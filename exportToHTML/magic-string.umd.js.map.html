<html>
<head>
<title>magic-string.umd.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
magic-string.umd.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;magic-string.umd.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/BitSet.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/Chunk.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/SourceMap.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/guessIndent.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/getRelativePath.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/isObject.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/getLocator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/Mappings.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/MagicString.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/Bundle.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/index-legacy.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export default class BitSet {</span><span class="s3">\n\t</span><span class="s1">constructor(arg) {</span><span class="s3">\n\t\t</span><span class="s1">this.bits = arg instanceof BitSet ? arg.bits.slice() : [];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">add(n) {</span><span class="s3">\n\t\t</span><span class="s1">this.bits[n &gt;&gt; 5] |= 1 &lt;&lt; (n &amp; 31);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">has(n) {</span><span class="s3">\n\t\t</span><span class="s1">return !!(this.bits[n &gt;&gt; 5] &amp; (1 &lt;&lt; (n &amp; 31)));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default class Chunk {</span><span class="s3">\n\t</span><span class="s1">constructor(start, end, content) {</span><span class="s3">\n\t\t</span><span class="s1">this.start = start;</span><span class="s3">\n\t\t</span><span class="s1">this.end = end;</span><span class="s3">\n\t\t</span><span class="s1">this.original = content;</span><span class="s3">\n\n\t\t</span><span class="s1">this.intro = '';</span><span class="s3">\n\t\t</span><span class="s1">this.outro = '';</span><span class="s3">\n\n\t\t</span><span class="s1">this.content = content;</span><span class="s3">\n\t\t</span><span class="s1">this.storeName = false;</span><span class="s3">\n\t\t</span><span class="s1">this.edited = false;</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) {</span><span class="s3">\n\t\t\t</span><span class="s1">// we make these non-enumerable, for sanity while debugging</span><span class="s3">\n\t\t\t</span><span class="s1">Object.defineProperties(this, {</span><span class="s3">\n\t\t\t\t</span><span class="s1">previous: { writable: true, value: null },</span><span class="s3">\n\t\t\t\t</span><span class="s1">next: { writable: true, value: null },</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.previous = null;</span><span class="s3">\n\t\t\t</span><span class="s1">this.next = null;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">appendLeft(content) {</span><span class="s3">\n\t\t</span><span class="s1">this.outro += content;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">appendRight(content) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = this.intro + content;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">clone() {</span><span class="s3">\n\t\t</span><span class="s1">const chunk = new Chunk(this.start, this.end, this.original);</span><span class="s3">\n\n\t\t</span><span class="s1">chunk.intro = this.intro;</span><span class="s3">\n\t\t</span><span class="s1">chunk.outro = this.outro;</span><span class="s3">\n\t\t</span><span class="s1">chunk.content = this.content;</span><span class="s3">\n\t\t</span><span class="s1">chunk.storeName = this.storeName;</span><span class="s3">\n\t\t</span><span class="s1">chunk.edited = this.edited;</span><span class="s3">\n\n\t\t</span><span class="s1">return chunk;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">contains(index) {</span><span class="s3">\n\t\t</span><span class="s1">return this.start &lt; index &amp;&amp; index &lt; this.end;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">eachNext(fn) {</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">fn(chunk);</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">eachPrevious(fn) {</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">fn(chunk);</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.previous;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">edit(content, storeName, contentOnly) {</span><span class="s3">\n\t\t</span><span class="s1">this.content = content;</span><span class="s3">\n\t\t</span><span class="s1">if (!contentOnly) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro = '';</span><span class="s3">\n\t\t\t</span><span class="s1">this.outro = '';</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">this.storeName = storeName;</span><span class="s3">\n\n\t\t</span><span class="s1">this.edited = true;</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prependLeft(content) {</span><span class="s3">\n\t\t</span><span class="s1">this.outro = content + this.outro;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prependRight(content) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = content + this.intro;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">reset() {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = '';</span><span class="s3">\n\t\t</span><span class="s1">this.outro = '';</span><span class="s3">\n\t\t</span><span class="s1">if (this.edited) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.content = this.original;</span><span class="s3">\n\t\t\t</span><span class="s1">this.storeName = false;</span><span class="s3">\n\t\t\t</span><span class="s1">this.edited = false;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">split(index) {</span><span class="s3">\n\t\t</span><span class="s1">const sliceIndex = index - this.start;</span><span class="s3">\n\n\t\t</span><span class="s1">const originalBefore = this.original.slice(0, sliceIndex);</span><span class="s3">\n\t\t</span><span class="s1">const originalAfter = this.original.slice(sliceIndex);</span><span class="s3">\n\n\t\t</span><span class="s1">this.original = originalBefore;</span><span class="s3">\n\n\t\t</span><span class="s1">const newChunk = new Chunk(index, this.end, originalAfter);</span><span class="s3">\n\t\t</span><span class="s1">newChunk.outro = this.outro;</span><span class="s3">\n\t\t</span><span class="s1">this.outro = '';</span><span class="s3">\n\n\t\t</span><span class="s1">this.end = index;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.edited) {</span><span class="s3">\n\t\t\t</span><span class="s1">// after split we should save the edit content record into the correct chunk</span><span class="s3">\n\t\t\t</span><span class="s1">// to make sure sourcemap correct</span><span class="s3">\n\t\t\t</span><span class="s1">// For example:</span><span class="s3">\n\t\t\t</span><span class="s1">// '  test'.trim()</span><span class="s3">\n\t\t\t</span><span class="s1">//     split   -&gt; '  ' + 'test'</span><span class="s3">\n\t\t\t</span><span class="s1">//   ✔️ edit    -&gt; '' + 'test'</span><span class="s3">\n\t\t\t</span><span class="s1">//   ✖️ edit    -&gt; 'test' + ''</span><span class="s3">\n\t\t\t</span><span class="s1">// TODO is this block necessary?...</span><span class="s3">\n\t\t\t</span><span class="s1">newChunk.edit('', false);</span><span class="s3">\n\t\t\t</span><span class="s1">this.content = '';</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.content = originalBefore;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">newChunk.next = this.next;</span><span class="s3">\n\t\t</span><span class="s1">if (newChunk.next) newChunk.next.previous = newChunk;</span><span class="s3">\n\t\t</span><span class="s1">newChunk.previous = this;</span><span class="s3">\n\t\t</span><span class="s1">this.next = newChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">return newChunk;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toString() {</span><span class="s3">\n\t\t</span><span class="s1">return this.intro + this.content + this.outro;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimEnd(rx) {</span><span class="s3">\n\t\t</span><span class="s1">this.outro = this.outro.replace(rx, '');</span><span class="s3">\n\t\t</span><span class="s1">if (this.outro.length) return true;</span><span class="s3">\n\n\t\t</span><span class="s1">const trimmed = this.content.replace(rx, '');</span><span class="s3">\n\n\t\t</span><span class="s1">if (trimmed.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (trimmed !== this.content) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.split(this.start + trimmed.length).edit('', undefined, true);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (this.edited) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">// save the change, if it has been edited</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">this.edit(trimmed, this.storeName, true);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">return true;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.edit('', undefined, true);</span><span class="s3">\n\n\t\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\t\t\t</span><span class="s1">if (this.intro.length) return true;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimStart(rx) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\t\t</span><span class="s1">if (this.intro.length) return true;</span><span class="s3">\n\n\t\t</span><span class="s1">const trimmed = this.content.replace(rx, '');</span><span class="s3">\n\n\t\t</span><span class="s1">if (trimmed.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (trimmed !== this.content) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const newChunk = this.split(this.end - trimmed.length);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (this.edited) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">// save the change, if it has been edited</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">newChunk.edit(trimmed, this.storeName, true);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.edit('', undefined, true);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">return true;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.edit('', undefined, true);</span><span class="s3">\n\n\t\t\t</span><span class="s1">this.outro = this.outro.replace(rx, '');</span><span class="s3">\n\t\t\t</span><span class="s1">if (this.outro.length) return true;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// src/vlq.ts</span><span class="s3">\n</span><span class="s1">var comma = </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">.charCodeAt(0);</span><span class="s3">\n</span><span class="s1">var semicolon = </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">.charCodeAt(0);</span><span class="s3">\n</span><span class="s1">var chars = </span><span class="s3">\&quot;</span><span class="s1">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var intToChar = new Uint8Array(64);</span><span class="s3">\n</span><span class="s1">var charToInt = new Uint8Array(128);</span><span class="s3">\n</span><span class="s1">for (let i = 0; i &lt; chars.length; i++) {</span><span class="s3">\n  </span><span class="s1">const c = chars.charCodeAt(i);</span><span class="s3">\n  </span><span class="s1">intToChar[i] = c;</span><span class="s3">\n  </span><span class="s1">charToInt[c] = i;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function decodeInteger(reader, relative) {</span><span class="s3">\n  </span><span class="s1">let value = 0;</span><span class="s3">\n  </span><span class="s1">let shift = 0;</span><span class="s3">\n  </span><span class="s1">let integer = 0;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const c = reader.next();</span><span class="s3">\n    </span><span class="s1">integer = charToInt[c];</span><span class="s3">\n    </span><span class="s1">value |= (integer &amp; 31) &lt;&lt; shift;</span><span class="s3">\n    </span><span class="s1">shift += 5;</span><span class="s3">\n  </span><span class="s1">} while (integer &amp; 32);</span><span class="s3">\n  </span><span class="s1">const shouldNegate = value &amp; 1;</span><span class="s3">\n  </span><span class="s1">value &gt;&gt;&gt;= 1;</span><span class="s3">\n  </span><span class="s1">if (shouldNegate) {</span><span class="s3">\n    </span><span class="s1">value = -2147483648 | -value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return relative + value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function encodeInteger(builder, num, relative) {</span><span class="s3">\n  </span><span class="s1">let delta = num - relative;</span><span class="s3">\n  </span><span class="s1">delta = delta &lt; 0 ? -delta &lt;&lt; 1 | 1 : delta &lt;&lt; 1;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">let clamped = delta &amp; 31;</span><span class="s3">\n    </span><span class="s1">delta &gt;&gt;&gt;= 5;</span><span class="s3">\n    </span><span class="s1">if (delta &gt; 0) clamped |= 32;</span><span class="s3">\n    </span><span class="s1">builder.write(intToChar[clamped]);</span><span class="s3">\n  </span><span class="s1">} while (delta &gt; 0);</span><span class="s3">\n  </span><span class="s1">return num;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasMoreVlq(reader, max) {</span><span class="s3">\n  </span><span class="s1">if (reader.pos &gt;= max) return false;</span><span class="s3">\n  </span><span class="s1">return reader.peek() !== comma;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// src/strings.ts</span><span class="s3">\n</span><span class="s1">var bufLength = 1024 * 16;</span><span class="s3">\n</span><span class="s1">var td = typeof TextDecoder !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? {</span><span class="s3">\n  </span><span class="s1">decode(buf) {</span><span class="s3">\n    </span><span class="s1">const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);</span><span class="s3">\n    </span><span class="s1">return out.toString();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">} : {</span><span class="s3">\n  </span><span class="s1">decode(buf) {</span><span class="s3">\n    </span><span class="s1">let out = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; buf.length; i++) {</span><span class="s3">\n      </span><span class="s1">out += String.fromCharCode(buf[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return out;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var StringWriter = class {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">this.pos = 0;</span><span class="s3">\n    </span><span class="s1">this.out = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">this.buffer = new Uint8Array(bufLength);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">write(v) {</span><span class="s3">\n    </span><span class="s1">const { buffer } = this;</span><span class="s3">\n    </span><span class="s1">buffer[this.pos++] = v;</span><span class="s3">\n    </span><span class="s1">if (this.pos === bufLength) {</span><span class="s3">\n      </span><span class="s1">this.out += td.decode(buffer);</span><span class="s3">\n      </span><span class="s1">this.pos = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">flush() {</span><span class="s3">\n    </span><span class="s1">const { buffer, out, pos } = this;</span><span class="s3">\n    </span><span class="s1">return pos &gt; 0 ? out + td.decode(buffer.subarray(0, pos)) : out;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var StringReader = class {</span><span class="s3">\n  </span><span class="s1">constructor(buffer) {</span><span class="s3">\n    </span><span class="s1">this.pos = 0;</span><span class="s3">\n    </span><span class="s1">this.buffer = buffer;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">next() {</span><span class="s3">\n    </span><span class="s1">return this.buffer.charCodeAt(this.pos++);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">peek() {</span><span class="s3">\n    </span><span class="s1">return this.buffer.charCodeAt(this.pos);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">indexOf(char) {</span><span class="s3">\n    </span><span class="s1">const { buffer, pos } = this;</span><span class="s3">\n    </span><span class="s1">const idx = buffer.indexOf(char, pos);</span><span class="s3">\n    </span><span class="s1">return idx === -1 ? buffer.length : idx;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/scopes.ts</span><span class="s3">\n</span><span class="s1">var EMPTY = [];</span><span class="s3">\n</span><span class="s1">function decodeOriginalScopes(input) {</span><span class="s3">\n  </span><span class="s1">const { length } = input;</span><span class="s3">\n  </span><span class="s1">const reader = new StringReader(input);</span><span class="s3">\n  </span><span class="s1">const scopes = [];</span><span class="s3">\n  </span><span class="s1">const stack = [];</span><span class="s3">\n  </span><span class="s1">let line = 0;</span><span class="s3">\n  </span><span class="s1">for (; reader.pos &lt; length; reader.pos++) {</span><span class="s3">\n    </span><span class="s1">line = decodeInteger(reader, line);</span><span class="s3">\n    </span><span class="s1">const column = decodeInteger(reader, 0);</span><span class="s3">\n    </span><span class="s1">if (!hasMoreVlq(reader, length)) {</span><span class="s3">\n      </span><span class="s1">const last = stack.pop();</span><span class="s3">\n      </span><span class="s1">last[2] = line;</span><span class="s3">\n      </span><span class="s1">last[3] = column;</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const kind = decodeInteger(reader, 0);</span><span class="s3">\n    </span><span class="s1">const fields = decodeInteger(reader, 0);</span><span class="s3">\n    </span><span class="s1">const hasName = fields &amp; 1;</span><span class="s3">\n    </span><span class="s1">const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];</span><span class="s3">\n    </span><span class="s1">let vars = EMPTY;</span><span class="s3">\n    </span><span class="s1">if (hasMoreVlq(reader, length)) {</span><span class="s3">\n      </span><span class="s1">vars = [];</span><span class="s3">\n      </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">const varsIndex = decodeInteger(reader, 0);</span><span class="s3">\n        </span><span class="s1">vars.push(varsIndex);</span><span class="s3">\n      </span><span class="s1">} while (hasMoreVlq(reader, length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scope.vars = vars;</span><span class="s3">\n    </span><span class="s1">scopes.push(scope);</span><span class="s3">\n    </span><span class="s1">stack.push(scope);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return scopes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function encodeOriginalScopes(scopes) {</span><span class="s3">\n  </span><span class="s1">const writer = new StringWriter();</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; scopes.length; ) {</span><span class="s3">\n    </span><span class="s1">i = _encodeOriginalScopes(scopes, i, writer, [0]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return writer.flush();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _encodeOriginalScopes(scopes, index, writer, state) {</span><span class="s3">\n  </span><span class="s1">const scope = scopes[index];</span><span class="s3">\n  </span><span class="s1">const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;</span><span class="s3">\n  </span><span class="s1">if (index &gt; 0) writer.write(comma);</span><span class="s3">\n  </span><span class="s1">state[0] = encodeInteger(writer, startLine, state[0]);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, startColumn, 0);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, kind, 0);</span><span class="s3">\n  </span><span class="s1">const fields = scope.length === 6 ? 1 : 0;</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, fields, 0);</span><span class="s3">\n  </span><span class="s1">if (scope.length === 6) encodeInteger(writer, scope[5], 0);</span><span class="s3">\n  </span><span class="s1">for (const v of vars) {</span><span class="s3">\n    </span><span class="s1">encodeInteger(writer, v, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (index++; index &lt; scopes.length; ) {</span><span class="s3">\n    </span><span class="s1">const next = scopes[index];</span><span class="s3">\n    </span><span class="s1">const { 0: l, 1: c } = next;</span><span class="s3">\n    </span><span class="s1">if (l &gt; endLine || l === endLine &amp;&amp; c &gt;= endColumn) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">index = _encodeOriginalScopes(scopes, index, writer, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">writer.write(comma);</span><span class="s3">\n  </span><span class="s1">state[0] = encodeInteger(writer, endLine, state[0]);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, endColumn, 0);</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function decodeGeneratedRanges(input) {</span><span class="s3">\n  </span><span class="s1">const { length } = input;</span><span class="s3">\n  </span><span class="s1">const reader = new StringReader(input);</span><span class="s3">\n  </span><span class="s1">const ranges = [];</span><span class="s3">\n  </span><span class="s1">const stack = [];</span><span class="s3">\n  </span><span class="s1">let genLine = 0;</span><span class="s3">\n  </span><span class="s1">let definitionSourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let definitionScopeIndex = 0;</span><span class="s3">\n  </span><span class="s1">let callsiteSourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let callsiteLine = 0;</span><span class="s3">\n  </span><span class="s1">let callsiteColumn = 0;</span><span class="s3">\n  </span><span class="s1">let bindingLine = 0;</span><span class="s3">\n  </span><span class="s1">let bindingColumn = 0;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const semi = reader.indexOf(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let genColumn = 0;</span><span class="s3">\n    </span><span class="s1">for (; reader.pos &lt; semi; reader.pos++) {</span><span class="s3">\n      </span><span class="s1">genColumn = decodeInteger(reader, genColumn);</span><span class="s3">\n      </span><span class="s1">if (!hasMoreVlq(reader, semi)) {</span><span class="s3">\n        </span><span class="s1">const last = stack.pop();</span><span class="s3">\n        </span><span class="s1">last[2] = genLine;</span><span class="s3">\n        </span><span class="s1">last[3] = genColumn;</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const fields = decodeInteger(reader, 0);</span><span class="s3">\n      </span><span class="s1">const hasDefinition = fields &amp; 1;</span><span class="s3">\n      </span><span class="s1">const hasCallsite = fields &amp; 2;</span><span class="s3">\n      </span><span class="s1">const hasScope = fields &amp; 4;</span><span class="s3">\n      </span><span class="s1">let callsite = null;</span><span class="s3">\n      </span><span class="s1">let bindings = EMPTY;</span><span class="s3">\n      </span><span class="s1">let range;</span><span class="s3">\n      </span><span class="s1">if (hasDefinition) {</span><span class="s3">\n        </span><span class="s1">const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);</span><span class="s3">\n        </span><span class="s1">definitionScopeIndex = decodeInteger(</span><span class="s3">\n          </span><span class="s1">reader,</span><span class="s3">\n          </span><span class="s1">definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">definitionSourcesIndex = defSourcesIndex;</span><span class="s3">\n        </span><span class="s1">range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">range = [genLine, genColumn, 0, 0];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">range.isScope = !!hasScope;</span><span class="s3">\n      </span><span class="s1">if (hasCallsite) {</span><span class="s3">\n        </span><span class="s1">const prevCsi = callsiteSourcesIndex;</span><span class="s3">\n        </span><span class="s1">const prevLine = callsiteLine;</span><span class="s3">\n        </span><span class="s1">callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);</span><span class="s3">\n        </span><span class="s1">const sameSource = prevCsi === callsiteSourcesIndex;</span><span class="s3">\n        </span><span class="s1">callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);</span><span class="s3">\n        </span><span class="s1">callsiteColumn = decodeInteger(</span><span class="s3">\n          </span><span class="s1">reader,</span><span class="s3">\n          </span><span class="s1">sameSource &amp;&amp; prevLine === callsiteLine ? callsiteColumn : 0</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">range.callsite = callsite;</span><span class="s3">\n      </span><span class="s1">if (hasMoreVlq(reader, semi)) {</span><span class="s3">\n        </span><span class="s1">bindings = [];</span><span class="s3">\n        </span><span class="s1">do {</span><span class="s3">\n          </span><span class="s1">bindingLine = genLine;</span><span class="s3">\n          </span><span class="s1">bindingColumn = genColumn;</span><span class="s3">\n          </span><span class="s1">const expressionsCount = decodeInteger(reader, 0);</span><span class="s3">\n          </span><span class="s1">let expressionRanges;</span><span class="s3">\n          </span><span class="s1">if (expressionsCount &lt; -1) {</span><span class="s3">\n            </span><span class="s1">expressionRanges = [[decodeInteger(reader, 0)]];</span><span class="s3">\n            </span><span class="s1">for (let i = -1; i &gt; expressionsCount; i--) {</span><span class="s3">\n              </span><span class="s1">const prevBl = bindingLine;</span><span class="s3">\n              </span><span class="s1">bindingLine = decodeInteger(reader, bindingLine);</span><span class="s3">\n              </span><span class="s1">bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);</span><span class="s3">\n              </span><span class="s1">const expression = decodeInteger(reader, 0);</span><span class="s3">\n              </span><span class="s1">expressionRanges.push([expression, bindingLine, bindingColumn]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">expressionRanges = [[expressionsCount]];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">bindings.push(expressionRanges);</span><span class="s3">\n        </span><span class="s1">} while (hasMoreVlq(reader, semi));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">range.bindings = bindings;</span><span class="s3">\n      </span><span class="s1">ranges.push(range);</span><span class="s3">\n      </span><span class="s1">stack.push(range);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">genLine++;</span><span class="s3">\n    </span><span class="s1">reader.pos = semi + 1;</span><span class="s3">\n  </span><span class="s1">} while (reader.pos &lt; length);</span><span class="s3">\n  </span><span class="s1">return ranges;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function encodeGeneratedRanges(ranges) {</span><span class="s3">\n  </span><span class="s1">if (ranges.length === 0) return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">const writer = new StringWriter();</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; ranges.length; ) {</span><span class="s3">\n    </span><span class="s1">i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return writer.flush();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _encodeGeneratedRanges(ranges, index, writer, state) {</span><span class="s3">\n  </span><span class="s1">const range = ranges[index];</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">0: startLine,</span><span class="s3">\n    </span><span class="s1">1: startColumn,</span><span class="s3">\n    </span><span class="s1">2: endLine,</span><span class="s3">\n    </span><span class="s1">3: endColumn,</span><span class="s3">\n    </span><span class="s1">isScope,</span><span class="s3">\n    </span><span class="s1">callsite,</span><span class="s3">\n    </span><span class="s1">bindings</span><span class="s3">\n  </span><span class="s1">} = range;</span><span class="s3">\n  </span><span class="s1">if (state[0] &lt; startLine) {</span><span class="s3">\n    </span><span class="s1">catchupLine(writer, state[0], startLine);</span><span class="s3">\n    </span><span class="s1">state[0] = startLine;</span><span class="s3">\n    </span><span class="s1">state[1] = 0;</span><span class="s3">\n  </span><span class="s1">} else if (index &gt; 0) {</span><span class="s3">\n    </span><span class="s1">writer.write(comma);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state[1] = encodeInteger(writer, range[1], state[1]);</span><span class="s3">\n  </span><span class="s1">const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, fields, 0);</span><span class="s3">\n  </span><span class="s1">if (range.length === 6) {</span><span class="s3">\n    </span><span class="s1">const { 4: sourcesIndex, 5: scopesIndex } = range;</span><span class="s3">\n    </span><span class="s1">if (sourcesIndex !== state[2]) {</span><span class="s3">\n      </span><span class="s1">state[3] = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state[2] = encodeInteger(writer, sourcesIndex, state[2]);</span><span class="s3">\n    </span><span class="s1">state[3] = encodeInteger(writer, scopesIndex, state[3]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (callsite) {</span><span class="s3">\n    </span><span class="s1">const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;</span><span class="s3">\n    </span><span class="s1">if (sourcesIndex !== state[4]) {</span><span class="s3">\n      </span><span class="s1">state[5] = 0;</span><span class="s3">\n      </span><span class="s1">state[6] = 0;</span><span class="s3">\n    </span><span class="s1">} else if (callLine !== state[5]) {</span><span class="s3">\n      </span><span class="s1">state[6] = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state[4] = encodeInteger(writer, sourcesIndex, state[4]);</span><span class="s3">\n    </span><span class="s1">state[5] = encodeInteger(writer, callLine, state[5]);</span><span class="s3">\n    </span><span class="s1">state[6] = encodeInteger(writer, callColumn, state[6]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (bindings) {</span><span class="s3">\n    </span><span class="s1">for (const binding of bindings) {</span><span class="s3">\n      </span><span class="s1">if (binding.length &gt; 1) encodeInteger(writer, -binding.length, 0);</span><span class="s3">\n      </span><span class="s1">const expression = binding[0][0];</span><span class="s3">\n      </span><span class="s1">encodeInteger(writer, expression, 0);</span><span class="s3">\n      </span><span class="s1">let bindingStartLine = startLine;</span><span class="s3">\n      </span><span class="s1">let bindingStartColumn = startColumn;</span><span class="s3">\n      </span><span class="s1">for (let i = 1; i &lt; binding.length; i++) {</span><span class="s3">\n        </span><span class="s1">const expRange = binding[i];</span><span class="s3">\n        </span><span class="s1">bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);</span><span class="s3">\n        </span><span class="s1">bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);</span><span class="s3">\n        </span><span class="s1">encodeInteger(writer, expRange[0], 0);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (index++; index &lt; ranges.length; ) {</span><span class="s3">\n    </span><span class="s1">const next = ranges[index];</span><span class="s3">\n    </span><span class="s1">const { 0: l, 1: c } = next;</span><span class="s3">\n    </span><span class="s1">if (l &gt; endLine || l === endLine &amp;&amp; c &gt;= endColumn) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">index = _encodeGeneratedRanges(ranges, index, writer, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (state[0] &lt; endLine) {</span><span class="s3">\n    </span><span class="s1">catchupLine(writer, state[0], endLine);</span><span class="s3">\n    </span><span class="s1">state[0] = endLine;</span><span class="s3">\n    </span><span class="s1">state[1] = 0;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">writer.write(comma);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state[1] = encodeInteger(writer, endColumn, state[1]);</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function catchupLine(writer, lastLine, line) {</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">writer.write(semicolon);</span><span class="s3">\n  </span><span class="s1">} while (++lastLine &lt; line);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// src/sourcemap-codec.ts</span><span class="s3">\n</span><span class="s1">function decode(mappings) {</span><span class="s3">\n  </span><span class="s1">const { length } = mappings;</span><span class="s3">\n  </span><span class="s1">const reader = new StringReader(mappings);</span><span class="s3">\n  </span><span class="s1">const decoded = [];</span><span class="s3">\n  </span><span class="s1">let genColumn = 0;</span><span class="s3">\n  </span><span class="s1">let sourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let sourceLine = 0;</span><span class="s3">\n  </span><span class="s1">let sourceColumn = 0;</span><span class="s3">\n  </span><span class="s1">let namesIndex = 0;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const semi = reader.indexOf(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const line = [];</span><span class="s3">\n    </span><span class="s1">let sorted = true;</span><span class="s3">\n    </span><span class="s1">let lastCol = 0;</span><span class="s3">\n    </span><span class="s1">genColumn = 0;</span><span class="s3">\n    </span><span class="s1">while (reader.pos &lt; semi) {</span><span class="s3">\n      </span><span class="s1">let seg;</span><span class="s3">\n      </span><span class="s1">genColumn = decodeInteger(reader, genColumn);</span><span class="s3">\n      </span><span class="s1">if (genColumn &lt; lastCol) sorted = false;</span><span class="s3">\n      </span><span class="s1">lastCol = genColumn;</span><span class="s3">\n      </span><span class="s1">if (hasMoreVlq(reader, semi)) {</span><span class="s3">\n        </span><span class="s1">sourcesIndex = decodeInteger(reader, sourcesIndex);</span><span class="s3">\n        </span><span class="s1">sourceLine = decodeInteger(reader, sourceLine);</span><span class="s3">\n        </span><span class="s1">sourceColumn = decodeInteger(reader, sourceColumn);</span><span class="s3">\n        </span><span class="s1">if (hasMoreVlq(reader, semi)) {</span><span class="s3">\n          </span><span class="s1">namesIndex = decodeInteger(reader, namesIndex);</span><span class="s3">\n          </span><span class="s1">seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">seg = [genColumn];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">line.push(seg);</span><span class="s3">\n      </span><span class="s1">reader.pos++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!sorted) sort(line);</span><span class="s3">\n    </span><span class="s1">decoded.push(line);</span><span class="s3">\n    </span><span class="s1">reader.pos = semi + 1;</span><span class="s3">\n  </span><span class="s1">} while (reader.pos &lt;= length);</span><span class="s3">\n  </span><span class="s1">return decoded;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sort(line) {</span><span class="s3">\n  </span><span class="s1">line.sort(sortComparator);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sortComparator(a, b) {</span><span class="s3">\n  </span><span class="s1">return a[0] - b[0];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function encode(decoded) {</span><span class="s3">\n  </span><span class="s1">const writer = new StringWriter();</span><span class="s3">\n  </span><span class="s1">let sourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let sourceLine = 0;</span><span class="s3">\n  </span><span class="s1">let sourceColumn = 0;</span><span class="s3">\n  </span><span class="s1">let namesIndex = 0;</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; decoded.length; i++) {</span><span class="s3">\n    </span><span class="s1">const line = decoded[i];</span><span class="s3">\n    </span><span class="s1">if (i &gt; 0) writer.write(semicolon);</span><span class="s3">\n    </span><span class="s1">if (line.length === 0) continue;</span><span class="s3">\n    </span><span class="s1">let genColumn = 0;</span><span class="s3">\n    </span><span class="s1">for (let j = 0; j &lt; line.length; j++) {</span><span class="s3">\n      </span><span class="s1">const segment = line[j];</span><span class="s3">\n      </span><span class="s1">if (j &gt; 0) writer.write(comma);</span><span class="s3">\n      </span><span class="s1">genColumn = encodeInteger(writer, segment[0], genColumn);</span><span class="s3">\n      </span><span class="s1">if (segment.length === 1) continue;</span><span class="s3">\n      </span><span class="s1">sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);</span><span class="s3">\n      </span><span class="s1">sourceLine = encodeInteger(writer, segment[2], sourceLine);</span><span class="s3">\n      </span><span class="s1">sourceColumn = encodeInteger(writer, segment[3], sourceColumn);</span><span class="s3">\n      </span><span class="s1">if (segment.length === 4) continue;</span><span class="s3">\n      </span><span class="s1">namesIndex = encodeInteger(writer, segment[4], namesIndex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return writer.flush();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">decode,</span><span class="s3">\n  </span><span class="s1">decodeGeneratedRanges,</span><span class="s3">\n  </span><span class="s1">decodeOriginalScopes,</span><span class="s3">\n  </span><span class="s1">encode,</span><span class="s3">\n  </span><span class="s1">encodeGeneratedRanges,</span><span class="s3">\n  </span><span class="s1">encodeOriginalScopes</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=sourcemap-codec.mjs.map</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { encode } from '@jridgewell/sourcemap-codec';</span><span class="s3">\n\n</span><span class="s1">function getBtoa() {</span><span class="s3">\n\t</span><span class="s1">if (typeof globalThis !== 'undefined' &amp;&amp; typeof globalThis.btoa === 'function') {</span><span class="s3">\n\t\t</span><span class="s1">return (str) =&gt; globalThis.btoa(unescape(encodeURIComponent(str)));</span><span class="s3">\n\t</span><span class="s1">} else if (typeof Buffer === 'function') {</span><span class="s3">\n\t\t</span><span class="s1">return (str) =&gt; Buffer.from(str, 'utf-8').toString('base64');</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">return () =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');</span><span class="s3">\n\t\t</span><span class="s1">};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const btoa = /*#__PURE__*/ getBtoa();</span><span class="s3">\n\n</span><span class="s1">export default class SourceMap {</span><span class="s3">\n\t</span><span class="s1">constructor(properties) {</span><span class="s3">\n\t\t</span><span class="s1">this.version = 3;</span><span class="s3">\n\t\t</span><span class="s1">this.file = properties.file;</span><span class="s3">\n\t\t</span><span class="s1">this.sources = properties.sources;</span><span class="s3">\n\t\t</span><span class="s1">this.sourcesContent = properties.sourcesContent;</span><span class="s3">\n\t\t</span><span class="s1">this.names = properties.names;</span><span class="s3">\n\t\t</span><span class="s1">this.mappings = encode(properties.mappings);</span><span class="s3">\n\t\t</span><span class="s1">if (typeof properties.x_google_ignoreList !== 'undefined') {</span><span class="s3">\n\t\t\t</span><span class="s1">this.x_google_ignoreList = properties.x_google_ignoreList;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">if (typeof properties.debugId !== 'undefined') {</span><span class="s3">\n\t\t\t</span><span class="s1">this.debugId = properties.debugId;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toString() {</span><span class="s3">\n\t\t</span><span class="s1">return JSON.stringify(this);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toUrl() {</span><span class="s3">\n\t\t</span><span class="s1">return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function guessIndent(code) {</span><span class="s3">\n\t</span><span class="s1">const lines = code.split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n\n\t</span><span class="s1">const tabbed = lines.filter((line) =&gt; /^</span><span class="s3">\\</span><span class="s1">t+/.test(line));</span><span class="s3">\n\t</span><span class="s1">const spaced = lines.filter((line) =&gt; /^ {2,}/.test(line));</span><span class="s3">\n\n\t</span><span class="s1">if (tabbed.length === 0 &amp;&amp; spaced.length === 0) {</span><span class="s3">\n\t\t</span><span class="s1">return null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// More lines tabbed than spaced? Assume tabs, and</span><span class="s3">\n\t</span><span class="s1">// default to tabs in the case of a tie (or nothing</span><span class="s3">\n\t</span><span class="s1">// to go on)</span><span class="s3">\n\t</span><span class="s1">if (tabbed.length &gt;= spaced.length) {</span><span class="s3">\n\t\t</span><span class="s1">return '</span><span class="s3">\\</span><span class="s1">t';</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Otherwise, we need to guess the multiple</span><span class="s3">\n\t</span><span class="s1">const min = spaced.reduce((previous, current) =&gt; {</span><span class="s3">\n\t\t</span><span class="s1">const numSpaces = /^ +/.exec(current)[0].length;</span><span class="s3">\n\t\t</span><span class="s1">return Math.min(numSpaces, previous);</span><span class="s3">\n\t</span><span class="s1">}, Infinity);</span><span class="s3">\n\n\t</span><span class="s1">return new Array(min + 1).join(' ');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function getRelativePath(from, to) {</span><span class="s3">\n\t</span><span class="s1">const fromParts = from.split(/[/</span><span class="s3">\\\\</span><span class="s1">]/);</span><span class="s3">\n\t</span><span class="s1">const toParts = to.split(/[/</span><span class="s3">\\\\</span><span class="s1">]/);</span><span class="s3">\n\n\t</span><span class="s1">fromParts.pop(); // get dirname</span><span class="s3">\n\n\t</span><span class="s1">while (fromParts[0] === toParts[0]) {</span><span class="s3">\n\t\t</span><span class="s1">fromParts.shift();</span><span class="s3">\n\t\t</span><span class="s1">toParts.shift();</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (fromParts.length) {</span><span class="s3">\n\t\t</span><span class="s1">let i = fromParts.length;</span><span class="s3">\n\t\t</span><span class="s1">while (i--) fromParts[i] = '..';</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return fromParts.concat(toParts).join('/');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const toString = Object.prototype.toString;</span><span class="s3">\n\n</span><span class="s1">export default function isObject(thing) {</span><span class="s3">\n\t</span><span class="s1">return toString.call(thing) === '[object Object]';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function getLocator(source) {</span><span class="s3">\n\t</span><span class="s1">const originalLines = source.split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n\t</span><span class="s1">const lineOffsets = [];</span><span class="s3">\n\n\t</span><span class="s1">for (let i = 0, pos = 0; i &lt; originalLines.length; i++) {</span><span class="s3">\n\t\t</span><span class="s1">lineOffsets.push(pos);</span><span class="s3">\n\t\t</span><span class="s1">pos += originalLines[i].length + 1;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return function locate(index) {</span><span class="s3">\n\t\t</span><span class="s1">let i = 0;</span><span class="s3">\n\t\t</span><span class="s1">let j = lineOffsets.length;</span><span class="s3">\n\t\t</span><span class="s1">while (i &lt; j) {</span><span class="s3">\n\t\t\t</span><span class="s1">const m = (i + j) &gt;&gt; 1;</span><span class="s3">\n\t\t\t</span><span class="s1">if (index &lt; lineOffsets[m]) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">j = m;</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">i = m + 1;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">const line = i - 1;</span><span class="s3">\n\t\t</span><span class="s1">const column = index - lineOffsets[line];</span><span class="s3">\n\t\t</span><span class="s1">return { line, column };</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const wordRegex = /</span><span class="s3">\\</span><span class="s1">w/;</span><span class="s3">\n\n</span><span class="s1">export default class Mappings {</span><span class="s3">\n\t</span><span class="s1">constructor(hires) {</span><span class="s3">\n\t\t</span><span class="s1">this.hires = hires;</span><span class="s3">\n\t\t</span><span class="s1">this.generatedCodeLine = 0;</span><span class="s3">\n\t\t</span><span class="s1">this.generatedCodeColumn = 0;</span><span class="s3">\n\t\t</span><span class="s1">this.raw = [];</span><span class="s3">\n\t\t</span><span class="s1">this.rawSegments = this.raw[this.generatedCodeLine] = [];</span><span class="s3">\n\t\t</span><span class="s1">this.pending = null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">addEdit(sourceIndex, content, loc, nameIndex) {</span><span class="s3">\n\t\t</span><span class="s1">if (content.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">const contentLengthMinusOne = content.length - 1;</span><span class="s3">\n\t\t\t</span><span class="s1">let contentLineEnd = content.indexOf('</span><span class="s3">\\</span><span class="s1">n', 0);</span><span class="s3">\n\t\t\t</span><span class="s1">let previousContentLineEnd = -1;</span><span class="s3">\n\t\t\t</span><span class="s1">// Loop through each line in the content and add a segment, but stop if the last line is empty,</span><span class="s3">\n\t\t\t</span><span class="s1">// else code afterwards would fill one line too many</span><span class="s3">\n\t\t\t</span><span class="s1">while (contentLineEnd &gt;= 0 &amp;&amp; contentLengthMinusOne &gt; contentLineEnd) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (nameIndex &gt;= 0) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">segment.push(nameIndex);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">this.generatedCodeLine += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.raw[this.generatedCodeLine] = this.rawSegments = [];</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeColumn = 0;</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">previousContentLineEnd = contentLineEnd;</span><span class="s3">\n\t\t\t\t</span><span class="s1">contentLineEnd = content.indexOf('</span><span class="s3">\\</span><span class="s1">n', contentLineEnd + 1);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];</span><span class="s3">\n\t\t\t</span><span class="s1">if (nameIndex &gt;= 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">segment.push(nameIndex);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\n\t\t\t</span><span class="s1">this.advance(content.slice(previousContentLineEnd + 1));</span><span class="s3">\n\t\t</span><span class="s1">} else if (this.pending) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.rawSegments.push(this.pending);</span><span class="s3">\n\t\t\t</span><span class="s1">this.advance(content);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.pending = null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {</span><span class="s3">\n\t\t</span><span class="s1">let originalCharIndex = chunk.start;</span><span class="s3">\n\t\t</span><span class="s1">let first = true;</span><span class="s3">\n\t\t</span><span class="s1">// when iterating each char, check if it's in a word boundary</span><span class="s3">\n\t\t</span><span class="s1">let charInHiresBoundary = false;</span><span class="s3">\n\n\t\t</span><span class="s1">while (originalCharIndex &lt; chunk.end) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (original[originalCharIndex] === '</span><span class="s3">\\</span><span class="s1">n') {</span><span class="s3">\n\t\t\t\t</span><span class="s1">loc.line += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">loc.column = 0;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeLine += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.raw[this.generatedCodeLine] = this.rawSegments = [];</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeColumn = 0;</span><span class="s3">\n\t\t\t\t</span><span class="s1">first = true;</span><span class="s3">\n\t\t\t\t</span><span class="s1">charInHiresBoundary = false;</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];</span><span class="s3">\n\n\t\t\t\t\t</span><span class="s1">if (this.hires === 'boundary') {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">// in hires </span><span class="s3">\&quot;</span><span class="s1">boundary</span><span class="s3">\&quot;</span><span class="s1">, group segments per word boundary than per char</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">if (wordRegex.test(original[originalCharIndex])) {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">// for first char in the boundary found, start the boundary by pushing a segment</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">if (!charInHiresBoundary) {</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">charInHiresBoundary = true;</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">// for non-word char, end the boundary by pushing a segment</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">charInHiresBoundary = false;</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">loc.column += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeColumn += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">first = false;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">originalCharIndex += 1;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.pending = null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">advance(str) {</span><span class="s3">\n\t\t</span><span class="s1">if (!str) return;</span><span class="s3">\n\n\t\t</span><span class="s1">const lines = str.split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n\n\t\t</span><span class="s1">if (lines.length &gt; 1) {</span><span class="s3">\n\t\t\t</span><span class="s1">for (let i = 0; i &lt; lines.length - 1; i++) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeLine++;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.raw[this.generatedCodeLine] = this.rawSegments = [];</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">this.generatedCodeColumn = 0;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.generatedCodeColumn += lines[lines.length - 1].length;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import BitSet from './BitSet.js';</span><span class="s3">\n</span><span class="s1">import Chunk from './Chunk.js';</span><span class="s3">\n</span><span class="s1">import SourceMap from './SourceMap.js';</span><span class="s3">\n</span><span class="s1">import guessIndent from './utils/guessIndent.js';</span><span class="s3">\n</span><span class="s1">import getRelativePath from './utils/getRelativePath.js';</span><span class="s3">\n</span><span class="s1">import isObject from './utils/isObject.js';</span><span class="s3">\n</span><span class="s1">import getLocator from './utils/getLocator.js';</span><span class="s3">\n</span><span class="s1">import Mappings from './utils/Mappings.js';</span><span class="s3">\n</span><span class="s1">import Stats from './utils/Stats.js';</span><span class="s3">\n\n</span><span class="s1">const n = '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\n</span><span class="s1">const warned = {</span><span class="s3">\n\t</span><span class="s1">insertLeft: false,</span><span class="s3">\n\t</span><span class="s1">insertRight: false,</span><span class="s3">\n\t</span><span class="s1">storeName: false,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default class MagicString {</span><span class="s3">\n\t</span><span class="s1">constructor(string, options = {}) {</span><span class="s3">\n\t\t</span><span class="s1">const chunk = new Chunk(0, string.length, string);</span><span class="s3">\n\n\t\t</span><span class="s1">Object.defineProperties(this, {</span><span class="s3">\n\t\t\t</span><span class="s1">original: { writable: true, value: string },</span><span class="s3">\n\t\t\t</span><span class="s1">outro: { writable: true, value: '' },</span><span class="s3">\n\t\t\t</span><span class="s1">intro: { writable: true, value: '' },</span><span class="s3">\n\t\t\t</span><span class="s1">firstChunk: { writable: true, value: chunk },</span><span class="s3">\n\t\t\t</span><span class="s1">lastChunk: { writable: true, value: chunk },</span><span class="s3">\n\t\t\t</span><span class="s1">lastSearchedChunk: { writable: true, value: chunk },</span><span class="s3">\n\t\t\t</span><span class="s1">byStart: { writable: true, value: {} },</span><span class="s3">\n\t\t\t</span><span class="s1">byEnd: { writable: true, value: {} },</span><span class="s3">\n\t\t\t</span><span class="s1">filename: { writable: true, value: options.filename },</span><span class="s3">\n\t\t\t</span><span class="s1">indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },</span><span class="s3">\n\t\t\t</span><span class="s1">sourcemapLocations: { writable: true, value: new BitSet() },</span><span class="s3">\n\t\t\t</span><span class="s1">storedNames: { writable: true, value: {} },</span><span class="s3">\n\t\t\t</span><span class="s1">indentStr: { writable: true, value: undefined },</span><span class="s3">\n\t\t\t</span><span class="s1">ignoreList: { writable: true, value: options.ignoreList },</span><span class="s3">\n\t\t\t</span><span class="s1">offset: { writable: true, value: options.offset || 0 },</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) {</span><span class="s3">\n\t\t\t</span><span class="s1">Object.defineProperty(this, 'stats', { value: new Stats() });</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.byStart[0] = chunk;</span><span class="s3">\n\t\t</span><span class="s1">this.byEnd[string.length] = chunk;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">addSourcemapLocation(char) {</span><span class="s3">\n\t\t</span><span class="s1">this.sourcemapLocations.add(char);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">append(content) {</span><span class="s3">\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('outro content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">this.outro += content;</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">appendLeft(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('inserted content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('appendLeft');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const chunk = this.byEnd[index];</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.appendLeft(content);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro += content;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('appendLeft');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">appendRight(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('inserted content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('appendRight');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const chunk = this.byStart[index];</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.appendRight(content);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.outro += content;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('appendRight');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">clone() {</span><span class="s3">\n\t\t</span><span class="s1">const cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });</span><span class="s3">\n\n\t\t</span><span class="s1">let originalChunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());</span><span class="s3">\n\n\t\t</span><span class="s1">while (originalChunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">cloned.byStart[clonedChunk.start] = clonedChunk;</span><span class="s3">\n\t\t\t</span><span class="s1">cloned.byEnd[clonedChunk.end] = clonedChunk;</span><span class="s3">\n\n\t\t\t</span><span class="s1">const nextOriginalChunk = originalChunk.next;</span><span class="s3">\n\t\t\t</span><span class="s1">const nextClonedChunk = nextOriginalChunk &amp;&amp; nextOriginalChunk.clone();</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (nextClonedChunk) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">clonedChunk.next = nextClonedChunk;</span><span class="s3">\n\t\t\t\t</span><span class="s1">nextClonedChunk.previous = clonedChunk;</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">clonedChunk = nextClonedChunk;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">originalChunk = nextOriginalChunk;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">cloned.lastChunk = clonedChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.indentExclusionRanges) {</span><span class="s3">\n\t\t\t</span><span class="s1">cloned.indentExclusionRanges = this.indentExclusionRanges.slice();</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);</span><span class="s3">\n\n\t\t</span><span class="s1">cloned.intro = this.intro;</span><span class="s3">\n\t\t</span><span class="s1">cloned.outro = this.outro;</span><span class="s3">\n\n\t\t</span><span class="s1">return cloned;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">generateDecodedMap(options) {</span><span class="s3">\n\t\t</span><span class="s1">options = options || {};</span><span class="s3">\n\n\t\t</span><span class="s1">const sourceIndex = 0;</span><span class="s3">\n\t\t</span><span class="s1">const names = Object.keys(this.storedNames);</span><span class="s3">\n\t\t</span><span class="s1">const mappings = new Mappings(options.hires);</span><span class="s3">\n\n\t\t</span><span class="s1">const locate = getLocator(this.original);</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.intro) {</span><span class="s3">\n\t\t\t</span><span class="s1">mappings.advance(this.intro);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.firstChunk.eachNext((chunk) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">const loc = locate(chunk.start);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.intro.length) mappings.advance(chunk.intro);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.edited) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.addEdit(</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">sourceIndex,</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">chunk.content,</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">loc,</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">chunk.storeName ? names.indexOf(chunk.original) : -1,</span><span class="s3">\n\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.outro.length) mappings.advance(chunk.outro);</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.outro) {</span><span class="s3">\n\t\t\t</span><span class="s1">mappings.advance(this.outro);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return {</span><span class="s3">\n\t\t\t</span><span class="s1">file: options.file ? options.file.split(/[/</span><span class="s3">\\\\</span><span class="s1">]/).pop() : undefined,</span><span class="s3">\n\t\t\t</span><span class="s1">sources: [</span><span class="s3">\n\t\t\t\t</span><span class="s1">options.source ? getRelativePath(options.file || '', options.source) : options.file || '',</span><span class="s3">\n\t\t\t</span><span class="s1">],</span><span class="s3">\n\t\t\t</span><span class="s1">sourcesContent: options.includeContent ? [this.original] : undefined,</span><span class="s3">\n\t\t\t</span><span class="s1">names,</span><span class="s3">\n\t\t\t</span><span class="s1">mappings: mappings.raw,</span><span class="s3">\n\t\t\t</span><span class="s1">x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,</span><span class="s3">\n\t\t</span><span class="s1">};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">generateMap(options) {</span><span class="s3">\n\t\t</span><span class="s1">return new SourceMap(this.generateDecodedMap(options));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_ensureindentStr() {</span><span class="s3">\n\t\t</span><span class="s1">if (this.indentStr === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.indentStr = guessIndent(this.original);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_getRawIndentString() {</span><span class="s3">\n\t\t</span><span class="s1">this._ensureindentStr();</span><span class="s3">\n\t\t</span><span class="s1">return this.indentStr;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">getIndentString() {</span><span class="s3">\n\t\t</span><span class="s1">this._ensureindentStr();</span><span class="s3">\n\t\t</span><span class="s1">return this.indentStr === null ? '</span><span class="s3">\\</span><span class="s1">t' : this.indentStr;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">indent(indentStr, options) {</span><span class="s3">\n\t\t</span><span class="s1">const pattern = /^[^</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n]/gm;</span><span class="s3">\n\n\t\t</span><span class="s1">if (isObject(indentStr)) {</span><span class="s3">\n\t\t\t</span><span class="s1">options = indentStr;</span><span class="s3">\n\t\t\t</span><span class="s1">indentStr = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (indentStr === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">this._ensureindentStr();</span><span class="s3">\n\t\t\t</span><span class="s1">indentStr = this.indentStr || '</span><span class="s3">\\</span><span class="s1">t';</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (indentStr === '') return this; // noop</span><span class="s3">\n\n\t\t</span><span class="s1">options = options || {};</span><span class="s3">\n\n\t\t</span><span class="s1">// Process exclusion ranges</span><span class="s3">\n\t\t</span><span class="s1">const isExcluded = {};</span><span class="s3">\n\n\t\t</span><span class="s1">if (options.exclude) {</span><span class="s3">\n\t\t\t</span><span class="s1">const exclusions =</span><span class="s3">\n\t\t\t\t</span><span class="s1">typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;</span><span class="s3">\n\t\t\t</span><span class="s1">exclusions.forEach((exclusion) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">for (let i = exclusion[0]; i &lt; exclusion[1]; i += 1) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">isExcluded[i] = true;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">let shouldIndentNextCharacter = options.indentStart !== false;</span><span class="s3">\n\t\t</span><span class="s1">const replacer = (match) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">if (shouldIndentNextCharacter) return `${indentStr}${match}`;</span><span class="s3">\n\t\t\t</span><span class="s1">shouldIndentNextCharacter = true;</span><span class="s3">\n\t\t\t</span><span class="s1">return match;</span><span class="s3">\n\t\t</span><span class="s1">};</span><span class="s3">\n\n\t\t</span><span class="s1">this.intro = this.intro.replace(pattern, replacer);</span><span class="s3">\n\n\t\t</span><span class="s1">let charIndex = 0;</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">const end = chunk.end;</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.edited) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (!isExcluded[charIndex]) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">chunk.content = chunk.content.replace(pattern, replacer);</span><span class="s3">\n\n\t\t\t\t\t</span><span class="s1">if (chunk.content.length) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">charIndex = chunk.start;</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">while (charIndex &lt; end) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (!isExcluded[charIndex]) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">const char = this.original[charIndex];</span><span class="s3">\n\n\t\t\t\t\t\t</span><span class="s1">if (char === '</span><span class="s3">\\</span><span class="s1">n') {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">shouldIndentNextCharacter = true;</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">} else if (char !== '</span><span class="s3">\\</span><span class="s1">r' &amp;&amp; shouldIndentNextCharacter) {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">shouldIndentNextCharacter = false;</span><span class="s3">\n\n\t\t\t\t\t\t\t</span><span class="s1">if (charIndex === chunk.start) {</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">chunk.prependRight(indentStr);</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">this._splitChunk(chunk, charIndex);</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">chunk.prependRight(indentStr);</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t\t</span><span class="s1">charIndex += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">charIndex = chunk.end;</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.outro = this.outro.replace(pattern, replacer);</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">insert() {</span><span class="s3">\n\t\t</span><span class="s1">throw new Error(</span><span class="s3">\n\t\t\t</span><span class="s1">'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',</span><span class="s3">\n\t\t</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">insertLeft(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">if (!warned.insertLeft) {</span><span class="s3">\n\t\t\t</span><span class="s1">console.warn(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">warned.insertLeft = true;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this.appendLeft(index, content);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">insertRight(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">if (!warned.insertRight) {</span><span class="s3">\n\t\t\t</span><span class="s1">console.warn(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">warned.insertRight = true;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this.prependRight(index, content);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">move(start, end, index) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (index &gt;= start &amp;&amp; index &lt;= end) throw new Error('Cannot move a selection inside itself');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('move');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(start);</span><span class="s3">\n\t\t</span><span class="s1">this._split(end);</span><span class="s3">\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const first = this.byStart[start];</span><span class="s3">\n\t\t</span><span class="s1">const last = this.byEnd[end];</span><span class="s3">\n\n\t\t</span><span class="s1">const oldLeft = first.previous;</span><span class="s3">\n\t\t</span><span class="s1">const oldRight = last.next;</span><span class="s3">\n\n\t\t</span><span class="s1">const newRight = this.byStart[index];</span><span class="s3">\n\t\t</span><span class="s1">if (!newRight &amp;&amp; last === this.lastChunk) return this;</span><span class="s3">\n\t\t</span><span class="s1">const newLeft = newRight ? newRight.previous : this.lastChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">if (oldLeft) oldLeft.next = oldRight;</span><span class="s3">\n\t\t</span><span class="s1">if (oldRight) oldRight.previous = oldLeft;</span><span class="s3">\n\n\t\t</span><span class="s1">if (newLeft) newLeft.next = first;</span><span class="s3">\n\t\t</span><span class="s1">if (newRight) newRight.previous = last;</span><span class="s3">\n\n\t\t</span><span class="s1">if (!first.previous) this.firstChunk = last.next;</span><span class="s3">\n\t\t</span><span class="s1">if (!last.next) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.lastChunk = first.previous;</span><span class="s3">\n\t\t\t</span><span class="s1">this.lastChunk.next = null;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">first.previous = newLeft;</span><span class="s3">\n\t\t</span><span class="s1">last.next = newRight || null;</span><span class="s3">\n\n\t\t</span><span class="s1">if (!newLeft) this.firstChunk = first;</span><span class="s3">\n\t\t</span><span class="s1">if (!newRight) this.lastChunk = last;</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('move');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">overwrite(start, end, content, options) {</span><span class="s3">\n\t\t</span><span class="s1">options = options || {};</span><span class="s3">\n\t\t</span><span class="s1">return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">update(start, end, content, options) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('replacement content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.original.length !== 0) {</span><span class="s3">\n\t\t\t</span><span class="s1">while (start &lt; 0) start += this.original.length;</span><span class="s3">\n\t\t\t</span><span class="s1">while (end &lt; 0) end += this.original.length;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (end &gt; this.original.length) throw new Error('end is out of bounds');</span><span class="s3">\n\t\t</span><span class="s1">if (start === end)</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('overwrite');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(start);</span><span class="s3">\n\t\t</span><span class="s1">this._split(end);</span><span class="s3">\n\n\t\t</span><span class="s1">if (options === true) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!warned.storeName) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">console.warn(</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',</span><span class="s3">\n\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t\t</span><span class="s1">warned.storeName = true;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">options = { storeName: true };</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">const storeName = options !== undefined ? options.storeName : false;</span><span class="s3">\n\t\t</span><span class="s1">const overwrite = options !== undefined ? options.overwrite : false;</span><span class="s3">\n\n\t\t</span><span class="s1">if (storeName) {</span><span class="s3">\n\t\t\t</span><span class="s1">const original = this.original.slice(start, end);</span><span class="s3">\n\t\t\t</span><span class="s1">Object.defineProperty(this.storedNames, original, {</span><span class="s3">\n\t\t\t\t</span><span class="s1">writable: true,</span><span class="s3">\n\t\t\t\t</span><span class="s1">value: true,</span><span class="s3">\n\t\t\t\t</span><span class="s1">enumerable: true,</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const first = this.byStart[start];</span><span class="s3">\n\t\t</span><span class="s1">const last = this.byEnd[end];</span><span class="s3">\n\n\t\t</span><span class="s1">if (first) {</span><span class="s3">\n\t\t\t</span><span class="s1">let chunk = first;</span><span class="s3">\n\t\t\t</span><span class="s1">while (chunk !== last) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (chunk.next !== this.byStart[chunk.end]) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">throw new Error('Cannot overwrite across a split point');</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t\t\t</span><span class="s1">chunk.edit('', false);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">first.edit(content, storeName, !overwrite);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">// must be inserting at the end</span><span class="s3">\n\t\t\t</span><span class="s1">const newChunk = new Chunk(start, end, '').edit(content, storeName);</span><span class="s3">\n\n\t\t\t</span><span class="s1">// TODO last chunk in the array may not be the last chunk, if it's moved...</span><span class="s3">\n\t\t\t</span><span class="s1">last.next = newChunk;</span><span class="s3">\n\t\t\t</span><span class="s1">newChunk.previous = last;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('overwrite');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prepend(content) {</span><span class="s3">\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('outro content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">this.intro = content + this.intro;</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prependLeft(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('inserted content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('insertRight');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const chunk = this.byEnd[index];</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.prependLeft(content);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro = content + this.intro;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('insertRight');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prependRight(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('inserted content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('insertRight');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const chunk = this.byStart[index];</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.prependRight(content);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.outro = content + this.outro;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('insertRight');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">remove(start, end) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.original.length !== 0) {</span><span class="s3">\n\t\t\t</span><span class="s1">while (start &lt; 0) start += this.original.length;</span><span class="s3">\n\t\t\t</span><span class="s1">while (end &lt; 0) end += this.original.length;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (start === end) return this;</span><span class="s3">\n\n\t\t</span><span class="s1">if (start &lt; 0 || end &gt; this.original.length) throw new Error('Character is out of bounds');</span><span class="s3">\n\t\t</span><span class="s1">if (start &gt; end) throw new Error('end must be greater than start');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('remove');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(start);</span><span class="s3">\n\t\t</span><span class="s1">this._split(end);</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.byStart[start];</span><span class="s3">\n\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.intro = '';</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.outro = '';</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.edit('');</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = end &gt; chunk.end ? this.byStart[chunk.end] : null;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('remove');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">reset(start, end) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.original.length !== 0) {</span><span class="s3">\n\t\t\t</span><span class="s1">while (start &lt; 0) start += this.original.length;</span><span class="s3">\n\t\t\t</span><span class="s1">while (end &lt; 0) end += this.original.length;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (start === end) return this;</span><span class="s3">\n\n\t\t</span><span class="s1">if (start &lt; 0 || end &gt; this.original.length) throw new Error('Character is out of bounds');</span><span class="s3">\n\t\t</span><span class="s1">if (start &gt; end) throw new Error('end must be greater than start');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('reset');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(start);</span><span class="s3">\n\t\t</span><span class="s1">this._split(end);</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.byStart[start];</span><span class="s3">\n\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.reset();</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = end &gt; chunk.end ? this.byStart[chunk.end] : null;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('reset');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">lastChar() {</span><span class="s3">\n\t\t</span><span class="s1">if (this.outro.length) return this.outro[this.outro.length - 1];</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.lastChunk;</span><span class="s3">\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.content.length) return chunk.content[chunk.content.length - 1];</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];</span><span class="s3">\n\t\t</span><span class="s1">} while ((chunk = chunk.previous));</span><span class="s3">\n\t\t</span><span class="s1">if (this.intro.length) return this.intro[this.intro.length - 1];</span><span class="s3">\n\t\t</span><span class="s1">return '';</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">lastLine() {</span><span class="s3">\n\t\t</span><span class="s1">let lineIndex = this.outro.lastIndexOf(n);</span><span class="s3">\n\t\t</span><span class="s1">if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);</span><span class="s3">\n\t\t</span><span class="s1">let lineStr = this.outro;</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.lastChunk;</span><span class="s3">\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.outro.length &gt; 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineIndex = chunk.outro.lastIndexOf(n);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineStr = chunk.outro + lineStr;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.content.length &gt; 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineIndex = chunk.content.lastIndexOf(n);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineStr = chunk.content + lineStr;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.intro.length &gt; 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineIndex = chunk.intro.lastIndexOf(n);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineStr = chunk.intro + lineStr;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} while ((chunk = chunk.previous));</span><span class="s3">\n\t\t</span><span class="s1">lineIndex = this.intro.lastIndexOf(n);</span><span class="s3">\n\t\t</span><span class="s1">if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;</span><span class="s3">\n\t\t</span><span class="s1">return this.intro + lineStr;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">slice(start = 0, end = this.original.length - this.offset) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.original.length !== 0) {</span><span class="s3">\n\t\t\t</span><span class="s1">while (start &lt; 0) start += this.original.length;</span><span class="s3">\n\t\t\t</span><span class="s1">while (end &lt; 0) end += this.original.length;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">let result = '';</span><span class="s3">\n\n\t\t</span><span class="s1">// find start chunk</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk &amp;&amp; (chunk.start &gt; start || chunk.end &lt;= start)) {</span><span class="s3">\n\t\t\t</span><span class="s1">// found end chunk before start</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.start &lt; end &amp;&amp; chunk.end &gt;= end) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return result;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk &amp;&amp; chunk.edited &amp;&amp; chunk.start !== start)</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);</span><span class="s3">\n\n\t\t</span><span class="s1">const startChunk = chunk;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.intro &amp;&amp; (startChunk !== chunk || chunk.start === start)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">result += chunk.intro;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const containsEnd = chunk.start &lt; end &amp;&amp; chunk.end &gt;= end;</span><span class="s3">\n\t\t\t</span><span class="s1">if (containsEnd &amp;&amp; chunk.edited &amp;&amp; chunk.end !== end)</span><span class="s3">\n\t\t\t\t</span><span class="s1">throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);</span><span class="s3">\n\n\t\t\t</span><span class="s1">const sliceStart = startChunk === chunk ? start - chunk.start : 0;</span><span class="s3">\n\t\t\t</span><span class="s1">const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;</span><span class="s3">\n\n\t\t\t</span><span class="s1">result += chunk.content.slice(sliceStart, sliceEnd);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.outro &amp;&amp; (!containsEnd || chunk.end === end)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">result += chunk.outro;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (containsEnd) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// TODO deprecate this? not really very useful</span><span class="s3">\n\t</span><span class="s1">snip(start, end) {</span><span class="s3">\n\t\t</span><span class="s1">const clone = this.clone();</span><span class="s3">\n\t\t</span><span class="s1">clone.remove(0, start);</span><span class="s3">\n\t\t</span><span class="s1">clone.remove(end, clone.original.length);</span><span class="s3">\n\n\t\t</span><span class="s1">return clone;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_split(index) {</span><span class="s3">\n\t\t</span><span class="s1">if (this.byStart[index] || this.byEnd[index]) return;</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('_split');</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.lastSearchedChunk;</span><span class="s3">\n\t\t</span><span class="s1">let previousChunk = chunk;</span><span class="s3">\n\t\t</span><span class="s1">const searchForward = index &gt; chunk.end;</span><span class="s3">\n\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.contains(index)) return this._splitChunk(chunk, index);</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];</span><span class="s3">\n\n\t\t\t</span><span class="s1">// Prevent infinite loop (e.g. via empty chunks, where start === end)</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk === previousChunk) return;</span><span class="s3">\n\n\t\t\t</span><span class="s1">previousChunk = chunk;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_splitChunk(chunk, index) {</span><span class="s3">\n\t\t</span><span class="s1">if (chunk.edited &amp;&amp; chunk.content.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">// zero-length edited chunks are a special case (overlapping replacements)</span><span class="s3">\n\t\t\t</span><span class="s1">const loc = getLocator(this.original)(index);</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error(</span><span class="s3">\n\t\t\t\t</span><span class="s1">`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – </span><span class="s3">\&quot;</span><span class="s1">${chunk.original}</span><span class="s3">\&quot;</span><span class="s1">)`,</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const newChunk = chunk.split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">this.byEnd[index] = chunk;</span><span class="s3">\n\t\t</span><span class="s1">this.byStart[index] = newChunk;</span><span class="s3">\n\t\t</span><span class="s1">this.byEnd[newChunk.end] = newChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk === this.lastChunk) this.lastChunk = newChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">this.lastSearchedChunk = chunk;</span><span class="s3">\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('_split');</span><span class="s3">\n\t\t</span><span class="s1">return true;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toString() {</span><span class="s3">\n\t\t</span><span class="s1">let str = this.intro;</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">str += chunk.toString();</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return str + this.outro;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">isEmpty() {</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">if (</span><span class="s3">\n\t\t\t\t</span><span class="s1">(chunk.intro.length &amp;&amp; chunk.intro.trim()) ||</span><span class="s3">\n\t\t\t\t</span><span class="s1">(chunk.content.length &amp;&amp; chunk.content.trim()) ||</span><span class="s3">\n\t\t\t\t</span><span class="s1">(chunk.outro.length &amp;&amp; chunk.outro.trim())</span><span class="s3">\n\t\t\t</span><span class="s1">)</span><span class="s3">\n\t\t\t\t</span><span class="s1">return false;</span><span class="s3">\n\t\t</span><span class="s1">} while ((chunk = chunk.next));</span><span class="s3">\n\t\t</span><span class="s1">return true;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">length() {</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">let length = 0;</span><span class="s3">\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">length += chunk.intro.length + chunk.content.length + chunk.outro.length;</span><span class="s3">\n\t\t</span><span class="s1">} while ((chunk = chunk.next));</span><span class="s3">\n\t\t</span><span class="s1">return length;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimLines() {</span><span class="s3">\n\t\t</span><span class="s1">return this.trim('[</span><span class="s3">\\\\</span><span class="s1">r</span><span class="s3">\\\\</span><span class="s1">n]');</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trim(charType) {</span><span class="s3">\n\t\t</span><span class="s1">return this.trimStart(charType).trimEnd(charType);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimEndAborted(charType) {</span><span class="s3">\n\t\t</span><span class="s1">const rx = new RegExp((charType || '</span><span class="s3">\\\\</span><span class="s1">s') + '+$');</span><span class="s3">\n\n\t\t</span><span class="s1">this.outro = this.outro.replace(rx, '');</span><span class="s3">\n\t\t</span><span class="s1">if (this.outro.length) return true;</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.lastChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">const end = chunk.end;</span><span class="s3">\n\t\t\t</span><span class="s1">const aborted = chunk.trimEnd(rx);</span><span class="s3">\n\n\t\t\t</span><span class="s1">// if chunk was trimmed, we have a new lastChunk</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.end !== end) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (this.lastChunk === chunk) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">this.lastChunk = chunk.next;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">this.byEnd[chunk.end] = chunk;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.byStart[chunk.next.start] = chunk.next;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.byEnd[chunk.next.end] = chunk.next;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (aborted) return true;</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.previous;</span><span class="s3">\n\t\t</span><span class="s1">} while (chunk);</span><span class="s3">\n\n\t\t</span><span class="s1">return false;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimEnd(charType) {</span><span class="s3">\n\t\t</span><span class="s1">this.trimEndAborted(charType);</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">trimStartAborted(charType) {</span><span class="s3">\n\t\t</span><span class="s1">const rx = new RegExp('^' + (charType || '</span><span class="s3">\\\\</span><span class="s1">s') + '+');</span><span class="s3">\n\n\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\t\t</span><span class="s1">if (this.intro.length) return true;</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">const end = chunk.end;</span><span class="s3">\n\t\t\t</span><span class="s1">const aborted = chunk.trimStart(rx);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.end !== end) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">// special case...</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (chunk === this.lastChunk) this.lastChunk = chunk.next;</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">this.byEnd[chunk.end] = chunk;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.byStart[chunk.next.start] = chunk.next;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.byEnd[chunk.next.end] = chunk.next;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (aborted) return true;</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">} while (chunk);</span><span class="s3">\n\n\t\t</span><span class="s1">return false;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimStart(charType) {</span><span class="s3">\n\t\t</span><span class="s1">this.trimStartAborted(charType);</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">hasChanged() {</span><span class="s3">\n\t\t</span><span class="s1">return this.original !== this.toString();</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_replaceRegexp(searchValue, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">function getReplacement(match, str) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (typeof replacement === 'string') {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return replacement.replace(/</span><span class="s3">\\</span><span class="s1">$(</span><span class="s3">\\</span><span class="s1">$|&amp;|</span><span class="s3">\\</span><span class="s1">d+)/g, (_, i) =&gt; {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (i === '$') return '$';</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (i === '&amp;') return match[0];</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const num = +i;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (num &lt; match.length) return match[+i];</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">return `$${i}`;</span><span class="s3">\n\t\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return replacement(...match, match.index, str, match.groups);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">function matchAll(re, str) {</span><span class="s3">\n\t\t\t</span><span class="s1">let match;</span><span class="s3">\n\t\t\t</span><span class="s1">const matches = [];</span><span class="s3">\n\t\t\t</span><span class="s1">while ((match = re.exec(str))) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">matches.push(match);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">return matches;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">if (searchValue.global) {</span><span class="s3">\n\t\t\t</span><span class="s1">const matches = matchAll(searchValue, this.original);</span><span class="s3">\n\t\t\t</span><span class="s1">matches.forEach((match) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (match.index != null) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const replacement = getReplacement(match, this.original);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (replacement !== match[0]) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">this.overwrite(match.index, match.index + match[0].length, replacement);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">const match = this.original.match(searchValue);</span><span class="s3">\n\t\t\t</span><span class="s1">if (match &amp;&amp; match.index != null) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const replacement = getReplacement(match, this.original);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (replacement !== match[0]) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">this.overwrite(match.index, match.index + match[0].length, replacement);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_replaceString(string, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">const { original } = this;</span><span class="s3">\n\t\t</span><span class="s1">const index = original.indexOf(string);</span><span class="s3">\n\n\t\t</span><span class="s1">if (index !== -1) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (typeof replacement === 'function') {</span><span class="s3">\n\t\t\t\t</span><span class="s1">replacement = replacement(string, index, original);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (string !== replacement) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.overwrite(index, index + string.length, replacement);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">replace(searchValue, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">if (typeof searchValue === 'string') {</span><span class="s3">\n\t\t\t</span><span class="s1">return this._replaceString(searchValue, replacement);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this._replaceRegexp(searchValue, replacement);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_replaceAllString(string, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">const { original } = this;</span><span class="s3">\n\t\t</span><span class="s1">const stringLength = string.length;</span><span class="s3">\n\t\t</span><span class="s1">for (</span><span class="s3">\n\t\t\t</span><span class="s1">let index = original.indexOf(string);</span><span class="s3">\n\t\t\t</span><span class="s1">index !== -1;</span><span class="s3">\n\t\t\t</span><span class="s1">index = original.indexOf(string, index + stringLength)</span><span class="s3">\n\t\t</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">const previous = original.slice(index, index + stringLength);</span><span class="s3">\n\t\t\t</span><span class="s1">let _replacement = replacement;</span><span class="s3">\n\t\t\t</span><span class="s1">if (typeof replacement === 'function') {</span><span class="s3">\n\t\t\t\t</span><span class="s1">_replacement = replacement(previous, index, original);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">replaceAll(searchValue, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">if (typeof searchValue === 'string') {</span><span class="s3">\n\t\t\t</span><span class="s1">return this._replaceAllString(searchValue, replacement);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (!searchValue.global) {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new TypeError(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'MagicString.prototype.replaceAll called with a non-global RegExp argument',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this._replaceRegexp(searchValue, replacement);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import MagicString from './MagicString.js';</span><span class="s3">\n</span><span class="s1">import SourceMap from './SourceMap.js';</span><span class="s3">\n</span><span class="s1">import getRelativePath from './utils/getRelativePath.js';</span><span class="s3">\n</span><span class="s1">import isObject from './utils/isObject.js';</span><span class="s3">\n</span><span class="s1">import getLocator from './utils/getLocator.js';</span><span class="s3">\n</span><span class="s1">import Mappings from './utils/Mappings.js';</span><span class="s3">\n\n</span><span class="s1">const hasOwnProp = Object.prototype.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">export default class Bundle {</span><span class="s3">\n\t</span><span class="s1">constructor(options = {}) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = options.intro || '';</span><span class="s3">\n\t\t</span><span class="s1">this.separator = options.separator !== undefined ? options.separator : '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\t\t</span><span class="s1">this.sources = [];</span><span class="s3">\n\t\t</span><span class="s1">this.uniqueSources = [];</span><span class="s3">\n\t\t</span><span class="s1">this.uniqueSourceIndexByFilename = {};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">addSource(source) {</span><span class="s3">\n\t\t</span><span class="s1">if (source instanceof MagicString) {</span><span class="s3">\n\t\t\t</span><span class="s1">return this.addSource({</span><span class="s3">\n\t\t\t\t</span><span class="s1">content: source,</span><span class="s3">\n\t\t\t\t</span><span class="s1">filename: source.filename,</span><span class="s3">\n\t\t\t\t</span><span class="s1">separator: this.separator,</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (!isObject(source) || !source.content) {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!hasOwnProp.call(source, option)) source[option] = source.content[option];</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">if (source.separator === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">// TODO there's a bunch of this sort of thing, needs cleaning up</span><span class="s3">\n\t\t\t</span><span class="s1">source.separator = this.separator;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (source.filename) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.uniqueSources.push({ filename: source.filename, content: source.content.original });</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (source.content.original !== uniqueSource.content) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">throw new Error(`Illegal source: same filename (${source.filename}), different contents`);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.push(source);</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">append(str, options) {</span><span class="s3">\n\t\t</span><span class="s1">this.addSource({</span><span class="s3">\n\t\t\t</span><span class="s1">content: new MagicString(str),</span><span class="s3">\n\t\t\t</span><span class="s1">separator: (options &amp;&amp; options.separator) || '',</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">clone() {</span><span class="s3">\n\t\t</span><span class="s1">const bundle = new Bundle({</span><span class="s3">\n\t\t\t</span><span class="s1">intro: this.intro,</span><span class="s3">\n\t\t\t</span><span class="s1">separator: this.separator,</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.forEach((source) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">bundle.addSource({</span><span class="s3">\n\t\t\t\t</span><span class="s1">filename: source.filename,</span><span class="s3">\n\t\t\t\t</span><span class="s1">content: source.content.clone(),</span><span class="s3">\n\t\t\t\t</span><span class="s1">separator: source.separator,</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">return bundle;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">generateDecodedMap(options = {}) {</span><span class="s3">\n\t\t</span><span class="s1">const names = [];</span><span class="s3">\n\t\t</span><span class="s1">let x_google_ignoreList = undefined;</span><span class="s3">\n\t\t</span><span class="s1">this.sources.forEach((source) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">Object.keys(source.content.storedNames).forEach((name) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (!~names.indexOf(name)) names.push(name);</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">const mappings = new Mappings(options.hires);</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.intro) {</span><span class="s3">\n\t\t\t</span><span class="s1">mappings.advance(this.intro);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.forEach((source, i) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">if (i &gt; 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.advance(this.separator);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;</span><span class="s3">\n\t\t\t</span><span class="s1">const magicString = source.content;</span><span class="s3">\n\t\t\t</span><span class="s1">const locate = getLocator(magicString.original);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (magicString.intro) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.advance(magicString.intro);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">magicString.firstChunk.eachNext((chunk) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const loc = locate(chunk.start);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if (chunk.intro.length) mappings.advance(chunk.intro);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if (source.filename) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (chunk.edited) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">mappings.addEdit(</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">sourceIndex,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">chunk.content,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">loc,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">chunk.storeName ? names.indexOf(chunk.original) : -1,</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">mappings.addUneditedChunk(</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">sourceIndex,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">chunk,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">magicString.original,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">loc,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">magicString.sourcemapLocations,</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">mappings.advance(chunk.content);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if (chunk.outro.length) mappings.advance(chunk.outro);</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (magicString.outro) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.advance(magicString.outro);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (source.ignoreList &amp;&amp; sourceIndex !== -1) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (x_google_ignoreList === undefined) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">x_google_ignoreList = [];</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">x_google_ignoreList.push(sourceIndex);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">return {</span><span class="s3">\n\t\t\t</span><span class="s1">file: options.file ? options.file.split(/[/</span><span class="s3">\\\\</span><span class="s1">]/).pop() : undefined,</span><span class="s3">\n\t\t\t</span><span class="s1">sources: this.uniqueSources.map((source) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return options.file ? getRelativePath(options.file, source.filename) : source.filename;</span><span class="s3">\n\t\t\t</span><span class="s1">}),</span><span class="s3">\n\t\t\t</span><span class="s1">sourcesContent: this.uniqueSources.map((source) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return options.includeContent ? source.content : null;</span><span class="s3">\n\t\t\t</span><span class="s1">}),</span><span class="s3">\n\t\t\t</span><span class="s1">names,</span><span class="s3">\n\t\t\t</span><span class="s1">mappings: mappings.raw,</span><span class="s3">\n\t\t\t</span><span class="s1">x_google_ignoreList,</span><span class="s3">\n\t\t</span><span class="s1">};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">generateMap(options) {</span><span class="s3">\n\t\t</span><span class="s1">return new SourceMap(this.generateDecodedMap(options));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">getIndentString() {</span><span class="s3">\n\t\t</span><span class="s1">const indentStringCounts = {};</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.forEach((source) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">const indentStr = source.content._getRawIndentString();</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (indentStr === null) return;</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;</span><span class="s3">\n\t\t\t</span><span class="s1">indentStringCounts[indentStr] += 1;</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">return (</span><span class="s3">\n\t\t\t</span><span class="s1">Object.keys(indentStringCounts).sort((a, b) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return indentStringCounts[a] - indentStringCounts[b];</span><span class="s3">\n\t\t\t</span><span class="s1">})[0] || '</span><span class="s3">\\</span><span class="s1">t'</span><span class="s3">\n\t\t</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">indent(indentStr) {</span><span class="s3">\n\t\t</span><span class="s1">if (!arguments.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">indentStr = this.getIndentString();</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (indentStr === '') return this; // noop</span><span class="s3">\n\n\t\t</span><span class="s1">let trailingNewline = !this.intro || this.intro.slice(-1) === '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.forEach((source, i) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">const separator = source.separator !== undefined ? source.separator : this.separator;</span><span class="s3">\n\t\t\t</span><span class="s1">const indentStart = trailingNewline || (i &gt; 0 &amp;&amp; /</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n$/.test(separator));</span><span class="s3">\n\n\t\t\t</span><span class="s1">source.content.indent(indentStr, {</span><span class="s3">\n\t\t\t\t</span><span class="s1">exclude: source.indentExclusionRanges,</span><span class="s3">\n\t\t\t\t</span><span class="s1">indentStart, //: trailingNewline || /</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n$/.test( separator )  //true///</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n/.test( separator )</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t\t</span><span class="s1">trailingNewline = source.content.lastChar() === '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.intro) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro =</span><span class="s3">\n\t\t\t\t</span><span class="s1">indentStr +</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.intro.replace(/^[^</span><span class="s3">\\</span><span class="s1">n]/gm, (match, index) =&gt; {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">return index &gt; 0 ? indentStr + match : match;</span><span class="s3">\n\t\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prepend(str) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = str + this.intro;</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toString() {</span><span class="s3">\n\t\t</span><span class="s1">const body = this.sources</span><span class="s3">\n\t\t\t</span><span class="s1">.map((source, i) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const separator = source.separator !== undefined ? source.separator : this.separator;</span><span class="s3">\n\t\t\t\t</span><span class="s1">const str = (i &gt; 0 ? separator : '') + source.content.toString();</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">return str;</span><span class="s3">\n\t\t\t</span><span class="s1">})</span><span class="s3">\n\t\t\t</span><span class="s1">.join('');</span><span class="s3">\n\n\t\t</span><span class="s1">return this.intro + body;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">isEmpty() {</span><span class="s3">\n\t\t</span><span class="s1">if (this.intro.length &amp;&amp; this.intro.trim()) return false;</span><span class="s3">\n\t\t</span><span class="s1">if (this.sources.some((source) =&gt; !source.content.isEmpty())) return false;</span><span class="s3">\n\t\t</span><span class="s1">return true;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">length() {</span><span class="s3">\n\t\t</span><span class="s1">return this.sources.reduce(</span><span class="s3">\n\t\t\t</span><span class="s1">(length, source) =&gt; length + source.content.length(),</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro.length,</span><span class="s3">\n\t\t</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimLines() {</span><span class="s3">\n\t\t</span><span class="s1">return this.trim('[</span><span class="s3">\\\\</span><span class="s1">r</span><span class="s3">\\\\</span><span class="s1">n]');</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trim(charType) {</span><span class="s3">\n\t\t</span><span class="s1">return this.trimStart(charType).trimEnd(charType);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimStart(charType) {</span><span class="s3">\n\t\t</span><span class="s1">const rx = new RegExp('^' + (charType || '</span><span class="s3">\\\\</span><span class="s1">s') + '+');</span><span class="s3">\n\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\n\t\t</span><span class="s1">if (!this.intro) {</span><span class="s3">\n\t\t\t</span><span class="s1">let source;</span><span class="s3">\n\t\t\t</span><span class="s1">let i = 0;</span><span class="s3">\n\n\t\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t\t</span><span class="s1">source = this.sources[i++];</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (!source) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} while (!source.content.trimStartAborted(charType));</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimEnd(charType) {</span><span class="s3">\n\t\t</span><span class="s1">const rx = new RegExp((charType || '</span><span class="s3">\\\\</span><span class="s1">s') + '+$');</span><span class="s3">\n\n\t\t</span><span class="s1">let source;</span><span class="s3">\n\t\t</span><span class="s1">let i = this.sources.length - 1;</span><span class="s3">\n\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">source = this.sources[i--];</span><span class="s3">\n\t\t\t</span><span class="s1">if (!source) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} while (!source.content.trimEndAborted(charType));</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import MagicString from './MagicString.js';</span><span class="s3">\n</span><span class="s1">import Bundle from './Bundle.js';</span><span class="s3">\n</span><span class="s1">import SourceMap from './SourceMap.js';</span><span class="s3">\n\n</span><span class="s1">MagicString.Bundle = Bundle;</span><span class="s3">\n</span><span class="s1">MagicString.SourceMap = SourceMap;</span><span class="s3">\n</span><span class="s1">MagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121</span><span class="s3">\n\n</span><span class="s1">export default MagicString;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;x_google_ignoreList&quot;</span><span class="s0">:[</span><span class="s2">2</span><span class="s0">]}</span></pre>
</body>
</html>