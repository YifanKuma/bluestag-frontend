<html>
<head>
<title>pages-api-turbo.runtime.prod.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pages-api-turbo.runtime.prod.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;pages-api-turbo.runtime.prod.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://next/./dist/compiled/@edge-runtime/cookies/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/bytes/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/content-type/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/cookie/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/fresh/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/path-to-regexp/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/format-dynamic-import-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/node/try-get-preview-data.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/crypto-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/node-fs-methods.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/trace/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/reflect.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/headers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/isomorphic/path.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/modern-browserslist-target.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/superstruct/index.cjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/compat_get_default_export&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/create_fake_namespace_object&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/define_property_getters&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/has_own_property&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/make_namespace_object&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/i18n/normalize-locale-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/ensure-leading-slash.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/app-paths.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/segment.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/interception-routes.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/is-dynamic.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/path-has-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/remove-path-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/escape-regexp.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/remove-trailing-slash.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/get-dynamic-param.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-regex.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/route-pattern-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-match-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/querystring.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/get-cookie-parser.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/prepare-destination.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/decode-query-path-parameter.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/format-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/types.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/generate-interception-routes-rewrites.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/app-router-headers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/server-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/i18n/detect-domain-locale.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/get-hostname.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-data-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/request-meta.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-page-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/metadata/is-metadata-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/detached-promise.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/batcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/scheduler.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/types.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/stream-utils/node-web-streams-helper.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/stream-utils/encoded-tags.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-path-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-path-suffix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/next-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/get-next-pathname-info.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/format-next-pathname-info.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-locale.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/request.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/next-request.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/client-component-renderer-logger.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/pipe-readable.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/invariant-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/render-result.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-kind.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/multi-file-writer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/incremental-cache/file-system-cache.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/to-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/incremental-cache/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/use-cache/handlers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/interop-default.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/router-utils/router-server-context.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/route-module.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-app-route-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-path-sep.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/path-match.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/router-reducer/compute-changed-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/parse-and-validate-flight-router-state.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-relative-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/router-utils/decode-path-params.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/escape-path-delimiters.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/node/parse-body.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/node/api-resolver.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/etag.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/send-payload.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/interop-default.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/pages-api/module.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var __defProp = Object.defineProperty;</span><span class="s3">\n</span><span class="s1">var __getOwnPropDesc = Object.getOwnPropertyDescriptor;</span><span class="s3">\n</span><span class="s1">var __getOwnPropNames = Object.getOwnPropertyNames;</span><span class="s3">\n</span><span class="s1">var __hasOwnProp = Object.prototype.hasOwnProperty;</span><span class="s3">\n</span><span class="s1">var __export = (target, all) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (var name in all)</span><span class="s3">\n    </span><span class="s1">__defProp(target, name, { get: all[name], enumerable: true });</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var __copyProps = (to, from, except, desc) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (from &amp;&amp; typeof from === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| typeof from === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (let key of __getOwnPropNames(from))</span><span class="s3">\n      </span><span class="s1">if (!__hasOwnProp.call(to, key) &amp;&amp; key !== except)</span><span class="s3">\n        </span><span class="s1">__defProp(to, key, { get: () =&gt; from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return to;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var __toCommonJS = (mod) =&gt; __copyProps(__defProp({}, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true }), mod);</span><span class="s3">\n\n</span><span class="s1">// src/index.ts</span><span class="s3">\n</span><span class="s1">var src_exports = {};</span><span class="s3">\n</span><span class="s1">__export(src_exports, {</span><span class="s3">\n  </span><span class="s1">RequestCookies: () =&gt; RequestCookies,</span><span class="s3">\n  </span><span class="s1">ResponseCookies: () =&gt; ResponseCookies,</span><span class="s3">\n  </span><span class="s1">parseCookie: () =&gt; parseCookie,</span><span class="s3">\n  </span><span class="s1">parseSetCookie: () =&gt; parseSetCookie,</span><span class="s3">\n  </span><span class="s1">stringifyCookie: () =&gt; stringifyCookie</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">module.exports = __toCommonJS(src_exports);</span><span class="s3">\n\n</span><span class="s1">// src/serialize.ts</span><span class="s3">\n</span><span class="s1">function stringifyCookie(c) {</span><span class="s3">\n  </span><span class="s1">var _a;</span><span class="s3">\n  </span><span class="s1">const attrs = [</span><span class="s3">\n    \&quot;</span><span class="s1">path</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.path &amp;&amp; `Path=${c.path}`,</span><span class="s3">\n    \&quot;</span><span class="s1">expires</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; (c.expires || c.expires === 0) &amp;&amp; `Expires=${(typeof c.expires === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? new Date(c.expires) : c.expires).toUTCString()}`,</span><span class="s3">\n    \&quot;</span><span class="s1">maxAge</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; typeof c.maxAge === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; `Max-Age=${c.maxAge}`,</span><span class="s3">\n    \&quot;</span><span class="s1">domain</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.domain &amp;&amp; `Domain=${c.domain}`,</span><span class="s3">\n    \&quot;</span><span class="s1">secure</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.secure &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">Secure</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">httpOnly</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.httpOnly &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">HttpOnly</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">sameSite</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.sameSite &amp;&amp; `SameSite=${c.sameSite}`,</span><span class="s3">\n    \&quot;</span><span class="s1">partitioned</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.partitioned &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">Partitioned</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">priority</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.priority &amp;&amp; `Priority=${c.priority}`</span><span class="s3">\n  </span><span class="s1">].filter(Boolean);</span><span class="s3">\n  </span><span class="s1">const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : </span><span class="s3">\&quot;\&quot;</span><span class="s1">)}`;</span><span class="s3">\n  </span><span class="s1">return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseCookie(cookie) {</span><span class="s3">\n  </span><span class="s1">const map = /* @__PURE__ */ new Map();</span><span class="s3">\n  </span><span class="s1">for (const pair of cookie.split(/; */)) {</span><span class="s3">\n    </span><span class="s1">if (!pair)</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">const splitAt = pair.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (splitAt === -1) {</span><span class="s3">\n      </span><span class="s1">map.set(pair, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">map.set(key, decodeURIComponent(value != null ? value : </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return map;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseSetCookie(setCookie) {</span><span class="s3">\n  </span><span class="s1">if (!setCookie) {</span><span class="s3">\n    </span><span class="s1">return void 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const [[name, value], ...attributes] = parseCookie(setCookie);</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">domain,</span><span class="s3">\n    </span><span class="s1">expires,</span><span class="s3">\n    </span><span class="s1">httponly,</span><span class="s3">\n    </span><span class="s1">maxage,</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">samesite,</span><span class="s3">\n    </span><span class="s1">secure,</span><span class="s3">\n    </span><span class="s1">partitioned,</span><span class="s3">\n    </span><span class="s1">priority</span><span class="s3">\n  </span><span class="s1">} = Object.fromEntries(</span><span class="s3">\n    </span><span class="s1">attributes.map(([key, value2]) =&gt; [</span><span class="s3">\n      </span><span class="s1">key.toLowerCase().replace(/-/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">value2</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const cookie = {</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">value: decodeURIComponent(value),</span><span class="s3">\n    </span><span class="s1">domain,</span><span class="s3">\n    </span><span class="s1">...expires &amp;&amp; { expires: new Date(expires) },</span><span class="s3">\n    </span><span class="s1">...httponly &amp;&amp; { httpOnly: true },</span><span class="s3">\n    </span><span class="s1">...typeof maxage === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; { maxAge: Number(maxage) },</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">...samesite &amp;&amp; { sameSite: parseSameSite(samesite) },</span><span class="s3">\n    </span><span class="s1">...secure &amp;&amp; { secure: true },</span><span class="s3">\n    </span><span class="s1">...priority &amp;&amp; { priority: parsePriority(priority) },</span><span class="s3">\n    </span><span class="s1">...partitioned &amp;&amp; { partitioned: true }</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return compact(cookie);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function compact(t) {</span><span class="s3">\n  </span><span class="s1">const newT = {};</span><span class="s3">\n  </span><span class="s1">for (const key in t) {</span><span class="s3">\n    </span><span class="s1">if (t[key]) {</span><span class="s3">\n      </span><span class="s1">newT[key] = t[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newT;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var SAME_SITE = [</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">lax</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">function parseSameSite(string) {</span><span class="s3">\n  </span><span class="s1">string = string.toLowerCase();</span><span class="s3">\n  </span><span class="s1">return SAME_SITE.includes(string) ? string : void 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var PRIORITY = [</span><span class="s3">\&quot;</span><span class="s1">low</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">medium</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">high</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">function parsePriority(string) {</span><span class="s3">\n  </span><span class="s1">string = string.toLowerCase();</span><span class="s3">\n  </span><span class="s1">return PRIORITY.includes(string) ? string : void 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function splitCookiesString(cookiesString) {</span><span class="s3">\n  </span><span class="s1">if (!cookiesString)</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">var cookiesStrings = [];</span><span class="s3">\n  </span><span class="s1">var pos = 0;</span><span class="s3">\n  </span><span class="s1">var start;</span><span class="s3">\n  </span><span class="s1">var ch;</span><span class="s3">\n  </span><span class="s1">var lastComma;</span><span class="s3">\n  </span><span class="s1">var nextStart;</span><span class="s3">\n  </span><span class="s1">var cookiesSeparatorFound;</span><span class="s3">\n  </span><span class="s1">function skipWhitespace() {</span><span class="s3">\n    </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(cookiesString.charAt(pos))) {</span><span class="s3">\n      </span><span class="s1">pos += 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos &lt; cookiesString.length;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function notSpecialChar() {</span><span class="s3">\n    </span><span class="s1">ch = cookiesString.charAt(pos);</span><span class="s3">\n    </span><span class="s1">return ch !== </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ch !== </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ch !== </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (pos &lt; cookiesString.length) {</span><span class="s3">\n    </span><span class="s1">start = pos;</span><span class="s3">\n    </span><span class="s1">cookiesSeparatorFound = false;</span><span class="s3">\n    </span><span class="s1">while (skipWhitespace()) {</span><span class="s3">\n      </span><span class="s1">ch = cookiesString.charAt(pos);</span><span class="s3">\n      </span><span class="s1">if (ch === </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">lastComma = pos;</span><span class="s3">\n        </span><span class="s1">pos += 1;</span><span class="s3">\n        </span><span class="s1">skipWhitespace();</span><span class="s3">\n        </span><span class="s1">nextStart = pos;</span><span class="s3">\n        </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; notSpecialChar()) {</span><span class="s3">\n          </span><span class="s1">pos += 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (pos &lt; cookiesString.length &amp;&amp; cookiesString.charAt(pos) === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">cookiesSeparatorFound = true;</span><span class="s3">\n          </span><span class="s1">pos = nextStart;</span><span class="s3">\n          </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, lastComma));</span><span class="s3">\n          </span><span class="s1">start = pos;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">pos = lastComma + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pos += 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!cookiesSeparatorFound || pos &gt;= cookiesString.length) {</span><span class="s3">\n      </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, cookiesString.length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cookiesStrings;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// src/request-cookies.ts</span><span class="s3">\n</span><span class="s1">var RequestCookies = class {</span><span class="s3">\n  </span><span class="s1">constructor(requestHeaders) {</span><span class="s3">\n    </span><span class="s1">/** @internal */</span><span class="s3">\n    </span><span class="s1">this._parsed = /* @__PURE__ */ new Map();</span><span class="s3">\n    </span><span class="s1">this._headers = requestHeaders;</span><span class="s3">\n    </span><span class="s1">const header = requestHeaders.get(</span><span class="s3">\&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (header) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseCookie(header);</span><span class="s3">\n      </span><span class="s1">for (const [name, value] of parsed) {</span><span class="s3">\n        </span><span class="s1">this._parsed.set(name, { name, value });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[Symbol.iterator]() {</span><span class="s3">\n    </span><span class="s1">return this._parsed[Symbol.iterator]();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The amount of cookies received from the client</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get size() {</span><span class="s3">\n    </span><span class="s1">return this._parsed.size;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">get(...args) {</span><span class="s3">\n    </span><span class="s1">const name = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : args[0].name;</span><span class="s3">\n    </span><span class="s1">return this._parsed.get(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">getAll(...args) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const all = Array.from(this._parsed);</span><span class="s3">\n    </span><span class="s1">if (!args.length) {</span><span class="s3">\n      </span><span class="s1">return all.map(([_, value]) =&gt; value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const name = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : (_a = args[0]) == null ? void 0 : _a.name;</span><span class="s3">\n    </span><span class="s1">return all.filter(([n]) =&gt; n === name).map(([_, value]) =&gt; value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">has(name) {</span><span class="s3">\n    </span><span class="s1">return this._parsed.has(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">set(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">map.set(name, { name, value });</span><span class="s3">\n    </span><span class="s1">this._headers.set(</span><span class="s3">\n      \&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">Array.from(map).map(([_, value2]) =&gt; stringifyCookie(value2)).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Delete the cookies matching the passed name or names in the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete(names) {</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">const result = !Array.isArray(names) ? map.delete(names) : names.map((name) =&gt; map.delete(name));</span><span class="s3">\n    </span><span class="s1">this._headers.set(</span><span class="s3">\n      \&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">Array.from(map).map(([_, value]) =&gt; stringifyCookie(value)).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Delete all the cookies in the cookies in the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clear() {</span><span class="s3">\n    </span><span class="s1">this.delete(Array.from(this._parsed.keys()));</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Format the cookies in the request as a string for logging</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">edge-runtime.inspect.custom</span><span class="s3">\&quot;</span><span class="s1">)]() {</span><span class="s3">\n    </span><span class="s1">return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return [...this._parsed.values()].map((v) =&gt; `${v.name}=${encodeURIComponent(v.value)}`).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/response-cookies.ts</span><span class="s3">\n</span><span class="s1">var ResponseCookies = class {</span><span class="s3">\n  </span><span class="s1">constructor(responseHeaders) {</span><span class="s3">\n    </span><span class="s1">/** @internal */</span><span class="s3">\n    </span><span class="s1">this._parsed = /* @__PURE__ */ new Map();</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n    </span><span class="s1">this._headers = responseHeaders;</span><span class="s3">\n    </span><span class="s1">const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">)) != null ? _c : [];</span><span class="s3">\n    </span><span class="s1">const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);</span><span class="s3">\n    </span><span class="s1">for (const cookieString of cookieStrings) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseSetCookie(cookieString);</span><span class="s3">\n      </span><span class="s1">if (parsed)</span><span class="s3">\n        </span><span class="s1">this._parsed.set(parsed.name, parsed);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get(...args) {</span><span class="s3">\n    </span><span class="s1">const key = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : args[0].name;</span><span class="s3">\n    </span><span class="s1">return this._parsed.get(key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getAll(...args) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const all = Array.from(this._parsed.values());</span><span class="s3">\n    </span><span class="s1">if (!args.length) {</span><span class="s3">\n      </span><span class="s1">return all;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const key = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : (_a = args[0]) == null ? void 0 : _a.name;</span><span class="s3">\n    </span><span class="s1">return all.filter((c) =&gt; c.name === key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">has(name) {</span><span class="s3">\n    </span><span class="s1">return this._parsed.has(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">set(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">map.set(name, normalizeCookie({ name, value, ...cookie }));</span><span class="s3">\n    </span><span class="s1">replace(map, this._headers);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, options] = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? [args[0]] : [args[0].name, args[0]];</span><span class="s3">\n    </span><span class="s1">return this.set({ ...options, name, value: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, expires: /* @__PURE__ */ new Date(0) });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">edge-runtime.inspect.custom</span><span class="s3">\&quot;</span><span class="s1">)]() {</span><span class="s3">\n    </span><span class="s1">return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return [...this._parsed.values()].map(stringifyCookie).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function replace(bag, headers) {</span><span class="s3">\n  </span><span class="s1">headers.delete(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">for (const [, value] of bag) {</span><span class="s3">\n    </span><span class="s1">const serialized = stringifyCookie(value);</span><span class="s3">\n    </span><span class="s1">headers.append(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">, serialized);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function normalizeCookie(cookie = { name: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, value: </span><span class="s3">\&quot;\&quot; </span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">if (typeof cookie.expires === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">cookie.expires = new Date(cookie.expires);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (cookie.maxAge) {</span><span class="s3">\n    </span><span class="s1">cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (cookie.path === null || cookie.path === void 0) {</span><span class="s3">\n    </span><span class="s1">cookie.path = </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cookie;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Annotate the CommonJS export names for ESM import in node:</span><span class="s3">\n</span><span class="s1">0 &amp;&amp; (module.exports = {</span><span class="s3">\n  </span><span class="s1">RequestCookies,</span><span class="s3">\n  </span><span class="s1">ResponseCookies,</span><span class="s3">\n  </span><span class="s1">parseCookie,</span><span class="s3">\n  </span><span class="s1">parseSetCookie,</span><span class="s3">\n  </span><span class="s1">stringifyCookie</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;var e={56:e=&gt;{</span><span class="s3">\n</span><span class="s1">/*!</span><span class="s3">\n </span><span class="s1">* bytes</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2012-2014 TJ Holowaychuk</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2015 Jed Watson</span><span class="s3">\n </span><span class="s1">* MIT Licensed</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">e.exports=bytes;e.exports.format=format;e.exports.parse=parse;var r=/</span><span class="s3">\\</span><span class="s1">B(?=(</span><span class="s3">\\</span><span class="s1">d{3})+(?!</span><span class="s3">\\</span><span class="s1">d))/g;var a=/(?:</span><span class="s3">\\</span><span class="s1">.0*|(</span><span class="s3">\\</span><span class="s1">.[^0]+)0+)$/;var t={b:1,kb:1&lt;&lt;10,mb:1&lt;&lt;20,gb:1&lt;&lt;30,tb:Math.pow(1024,4),pb:Math.pow(1024,5)};var i=/^((-|</span><span class="s3">\\</span><span class="s1">+)?(</span><span class="s3">\\</span><span class="s1">d+(?:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)?)) *(kb|mb|gb|tb|pb)$/i;function bytes(e,r){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){return parse(e)}if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">){return format(e,r)}return null}function format(e,i){if(!Number.isFinite(e)){return null}var n=Math.abs(e);var o=i&amp;&amp;i.thousandsSeparator||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var s=i&amp;&amp;i.unitSeparator||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var f=i&amp;&amp;i.decimalPlaces!==undefined?i.decimalPlaces:2;var u=Boolean(i&amp;&amp;i.fixedDecimals);var p=i&amp;&amp;i.unit||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;if(!p||!t[p.toLowerCase()]){if(n&gt;=t.pb){p=</span><span class="s3">\&quot;</span><span class="s1">PB</span><span class="s3">\&quot;</span><span class="s1">}else if(n&gt;=t.tb){p=</span><span class="s3">\&quot;</span><span class="s1">TB</span><span class="s3">\&quot;</span><span class="s1">}else if(n&gt;=t.gb){p=</span><span class="s3">\&quot;</span><span class="s1">GB</span><span class="s3">\&quot;</span><span class="s1">}else if(n&gt;=t.mb){p=</span><span class="s3">\&quot;</span><span class="s1">MB</span><span class="s3">\&quot;</span><span class="s1">}else if(n&gt;=t.kb){p=</span><span class="s3">\&quot;</span><span class="s1">KB</span><span class="s3">\&quot;</span><span class="s1">}else{p=</span><span class="s3">\&quot;</span><span class="s1">B</span><span class="s3">\&quot;</span><span class="s1">}}var b=e/t[p.toLowerCase()];var l=b.toFixed(f);if(!u){l=l.replace(a,</span><span class="s3">\&quot;</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)}if(o){l=l.split(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">).map((function(e,a){return a===0?e.replace(r,o):e})).join(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)}return l+s+p}function parse(e){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;!isNaN(e)){return e}if(typeof e!==</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){return null}var r=i.exec(e);var a;var n=</span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">;if(!r){a=parseInt(e,10);n=</span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">}else{a=parseFloat(r[1]);n=r[4].toLowerCase()}return Math.floor(t[n]*a)}}};var r={};function __nccwpck_require__(a){var t=r[a];if(t!==undefined){return t.exports}var i=r[a]={exports:{}};var n=true;try{e[a](i,i.exports,__nccwpck_require__);n=false}finally{if(n)delete r[a]}return i.exports}if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var a=__nccwpck_require__(56);module.exports=a})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var e={};(()=&gt;{var r=e;</span><span class="s3">\n</span><span class="s1">/*!</span><span class="s3">\n </span><span class="s1">* content-type</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2015 Douglas Christopher Wilson</span><span class="s3">\n </span><span class="s1">* MIT Licensed</span><span class="s3">\n </span><span class="s1">*/var t=/; *([!#$%&amp;'*+.^_`|~0-9A-Za-z-]+) *= *(</span><span class="s3">\&quot;</span><span class="s1">(?:[</span><span class="s3">\\</span><span class="s1">u000b</span><span class="s3">\\</span><span class="s1">u0020</span><span class="s3">\\</span><span class="s1">u0021</span><span class="s3">\\</span><span class="s1">u0023-</span><span class="s3">\\</span><span class="s1">u005b</span><span class="s3">\\</span><span class="s1">u005d-</span><span class="s3">\\</span><span class="s1">u007e</span><span class="s3">\\</span><span class="s1">u0080-</span><span class="s3">\\</span><span class="s1">u00ff]|</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">u000b</span><span class="s3">\\</span><span class="s1">u0020-</span><span class="s3">\\</span><span class="s1">u00ff])*</span><span class="s3">\&quot;</span><span class="s1">|[!#$%&amp;'*+.^_`|~0-9A-Za-z-]+) */g;var a=/^[</span><span class="s3">\\</span><span class="s1">u000b</span><span class="s3">\\</span><span class="s1">u0020-</span><span class="s3">\\</span><span class="s1">u007e</span><span class="s3">\\</span><span class="s1">u0080-</span><span class="s3">\\</span><span class="s1">u00ff]+$/;var n=/^[!#$%&amp;'*+.^_`|~0-9A-Za-z-]+$/;var i=/</span><span class="s3">\\\\</span><span class="s1">([</span><span class="s3">\\</span><span class="s1">u000b</span><span class="s3">\\</span><span class="s1">u0020-</span><span class="s3">\\</span><span class="s1">u00ff])/g;var o=/([</span><span class="s3">\\\\\&quot;</span><span class="s1">])/g;var f=/^[!#$%&amp;'*+.^_`|~0-9A-Za-z-]+</span><span class="s3">\\</span><span class="s1">/[!#$%&amp;'*+.^_`|~0-9A-Za-z-]+$/;r.format=format;r.parse=parse;function format(e){if(!e||typeof e!==</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument obj is required</span><span class="s3">\&quot;</span><span class="s1">)}var r=e.parameters;var t=e.type;if(!t||!f.test(t)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">invalid type</span><span class="s3">\&quot;</span><span class="s1">)}var a=t;if(r&amp;&amp;typeof r===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">){var i;var o=Object.keys(r).sort();for(var u=0;u&lt;o.length;u++){i=o[u];if(!n.test(i)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">invalid parameter name</span><span class="s3">\&quot;</span><span class="s1">)}a+=</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">+i+</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">+qstring(r[i])}}return a}function parse(e){if(!e){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument string is required</span><span class="s3">\&quot;</span><span class="s1">)}var r=typeof e===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">?getcontenttype(e):e;if(typeof r!==</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument string is required to be a string</span><span class="s3">\&quot;</span><span class="s1">)}var a=r.indexOf(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">);var n=a!==-1?r.substr(0,a).trim():r.trim();if(!f.test(n)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">invalid media type</span><span class="s3">\&quot;</span><span class="s1">)}var o=new ContentType(n.toLowerCase());if(a!==-1){var u;var p;var s;t.lastIndex=a;while(p=t.exec(r)){if(p.index!==a){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">invalid parameter format</span><span class="s3">\&quot;</span><span class="s1">)}a+=p[0].length;u=p[1].toLowerCase();s=p[2];if(s[0]==='</span><span class="s3">\&quot;</span><span class="s1">'){s=s.substr(1,s.length-2).replace(i,</span><span class="s3">\&quot;</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)}o.parameters[u]=s}if(a!==r.length){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">invalid parameter format</span><span class="s3">\&quot;</span><span class="s1">)}}return o}function getcontenttype(e){var r;if(typeof e.getHeader===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){r=e.getHeader(</span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">)}else if(typeof e.headers===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">){r=e.headers&amp;&amp;e.headers[</span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">]}if(typeof r!==</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">content-type header is missing from object</span><span class="s3">\&quot;</span><span class="s1">)}return r}function qstring(e){var r=String(e);if(n.test(r)){return r}if(r.length&gt;0&amp;&amp;!a.test(r)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">invalid parameter value</span><span class="s3">\&quot;</span><span class="s1">)}return'</span><span class="s3">\&quot;</span><span class="s1">'+r.replace(o,</span><span class="s3">\&quot;\\\\</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)+'</span><span class="s3">\&quot;</span><span class="s1">'}function ContentType(e){this.parameters=Object.create(null);this.type=e}})();module.exports=e})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var e={};(()=&gt;{var r=e;</span><span class="s3">\n</span><span class="s1">/*!</span><span class="s3">\n </span><span class="s1">* cookie</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2012-2014 Roman Shtylman</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2015 Douglas Christopher Wilson</span><span class="s3">\n </span><span class="s1">* MIT Licensed</span><span class="s3">\n </span><span class="s1">*/r.parse=parse;r.serialize=serialize;var i=decodeURIComponent;var t=encodeURIComponent;var a=/; */;var n=/^[</span><span class="s3">\\</span><span class="s1">u0009</span><span class="s3">\\</span><span class="s1">u0020-</span><span class="s3">\\</span><span class="s1">u007e</span><span class="s3">\\</span><span class="s1">u0080-</span><span class="s3">\\</span><span class="s1">u00ff]+$/;function parse(e,r){if(typeof e!==</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument str must be a string</span><span class="s3">\&quot;</span><span class="s1">)}var t={};var n=r||{};var o=e.split(a);var s=n.decode||i;for(var p=0;p&lt;o.length;p++){var f=o[p];var u=f.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);if(u&lt;0){continue}var v=f.substr(0,u).trim();var c=f.substr(++u,f.length).trim();if('</span><span class="s3">\&quot;</span><span class="s1">'==c[0]){c=c.slice(1,-1)}if(undefined==t[v]){t[v]=tryDecode(c,s)}}return t}function serialize(e,r,i){var a=i||{};var o=a.encode||t;if(typeof o!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option encode is invalid</span><span class="s3">\&quot;</span><span class="s1">)}if(!n.test(e)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument name is invalid</span><span class="s3">\&quot;</span><span class="s1">)}var s=o(r);if(s&amp;&amp;!n.test(s)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument val is invalid</span><span class="s3">\&quot;</span><span class="s1">)}var p=e+</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">+s;if(null!=a.maxAge){var f=a.maxAge-0;if(isNaN(f)||!isFinite(f)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option maxAge is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Max-Age=</span><span class="s3">\&quot;</span><span class="s1">+Math.floor(f)}if(a.domain){if(!n.test(a.domain)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option domain is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Domain=</span><span class="s3">\&quot;</span><span class="s1">+a.domain}if(a.path){if(!n.test(a.path)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option path is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Path=</span><span class="s3">\&quot;</span><span class="s1">+a.path}if(a.expires){if(typeof a.expires.toUTCString!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option expires is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Expires=</span><span class="s3">\&quot;</span><span class="s1">+a.expires.toUTCString()}if(a.httpOnly){p+=</span><span class="s3">\&quot;</span><span class="s1">; HttpOnly</span><span class="s3">\&quot;</span><span class="s1">}if(a.secure){p+=</span><span class="s3">\&quot;</span><span class="s1">; Secure</span><span class="s3">\&quot;</span><span class="s1">}if(a.sameSite){var u=typeof a.sameSite===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?a.sameSite.toLowerCase():a.sameSite;switch(u){case true:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">lax</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Lax</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=None</span><span class="s3">\&quot;</span><span class="s1">;break;default:throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option sameSite is invalid</span><span class="s3">\&quot;</span><span class="s1">)}}return p}function tryDecode(e,r){try{return r(e)}catch(r){return e}}})();module.exports=e})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;var e={695:e=&gt;{</span><span class="s3">\n</span><span class="s1">/*!</span><span class="s3">\n </span><span class="s1">* fresh</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2012 TJ Holowaychuk</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2016-2017 Douglas Christopher Wilson</span><span class="s3">\n </span><span class="s1">* MIT Licensed</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var r=/(?:^|,)</span><span class="s3">\\</span><span class="s1">s*?no-cache</span><span class="s3">\\</span><span class="s1">s*?(?:,|$)/;e.exports=fresh;function fresh(e,a){var t=e[</span><span class="s3">\&quot;</span><span class="s1">if-modified-since</span><span class="s3">\&quot;</span><span class="s1">];var s=e[</span><span class="s3">\&quot;</span><span class="s1">if-none-match</span><span class="s3">\&quot;</span><span class="s1">];if(!t&amp;&amp;!s){return false}var i=e[</span><span class="s3">\&quot;</span><span class="s1">cache-control</span><span class="s3">\&quot;</span><span class="s1">];if(i&amp;&amp;r.test(i)){return false}if(s&amp;&amp;s!==</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){var f=a[</span><span class="s3">\&quot;</span><span class="s1">etag</span><span class="s3">\&quot;</span><span class="s1">];if(!f){return false}var n=true;var u=parseTokenList(s);for(var _=0;_&lt;u.length;_++){var o=u[_];if(o===f||o===</span><span class="s3">\&quot;</span><span class="s1">W/</span><span class="s3">\&quot;</span><span class="s1">+f||</span><span class="s3">\&quot;</span><span class="s1">W/</span><span class="s3">\&quot;</span><span class="s1">+o===f){n=false;break}}if(n){return false}}if(t){var p=a[</span><span class="s3">\&quot;</span><span class="s1">last-modified</span><span class="s3">\&quot;</span><span class="s1">];var v=!p||!(parseHttpDate(p)&lt;=parseHttpDate(t));if(v){return false}}return true}function parseHttpDate(e){var r=e&amp;&amp;Date.parse(e);return typeof r===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">?r:NaN}function parseTokenList(e){var r=0;var a=[];var t=0;for(var s=0,i=e.length;s&lt;i;s++){switch(e.charCodeAt(s)){case 32:if(t===r){t=r=s+1}break;case 44:a.push(e.substring(t,r));t=r=s+1;break;default:r=s+1;break}}a.push(e.substring(t,r));return a}}};var r={};function __nccwpck_require__(a){var t=r[a];if(t!==undefined){return t.exports}var s=r[a]={exports:{}};var i=true;try{e[a](s,s.exports,__nccwpck_require__);i=false}finally{if(i)delete r[a]}return s.exports}if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var a=__nccwpck_require__(695);module.exports=a})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var e={};(()=&gt;{var n=e;Object.defineProperty(n,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});n.pathToRegexp=n.tokensToRegexp=n.regexpToFunction=n.match=n.tokensToFunction=n.compile=n.parse=void 0;function lexer(e){var n=[];var r=0;while(r&lt;e.length){var t=e[r];if(t===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||t===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||t===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">,index:r++,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">OPEN</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">CLOSE</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">){var a=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var i=r+1;while(i&lt;e.length){var o=e.charCodeAt(i);if(o&gt;=48&amp;&amp;o&lt;=57||o&gt;=65&amp;&amp;o&lt;=90||o&gt;=97&amp;&amp;o&lt;=122||o===95){a+=e[i++];continue}break}if(!a)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Missing parameter name at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));n.push({type:</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:a});r=i;continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">){var c=1;var f=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var i=r+1;if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError('Pattern cannot start with </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">at '.concat(i))}while(i&lt;e.length){if(e[i]===</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">){f+=e[i++]+e[i++];continue}if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">){c--;if(c===0){i++;break}}else if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">){c++;if(e[i+1]!==</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Capturing groups are not allowed at </span><span class="s3">\&quot;</span><span class="s1">.concat(i))}}f+=e[i++]}if(c)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Unbalanced pattern at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));if(!f)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Missing pattern at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));n.push({type:</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:f});r=i;continue}n.push({type:</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]})}n.push({type:</span><span class="s3">\&quot;</span><span class="s1">END</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:</span><span class="s3">\&quot;\&quot;</span><span class="s1">});return n}function parse(e,n){if(n===void 0){n={}}var r=lexer(e);var t=n.prefixes,a=t===void 0?</span><span class="s3">\&quot;</span><span class="s1">./</span><span class="s3">\&quot;</span><span class="s1">:t,i=n.delimiter,o=i===void 0?</span><span class="s3">\&quot;</span><span class="s1">/#?</span><span class="s3">\&quot;</span><span class="s1">:i;var c=[];var f=0;var u=0;var p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var tryConsume=function(e){if(u&lt;r.length&amp;&amp;r[u].type===e)return r[u++].value};var mustConsume=function(e){var n=tryConsume(e);if(n!==undefined)return n;var t=r[u],a=t.type,i=t.index;throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Unexpected </span><span class="s3">\&quot;</span><span class="s1">.concat(a,</span><span class="s3">\&quot; </span><span class="s1">at </span><span class="s3">\&quot;</span><span class="s1">).concat(i,</span><span class="s3">\&quot;</span><span class="s1">, expected </span><span class="s3">\&quot;</span><span class="s1">).concat(e))};var consumeText=function(){var e=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var n;while(n=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">)||tryConsume(</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">)){e+=n}return e};var isSafe=function(e){for(var n=0,r=o;n&lt;r.length;n++){var t=r[n];if(e.indexOf(t)&gt;-1)return true}return false};var safePattern=function(e){var n=c[c.length-1];var r=e||(n&amp;&amp;typeof n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?n:</span><span class="s3">\&quot;\&quot;</span><span class="s1">);if(n&amp;&amp;!r){throw new TypeError('Must have text between two parameters, missing text after </span><span class="s3">\&quot;</span><span class="s1">'.concat(n.name,'</span><span class="s3">\&quot;</span><span class="s1">'))}if(!r||isSafe(r))return</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(o),</span><span class="s3">\&quot;</span><span class="s1">]+?</span><span class="s3">\&quot;</span><span class="s1">);return</span><span class="s3">\&quot;</span><span class="s1">(?:(?!</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(r),</span><span class="s3">\&quot;</span><span class="s1">)[^</span><span class="s3">\&quot;</span><span class="s1">).concat(escapeString(o),</span><span class="s3">\&quot;</span><span class="s1">])+?</span><span class="s3">\&quot;</span><span class="s1">)};while(u&lt;r.length){var v=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">);var s=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">);var d=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">);if(s||d){var g=v||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;if(a.indexOf(g)===-1){p+=g;g=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}if(p){c.push(p);p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}c.push({name:s||f++,prefix:g,suffix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,pattern:d||safePattern(g),modifier:tryConsume(</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">});continue}var x=v||tryConsume(</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">);if(x){p+=x;continue}if(p){c.push(p);p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}var h=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">OPEN</span><span class="s3">\&quot;</span><span class="s1">);if(h){var g=consumeText();var l=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var m=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var T=consumeText();mustConsume(</span><span class="s3">\&quot;</span><span class="s1">CLOSE</span><span class="s3">\&quot;</span><span class="s1">);c.push({name:l||(m?f++:</span><span class="s3">\&quot;\&quot;</span><span class="s1">),pattern:l&amp;&amp;!m?safePattern(g):m,prefix:g,suffix:T,modifier:tryConsume(</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">});continue}mustConsume(</span><span class="s3">\&quot;</span><span class="s1">END</span><span class="s3">\&quot;</span><span class="s1">)}return c}n.parse=parse;function compile(e,n){return tokensToFunction(parse(e,n),n)}n.compile=compile;function tokensToFunction(e,n){if(n===void 0){n={}}var r=flags(n);var t=n.encode,a=t===void 0?function(e){return e}:t,i=n.validate,o=i===void 0?true:i;var c=e.map((function(e){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">){return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(e.pattern,</span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">),r)}}));return function(n){var r=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(var t=0;t&lt;e.length;t++){var i=e[t];if(typeof i===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){r+=i;continue}var f=n?n[i.name]:undefined;var u=i.modifier===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">||i.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">;var p=i.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||i.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">;if(Array.isArray(f)){if(!p){throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to not repeat, but got an array'))}if(f.length===0){if(u)continue;throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to not be empty'))}for(var v=0;v&lt;f.length;v++){var s=a(f[v],i);if(o&amp;&amp;!c[t].test(s)){throw new TypeError('Expected all </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to match </span><span class="s3">\&quot;</span><span class="s1">').concat(i.pattern,'</span><span class="s3">\&quot;</span><span class="s1">, but got </span><span class="s3">\&quot;</span><span class="s1">').concat(s,'</span><span class="s3">\&quot;</span><span class="s1">'))}r+=i.prefix+s+i.suffix}continue}if(typeof f===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||typeof f===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">){var s=a(String(f),i);if(o&amp;&amp;!c[t].test(s)){throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to match </span><span class="s3">\&quot;</span><span class="s1">').concat(i.pattern,'</span><span class="s3">\&quot;</span><span class="s1">, but got </span><span class="s3">\&quot;</span><span class="s1">').concat(s,'</span><span class="s3">\&quot;</span><span class="s1">'))}r+=i.prefix+s+i.suffix;continue}if(u)continue;var d=p?</span><span class="s3">\&quot;</span><span class="s1">an array</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">a string</span><span class="s3">\&quot;</span><span class="s1">;throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to be ').concat(d))}return r}}n.tokensToFunction=tokensToFunction;function match(e,n){var r=[];var t=pathToRegexp(e,r,n);return regexpToFunction(t,r,n)}n.match=match;function regexpToFunction(e,n,r){if(r===void 0){r={}}var t=r.decode,a=t===void 0?function(e){return e}:t;return function(r){var t=e.exec(r);if(!t)return false;var i=t[0],o=t.index;var c=Object.create(null);var _loop_1=function(e){if(t[e]===undefined)return</span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">;var r=n[e-1];if(r.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||r.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">){c[r.name]=t[e].split(r.prefix+r.suffix).map((function(e){return a(e,r)}))}else{c[r.name]=a(t[e],r)}};for(var f=1;f&lt;t.length;f++){_loop_1(f)}return{path:i,index:o,params:c}}}n.regexpToFunction=regexpToFunction;function escapeString(e){return e.replace(/([.+*?=^!:${}()[</span><span class="s3">\\</span><span class="s1">]|/</span><span class="s3">\\\\</span><span class="s1">])/g,</span><span class="s3">\&quot;\\\\</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)}function flags(e){return e&amp;&amp;e.sensitive?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">}function regexpToRegexp(e,n){if(!n)return e;var r=/</span><span class="s3">\\</span><span class="s1">((?:</span><span class="s3">\\</span><span class="s1">?&lt;(.*?)&gt;)?(?!</span><span class="s3">\\</span><span class="s1">?)/g;var t=0;var a=r.exec(e.source);while(a){n.push({name:a[1]||t++,prefix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,suffix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,modifier:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,pattern:</span><span class="s3">\&quot;\&quot;</span><span class="s1">});a=r.exec(e.source)}return e}function arrayToRegexp(e,n,r){var t=e.map((function(e){return pathToRegexp(e,n,r).source}));return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(t.join(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">),flags(r))}function stringToRegexp(e,n,r){return tokensToRegexp(parse(e,r),n,r)}function tokensToRegexp(e,n,r){if(r===void 0){r={}}var t=r.strict,a=t===void 0?false:t,i=r.start,o=i===void 0?true:i,c=r.end,f=c===void 0?true:c,u=r.encode,p=u===void 0?function(e){return e}:u,v=r.delimiter,s=v===void 0?</span><span class="s3">\&quot;</span><span class="s1">/#?</span><span class="s3">\&quot;</span><span class="s1">:v,d=r.endsWith,g=d===void 0?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:d;var x=</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(g),</span><span class="s3">\&quot;</span><span class="s1">]|$</span><span class="s3">\&quot;</span><span class="s1">);var h=</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(s),</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);var l=o?</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(var m=0,T=e;m&lt;T.length;m++){var E=T[m];if(typeof E===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){l+=escapeString(p(E))}else{var w=escapeString(p(E.prefix));var y=escapeString(p(E.suffix));if(E.pattern){if(n)n.push(E);if(w||y){if(E.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){var R=E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;\&quot;</span><span class="s1">;l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w,</span><span class="s3">\&quot;</span><span class="s1">((?:</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)(?:</span><span class="s3">\&quot;</span><span class="s1">).concat(y).concat(w,</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">))*)</span><span class="s3">\&quot;</span><span class="s1">).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(R)}else{l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w,</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}else{if(E.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError('Can not repeat </span><span class="s3">\&quot;</span><span class="s1">'.concat(E.name,'</span><span class="s3">\&quot; </span><span class="s1">without a prefix and suffix'))}l+=</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">.concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}else{l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}}if(f){if(!a)l+=</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);l+=!r.endsWith?</span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">.concat(x,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)}else{var A=e[e.length-1];var _=typeof A===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?h.indexOf(A[A.length-1])&gt;-1:A===undefined;if(!a){l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">).concat(x,</span><span class="s3">\&quot;</span><span class="s1">))?</span><span class="s3">\&quot;</span><span class="s1">)}if(!_){l+=</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">).concat(x,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)}}return new RegExp(l,flags(r))}n.tokensToRegexp=tokensToRegexp;function pathToRegexp(e,n,r){if(e instanceof RegExp)return regexpToRegexp(e,n);if(Array.isArray(e))return arrayToRegexp(e,n,r);return stringToRegexp(e,n,r)}n.pathToRegexp=pathToRegexp})();module.exports=e})();&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ServerRuntime } from '../types'</span><span class="s3">\n\n</span><span class="s1">export const TEXT_PLAIN_CONTENT_TYPE_HEADER = 'text/plain'</span><span class="s3">\n</span><span class="s1">export const HTML_CONTENT_TYPE_HEADER = 'text/html; charset=utf-8'</span><span class="s3">\n</span><span class="s1">export const JSON_CONTENT_TYPE_HEADER = 'application/json; charset=utf-8'</span><span class="s3">\n</span><span class="s1">export const NEXT_QUERY_PARAM_PREFIX = 'nxtP'</span><span class="s3">\n</span><span class="s1">export const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI'</span><span class="s3">\n\n</span><span class="s1">export const MATCHED_PATH_HEADER = 'x-matched-path'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER =</span><span class="s3">\n  </span><span class="s1">'x-prerender-revalidate-if-generated'</span><span class="s3">\n\n</span><span class="s1">export const RSC_PREFETCH_SUFFIX = '.prefetch.rsc'</span><span class="s3">\n</span><span class="s1">export const RSC_SEGMENTS_DIR_SUFFIX = '.segments'</span><span class="s3">\n</span><span class="s1">export const RSC_SEGMENT_SUFFIX = '.segment.rsc'</span><span class="s3">\n</span><span class="s1">export const RSC_SUFFIX = '.rsc'</span><span class="s3">\n</span><span class="s1">export const ACTION_SUFFIX = '.action'</span><span class="s3">\n</span><span class="s1">export const NEXT_DATA_SUFFIX = '.json'</span><span class="s3">\n</span><span class="s1">export const NEXT_META_SUFFIX = '.meta'</span><span class="s3">\n</span><span class="s1">export const NEXT_BODY_SUFFIX = '.body'</span><span class="s3">\n\n</span><span class="s1">export const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags'</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags'</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER =</span><span class="s3">\n  </span><span class="s1">'x-next-revalidate-tag-token'</span><span class="s3">\n\n</span><span class="s1">export const NEXT_RESUME_HEADER = 'next-resume'</span><span class="s3">\n\n</span><span class="s1">// if these change make sure we update the related</span><span class="s3">\n</span><span class="s1">// documentation as well</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_TAG_MAX_ITEMS = 128</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_TAG_MAX_LENGTH = 256</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_'</span><span class="s3">\n\n</span><span class="s1">// in seconds</span><span class="s3">\n</span><span class="s1">export const CACHE_ONE_YEAR = 31536000</span><span class="s3">\n\n</span><span class="s1">// in seconds, represents revalidate=false. I.e. never revaliate.</span><span class="s3">\n</span><span class="s1">// We use this value since it can be represented as a V8 SMI for optimal performance.</span><span class="s3">\n</span><span class="s1">// It can also be serialized as JSON if it ever leaks accidentally as an actual value.</span><span class="s3">\n</span><span class="s1">export const INFINITE_CACHE = 0xfffffffe</span><span class="s3">\n\n</span><span class="s1">// Patterns to detect middleware files</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_FILENAME = 'middleware'</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`</span><span class="s3">\n\n</span><span class="s1">// Pattern to detect instrumentation hooks file</span><span class="s3">\n</span><span class="s1">export const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation'</span><span class="s3">\n\n</span><span class="s1">// Because on Windows absolute paths in the generated code can break because of numbers, eg 1 in the path,</span><span class="s3">\n</span><span class="s1">// we have to use a private alias</span><span class="s3">\n</span><span class="s1">export const PAGES_DIR_ALIAS = 'private-next-pages'</span><span class="s3">\n</span><span class="s1">export const DOT_NEXT_ALIAS = 'private-dot-next'</span><span class="s3">\n</span><span class="s1">export const ROOT_DIR_ALIAS = 'private-next-root-dir'</span><span class="s3">\n</span><span class="s1">export const APP_DIR_ALIAS = 'private-next-app-dir'</span><span class="s3">\n</span><span class="s1">export const RSC_MOD_REF_PROXY_ALIAS = 'private-next-rsc-mod-ref-proxy'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference'</span><span class="s3">\n</span><span class="s1">export const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper'</span><span class="s3">\n</span><span class="s1">export const RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS =</span><span class="s3">\n  </span><span class="s1">'private-next-rsc-track-dynamic-import'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_CLIENT_WRAPPER_ALIAS =</span><span class="s3">\n  </span><span class="s1">'private-next-rsc-action-client-wrapper'</span><span class="s3">\n\n</span><span class="s1">export const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`</span><span class="s3">\n\n</span><span class="s1">export const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`</span><span class="s3">\n\n</span><span class="s1">export const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_EXPORT_ERROR = `pages with </span><span class="s3">\\</span><span class="s1">`getServerSideProps</span><span class="s3">\\</span><span class="s1">` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`</span><span class="s3">\n\n</span><span class="s1">export const GSP_NO_RETURNED_VALUE =</span><span class="s3">\n  </span><span class="s1">'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?'</span><span class="s3">\n</span><span class="s1">export const GSSP_NO_RETURNED_VALUE =</span><span class="s3">\n  </span><span class="s1">'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?'</span><span class="s3">\n\n</span><span class="s1">export const UNSTABLE_REVALIDATE_RENAME_ERROR =</span><span class="s3">\n  </span><span class="s1">'The `unstable_revalidate` property is available for general use.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n  </span><span class="s1">'Please use `revalidate` instead.'</span><span class="s3">\n\n</span><span class="s1">export const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`</span><span class="s3">\n\n</span><span class="s1">export const NON_STANDARD_NODE_ENV = `You are using a non-standard </span><span class="s3">\&quot;</span><span class="s1">NODE_ENV</span><span class="s3">\&quot; </span><span class="s1">value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`</span><span class="s3">\n\n</span><span class="s1">export const SSG_FALLBACK_EXPORT_ERROR = `Pages with </span><span class="s3">\\</span><span class="s1">`fallback</span><span class="s3">\\</span><span class="s1">` enabled in </span><span class="s3">\\</span><span class="s1">`getStaticPaths</span><span class="s3">\\</span><span class="s1">` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`</span><span class="s3">\n\n</span><span class="s1">export const ESLINT_DEFAULT_DIRS = ['app', 'pages', 'components', 'lib', 'src']</span><span class="s3">\n\n</span><span class="s1">export const SERVER_RUNTIME: Record&lt;string, ServerRuntime&gt; = {</span><span class="s3">\n  </span><span class="s1">edge: 'edge',</span><span class="s3">\n  </span><span class="s1">experimentalEdge: 'experimental-edge',</span><span class="s3">\n  </span><span class="s1">nodejs: 'nodejs',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The names of the webpack layers. These layers are the primitives for the</span><span class="s3">\n </span><span class="s1">* webpack chunks.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const WEBPACK_LAYERS_NAMES = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the shared code between the client and server bundles.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">shared: 'shared',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for server-only runtime and picking up `react-server` export conditions.</span><span class="s3">\n   </span><span class="s1">* Including app router RSC pages and app router custom routes and metadata routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">reactServerComponents: 'rsc',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Server Side Rendering layer for app (ssr).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">serverSideRendering: 'ssr',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for actions.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">actionBrowser: 'action-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Node.js bundle layer for the API routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apiNode: 'api-node',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Edge Lite bundle layer for the API routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apiEdge: 'api-edge',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the middleware code.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middleware: 'middleware',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the instrumentation hooks.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">instrument: 'instrument',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for assets on the edge.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">edgeAsset: 'edge-asset',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for App directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">appPagesBrowser: 'app-pages-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirBrowser: 'pages-dir-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Edge Lite bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirEdge: 'pages-dir-edge',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Node.js bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirNode: 'pages-dir-node',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export type WebpackLayerName =</span><span class="s3">\n  </span><span class="s1">(typeof WEBPACK_LAYERS_NAMES)[keyof typeof WEBPACK_LAYERS_NAMES]</span><span class="s3">\n\n</span><span class="s1">const WEBPACK_LAYERS = {</span><span class="s3">\n  </span><span class="s1">...WEBPACK_LAYERS_NAMES,</span><span class="s3">\n  </span><span class="s1">GROUP: {</span><span class="s3">\n    </span><span class="s1">builtinReact: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">serverOnly: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.instrument,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.middleware,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">neutralTarget: [</span><span class="s3">\n      </span><span class="s1">// pages api</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.apiNode,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.apiEdge,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">clientOnly: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">bundled: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.shared,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.instrument,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.middleware,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">appPages: [</span><span class="s3">\n      </span><span class="s1">// app router pages and layouts</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const WEBPACK_RESOURCE_QUERIES = {</span><span class="s3">\n  </span><span class="s1">edgeSSREntry: '__next_edge_ssr_entry__',</span><span class="s3">\n  </span><span class="s1">metadata: '__next_metadata__',</span><span class="s3">\n  </span><span class="s1">metadataRoute: '__next_metadata_route__',</span><span class="s3">\n  </span><span class="s1">metadataImageMeta: '__next_metadata_image_meta__',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { WEBPACK_LAYERS, WEBPACK_RESOURCE_QUERIES }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from 'path'</span><span class="s3">\n</span><span class="s1">import { pathToFileURL } from 'url'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The path for a dynamic route must be URLs with a valid scheme.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* When an absolute Windows path is passed to it, it interprets the beginning of the path as a protocol (`C:`).</span><span class="s3">\n </span><span class="s1">* Therefore, it is important to always construct a complete path.</span><span class="s3">\n </span><span class="s1">* @param dir File directory</span><span class="s3">\n </span><span class="s1">* @param filePath Absolute or relative path</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const formatDynamicImportPath = (dir: string, filePath: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">const absoluteFilePath = path.isAbsolute(filePath)</span><span class="s3">\n    </span><span class="s1">? filePath</span><span class="s3">\n    </span><span class="s1">: path.join(dir, filePath)</span><span class="s3">\n  </span><span class="s1">const formattedFilePath = pathToFileURL(absoluteFilePath).toString()</span><span class="s3">\n\n  </span><span class="s1">return formattedFilePath</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { CookieSerializeOptions } from 'next/dist/compiled/cookie'</span><span class="s3">\n</span><span class="s1">import type { NextApiResponse } from '../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">import { HeadersAdapter } from '../web/spec-extension/adapters/headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_HEADER,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NodeSpan } from '../lib/trace/constants'</span><span class="s3">\n\n</span><span class="s1">export type NextApiRequestCookies = Partial&lt;{ [key: string]: string }&gt;</span><span class="s3">\n</span><span class="s1">export type NextApiRequestQuery = Partial&lt;{ [key: string]: string | string[] }&gt;</span><span class="s3">\n\n</span><span class="s1">export type __ApiPreviewProps = {</span><span class="s3">\n  </span><span class="s1">previewModeId: string</span><span class="s3">\n  </span><span class="s1">previewModeEncryptionKey: string</span><span class="s3">\n  </span><span class="s1">previewModeSigningKey: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function wrapApiHandler&lt;T extends (...args: any[]) =&gt; any&gt;(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">handler: T</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">return ((...args) =&gt; {</span><span class="s3">\n    </span><span class="s1">getTracer().setRootSpanAttribute('next.route', page)</span><span class="s3">\n    </span><span class="s1">// Call API route method</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">NodeSpan.runHandler,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">spanName: `executing api route (pages) ${page}`,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">() =&gt; handler(...args)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param statusCode `HTTP` status code of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sendStatusCode(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusCode: number</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">res.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param [statusOrUrl] `HTTP` status code of redirect</span><span class="s3">\n </span><span class="s1">* @param url URL of redirect</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function redirect(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusOrUrl: string | number,</span><span class="s3">\n  </span><span class="s1">url?: string</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof statusOrUrl === 'string') {</span><span class="s3">\n    </span><span class="s1">url = statusOrUrl</span><span class="s3">\n    </span><span class="s1">statusOrUrl = 307</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">res.writeHead(statusOrUrl, { Location: url })</span><span class="s3">\n  </span><span class="s1">res.write(url)</span><span class="s3">\n  </span><span class="s1">res.end()</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function checkIsOnDemandRevalidate(</span><span class="s3">\n  </span><span class="s1">req: Request | IncomingMessage | BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">isOnDemandRevalidate: boolean</span><span class="s3">\n  </span><span class="s1">revalidateOnlyGenerated: boolean</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const headers = HeadersAdapter.from(req.headers)</span><span class="s3">\n\n  </span><span class="s1">const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)</span><span class="s3">\n  </span><span class="s1">const isOnDemandRevalidate = previewModeId === previewProps.previewModeId</span><span class="s3">\n\n  </span><span class="s1">const revalidateOnlyGenerated = headers.has(</span><span class="s3">\n    </span><span class="s1">PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return { isOnDemandRevalidate, revalidateOnlyGenerated }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`</span><span class="s3">\n</span><span class="s1">export const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`</span><span class="s3">\n\n</span><span class="s1">export const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024</span><span class="s3">\n\n</span><span class="s1">export const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)</span><span class="s3">\n</span><span class="s1">export const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)</span><span class="s3">\n\n</span><span class="s1">export function clearPreviewData&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">path?: string</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (SYMBOL_CLEARED_COOKIES in res) {</span><span class="s3">\n    </span><span class="s1">return res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { serialize } =</span><span class="s3">\n    </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n  </span><span class="s1">const previous = res.getHeader('Set-Cookie')</span><span class="s3">\n  </span><span class="s1">res.setHeader(`Set-Cookie`, [</span><span class="s3">\n    </span><span class="s1">...(typeof previous === 'string'</span><span class="s3">\n      </span><span class="s1">? [previous]</span><span class="s3">\n      </span><span class="s1">: Array.isArray(previous)</span><span class="s3">\n        </span><span class="s1">? previous</span><span class="s3">\n        </span><span class="s1">: []),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {</span><span class="s3">\n      </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n      </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n      </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n      </span><span class="s1">expires: new Date(0),</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_DATA, '', {</span><span class="s3">\n      </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n      </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n      </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n      </span><span class="s1">expires: new Date(0),</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {</span><span class="s3">\n    </span><span class="s1">value: true,</span><span class="s3">\n    </span><span class="s1">enumerable: false,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Custom error class</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ApiError extends Error {</span><span class="s3">\n  </span><span class="s1">readonly statusCode: number</span><span class="s3">\n\n  </span><span class="s1">constructor(statusCode: number, message: string) {</span><span class="s3">\n    </span><span class="s1">super(message)</span><span class="s3">\n    </span><span class="s1">this.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sends error in `response`</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param statusCode of response</span><span class="s3">\n </span><span class="s1">* @param message of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sendError(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusCode: number,</span><span class="s3">\n  </span><span class="s1">message: string</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">res.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">res.statusMessage = message</span><span class="s3">\n  </span><span class="s1">res.end(message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface LazyProps {</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Execute getter function only if its needed</span><span class="s3">\n </span><span class="s1">* @param LazyProps `req` and `params` for lazyProp</span><span class="s3">\n </span><span class="s1">* @param prop name of property</span><span class="s3">\n </span><span class="s1">* @param getter function to get data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setLazyProp&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">{ req }: LazyProps,</span><span class="s3">\n  </span><span class="s1">prop: string,</span><span class="s3">\n  </span><span class="s1">getter: () =&gt; T</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const opts = { configurable: true, enumerable: true }</span><span class="s3">\n  </span><span class="s1">const optsReset = { ...opts, writable: true }</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(req, prop, {</span><span class="s3">\n    </span><span class="s1">...opts,</span><span class="s3">\n    </span><span class="s1">get: () =&gt; {</span><span class="s3">\n      </span><span class="s1">const value = getter()</span><span class="s3">\n      </span><span class="s1">// we set the property on the object to avoid recalculating it</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(req, prop, { ...optsReset, value })</span><span class="s3">\n      </span><span class="s1">return value</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set: (value) =&gt; {</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(req, prop, { ...optsReset, value })</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { NextApiResponse } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { checkIsOnDemandRevalidate } from '../.'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../.'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest, BaseNextResponse } from '../../base-http'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../../types'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">clearPreviewData,</span><span class="s3">\n  </span><span class="s1">COOKIE_NAME_PRERENDER_BYPASS,</span><span class="s3">\n  </span><span class="s1">COOKIE_NAME_PRERENDER_DATA,</span><span class="s3">\n  </span><span class="s1">SYMBOL_PREVIEW_DATA,</span><span class="s3">\n</span><span class="s1">} from '../index'</span><span class="s3">\n</span><span class="s1">import { RequestCookies } from '../../web/spec-extension/cookies'</span><span class="s3">\n</span><span class="s1">import { HeadersAdapter } from '../../web/spec-extension/adapters/headers'</span><span class="s3">\n\n</span><span class="s1">export function tryGetPreviewData(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage | BaseNextRequest | Request,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse | BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">options: __ApiPreviewProps,</span><span class="s3">\n  </span><span class="s1">multiZoneDraftMode: boolean</span><span class="s3">\n</span><span class="s1">): PreviewData {</span><span class="s3">\n  </span><span class="s1">// if an On-Demand revalidation is being done preview mode</span><span class="s3">\n  </span><span class="s1">// is disabled</span><span class="s3">\n  </span><span class="s1">if (options &amp;&amp; checkIsOnDemandRevalidate(req, options).isOnDemandRevalidate) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Read cached preview data if present</span><span class="s3">\n  </span><span class="s1">// TODO: use request metadata instead of a symbol</span><span class="s3">\n  </span><span class="s1">if (SYMBOL_PREVIEW_DATA in req) {</span><span class="s3">\n    </span><span class="s1">return (req as any)[SYMBOL_PREVIEW_DATA] as any</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const headers = HeadersAdapter.from(req.headers)</span><span class="s3">\n  </span><span class="s1">const cookies = new RequestCookies(headers)</span><span class="s3">\n\n  </span><span class="s1">const previewModeId = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value</span><span class="s3">\n  </span><span class="s1">const tokenPreviewData = cookies.get(COOKIE_NAME_PRERENDER_DATA)?.value</span><span class="s3">\n\n  </span><span class="s1">// Case: preview mode cookie set but data cookie is not set</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">previewModeId &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!tokenPreviewData &amp;&amp;</span><span class="s3">\n    </span><span class="s1">previewModeId === options.previewModeId</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// This is </span><span class="s3">\&quot;</span><span class="s1">Draft Mode</span><span class="s3">\&quot; </span><span class="s1">which doesn't use</span><span class="s3">\n    </span><span class="s1">// previewData, so we return an empty object</span><span class="s3">\n    </span><span class="s1">// for backwards compat with </span><span class="s3">\&quot;</span><span class="s1">Preview Mode</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n    </span><span class="s1">const data = {}</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(req, SYMBOL_PREVIEW_DATA, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">enumerable: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return data</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: neither cookie is set.</span><span class="s3">\n  </span><span class="s1">if (!previewModeId &amp;&amp; !tokenPreviewData) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: one cookie is set, but not the other.</span><span class="s3">\n  </span><span class="s1">if (!previewModeId || !tokenPreviewData) {</span><span class="s3">\n    </span><span class="s1">if (!multiZoneDraftMode) {</span><span class="s3">\n      </span><span class="s1">clearPreviewData(res as NextApiResponse)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: preview session is for an old build.</span><span class="s3">\n  </span><span class="s1">if (previewModeId !== options.previewModeId) {</span><span class="s3">\n    </span><span class="s1">if (!multiZoneDraftMode) {</span><span class="s3">\n      </span><span class="s1">clearPreviewData(res as NextApiResponse)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let encryptedPreviewData: {</span><span class="s3">\n    </span><span class="s1">data: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const jsonwebtoken =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/jsonwebtoken') as typeof import('next/dist/compiled/jsonwebtoken')</span><span class="s3">\n    </span><span class="s1">encryptedPreviewData = jsonwebtoken.verify(</span><span class="s3">\n      </span><span class="s1">tokenPreviewData,</span><span class="s3">\n      </span><span class="s1">options.previewModeSigningKey</span><span class="s3">\n    </span><span class="s1">) as typeof encryptedPreviewData</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">// TODO: warn</span><span class="s3">\n    </span><span class="s1">clearPreviewData(res as NextApiResponse)</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { decryptWithSecret } =</span><span class="s3">\n    </span><span class="s1">require('../../crypto-utils') as typeof import('../../crypto-utils')</span><span class="s3">\n  </span><span class="s1">const decryptedPreviewData = decryptWithSecret(</span><span class="s3">\n    </span><span class="s1">Buffer.from(options.previewModeEncryptionKey),</span><span class="s3">\n    </span><span class="s1">encryptedPreviewData.data</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// TODO: strict runtime type checking</span><span class="s3">\n    </span><span class="s1">const data = JSON.parse(decryptedPreviewData)</span><span class="s3">\n    </span><span class="s1">// Cache lookup</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(req, SYMBOL_PREVIEW_DATA, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">enumerable: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return data</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import crypto from 'crypto'</span><span class="s3">\n\n</span><span class="s1">// Background:</span><span class="s3">\n</span><span class="s1">// https://security.stackexchange.com/questions/184305/why-would-i-ever-use-aes-256-cbc-if-aes-256-gcm-is-more-secure</span><span class="s3">\n\n</span><span class="s1">const CIPHER_ALGORITHM = `aes-256-gcm`,</span><span class="s3">\n  </span><span class="s1">CIPHER_KEY_LENGTH = 32, // https://stackoverflow.com/a/28307668/4397028</span><span class="s3">\n  </span><span class="s1">CIPHER_IV_LENGTH = 16, // https://stackoverflow.com/a/28307668/4397028</span><span class="s3">\n  </span><span class="s1">CIPHER_TAG_LENGTH = 16,</span><span class="s3">\n  </span><span class="s1">CIPHER_SALT_LENGTH = 64</span><span class="s3">\n\n</span><span class="s1">const PBKDF2_ITERATIONS = 100_000 // https://support.1password.com/pbkdf2/</span><span class="s3">\n\n</span><span class="s1">export function encryptWithSecret(secret: Buffer, data: string): string {</span><span class="s3">\n  </span><span class="s1">const iv = crypto.randomBytes(CIPHER_IV_LENGTH)</span><span class="s3">\n  </span><span class="s1">const salt = crypto.randomBytes(CIPHER_SALT_LENGTH)</span><span class="s3">\n\n  </span><span class="s1">// https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest</span><span class="s3">\n  </span><span class="s1">const key = crypto.pbkdf2Sync(</span><span class="s3">\n    </span><span class="s1">secret,</span><span class="s3">\n    </span><span class="s1">salt,</span><span class="s3">\n    </span><span class="s1">PBKDF2_ITERATIONS,</span><span class="s3">\n    </span><span class="s1">CIPHER_KEY_LENGTH,</span><span class="s3">\n    </span><span class="s1">`sha512`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const cipher = crypto.createCipheriv(CIPHER_ALGORITHM, key, iv)</span><span class="s3">\n  </span><span class="s1">const encrypted = Buffer.concat([cipher.update(data, `utf8`), cipher.final()])</span><span class="s3">\n\n  </span><span class="s1">// https://nodejs.org/api/crypto.html#crypto_cipher_getauthtag</span><span class="s3">\n  </span><span class="s1">const tag = cipher.getAuthTag()</span><span class="s3">\n\n  </span><span class="s1">return Buffer.concat([</span><span class="s3">\n    </span><span class="s1">// Data as required by:</span><span class="s3">\n    </span><span class="s1">// Salt for Key: https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest</span><span class="s3">\n    </span><span class="s1">// IV: https://nodejs.org/api/crypto.html#crypto_class_decipher</span><span class="s3">\n    </span><span class="s1">// Tag: https://nodejs.org/api/crypto.html#crypto_decipher_setauthtag_buffer</span><span class="s3">\n    </span><span class="s1">salt,</span><span class="s3">\n    </span><span class="s1">iv,</span><span class="s3">\n    </span><span class="s1">tag,</span><span class="s3">\n    </span><span class="s1">encrypted,</span><span class="s3">\n  </span><span class="s1">]).toString(`hex`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function decryptWithSecret(</span><span class="s3">\n  </span><span class="s1">secret: Buffer,</span><span class="s3">\n  </span><span class="s1">encryptedData: string</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const buffer = Buffer.from(encryptedData, `hex`)</span><span class="s3">\n\n  </span><span class="s1">const salt = buffer.slice(0, CIPHER_SALT_LENGTH)</span><span class="s3">\n  </span><span class="s1">const iv = buffer.slice(</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH,</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const tag = buffer.slice(</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH,</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const encrypted = buffer.slice(</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest</span><span class="s3">\n  </span><span class="s1">const key = crypto.pbkdf2Sync(</span><span class="s3">\n    </span><span class="s1">secret,</span><span class="s3">\n    </span><span class="s1">salt,</span><span class="s3">\n    </span><span class="s1">PBKDF2_ITERATIONS,</span><span class="s3">\n    </span><span class="s1">CIPHER_KEY_LENGTH,</span><span class="s3">\n    </span><span class="s1">`sha512`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const decipher = crypto.createDecipheriv(CIPHER_ALGORITHM, key, iv)</span><span class="s3">\n  </span><span class="s1">decipher.setAuthTag(tag)</span><span class="s3">\n\n  </span><span class="s1">return decipher.update(encrypted) + decipher.final(`utf8`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { CacheFs } from '../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">import fs from 'fs'</span><span class="s3">\n\n</span><span class="s1">export const nodeFs: CacheFs = {</span><span class="s3">\n  </span><span class="s1">existsSync: fs.existsSync,</span><span class="s3">\n  </span><span class="s1">readFile: fs.promises.readFile,</span><span class="s3">\n  </span><span class="s1">readFileSync: fs.readFileSync,</span><span class="s3">\n  </span><span class="s1">writeFile: (f, d) =&gt; fs.promises.writeFile(f, d),</span><span class="s3">\n  </span><span class="s1">mkdir: (dir) =&gt; fs.promises.mkdir(dir, { recursive: true }),</span><span class="s3">\n  </span><span class="s1">stat: (f) =&gt; fs.promises.stat(f),</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Contains predefined constants for the trace span name in next/server.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Currently, next/server/tracer is internal implementation only for tracking</span><span class="s3">\n </span><span class="s1">* next.js's implementation only with known span names defined here.</span><span class="s3">\n </span><span class="s1">**/</span><span class="s3">\n\n</span><span class="s1">// eslint typescript has a bug with TS enums</span><span class="s3">\n</span><span class="s1">/* eslint-disable no-shadow */</span><span class="s3">\n\n</span><span class="s1">enum BaseServerSpan {</span><span class="s3">\n  </span><span class="s1">handleRequest = 'BaseServer.handleRequest',</span><span class="s3">\n  </span><span class="s1">run = 'BaseServer.run',</span><span class="s3">\n  </span><span class="s1">pipe = 'BaseServer.pipe',</span><span class="s3">\n  </span><span class="s1">getStaticHTML = 'BaseServer.getStaticHTML',</span><span class="s3">\n  </span><span class="s1">render = 'BaseServer.render',</span><span class="s3">\n  </span><span class="s1">renderToResponseWithComponents = 'BaseServer.renderToResponseWithComponents',</span><span class="s3">\n  </span><span class="s1">renderToResponse = 'BaseServer.renderToResponse',</span><span class="s3">\n  </span><span class="s1">renderToHTML = 'BaseServer.renderToHTML',</span><span class="s3">\n  </span><span class="s1">renderError = 'BaseServer.renderError',</span><span class="s3">\n  </span><span class="s1">renderErrorToResponse = 'BaseServer.renderErrorToResponse',</span><span class="s3">\n  </span><span class="s1">renderErrorToHTML = 'BaseServer.renderErrorToHTML',</span><span class="s3">\n  </span><span class="s1">render404 = 'BaseServer.render404',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum LoadComponentsSpan {</span><span class="s3">\n  </span><span class="s1">loadDefaultErrorComponents = 'LoadComponents.loadDefaultErrorComponents',</span><span class="s3">\n  </span><span class="s1">loadComponents = 'LoadComponents.loadComponents',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NextServerSpan {</span><span class="s3">\n  </span><span class="s1">getRequestHandler = 'NextServer.getRequestHandler',</span><span class="s3">\n  </span><span class="s1">getServer = 'NextServer.getServer',</span><span class="s3">\n  </span><span class="s1">getServerRequestHandler = 'NextServer.getServerRequestHandler',</span><span class="s3">\n  </span><span class="s1">createServer = 'createServer.createServer',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NextNodeServerSpan {</span><span class="s3">\n  </span><span class="s1">compression = 'NextNodeServer.compression',</span><span class="s3">\n  </span><span class="s1">getBuildId = 'NextNodeServer.getBuildId',</span><span class="s3">\n  </span><span class="s1">createComponentTree = 'NextNodeServer.createComponentTree',</span><span class="s3">\n  </span><span class="s1">clientComponentLoading = 'NextNodeServer.clientComponentLoading',</span><span class="s3">\n  </span><span class="s1">getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule',</span><span class="s3">\n  </span><span class="s1">generateStaticRoutes = 'NextNodeServer.generateStaticRoutes',</span><span class="s3">\n  </span><span class="s1">generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes',</span><span class="s3">\n  </span><span class="s1">generatePublicRoutes = 'NextNodeServer.generatePublicRoutes',</span><span class="s3">\n  </span><span class="s1">generateImageRoutes = 'NextNodeServer.generateImageRoutes.route',</span><span class="s3">\n  </span><span class="s1">sendRenderResult = 'NextNodeServer.sendRenderResult',</span><span class="s3">\n  </span><span class="s1">proxyRequest = 'NextNodeServer.proxyRequest',</span><span class="s3">\n  </span><span class="s1">runApi = 'NextNodeServer.runApi',</span><span class="s3">\n  </span><span class="s1">render = 'NextNodeServer.render',</span><span class="s3">\n  </span><span class="s1">renderHTML = 'NextNodeServer.renderHTML',</span><span class="s3">\n  </span><span class="s1">imageOptimizer = 'NextNodeServer.imageOptimizer',</span><span class="s3">\n  </span><span class="s1">getPagePath = 'NextNodeServer.getPagePath',</span><span class="s3">\n  </span><span class="s1">getRoutesManifest = 'NextNodeServer.getRoutesManifest',</span><span class="s3">\n  </span><span class="s1">findPageComponents = 'NextNodeServer.findPageComponents',</span><span class="s3">\n  </span><span class="s1">getFontManifest = 'NextNodeServer.getFontManifest',</span><span class="s3">\n  </span><span class="s1">getServerComponentManifest = 'NextNodeServer.getServerComponentManifest',</span><span class="s3">\n  </span><span class="s1">getRequestHandler = 'NextNodeServer.getRequestHandler',</span><span class="s3">\n  </span><span class="s1">renderToHTML = 'NextNodeServer.renderToHTML',</span><span class="s3">\n  </span><span class="s1">renderError = 'NextNodeServer.renderError',</span><span class="s3">\n  </span><span class="s1">renderErrorToHTML = 'NextNodeServer.renderErrorToHTML',</span><span class="s3">\n  </span><span class="s1">render404 = 'NextNodeServer.render404',</span><span class="s3">\n  </span><span class="s1">startResponse = 'NextNodeServer.startResponse',</span><span class="s3">\n\n  </span><span class="s1">// nested inner span, does not require parent scope name</span><span class="s3">\n  </span><span class="s1">route = 'route',</span><span class="s3">\n  </span><span class="s1">onProxyReq = 'onProxyReq',</span><span class="s3">\n  </span><span class="s1">apiResolver = 'apiResolver',</span><span class="s3">\n  </span><span class="s1">internalFetch = 'internalFetch',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum StartServerSpan {</span><span class="s3">\n  </span><span class="s1">startServer = 'startServer.startServer',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum RenderSpan {</span><span class="s3">\n  </span><span class="s1">getServerSideProps = 'Render.getServerSideProps',</span><span class="s3">\n  </span><span class="s1">getStaticProps = 'Render.getStaticProps',</span><span class="s3">\n  </span><span class="s1">renderToString = 'Render.renderToString',</span><span class="s3">\n  </span><span class="s1">renderDocument = 'Render.renderDocument',</span><span class="s3">\n  </span><span class="s1">createBodyResult = 'Render.createBodyResult',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum AppRenderSpan {</span><span class="s3">\n  </span><span class="s1">renderToString = 'AppRender.renderToString',</span><span class="s3">\n  </span><span class="s1">renderToReadableStream = 'AppRender.renderToReadableStream',</span><span class="s3">\n  </span><span class="s1">getBodyResult = 'AppRender.getBodyResult',</span><span class="s3">\n  </span><span class="s1">fetch = 'AppRender.fetch',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum RouterSpan {</span><span class="s3">\n  </span><span class="s1">executeRoute = 'Router.executeRoute',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NodeSpan {</span><span class="s3">\n  </span><span class="s1">runHandler = 'Node.runHandler',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum AppRouteRouteHandlersSpan {</span><span class="s3">\n  </span><span class="s1">runHandler = 'AppRouteRouteHandlers.runHandler',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum ResolveMetadataSpan {</span><span class="s3">\n  </span><span class="s1">generateMetadata = 'ResolveMetadata.generateMetadata',</span><span class="s3">\n  </span><span class="s1">generateViewport = 'ResolveMetadata.generateViewport',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum MiddlewareSpan {</span><span class="s3">\n  </span><span class="s1">execute = 'Middleware.execute',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SpanTypes =</span><span class="s3">\n  </span><span class="s1">| `${BaseServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${LoadComponentsSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NextServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${StartServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NextNodeServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${RenderSpan}`</span><span class="s3">\n  </span><span class="s1">| `${RouterSpan}`</span><span class="s3">\n  </span><span class="s1">| `${AppRenderSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NodeSpan}`</span><span class="s3">\n  </span><span class="s1">| `${AppRouteRouteHandlersSpan}`</span><span class="s3">\n  </span><span class="s1">| `${ResolveMetadataSpan}`</span><span class="s3">\n  </span><span class="s1">| `${MiddlewareSpan}`</span><span class="s3">\n\n</span><span class="s1">// This list is used to filter out spans that are not relevant to the user</span><span class="s3">\n</span><span class="s1">export const NextVanillaSpanAllowlist = [</span><span class="s3">\n  </span><span class="s1">MiddlewareSpan.execute,</span><span class="s3">\n  </span><span class="s1">BaseServerSpan.handleRequest,</span><span class="s3">\n  </span><span class="s1">RenderSpan.getServerSideProps,</span><span class="s3">\n  </span><span class="s1">RenderSpan.getStaticProps,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan.fetch,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan.getBodyResult,</span><span class="s3">\n  </span><span class="s1">RenderSpan.renderDocument,</span><span class="s3">\n  </span><span class="s1">NodeSpan.runHandler,</span><span class="s3">\n  </span><span class="s1">AppRouteRouteHandlersSpan.runHandler,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan.generateMetadata,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan.generateViewport,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.createComponentTree,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.findPageComponents,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.getLayoutOrPageModule,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.startResponse,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.clientComponentLoading,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">// These Spans are allowed to be always logged</span><span class="s3">\n</span><span class="s1">// when the otel log prefix env is set</span><span class="s3">\n</span><span class="s1">export const LogSpanAllowList = [</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.findPageComponents,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.createComponentTree,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.clientComponentLoading,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">BaseServerSpan,</span><span class="s3">\n  </span><span class="s1">LoadComponentsSpan,</span><span class="s3">\n  </span><span class="s1">NextServerSpan,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan,</span><span class="s3">\n  </span><span class="s1">StartServerSpan,</span><span class="s3">\n  </span><span class="s1">RenderSpan,</span><span class="s3">\n  </span><span class="s1">RouterSpan,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan,</span><span class="s3">\n  </span><span class="s1">NodeSpan,</span><span class="s3">\n  </span><span class="s1">AppRouteRouteHandlersSpan,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan,</span><span class="s3">\n  </span><span class="s1">MiddlewareSpan,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type { SpanTypes }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class ReflectAdapter {</span><span class="s3">\n  </span><span class="s1">static get&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">receiver: unknown</span><span class="s3">\n  </span><span class="s1">): any {</span><span class="s3">\n    </span><span class="s1">const value = Reflect.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'function') {</span><span class="s3">\n      </span><span class="s1">return value.bind(target)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static set&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">value: any,</span><span class="s3">\n    </span><span class="s1">receiver: any</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.set(target, prop, value, receiver)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static has&lt;T extends object&gt;(target: T, prop: string | symbol): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.has(target, prop)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static deleteProperty&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.deleteProperty(target, prop)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingHttpHeaders } from 'http'</span><span class="s3">\n\n</span><span class="s1">import { ReflectAdapter } from './reflect'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ReadonlyHeadersError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static callable() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyHeadersError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReadonlyHeaders = Headers &amp; {</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">append(...args: any[]): void</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">set(...args: any[]): void</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">delete(...args: any[]): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class HeadersAdapter extends Headers {</span><span class="s3">\n  </span><span class="s1">private readonly headers: IncomingHttpHeaders</span><span class="s3">\n\n  </span><span class="s1">constructor(headers: IncomingHttpHeaders) {</span><span class="s3">\n    </span><span class="s1">// We've already overridden the methods that would be called, so we're just</span><span class="s3">\n    </span><span class="s1">// calling the super constructor to ensure that the instanceof check works.</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n\n    </span><span class="s1">this.headers = new Proxy(headers, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">// Because this is just an object, we expect that all </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">operations</span><span class="s3">\n        </span><span class="s1">// are for properties. If it's a </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">for a symbol, we'll just return</span><span class="s3">\n        </span><span class="s1">// the symbol.</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') {</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return undefined.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, return the value.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, original, receiver)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">set(target, prop, value, receiver) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') {</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.set(target, prop, value, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, use the prop as the key.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.set(target, original ?? prop, value, receiver)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">has(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return false.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return false</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, return true.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.has(target, original)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">deleteProperty(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol')</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.deleteProperty(target, prop)</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return true.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return true</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, delete the property.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.deleteProperty(target, original)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Seals a Headers instance to prevent modification by throwing an error when</span><span class="s3">\n   </span><span class="s1">* any mutating method is called.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static seal(headers: Headers): ReadonlyHeaders {</span><span class="s3">\n    </span><span class="s1">return new Proxy&lt;ReadonlyHeaders&gt;(headers, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">switch (prop) {</span><span class="s3">\n          </span><span class="s1">case 'append':</span><span class="s3">\n          </span><span class="s1">case 'delete':</span><span class="s3">\n          </span><span class="s1">case 'set':</span><span class="s3">\n            </span><span class="s1">return ReadonlyHeadersError.callable</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Merges a header value into a string. This stores multiple values as an</span><span class="s3">\n   </span><span class="s1">* array, so we need to merge them into a string.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param value a header value</span><span class="s3">\n   </span><span class="s1">* @returns a merged header value (a string)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private merge(value: string | string[]): string {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) return value.join(', ')</span><span class="s3">\n\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a Headers instance from a plain object or a Headers instance.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param headers a plain object or a Headers instance</span><span class="s3">\n   </span><span class="s1">* @returns a headers instance</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static from(headers: IncomingHttpHeaders | Headers): Headers {</span><span class="s3">\n    </span><span class="s1">if (headers instanceof Headers) return headers</span><span class="s3">\n\n    </span><span class="s1">return new HeadersAdapter(headers)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public append(name: string, value: string): void {</span><span class="s3">\n    </span><span class="s1">const existing = this.headers[name]</span><span class="s3">\n    </span><span class="s1">if (typeof existing === 'string') {</span><span class="s3">\n      </span><span class="s1">this.headers[name] = [existing, value]</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(existing)) {</span><span class="s3">\n      </span><span class="s1">existing.push(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.headers[name] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public delete(name: string): void {</span><span class="s3">\n    </span><span class="s1">delete this.headers[name]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get(name: string): string | null {</span><span class="s3">\n    </span><span class="s1">const value = this.headers[name]</span><span class="s3">\n    </span><span class="s1">if (typeof value !== 'undefined') return this.merge(value)</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public has(name: string): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.headers[name] !== 'undefined'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set(name: string, value: string): void {</span><span class="s3">\n    </span><span class="s1">this.headers[name] = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public forEach(</span><span class="s3">\n    </span><span class="s1">callbackfn: (value: string, name: string, parent: Headers) =&gt; void,</span><span class="s3">\n    </span><span class="s1">thisArg?: any</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">for (const [name, value] of this.entries()) {</span><span class="s3">\n      </span><span class="s1">callbackfn.call(thisArg, value, name, this)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *entries(): HeadersIterator&lt;[string, string]&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">const name = key.toLowerCase()</span><span class="s3">\n      </span><span class="s1">// We assert here that this is a string because we got it from the</span><span class="s3">\n      </span><span class="s1">// Object.keys() call above.</span><span class="s3">\n      </span><span class="s1">const value = this.get(name) as string</span><span class="s3">\n\n      </span><span class="s1">yield [name, value] as [string, string]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *keys(): HeadersIterator&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">const name = key.toLowerCase()</span><span class="s3">\n      </span><span class="s1">yield name</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *values(): HeadersIterator&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">// We assert here that this is a string because we got it from the</span><span class="s3">\n      </span><span class="s1">// Object.keys() call above.</span><span class="s3">\n      </span><span class="s1">const value = this.get(key) as string</span><span class="s3">\n\n      </span><span class="s1">yield value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public [Symbol.iterator](): HeadersIterator&lt;[string, string]&gt; {</span><span class="s3">\n    </span><span class="s1">return this.entries()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This module is for next.js server internal usage of path module.</span><span class="s3">\n </span><span class="s1">* It will use native path module for nodejs runtime.</span><span class="s3">\n </span><span class="s1">* It will use path-browserify polyfill for edge runtime.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let path</span><span class="s3">\n\n</span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n  </span><span class="s1">path = require('next/dist/compiled/path-browserify')</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">path = require('path')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = path</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Note: This file is JS because it's used by the taskfile-swc.js file, which is JS.</span><span class="s3">\n</span><span class="s1">// Keep file changes in sync with the corresponding `.d.ts` files.</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* These are the browser versions that support all of the following:</span><span class="s3">\n </span><span class="s1">* static import: https://caniuse.com/es6-module</span><span class="s3">\n </span><span class="s1">* dynamic import: https://caniuse.com/es6-module-dynamic-import</span><span class="s3">\n </span><span class="s1">* import.meta: https://caniuse.com/mdn-javascript_operators_import_meta</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MODERN_BROWSERSLIST_TARGET = [</span><span class="s3">\n  </span><span class="s1">'chrome 64',</span><span class="s3">\n  </span><span class="s1">'edge 79',</span><span class="s3">\n  </span><span class="s1">'firefox 67',</span><span class="s3">\n  </span><span class="s1">'opera 51',</span><span class="s3">\n  </span><span class="s1">'safari 12',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">module.exports = MODERN_BROWSERSLIST_TARGET</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{var e={318:function(e,t){(function(e,n){true?n(t):0})(this,(function(e){</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;class StructError extends TypeError{constructor(e,t){let n;const{message:r,explanation:i,...c}=e;const{path:o}=e;const a=o.length===0?r:`At path: ${o.join(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)} -- ${r}`;super(i??a);if(i!=null)this.cause=a;Object.assign(this,c);this.name=this.constructor.name;this.failures=()=&gt;n??(n=[e,...t()])}}function isIterable(e){return isObject(e)&amp;&amp;typeof e[Symbol.iterator]===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">}function isObject(e){return typeof e===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;e!=null}function isPlainObject(e){if(Object.prototype.toString.call(e)!==</span><span class="s3">\&quot;</span><span class="s1">[object Object]</span><span class="s3">\&quot;</span><span class="s1">){return false}const t=Object.getPrototypeOf(e);return t===null||t===Object.prototype}function print(e){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot;</span><span class="s1">){return e.toString()}return typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?JSON.stringify(e):`${e}`}function shiftIterator(e){const{done:t,value:n}=e.next();return t?undefined:n}function toFailure(e,t,n,r){if(e===true){return}else if(e===false){e={}}else if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){e={message:e}}const{path:i,branch:c}=t;const{type:o}=n;const{refinement:a,message:s=`Expected a value of type </span><span class="s3">\\</span><span class="s1">`${o}</span><span class="s3">\\</span><span class="s1">`${a?` with refinement </span><span class="s3">\\</span><span class="s1">`${a}</span><span class="s3">\\</span><span class="s1">``:</span><span class="s3">\&quot;\&quot;</span><span class="s1">}, but received: </span><span class="s3">\\</span><span class="s1">`${print(r)}</span><span class="s3">\\</span><span class="s1">``}=e;return{value:r,type:o,refinement:a,key:i[i.length-1],path:i,branch:c,...e,message:s}}function*toFailures(e,t,n,r){if(!isIterable(e)){e=[e]}for(const i of e){const e=toFailure(i,t,n,r);if(e){yield e}}}function*run(e,t,n={}){const{path:r=[],branch:i=[e],coerce:c=false,mask:o=false}=n;const a={path:r,branch:i};if(c){e=t.coercer(e,a);if(o&amp;&amp;t.type!==</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;isObject(t.schema)&amp;&amp;isObject(e)&amp;&amp;!Array.isArray(e)){for(const n in e){if(t.schema[n]===undefined){delete e[n]}}}}let s=</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">;for(const r of t.validator(e,a)){r.explanation=n.message;s=</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">;yield[r,undefined]}for(let[u,f,l]of t.entries(e,a)){const t=run(f,l,{path:u===undefined?r:[...r,u],branch:u===undefined?i:[...i,f],coerce:c,mask:o,message:n.message});for(const n of t){if(n[0]){s=n[0].refinement!=null?</span><span class="s3">\&quot;</span><span class="s1">not_refined</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">;yield[n[0],undefined]}else if(c){f=n[1];if(u===undefined){e=f}else if(e instanceof Map){e.set(u,f)}else if(e instanceof Set){e.add(f)}else if(isObject(e)){if(f!==undefined||u in e)e[u]=f}}}}if(s!==</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">){for(const r of t.refiner(e,a)){r.explanation=n.message;s=</span><span class="s3">\&quot;</span><span class="s1">not_refined</span><span class="s3">\&quot;</span><span class="s1">;yield[r,undefined]}}if(s===</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">){yield[undefined,e]}}class Struct{constructor(e){const{type:t,schema:n,validator:r,refiner:i,coercer:c=(e=&gt;e),entries:o=function*(){}}=e;this.type=t;this.schema=n;this.entries=o;this.coercer=c;if(r){this.validator=(e,t)=&gt;{const n=r(e,t);return toFailures(n,t,this,e)}}else{this.validator=()=&gt;[]}if(i){this.refiner=(e,t)=&gt;{const n=i(e,t);return toFailures(n,t,this,e)}}else{this.refiner=()=&gt;[]}}assert(e,t){return assert(e,this,t)}create(e,t){return create(e,this,t)}is(e){return is(e,this)}mask(e,t){return mask(e,this,t)}validate(e,t={}){return validate(e,this,t)}}function assert(e,t,n){const r=validate(e,t,{message:n});if(r[0]){throw r[0]}}function create(e,t,n){const r=validate(e,t,{coerce:true,message:n});if(r[0]){throw r[0]}else{return r[1]}}function mask(e,t,n){const r=validate(e,t,{coerce:true,mask:true,message:n});if(r[0]){throw r[0]}else{return r[1]}}function is(e,t){const n=validate(e,t);return!n[0]}function validate(e,t,n={}){const r=run(e,t,n);const i=shiftIterator(r);if(i[0]){const e=new StructError(i[0],(function*(){for(const e of r){if(e[0]){yield e[0]}}}));return[e,undefined]}else{const e=i[1];return[undefined,e]}}function assign(...e){const t=e[0].type===</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">;const n=e.map((e=&gt;e.schema));const r=Object.assign({},...n);return t?type(r):object(r)}function define(e,t){return new Struct({type:e,schema:null,validator:t})}function deprecated(e,t){return new Struct({...e,refiner:(t,n)=&gt;t===undefined||e.refiner(t,n),validator(n,r){if(n===undefined){return true}else{t(n,r);return e.validator(n,r)}}})}function dynamic(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">dynamic</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t,n){const r=e(t,n);yield*r.entries(t,n)},validator(t,n){const r=e(t,n);return r.validator(t,n)},coercer(t,n){const r=e(t,n);return r.coercer(t,n)},refiner(t,n){const r=e(t,n);return r.refiner(t,n)}})}function lazy(e){let t;return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">lazy</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n,r){t??(t=e());yield*t.entries(n,r)},validator(n,r){t??(t=e());return t.validator(n,r)},coercer(n,r){t??(t=e());return t.coercer(n,r)},refiner(n,r){t??(t=e());return t.refiner(n,r)}})}function omit(e,t){const{schema:n}=e;const r={...n};for(const e of t){delete r[e]}switch(e.type){case</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:return type(r);default:return object(r)}}function partial(e){const t=e instanceof Struct?{...e.schema}:{...e};for(const e in t){t[e]=optional(t[e])}return object(t)}function pick(e,t){const{schema:n}=e;const r={};for(const e of t){r[e]=n[e]}return object(r)}function struct(e,t){console.warn(</span><span class="s3">\&quot;</span><span class="s1">superstruct@0.11 - The `struct` helper has been renamed to `define`.</span><span class="s3">\&quot;</span><span class="s1">);return define(e,t)}function any(){return define(</span><span class="s3">\&quot;</span><span class="s1">any</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;true))}function array(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,schema:e,*entries(t){if(e&amp;&amp;Array.isArray(t)){for(const[n,r]of t.entries()){yield[n,r,e]}}},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${print(e)}`}})}function bigint(){return define(</span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">))}function boolean(){return define(</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">))}function date(){return define(</span><span class="s3">\&quot;</span><span class="s1">date</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;e instanceof Date&amp;&amp;!isNaN(e.getTime())||`Expected a valid </span><span class="s3">\\</span><span class="s1">`Date</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`))}function enums(e){const t={};const n=e.map((e=&gt;print(e))).join();for(const n of e){t[n]=n}return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">enums</span><span class="s3">\&quot;</span><span class="s1">,schema:t,validator(t){return e.includes(t)||`Expected one of </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(t)}`}})}function func(){return define(</span><span class="s3">\&quot;</span><span class="s1">func</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">||`Expected a function, but received: ${print(e)}`))}function instance(e){return define(</span><span class="s3">\&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;t instanceof e||`Expected a </span><span class="s3">\\</span><span class="s1">`${e.name}</span><span class="s3">\\</span><span class="s1">` instance, but received: ${print(t)}`))}function integer(){return define(</span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;!isNaN(e)&amp;&amp;Number.isInteger(e)||`Expected an integer, but received: ${print(e)}`))}function intersection(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">intersection</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t,n){for(const r of e){yield*r.entries(t,n)}},*validator(t,n){for(const r of e){yield*r.validator(t,n)}},*refiner(t,n){for(const r of e){yield*r.refiner(t,n)}}})}function literal(e){const t=print(e);const n=typeof e;return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">literal</span><span class="s3">\&quot;</span><span class="s1">,schema:n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||n===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||n===</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">?e:null,validator(n){return n===e||`Expected the literal </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(n)}`}})}function map(e,t){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">map</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(e&amp;&amp;t&amp;&amp;n instanceof Map){for(const[r,i]of n.entries()){yield[r,r,e];yield[r,i,t]}}},coercer(e){return e instanceof Map?new Map(e):e},validator(e){return e instanceof Map||`Expected a </span><span class="s3">\\</span><span class="s1">`Map</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`}})}function never(){return define(</span><span class="s3">\&quot;</span><span class="s1">never</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;false))}function nullable(e){return new Struct({...e,validator:(t,n)=&gt;t===null||e.validator(t,n),refiner:(t,n)=&gt;t===null||e.refiner(t,n)})}function number(){return define(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;!isNaN(e)||`Expected a number, but received: ${print(e)}`))}function object(e){const t=e?Object.keys(e):[];const n=never();return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,schema:e?e:null,*entries(r){if(e&amp;&amp;isObject(r)){const i=new Set(Object.keys(r));for(const n of t){i.delete(n);yield[n,r[n],e[n]]}for(const e of i){yield[e,r[e],n]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`},coercer(e){return isObject(e)?{...e}:e}})}function optional(e){return new Struct({...e,validator:(t,n)=&gt;t===undefined||e.validator(t,n),refiner:(t,n)=&gt;t===undefined||e.refiner(t,n)})}function record(e,t){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">record</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(isObject(n)){for(const r in n){const i=n[r];yield[r,r,e];yield[r,i,t]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`}})}function regexp(){return define(</span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;e instanceof RegExp))}function set(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t){if(e&amp;&amp;t instanceof Set){for(const n of t){yield[n,n,e]}}},coercer(e){return e instanceof Set?new Set(e):e},validator(e){return e instanceof Set||`Expected a </span><span class="s3">\\</span><span class="s1">`Set</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`}})}function string(){return define(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||`Expected a string, but received: ${print(e)}`))}function tuple(e){const t=never();return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">tuple</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(Array.isArray(n)){const r=Math.max(e.length,n.length);for(let i=0;i&lt;r;i++){yield[i,n[i],e[i]||t]}}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${print(e)}`}})}function type(e){const t=Object.keys(e);return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">,schema:e,*entries(n){if(isObject(n)){for(const r of t){yield[r,n[r],e[r]]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`},coercer(e){return isObject(e)?{...e}:e}})}function union(e){const t=e.map((e=&gt;e.type)).join(</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">);return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">union</span><span class="s3">\&quot;</span><span class="s1">,schema:null,coercer(t){for(const n of e){const[e,r]=n.validate(t,{coerce:true});if(!e){return r}}return t},validator(n,r){const i=[];for(const t of e){const[...e]=run(n,t,r);const[c]=e;if(!c[0]){return[]}else{for(const[t]of e){if(t){i.push(t)}}}}return[`Expected the value to satisfy a union of </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(n)}`,...i]}})}function unknown(){return define(</span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;true))}function coerce(e,t,n){return new Struct({...e,coercer:(r,i)=&gt;is(r,t)?e.coercer(n(r,i),i):e.coercer(r,i)})}function defaulted(e,t,n={}){return coerce(e,unknown(),(e=&gt;{const r=typeof t===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">?t():t;if(e===undefined){return r}if(!n.strict&amp;&amp;isPlainObject(e)&amp;&amp;isPlainObject(r)){const t={...e};let n=false;for(const e in r){if(t[e]===undefined){t[e]=r[e];n=true}}if(n){return t}}return e}))}function trimmed(e){return coerce(e,string(),(e=&gt;e.trim()))}function empty(e){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">empty</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;{const n=getSize(t);return n===0||`Expected an empty ${e.type} but received one with a size of </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``}))}function getSize(e){if(e instanceof Map||e instanceof Set){return e.size}else{return e.length}}function max(e,t,n={}){const{exclusive:r}=n;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">max</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;r?n&lt;t:n&lt;=t||`Expected a ${e.type} less than ${r?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">or equal to </span><span class="s3">\&quot;</span><span class="s1">}${t} but received </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``))}function min(e,t,n={}){const{exclusive:r}=n;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">min</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;r?n&gt;t:n&gt;=t||`Expected a ${e.type} greater than ${r?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">or equal to </span><span class="s3">\&quot;</span><span class="s1">}${t} but received </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``))}function nonempty(e){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">nonempty</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;{const n=getSize(t);return n&gt;0||`Expected a nonempty ${e.type} but received an empty one`}))}function pattern(e,t){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;t.test(n)||`Expected a ${e.type} matching </span><span class="s3">\\</span><span class="s1">`/${t.source}/</span><span class="s3">\\</span><span class="s1">` but received </span><span class="s3">\&quot;</span><span class="s1">${n}</span><span class="s3">\&quot;</span><span class="s1">`))}function size(e,t,n=t){const r=`Expected a ${e.type}`;const i=t===n?`of </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">``:`between </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">` and </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;{if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||e instanceof Date){return t&lt;=e&amp;&amp;e&lt;=n||`${r} ${i} but received </span><span class="s3">\\</span><span class="s1">`${e}</span><span class="s3">\\</span><span class="s1">``}else if(e instanceof Map||e instanceof Set){const{size:c}=e;return t&lt;=c&amp;&amp;c&lt;=n||`${r} with a size ${i} but received one with a size of </span><span class="s3">\\</span><span class="s1">`${c}</span><span class="s3">\\</span><span class="s1">``}else{const{length:c}=e;return t&lt;=c&amp;&amp;c&lt;=n||`${r} with a length ${i} but received one with a length of </span><span class="s3">\\</span><span class="s1">`${c}</span><span class="s3">\\</span><span class="s1">``}}))}function refine(e,t,n){return new Struct({...e,*refiner(r,i){yield*e.refiner(r,i);const c=n(r,i);const o=toFailures(c,i,e,r);for(const e of o){yield{...e,refinement:t}}}})}e.Struct=Struct;e.StructError=StructError;e.any=any;e.array=array;e.assert=assert;e.assign=assign;e.bigint=bigint;e.boolean=boolean;e.coerce=coerce;e.create=create;e.date=date;e.defaulted=defaulted;e.define=define;e.deprecated=deprecated;e.dynamic=dynamic;e.empty=empty;e.enums=enums;e.func=func;e.instance=instance;e.integer=integer;e.intersection=intersection;e.is=is;e.lazy=lazy;e.literal=literal;e.map=map;e.mask=mask;e.max=max;e.min=min;e.never=never;e.nonempty=nonempty;e.nullable=nullable;e.number=number;e.object=object;e.omit=omit;e.optional=optional;e.partial=partial;e.pattern=pattern;e.pick=pick;e.record=record;e.refine=refine;e.regexp=regexp;e.set=set;e.size=size;e.string=string;e.struct=struct;e.trimmed=trimmed;e.tuple=tuple;e.type=type;e.union=union;e.unknown=unknown;e.validate=validate}))}};if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var t={};e[318](0,t);module.exports=t})();&quot;</span><span class="s0">,</span><span class="s1">&quot;// getDefaultExport function for compatibility with non-ESM modules</span><span class="s3">\n</span><span class="s1">__webpack_require__.n = (module) =&gt; {</span><span class="s3">\n\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n\t\t</span><span class="s1">() =&gt; (module['default']) :</span><span class="s3">\n\t\t</span><span class="s1">() =&gt; (module);</span><span class="s3">\n\t</span><span class="s1">__webpack_require__.d(getter, { a: getter });</span><span class="s3">\n\t</span><span class="s1">return getter;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var getProto = Object.getPrototypeOf ? (obj) =&gt; (Object.getPrototypeOf(obj)) : (obj) =&gt; (obj.__proto__);</span><span class="s3">\n</span><span class="s1">var leafPrototypes;</span><span class="s3">\n</span><span class="s1">// create a fake namespace object</span><span class="s3">\n</span><span class="s1">// mode &amp; 1: value is a module id, require it</span><span class="s3">\n</span><span class="s1">// mode &amp; 2: merge all properties of value into the ns</span><span class="s3">\n</span><span class="s1">// mode &amp; 4: return value when already ns object</span><span class="s3">\n</span><span class="s1">// mode &amp; 16: return value when it's Promise-like</span><span class="s3">\n</span><span class="s1">// mode &amp; 8|1: behave like require</span><span class="s3">\n</span><span class="s1">__webpack_require__.t = function(value, mode) {</span><span class="s3">\n\t</span><span class="s1">if(mode &amp; 1) value = this(value);</span><span class="s3">\n\t</span><span class="s1">if(mode &amp; 8) return value;</span><span class="s3">\n\t</span><span class="s1">if(typeof value === 'object' &amp;&amp; value) {</span><span class="s3">\n\t\t</span><span class="s1">if((mode &amp; 4) &amp;&amp; value.__esModule) return value;</span><span class="s3">\n\t\t</span><span class="s1">if((mode &amp; 16) &amp;&amp; typeof value.then === 'function') return value;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">var ns = Object.create(null);</span><span class="s3">\n  </span><span class="s1">__webpack_require__.r(ns);</span><span class="s3">\n\t</span><span class="s1">var def = {};</span><span class="s3">\n\t</span><span class="s1">leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];</span><span class="s3">\n\t</span><span class="s1">for(var current = mode &amp; 2 &amp;&amp; value; typeof current == 'object' &amp;&amp; !~leafPrototypes.indexOf(current); current = getProto(current)) {</span><span class="s3">\n\t\t</span><span class="s1">Object.getOwnPropertyNames(current).forEach((key) =&gt; { def[key] = () =&gt; (value[key]) });</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">def['default'] = () =&gt; (value);</span><span class="s3">\n\t</span><span class="s1">__webpack_require__.d(ns, def);</span><span class="s3">\n\t</span><span class="s1">return ns;</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__.d = (exports, definition) =&gt; {</span><span class="s3">\n\t</span><span class="s1">for(var key in definition) {</span><span class="s3">\n        </span><span class="s1">if(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) {</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__.o = (obj, prop) =&gt; (Object.prototype.hasOwnProperty.call(obj, prop))&quot;</span><span class="s0">,</span><span class="s1">&quot;// define __esModule on exports</span><span class="s3">\n</span><span class="s1">__webpack_require__.r = (exports) =&gt; {</span><span class="s3">\n\t</span><span class="s1">if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {</span><span class="s3">\n\t\t</span><span class="s1">Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">Object.defineProperty(exports, '__esModule', { value: true });</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;import MODERN_BROWSERSLIST_TARGET from './modern-browserslist-target'</span><span class="s3">\n\n</span><span class="s1">export { MODERN_BROWSERSLIST_TARGET }</span><span class="s3">\n\n</span><span class="s1">export type ValueOf&lt;T&gt; = Required&lt;T&gt;[keyof T]</span><span class="s3">\n\n</span><span class="s1">export const COMPILER_NAMES = {</span><span class="s3">\n  </span><span class="s1">client: 'client',</span><span class="s3">\n  </span><span class="s1">server: 'server',</span><span class="s3">\n  </span><span class="s1">edgeServer: 'edge-server',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export type CompilerNameValues = ValueOf&lt;typeof COMPILER_NAMES&gt;</span><span class="s3">\n\n</span><span class="s1">export enum AdapterOutputType {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES` represents all the React pages that are under `pages/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES_API` represents all the API routes under `pages/api/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES_API = 'PAGES_API',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_PAGE` represents all the React pages that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `page.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `route.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PRERENDER` represents an ISR enabled route that might</span><span class="s3">\n   </span><span class="s1">* have a seeded cache entry or fallback generated during build</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PRERENDER = 'PRERENDER',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `STATIC_FILE` represents a static file (ie /_next/static)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">STATIC_FILE = 'STATIC_FILE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `MIDDLEWARE` represents the middleware output if present</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">MIDDLEWARE = 'MIDDLEWARE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const COMPILER_INDEXES: {</span><span class="s3">\n  </span><span class="s1">[compilerKey in CompilerNameValues]: number</span><span class="s3">\n</span><span class="s1">} = {</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.client]: 0,</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.server]: 1,</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.edgeServer]: 2,</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export const UNDERSCORE_NOT_FOUND_ROUTE = '/_not-found'</span><span class="s3">\n</span><span class="s1">export const UNDERSCORE_NOT_FOUND_ROUTE_ENTRY = `${UNDERSCORE_NOT_FOUND_ROUTE}/page`</span><span class="s3">\n</span><span class="s1">export const PHASE_EXPORT = 'phase-export'</span><span class="s3">\n</span><span class="s1">export const PHASE_PRODUCTION_BUILD = 'phase-production-build'</span><span class="s3">\n</span><span class="s1">export const PHASE_PRODUCTION_SERVER = 'phase-production-server'</span><span class="s3">\n</span><span class="s1">export const PHASE_DEVELOPMENT_SERVER = 'phase-development-server'</span><span class="s3">\n</span><span class="s1">export const PHASE_TEST = 'phase-test'</span><span class="s3">\n</span><span class="s1">export const PHASE_INFO = 'phase-info'</span><span class="s3">\n</span><span class="s1">export const PAGES_MANIFEST = 'pages-manifest.json'</span><span class="s3">\n</span><span class="s1">export const WEBPACK_STATS = 'webpack-stats.json'</span><span class="s3">\n</span><span class="s1">export const APP_PATHS_MANIFEST = 'app-paths-manifest.json'</span><span class="s3">\n</span><span class="s1">export const APP_PATH_ROUTES_MANIFEST = 'app-path-routes-manifest.json'</span><span class="s3">\n</span><span class="s1">export const BUILD_MANIFEST = 'build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const APP_BUILD_MANIFEST = 'app-build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const FUNCTIONS_CONFIG_MANIFEST = 'functions-config-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SUBRESOURCE_INTEGRITY_MANIFEST = 'subresource-integrity-manifest'</span><span class="s3">\n</span><span class="s1">export const NEXT_FONT_MANIFEST = 'next-font-manifest'</span><span class="s3">\n</span><span class="s1">export const EXPORT_MARKER = 'export-marker.json'</span><span class="s3">\n</span><span class="s1">export const EXPORT_DETAIL = 'export-detail.json'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_MANIFEST = 'prerender-manifest.json'</span><span class="s3">\n</span><span class="s1">export const ROUTES_MANIFEST = 'routes-manifest.json'</span><span class="s3">\n</span><span class="s1">export const IMAGES_MANIFEST = 'images-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SERVER_FILES_MANIFEST = 'required-server-files.json'</span><span class="s3">\n</span><span class="s1">export const DEV_CLIENT_PAGES_MANIFEST = '_devPagesManifest.json'</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_MANIFEST = 'middleware-manifest.json'</span><span class="s3">\n</span><span class="s1">export const TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'_clientMiddlewareManifest.json'</span><span class="s3">\n</span><span class="s1">export const TURBOPACK_CLIENT_BUILD_MANIFEST = 'client-build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const DEV_CLIENT_MIDDLEWARE_MANIFEST = '_devMiddlewareManifest.json'</span><span class="s3">\n</span><span class="s1">export const REACT_LOADABLE_MANIFEST = 'react-loadable-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SERVER_DIRECTORY = 'server'</span><span class="s3">\n</span><span class="s1">export const CONFIG_FILES = [</span><span class="s3">\n  </span><span class="s1">'next.config.js',</span><span class="s3">\n  </span><span class="s1">'next.config.mjs',</span><span class="s3">\n  </span><span class="s1">'next.config.ts',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">export const BUILD_ID_FILE = 'BUILD_ID'</span><span class="s3">\n</span><span class="s1">export const BLOCKED_PAGES = ['/_document', '/_app', '/_error']</span><span class="s3">\n</span><span class="s1">export const CLIENT_PUBLIC_FILES_PATH = 'public'</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_PATH = 'static'</span><span class="s3">\n</span><span class="s1">export const STRING_LITERAL_DROP_BUNDLE = '__NEXT_DROP_CLIENT_FILE__'</span><span class="s3">\n</span><span class="s1">export const NEXT_BUILTIN_DOCUMENT = '__NEXT_BUILTIN_DOCUMENT__'</span><span class="s3">\n</span><span class="s1">export const BARREL_OPTIMIZATION_PREFIX = '__barrel_optimize__'</span><span class="s3">\n\n</span><span class="s1">// server/[entry]/page_client-reference-manifest.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_REFERENCE_MANIFEST = 'client-reference-manifest'</span><span class="s3">\n</span><span class="s1">// server/server-reference-manifest</span><span class="s3">\n</span><span class="s1">export const SERVER_REFERENCE_MANIFEST = 'server-reference-manifest'</span><span class="s3">\n</span><span class="s1">// server/middleware-build-manifest.js</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_BUILD_MANIFEST = 'middleware-build-manifest'</span><span class="s3">\n</span><span class="s1">// server/middleware-react-loadable-manifest.js</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_REACT_LOADABLE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'middleware-react-loadable-manifest'</span><span class="s3">\n</span><span class="s1">// server/interception-route-rewrite-manifest.js</span><span class="s3">\n</span><span class="s1">export const INTERCEPTION_ROUTE_REWRITE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'interception-route-rewrite-manifest'</span><span class="s3">\n</span><span class="s1">// server/dynamic-css-manifest.js</span><span class="s3">\n</span><span class="s1">export const DYNAMIC_CSS_MANIFEST = 'dynamic-css-manifest'</span><span class="s3">\n\n</span><span class="s1">// static/runtime/main.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_MAIN = `main`</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_MAIN_APP = `${CLIENT_STATIC_FILES_RUNTIME_MAIN}-app`</span><span class="s3">\n</span><span class="s1">// next internal client components chunk for layouts</span><span class="s3">\n</span><span class="s1">export const APP_CLIENT_INTERNALS = 'app-pages-internals'</span><span class="s3">\n</span><span class="s1">// static/runtime/react-refresh.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH = `react-refresh`</span><span class="s3">\n</span><span class="s1">// static/runtime/amp.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_AMP = `amp`</span><span class="s3">\n</span><span class="s1">// static/runtime/webpack.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_WEBPACK = `webpack`</span><span class="s3">\n</span><span class="s1">// static/runtime/polyfills.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_POLYFILLS = 'polyfills'</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL = Symbol(</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_POLYFILLS</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const DEFAULT_RUNTIME_WEBPACK = 'webpack-runtime'</span><span class="s3">\n</span><span class="s1">export const EDGE_RUNTIME_WEBPACK = 'edge-runtime-webpack'</span><span class="s3">\n</span><span class="s1">export const STATIC_PROPS_ID = '__N_SSG'</span><span class="s3">\n</span><span class="s1">export const SERVER_PROPS_ID = '__N_SSP'</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SERIF_FONT = {</span><span class="s3">\n  </span><span class="s1">name: 'Times New Roman',</span><span class="s3">\n  </span><span class="s1">xAvgCharWidth: 821,</span><span class="s3">\n  </span><span class="s1">azAvgWidth: 854.3953488372093,</span><span class="s3">\n  </span><span class="s1">unitsPerEm: 2048,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SANS_SERIF_FONT = {</span><span class="s3">\n  </span><span class="s1">name: 'Arial',</span><span class="s3">\n  </span><span class="s1">xAvgCharWidth: 904,</span><span class="s3">\n  </span><span class="s1">azAvgWidth: 934.5116279069767,</span><span class="s3">\n  </span><span class="s1">unitsPerEm: 2048,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const STATIC_STATUS_PAGES = ['/500']</span><span class="s3">\n</span><span class="s1">export const TRACE_OUTPUT_VERSION = 1</span><span class="s3">\n</span><span class="s1">// in `MB`</span><span class="s3">\n</span><span class="s1">export const TURBO_TRACE_DEFAULT_MEMORY_LIMIT = 6000</span><span class="s3">\n\n</span><span class="s1">export const RSC_MODULE_TYPES = {</span><span class="s3">\n  </span><span class="s1">client: 'client',</span><span class="s3">\n  </span><span class="s1">server: 'server',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">// comparing</span><span class="s3">\n</span><span class="s1">// https://nextjs.org/docs/api-reference/edge-runtime</span><span class="s3">\n</span><span class="s1">// with</span><span class="s3">\n</span><span class="s1">// https://nodejs.org/docs/latest/api/globals.html</span><span class="s3">\n</span><span class="s1">export const EDGE_UNSUPPORTED_NODE_APIS = [</span><span class="s3">\n  </span><span class="s1">'clearImmediate',</span><span class="s3">\n  </span><span class="s1">'setImmediate',</span><span class="s3">\n  </span><span class="s1">'BroadcastChannel',</span><span class="s3">\n  </span><span class="s1">'ByteLengthQueuingStrategy',</span><span class="s3">\n  </span><span class="s1">'CompressionStream',</span><span class="s3">\n  </span><span class="s1">'CountQueuingStrategy',</span><span class="s3">\n  </span><span class="s1">'DecompressionStream',</span><span class="s3">\n  </span><span class="s1">'DomException',</span><span class="s3">\n  </span><span class="s1">'MessageChannel',</span><span class="s3">\n  </span><span class="s1">'MessageEvent',</span><span class="s3">\n  </span><span class="s1">'MessagePort',</span><span class="s3">\n  </span><span class="s1">'ReadableByteStreamController',</span><span class="s3">\n  </span><span class="s1">'ReadableStreamBYOBRequest',</span><span class="s3">\n  </span><span class="s1">'ReadableStreamDefaultController',</span><span class="s3">\n  </span><span class="s1">'TransformStreamDefaultController',</span><span class="s3">\n  </span><span class="s1">'WritableStreamDefaultController',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export const SYSTEM_ENTRYPOINTS = new Set&lt;string&gt;([</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_MAIN,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_AMP,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_MAIN_APP,</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">const DUMMY_ORIGIN = 'http://n'</span><span class="s3">\n\n</span><span class="s1">export function isFullStringUrl(url: string) {</span><span class="s3">\n  </span><span class="s1">return /https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//.test(url)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseUrl(url: string): URL | undefined {</span><span class="s3">\n  </span><span class="s1">let parsed: URL | undefined = undefined</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">parsed = new URL(url, DUMMY_ORIGIN)</span><span class="s3">\n  </span><span class="s1">} catch {}</span><span class="s3">\n  </span><span class="s1">return parsed</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseReqUrl(url: string): UrlWithParsedQuery | undefined {</span><span class="s3">\n  </span><span class="s1">const parsedUrl: URL | undefined = parseUrl(url)</span><span class="s3">\n\n  </span><span class="s1">if (!parsedUrl) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const query: Record&lt;string, string | string[]&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const key of parsedUrl.searchParams.keys()) {</span><span class="s3">\n    </span><span class="s1">const values = parsedUrl.searchParams.getAll(key)</span><span class="s3">\n    </span><span class="s1">query[key] = values.length &gt; 1 ? values : values[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const legacyUrl: UrlWithParsedQuery = {</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">hash: parsedUrl.hash,</span><span class="s3">\n    </span><span class="s1">search: parsedUrl.search,</span><span class="s3">\n    </span><span class="s1">path: parsedUrl.pathname,</span><span class="s3">\n    </span><span class="s1">pathname: parsedUrl.pathname,</span><span class="s3">\n    </span><span class="s1">href: `${parsedUrl.pathname}${parsedUrl.search}${parsedUrl.hash}`,</span><span class="s3">\n    </span><span class="s1">host: '',</span><span class="s3">\n    </span><span class="s1">hostname: '',</span><span class="s3">\n    </span><span class="s1">auth: '',</span><span class="s3">\n    </span><span class="s1">protocol: '',</span><span class="s3">\n    </span><span class="s1">slashes: null,</span><span class="s3">\n    </span><span class="s1">port: '',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return legacyUrl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stripNextRscUnionQuery(relativeUrl: string): string {</span><span class="s3">\n  </span><span class="s1">const urlInstance = new URL(relativeUrl, DUMMY_ORIGIN)</span><span class="s3">\n  </span><span class="s1">urlInstance.searchParams.delete(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n\n  </span><span class="s1">return urlInstance.pathname + urlInstance.search</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export interface PathLocale {</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache of lowercased locales for each list of locales. This is stored as a</span><span class="s3">\n </span><span class="s1">* WeakMap so if the locales are garbage collected, the cache entry will be</span><span class="s3">\n </span><span class="s1">* removed as well.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cache = new WeakMap&lt;readonly string[], readonly string[]&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* For a pathname that may include a locale from a list of locales, it</span><span class="s3">\n </span><span class="s1">* removes the locale from the pathname returning it alongside with the</span><span class="s3">\n </span><span class="s1">* detected locale.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pathname A pathname that may include a locale.</span><span class="s3">\n </span><span class="s1">* @param locales A list of locales.</span><span class="s3">\n </span><span class="s1">* @returns The detected locale and pathname without locale</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeLocalePath(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n</span><span class="s1">): PathLocale {</span><span class="s3">\n  </span><span class="s1">// If locales is undefined, return the pathname as is.</span><span class="s3">\n  </span><span class="s1">if (!locales) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// Get the cached lowercased locales or create a new cache entry.</span><span class="s3">\n  </span><span class="s1">let lowercasedLocales = cache.get(locales)</span><span class="s3">\n  </span><span class="s1">if (!lowercasedLocales) {</span><span class="s3">\n    </span><span class="s1">lowercasedLocales = locales.map((locale) =&gt; locale.toLowerCase())</span><span class="s3">\n    </span><span class="s1">cache.set(locales, lowercasedLocales)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let detectedLocale: string | undefined</span><span class="s3">\n\n  </span><span class="s1">// The first segment will be empty, because it has a leading `/`. If</span><span class="s3">\n  </span><span class="s1">// there is no further segment, there is no locale (or it's the default).</span><span class="s3">\n  </span><span class="s1">const segments = pathname.split('/', 2)</span><span class="s3">\n\n  </span><span class="s1">// If there's no second segment (ie, the pathname is just `/`), there's no</span><span class="s3">\n  </span><span class="s1">// locale.</span><span class="s3">\n  </span><span class="s1">if (!segments[1]) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// The second segment will contain the locale part if any.</span><span class="s3">\n  </span><span class="s1">const segment = segments[1].toLowerCase()</span><span class="s3">\n\n  </span><span class="s1">// See if the segment matches one of the locales. If it doesn't, there is</span><span class="s3">\n  </span><span class="s1">// no locale (or it's the default).</span><span class="s3">\n  </span><span class="s1">const index = lowercasedLocales.indexOf(segment)</span><span class="s3">\n  </span><span class="s1">if (index &lt; 0) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// Return the case-sensitive locale.</span><span class="s3">\n  </span><span class="s1">detectedLocale = locales[index]</span><span class="s3">\n\n  </span><span class="s1">// Remove the `/${locale}` part of the pathname.</span><span class="s3">\n  </span><span class="s1">pathname = pathname.slice(detectedLocale.length + 1) || '/'</span><span class="s3">\n\n  </span><span class="s1">return { pathname, detectedLocale }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* For a given page path, this function ensures that there is a leading slash.</span><span class="s3">\n </span><span class="s1">* If there is not a leading slash, one is added, otherwise it is noop.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function ensureLeadingSlash(path: string) {</span><span class="s3">\n  </span><span class="s1">return path.startsWith('/') ? path : `/${path}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { isGroupSegment } from '../../segment'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes an app route so it represents the actual request path. Essentially</span><span class="s3">\n </span><span class="s1">* performing the following transformations:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/user/[id]/page` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/account/page` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/user/[id]/page` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/account/page` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/page` to `/`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/user/[id]/route` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/account/route` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/user/[id]/route` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/account/route` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/route` to `/`</span><span class="s3">\n </span><span class="s1">* - `/` to `/`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param route the app route to normalize</span><span class="s3">\n </span><span class="s1">* @returns the normalized pathname</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeAppPath(route: string) {</span><span class="s3">\n  </span><span class="s1">return ensureLeadingSlash(</span><span class="s3">\n    </span><span class="s1">route.split('/').reduce((pathname, segment, index, segments) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Empty segments are ignored.</span><span class="s3">\n      </span><span class="s1">if (!segment) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Groups are ignored.</span><span class="s3">\n      </span><span class="s1">if (isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Parallel segments are ignored.</span><span class="s3">\n      </span><span class="s1">if (segment[0] === '@') {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// The last segment (if it's a leaf) should be ignored.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(segment === 'page' || segment === 'route') &amp;&amp;</span><span class="s3">\n        </span><span class="s1">index === segments.length - 1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${pathname}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips the `.rsc` extension if it's in the pathname.</span><span class="s3">\n </span><span class="s1">* Since this function is used on full urls it checks `?` for searchParams handling.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeRscURL(url: string) {</span><span class="s3">\n  </span><span class="s1">return url.replace(</span><span class="s3">\n    </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.rsc($|</span><span class="s3">\\</span><span class="s1">?)/,</span><span class="s3">\n    </span><span class="s1">// $1 ensures `?` is preserved</span><span class="s3">\n    </span><span class="s1">'$1'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Segment } from '../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">export function isGroupSegment(segment: string) {</span><span class="s3">\n  </span><span class="s1">// Use array[0] for performant purpose</span><span class="s3">\n  </span><span class="s1">return segment[0] === '(' &amp;&amp; segment.endsWith(')')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isParallelRouteSegment(segment: string) {</span><span class="s3">\n  </span><span class="s1">return segment.startsWith('@') &amp;&amp; segment !== '@children'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function addSearchParamsIfPageSegment(</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">searchParams: Record&lt;string, string | string[] | undefined&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)</span><span class="s3">\n\n  </span><span class="s1">if (isPageSegment) {</span><span class="s3">\n    </span><span class="s1">const stringifiedQuery = JSON.stringify(searchParams)</span><span class="s3">\n    </span><span class="s1">return stringifiedQuery !== '{}'</span><span class="s3">\n      </span><span class="s1">? PAGE_SEGMENT_KEY + '?' + stringifiedQuery</span><span class="s3">\n      </span><span class="s1">: PAGE_SEGMENT_KEY</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const PAGE_SEGMENT_KEY = '__PAGE__'</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SEGMENT_KEY = '__DEFAULT__'</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizeAppPath } from './app-paths'</span><span class="s3">\n\n</span><span class="s1">// order matters here, the first match will be used</span><span class="s3">\n</span><span class="s1">export const INTERCEPTION_ROUTE_MARKERS = [</span><span class="s3">\n  </span><span class="s1">'(..)(..)',</span><span class="s3">\n  </span><span class="s1">'(.)',</span><span class="s3">\n  </span><span class="s1">'(..)',</span><span class="s3">\n  </span><span class="s1">'(...)',</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteAppPath(path: string): boolean {</span><span class="s3">\n  </span><span class="s1">// TODO-APP: add more serious validation</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">path</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n      </span><span class="s1">.find((segment) =&gt;</span><span class="s3">\n        </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n      </span><span class="s1">) !== undefined</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractInterceptionRouteInformation(path: string) {</span><span class="s3">\n  </span><span class="s1">let interceptingRoute: string | undefined,</span><span class="s3">\n    </span><span class="s1">marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,</span><span class="s3">\n    </span><span class="s1">interceptedRoute: string | undefined</span><span class="s3">\n\n  </span><span class="s1">for (const segment of path.split('/')) {</span><span class="s3">\n    </span><span class="s1">marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n    </span><span class="s1">if (marker) {</span><span class="s3">\n      </span><span class="s1">;[interceptingRoute, interceptedRoute] = path.split(marker, 2)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!interceptingRoute || !marker || !interceptedRoute) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid interception route: ${path}. Must be in the format /&lt;intercepting route&gt;/(..|...|..)(..)/&lt;intercepted route&gt;`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -&gt; /feed</span><span class="s3">\n\n  </span><span class="s1">switch (marker) {</span><span class="s3">\n    </span><span class="s1">case '(.)':</span><span class="s3">\n      </span><span class="s1">// (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = `/${interceptedRoute}`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = interceptingRoute + '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)':</span><span class="s3">\n      </span><span class="s1">// (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">interceptedRoute = interceptingRoute</span><span class="s3">\n        </span><span class="s1">.split('/')</span><span class="s3">\n        </span><span class="s1">.slice(0, -1)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(...)':</span><span class="s3">\n      </span><span class="s1">// (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route</span><span class="s3">\n      </span><span class="s1">interceptedRoute = '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)(..)':</span><span class="s3">\n      </span><span class="s1">// (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route</span><span class="s3">\n\n      </span><span class="s1">const splitInterceptingRoute = interceptingRoute.split('/')</span><span class="s3">\n      </span><span class="s1">if (splitInterceptingRoute.length &lt;= 2) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">interceptedRoute = splitInterceptingRoute</span><span class="s3">\n        </span><span class="s1">.slice(0, -2)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: unexpected marker')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { interceptingRoute, interceptedRoute }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from './interception-routes'</span><span class="s3">\n\n</span><span class="s1">// Identify /.*[param].*/ in route string</span><span class="s3">\n</span><span class="s1">const TEST_ROUTE = /</span><span class="s3">\\</span><span class="s1">/[^/]*</span><span class="s3">\\</span><span class="s1">[[^/]+</span><span class="s3">\\</span><span class="s1">][^/]*(?=</span><span class="s3">\\</span><span class="s1">/|$)/</span><span class="s3">\n\n</span><span class="s1">// Identify /[param]/ in route string</span><span class="s3">\n</span><span class="s1">const TEST_STRICT_ROUTE = /</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">[[^/]+</span><span class="s3">\\</span><span class="s1">](?=</span><span class="s3">\\</span><span class="s1">/|$)/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if a route is dynamic.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param route - The route to check.</span><span class="s3">\n </span><span class="s1">* @param strict - Whether to use strict mode which prohibits segments with prefixes/suffixes (default: true).</span><span class="s3">\n </span><span class="s1">* @returns Whether the route is dynamic.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isDynamicRoute(route: string, strict: boolean = true): boolean {</span><span class="s3">\n  </span><span class="s1">if (isInterceptionRouteAppPath(route)) {</span><span class="s3">\n    </span><span class="s1">route = extractInterceptionRouteInformation(route).interceptedRoute</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (strict) {</span><span class="s3">\n    </span><span class="s1">return TEST_STRICT_ROUTE.test(route)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return TEST_ROUTE.test(route)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Given a path this function will find the pathname, query and hash and return</span><span class="s3">\n </span><span class="s1">* them. This is useful to parse full paths on the client side.</span><span class="s3">\n </span><span class="s1">* @param path A path to parse e.g. /foo/bar?id=1#hash</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parsePath(path: string) {</span><span class="s3">\n  </span><span class="s1">const hashIndex = path.indexOf('#')</span><span class="s3">\n  </span><span class="s1">const queryIndex = path.indexOf('?')</span><span class="s3">\n  </span><span class="s1">const hasQuery = queryIndex &gt; -1 &amp;&amp; (hashIndex &lt; 0 || queryIndex &lt; hashIndex)</span><span class="s3">\n\n  </span><span class="s1">if (hasQuery || hashIndex &gt; -1) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),</span><span class="s3">\n      </span><span class="s1">query: hasQuery</span><span class="s3">\n        </span><span class="s1">? path.substring(queryIndex, hashIndex &gt; -1 ? hashIndex : undefined)</span><span class="s3">\n        </span><span class="s1">: '',</span><span class="s3">\n      </span><span class="s1">hash: hashIndex &gt; -1 ? path.slice(hashIndex) : '',</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { pathname: path, query: '', hash: '' }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a given path starts with a given prefix. It ensures it matches</span><span class="s3">\n </span><span class="s1">* exactly without containing extra chars. e.g. prefix /docs should replace</span><span class="s3">\n </span><span class="s1">* for /docs, /docs/, /docs/a but not /docsss</span><span class="s3">\n </span><span class="s1">* @param path The path to check.</span><span class="s3">\n </span><span class="s1">* @param prefix The prefix to check against.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function pathHasPrefix(path: string, prefix: string) {</span><span class="s3">\n  </span><span class="s1">if (typeof path !== 'string') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return pathname === prefix || pathname.startsWith(prefix + '/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a path and a prefix it will remove the prefix when it exists in the</span><span class="s3">\n </span><span class="s1">* given path. It ensures it matches exactly without containing extra chars</span><span class="s3">\n </span><span class="s1">* and if the prefix is not there it will be noop.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param path The path to remove the prefix from.</span><span class="s3">\n </span><span class="s1">* @param prefix The prefix to be removed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removePathPrefix(path: string, prefix: string): string {</span><span class="s3">\n  </span><span class="s1">// If the path doesn't start with the prefix we can return it as is. This</span><span class="s3">\n  </span><span class="s1">// protects us from situations where the prefix is a substring of the path</span><span class="s3">\n  </span><span class="s1">// prefix such as:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// For prefix: /blog</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   /blog -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blog/ -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blog/1 -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blogging -&gt; false</span><span class="s3">\n  </span><span class="s1">//   /blogging/ -&gt; false</span><span class="s3">\n  </span><span class="s1">//   /blogging/1 -&gt; false</span><span class="s3">\n  </span><span class="s1">if (!pathHasPrefix(path, prefix)) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Remove the prefix from the path via slicing.</span><span class="s3">\n  </span><span class="s1">const withoutPrefix = path.slice(prefix.length)</span><span class="s3">\n\n  </span><span class="s1">// If the path without the prefix starts with a `/` we can return it as is.</span><span class="s3">\n  </span><span class="s1">if (withoutPrefix.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">return withoutPrefix</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If the path without the prefix doesn't start with a `/` we need to add it</span><span class="s3">\n  </span><span class="s1">// back to the path to make sure it's a valid path.</span><span class="s3">\n  </span><span class="s1">return `/${withoutPrefix}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// regexp is based on https://github.com/sindresorhus/escape-string-regexp</span><span class="s3">\n</span><span class="s1">const reHasRegExp = /[|</span><span class="s3">\\\\</span><span class="s1">{}()[</span><span class="s3">\\</span><span class="s1">]^$+*?.-]/</span><span class="s3">\n</span><span class="s1">const reReplaceRegExp = /[|</span><span class="s3">\\\\</span><span class="s1">{}()[</span><span class="s3">\\</span><span class="s1">]^$+*?.-]/g</span><span class="s3">\n\n</span><span class="s1">export function escapeStringRegexp(str: string) {</span><span class="s3">\n  </span><span class="s1">// see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23</span><span class="s3">\n  </span><span class="s1">if (reHasRegExp.test(str)) {</span><span class="s3">\n    </span><span class="s1">return str.replace(reReplaceRegExp, '</span><span class="s3">\\\\</span><span class="s1">$&amp;')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return str</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Removes the trailing slash for a given route or page path. Preserves the</span><span class="s3">\n </span><span class="s1">* root page. Examples:</span><span class="s3">\n </span><span class="s1">*   - `/foo/bar/` -&gt; `/foo/bar`</span><span class="s3">\n </span><span class="s1">*   - `/foo/bar` -&gt; `/foo/bar`</span><span class="s3">\n </span><span class="s1">*   - `/` -&gt; `/`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removeTrailingSlash(route: string) {</span><span class="s3">\n  </span><span class="s1">return route.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '') || '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { DynamicParam } from '../../../../server/app-render/app-render'</span><span class="s3">\n</span><span class="s1">import type { DynamicParamTypesShort } from '../../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { FallbackRouteParams } from '../../../../server/request/fallback-params'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Shared logic on client and server for creating a dynamic param value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This code needs to be shared with the client so it can extract dynamic route</span><span class="s3">\n </span><span class="s1">* params from the URL without a server request.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Because everything in this module is sent to the client, we should aim to</span><span class="s3">\n </span><span class="s1">* keep this code as simple as possible. The special case handling for catchall</span><span class="s3">\n </span><span class="s1">* and optional is, alas, unfortunate.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getDynamicParam(</span><span class="s3">\n  </span><span class="s1">params: { [key: string]: any },</span><span class="s3">\n  </span><span class="s1">segmentKey: string,</span><span class="s3">\n  </span><span class="s1">dynamicParamType: DynamicParamTypesShort,</span><span class="s3">\n  </span><span class="s1">pagePath: string,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">): DynamicParam {</span><span class="s3">\n  </span><span class="s1">let value = params[segmentKey]</span><span class="s3">\n\n  </span><span class="s1">if (fallbackRouteParams &amp;&amp; fallbackRouteParams.has(segmentKey)) {</span><span class="s3">\n    </span><span class="s1">value = fallbackRouteParams.get(segmentKey)</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">value = value.map((i) =&gt; encodeURIComponent(i))</span><span class="s3">\n  </span><span class="s1">} else if (typeof value === 'string') {</span><span class="s3">\n    </span><span class="s1">value = encodeURIComponent(value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!value) {</span><span class="s3">\n    </span><span class="s1">const isCatchall = dynamicParamType === 'c'</span><span class="s3">\n    </span><span class="s1">const isOptionalCatchall = dynamicParamType === 'oc'</span><span class="s3">\n\n    </span><span class="s1">if (isCatchall || isOptionalCatchall) {</span><span class="s3">\n      </span><span class="s1">// handle the case where an optional catchall does not have a value,</span><span class="s3">\n      </span><span class="s1">// e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`</span><span class="s3">\n      </span><span class="s1">if (isOptionalCatchall) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">param: segmentKey,</span><span class="s3">\n          </span><span class="s1">value: null,</span><span class="s3">\n          </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n          </span><span class="s1">treeSegment: [segmentKey, '', dynamicParamType],</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// handle the case where a catchall or optional catchall does not have a value,</span><span class="s3">\n      </span><span class="s1">// e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched</span><span class="s3">\n      </span><span class="s1">value = pagePath</span><span class="s3">\n        </span><span class="s1">.split('/')</span><span class="s3">\n        </span><span class="s1">// remove the first empty string</span><span class="s3">\n        </span><span class="s1">.slice(1)</span><span class="s3">\n        </span><span class="s1">// replace any dynamic params with the actual values</span><span class="s3">\n        </span><span class="s1">.flatMap((pathSegment) =&gt; {</span><span class="s3">\n          </span><span class="s1">const param = parseParameter(pathSegment)</span><span class="s3">\n          </span><span class="s1">// if the segment matches a param, return the param value</span><span class="s3">\n          </span><span class="s1">// otherwise, it's a static segment, so just return that</span><span class="s3">\n          </span><span class="s1">return params[param.key] ?? param.key</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">param: segmentKey,</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n        </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n        </span><span class="s1">// This value always has to be a string.</span><span class="s3">\n        </span><span class="s1">treeSegment: [segmentKey, value.join('/'), dynamicParamType],</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">param: segmentKey,</span><span class="s3">\n    </span><span class="s1">// The value that is passed to user code.</span><span class="s3">\n    </span><span class="s1">value: value,</span><span class="s3">\n    </span><span class="s1">// The value that is rendered in the router tree.</span><span class="s3">\n    </span><span class="s1">treeSegment: [</span><span class="s3">\n      </span><span class="s1">segmentKey,</span><span class="s3">\n      </span><span class="s1">Array.isArray(value) ? value.join('/') : value,</span><span class="s3">\n      </span><span class="s1">dynamicParamType,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Regular expression pattern used to match route parameters.</span><span class="s3">\n </span><span class="s1">* Matches both single parameters and parameter groups.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false</span><span class="s3">\n </span><span class="s1">*   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true</span><span class="s3">\n </span><span class="s1">*   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const PARAMETER_PATTERN = /^([^[]*)</span><span class="s3">\\</span><span class="s1">[((?:</span><span class="s3">\\</span><span class="s1">[[^</span><span class="s3">\\</span><span class="s1">]]*</span><span class="s3">\\</span><span class="s1">])|[^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">](.*)$/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses a given parameter from a route to a data structure that can be used</span><span class="s3">\n </span><span class="s1">* to generate the parametrized route.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[[...slug]]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `[[foo]]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `[bar]` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `fizz` -&gt; `{ key: 'fizz', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">* @param param - The parameter to parse.</span><span class="s3">\n </span><span class="s1">* @returns The parsed parameter as a data structure.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseParameter(param: string) {</span><span class="s3">\n  </span><span class="s1">const match = param.match(PARAMETER_PATTERN)</span><span class="s3">\n\n  </span><span class="s1">if (!match) {</span><span class="s3">\n    </span><span class="s1">return parseMatchedParameter(param)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return parseMatchedParameter(match[2])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used</span><span class="s3">\n </span><span class="s1">* to generate the parametrized route.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `...slug` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `[foo]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `bar` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">* @param param - The matched parameter to parse.</span><span class="s3">\n </span><span class="s1">* @returns The parsed parameter as a data structure.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseMatchedParameter(param: string) {</span><span class="s3">\n  </span><span class="s1">const optional = param.startsWith('[') &amp;&amp; param.endsWith(']')</span><span class="s3">\n  </span><span class="s1">if (optional) {</span><span class="s3">\n    </span><span class="s1">param = param.slice(1, -1)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const repeat = param.startsWith('...')</span><span class="s3">\n  </span><span class="s1">if (repeat) {</span><span class="s3">\n    </span><span class="s1">param = param.slice(3)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return { key: param, repeat, optional }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from './remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { PARAMETER_PATTERN, parseMatchedParameter } from './get-dynamic-param'</span><span class="s3">\n\n</span><span class="s1">export interface Group {</span><span class="s3">\n  </span><span class="s1">pos: number</span><span class="s3">\n  </span><span class="s1">repeat: boolean</span><span class="s3">\n  </span><span class="s1">optional: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RouteRegex {</span><span class="s3">\n  </span><span class="s1">groups: { [groupName: string]: Group }</span><span class="s3">\n  </span><span class="s1">re: RegExp</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetNamedRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n   </span><span class="s1">* or NEXT_QUERY_PARAM_PREFIX. This is only relevant when creating the</span><span class="s3">\n   </span><span class="s1">* routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the suffix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to backtrack duplicate keys. This is only relevant when creating</span><span class="s3">\n   </span><span class="s1">* the routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include extra parts in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">* of adding this option.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const groups: { [groupName: string]: Group } = {}</span><span class="s3">\n  </span><span class="s1">let groupIndex = 1</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const markerMatch = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (markerMatch &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(markerMatch)}([^/]+?)`)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, repeat, optional } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">parameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* From a normalized route this function generates a regular expression and</span><span class="s3">\n </span><span class="s1">* a corresponding groups object intended to be used to store matching groups</span><span class="s3">\n </span><span class="s1">* from the regular expression.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">includeSuffix = false,</span><span class="s3">\n    </span><span class="s1">includePrefix = false,</span><span class="s3">\n    </span><span class="s1">excludeOptionalTrailingSlash = false,</span><span class="s3">\n  </span><span class="s1">}: GetRouteRegexOptions = {}</span><span class="s3">\n</span><span class="s1">): RouteRegex {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute, groups } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">includeSuffix,</span><span class="s3">\n    </span><span class="s1">includePrefix</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let re = parameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">re += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">re: new RegExp(`^${re}$`),</span><span class="s3">\n    </span><span class="s1">groups: groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Builds a function to generate a minimal routeKey using only a-z and minimal</span><span class="s3">\n </span><span class="s1">* number of characters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildGetSafeRouteKey() {</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n\n  </span><span class="s1">return () =&gt; {</span><span class="s3">\n    </span><span class="s1">let routeKey = ''</span><span class="s3">\n    </span><span class="s1">let j = ++i</span><span class="s3">\n    </span><span class="s1">while (j &gt; 0) {</span><span class="s3">\n      </span><span class="s1">routeKey += String.fromCharCode(97 + ((j - 1) % 26))</span><span class="s3">\n      </span><span class="s1">j = Math.floor((j - 1) / 26)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return routeKey</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getSafeKeyFromSegment({</span><span class="s3">\n  </span><span class="s1">interceptionMarker,</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n  </span><span class="s1">segment,</span><span class="s3">\n  </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">keyPrefix,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">interceptionMarker?: string</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey: () =&gt; string</span><span class="s3">\n  </span><span class="s1">segment: string</span><span class="s3">\n  </span><span class="s1">routeKeys: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">keyPrefix?: string</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(segment)</span><span class="s3">\n\n  </span><span class="s1">// replace any non-word characters since they can break</span><span class="s3">\n  </span><span class="s1">// the named regex</span><span class="s3">\n  </span><span class="s1">let cleanedKey = key.replace(/</span><span class="s3">\\</span><span class="s1">W/g, '')</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = `${keyPrefix}${cleanedKey}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let invalidKey = false</span><span class="s3">\n\n  </span><span class="s1">// check if the key is still invalid and fallback to using a known</span><span class="s3">\n  </span><span class="s1">// safe key</span><span class="s3">\n  </span><span class="s1">if (cleanedKey.length === 0 || cleanedKey.length &gt; 30) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (invalidKey) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = getSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const duplicateKey = cleanedKey in routeKeys</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = `${keyPrefix}${key}`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = key</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if the segment has an interception marker, make sure that's part of the regex pattern</span><span class="s3">\n  </span><span class="s1">// this is to ensure that the route with the interception marker doesn't incorrectly match</span><span class="s3">\n  </span><span class="s1">// the non-intercepted route (ie /app/(.)[username] should not match /app/[username])</span><span class="s3">\n  </span><span class="s1">const interceptionPrefix = interceptionMarker</span><span class="s3">\n    </span><span class="s1">? escapeStringRegexp(interceptionMarker)</span><span class="s3">\n    </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">let pattern: string</span><span class="s3">\n  </span><span class="s1">if (duplicateKey &amp;&amp; backreferenceDuplicateKeys) {</span><span class="s3">\n    </span><span class="s1">// Use a backreference to the key to ensure that the key is the same value</span><span class="s3">\n    </span><span class="s1">// in each of the placeholders.</span><span class="s3">\n    </span><span class="s1">pattern = `</span><span class="s3">\\\\</span><span class="s1">k&lt;${cleanedKey}&gt;`</span><span class="s3">\n  </span><span class="s1">} else if (repeat) {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;.+?)`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;[^/]+?)`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return optional</span><span class="s3">\n    </span><span class="s1">? `(?:/${interceptionPrefix}${pattern})?`</span><span class="s3">\n    </span><span class="s1">: `/${interceptionPrefix}${pattern}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getNamedParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const getSafeRouteKey = buildGetSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">const routeKeys: { [named: string]: string } = {}</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const hasInterceptionMarker = INTERCEPTION_ROUTE_MARKERS.some((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (hasInterceptionMarker &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's an interception marker, add it to the segments.</span><span class="s3">\n      </span><span class="s1">segments.push(</span><span class="s3">\n        </span><span class="s1">getSafeKeyFromSegment({</span><span class="s3">\n          </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n          </span><span class="s1">interceptionMarker: paramMatches[1],</span><span class="s3">\n          </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n          </span><span class="s1">routeKeys,</span><span class="s3">\n          </span><span class="s1">keyPrefix: prefixRouteKeys</span><span class="s3">\n            </span><span class="s1">? NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n            </span><span class="s1">: undefined,</span><span class="s3">\n          </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's a prefix, add it to the segments if it's enabled.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = getSafeKeyFromSegment({</span><span class="s3">\n        </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n        </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n        </span><span class="s1">routeKeys,</span><span class="s3">\n        </span><span class="s1">keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,</span><span class="s3">\n        </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedParameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function extends `getRouteRegex` generating also a named regexp where</span><span class="s3">\n </span><span class="s1">* each group is named along with a routeKeys object that indexes the assigned</span><span class="s3">\n </span><span class="s1">* named group with its corresponding key. When the routeKeys need to be</span><span class="s3">\n </span><span class="s1">* prefixed to uniquely identify internally the </span><span class="s3">\&quot;</span><span class="s1">prefixRouteKey</span><span class="s3">\&quot; </span><span class="s1">arg should</span><span class="s3">\n </span><span class="s1">* be </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot; </span><span class="s1">currently this is only the case when creating the routes-manifest</span><span class="s3">\n </span><span class="s1">* during the build</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: GetNamedRouteRegexOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const result = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">options.prefixRouteKeys,</span><span class="s3">\n    </span><span class="s1">options.includeSuffix ?? false,</span><span class="s3">\n    </span><span class="s1">options.includePrefix ?? false,</span><span class="s3">\n    </span><span class="s1">options.backreferenceDuplicateKeys ?? false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let namedRegex = result.namedParameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!options.excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">namedRegex += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...getRouteRegex(normalizedRoute, options),</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedRegex}$`,</span><span class="s3">\n    </span><span class="s1">routeKeys: result.routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a named regexp.</span><span class="s3">\n </span><span class="s1">* This is intended to be using for build time only.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedMiddlewareRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">catchAll?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const { catchAll = true } = options</span><span class="s3">\n  </span><span class="s1">if (parameterizedRoute === '/') {</span><span class="s3">\n    </span><span class="s1">let catchAllRegex = catchAll ? '.*' : ''</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">namedRegex: `^/${catchAllRegex}$`,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { namedParameterizedRoute } = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : ''</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { HtmlProps } from './html-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { ComponentType, JSX } from 'react'</span><span class="s3">\n</span><span class="s1">import type { DomainLocale } from '../../server/config'</span><span class="s3">\n</span><span class="s1">import type { Env } from '@next/env'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { NextRouter } from './router/router'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../types'</span><span class="s3">\n</span><span class="s1">import type { COMPILER_NAMES } from './constants'</span><span class="s3">\n</span><span class="s1">import type fs from 'fs'</span><span class="s3">\n\n</span><span class="s1">export type NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">Context extends BaseContext = NextPageContext,</span><span class="s3">\n  </span><span class="s1">InitialProps = {},</span><span class="s3">\n  </span><span class="s1">Props = {},</span><span class="s3">\n</span><span class="s1">&gt; = ComponentType&lt;Props&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.</span><span class="s3">\n   </span><span class="s1">* Make sure to return plain `Object` without using `Date`, `Map`, `Set`.</span><span class="s3">\n   </span><span class="s1">* @param context Context of `page`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getInitialProps?(context: Context): InitialProps | Promise&lt;InitialProps&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentType = NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">DocumentContext,</span><span class="s3">\n  </span><span class="s1">DocumentInitialProps,</span><span class="s3">\n  </span><span class="s1">DocumentProps</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppType&lt;P = {}&gt; = NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">AppContextType,</span><span class="s3">\n  </span><span class="s1">P,</span><span class="s3">\n  </span><span class="s1">AppPropsType&lt;any, P&gt;</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppTreeType = ComponentType&lt;</span><span class="s3">\n  </span><span class="s1">AppInitialProps &amp; { [name: string]: any }</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.</span><span class="s3">\n </span><span class="s1">* https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const</span><span class="s3">\n</span><span class="s1">export type NextWebVitalsMetric = {</span><span class="s3">\n  </span><span class="s1">id: string</span><span class="s3">\n  </span><span class="s1">startTime: number</span><span class="s3">\n  </span><span class="s1">value: number</span><span class="s3">\n  </span><span class="s1">attribution?: { [key: string]: unknown }</span><span class="s3">\n</span><span class="s1">} &amp; (</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">label: 'web-vital'</span><span class="s3">\n      </span><span class="s1">name: (typeof WEB_VITALS)[number]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">label: 'custom'</span><span class="s3">\n      </span><span class="s1">name:</span><span class="s3">\n        </span><span class="s1">| 'Next.js-hydration'</span><span class="s3">\n        </span><span class="s1">| 'Next.js-route-change-to-render'</span><span class="s3">\n        </span><span class="s1">| 'Next.js-render'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export type Enhancer&lt;C&gt; = (Component: C) =&gt; C</span><span class="s3">\n\n</span><span class="s1">export type ComponentsEnhancer =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">enhanceApp?: Enhancer&lt;AppType&gt;</span><span class="s3">\n      </span><span class="s1">enhanceComponent?: Enhancer&lt;NextComponentType&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| Enhancer&lt;NextComponentType&gt;</span><span class="s3">\n\n</span><span class="s1">export type RenderPageResult = {</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">head?: Array&lt;JSX.Element | null&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderPage = (</span><span class="s3">\n  </span><span class="s1">options?: ComponentsEnhancer</span><span class="s3">\n</span><span class="s1">) =&gt; DocumentInitialProps | Promise&lt;DocumentInitialProps&gt;</span><span class="s3">\n\n</span><span class="s1">export type BaseContext = {</span><span class="s3">\n  </span><span class="s1">res?: ServerResponse</span><span class="s3">\n  </span><span class="s1">[k: string]: any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NEXT_DATA = {</span><span class="s3">\n  </span><span class="s1">props: Record&lt;string, any&gt;</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">runtimeConfig?: { [key: string]: any }</span><span class="s3">\n  </span><span class="s1">nextExport?: boolean</span><span class="s3">\n  </span><span class="s1">autoExport?: boolean</span><span class="s3">\n  </span><span class="s1">isFallback?: boolean</span><span class="s3">\n  </span><span class="s1">isExperimentalCompile?: boolean</span><span class="s3">\n  </span><span class="s1">dynamicIds?: (string | number)[]</span><span class="s3">\n  </span><span class="s1">err?: Error &amp; {</span><span class="s3">\n    </span><span class="s1">statusCode?: number</span><span class="s3">\n    </span><span class="s1">source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">gsp?: boolean</span><span class="s3">\n  </span><span class="s1">gssp?: boolean</span><span class="s3">\n  </span><span class="s1">customServer?: boolean</span><span class="s3">\n  </span><span class="s1">gip?: boolean</span><span class="s3">\n  </span><span class="s1">appGip?: boolean</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">domainLocales?: readonly DomainLocale[]</span><span class="s3">\n  </span><span class="s1">scriptLoader?: any[]</span><span class="s3">\n  </span><span class="s1">isPreview?: boolean</span><span class="s3">\n  </span><span class="s1">notFoundSrcPage?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* `Next` context</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NextPageContext {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Error object if encountered during rendering</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">err?: (Error &amp; { statusCode?: number }) | null</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `HTTP` request object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">req?: IncomingMessage</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `HTTP` response object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">res?: ServerResponse</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Path section of `URL`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Query string section of `URL` parsed as an object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `String` of the actual path including query.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">asPath?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The currently active locale</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* All configured locales</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The configured default locale</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `Component` the tree of the App to use if needing to render separately</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">AppTree: AppTreeType</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppContextType&lt;Router extends NextRouter = NextRouter&gt; = {</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType&lt;NextPageContext&gt;</span><span class="s3">\n  </span><span class="s1">AppTree: AppTreeType</span><span class="s3">\n  </span><span class="s1">ctx: NextPageContext</span><span class="s3">\n  </span><span class="s1">router: Router</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppInitialProps&lt;PageProps = any&gt; = {</span><span class="s3">\n  </span><span class="s1">pageProps: PageProps</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppPropsType&lt;</span><span class="s3">\n  </span><span class="s1">Router extends NextRouter = NextRouter,</span><span class="s3">\n  </span><span class="s1">PageProps = {},</span><span class="s3">\n</span><span class="s1">&gt; = AppInitialProps&lt;PageProps&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType&lt;NextPageContext, any, any&gt;</span><span class="s3">\n  </span><span class="s1">router: Router</span><span class="s3">\n  </span><span class="s1">__N_SSG?: boolean</span><span class="s3">\n  </span><span class="s1">__N_SSP?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentContext = NextPageContext &amp; {</span><span class="s3">\n  </span><span class="s1">renderPage: RenderPage</span><span class="s3">\n  </span><span class="s1">defaultGetInitialProps(</span><span class="s3">\n    </span><span class="s1">ctx: DocumentContext,</span><span class="s3">\n    </span><span class="s1">options?: { nonce?: string }</span><span class="s3">\n  </span><span class="s1">): Promise&lt;DocumentInitialProps&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentInitialProps = RenderPageResult &amp; {</span><span class="s3">\n  </span><span class="s1">styles?: React.ReactElement[] | Iterable&lt;React.ReactNode&gt; | JSX.Element</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentProps = DocumentInitialProps &amp; HtmlProps</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route request</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NextApiRequest extends IncomingMessage {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object of `query` values from url</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: Partial&lt;{</span><span class="s3">\n    </span><span class="s1">[key: string]: string | string[]</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object of `cookies` from header</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cookies: Partial&lt;{</span><span class="s3">\n    </span><span class="s1">[key: string]: string</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n\n  </span><span class="s1">body: any</span><span class="s3">\n\n  </span><span class="s1">env: Env</span><span class="s3">\n\n  </span><span class="s1">draftMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">preview?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Preview data set on the request, if any</span><span class="s3">\n   </span><span class="s1">* */</span><span class="s3">\n  </span><span class="s1">previewData?: PreviewData</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Send body of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type Send&lt;T&gt; = (body: T) =&gt; void</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NextApiResponse&lt;Data = any&gt; = ServerResponse &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Send data `any` data in response</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">send: Send&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Send data `json` data in response</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">json: Send&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">status: (statusCode: number) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">redirect(url: string): NextApiResponse&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">redirect(status: number, url: string): NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set draft mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setDraftMode: (options: { enable: boolean }) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set preview data for Next.js' prerender mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setPreviewData: (</span><span class="s3">\n    </span><span class="s1">data: object | string,</span><span class="s3">\n    </span><span class="s1">options?: {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Specifies the number (in seconds) for the preview session to last for.</span><span class="s3">\n       </span><span class="s1">* The given number will be converted to an integer by rounding down.</span><span class="s3">\n       </span><span class="s1">* By default, no maximum age is set and the preview session finishes</span><span class="s3">\n       </span><span class="s1">* when the client shuts down (browser is closed).</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">maxAge?: number</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Specifies the path for the preview session to work under. By default,</span><span class="s3">\n       </span><span class="s1">* the path is considered the </span><span class="s3">\&quot;</span><span class="s1">default path</span><span class="s3">\&quot;</span><span class="s1">, i.e., any pages under </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">path?: string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Clear preview data for Next.js' prerender mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clearPreviewData: (options?: { path?: string }) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Revalidate a specific page and regenerate it using On-Demand Incremental</span><span class="s3">\n   </span><span class="s1">* Static Regeneration.</span><span class="s3">\n   </span><span class="s1">* The path should be an actual path, not a rewritten path. E.g. for</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">/blog/[slug]</span><span class="s3">\&quot; </span><span class="s1">this should be </span><span class="s3">\&quot;</span><span class="s1">/blog/post-1</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n   </span><span class="s1">* @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">revalidate: (</span><span class="s3">\n    </span><span class="s1">urlPath: string,</span><span class="s3">\n    </span><span class="s1">opts?: {</span><span class="s3">\n      </span><span class="s1">unstable_onlyGenerated?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route handler</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NextApiHandler&lt;T = any&gt; = (</span><span class="s3">\n  </span><span class="s1">req: NextApiRequest,</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; unknown | Promise&lt;unknown&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utils</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function execOnce&lt;T extends (...args: any[]) =&gt; ReturnType&lt;T&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">fn: T</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">let used = false</span><span class="s3">\n  </span><span class="s1">let result: ReturnType&lt;T&gt;</span><span class="s3">\n\n  </span><span class="s1">return ((...args: any[]) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!used) {</span><span class="s3">\n      </span><span class="s1">used = true</span><span class="s3">\n      </span><span class="s1">result = fn(...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1</span><span class="s3">\n</span><span class="s1">// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3</span><span class="s3">\n</span><span class="s1">const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z</span><span class="s3">\\</span><span class="s1">d+</span><span class="s3">\\</span><span class="s1">-.]*?:/</span><span class="s3">\n</span><span class="s1">export const isAbsoluteUrl = (url: string) =&gt; ABSOLUTE_URL_REGEX.test(url)</span><span class="s3">\n\n</span><span class="s1">export function getLocationOrigin() {</span><span class="s3">\n  </span><span class="s1">const { protocol, hostname, port } = window.location</span><span class="s3">\n  </span><span class="s1">return `${protocol}//${hostname}${port ? ':' + port : ''}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getURL() {</span><span class="s3">\n  </span><span class="s1">const { href } = window.location</span><span class="s3">\n  </span><span class="s1">const origin = getLocationOrigin()</span><span class="s3">\n  </span><span class="s1">return href.substring(origin.length)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getDisplayName&lt;P&gt;(Component: ComponentType&lt;P&gt;) {</span><span class="s3">\n  </span><span class="s1">return typeof Component === 'string'</span><span class="s3">\n    </span><span class="s1">? Component</span><span class="s3">\n    </span><span class="s1">: Component.displayName || Component.name || 'Unknown'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isResSent(res: ServerResponse) {</span><span class="s3">\n  </span><span class="s1">return res.finished || res.headersSent</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeRepeatedSlashes(url: string) {</span><span class="s3">\n  </span><span class="s1">const urlParts = url.split('?')</span><span class="s3">\n  </span><span class="s1">const urlNoQuery = urlParts[0]</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">urlNoQuery</span><span class="s3">\n      </span><span class="s1">// first we replace any non-encoded backslashes with forward</span><span class="s3">\n      </span><span class="s1">// then normalize repeated forward slashes</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/+/g, '/') +</span><span class="s3">\n    </span><span class="s1">(urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function loadGetInitialProps&lt;</span><span class="s3">\n  </span><span class="s1">C extends BaseContext,</span><span class="s3">\n  </span><span class="s1">IP = {},</span><span class="s3">\n  </span><span class="s1">P = {},</span><span class="s3">\n</span><span class="s1">&gt;(App: NextComponentType&lt;C, IP, P&gt;, ctx: C): Promise&lt;IP&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">if (App.prototype?.getInitialProps) {</span><span class="s3">\n      </span><span class="s1">const message = `</span><span class="s3">\&quot;</span><span class="s1">${getDisplayName(</span><span class="s3">\n        </span><span class="s1">App</span><span class="s3">\n      </span><span class="s1">)}.getInitialProps()</span><span class="s3">\&quot; </span><span class="s1">is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`</span><span class="s3">\n      </span><span class="s1">throw new Error(message)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// when called from _app `ctx` is nested in `ctx`</span><span class="s3">\n  </span><span class="s1">const res = ctx.res || (ctx.ctx &amp;&amp; ctx.ctx.res)</span><span class="s3">\n\n  </span><span class="s1">if (!App.getInitialProps) {</span><span class="s3">\n    </span><span class="s1">if (ctx.ctx &amp;&amp; ctx.Component) {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore pageProps default</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {} as IP</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const props = await App.getInitialProps(ctx)</span><span class="s3">\n\n  </span><span class="s1">if (res &amp;&amp; isResSent(res)) {</span><span class="s3">\n    </span><span class="s1">return props</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!props) {</span><span class="s3">\n    </span><span class="s1">const message = `</span><span class="s3">\&quot;</span><span class="s1">${getDisplayName(</span><span class="s3">\n      </span><span class="s1">App</span><span class="s3">\n    </span><span class="s1">)}.getInitialProps()</span><span class="s3">\&quot; </span><span class="s1">should resolve to an object. But found </span><span class="s3">\&quot;</span><span class="s1">${props}</span><span class="s3">\&quot; </span><span class="s1">instead.`</span><span class="s3">\n    </span><span class="s1">throw new Error(message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">if (Object.keys(props).length === 0 &amp;&amp; !ctx.ctx) {</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">`${getDisplayName(</span><span class="s3">\n          </span><span class="s1">App</span><span class="s3">\n        </span><span class="s1">)} returned an empty object from </span><span class="s3">\\</span><span class="s1">`getInitialProps</span><span class="s3">\\</span><span class="s1">`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return props</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const SP = typeof performance !== 'undefined'</span><span class="s3">\n</span><span class="s1">export const ST =</span><span class="s3">\n  </span><span class="s1">SP &amp;&amp;</span><span class="s3">\n  </span><span class="s1">(['mark', 'measure', 'getEntriesByName'] as const).every(</span><span class="s3">\n    </span><span class="s1">(method) =&gt; typeof performance[method] === 'function'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export class DecodeError extends Error {}</span><span class="s3">\n</span><span class="s1">export class NormalizeError extends Error {}</span><span class="s3">\n</span><span class="s1">export class PageNotFoundError extends Error {</span><span class="s3">\n  </span><span class="s1">code: string</span><span class="s3">\n\n  </span><span class="s1">constructor(page: string) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.code = 'ENOENT'</span><span class="s3">\n    </span><span class="s1">this.name = 'PageNotFoundError'</span><span class="s3">\n    </span><span class="s1">this.message = `Cannot find module for page: ${page}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MissingStaticPage extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(page: string, message: string) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.message = `Failed to load static file for page: ${page} ${message}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MiddlewareNotFoundError extends Error {</span><span class="s3">\n  </span><span class="s1">code: string</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.code = 'ENOENT'</span><span class="s3">\n    </span><span class="s1">this.message = `Cannot find the middleware module`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CacheFs {</span><span class="s3">\n  </span><span class="s1">existsSync: typeof fs.existsSync</span><span class="s3">\n  </span><span class="s1">readFile: typeof fs.promises.readFile</span><span class="s3">\n  </span><span class="s1">readFileSync: typeof fs.readFileSync</span><span class="s3">\n  </span><span class="s1">writeFile(f: string, d: any): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">mkdir(dir: string): Promise&lt;void | string&gt;</span><span class="s3">\n  </span><span class="s1">stat(f: string): Promise&lt;{ mtime: Date }&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stringifyError(error: Error) {</span><span class="s3">\n  </span><span class="s1">return JSON.stringify({ message: error.message, stack: error.stack })</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Token } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Route pattern normalization utilities for path-to-regexp compatibility.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* path-to-regexp 6.3.0+ introduced stricter validation that rejects certain</span><span class="s3">\n </span><span class="s1">* patterns commonly used in Next.js interception routes. This module provides</span><span class="s3">\n </span><span class="s1">* normalization functions to make Next.js route patterns compatible with the</span><span class="s3">\n </span><span class="s1">* updated library while preserving all functionality.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Internal separator used to normalize adjacent parameter patterns.</span><span class="s3">\n </span><span class="s1">* This unique marker is inserted between adjacent parameters and stripped out</span><span class="s3">\n </span><span class="s1">* during parameter extraction to avoid conflicts with real URL content.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const PARAM_SEPARATOR = '_NEXTSEP_'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Detects if a route pattern needs normalization for path-to-regexp compatibility.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hasAdjacentParameterIssues(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">if (typeof route !== 'string') return false</span><span class="s3">\n\n  </span><span class="s1">// Check for interception route markers followed immediately by parameters</span><span class="s3">\n  </span><span class="s1">// Pattern: /(.):param, /(..):param, /(...):param, /(.)(.):param etc.</span><span class="s3">\n  </span><span class="s1">// These patterns cause </span><span class="s3">\&quot;</span><span class="s1">Must have text between two parameters</span><span class="s3">\&quot; </span><span class="s1">errors</span><span class="s3">\n  </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">.{1,3}</span><span class="s3">\\</span><span class="s1">):[^/</span><span class="s3">\\</span><span class="s1">s]+/.test(route)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check for basic adjacent parameters without separators</span><span class="s3">\n  </span><span class="s1">// Pattern: :param1:param2 (but not :param* or other URL patterns)</span><span class="s3">\n  </span><span class="s1">if (/:[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z_][a-zA-Z0-9_]*/.test(route)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes route patterns that have adjacent parameters without text between them.</span><span class="s3">\n </span><span class="s1">* Inserts a unique separator that can be safely stripped out later.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeAdjacentParameters(route: string): string {</span><span class="s3">\n  </span><span class="s1">let normalized = route</span><span class="s3">\n\n  </span><span class="s1">// Handle interception route patterns: (.):param -&gt; (.)_NEXTSEP_:param</span><span class="s3">\n  </span><span class="s1">normalized = normalized.replace(</span><span class="s3">\n    </span><span class="s1">/(</span><span class="s3">\\</span><span class="s1">([^)]*</span><span class="s3">\\</span><span class="s1">)):([^/</span><span class="s3">\\</span><span class="s1">s]+)/g,</span><span class="s3">\n    </span><span class="s1">`$1${PARAM_SEPARATOR}:$2`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Handle other adjacent parameter patterns: :param1:param2 -&gt; :param1_NEXTSEP_:param2</span><span class="s3">\n  </span><span class="s1">normalized = normalized.replace(/:([^:/</span><span class="s3">\\</span><span class="s1">s)]+)(?=:)/g, `:$1${PARAM_SEPARATOR}`)</span><span class="s3">\n\n  </span><span class="s1">return normalized</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes tokens that have repeating modifiers (* or +) but empty prefix and suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* path-to-regexp 6.3.0+ introduced validation that throws:</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">Can not repeat without prefix/suffix</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This occurs when a token has modifier: '*' or '+' with both prefix: '' and suffix: ''</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeTokensForRegexp(tokens: Token[]): Token[] {</span><span class="s3">\n  </span><span class="s1">return tokens.map((token) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Token union type: Token = string | TokenObject</span><span class="s3">\n    </span><span class="s1">// Literal path segments are strings, parameters/wildcards are objects</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">typeof token === 'object' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">token !== null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Not all token objects have 'modifier' property (e.g., simple text tokens)</span><span class="s3">\n      </span><span class="s1">'modifier' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Only repeating modifiers (* or +) cause the validation error</span><span class="s3">\n      </span><span class="s1">// Other modifiers like '?' (optional) are fine</span><span class="s3">\n      </span><span class="s1">(token.modifier === '*' || token.modifier === '+') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Token objects can have different shapes depending on route pattern</span><span class="s3">\n      </span><span class="s1">'prefix' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">'suffix' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Both prefix and suffix must be empty strings</span><span class="s3">\n      </span><span class="s1">// This is what causes the validation error in path-to-regexp</span><span class="s3">\n      </span><span class="s1">token.prefix === '' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">token.suffix === ''</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Add minimal prefix to satisfy path-to-regexp validation</span><span class="s3">\n      </span><span class="s1">// We use '/' as it's the most common path delimiter and won't break route matching</span><span class="s3">\n      </span><span class="s1">// The prefix gets used in regex generation but doesn't affect parameter extraction</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">...token,</span><span class="s3">\n        </span><span class="s1">prefix: '/',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return token</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips normalization separators from extracted route parameters.</span><span class="s3">\n </span><span class="s1">* Used by both server and client code to clean up parameters after route matching.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function stripParameterSeparators(</span><span class="s3">\n  </span><span class="s1">params: Record&lt;string, any&gt;</span><span class="s3">\n</span><span class="s1">): Record&lt;string, any&gt; {</span><span class="s3">\n  </span><span class="s1">const cleaned: Record&lt;string, any&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const [key, value] of Object.entries(params)) {</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">// Remove the separator if it appears at the start of parameter values</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">// Handle array parameters (from repeated route segments)</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value.map((item) =&gt;</span><span class="s3">\n        </span><span class="s1">typeof item === 'string'</span><span class="s3">\n          </span><span class="s1">? item.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')</span><span class="s3">\n          </span><span class="s1">: item</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return cleaned</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Client-safe utilities for route matching that don't import server-side</span><span class="s3">\n </span><span class="s1">* utilities to avoid bundling issues with Turbopack</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Key,</span><span class="s3">\n  </span><span class="s1">TokensToRegexpOptions,</span><span class="s3">\n  </span><span class="s1">ParseOptions,</span><span class="s3">\n  </span><span class="s1">TokensToFunctionOptions,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">pathToRegexp,</span><span class="s3">\n  </span><span class="s1">compile,</span><span class="s3">\n  </span><span class="s1">regexpToFunction,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">hasAdjacentParameterIssues,</span><span class="s3">\n  </span><span class="s1">normalizeAdjacentParameters,</span><span class="s3">\n  </span><span class="s1">stripParameterSeparators,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/route-pattern-normalizer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around pathToRegexp that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* This includes both </span><span class="s3">\&quot;</span><span class="s1">Can not repeat without prefix/suffix</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">Must have text between parameters</span><span class="s3">\&quot; </span><span class="s1">errors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safePathToRegexp(</span><span class="s3">\n  </span><span class="s1">route: string | RegExp | Array&lt;string | RegExp&gt;,</span><span class="s3">\n  </span><span class="s1">keys?: Key[],</span><span class="s3">\n  </span><span class="s1">options?: TokensToRegexpOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">): RegExp {</span><span class="s3">\n  </span><span class="s1">if (typeof route !== 'string') {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(route, keys, options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(routeToUse, keys, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return pathToRegexp(normalizedRoute, keys, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around compile that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* No server-side error reporting to avoid bundling issues.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeCompile(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">options?: TokensToFunctionOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return compile(routeToUse, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return compile(normalizedRoute, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around regexpToFunction that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRegexpToFunction&lt;</span><span class="s3">\n  </span><span class="s1">T extends Record&lt;string, any&gt; = Record&lt;string, any&gt;,</span><span class="s3">\n</span><span class="s1">&gt;(regexp: RegExp, keys?: Key[]): (pathname: string) =&gt; { params: T } | false {</span><span class="s3">\n  </span><span class="s1">const originalMatcher = regexpToFunction&lt;T&gt;(regexp, keys || [])</span><span class="s3">\n\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = originalMatcher(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">...result,</span><span class="s3">\n      </span><span class="s1">params: stripParameterSeparators(result.params as any) as T,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Safe wrapper for route matcher functions that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">* This is client-safe and doesn't import path-to-regexp.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRouteMatcher&lt;T extends Record&lt;string, any&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">matcherFn: (pathname: string) =&gt; false | T</span><span class="s3">\n</span><span class="s1">): (pathname: string) =&gt; false | T {</span><span class="s3">\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = matcherFn(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return stripParameterSeparators(result) as T</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Group } from './route-regex'</span><span class="s3">\n</span><span class="s1">import { DecodeError } from '../../utils'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { safeRouteMatcher } from './route-match-utils'</span><span class="s3">\n\n</span><span class="s1">export interface RouteMatchFn {</span><span class="s3">\n  </span><span class="s1">(pathname: string): false | Params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RouteMatcherOptions = {</span><span class="s3">\n  </span><span class="s1">// We only use the exec method of the RegExp object. This helps us avoid using</span><span class="s3">\n  </span><span class="s1">// type assertions that the passed in properties are of the correct type.</span><span class="s3">\n  </span><span class="s1">re: Pick&lt;RegExp, 'exec'&gt;</span><span class="s3">\n  </span><span class="s1">groups: Record&lt;string, Group&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRouteMatcher({</span><span class="s3">\n  </span><span class="s1">re,</span><span class="s3">\n  </span><span class="s1">groups,</span><span class="s3">\n</span><span class="s1">}: RouteMatcherOptions): RouteMatchFn {</span><span class="s3">\n  </span><span class="s1">const rawMatcher = (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const routeMatch = re.exec(pathname)</span><span class="s3">\n    </span><span class="s1">if (!routeMatch) return false</span><span class="s3">\n\n    </span><span class="s1">const decode = (param: string) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return decodeURIComponent(param)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">throw new DecodeError('failed to decode param')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const params: Params = {}</span><span class="s3">\n    </span><span class="s1">for (const [key, group] of Object.entries(groups)) {</span><span class="s3">\n      </span><span class="s1">const match = routeMatch[group.pos]</span><span class="s3">\n      </span><span class="s1">if (match !== undefined) {</span><span class="s3">\n        </span><span class="s1">if (group.repeat) {</span><span class="s3">\n          </span><span class="s1">params[key] = match.split('/').map((entry) =&gt; decode(entry))</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params[key] = decode(match)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Wrap with safe matcher to handle parameter cleaning</span><span class="s3">\n  </span><span class="s1">return safeRouteMatcher(rawMatcher)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">export function searchParamsToUrlQuery(</span><span class="s3">\n  </span><span class="s1">searchParams: URLSearchParams</span><span class="s3">\n</span><span class="s1">): ParsedUrlQuery {</span><span class="s3">\n  </span><span class="s1">const query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of searchParams.entries()) {</span><span class="s3">\n    </span><span class="s1">const existing = query[key]</span><span class="s3">\n    </span><span class="s1">if (typeof existing === 'undefined') {</span><span class="s3">\n      </span><span class="s1">query[key] = value</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(existing)) {</span><span class="s3">\n      </span><span class="s1">existing.push(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">query[key] = [existing, value]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return query</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function stringifyUrlQueryParam(param: unknown): string {</span><span class="s3">\n  </span><span class="s1">if (typeof param === 'string') {</span><span class="s3">\n    </span><span class="s1">return param</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(typeof param === 'number' &amp;&amp; !isNaN(param)) ||</span><span class="s3">\n    </span><span class="s1">typeof param === 'boolean'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return String(param)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function urlQueryToSearchParams(query: ParsedUrlQuery): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">const searchParams = new URLSearchParams()</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">for (const item of value) {</span><span class="s3">\n        </span><span class="s1">searchParams.append(key, stringifyUrlQueryParam(item))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">searchParams.set(key, stringifyUrlQueryParam(value))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return searchParams</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assign(</span><span class="s3">\n  </span><span class="s1">target: URLSearchParams,</span><span class="s3">\n  </span><span class="s1">...searchParamsList: URLSearchParams[]</span><span class="s3">\n</span><span class="s1">): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">for (const searchParams of searchParamsList) {</span><span class="s3">\n    </span><span class="s1">for (const key of searchParams.keys()) {</span><span class="s3">\n      </span><span class="s1">target.delete(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [key, value] of searchParams.entries()) {</span><span class="s3">\n      </span><span class="s1">target.append(key, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return target</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextApiRequestCookies } from '.'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse cookies from the `headers` of request</span><span class="s3">\n </span><span class="s1">* @param req request object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function getCookieParser(headers: {</span><span class="s3">\n  </span><span class="s1">[key: string]: string | string[] | null | undefined</span><span class="s3">\n</span><span class="s1">}): () =&gt; NextApiRequestCookies {</span><span class="s3">\n  </span><span class="s1">return function parseCookie(): NextApiRequestCookies {</span><span class="s3">\n    </span><span class="s1">const { cookie } = headers</span><span class="s3">\n\n    </span><span class="s1">if (!cookie) {</span><span class="s3">\n      </span><span class="s1">return {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { parse: parseCookieFn } =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n    </span><span class="s1">return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { Key } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import type { NextParsedUrlQuery } from '../../../../server/request-meta'</span><span class="s3">\n</span><span class="s1">import type { RouteHas } from '../../../../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../../../../server/base-http'</span><span class="s3">\n\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { parseUrl } from './parse-url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">INTERCEPTION_ROUTE_MARKERS,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { getCookieParser } from '../../../../server/api-utils/get-cookie-parser'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp, safeCompile } from './route-match-utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensure only a-zA-Z are used for param names for proper interpolating</span><span class="s3">\n </span><span class="s1">* with path-to-regexp</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getSafeParamName(paramName: string) {</span><span class="s3">\n  </span><span class="s1">let newParamName = ''</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; paramName.length; i++) {</span><span class="s3">\n    </span><span class="s1">const charCode = paramName.charCodeAt(i)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 64 &amp;&amp; charCode &lt; 91) || // A-Z</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 96 &amp;&amp; charCode &lt; 123) // a-z</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">newParamName += paramName[i]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newParamName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function escapeSegment(str: string, segmentName: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(</span><span class="s3">\n    </span><span class="s1">new RegExp(`:${escapeStringRegexp(segmentName)}`, 'g'),</span><span class="s3">\n    </span><span class="s1">`__ESC_COLON_${segmentName}`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function unescapeSegments(str: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(/__ESC_COLON_/gi, ':')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function matchHas(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">query: Params,</span><span class="s3">\n  </span><span class="s1">has: RouteHas[] = [],</span><span class="s3">\n  </span><span class="s1">missing: RouteHas[] = []</span><span class="s3">\n</span><span class="s1">): false | Params {</span><span class="s3">\n  </span><span class="s1">const params: Params = {}</span><span class="s3">\n\n  </span><span class="s1">const hasMatch = (hasItem: RouteHas) =&gt; {</span><span class="s3">\n    </span><span class="s1">let value</span><span class="s3">\n    </span><span class="s1">let key = hasItem.key</span><span class="s3">\n\n    </span><span class="s1">switch (hasItem.type) {</span><span class="s3">\n      </span><span class="s1">case 'header': {</span><span class="s3">\n        </span><span class="s1">key = key!.toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = req.headers[key] as string</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'cookie': {</span><span class="s3">\n        </span><span class="s1">if ('cookies' in req) {</span><span class="s3">\n          </span><span class="s1">value = req.cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const cookies = getCookieParser(req.headers)()</span><span class="s3">\n          </span><span class="s1">value = cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'query': {</span><span class="s3">\n        </span><span class="s1">value = query[key!]</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'host': {</span><span class="s3">\n        </span><span class="s1">const { host } = req?.headers || {}</span><span class="s3">\n        </span><span class="s1">// remove port from host if present</span><span class="s3">\n        </span><span class="s1">const hostname = host?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = hostname</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!hasItem.value &amp;&amp; value) {</span><span class="s3">\n      </span><span class="s1">params[getSafeParamName(key!)] = value</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">const matcher = new RegExp(`^${hasItem.value}$`)</span><span class="s3">\n      </span><span class="s1">const matches = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.slice(-1)[0].match(matcher)</span><span class="s3">\n        </span><span class="s1">: value.match(matcher)</span><span class="s3">\n\n      </span><span class="s1">if (matches) {</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(matches)) {</span><span class="s3">\n          </span><span class="s1">if (matches.groups) {</span><span class="s3">\n            </span><span class="s1">Object.keys(matches.groups).forEach((groupKey) =&gt; {</span><span class="s3">\n              </span><span class="s1">params[groupKey] = matches.groups![groupKey]</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">} else if (hasItem.type === 'host' &amp;&amp; matches[0]) {</span><span class="s3">\n            </span><span class="s1">params.host = matches[0]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const allMatch =</span><span class="s3">\n    </span><span class="s1">has.every((item) =&gt; hasMatch(item)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!missing.some((item) =&gt; hasMatch(item))</span><span class="s3">\n\n  </span><span class="s1">if (allMatch) {</span><span class="s3">\n    </span><span class="s1">return params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function compileNonPath(value: string, params: Params): string {</span><span class="s3">\n  </span><span class="s1">if (!value.includes(':')) {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(params)) {</span><span class="s3">\n    </span><span class="s1">if (value.includes(`:${key}`)) {</span><span class="s3">\n      </span><span class="s1">value = value</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">*`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_ASTERISKS`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">?`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_QUESTION`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}(?!</span><span class="s3">\\\\</span><span class="s1">w)`, 'g'),</span><span class="s3">\n          </span><span class="s1">`--ESCAPED_PARAM_COLON${key}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = value</span><span class="s3">\n    </span><span class="s1">.replace(/(:|</span><span class="s3">\\</span><span class="s1">*|</span><span class="s3">\\</span><span class="s1">?|</span><span class="s3">\\</span><span class="s1">+|</span><span class="s3">\\</span><span class="s1">(|</span><span class="s3">\\</span><span class="s1">)|</span><span class="s3">\\</span><span class="s1">{|</span><span class="s3">\\</span><span class="s1">})/g, '</span><span class="s3">\\\\</span><span class="s1">$1')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_PLUS/g, '+')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_COLON/g, ':')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_QUESTION/g, '?')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')</span><span class="s3">\n\n  </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n  </span><span class="s1">// correctly</span><span class="s3">\n  </span><span class="s1">return safeCompile(`/${value}`, { validate: false })(params).slice(1)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseDestination(args: {</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Readonly&lt;Params&gt;</span><span class="s3">\n  </span><span class="s1">query: Readonly&lt;NextParsedUrlQuery&gt;</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let escaped = args.destination</span><span class="s3">\n  </span><span class="s1">for (const param of Object.keys({ ...args.params, ...args.query })) {</span><span class="s3">\n    </span><span class="s1">if (!param) continue</span><span class="s3">\n\n    </span><span class="s1">escaped = escapeSegment(escaped, param)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsed = parseUrl(escaped)</span><span class="s3">\n\n  </span><span class="s1">let pathname = parsed.pathname</span><span class="s3">\n  </span><span class="s1">if (pathname) {</span><span class="s3">\n    </span><span class="s1">pathname = unescapeSegments(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let href = parsed.href</span><span class="s3">\n  </span><span class="s1">if (href) {</span><span class="s3">\n    </span><span class="s1">href = unescapeSegments(href)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hostname = parsed.hostname</span><span class="s3">\n  </span><span class="s1">if (hostname) {</span><span class="s3">\n    </span><span class="s1">hostname = unescapeSegments(hostname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hash = parsed.hash</span><span class="s3">\n  </span><span class="s1">if (hash) {</span><span class="s3">\n    </span><span class="s1">hash = unescapeSegments(hash)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let search = parsed.search</span><span class="s3">\n  </span><span class="s1">if (search) {</span><span class="s3">\n    </span><span class="s1">search = unescapeSegments(search)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...parsed,</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">hostname,</span><span class="s3">\n    </span><span class="s1">href,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">search,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function prepareDestination(args: {</span><span class="s3">\n  </span><span class="s1">appendParamsToQuery: boolean</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Params</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const parsedDestination = parseDestination(args)</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">hostname: destHostname,</span><span class="s3">\n    </span><span class="s1">query: destQuery,</span><span class="s3">\n    </span><span class="s1">search: destSearch,</span><span class="s3">\n  </span><span class="s1">} = parsedDestination</span><span class="s3">\n\n  </span><span class="s1">// The following code assumes that the pathname here includes the hash if it's</span><span class="s3">\n  </span><span class="s1">// present.</span><span class="s3">\n  </span><span class="s1">let destPath = parsedDestination.pathname</span><span class="s3">\n  </span><span class="s1">if (parsedDestination.hash) {</span><span class="s3">\n    </span><span class="s1">destPath = `${destPath}${parsedDestination.hash}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destParams: (string | number)[] = []</span><span class="s3">\n\n  </span><span class="s1">const destPathParamKeys: Key[] = []</span><span class="s3">\n  </span><span class="s1">safePathToRegexp(destPath, destPathParamKeys)</span><span class="s3">\n  </span><span class="s1">for (const key of destPathParamKeys) {</span><span class="s3">\n    </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">const destHostnameParamKeys: Key[] = []</span><span class="s3">\n    </span><span class="s1">safePathToRegexp(destHostname, destHostnameParamKeys)</span><span class="s3">\n    </span><span class="s1">for (const key of destHostnameParamKeys) {</span><span class="s3">\n      </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destPathCompiler = safeCompile(</span><span class="s3">\n    </span><span class="s1">destPath,</span><span class="s3">\n    </span><span class="s1">// we don't validate while compiling the destination since we should</span><span class="s3">\n    </span><span class="s1">// have already validated before we got to this point and validating</span><span class="s3">\n    </span><span class="s1">// breaks compiling destinations with named pattern params from the source</span><span class="s3">\n    </span><span class="s1">// e.g. /something:hello(.*) -&gt; /another/:hello is broken with validation</span><span class="s3">\n    </span><span class="s1">// since compile validation is meant for reversing and not for inserting</span><span class="s3">\n    </span><span class="s1">// params from a separate path-regex into another</span><span class="s3">\n    </span><span class="s1">{ validate: false }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let destHostnameCompiler</span><span class="s3">\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">destHostnameCompiler = safeCompile(destHostname, { validate: false })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// update any params in query values</span><span class="s3">\n  </span><span class="s1">for (const [key, strOrArray] of Object.entries(destQuery)) {</span><span class="s3">\n    </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n    </span><span class="s1">// correctly</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(strOrArray)) {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = strOrArray.map((value) =&gt;</span><span class="s3">\n        </span><span class="s1">compileNonPath(unescapeSegments(value), args.params)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (typeof strOrArray === 'string') {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add path params to query if it's not a redirect and not</span><span class="s3">\n  </span><span class="s1">// already defined in destination query or path</span><span class="s3">\n  </span><span class="s1">let paramKeys = Object.keys(args.params).filter(</span><span class="s3">\n    </span><span class="s1">(name) =&gt; name !== 'nextInternalLocale'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">args.appendParamsToQuery &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!paramKeys.some((key) =&gt; destParams.includes(key))</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const key of paramKeys) {</span><span class="s3">\n      </span><span class="s1">if (!(key in destQuery)) {</span><span class="s3">\n        </span><span class="s1">destQuery[key] = args.params[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let newUrl</span><span class="s3">\n\n  </span><span class="s1">// The compiler also that the interception route marker is an unnamed param, hence '0',</span><span class="s3">\n  </span><span class="s1">// so we need to add it to the params object.</span><span class="s3">\n  </span><span class="s1">if (isInterceptionRouteAppPath(destPath)) {</span><span class="s3">\n    </span><span class="s1">for (const segment of destPath.split('/')) {</span><span class="s3">\n      </span><span class="s1">const marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n        </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (marker) {</span><span class="s3">\n        </span><span class="s1">if (marker === '(..)(..)') {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = '(..)'</span><span class="s3">\n          </span><span class="s1">args.params['1'] = '(..)'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = marker</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">newUrl = destPathCompiler(args.params)</span><span class="s3">\n\n    </span><span class="s1">const [pathname, hash] = newUrl.split('#', 2)</span><span class="s3">\n    </span><span class="s1">if (destHostnameCompiler) {</span><span class="s3">\n      </span><span class="s1">parsedDestination.hostname = destHostnameCompiler(args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parsedDestination.pathname = pathname</span><span class="s3">\n    </span><span class="s1">parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`</span><span class="s3">\n    </span><span class="s1">parsedDestination.search = destSearch</span><span class="s3">\n      </span><span class="s1">? compileNonPath(destSearch, args.params)</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">if (err.message.match(/Expected .*? to not repeat, but got an array/)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`To use a multi-match in the destination you must add </span><span class="s3">\\</span><span class="s1">`*</span><span class="s3">\\</span><span class="s1">` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Query merge order lowest priority to highest</span><span class="s3">\n  </span><span class="s1">// 1. initial URL query values</span><span class="s3">\n  </span><span class="s1">// 2. path segment values</span><span class="s3">\n  </span><span class="s1">// 3. destination specified query values</span><span class="s3">\n  </span><span class="s1">parsedDestination.query = {</span><span class="s3">\n    </span><span class="s1">...args.query,</span><span class="s3">\n    </span><span class="s1">...parsedDestination.query,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">newUrl,</span><span class="s3">\n    </span><span class="s1">destQuery,</span><span class="s3">\n    </span><span class="s1">parsedDestination,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Node.js IncomingHttpHeaders object to a Headers object. Any</span><span class="s3">\n </span><span class="s1">* headers with multiple values will be joined with a comma and space. Any</span><span class="s3">\n </span><span class="s1">* headers that have an undefined value will be ignored and others will be</span><span class="s3">\n </span><span class="s1">* coerced to strings.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param nodeHeaders the headers object to convert</span><span class="s3">\n </span><span class="s1">* @returns the converted headers object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function fromNodeOutgoingHttpHeaders(</span><span class="s3">\n  </span><span class="s1">nodeHeaders: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">): Headers {</span><span class="s3">\n  </span><span class="s1">const headers = new Headers()</span><span class="s3">\n  </span><span class="s1">for (let [key, value] of Object.entries(nodeHeaders)) {</span><span class="s3">\n    </span><span class="s1">const values = Array.isArray(value) ? value : [value]</span><span class="s3">\n    </span><span class="s1">for (let v of values) {</span><span class="s3">\n      </span><span class="s1">if (typeof v === 'undefined') continue</span><span class="s3">\n      </span><span class="s1">if (typeof v === 'number') {</span><span class="s3">\n        </span><span class="s1">v = v.toString()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">headers.append(key, v)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return headers</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n  </span><span class="s1">Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas</span><span class="s3">\n  </span><span class="s1">that are within a single set-cookie field-value, such as in the Expires portion.</span><span class="s3">\n  </span><span class="s1">This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2</span><span class="s3">\n  </span><span class="s1">Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128</span><span class="s3">\n  </span><span class="s1">React Native's fetch does this for *every* header, including set-cookie.</span><span class="s3">\n  \n  </span><span class="s1">Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25</span><span class="s3">\n  </span><span class="s1">Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function splitCookiesString(cookiesString: string) {</span><span class="s3">\n  </span><span class="s1">var cookiesStrings = []</span><span class="s3">\n  </span><span class="s1">var pos = 0</span><span class="s3">\n  </span><span class="s1">var start</span><span class="s3">\n  </span><span class="s1">var ch</span><span class="s3">\n  </span><span class="s1">var lastComma</span><span class="s3">\n  </span><span class="s1">var nextStart</span><span class="s3">\n  </span><span class="s1">var cookiesSeparatorFound</span><span class="s3">\n\n  </span><span class="s1">function skipWhitespace() {</span><span class="s3">\n    </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(cookiesString.charAt(pos))) {</span><span class="s3">\n      </span><span class="s1">pos += 1</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos &lt; cookiesString.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function notSpecialChar() {</span><span class="s3">\n    </span><span class="s1">ch = cookiesString.charAt(pos)</span><span class="s3">\n\n    </span><span class="s1">return ch !== '=' &amp;&amp; ch !== ';' &amp;&amp; ch !== ','</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (pos &lt; cookiesString.length) {</span><span class="s3">\n    </span><span class="s1">start = pos</span><span class="s3">\n    </span><span class="s1">cookiesSeparatorFound = false</span><span class="s3">\n\n    </span><span class="s1">while (skipWhitespace()) {</span><span class="s3">\n      </span><span class="s1">ch = cookiesString.charAt(pos)</span><span class="s3">\n      </span><span class="s1">if (ch === ',') {</span><span class="s3">\n        </span><span class="s1">// ',' is a cookie separator if we have later first '=', not ';' or ','</span><span class="s3">\n        </span><span class="s1">lastComma = pos</span><span class="s3">\n        </span><span class="s1">pos += 1</span><span class="s3">\n\n        </span><span class="s1">skipWhitespace()</span><span class="s3">\n        </span><span class="s1">nextStart = pos</span><span class="s3">\n\n        </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; notSpecialChar()) {</span><span class="s3">\n          </span><span class="s1">pos += 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// currently special character</span><span class="s3">\n        </span><span class="s1">if (pos &lt; cookiesString.length &amp;&amp; cookiesString.charAt(pos) === '=') {</span><span class="s3">\n          </span><span class="s1">// we found cookies separator</span><span class="s3">\n          </span><span class="s1">cookiesSeparatorFound = true</span><span class="s3">\n          </span><span class="s1">// pos is inside the next cookie, so back up and return it.</span><span class="s3">\n          </span><span class="s1">pos = nextStart</span><span class="s3">\n          </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, lastComma))</span><span class="s3">\n          </span><span class="s1">start = pos</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// in param ',' or param separator ';',</span><span class="s3">\n          </span><span class="s1">// we continue from that comma</span><span class="s3">\n          </span><span class="s1">pos = lastComma + 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pos += 1</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!cookiesSeparatorFound || pos &gt;= cookiesString.length) {</span><span class="s3">\n      </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, cookiesString.length))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return cookiesStrings</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Headers object to a Node.js OutgoingHttpHeaders object. This is</span><span class="s3">\n </span><span class="s1">* required to support the set-cookie header, which may have multiple values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param headers the headers object to convert</span><span class="s3">\n </span><span class="s1">* @returns the converted headers object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function toNodeOutgoingHttpHeaders(</span><span class="s3">\n  </span><span class="s1">headers: Headers</span><span class="s3">\n</span><span class="s1">): OutgoingHttpHeaders {</span><span class="s3">\n  </span><span class="s1">const nodeHeaders: OutgoingHttpHeaders = {}</span><span class="s3">\n  </span><span class="s1">const cookies: string[] = []</span><span class="s3">\n  </span><span class="s1">if (headers) {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of headers.entries()) {</span><span class="s3">\n      </span><span class="s1">if (key.toLowerCase() === 'set-cookie') {</span><span class="s3">\n        </span><span class="s1">// We may have gotten a comma joined string of cookies, or multiple</span><span class="s3">\n        </span><span class="s1">// set-cookie headers. We need to merge them into one header array</span><span class="s3">\n        </span><span class="s1">// to represent all the cookies.</span><span class="s3">\n        </span><span class="s1">cookies.push(...splitCookiesString(value))</span><span class="s3">\n        </span><span class="s1">nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">nodeHeaders[key] = value</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return nodeHeaders</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Validate the correctness of a user-provided URL.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function validateURL(url: string | URL): string {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return String(new URL(String(url)))</span><span class="s3">\n  </span><span class="s1">} catch (error: any) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`URL is malformed </span><span class="s3">\&quot;</span><span class="s1">${String(</span><span class="s3">\n        </span><span class="s1">url</span><span class="s3">\n      </span><span class="s1">)}</span><span class="s3">\&quot;</span><span class="s1">. Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`,</span><span class="s3">\n      </span><span class="s1">{ cause: error }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes `nxtP` and `nxtI` query param values to remove the prefix.</span><span class="s3">\n </span><span class="s1">* This function does not mutate the input key.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeNextQueryParam(key: string): null | string {</span><span class="s3">\n  </span><span class="s1">const prefixes = [NEXT_QUERY_PARAM_PREFIX, NEXT_INTERCEPTION_MARKER_PREFIX]</span><span class="s3">\n  </span><span class="s1">for (const prefix of prefixes) {</span><span class="s3">\n    </span><span class="s1">if (key !== prefix &amp;&amp; key.startsWith(prefix)) {</span><span class="s3">\n      </span><span class="s1">return key.substring(prefix.length)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Decodes a query path parameter.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param value - The value to decode.</span><span class="s3">\n </span><span class="s1">* @returns The decoded value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function decodeQueryPathParameter(value: string) {</span><span class="s3">\n  </span><span class="s1">// When deployed to Vercel, the value may be encoded, so this attempts to</span><span class="s3">\n  </span><span class="s1">// decode it and returns the original value if it fails.</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return decodeURIComponent(value)</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Format function modified from nodejs</span><span class="s3">\n</span><span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span><span class="s3">\n</span><span class="s1">// copy of this software and associated documentation files (the</span><span class="s3">\n</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Software</span><span class="s3">\&quot;</span><span class="s1">), to deal in the Software without restriction, including</span><span class="s3">\n</span><span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span><span class="s3">\n</span><span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span><span class="s3">\n</span><span class="s1">// persons to whom the Software is furnished to do so, subject to the</span><span class="s3">\n</span><span class="s1">// following conditions:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The above copyright notice and this permission notice shall be included</span><span class="s3">\n</span><span class="s1">// in all copies or substantial portions of the Software.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot;</span><span class="s1">, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span><span class="s3">\n</span><span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span><span class="s3">\n</span><span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span><span class="s3">\n</span><span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span><span class="s3">\n</span><span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span><span class="s3">\n</span><span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span><span class="s3">\n</span><span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span><span class="s3">\n\n</span><span class="s1">import type { UrlObject } from 'url'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import * as querystring from './querystring'</span><span class="s3">\n\n</span><span class="s1">const slashedProtocols = /https?|ftp|gopher|file/</span><span class="s3">\n\n</span><span class="s1">export function formatUrl(urlObj: UrlObject) {</span><span class="s3">\n  </span><span class="s1">let { auth, hostname } = urlObj</span><span class="s3">\n  </span><span class="s1">let protocol = urlObj.protocol || ''</span><span class="s3">\n  </span><span class="s1">let pathname = urlObj.pathname || ''</span><span class="s3">\n  </span><span class="s1">let hash = urlObj.hash || ''</span><span class="s3">\n  </span><span class="s1">let query = urlObj.query || ''</span><span class="s3">\n  </span><span class="s1">let host: string | false = false</span><span class="s3">\n\n  </span><span class="s1">auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : ''</span><span class="s3">\n\n  </span><span class="s1">if (urlObj.host) {</span><span class="s3">\n    </span><span class="s1">host = auth + urlObj.host</span><span class="s3">\n  </span><span class="s1">} else if (hostname) {</span><span class="s3">\n    </span><span class="s1">host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname)</span><span class="s3">\n    </span><span class="s1">if (urlObj.port) {</span><span class="s3">\n      </span><span class="s1">host += ':' + urlObj.port</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (query &amp;&amp; typeof query === 'object') {</span><span class="s3">\n    </span><span class="s1">query = String(querystring.urlQueryToSearchParams(query as ParsedUrlQuery))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let search = urlObj.search || (query &amp;&amp; `?${query}`) || ''</span><span class="s3">\n\n  </span><span class="s1">if (protocol &amp;&amp; !protocol.endsWith(':')) protocol += ':'</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">urlObj.slashes ||</span><span class="s3">\n    </span><span class="s1">((!protocol || slashedProtocols.test(protocol)) &amp;&amp; host !== false)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">host = '//' + (host || '')</span><span class="s3">\n    </span><span class="s1">if (pathname &amp;&amp; pathname[0] !== '/') pathname = '/' + pathname</span><span class="s3">\n  </span><span class="s1">} else if (!host) {</span><span class="s3">\n    </span><span class="s1">host = ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (hash &amp;&amp; hash[0] !== '#') hash = '#' + hash</span><span class="s3">\n  </span><span class="s1">if (search &amp;&amp; search[0] !== '?') search = '?' + search</span><span class="s3">\n\n  </span><span class="s1">pathname = pathname.replace(/[?#]/g, encodeURIComponent)</span><span class="s3">\n  </span><span class="s1">search = search.replace('#', '%23')</span><span class="s3">\n\n  </span><span class="s1">return `${protocol}${host}${pathname}${search}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const urlObjectKeys = [</span><span class="s3">\n  </span><span class="s1">'auth',</span><span class="s3">\n  </span><span class="s1">'hash',</span><span class="s3">\n  </span><span class="s1">'host',</span><span class="s3">\n  </span><span class="s1">'hostname',</span><span class="s3">\n  </span><span class="s1">'href',</span><span class="s3">\n  </span><span class="s1">'path',</span><span class="s3">\n  </span><span class="s1">'pathname',</span><span class="s3">\n  </span><span class="s1">'port',</span><span class="s3">\n  </span><span class="s1">'protocol',</span><span class="s3">\n  </span><span class="s1">'query',</span><span class="s3">\n  </span><span class="s1">'search',</span><span class="s3">\n  </span><span class="s1">'slashes',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export function formatWithValidation(url: UrlObject): string {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">if (url !== null &amp;&amp; typeof url === 'object') {</span><span class="s3">\n      </span><span class="s1">Object.keys(url).forEach((key) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!urlObjectKeys.includes(key)) {</span><span class="s3">\n          </span><span class="s1">console.warn(</span><span class="s3">\n            </span><span class="s1">`Unknown key passed via urlObject into url.format: ${key}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return formatUrl(url)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { LoadComponentsReturnType } from '../load-components'</span><span class="s3">\n</span><span class="s1">import type { ServerRuntime, SizeLimit } from '../../types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ExperimentalConfig,</span><span class="s3">\n  </span><span class="s1">NextConfigComplete,</span><span class="s3">\n</span><span class="s1">} from '../../server/config-shared'</span><span class="s3">\n</span><span class="s1">import type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { AppPageModule } from '../route-modules/app-page/module'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HeadData,</span><span class="s3">\n  </span><span class="s1">LoadingModuleData,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../api-utils'</span><span class="s3">\n\n</span><span class="s1">import s from 'next/dist/compiled/superstruct'</span><span class="s3">\n</span><span class="s1">import type { RequestLifecycleOpts } from '../base-server'</span><span class="s3">\n</span><span class="s1">import type { InstrumentationOnRequestError } from '../instrumentation/types'</span><span class="s3">\n</span><span class="s1">import type { NextRequestHint } from '../web/adapter'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'</span><span class="s3">\n\n</span><span class="s1">export type DynamicParamTypes =</span><span class="s3">\n  </span><span class="s1">| 'catchall'</span><span class="s3">\n  </span><span class="s1">| 'catchall-intercepted'</span><span class="s3">\n  </span><span class="s1">| 'optional-catchall'</span><span class="s3">\n  </span><span class="s1">| 'dynamic'</span><span class="s3">\n  </span><span class="s1">| 'dynamic-intercepted'</span><span class="s3">\n\n</span><span class="s1">const dynamicParamTypesSchema = s.enums(['c', 'ci', 'oc', 'd', 'di'])</span><span class="s3">\n\n</span><span class="s1">export type DynamicParamTypesShort = s.Infer&lt;typeof dynamicParamTypesSchema&gt;</span><span class="s3">\n\n</span><span class="s1">const segmentSchema = s.union([</span><span class="s3">\n  </span><span class="s1">s.string(),</span><span class="s3">\n\n  </span><span class="s1">s.tuple([</span><span class="s3">\n    </span><span class="s1">// Param name</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">// Param cache key (almost the same as the value, but arrays are</span><span class="s3">\n    </span><span class="s1">// concatenated into strings)</span><span class="s3">\n    </span><span class="s1">// TODO: We should change this to just be the value. Currently we convert</span><span class="s3">\n    </span><span class="s1">// it back to a value when passing to useParams. It only needs to be</span><span class="s3">\n    </span><span class="s1">// a string when converted to a a cache key, but that doesn't mean we</span><span class="s3">\n    </span><span class="s1">// need to store it as that representation.</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">// Dynamic param type</span><span class="s3">\n    </span><span class="s1">dynamicParamTypesSchema,</span><span class="s3">\n  </span><span class="s1">]),</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">export type Segment = s.Infer&lt;typeof segmentSchema&gt;</span><span class="s3">\n\n</span><span class="s1">// unfortunately the tuple is not understood well by Describe so we have to</span><span class="s3">\n</span><span class="s1">// use any here. This does not have any impact on the runtime type since the validation</span><span class="s3">\n</span><span class="s1">// does work correctly.</span><span class="s3">\n</span><span class="s1">export const flightRouterStateSchema: s.Describe&lt;any&gt; = s.tuple([</span><span class="s3">\n  </span><span class="s1">segmentSchema,</span><span class="s3">\n  </span><span class="s1">s.record(</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">s.lazy(() =&gt; flightRouterStateSchema)</span><span class="s3">\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">s.optional(s.nullable(s.string())),</span><span class="s3">\n  </span><span class="s1">s.optional(</span><span class="s3">\n    </span><span class="s1">s.nullable(</span><span class="s3">\n      </span><span class="s1">s.union([</span><span class="s3">\n        </span><span class="s1">s.literal('refetch'),</span><span class="s3">\n        </span><span class="s1">s.literal('refresh'),</span><span class="s3">\n        </span><span class="s1">s.literal('inside-shared-layout'),</span><span class="s3">\n        </span><span class="s1">s.literal('metadata-only'),</span><span class="s3">\n      </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">s.optional(s.boolean()),</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Router state</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightRouterState = [</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },</span><span class="s3">\n  </span><span class="s1">url?: string | null,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">refetch</span><span class="s3">\&quot;</span><span class="s1">, despite being similarly named, have different</span><span class="s3">\n   </span><span class="s1">* semantics:</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">refetch</span><span class="s3">\&quot; </span><span class="s1">is used during a request to inform the server where rendering</span><span class="s3">\n   </span><span class="s1">*   should start from.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot; </span><span class="s1">is used by the client to mark that a segment should re-fetch the</span><span class="s3">\n   </span><span class="s1">*   data from the server for the current segment. It uses the </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">property</span><span class="s3">\n   </span><span class="s1">*   above to determine where to fetch from.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">inside-shared-layout</span><span class="s3">\&quot; </span><span class="s1">is used during a prefetch request to inform the</span><span class="s3">\n   </span><span class="s1">*   server that even if the segment matches, it should be treated as if it's</span><span class="s3">\n   </span><span class="s1">*   within the </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">part of a navigation  inside the shared layout. If</span><span class="s3">\n   </span><span class="s1">*   the segment doesn't match, then it has no effect, since it would be</span><span class="s3">\n   </span><span class="s1">*   treated as new regardless. If it does match, though, the server does not</span><span class="s3">\n   </span><span class="s1">*   need to render it, because the client already has it.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">metadata-only</span><span class="s3">\&quot; </span><span class="s1">instructs the server to skip rendering the segments and</span><span class="s3">\n   </span><span class="s1">*   only send the head data.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   A bit confusing, but that's because it has only one extremely narrow use</span><span class="s3">\n   </span><span class="s1">*   case  during a non-PPR prefetch, the server uses it to find the first</span><span class="s3">\n   </span><span class="s1">*   loading boundary beneath a shared layout.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   TODO: We should rethink the protocol for dynamic requests. It might not</span><span class="s3">\n   </span><span class="s1">*   make sense for the client to send a FlightRouterState, since this type is</span><span class="s3">\n   </span><span class="s1">*   overloaded with concerns.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">refresh?:</span><span class="s3">\n    </span><span class="s1">| 'refetch'</span><span class="s3">\n    </span><span class="s1">| 'refresh'</span><span class="s3">\n    </span><span class="s1">| 'inside-shared-layout'</span><span class="s3">\n    </span><span class="s1">| 'metadata-only'</span><span class="s3">\n    </span><span class="s1">| null,</span><span class="s3">\n  </span><span class="s1">isRootLayout?: boolean,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Only present when responding to a tree prefetch request. Indicates whether</span><span class="s3">\n   </span><span class="s1">* there is a loading boundary somewhere in the tree. The client cache uses</span><span class="s3">\n   </span><span class="s1">* this to determine if it can skip the data prefetch request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasLoadingBoundary?: HasLoadingBoundary,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export const enum HasLoadingBoundary {</span><span class="s3">\n  </span><span class="s1">// There is a loading boundary in this particular segment</span><span class="s3">\n  </span><span class="s1">SegmentHasLoadingBoundary = 1,</span><span class="s3">\n  </span><span class="s1">// There is a loading boundary somewhere in the subtree (but not in</span><span class="s3">\n  </span><span class="s1">// this segment)</span><span class="s3">\n  </span><span class="s1">SubtreeHasLoadingBoundary = 2,</span><span class="s3">\n  </span><span class="s1">// There is no loading boundary in this segment or any of its descendants</span><span class="s3">\n  </span><span class="s1">SubtreeHasNoLoadingBoundary = 3,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Individual Flight response path</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightSegmentPath =</span><span class="s3">\n  </span><span class="s1">// Uses `any` as repeating pattern can't be typed.</span><span class="s3">\n  </span><span class="s1">| any[]</span><span class="s3">\n  </span><span class="s1">// Looks somewhat like this</span><span class="s3">\n  </span><span class="s1">| [</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Represents a tree of segments and the Flight data (i.e. React nodes) that</span><span class="s3">\n </span><span class="s1">* correspond to each one. The tree is isomorphic to the FlightRouterState;</span><span class="s3">\n </span><span class="s1">* however in the future we want to be able to fetch arbitrary partial segments</span><span class="s3">\n </span><span class="s1">* without having to fetch all its children. So this response format will</span><span class="s3">\n </span><span class="s1">* likely change.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type CacheNodeSeedData = [</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">node: React.ReactNode | null,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: {</span><span class="s3">\n    </span><span class="s1">[parallelRouterKey: string]: CacheNodeSeedData | null</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;,</span><span class="s3">\n  </span><span class="s1">isPartial: boolean,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type FlightDataSegment = [</span><span class="s3">\n  </span><span class="s1">/* segment of the rendered slice: */ Segment,</span><span class="s3">\n  </span><span class="s1">/* treePatch */ FlightRouterState,</span><span class="s3">\n  </span><span class="s1">/* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component</span><span class="s3">\n  </span><span class="s1">/* head: viewport */ HeadData,</span><span class="s3">\n  </span><span class="s1">/* isHeadPartial */ boolean,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type FlightDataPath =</span><span class="s3">\n  </span><span class="s1">// Uses `any` as repeating pattern can't be typed.</span><span class="s3">\n  </span><span class="s1">| any[]</span><span class="s3">\n  </span><span class="s1">// Looks somewhat like this</span><span class="s3">\n  </span><span class="s1">| [</span><span class="s3">\n      </span><span class="s1">// Holds full path to the segment.</span><span class="s3">\n      </span><span class="s1">...FlightSegmentPath[],</span><span class="s3">\n      </span><span class="s1">...FlightDataSegment,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Flight response data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightData = Array&lt;FlightDataPath&gt; | string</span><span class="s3">\n\n</span><span class="s1">export type ActionResult = Promise&lt;any&gt;</span><span class="s3">\n\n</span><span class="s1">export type ServerOnInstrumentationRequestError = (</span><span class="s3">\n  </span><span class="s1">error: unknown,</span><span class="s3">\n  </span><span class="s1">// The request could be middleware, node server or web server request,</span><span class="s3">\n  </span><span class="s1">// we normalized them into an aligned format to `onRequestError` API later.</span><span class="s3">\n  </span><span class="s1">request: NextRequestHint | BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">errorContext: Parameters&lt;InstrumentationOnRequestError&gt;[2]</span><span class="s3">\n</span><span class="s1">) =&gt; void | Promise&lt;void&gt;</span><span class="s3">\n\n</span><span class="s1">export interface RenderOptsPartial {</span><span class="s3">\n  </span><span class="s1">dir?: string</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps | undefined</span><span class="s3">\n  </span><span class="s1">err?: Error | null</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">trailingSlash: boolean</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest?: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">supportsDynamicResponse: boolean</span><span class="s3">\n  </span><span class="s1">runtime?: ServerRuntime</span><span class="s3">\n  </span><span class="s1">serverComponents?: boolean</span><span class="s3">\n  </span><span class="s1">enableTainting?: boolean</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined</span><span class="s3">\n  </span><span class="s1">nextFontManifest?: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n  </span><span class="s1">botType?: 'dom' | 'html' | undefined</span><span class="s3">\n  </span><span class="s1">serveStreamingMetadata?: boolean</span><span class="s3">\n  </span><span class="s1">incrementalCache?: import('../lib/incremental-cache').IncrementalCache</span><span class="s3">\n  </span><span class="s1">cacheLifeProfiles?: {</span><span class="s3">\n    </span><span class="s1">[profile: string]: import('../use-cache/cache-life').CacheLife</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction?: boolean</span><span class="s3">\n  </span><span class="s1">setIsrStatus?: (key: string, value: boolean | null) =&gt; void</span><span class="s3">\n  </span><span class="s1">isRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">nextExport?: boolean</span><span class="s3">\n  </span><span class="s1">nextConfigOutput?: 'standalone' | 'export'</span><span class="s3">\n  </span><span class="s1">onInstrumentationRequestError?: ServerOnInstrumentationRequestError</span><span class="s3">\n  </span><span class="s1">isDraftMode?: boolean</span><span class="s3">\n  </span><span class="s1">deploymentId?: string</span><span class="s3">\n  </span><span class="s1">onUpdateCookies?: (cookies: string[]) =&gt; void</span><span class="s3">\n  </span><span class="s1">loadConfig?: (</span><span class="s3">\n    </span><span class="s1">phase: string,</span><span class="s3">\n    </span><span class="s1">dir: string,</span><span class="s3">\n    </span><span class="s1">customConfig?: object | null,</span><span class="s3">\n    </span><span class="s1">rawConfig?: boolean,</span><span class="s3">\n    </span><span class="s1">silent?: boolean</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;NextConfigComplete&gt;</span><span class="s3">\n  </span><span class="s1">serverActions?: {</span><span class="s3">\n    </span><span class="s1">bodySizeLimit?: SizeLimit</span><span class="s3">\n    </span><span class="s1">allowedOrigins?: string[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n  </span><span class="s1">htmlLimitedBots: string | undefined</span><span class="s3">\n  </span><span class="s1">experimental: {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When true, it indicates that the current page supports partial</span><span class="s3">\n     </span><span class="s1">* prerendering.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">expireTime: number | undefined</span><span class="s3">\n    </span><span class="s1">staleTimes: ExperimentalConfig['staleTimes'] | undefined</span><span class="s3">\n    </span><span class="s1">clientTraceMetadata: string[] | undefined</span><span class="s3">\n    </span><span class="s1">cacheComponents: boolean</span><span class="s3">\n    </span><span class="s1">clientSegmentCache: boolean | 'client-only'</span><span class="s3">\n    </span><span class="s1">clientParamParsing: boolean</span><span class="s3">\n    </span><span class="s1">dynamicOnHover: boolean</span><span class="s3">\n    </span><span class="s1">inlineCss: boolean</span><span class="s3">\n    </span><span class="s1">authInterrupts: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Should wait for react stream allReady to resolve all suspense boundaries,</span><span class="s3">\n   </span><span class="s1">* in order to perform a full page render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">shouldWaitOnAllReady?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A prefilled resume data cache. This was either generated for this page</span><span class="s3">\n   </span><span class="s1">* during dev warmup, or when a page with defined params was previously</span><span class="s3">\n   </span><span class="s1">* prerendered, and now its matching optional fallback shell is prerendered.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, the page will be rendered using the static rendering to detect</span><span class="s3">\n   </span><span class="s1">* any dynamic API's that would have stopped the page from being fully</span><span class="s3">\n   </span><span class="s1">* statically generated.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isDebugDynamicAccesses?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is true when:</span><span class="s3">\n   </span><span class="s1">* - source maps are generated</span><span class="s3">\n   </span><span class="s1">* - source maps are applied</span><span class="s3">\n   </span><span class="s1">* - minification is disabled</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasReadableErrorStacks?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The maximum length of the headers that are emitted by React and added to</span><span class="s3">\n   </span><span class="s1">* the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">reactMaxHeadersLength: number | undefined</span><span class="s3">\n\n  </span><span class="s1">isStaticGeneration?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, the page is prerendered as a fallback shell, while allowing any</span><span class="s3">\n   </span><span class="s1">* dynamic accesses to result in an empty shell. This is the case when there</span><span class="s3">\n   </span><span class="s1">* are also routes prerendered with a more complete set of params.</span><span class="s3">\n   </span><span class="s1">* Prerendering those routes would catch any invalid dynamic accesses.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">allowEmptyStaticShell?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* next config experimental.devtoolSegmentExplorer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">devtoolSegmentExplorer?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderOpts = LoadComponentsReturnType&lt;AppPageModule&gt; &amp;</span><span class="s3">\n  </span><span class="s1">RenderOptsPartial &amp;</span><span class="s3">\n  </span><span class="s1">RequestLifecycleOpts</span><span class="s3">\n\n</span><span class="s1">export type PreloadCallbacks = (() =&gt; void)[]</span><span class="s3">\n\n</span><span class="s1">export type InitialRSCPayload = {</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** assetPrefix */</span><span class="s3">\n  </span><span class="s1">p: string</span><span class="s3">\n  </span><span class="s1">/** initialCanonicalUrlParts */</span><span class="s3">\n  </span><span class="s1">c: string[]</span><span class="s3">\n  </span><span class="s1">/** couldBeIntercepted */</span><span class="s3">\n  </span><span class="s1">i: boolean</span><span class="s3">\n  </span><span class="s1">/** initialFlightData */</span><span class="s3">\n  </span><span class="s1">f: FlightDataPath[]</span><span class="s3">\n  </span><span class="s1">/** missingSlots */</span><span class="s3">\n  </span><span class="s1">m: Set&lt;string&gt; | undefined</span><span class="s3">\n  </span><span class="s1">/** GlobalError */</span><span class="s3">\n  </span><span class="s1">G: [React.ComponentType&lt;any&gt;, React.ReactNode | undefined]</span><span class="s3">\n  </span><span class="s1">/** postponed */</span><span class="s3">\n  </span><span class="s1">s: boolean</span><span class="s3">\n  </span><span class="s1">/** prerendered */</span><span class="s3">\n  </span><span class="s1">S: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Response from `createFromFetch` for normal rendering</span><span class="s3">\n</span><span class="s1">export type NavigationFlightResponse = {</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** flightData */</span><span class="s3">\n  </span><span class="s1">f: FlightData</span><span class="s3">\n  </span><span class="s1">/** prerendered */</span><span class="s3">\n  </span><span class="s1">S: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Response from `createFromFetch` for server actions. Action's flight data can be null</span><span class="s3">\n</span><span class="s1">export type ActionFlightResponse = {</span><span class="s3">\n  </span><span class="s1">/** actionResult */</span><span class="s3">\n  </span><span class="s1">a: ActionResult</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** flightData */</span><span class="s3">\n  </span><span class="s1">f: FlightData</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RSCPayload =</span><span class="s3">\n  </span><span class="s1">| InitialRSCPayload</span><span class="s3">\n  </span><span class="s1">| NavigationFlightResponse</span><span class="s3">\n  </span><span class="s1">| ActionFlightResponse</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { NEXT_URL } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Rewrite } from './load-custom-routes'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp } from '../shared/lib/router/utils/route-match-utils'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)</span><span class="s3">\n</span><span class="s1">function toPathToRegexpPath(path: string): string {</span><span class="s3">\n  </span><span class="s1">return path.replace(/</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">[?([^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">]?/g, (_, capture) =&gt; {</span><span class="s3">\n    </span><span class="s1">// path-to-regexp only supports word characters, so we replace any non-word characters with underscores</span><span class="s3">\n    </span><span class="s1">const paramName = capture.replace(/</span><span class="s3">\\</span><span class="s1">W+/g, '_')</span><span class="s3">\n\n    </span><span class="s1">// handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])</span><span class="s3">\n    </span><span class="s1">if (capture.startsWith('...')) {</span><span class="s3">\n      </span><span class="s1">return `:${capture.slice(3)}*`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ':' + paramName</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateInterceptionRoutesRewrites(</span><span class="s3">\n  </span><span class="s1">appPaths: string[],</span><span class="s3">\n  </span><span class="s1">basePath = ''</span><span class="s3">\n</span><span class="s1">): Rewrite[] {</span><span class="s3">\n  </span><span class="s1">const rewrites: Rewrite[] = []</span><span class="s3">\n\n  </span><span class="s1">for (const appPath of appPaths) {</span><span class="s3">\n    </span><span class="s1">if (isInterceptionRouteAppPath(appPath)) {</span><span class="s3">\n      </span><span class="s1">const { interceptingRoute, interceptedRoute } =</span><span class="s3">\n        </span><span class="s1">extractInterceptionRouteInformation(appPath)</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptingRoute = `${</span><span class="s3">\n        </span><span class="s1">interceptingRoute !== '/' ? toPathToRegexpPath(interceptingRoute) : ''</span><span class="s3">\n      </span><span class="s1">}/(.*)?`</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute)</span><span class="s3">\n      </span><span class="s1">const normalizedAppPath = toPathToRegexpPath(appPath)</span><span class="s3">\n\n      </span><span class="s1">// pathToRegexp returns a regex that matches the path, but we need to</span><span class="s3">\n      </span><span class="s1">// convert it to a string that can be used in a header value</span><span class="s3">\n      </span><span class="s1">// to the format that Next/the proxy expects</span><span class="s3">\n      </span><span class="s1">let interceptingRouteRegex = safePathToRegexp(normalizedInterceptingRoute)</span><span class="s3">\n        </span><span class="s1">.toString()</span><span class="s3">\n        </span><span class="s1">.slice(2, -3)</span><span class="s3">\n\n      </span><span class="s1">rewrites.push({</span><span class="s3">\n        </span><span class="s1">source: `${basePath}${normalizedInterceptedRoute}`,</span><span class="s3">\n        </span><span class="s1">destination: `${basePath}${normalizedAppPath}`,</span><span class="s3">\n        </span><span class="s1">has: [</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">type: 'header',</span><span class="s3">\n            </span><span class="s1">key: NEXT_URL,</span><span class="s3">\n            </span><span class="s1">value: interceptingRouteRegex,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">],</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return rewrites</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteRewrite(route: DeepReadonly&lt;Rewrite&gt;) {</span><span class="s3">\n  </span><span class="s1">// When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.</span><span class="s3">\n  </span><span class="s1">return route.has?.[0]?.key === NEXT_URL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const RSC_HEADER = 'rsc' as const</span><span class="s3">\n</span><span class="s1">export const ACTION_HEADER = 'next-action' as const</span><span class="s3">\n</span><span class="s1">// TODO: Instead of sending the full router state, we only need to send the</span><span class="s3">\n</span><span class="s1">// segment path. Saves bytes. Then we could also use this field for segment</span><span class="s3">\n</span><span class="s1">// prefetches, which also need to specify a particular segment.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const</span><span class="s3">\n</span><span class="s1">// This contains the path to the segment being prefetched.</span><span class="s3">\n</span><span class="s1">// TODO: If we change next-router-state-tree to be a segment path, we can use</span><span class="s3">\n</span><span class="s1">// that instead. Then next-router-prefetch and next-router-segment-prefetch can</span><span class="s3">\n</span><span class="s1">// be merged into a single enum.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =</span><span class="s3">\n  </span><span class="s1">'next-router-segment-prefetch' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_URL = 'next-url' as const</span><span class="s3">\n</span><span class="s1">export const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const</span><span class="s3">\n\n</span><span class="s1">export const FLIGHT_HEADERS = [</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_HMR_REFRESH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_RSC_UNION_QUERY = '_rsc' as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Rewrite } from '../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { RouteMatchFn } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import type { NextConfig } from './config'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n\n</span><span class="s1">import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { getPathMatch } from '../shared/lib/router/utils/path-match'</span><span class="s3">\n</span><span class="s1">import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'</span><span class="s3">\n</span><span class="s1">import { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">matchHas,</span><span class="s3">\n  </span><span class="s1">prepareDestination,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/prepare-destination'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { normalizeRscURL } from '../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATED_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import { normalizeNextQueryParam } from './web/utils'</span><span class="s3">\n</span><span class="s1">import type { IncomingHttpHeaders, IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import { parseReqUrl } from '../lib/url'</span><span class="s3">\n</span><span class="s1">import { formatUrl } from '../shared/lib/router/utils/format-url'</span><span class="s3">\n</span><span class="s1">import { parseAndValidateFlightRouterState } from './app-render/parse-and-validate-flight-router-state'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites'</span><span class="s3">\n</span><span class="s1">import { NEXT_ROUTER_STATE_TREE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { getSelectedParams } from '../client/components/router-reducer/compute-changed-path'</span><span class="s3">\n\n</span><span class="s1">function filterInternalQuery(</span><span class="s3">\n  </span><span class="s1">query: Record&lt;string, undefined | string | string[]&gt;,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n  </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n  </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n  </span><span class="s1">for (const key in query) {</span><span class="s3">\n    </span><span class="s1">const isNextQueryPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_QUERY_PARAM_PREFIX &amp;&amp; key.startsWith(NEXT_QUERY_PARAM_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">const isNextInterceptionMarkerPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_INTERCEPTION_MARKER_PREFIX &amp;&amp;</span><span class="s3">\n      </span><span class="s1">key.startsWith(NEXT_INTERCEPTION_MARKER_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isNextQueryPrefix ||</span><span class="s3">\n      </span><span class="s1">isNextInterceptionMarkerPrefix ||</span><span class="s3">\n      </span><span class="s1">paramKeys.includes(key)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeCdnUrl(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// make sure to normalize req.url from CDNs to strip dynamic and rewrite</span><span class="s3">\n  </span><span class="s1">// params from the query which are added during routing</span><span class="s3">\n  </span><span class="s1">const _parsedUrl = parseReqUrl(req.url!)</span><span class="s3">\n\n  </span><span class="s1">// we can't normalize if we can't parse</span><span class="s3">\n  </span><span class="s1">if (!_parsedUrl) {</span><span class="s3">\n    </span><span class="s1">return req.url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">delete (_parsedUrl as any).search</span><span class="s3">\n  </span><span class="s1">filterInternalQuery(_parsedUrl.query, paramKeys)</span><span class="s3">\n\n  </span><span class="s1">req.url = formatUrl(_parsedUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function interpolateDynamicPath(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">params: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex?: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!defaultRouteRegex) return pathname</span><span class="s3">\n\n  </span><span class="s1">for (const param of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">const { optional, repeat } = defaultRouteRegex.groups[param]</span><span class="s3">\n    </span><span class="s1">let builtParam = `[${repeat ? '...' : ''}${param}]`</span><span class="s3">\n\n    </span><span class="s1">if (optional) {</span><span class="s3">\n      </span><span class="s1">builtParam = `[${builtParam}]`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let paramValue: string</span><span class="s3">\n    </span><span class="s1">const value = params[param]</span><span class="s3">\n\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">paramValue = value.map((v) =&gt; v &amp;&amp; encodeURIComponent(v)).join('/')</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">paramValue = encodeURIComponent(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">paramValue = ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (paramValue || optional) {</span><span class="s3">\n      </span><span class="s1">pathname = pathname.replaceAll(builtParam, paramValue)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeDynamicRouteParams(</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt;,</span><span class="s3">\n  </span><span class="s1">defaultRouteMatches: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let hasValidParams = true</span><span class="s3">\n  </span><span class="s1">let params: ParsedUrlQuery = {}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">let value: string | string[] | undefined = query[key]</span><span class="s3">\n\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">value = normalizeRscURL(value)</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">value = value.map(normalizeRscURL)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the value matches the default value we can't rely</span><span class="s3">\n    </span><span class="s1">// on the parsed params, this is used to signal if we need</span><span class="s3">\n    </span><span class="s1">// to parse x-now-route-matches or not</span><span class="s3">\n    </span><span class="s1">const defaultValue = defaultRouteMatches![key]</span><span class="s3">\n    </span><span class="s1">const isOptional = defaultRouteRegex!.groups[key].optional</span><span class="s3">\n\n    </span><span class="s1">const isDefaultValue = Array.isArray(defaultValue)</span><span class="s3">\n      </span><span class="s1">? defaultValue.some((defaultVal) =&gt; {</span><span class="s3">\n          </span><span class="s1">return Array.isArray(value)</span><span class="s3">\n            </span><span class="s1">? value.some((val) =&gt; val.includes(defaultVal))</span><span class="s3">\n            </span><span class="s1">: value?.includes(defaultVal)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">: value?.includes(defaultValue as string)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isDefaultValue ||</span><span class="s3">\n      </span><span class="s1">(typeof value === 'undefined' &amp;&amp; !(isOptional &amp;&amp; ignoreMissingOptional))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// non-provided optional values should be undefined so normalize</span><span class="s3">\n    </span><span class="s1">// them to undefined</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isOptional &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!value ||</span><span class="s3">\n        </span><span class="s1">(Array.isArray(value) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">value.length === 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// fallback optional catch-all SSG pages have</span><span class="s3">\n          </span><span class="s1">// [[...paramName]] for the root path on Vercel</span><span class="s3">\n          </span><span class="s1">(value[0] === 'index' || value[0] === `[[...${key}]]`)))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = undefined</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// query values from the proxy aren't already split into arrays</span><span class="s3">\n    </span><span class="s1">// so make sure to normalize catch-all values</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">value &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof value === 'string' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">defaultRouteRegex!.groups[key].repeat</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = value.split('/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (value) {</span><span class="s3">\n      </span><span class="s1">params[key] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">hasValidParams,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getServerUtils({</span><span class="s3">\n  </span><span class="s1">page,</span><span class="s3">\n  </span><span class="s1">i18n,</span><span class="s3">\n  </span><span class="s1">basePath,</span><span class="s3">\n  </span><span class="s1">rewrites,</span><span class="s3">\n  </span><span class="s1">pageIsDynamic,</span><span class="s3">\n  </span><span class="s1">trailingSlash,</span><span class="s3">\n  </span><span class="s1">caseSensitive,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">i18n?: NextConfig['i18n']</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">rewrites: DeepReadonly&lt;{</span><span class="s3">\n    </span><span class="s1">fallback?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">afterFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">beforeFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n  </span><span class="s1">pageIsDynamic: boolean</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">caseSensitive: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n  </span><span class="s1">let dynamicRouteMatcher: RouteMatchFn | undefined</span><span class="s3">\n  </span><span class="s1">let defaultRouteMatches: ParsedUrlQuery | undefined</span><span class="s3">\n\n  </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex = getNamedRouteRegex(page, {</span><span class="s3">\n      </span><span class="s1">prefixRouteKeys: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleRewrites(</span><span class="s3">\n    </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const rewriteParams: Record&lt;string, string&gt; = {}</span><span class="s3">\n    </span><span class="s1">let fsPathname = parsedUrl.pathname</span><span class="s3">\n\n    </span><span class="s1">const matchesPage = () =&gt; {</span><span class="s3">\n      </span><span class="s1">const fsPathnameNoSlash = removeTrailingSlash(fsPathname || '')</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">fsPathnameNoSlash === removeTrailingSlash(page) ||</span><span class="s3">\n        </span><span class="s1">dynamicRouteMatcher?.(fsPathnameNoSlash)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const checkRewrite = (rewrite: DeepReadonly&lt;Rewrite&gt;): boolean =&gt; {</span><span class="s3">\n      </span><span class="s1">const matcher = getPathMatch(</span><span class="s3">\n        </span><span class="s1">rewrite.source + (trailingSlash ? '(/)?' : ''),</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">removeUnnamedParams: true,</span><span class="s3">\n          </span><span class="s1">strict: true,</span><span class="s3">\n          </span><span class="s1">sensitive: !!caseSensitive,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (!parsedUrl.pathname) return false</span><span class="s3">\n\n      </span><span class="s1">let params = matcher(parsedUrl.pathname)</span><span class="s3">\n\n      </span><span class="s1">if ((rewrite.has || rewrite.missing) &amp;&amp; params) {</span><span class="s3">\n        </span><span class="s1">const hasParams = matchHas(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">parsedUrl.query,</span><span class="s3">\n          </span><span class="s1">rewrite.has as Rewrite['has'],</span><span class="s3">\n          </span><span class="s1">rewrite.missing as Rewrite['missing']</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (hasParams) {</span><span class="s3">\n          </span><span class="s1">Object.assign(params, hasParams)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (params) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">// An interception rewrite might reference a dynamic param for a route the user</span><span class="s3">\n          </span><span class="s1">// is currently on, which wouldn't be extractable from the matched route params.</span><span class="s3">\n          </span><span class="s1">// This attempts to extract the dynamic params from the provided router state.</span><span class="s3">\n          </span><span class="s1">if (isInterceptionRouteRewrite(rewrite as Rewrite)) {</span><span class="s3">\n            </span><span class="s1">const stateHeader = req.headers[NEXT_ROUTER_STATE_TREE_HEADER]</span><span class="s3">\n\n            </span><span class="s1">if (stateHeader) {</span><span class="s3">\n              </span><span class="s1">params = {</span><span class="s3">\n                </span><span class="s1">...getSelectedParams(</span><span class="s3">\n                  </span><span class="s1">parseAndValidateFlightRouterState(stateHeader)</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">...params,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">// this is a no-op -- we couldn't extract dynamic params from the provided router state,</span><span class="s3">\n          </span><span class="s1">// so we'll just use the params from the route matcher</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const { parsedDestination, destQuery } = prepareDestination({</span><span class="s3">\n          </span><span class="s1">appendParamsToQuery: true,</span><span class="s3">\n          </span><span class="s1">destination: rewrite.destination,</span><span class="s3">\n          </span><span class="s1">params: params,</span><span class="s3">\n          </span><span class="s1">query: parsedUrl.query,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">// if the rewrite destination is external break rewrite chain</span><span class="s3">\n        </span><span class="s1">if (parsedDestination.protocol) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">Object.assign(rewriteParams, destQuery, params)</span><span class="s3">\n        </span><span class="s1">Object.assign(parsedUrl.query, parsedDestination.query)</span><span class="s3">\n        </span><span class="s1">delete (parsedDestination as any).query</span><span class="s3">\n\n        </span><span class="s1">// for each property in parsedUrl.query, if the value is parametrized (eg :foo), look up the value</span><span class="s3">\n        </span><span class="s1">// in rewriteParams and replace the parametrized value with the actual value</span><span class="s3">\n        </span><span class="s1">// this is used when the rewrite destination does not contain the original source param</span><span class="s3">\n        </span><span class="s1">// and so the value is still parametrized and needs to be replaced with the actual rewrite param</span><span class="s3">\n        </span><span class="s1">Object.entries(parsedUrl.query).forEach(([key, value]) =&gt; {</span><span class="s3">\n          </span><span class="s1">if (value &amp;&amp; typeof value === 'string' &amp;&amp; value.startsWith(':')) {</span><span class="s3">\n            </span><span class="s1">const paramName = value.slice(1)</span><span class="s3">\n            </span><span class="s1">const actualValue = rewriteParams[paramName]</span><span class="s3">\n            </span><span class="s1">if (actualValue) {</span><span class="s3">\n              </span><span class="s1">parsedUrl.query[key] = actualValue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">Object.assign(parsedUrl, parsedDestination)</span><span class="s3">\n\n        </span><span class="s1">fsPathname = parsedUrl.pathname</span><span class="s3">\n        </span><span class="s1">if (!fsPathname) return false</span><span class="s3">\n\n        </span><span class="s1">if (basePath) {</span><span class="s3">\n          </span><span class="s1">fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (i18n) {</span><span class="s3">\n          </span><span class="s1">const result = normalizeLocalePath(fsPathname, i18n.locales)</span><span class="s3">\n          </span><span class="s1">fsPathname = result.pathname</span><span class="s3">\n          </span><span class="s1">parsedUrl.query.nextInternalLocale =</span><span class="s3">\n            </span><span class="s1">result.detectedLocale || params.nextInternalLocale</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (fsPathname === page) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (pageIsDynamic &amp;&amp; dynamicRouteMatcher) {</span><span class="s3">\n          </span><span class="s1">const dynamicParams = dynamicRouteMatcher(fsPathname)</span><span class="s3">\n          </span><span class="s1">if (dynamicParams) {</span><span class="s3">\n            </span><span class="s1">parsedUrl.query = {</span><span class="s3">\n              </span><span class="s1">...parsedUrl.query,</span><span class="s3">\n              </span><span class="s1">...dynamicParams,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const rewrite of rewrites.beforeFiles || []) {</span><span class="s3">\n      </span><span class="s1">checkRewrite(rewrite)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (fsPathname !== page) {</span><span class="s3">\n      </span><span class="s1">let finished = false</span><span class="s3">\n\n      </span><span class="s1">for (const rewrite of rewrites.afterFiles || []) {</span><span class="s3">\n        </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n        </span><span class="s1">if (finished) break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!finished &amp;&amp; !matchesPage()) {</span><span class="s3">\n        </span><span class="s1">for (const rewrite of rewrites.fallback || []) {</span><span class="s3">\n          </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n          </span><span class="s1">if (finished) break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return rewriteParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function getParamsFromRouteMatches(routeMatchesHeader: string) {</span><span class="s3">\n    </span><span class="s1">// If we don't have a default route regex, we can't get params from route</span><span class="s3">\n    </span><span class="s1">// matches</span><span class="s3">\n    </span><span class="s1">if (!defaultRouteRegex) return null</span><span class="s3">\n\n    </span><span class="s1">const { groups, routeKeys } = defaultRouteRegex</span><span class="s3">\n\n    </span><span class="s1">const matcher = getRouteMatcher({</span><span class="s3">\n      </span><span class="s1">re: {</span><span class="s3">\n        </span><span class="s1">// Simulate a RegExp match from the </span><span class="s3">\\</span><span class="s1">`req.url</span><span class="s3">\\</span><span class="s1">` input</span><span class="s3">\n        </span><span class="s1">exec: (str: string) =&gt; {</span><span class="s3">\n          </span><span class="s1">// Normalize all the prefixed query params.</span><span class="s3">\n          </span><span class="s1">const obj: Record&lt;string, string&gt; = Object.fromEntries(</span><span class="s3">\n            </span><span class="s1">new URLSearchParams(str)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">for (const [key, value] of Object.entries(obj)) {</span><span class="s3">\n            </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n            </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n            </span><span class="s1">obj[normalizedKey] = value</span><span class="s3">\n            </span><span class="s1">delete obj[key]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Use all the named route keys.</span><span class="s3">\n          </span><span class="s1">const result = {} as RegExpExecArray</span><span class="s3">\n          </span><span class="s1">for (const keyName of Object.keys(routeKeys)) {</span><span class="s3">\n            </span><span class="s1">const paramName = routeKeys[keyName]</span><span class="s3">\n\n            </span><span class="s1">// If this param name is not a valid parameter name, then skip it.</span><span class="s3">\n            </span><span class="s1">if (!paramName) continue</span><span class="s3">\n\n            </span><span class="s1">const group = groups[paramName]</span><span class="s3">\n            </span><span class="s1">const value = obj[keyName]</span><span class="s3">\n\n            </span><span class="s1">// When we're missing a required param, we can't match the route.</span><span class="s3">\n            </span><span class="s1">if (!group.optional &amp;&amp; !value) return null</span><span class="s3">\n\n            </span><span class="s1">result[group.pos] = value</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return result</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">groups,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const routeMatches = matcher(routeMatchesHeader)</span><span class="s3">\n    </span><span class="s1">if (!routeMatches) return null</span><span class="s3">\n\n    </span><span class="s1">return routeMatches</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function normalizeQueryParams(</span><span class="s3">\n    </span><span class="s1">query: Record&lt;string, string | string[] | undefined&gt;,</span><span class="s3">\n    </span><span class="s1">routeParamKeys: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n    </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n    </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n    </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n      </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n      </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n      </span><span class="s1">// Remove the prefixed key from the query params because we want</span><span class="s3">\n      </span><span class="s1">// to consume it for the dynamic route matcher.</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n      </span><span class="s1">routeParamKeys.add(normalizedKey)</span><span class="s3">\n\n      </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n\n      </span><span class="s1">query[normalizedKey] = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.map((v) =&gt; decodeQueryPathParameter(v))</span><span class="s3">\n        </span><span class="s1">: decodeQueryPathParameter(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">handleRewrites,</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher,</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n    </span><span class="s1">normalizeQueryParams,</span><span class="s3">\n    </span><span class="s1">getParamsFromRouteMatches,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Normalize dynamic route params.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param query - The query params to normalize.</span><span class="s3">\n     </span><span class="s1">* @param ignoreMissingOptional - Whether to ignore missing optional params.</span><span class="s3">\n     </span><span class="s1">* @returns The normalized params and whether they are valid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">normalizeDynamicRouteParams: (</span><span class="s3">\n      </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n      </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n    </span><span class="s1">) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!defaultRouteRegex || !defaultRouteMatches) {</span><span class="s3">\n        </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">query,</span><span class="s3">\n        </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n        </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n        </span><span class="s1">ignoreMissingOptional</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">normalizeCdnUrl: (</span><span class="s3">\n      </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n      </span><span class="s1">paramKeys: string[]</span><span class="s3">\n    </span><span class="s1">) =&gt; normalizeCdnUrl(req, paramKeys),</span><span class="s3">\n\n    </span><span class="s1">interpolateDynamicPath: (</span><span class="s3">\n      </span><span class="s1">pathname: string,</span><span class="s3">\n      </span><span class="s1">params: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; interpolateDynamicPath(pathname, params, defaultRouteRegex),</span><span class="s3">\n\n    </span><span class="s1">filterInternalQuery: (query: ParsedUrlQuery, paramKeys: string[]) =&gt;</span><span class="s3">\n      </span><span class="s1">filterInternalQuery(query, paramKeys),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getPreviouslyRevalidatedTags(</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">previewModeId: string | undefined</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">return typeof headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">headers[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === previewModeId</span><span class="s3">\n    </span><span class="s1">? headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')</span><span class="s3">\n    </span><span class="s1">: []</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { DomainLocale } from '../../../server/config-shared'</span><span class="s3">\n\n</span><span class="s1">export function detectDomainLocale(</span><span class="s3">\n  </span><span class="s1">domainItems?: readonly DomainLocale[],</span><span class="s3">\n  </span><span class="s1">hostname?: string,</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!domainItems) return</span><span class="s3">\n\n  </span><span class="s1">if (detectedLocale) {</span><span class="s3">\n    </span><span class="s1">detectedLocale = detectedLocale.toLowerCase()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const item of domainItems) {</span><span class="s3">\n    </span><span class="s1">// remove port if present</span><span class="s3">\n    </span><span class="s1">const domainHostname = item.domain?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">hostname === domainHostname ||</span><span class="s3">\n      </span><span class="s1">detectedLocale === item.defaultLocale.toLowerCase() ||</span><span class="s3">\n      </span><span class="s1">item.locales?.some((locale) =&gt; locale.toLowerCase() === detectedLocale)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return item</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes an object with a hostname property (like a parsed URL) and some</span><span class="s3">\n </span><span class="s1">* headers that may contain Host and returns the preferred hostname.</span><span class="s3">\n </span><span class="s1">* @param parsed An object containing a hostname property.</span><span class="s3">\n </span><span class="s1">* @param headers A dictionary with headers containing a `host`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getHostname(</span><span class="s3">\n  </span><span class="s1">parsed: { hostname?: string | null },</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">// Get the hostname from the headers if it exists, otherwise use the parsed</span><span class="s3">\n  </span><span class="s1">// hostname.</span><span class="s3">\n  </span><span class="s1">let hostname: string</span><span class="s3">\n  </span><span class="s1">if (headers?.host &amp;&amp; !Array.isArray(headers.host)) {</span><span class="s3">\n    </span><span class="s1">hostname = headers.host.toString().split(':', 1)[0]</span><span class="s3">\n  </span><span class="s1">} else if (parsed.hostname) {</span><span class="s3">\n    </span><span class="s1">hostname = parsed.hostname</span><span class="s3">\n  </span><span class="s1">} else return</span><span class="s3">\n\n  </span><span class="s1">return hostname.toLowerCase()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { pathHasPrefix } from '../router/utils/path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* strip _next/data/&lt;build-id&gt;/ prefix and .json suffix</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeDataPath(pathname: string) {</span><span class="s3">\n  </span><span class="s1">if (!pathHasPrefix(pathname || '/', '/_next/data')) {</span><span class="s3">\n    </span><span class="s1">return pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">pathname = pathname</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">/data</span><span class="s3">\\</span><span class="s1">/[^/]{1,}/, '')</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">.json$/, '')</span><span class="s3">\n\n  </span><span class="s1">if (pathname === '/index') {</span><span class="s3">\n    </span><span class="s1">return '/'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* eslint-disable no-redeclare */</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { CloneableBody } from './body-streams'</span><span class="s3">\n</span><span class="s1">import type { RouteMatch } from './route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import type { ServerComponentsHmrCache } from './response-cache'</span><span class="s3">\n</span><span class="s1">import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'</span><span class="s3">\n\n</span><span class="s1">// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules</span><span class="s3">\n</span><span class="s1">export const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')</span><span class="s3">\n\n</span><span class="s1">export type NextIncomingMessage = (BaseNextRequest | IncomingMessage) &amp; {</span><span class="s3">\n  </span><span class="s1">[NEXT_REQUEST_META]?: RequestMeta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RequestMeta {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initQuery?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The URL that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The protocol that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initProtocol?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The body that was read from the request. This is used to allow the body to</span><span class="s3">\n   </span><span class="s1">* be read multiple times.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clonableBody?: CloneableBody</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request matched a locale domain that was configured in the</span><span class="s3">\n   </span><span class="s1">* next.config.js file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isLocaleDomain?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information stripped from the pathname</span><span class="s3">\n   </span><span class="s1">* part of the URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">didStripLocale?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If the request had it's URL rewritten, this is the URL it was rewritten to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rewroteURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cookies that were added by middleware and were added to the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareCookie?: string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The match on the request for a given route.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">match?: RouteMatch</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The incremental cache to use for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">incrementalCache?: any</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The server components HMR cache, only for dev.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache?: ServerComponentsHmrCache</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Equals the segment path that was used for the prefetch RSC request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">segmentPrefetchRSCRequest?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the prefetch flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isPrefetchRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A search param set by the Next.js client when performing RSC requests.</span><span class="s3">\n   </span><span class="s1">* Because some CDNs do not vary their cache entries on our custom headers,</span><span class="s3">\n   </span><span class="s1">* this search param represents a hash of the header values. For any cached</span><span class="s3">\n   </span><span class="s1">* RSC request, we should verify that the hash matches before responding.</span><span class="s3">\n   </span><span class="s1">* Otherwise this can lead to cache poisoning.</span><span class="s3">\n   </span><span class="s1">* TODO: Consider not using custom request headers at all, and instead encode</span><span class="s3">\n   </span><span class="s1">* everything into the search param.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cacheBustingSearchParam?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the `/_next/data` route using the pages</span><span class="s3">\n   </span><span class="s1">* router.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isNextDataReq?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Postponed state to use for resumption. If present it's assumed that the</span><span class="s3">\n   </span><span class="s1">* request is for a page that has postponed (there are no guarantees that the</span><span class="s3">\n   </span><span class="s1">* page actually has postponed though as it would incur an additional cache</span><span class="s3">\n   </span><span class="s1">* lookup).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If provided, this will be called when a response cache entry was generated</span><span class="s3">\n   </span><span class="s1">* or looked up in the cache.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">onCacheEntry?: (</span><span class="s3">\n    </span><span class="s1">cacheEntry: any,</span><span class="s3">\n    </span><span class="s1">requestMeta: any</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;boolean | void&gt; | boolean | void</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The previous revalidate before rendering 404 page for notFound: true</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">notFoundRevalidate?: number | false</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the original source page that returned a 404.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">developmentNotFoundSourcePage?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The path we routed to and should be invoked</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokePath?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The specific page output we should be matching</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeOutput?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The status we are invoking the request with from routing</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeStatus?: number</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The routing error we are invoking with</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeError?: Error</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query parsed for the invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeQuery?: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is a middleware invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareInvoke?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request should render the fallback shell or not.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderFallbackShell?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is for the custom error page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">customErrorRender?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to bubble up the NoFallbackError to the caller when a 404 is</span><span class="s3">\n   </span><span class="s1">* returned.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">bubbleNoFallback?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information inferred from the default</span><span class="s3">\n   </span><span class="s1">* locale.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">localeInferredFromDefault?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The default locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The relative project dir the server is running in from project root</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">relativeProjectDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The dist directory the server is currently using</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">distDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The params after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The AMP validator to use in development</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ampValidator?: (html: string, pathname: string) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* ErrorOverlay component to use in development for pages router</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PagesErrorDebug?: PagesDevOverlayBridgeType</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether server is in minimal mode (this will be replaced with more</span><span class="s3">\n   </span><span class="s1">* specific flags in future)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* DEV only: The fallback params that should be used when validating prerenders during dev</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">devValidatingFallbackParams?: Map&lt;string, string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the request metadata. If no key is provided, the entire metadata object</span><span class="s3">\n </span><span class="s1">* is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to get the metadata from</span><span class="s3">\n </span><span class="s1">* @param key the key to get from the metadata (optional)</span><span class="s3">\n </span><span class="s1">* @returns the value for the key or the entire metadata object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRequestMeta(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: undefined</span><span class="s3">\n</span><span class="s1">): RequestMeta</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">): RequestMeta[K]</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: K</span><span class="s3">\n</span><span class="s1">): RequestMeta | RequestMeta[K] {</span><span class="s3">\n  </span><span class="s1">const meta = req[NEXT_REQUEST_META] || {}</span><span class="s3">\n  </span><span class="s1">return typeof key === 'string' ? meta[key] : meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to set the metadata on</span><span class="s3">\n </span><span class="s1">* @param meta the metadata to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {</span><span class="s3">\n  </span><span class="s1">req[NEXT_REQUEST_META] = meta</span><span class="s3">\n  </span><span class="s1">return meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds a value to the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to set</span><span class="s3">\n </span><span class="s1">* @param value the value to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K,</span><span class="s3">\n  </span><span class="s1">value: RequestMeta[K]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">meta[key] = value</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes a key from the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to remove</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removeRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">delete meta[key]</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type NextQueryMetadata = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `_rsc` query parameter used for cache busting to ensure that the RSC</span><span class="s3">\n   </span><span class="s1">* requests do not get cached by the browser explicitly.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[NEXT_RSC_UNION_QUERY]?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NextParsedUrlQuery = ParsedUrlQuery &amp;</span><span class="s3">\n  </span><span class="s1">NextQueryMetadata &amp; {</span><span class="s3">\n    </span><span class="s1">amp?: '1'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface NextUrlWithParsedQuery extends UrlWithParsedQuery {</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ensureLeadingSlash } from './ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../router/utils'</span><span class="s3">\n</span><span class="s1">import { NormalizeError } from '../utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes a page and transforms it into its file counterpart ensuring that the</span><span class="s3">\n </span><span class="s1">* output is normalized. Note this function is not idempotent because a page</span><span class="s3">\n </span><span class="s1">* `/index` can be referencing `/index/index.js` and `/index/index` could be</span><span class="s3">\n </span><span class="s1">* referencing `/index/index/index.js`. Examples:</span><span class="s3">\n </span><span class="s1">*  - `/` -&gt; `/index`</span><span class="s3">\n </span><span class="s1">*  - `/index/foo` -&gt; `/index/index/foo`</span><span class="s3">\n </span><span class="s1">*  - `/index` -&gt; `/index/index`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizePagePath(page: string): string {</span><span class="s3">\n  </span><span class="s1">const normalized =</span><span class="s3">\n    </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">/index(</span><span class="s3">\\</span><span class="s1">/|$)/.test(page) &amp;&amp; !isDynamicRoute(page)</span><span class="s3">\n      </span><span class="s1">? `/index${page}`</span><span class="s3">\n      </span><span class="s1">: page === '/'</span><span class="s3">\n        </span><span class="s1">? '/index'</span><span class="s3">\n        </span><span class="s1">: ensureLeadingSlash(page)</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n    </span><span class="s1">const { posix } = require('path') as typeof import('path')</span><span class="s3">\n    </span><span class="s1">const resolvedPage = posix.normalize(normalized)</span><span class="s3">\n    </span><span class="s1">if (resolvedPage !== normalized) {</span><span class="s3">\n      </span><span class="s1">throw new NormalizeError(</span><span class="s3">\n        </span><span class="s1">`Requested and resolved page mismatch: ${normalized} ${resolvedPage}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalized</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PageExtensions } from '../../build/page-extensions-type'</span><span class="s3">\n</span><span class="s1">import { normalizePathSep } from '../../shared/lib/page-path/normalize-path-sep'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { isAppRouteRoute } from '../is-app-route-route'</span><span class="s3">\n\n</span><span class="s1">export const STATIC_METADATA_IMAGES = {</span><span class="s3">\n  </span><span class="s1">icon: {</span><span class="s3">\n    </span><span class="s1">filename: 'icon',</span><span class="s3">\n    </span><span class="s1">extensions: ['ico', 'jpg', 'jpeg', 'png', 'svg'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">apple: {</span><span class="s3">\n    </span><span class="s1">filename: 'apple-icon',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">favicon: {</span><span class="s3">\n    </span><span class="s1">filename: 'favicon',</span><span class="s3">\n    </span><span class="s1">extensions: ['ico'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">openGraph: {</span><span class="s3">\n    </span><span class="s1">filename: 'opengraph-image',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png', 'gif'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">twitter: {</span><span class="s3">\n    </span><span class="s1">filename: 'twitter-image',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png', 'gif'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">// Match routes that are metadata routes, e.g. /sitemap.xml, /favicon.&lt;ext&gt;, /&lt;icon&gt;.&lt;ext&gt;, etc.</span><span class="s3">\n</span><span class="s1">// TODO-METADATA: support more metadata routes with more extensions</span><span class="s3">\n</span><span class="s1">export const DEFAULT_METADATA_ROUTE_EXTENSIONS = ['js', 'jsx', 'ts', 'tsx']</span><span class="s3">\n\n</span><span class="s1">// Match the file extension with the dynamic multi-routes extensions</span><span class="s3">\n</span><span class="s1">// e.g. ([xml, js], null) -&gt; can match `/sitemap.xml/route`, `sitemap.js/route`</span><span class="s3">\n</span><span class="s1">// e.g. ([png], [ts]) -&gt; can match `/opengrapg-image.png`, `/opengraph-image.ts`</span><span class="s3">\n</span><span class="s1">export const getExtensionRegexString = (</span><span class="s3">\n  </span><span class="s1">staticExtensions: readonly string[],</span><span class="s3">\n  </span><span class="s1">dynamicExtensions: readonly string[] | null</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">// If there's no possible multi dynamic routes, will not match any &lt;name&gt;[].&lt;ext&gt; files</span><span class="s3">\n  </span><span class="s1">if (!dynamicExtensions || dynamicExtensions.length === 0) {</span><span class="s3">\n    </span><span class="s1">return `(</span><span class="s3">\\\\</span><span class="s1">.(?:${staticExtensions.join('|')}))`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return `(?:</span><span class="s3">\\\\</span><span class="s1">.(${staticExtensions.join('|')})|(</span><span class="s3">\\\\</span><span class="s1">.(${dynamicExtensions.join('|')})))`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine if the file is a metadata route file entry</span><span class="s3">\n </span><span class="s1">* @param appDirRelativePath the relative file path to app/</span><span class="s3">\n </span><span class="s1">* @param pageExtensions the js extensions, such as ['js', 'jsx', 'ts', 'tsx']</span><span class="s3">\n </span><span class="s1">* @param strictlyMatchExtensions if it's true, match the file with page extension, otherwise match the file with default corresponding extension</span><span class="s3">\n </span><span class="s1">* @returns if the file is a metadata route file</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataRouteFile(</span><span class="s3">\n  </span><span class="s1">appDirRelativePath: string,</span><span class="s3">\n  </span><span class="s1">pageExtensions: PageExtensions,</span><span class="s3">\n  </span><span class="s1">strictlyMatchExtensions: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// End with the extension or optional to have the extension</span><span class="s3">\n  </span><span class="s1">// When strictlyMatchExtensions is true, it's used for match file path;</span><span class="s3">\n  </span><span class="s1">// When strictlyMatchExtensions, the dynamic extension is skipped but</span><span class="s3">\n  </span><span class="s1">// static extension is kept, which is usually used for matching route path.</span><span class="s3">\n  </span><span class="s1">const trailingMatcher = (strictlyMatchExtensions ? '' : '?') + '$'</span><span class="s3">\n  </span><span class="s1">// Match the optional variants like /opengraph-image2, /icon-a102f4.png, etc.</span><span class="s3">\n  </span><span class="s1">const variantsMatcher = '</span><span class="s3">\\\\</span><span class="s1">d?'</span><span class="s3">\n  </span><span class="s1">// The -</span><span class="s3">\\</span><span class="s1">w{6} is the suffix that normalized from group routes;</span><span class="s3">\n  </span><span class="s1">const groupSuffix = strictlyMatchExtensions ? '' : '(-</span><span class="s3">\\\\</span><span class="s1">w{6})?'</span><span class="s3">\n\n  </span><span class="s1">const suffixMatcher = `${variantsMatcher}${groupSuffix}`</span><span class="s3">\n\n  </span><span class="s1">const metadataRouteFilesRegex = [</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]robots${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">pageExtensions.concat('txt'),</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]manifest${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">pageExtensions.concat('webmanifest', 'json'),</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]favicon</span><span class="s3">\\\\</span><span class="s1">.ico$`),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]sitemap${getExtensionRegexString(['xml'], pageExtensions)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.icon.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.icon.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.apple.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.apple.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.openGraph.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.openGraph.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.twitter.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.twitter.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">const normalizedAppDirRelativePath = normalizePathSep(appDirRelativePath)</span><span class="s3">\n  </span><span class="s1">const matched = metadataRouteFilesRegex.some((r) =&gt;</span><span class="s3">\n    </span><span class="s1">r.test(normalizedAppDirRelativePath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Check if the route is a static metadata route, with /route suffix</span><span class="s3">\n</span><span class="s1">// e.g. /favicon.ico/route, /icon.png/route, etc.</span><span class="s3">\n</span><span class="s1">// But skip the text routes like robots.txt since they might also be dynamic.</span><span class="s3">\n</span><span class="s1">// Checking route path is not enough to determine if text routes is dynamic.</span><span class="s3">\n</span><span class="s1">export function isStaticMetadataRoute(route: string) {</span><span class="s3">\n  </span><span class="s1">// extract ext with regex</span><span class="s3">\n  </span><span class="s1">const pathname = route.replace(/</span><span class="s3">\\</span><span class="s1">/route$/, '')</span><span class="s3">\n\n  </span><span class="s1">const matched =</span><span class="s3">\n    </span><span class="s1">isAppRouteRoute(route) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isMetadataRouteFile(pathname, [], true) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// These routes can either be built by static or dynamic entrypoints,</span><span class="s3">\n    </span><span class="s1">// so we assume they're dynamic</span><span class="s3">\n    </span><span class="s1">pathname !== '/robots.txt' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">pathname !== '/manifest.webmanifest' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!pathname.endsWith('/sitemap.xml')</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine if a page or pathname is a metadata page.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The input is a page or pathname, which can be with or without page suffix /foo/page or /foo.</span><span class="s3">\n </span><span class="s1">* But it will not contain the /route suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* .e.g</span><span class="s3">\n </span><span class="s1">* /robots -&gt; true</span><span class="s3">\n </span><span class="s1">* /sitemap -&gt; true</span><span class="s3">\n </span><span class="s1">* /foo -&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataPage(page: string) {</span><span class="s3">\n  </span><span class="s1">const matched = !isAppRouteRoute(page) &amp;&amp; isMetadataRouteFile(page, [], false)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Determine if a Next.js route is a metadata route.</span><span class="s3">\n </span><span class="s1">* `route` will has a route suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* e.g.</span><span class="s3">\n </span><span class="s1">* /app/robots/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /robots/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /sitemap/[__metadata_id__]/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /app/sitemap/page -&gt; false</span><span class="s3">\n </span><span class="s1">* /icon-a102f4/route -&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataRoute(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">let page = normalizeAppPath(route)</span><span class="s3">\n    </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">/?app</span><span class="s3">\\</span><span class="s1">//, '')</span><span class="s3">\n    </span><span class="s1">// Remove the dynamic route id</span><span class="s3">\n    </span><span class="s1">.replace('/[__metadata_id__]', '')</span><span class="s3">\n    </span><span class="s1">// Remove the /route suffix</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/route$/, '')</span><span class="s3">\n\n  </span><span class="s1">if (page[0] !== '/') page = '/' + page</span><span class="s3">\n\n  </span><span class="s1">const matched = isAppRouteRoute(route) &amp;&amp; isMetadataRouteFile(page, [], false)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A `Promise.withResolvers` implementation that exposes the `resolve` and</span><span class="s3">\n </span><span class="s1">* `reject` functions on a `Promise`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @see https://tc39.es/proposal-promise-with-resolvers/</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class DetachedPromise&lt;T = any&gt; {</span><span class="s3">\n  </span><span class="s1">public readonly resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n  </span><span class="s1">public readonly reject: (reason: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">public readonly promise: Promise&lt;T&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">let resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">let reject: (reason: any) =&gt; void</span><span class="s3">\n\n    </span><span class="s1">// Create the promise and assign the resolvers to the object.</span><span class="s3">\n    </span><span class="s1">this.promise = new Promise&lt;T&gt;((res, rej) =&gt; {</span><span class="s3">\n      </span><span class="s1">resolve = res</span><span class="s3">\n      </span><span class="s1">reject = rej</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// We know that resolvers is defined because the Promise constructor runs</span><span class="s3">\n    </span><span class="s1">// synchronously.</span><span class="s3">\n    </span><span class="s1">this.resolve = resolve!</span><span class="s3">\n    </span><span class="s1">this.reject = reject!</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { SchedulerFn } from './scheduler'</span><span class="s3">\n\n</span><span class="s1">import { DetachedPromise } from './detached-promise'</span><span class="s3">\n\n</span><span class="s1">type CacheKeyFn&lt;K, C extends string | number | null&gt; = (</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">) =&gt; PromiseLike&lt;C&gt; | C</span><span class="s3">\n\n</span><span class="s1">type BatcherOptions&lt;K, C extends string | number | null&gt; = {</span><span class="s3">\n  </span><span class="s1">cacheKeyFn?: CacheKeyFn&lt;K, C&gt;</span><span class="s3">\n  </span><span class="s1">schedulerFn?: SchedulerFn&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type WorkFn&lt;V, C&gt; = (</span><span class="s3">\n  </span><span class="s1">key: C,</span><span class="s3">\n  </span><span class="s1">resolve: (value: V | PromiseLike&lt;V&gt;) =&gt; void</span><span class="s3">\n</span><span class="s1">) =&gt; Promise&lt;V&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A wrapper for a function that will only allow one call to the function to</span><span class="s3">\n </span><span class="s1">* execute at a time.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Batcher&lt;K, V, C extends string | number | null&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly pending = new Map&lt;C, Promise&lt;V&gt;&gt;()</span><span class="s3">\n\n  </span><span class="s1">protected constructor(</span><span class="s3">\n    </span><span class="s1">private readonly cacheKeyFn?: CacheKeyFn&lt;K, C&gt;,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A function that will be called to schedule the wrapped function to be</span><span class="s3">\n     </span><span class="s1">* executed. This defaults to a function that will execute the function</span><span class="s3">\n     </span><span class="s1">* immediately.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">private readonly schedulerFn: SchedulerFn&lt;void&gt; = (fn) =&gt; fn()</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a new instance of PendingWrapper. If the key extends a string or</span><span class="s3">\n   </span><span class="s1">* number, the key will be used as the cache key. If the key is an object, a</span><span class="s3">\n   </span><span class="s1">* cache key function must be provided.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static create&lt;K extends string | number | null, V&gt;(</span><span class="s3">\n    </span><span class="s1">options?: BatcherOptions&lt;K, K&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, K&gt;</span><span class="s3">\n  </span><span class="s1">public static create&lt;K, V, C extends string | number | null&gt;(</span><span class="s3">\n    </span><span class="s1">options: BatcherOptions&lt;K, C&gt; &amp;</span><span class="s3">\n      </span><span class="s1">Required&lt;Pick&lt;BatcherOptions&lt;K, C&gt;, 'cacheKeyFn'&gt;&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, C&gt;</span><span class="s3">\n  </span><span class="s1">public static create&lt;K, V, C extends string | number | null&gt;(</span><span class="s3">\n    </span><span class="s1">options?: BatcherOptions&lt;K, C&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, C&gt; {</span><span class="s3">\n    </span><span class="s1">return new Batcher&lt;K, V, C&gt;(options?.cacheKeyFn, options?.schedulerFn)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Wraps a function in a promise that will be resolved or rejected only once</span><span class="s3">\n   </span><span class="s1">* for a given key. This will allow multiple calls to the function to be</span><span class="s3">\n   </span><span class="s1">* made, but only one will be executed at a time. The result of the first</span><span class="s3">\n   </span><span class="s1">* call will be returned to all callers.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param key the key to use for the cache</span><span class="s3">\n   </span><span class="s1">* @param fn the function to wrap</span><span class="s3">\n   </span><span class="s1">* @returns a promise that resolves to the result of the function</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async batch(key: K, fn: WorkFn&lt;V, C&gt;): Promise&lt;V&gt; {</span><span class="s3">\n    </span><span class="s1">const cacheKey = (this.cacheKeyFn ? await this.cacheKeyFn(key) : key) as C</span><span class="s3">\n    </span><span class="s1">if (cacheKey === null) {</span><span class="s3">\n      </span><span class="s1">return fn(cacheKey, Promise.resolve)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const pending = this.pending.get(cacheKey)</span><span class="s3">\n    </span><span class="s1">if (pending) return pending</span><span class="s3">\n\n    </span><span class="s1">const { promise, resolve, reject } = new DetachedPromise&lt;V&gt;()</span><span class="s3">\n    </span><span class="s1">this.pending.set(cacheKey, promise)</span><span class="s3">\n\n    </span><span class="s1">this.schedulerFn(async () =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const result = await fn(cacheKey, resolve)</span><span class="s3">\n\n        </span><span class="s1">// Resolving a promise multiple times is a no-op, so we can safely</span><span class="s3">\n        </span><span class="s1">// resolve all pending promises with the same result.</span><span class="s3">\n        </span><span class="s1">resolve(result)</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">reject(err)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">this.pending.delete(cacheKey)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">return promise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export type ScheduledFn&lt;T = void&gt; = () =&gt; T | PromiseLike&lt;T&gt;</span><span class="s3">\n</span><span class="s1">export type SchedulerFn&lt;T = void&gt; = (cb: ScheduledFn&lt;T&gt;) =&gt; void</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Schedules a function to be called on the next tick after the other promises</span><span class="s3">\n </span><span class="s1">* have been resolved.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cb the function to schedule</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const scheduleOnNextTick = (cb: ScheduledFn&lt;void&gt;) =&gt; {</span><span class="s3">\n  </span><span class="s1">// We use Promise.resolve().then() here so that the operation is scheduled at</span><span class="s3">\n  </span><span class="s1">// the end of the promise job queue, we then add it to the next process tick</span><span class="s3">\n  </span><span class="s1">// to ensure it's evaluated afterwards.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">Promise.resolve().then(() =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">setTimeout(cb, 0)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">process.nextTick(cb)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Schedules a function to be called using `setImmediate` or `setTimeout` if</span><span class="s3">\n </span><span class="s1">* `setImmediate` is not available (like in the Edge runtime).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cb the function to schedule</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const scheduleImmediate = (cb: ScheduledFn&lt;void&gt;): void =&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">setTimeout(cb, 0)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">setImmediate(cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* returns a promise than resolves in a future task. There is no guarantee that the task it resolves in</span><span class="s3">\n </span><span class="s1">* will be the next task but if you await it you can at least be sure that the current task is over and</span><span class="s3">\n </span><span class="s1">* most usefully that the entire microtask queue of the current task has been emptied.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function atLeastOneTask() {</span><span class="s3">\n  </span><span class="s1">return new Promise&lt;void&gt;((resolve) =&gt; scheduleImmediate(resolve))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This utility function is extracted to make it easier to find places where we are doing</span><span class="s3">\n </span><span class="s1">* specific timing tricks to try to schedule work after React has rendered. This is especially</span><span class="s3">\n </span><span class="s1">* important at the moment because Next.js uses the edge builds of React which use setTimeout to</span><span class="s3">\n </span><span class="s1">* schedule work when you might expect that something like setImmediate would do the trick.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Long term we should switch to the node versions of React rendering when possible and then</span><span class="s3">\n </span><span class="s1">* update this to use setImmediate rather than setTimeout</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function waitAtLeastOneReactRenderTask(): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">return new Promise((r) =&gt; setTimeout(r, 0))</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return new Promise((r) =&gt; setImmediate(r))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type RenderResult from '../render-result'</span><span class="s3">\n</span><span class="s1">import type { CacheControl, Revalidate } from '../lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export interface ResponseCacheBase {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">key: string | null,</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator,</span><span class="s3">\n    </span><span class="s1">context: {</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n      </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n      </span><span class="s1">incrementalCache: IncrementalCache</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* This is a hint to the cache to help it determine what kind of route</span><span class="s3">\n       </span><span class="s1">* this is so it knows where to look up the cache entry from. If not</span><span class="s3">\n       </span><span class="s1">* provided it will test the filesystem to check.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">isFallback?: boolean</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// The server components HMR cache might store other data as well in the future,</span><span class="s3">\n</span><span class="s1">// at which point this should be refactored to a discriminated union type.</span><span class="s3">\n</span><span class="s1">export interface ServerComponentsHmrCache {</span><span class="s3">\n  </span><span class="s1">get(key: string): CachedFetchData | undefined</span><span class="s3">\n  </span><span class="s1">set(key: string, data: CachedFetchData): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type CachedFetchData = {</span><span class="s3">\n  </span><span class="s1">headers: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">body: string</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">status?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const enum CachedRouteKind {</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">FETCH = 'FETCH',</span><span class="s3">\n  </span><span class="s1">REDIRECT = 'REDIRECT',</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedFetchValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.FETCH</span><span class="s3">\n  </span><span class="s1">data: CachedFetchData</span><span class="s3">\n  </span><span class="s1">// tags are only present with file-system-cache</span><span class="s3">\n  </span><span class="s1">// fetch cache stores tags outside of cache entry</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">revalidate: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedRedirectValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.REDIRECT</span><span class="s3">\n  </span><span class="s1">props: Object</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedAppPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_PAGE</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">html: RenderResult</span><span class="s3">\n  </span><span class="s1">rscData: Buffer | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">postponed: string | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">segmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.PAGES</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">html: RenderResult</span><span class="s3">\n  </span><span class="s1">pageData: Object</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedRouteValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_ROUTE</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">body: Buffer</span><span class="s3">\n  </span><span class="s1">status: number</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedImageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.IMAGE</span><span class="s3">\n  </span><span class="s1">etag: string</span><span class="s3">\n  </span><span class="s1">upstreamEtag: string</span><span class="s3">\n  </span><span class="s1">buffer: Buffer</span><span class="s3">\n  </span><span class="s1">extension: string</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n  </span><span class="s1">isStale?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCachedAppPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_PAGE</span><span class="s3">\n  </span><span class="s1">// this needs to be a string since the cache expects to store</span><span class="s3">\n  </span><span class="s1">// the string value</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">rscData: Buffer | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">postponed: string | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">segmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCachedPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.PAGES</span><span class="s3">\n  </span><span class="s1">// this needs to be a string since the cache expects to store</span><span class="s3">\n  </span><span class="s1">// the string value</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">pageData: Object</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalResponseCacheEntry {</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* timestamp in milliseconds to revalidate after</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">revalidateAfter?: Revalidate</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `-1` here dictates a blocking revalidate should be used</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n  </span><span class="s1">value: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalFetchCacheEntry {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `-1` here dictates a blocking revalidate should be used</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">value: CachedFetchValue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type IncrementalCacheEntry =</span><span class="s3">\n  </span><span class="s1">| IncrementalResponseCacheEntry</span><span class="s3">\n  </span><span class="s1">| IncrementalFetchCacheEntry</span><span class="s3">\n\n</span><span class="s1">export type IncrementalCacheValue =</span><span class="s3">\n  </span><span class="s1">| CachedRedirectValue</span><span class="s3">\n  </span><span class="s1">| IncrementalCachedPageValue</span><span class="s3">\n  </span><span class="s1">| IncrementalCachedAppPageValue</span><span class="s3">\n  </span><span class="s1">| CachedImageValue</span><span class="s3">\n  </span><span class="s1">| CachedFetchValue</span><span class="s3">\n  </span><span class="s1">| CachedRouteValue</span><span class="s3">\n\n</span><span class="s1">export type ResponseCacheValue =</span><span class="s3">\n  </span><span class="s1">| CachedRedirectValue</span><span class="s3">\n  </span><span class="s1">| CachedPageValue</span><span class="s3">\n  </span><span class="s1">| CachedAppPageValue</span><span class="s3">\n  </span><span class="s1">| CachedImageValue</span><span class="s3">\n  </span><span class="s1">| CachedRouteValue</span><span class="s3">\n\n</span><span class="s1">export type ResponseCacheEntry = {</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">value: ResponseCacheValue | null</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param hasResolved whether the responseGenerator has resolved it's promise</span><span class="s3">\n </span><span class="s1">* @param previousCacheEntry the previous cache entry if it exists or the current</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type ResponseGenerator = (state: {</span><span class="s3">\n  </span><span class="s1">hasResolved: boolean</span><span class="s3">\n  </span><span class="s1">previousCacheEntry?: IncrementalResponseCacheEntry | null</span><span class="s3">\n  </span><span class="s1">isRevalidating?: boolean</span><span class="s3">\n  </span><span class="s1">span?: any</span><span class="s3">\n</span><span class="s1">}) =&gt; Promise&lt;ResponseCacheEntry | null&gt;</span><span class="s3">\n\n</span><span class="s1">export const enum IncrementalCacheKind {</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">FETCH = 'FETCH',</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface GetIncrementalFetchCacheContext {</span><span class="s3">\n  </span><span class="s1">kind: IncrementalCacheKind.FETCH</span><span class="s3">\n  </span><span class="s1">revalidate?: Revalidate</span><span class="s3">\n  </span><span class="s1">fetchUrl?: string</span><span class="s3">\n  </span><span class="s1">fetchIdx?: number</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">softTags?: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface GetIncrementalResponseCacheContext {</span><span class="s3">\n  </span><span class="s1">kind: Exclude&lt;IncrementalCacheKind, IncrementalCacheKind.FETCH&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isFallback: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface SetIncrementalFetchCacheContext {</span><span class="s3">\n  </span><span class="s1">fetchCache: true</span><span class="s3">\n  </span><span class="s1">fetchUrl?: string</span><span class="s3">\n  </span><span class="s1">fetchIdx?: number</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">isImplicitBuildTimeCache?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface SetIncrementalResponseCacheContext {</span><span class="s3">\n  </span><span class="s1">fetchCache?: false</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isFallback?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalResponseCache {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCache extends IncrementalResponseCache {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalFetchCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: CachedFetchValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ReactDOMServerReadableStream } from 'react-dom/server'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { AppRenderSpan } from '../lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../lib/detached-promise'</span><span class="s3">\n</span><span class="s1">import { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import { ENCODED_TAGS } from './encoded-tags'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">indexOfUint8Array,</span><span class="s3">\n  </span><span class="s1">isEquivalentUint8Arrays,</span><span class="s3">\n  </span><span class="s1">removeFromUint8Array,</span><span class="s3">\n</span><span class="s1">} from './uint8array-helpers'</span><span class="s3">\n</span><span class="s1">import { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'</span><span class="s3">\n</span><span class="s1">import { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'</span><span class="s3">\n\n</span><span class="s1">function voidCatch() {</span><span class="s3">\n  </span><span class="s1">// this catcher is designed to be used with pipeTo where we expect the underlying</span><span class="s3">\n  </span><span class="s1">// pipe implementation to forward errors but we don't want the pipeTo promise to reject</span><span class="s3">\n  </span><span class="s1">// and be unhandled</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We can share the same encoder instance everywhere</span><span class="s3">\n</span><span class="s1">// Notably we cannot do the same for TextDecoder because it is stateful</span><span class="s3">\n</span><span class="s1">// when handling streaming data</span><span class="s3">\n</span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n\n</span><span class="s1">export function chainStreams&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">...streams: ReadableStream&lt;T&gt;[]</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">// If we have no streams, return an empty stream. This behavior is</span><span class="s3">\n  </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n  </span><span class="s1">if (streams.length === 0) {</span><span class="s3">\n    </span><span class="s1">return new ReadableStream&lt;T&gt;({</span><span class="s3">\n      </span><span class="s1">start(controller) {</span><span class="s3">\n        </span><span class="s1">controller.close()</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we only have 1 stream we fast path it by returning just this stream</span><span class="s3">\n  </span><span class="s1">if (streams.length === 1) {</span><span class="s3">\n    </span><span class="s1">return streams[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { readable, writable } = new TransformStream()</span><span class="s3">\n\n  </span><span class="s1">// We always initiate pipeTo immediately. We know we have at least 2 streams</span><span class="s3">\n  </span><span class="s1">// so we need to avoid closing the writable when this one finishes.</span><span class="s3">\n  </span><span class="s1">let promise = streams[0].pipeTo(writable, { preventClose: true })</span><span class="s3">\n\n  </span><span class="s1">let i = 1</span><span class="s3">\n  </span><span class="s1">for (; i &lt; streams.length - 1; i++) {</span><span class="s3">\n    </span><span class="s1">const nextStream = streams[i]</span><span class="s3">\n    </span><span class="s1">promise = promise.then(() =&gt;</span><span class="s3">\n      </span><span class="s1">nextStream.pipeTo(writable, { preventClose: true })</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We can omit the length check because we halted before the last stream and there</span><span class="s3">\n  </span><span class="s1">// is at least two streams so the lastStream here will always be defined</span><span class="s3">\n  </span><span class="s1">const lastStream = streams[i]</span><span class="s3">\n  </span><span class="s1">promise = promise.then(() =&gt; lastStream.pipeTo(writable))</span><span class="s3">\n\n  </span><span class="s1">// Catch any errors from the streams and ignore them, they will be handled</span><span class="s3">\n  </span><span class="s1">// by whatever is consuming the readable stream.</span><span class="s3">\n  </span><span class="s1">promise.catch(voidCatch)</span><span class="s3">\n\n  </span><span class="s1">return readable</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function streamFromString(str: string): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(encoder.encode(str))</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function streamFromBuffer(chunk: Buffer): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function streamToBuffer(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;Buffer&gt; {</span><span class="s3">\n  </span><span class="s1">const reader = stream.getReader()</span><span class="s3">\n  </span><span class="s1">const chunks: Uint8Array[] = []</span><span class="s3">\n\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n    </span><span class="s1">if (done) {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">chunks.push(value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return Buffer.concat(chunks)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function streamToString(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n</span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n  </span><span class="s1">const decoder = new TextDecoder('utf-8', { fatal: true })</span><span class="s3">\n  </span><span class="s1">let string = ''</span><span class="s3">\n\n  </span><span class="s1">for await (const chunk of stream) {</span><span class="s3">\n    </span><span class="s1">if (signal?.aborted) {</span><span class="s3">\n      </span><span class="s1">return string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">string += decoder.decode(chunk, { stream: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">string += decoder.decode()</span><span class="s3">\n\n  </span><span class="s1">return string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createBufferedTransformStream(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">let bufferedChunks: Array&lt;Uint8Array&gt; = []</span><span class="s3">\n  </span><span class="s1">let bufferByteLength: number = 0</span><span class="s3">\n  </span><span class="s1">let pending: DetachedPromise&lt;void&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const flush = (controller: TransformStreamDefaultController) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If we already have a pending flush, then return early.</span><span class="s3">\n    </span><span class="s1">if (pending) return</span><span class="s3">\n\n    </span><span class="s1">const detached = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">pending = detached</span><span class="s3">\n\n    </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const chunk = new Uint8Array(bufferByteLength)</span><span class="s3">\n        </span><span class="s1">let copiedBytes = 0</span><span class="s3">\n\n        </span><span class="s1">for (let i = 0; i &lt; bufferedChunks.length; i++) {</span><span class="s3">\n          </span><span class="s1">const bufferedChunk = bufferedChunks[i]</span><span class="s3">\n          </span><span class="s1">chunk.set(bufferedChunk, copiedBytes)</span><span class="s3">\n          </span><span class="s1">copiedBytes += bufferedChunk.byteLength</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// We just wrote all the buffered chunks so we need to reset the bufferedChunks array</span><span class="s3">\n        </span><span class="s1">// and our bufferByteLength to prepare for the next round of buffered chunks</span><span class="s3">\n        </span><span class="s1">bufferedChunks.length = 0</span><span class="s3">\n        </span><span class="s1">bufferByteLength = 0</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// If an error occurs while enqueuing it can't be due to this</span><span class="s3">\n        </span><span class="s1">// transformers fault. It's likely due to the controller being</span><span class="s3">\n        </span><span class="s1">// errored due to the stream being cancelled.</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">pending = undefined</span><span class="s3">\n        </span><span class="s1">detached.resolve()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// Combine the previous buffer with the new chunk.</span><span class="s3">\n      </span><span class="s1">bufferedChunks.push(chunk)</span><span class="s3">\n      </span><span class="s1">bufferByteLength += chunk.byteLength</span><span class="s3">\n\n      </span><span class="s1">// Flush the buffer to the controller.</span><span class="s3">\n      </span><span class="s1">flush(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush() {</span><span class="s3">\n      </span><span class="s1">if (!pending) return</span><span class="s3">\n\n      </span><span class="s1">return pending.promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPrefetchCommentStream(</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean,</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">// Insert an extra comment at the beginning of the HTML document. This must</span><span class="s3">\n  </span><span class="s1">// come after the DOCTYPE, which is inserted by React.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// The first chunk sent by React will contain the doctype. After that, we can</span><span class="s3">\n  </span><span class="s1">// pass through the rest of the chunks as-is.</span><span class="s3">\n  </span><span class="s1">let didTransformFirstChunk = false</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">if (isBuildTimePrerendering &amp;&amp; !didTransformFirstChunk) {</span><span class="s3">\n        </span><span class="s1">didTransformFirstChunk = true</span><span class="s3">\n        </span><span class="s1">const decoder = new TextDecoder('utf-8', { fatal: true })</span><span class="s3">\n        </span><span class="s1">const chunkStr = decoder.decode(chunk, {</span><span class="s3">\n          </span><span class="s1">stream: true,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)</span><span class="s3">\n        </span><span class="s1">controller.enqueue(encoder.encode(updatedChunkStr))</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function renderToInitialFizzStream({</span><span class="s3">\n  </span><span class="s1">ReactDOMServer,</span><span class="s3">\n  </span><span class="s1">element,</span><span class="s3">\n  </span><span class="s1">streamOptions,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">ReactDOMServer: {</span><span class="s3">\n    </span><span class="s1">renderToReadableStream: typeof import('react-dom/server').renderToReadableStream</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">element: React.ReactElement</span><span class="s3">\n  </span><span class="s1">streamOptions?: Parameters&lt;typeof ReactDOMServer.renderToReadableStream&gt;[1]</span><span class="s3">\n</span><span class="s1">}): Promise&lt;ReactDOMServerReadableStream&gt; {</span><span class="s3">\n  </span><span class="s1">return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =&gt;</span><span class="s3">\n    </span><span class="s1">ReactDOMServer.renderToReadableStream(element, streamOptions)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createMetadataTransformStream(</span><span class="s3">\n  </span><span class="s1">insert: () =&gt; Promise&lt;string&gt; | string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let chunkIndex = -1</span><span class="s3">\n  </span><span class="s1">let isMarkRemoved = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">let iconMarkIndex = -1</span><span class="s3">\n      </span><span class="s1">let closedHeadIndex = -1</span><span class="s3">\n      </span><span class="s1">chunkIndex++</span><span class="s3">\n\n      </span><span class="s1">if (isMarkRemoved) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">let iconMarkLength = 0</span><span class="s3">\n      </span><span class="s1">// Only search for the closed head tag once</span><span class="s3">\n      </span><span class="s1">if (iconMarkIndex === -1) {</span><span class="s3">\n        </span><span class="s1">iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)</span><span class="s3">\n        </span><span class="s1">if (iconMarkIndex === -1) {</span><span class="s3">\n          </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// When we found the `&lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">nxt-icon</span><span class="s3">\&quot;</span><span class="s1">` tag prefix, we will remove it from the chunk.</span><span class="s3">\n          </span><span class="s1">// Its close tag could either be `/&gt;` or `&gt;`, checking the next char to ensure we cover both cases.</span><span class="s3">\n          </span><span class="s1">iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length</span><span class="s3">\n          </span><span class="s1">// Check if next char is /, this is for xml mode.</span><span class="s3">\n          </span><span class="s1">if (chunk[iconMarkIndex + iconMarkLength] === 47) {</span><span class="s3">\n            </span><span class="s1">iconMarkLength += 2</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The last char is `&gt;`</span><span class="s3">\n            </span><span class="s1">iconMarkLength++</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check if icon mark is inside &lt;head&gt; tag in the first chunk.</span><span class="s3">\n      </span><span class="s1">if (chunkIndex === 0) {</span><span class="s3">\n        </span><span class="s1">closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)</span><span class="s3">\n        </span><span class="s1">if (iconMarkIndex !== -1) {</span><span class="s3">\n          </span><span class="s1">// The mark icon is located in the 1st chunk before the head tag.</span><span class="s3">\n          </span><span class="s1">// We do not need to insert the script tag in this case because it's in the head.</span><span class="s3">\n          </span><span class="s1">// Just remove the icon mark from the chunk.</span><span class="s3">\n          </span><span class="s1">if (iconMarkIndex &lt; closedHeadIndex) {</span><span class="s3">\n            </span><span class="s1">const replaced = new Uint8Array(chunk.length - iconMarkLength)</span><span class="s3">\n\n            </span><span class="s1">// Remove the icon mark from the chunk.</span><span class="s3">\n            </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n            </span><span class="s1">replaced.set(</span><span class="s3">\n              </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n              </span><span class="s1">iconMarkIndex</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">chunk = replaced</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The icon mark is after the head tag, replace and insert the script tag at that position.</span><span class="s3">\n            </span><span class="s1">const insertion = await insert()</span><span class="s3">\n            </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n            </span><span class="s1">const insertionLength = encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">const replaced = new Uint8Array(</span><span class="s3">\n              </span><span class="s1">chunk.length - iconMarkLength + insertionLength</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n            </span><span class="s1">replaced.set(encodedInsertion, iconMarkIndex)</span><span class="s3">\n            </span><span class="s1">replaced.set(</span><span class="s3">\n              </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n              </span><span class="s1">iconMarkIndex + insertionLength</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">chunk = replaced</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">isMarkRemoved = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If there's no icon mark located, it will be handled later when if present in the following chunks.</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// When it's appeared in the following chunks, we'll need to</span><span class="s3">\n        </span><span class="s1">// remove the mark and then insert the script tag at that position.</span><span class="s3">\n        </span><span class="s1">const insertion = await insert()</span><span class="s3">\n        </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n        </span><span class="s1">const insertionLength = encodedInsertion.length</span><span class="s3">\n        </span><span class="s1">// Replace the icon mark with the hoist script or empty string.</span><span class="s3">\n        </span><span class="s1">const replaced = new Uint8Array(</span><span class="s3">\n          </span><span class="s1">chunk.length - iconMarkLength + insertionLength</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">// Set the first part of the chunk, before the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n        </span><span class="s1">// Set the insertion after the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(encodedInsertion, iconMarkIndex)</span><span class="s3">\n\n        </span><span class="s1">// Set the rest of the chunk after the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(</span><span class="s3">\n          </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n          </span><span class="s1">iconMarkIndex + insertionLength</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">chunk = replaced</span><span class="s3">\n        </span><span class="s1">isMarkRemoved = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createHeadInsertionTransformStream(</span><span class="s3">\n  </span><span class="s1">insert: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let inserted = false</span><span class="s3">\n\n  </span><span class="s1">// We need to track if this transform saw any bytes because if it didn't</span><span class="s3">\n  </span><span class="s1">// we won't want to insert any server HTML at all</span><span class="s3">\n  </span><span class="s1">let hasBytes = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">hasBytes = true</span><span class="s3">\n\n      </span><span class="s1">const insertion = await insert()</span><span class="s3">\n      </span><span class="s1">if (inserted) {</span><span class="s3">\n        </span><span class="s1">if (insertion) {</span><span class="s3">\n          </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n          </span><span class="s1">controller.enqueue(encodedInsertion)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.</span><span class="s3">\n        </span><span class="s1">const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)</span><span class="s3">\n        </span><span class="s1">// In fully static rendering or non PPR rendering cases:</span><span class="s3">\n        </span><span class="s1">// `/head&gt;` will always be found in the chunk in first chunk rendering.</span><span class="s3">\n        </span><span class="s1">if (index !== -1) {</span><span class="s3">\n          </span><span class="s1">if (insertion) {</span><span class="s3">\n            </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n            </span><span class="s1">// Get the total count of the bytes in the chunk and the insertion</span><span class="s3">\n            </span><span class="s1">// e.g.</span><span class="s3">\n            </span><span class="s1">// chunk = &lt;head&gt;&lt;meta charset=</span><span class="s3">\&quot;</span><span class="s1">utf-8</span><span class="s3">\&quot;</span><span class="s1">&gt;&lt;/head&gt;</span><span class="s3">\n            </span><span class="s1">// insertion = &lt;script&gt;...&lt;/script&gt;</span><span class="s3">\n            </span><span class="s1">// output = &lt;head&gt;&lt;meta charset=</span><span class="s3">\&quot;</span><span class="s1">utf-8</span><span class="s3">\&quot;</span><span class="s1">&gt; [ &lt;script&gt;...&lt;/script&gt; ] &lt;/head&gt;</span><span class="s3">\n            </span><span class="s1">const insertedHeadContent = new Uint8Array(</span><span class="s3">\n              </span><span class="s1">chunk.length + encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">// Append the first part of the chunk, before the head tag</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(chunk.slice(0, index))</span><span class="s3">\n            </span><span class="s1">// Append the server inserted content</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(encodedInsertion, index)</span><span class="s3">\n            </span><span class="s1">// Append the rest of the chunk</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(</span><span class="s3">\n              </span><span class="s1">chunk.slice(index),</span><span class="s3">\n              </span><span class="s1">index + encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">controller.enqueue(insertedHeadContent)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">inserted = true</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// This will happens in PPR rendering during next start, when the page is partially rendered.</span><span class="s3">\n          </span><span class="s1">// When the page resumes, the head tag will be found in the middle of the chunk.</span><span class="s3">\n          </span><span class="s1">// Where we just need to append the insertion and chunk to the current stream.</span><span class="s3">\n          </span><span class="s1">// e.g.</span><span class="s3">\n          </span><span class="s1">// PPR-static: &lt;head&gt;...&lt;/head&gt;&lt;body&gt; [ resume content ] &lt;/body&gt;</span><span class="s3">\n          </span><span class="s1">// PPR-resume: [ insertion ] [ rest content ]</span><span class="s3">\n          </span><span class="s1">if (insertion) {</span><span class="s3">\n            </span><span class="s1">controller.enqueue(encoder.encode(insertion))</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">inserted = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">async flush(controller) {</span><span class="s3">\n      </span><span class="s1">// Check before closing if there's anything remaining to insert.</span><span class="s3">\n      </span><span class="s1">if (hasBytes) {</span><span class="s3">\n        </span><span class="s1">const insertion = await insert()</span><span class="s3">\n        </span><span class="s1">if (insertion) {</span><span class="s3">\n          </span><span class="s1">controller.enqueue(encoder.encode(insertion))</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Suffix after main body content - scripts before &lt;/body&gt;,</span><span class="s3">\n</span><span class="s1">// but wait for the major chunks to be enqueued.</span><span class="s3">\n</span><span class="s1">function createDeferredSuffixStream(</span><span class="s3">\n  </span><span class="s1">suffix: string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let flushed = false</span><span class="s3">\n  </span><span class="s1">let pending: DetachedPromise&lt;void&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const flush = (controller: TransformStreamDefaultController) =&gt; {</span><span class="s3">\n    </span><span class="s1">const detached = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">pending = detached</span><span class="s3">\n\n    </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(encoder.encode(suffix))</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// If an error occurs while enqueuing it can't be due to this</span><span class="s3">\n        </span><span class="s1">// transformers fault. It's likely due to the controller being</span><span class="s3">\n        </span><span class="s1">// errored due to the stream being cancelled.</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">pending = undefined</span><span class="s3">\n        </span><span class="s1">detached.resolve()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n\n      </span><span class="s1">// If we've already flushed, we're done.</span><span class="s3">\n      </span><span class="s1">if (flushed) return</span><span class="s3">\n\n      </span><span class="s1">// Schedule the flush to happen.</span><span class="s3">\n      </span><span class="s1">flushed = true</span><span class="s3">\n      </span><span class="s1">flush(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">if (pending) return pending.promise</span><span class="s3">\n      </span><span class="s1">if (flushed) return</span><span class="s3">\n\n      </span><span class="s1">// Flush now.</span><span class="s3">\n      </span><span class="s1">controller.enqueue(encoder.encode(suffix))</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createFlightDataInjectionTransformStream(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">delayDataUntilFirstHtmlChunk: boolean</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let htmlStreamFinished = false</span><span class="s3">\n\n  </span><span class="s1">let pull: Promise&lt;void&gt; | null = null</span><span class="s3">\n  </span><span class="s1">let donePulling = false</span><span class="s3">\n\n  </span><span class="s1">function startOrContinuePulling(</span><span class="s3">\n    </span><span class="s1">controller: TransformStreamDefaultController</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!pull) {</span><span class="s3">\n      </span><span class="s1">pull = startPulling(controller)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pull</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async function startPulling(controller: TransformStreamDefaultController) {</span><span class="s3">\n    </span><span class="s1">const reader = stream.getReader()</span><span class="s3">\n\n    </span><span class="s1">if (delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n      </span><span class="s1">// NOTE: streaming flush</span><span class="s3">\n      </span><span class="s1">// We are buffering here for the inlined data stream because the</span><span class="s3">\n      </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">shell</span><span class="s3">\&quot; </span><span class="s1">stream might be chunkenized again by the underlying stream</span><span class="s3">\n      </span><span class="s1">// implementation, e.g. with a specific high-water mark. To ensure it's</span><span class="s3">\n      </span><span class="s1">// the safe timing to pipe the data stream, this extra tick is</span><span class="s3">\n      </span><span class="s1">// necessary.</span><span class="s3">\n\n      </span><span class="s1">// We don't start reading until we've left the current Task to ensure</span><span class="s3">\n      </span><span class="s1">// that it's inserted after flushing the shell. Note that this implementation</span><span class="s3">\n      </span><span class="s1">// might get stale if impl details of Fizz change in the future.</span><span class="s3">\n      </span><span class="s1">await atLeastOneTask()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n        </span><span class="s1">if (done) {</span><span class="s3">\n          </span><span class="s1">donePulling = true</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// We want to prioritize HTML over RSC data.</span><span class="s3">\n        </span><span class="s1">// The SSR render is based on the same RSC stream, so when we get a new RSC chunk,</span><span class="s3">\n        </span><span class="s1">// we're likely to produce an HTML chunk as well, so give it a chance to flush first.</span><span class="s3">\n        </span><span class="s1">if (!delayDataUntilFirstHtmlChunk &amp;&amp; !htmlStreamFinished) {</span><span class="s3">\n          </span><span class="s1">await atLeastOneTask()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">controller.enqueue(value)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">controller.error(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">if (!delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n        </span><span class="s1">startOrContinuePulling(controller)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n\n      </span><span class="s1">// Start the streaming if it hasn't already been started yet.</span><span class="s3">\n      </span><span class="s1">if (delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n        </span><span class="s1">startOrContinuePulling(controller)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">htmlStreamFinished = true</span><span class="s3">\n      </span><span class="s1">if (donePulling) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return startOrContinuePulling(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const CLOSE_TAG = '&lt;/body&gt;&lt;/html&gt;'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This transform stream moves the suffix to the end of the stream, so results</span><span class="s3">\n </span><span class="s1">* like `&lt;/body&gt;&lt;/html&gt;&lt;script&gt;...&lt;/script&gt;` will be transformed to</span><span class="s3">\n </span><span class="s1">* `&lt;script&gt;...&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createMoveSuffixStream(): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let foundSuffix = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">if (foundSuffix) {</span><span class="s3">\n        </span><span class="s1">return controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)</span><span class="s3">\n      </span><span class="s1">if (index &gt; -1) {</span><span class="s3">\n        </span><span class="s1">foundSuffix = true</span><span class="s3">\n\n        </span><span class="s1">// If the whole chunk is the suffix, then don't write anything, it will</span><span class="s3">\n        </span><span class="s1">// be written in the flush.</span><span class="s3">\n        </span><span class="s1">if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Write out the part before the suffix.</span><span class="s3">\n        </span><span class="s1">const before = chunk.slice(0, index)</span><span class="s3">\n        </span><span class="s1">controller.enqueue(before)</span><span class="s3">\n\n        </span><span class="s1">// In the case where the suffix is in the middle of the chunk, we need</span><span class="s3">\n        </span><span class="s1">// to split the chunk into two parts.</span><span class="s3">\n        </span><span class="s1">if (chunk.length &gt; ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {</span><span class="s3">\n          </span><span class="s1">// Write out the part after the suffix.</span><span class="s3">\n          </span><span class="s1">const after = chunk.slice(</span><span class="s3">\n            </span><span class="s1">index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">controller.enqueue(after)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">// Even if we didn't find the suffix, the HTML is not valid if we don't</span><span class="s3">\n      </span><span class="s1">// add it, so insert it at the end.</span><span class="s3">\n      </span><span class="s1">controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createStripDocumentClosingTagsTransform(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// We rely on the assumption that chunks will never break across a code unit.</span><span class="s3">\n      </span><span class="s1">// This is reasonable because we currently concat all of React's output from a single</span><span class="s3">\n      </span><span class="s1">// flush into one chunk before streaming it forward which means the chunk will represent</span><span class="s3">\n      </span><span class="s1">// a single coherent utf-8 string. This is not safe to use if we change our streaming to no</span><span class="s3">\n      </span><span class="s1">// longer do this large buffered chunk</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// the entire chunk is the closing tags; return without enqueueing anything.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We assume these tags will go at together at the end of the document and that</span><span class="s3">\n      </span><span class="s1">// they won't appear anywhere else in the document. This is not really a safe assumption</span><span class="s3">\n      </span><span class="s1">// but until we revamp our streaming infra this is a performant way to string the tags</span><span class="s3">\n      </span><span class="s1">chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)</span><span class="s3">\n      </span><span class="s1">chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Checks if the root layout is missing the html or body tags</span><span class="s3">\n </span><span class="s1">* and if so, it will inject a script tag to throw an error in the browser, showing the user</span><span class="s3">\n </span><span class="s1">* the error message in the error overlay.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createRootLayoutValidatorStream(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">let foundHtml = false</span><span class="s3">\n  </span><span class="s1">let foundBody = false</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// Peek into the streamed chunk to see if the tags are present.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!foundHtml &amp;&amp;</span><span class="s3">\n        </span><span class="s1">indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) &gt; -1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">foundHtml = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!foundBody &amp;&amp;</span><span class="s3">\n        </span><span class="s1">indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) &gt; -1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">foundBody = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">const missingTags: ('html' | 'body')[] = []</span><span class="s3">\n      </span><span class="s1">if (!foundHtml) missingTags.push('html')</span><span class="s3">\n      </span><span class="s1">if (!foundBody) missingTags.push('body')</span><span class="s3">\n\n      </span><span class="s1">if (!missingTags.length) return</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(</span><span class="s3">\n        </span><span class="s1">encoder.encode(</span><span class="s3">\n          </span><span class="s1">`&lt;html id=</span><span class="s3">\&quot;</span><span class="s1">__next_error__</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\n            </span><span class="s1">&lt;template</span><span class="s3">\n              </span><span class="s1">data-next-error-message=</span><span class="s3">\&quot;</span><span class="s1">Missing ${missingTags</span><span class="s3">\n                </span><span class="s1">.map((c) =&gt; `&lt;${c}&gt;`)</span><span class="s3">\n                </span><span class="s1">.join(</span><span class="s3">\n                  </span><span class="s1">missingTags.length &gt; 1 ? ' and ' : ''</span><span class="s3">\n                </span><span class="s1">)} tags in the root layout.</span><span class="s3">\\</span><span class="s1">nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags</span><span class="s3">\&quot;\n              </span><span class="s1">data-next-error-digest=</span><span class="s3">\&quot;</span><span class="s1">${MISSING_ROOT_TAGS_ERROR}</span><span class="s3">\&quot;\n              </span><span class="s1">data-next-error-stack=</span><span class="s3">\&quot;\&quot;\n            </span><span class="s1">&gt;&lt;/template&gt;</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function chainTransformers&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">readable: ReadableStream&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">transformers: ReadonlyArray&lt;TransformStream&lt;T, T&gt; | null&gt;</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">let stream = readable</span><span class="s3">\n  </span><span class="s1">for (const transformer of transformers) {</span><span class="s3">\n    </span><span class="s1">if (!transformer) continue</span><span class="s3">\n\n    </span><span class="s1">stream = stream.pipeThrough(transformer)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return stream</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ContinueStreamOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt; | undefined</span><span class="s3">\n  </span><span class="s1">isStaticGeneration: boolean</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">validateRootLayout?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Suffix to inject after the buffered data, but before the close tags.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">suffix?: string | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueFizzStream(</span><span class="s3">\n  </span><span class="s1">renderStream: ReactDOMServerReadableStream,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">suffix,</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">isStaticGeneration,</span><span class="s3">\n    </span><span class="s1">isBuildTimePrerendering,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n    </span><span class="s1">validateRootLayout,</span><span class="s3">\n  </span><span class="s1">}: ContinueStreamOptions</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadableStream&lt;Uint8Array&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">// Suffix itself might contain close tags at the end, so we need to split it.</span><span class="s3">\n  </span><span class="s1">const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null</span><span class="s3">\n\n  </span><span class="s1">// If we're generating static HTML we need to wait for it to resolve before continuing.</span><span class="s3">\n  </span><span class="s1">if (isStaticGeneration) {</span><span class="s3">\n    </span><span class="s1">await renderStream.allReady</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return chainTransformers(renderStream, [</span><span class="s3">\n    </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n    </span><span class="s1">createBufferedTransformStream(),</span><span class="s3">\n\n    </span><span class="s1">// Add build id comment to start of the HTML document (in export mode)</span><span class="s3">\n    </span><span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId),</span><span class="s3">\n\n    </span><span class="s1">// Transform metadata</span><span class="s3">\n    </span><span class="s1">createMetadataTransformStream(getServerInsertedMetadata),</span><span class="s3">\n\n    </span><span class="s1">// Insert suffix content</span><span class="s3">\n    </span><span class="s1">suffixUnclosed != null &amp;&amp; suffixUnclosed.length &gt; 0</span><span class="s3">\n      </span><span class="s1">? createDeferredSuffixStream(suffixUnclosed)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n\n    </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n    </span><span class="s1">inlinedDataStream</span><span class="s3">\n      </span><span class="s1">? createFlightDataInjectionTransformStream(inlinedDataStream, true)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n\n    </span><span class="s1">// Validate the root layout for missing html or body tags</span><span class="s3">\n    </span><span class="s1">validateRootLayout ? createRootLayoutValidatorStream() : null,</span><span class="s3">\n\n    </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n    </span><span class="s1">createMoveSuffixStream(),</span><span class="s3">\n\n    </span><span class="s1">// Special head insertions</span><span class="s3">\n    </span><span class="s1">// TODO-APP: Insert server side html to end of head in app layout rendering, to avoid</span><span class="s3">\n    </span><span class="s1">// hydration errors. Remove this once it's ready to be handled by react itself.</span><span class="s3">\n    </span><span class="s1">createHeadInsertionTransformStream(getServerInsertedHTML),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueDynamicPrerenderOptions = {</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueDynamicPrerender(</span><span class="s3">\n  </span><span class="s1">prerenderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n  </span><span class="s1">}: ContinueDynamicPrerenderOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prerenderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createStripDocumentClosingTagsTransform())</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueStaticPrerenderOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueStaticPrerender(</span><span class="s3">\n  </span><span class="s1">prerenderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n    </span><span class="s1">isBuildTimePrerendering,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n  </span><span class="s1">}: ContinueStaticPrerenderOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prerenderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">// Add build id comment to start of the HTML document (in export mode)</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n      </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createFlightDataInjectionTransformStream(inlinedDataStream, true)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMoveSuffixStream())</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueResumeOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">delayDataUntilFirstHtmlChunk: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueDynamicHTMLResume(</span><span class="s3">\n  </span><span class="s1">renderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">delayDataUntilFirstHtmlChunk,</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n  </span><span class="s1">}: ContinueResumeOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">renderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n      </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createFlightDataInjectionTransformStream(</span><span class="s3">\n          </span><span class="s1">inlinedDataStream,</span><span class="s3">\n          </span><span class="s1">delayDataUntilFirstHtmlChunk</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMoveSuffixStream())</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createDocumentClosingStream(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return streamFromString(CLOSE_TAG)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const ENCODED_TAGS = {</span><span class="s3">\n  </span><span class="s1">// opening tags do not have the closing `&gt;` since they can contain other attributes such as `&lt;body className=''&gt;`</span><span class="s3">\n  </span><span class="s1">OPENING: {</span><span class="s3">\n    </span><span class="s1">// &lt;html</span><span class="s3">\n    </span><span class="s1">HTML: new Uint8Array([60, 104, 116, 109, 108]),</span><span class="s3">\n    </span><span class="s1">// &lt;body</span><span class="s3">\n    </span><span class="s1">BODY: new Uint8Array([60, 98, 111, 100, 121]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">CLOSED: {</span><span class="s3">\n    </span><span class="s1">// &lt;/head&gt;</span><span class="s3">\n    </span><span class="s1">HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/body&gt;</span><span class="s3">\n    </span><span class="s1">BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/html&gt;</span><span class="s3">\n    </span><span class="s1">HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/body&gt;&lt;/html&gt;</span><span class="s3">\n    </span><span class="s1">BODY_AND_HTML: new Uint8Array([</span><span class="s3">\n      </span><span class="s1">60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">META: {</span><span class="s3">\n    </span><span class="s1">// Only the match the prefix cause the suffix can be different wether it's xml compatible or not </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">/&gt;</span><span class="s3">\&quot;\n    </span><span class="s1">// &lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">nxt-icon</span><span class="s3">\&quot;\n    </span><span class="s1">// This is a special mark that will be replaced by the icon insertion script tag.</span><span class="s3">\n    </span><span class="s1">ICON_MARK: new Uint8Array([</span><span class="s3">\n      </span><span class="s1">60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,</span><span class="s3">\n      </span><span class="s1">116, 45, 105, 99, 111, 110, 194, 187, 34,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds the provided prefix to the given path. It first ensures that the path</span><span class="s3">\n </span><span class="s1">* is indeed starting with a slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addPathPrefix(path: string, prefix?: string) {</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/') || !prefix) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname, query, hash } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return `${prefix}${pathname}${query}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Similarly to `addPathPrefix`, this function adds a suffix at the end on the</span><span class="s3">\n </span><span class="s1">* provided path. It also works only for paths ensuring the argument starts</span><span class="s3">\n </span><span class="s1">* with a slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addPathSuffix(path: string, suffix?: string) {</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/') || !suffix) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname, query, hash } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return `${pathname}${suffix}${query}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type { DomainLocale, I18NConfig } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../lib/i18n-provider'</span><span class="s3">\n\n</span><span class="s1">import { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale'</span><span class="s3">\n</span><span class="s1">import { formatNextPathnameInfo } from '../../shared/lib/router/utils/format-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import { getNextPathnameInfo } from '../../shared/lib/router/utils/get-next-pathname-info'</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">base?: string | URL</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">forceLocale?: boolean</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: I18NConfig | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">i18nProvider?: I18NProvider</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const REGEX_LOCALHOST_HOSTNAME =</span><span class="s3">\n  </span><span class="s1">/(?!^https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/)(127(?:</span><span class="s3">\\</span><span class="s1">.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|</span><span class="s3">\\</span><span class="s1">[::1</span><span class="s3">\\</span><span class="s1">]|localhost)/</span><span class="s3">\n\n</span><span class="s1">function parseURL(url: string | URL, base?: string | URL) {</span><span class="s3">\n  </span><span class="s1">return new URL(</span><span class="s3">\n    </span><span class="s1">String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'),</span><span class="s3">\n    </span><span class="s1">base &amp;&amp; String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const Internal = Symbol('NextURLInternal')</span><span class="s3">\n\n</span><span class="s1">export class NextURL {</span><span class="s3">\n  </span><span class="s1">private [Internal]: {</span><span class="s3">\n    </span><span class="s1">basePath: string</span><span class="s3">\n    </span><span class="s1">buildId?: string</span><span class="s3">\n    </span><span class="s1">flightSearchParameters?: Record&lt;string, string&gt;</span><span class="s3">\n    </span><span class="s1">defaultLocale?: string</span><span class="s3">\n    </span><span class="s1">domainLocale?: DomainLocale</span><span class="s3">\n    </span><span class="s1">locale?: string</span><span class="s3">\n    </span><span class="s1">options: Options</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n    </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(input: string | URL, base?: string | URL, opts?: Options)</span><span class="s3">\n  </span><span class="s1">constructor(input: string | URL, opts?: Options)</span><span class="s3">\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">input: string | URL,</span><span class="s3">\n    </span><span class="s1">baseOrOpts?: string | URL | Options,</span><span class="s3">\n    </span><span class="s1">opts?: Options</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let base: undefined | string | URL</span><span class="s3">\n    </span><span class="s1">let options: Options</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(typeof baseOrOpts === 'object' &amp;&amp; 'pathname' in baseOrOpts) ||</span><span class="s3">\n      </span><span class="s1">typeof baseOrOpts === 'string'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">base = baseOrOpts</span><span class="s3">\n      </span><span class="s1">options = opts || {}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">options = opts || baseOrOpts || {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[Internal] = {</span><span class="s3">\n      </span><span class="s1">url: parseURL(input, base ?? options.base),</span><span class="s3">\n      </span><span class="s1">options: options,</span><span class="s3">\n      </span><span class="s1">basePath: '',</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.analyze()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private analyze() {</span><span class="s3">\n    </span><span class="s1">const info = getNextPathnameInfo(this[Internal].url.pathname, {</span><span class="s3">\n      </span><span class="s1">nextConfig: this[Internal].options.nextConfig,</span><span class="s3">\n      </span><span class="s1">parseData: !process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE,</span><span class="s3">\n      </span><span class="s1">i18nProvider: this[Internal].options.i18nProvider,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const hostname = getHostname(</span><span class="s3">\n      </span><span class="s1">this[Internal].url,</span><span class="s3">\n      </span><span class="s1">this[Internal].options.headers</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this[Internal].domainLocale = this[Internal].options.i18nProvider</span><span class="s3">\n      </span><span class="s1">? this[Internal].options.i18nProvider.detectDomainLocale(hostname)</span><span class="s3">\n      </span><span class="s1">: detectDomainLocale(</span><span class="s3">\n          </span><span class="s1">this[Internal].options.nextConfig?.i18n?.domains,</span><span class="s3">\n          </span><span class="s1">hostname</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const defaultLocale =</span><span class="s3">\n      </span><span class="s1">this[Internal].domainLocale?.defaultLocale ||</span><span class="s3">\n      </span><span class="s1">this[Internal].options.nextConfig?.i18n?.defaultLocale</span><span class="s3">\n\n    </span><span class="s1">this[Internal].url.pathname = info.pathname</span><span class="s3">\n    </span><span class="s1">this[Internal].defaultLocale = defaultLocale</span><span class="s3">\n    </span><span class="s1">this[Internal].basePath = info.basePath ?? ''</span><span class="s3">\n    </span><span class="s1">this[Internal].buildId = info.buildId</span><span class="s3">\n    </span><span class="s1">this[Internal].locale = info.locale ?? defaultLocale</span><span class="s3">\n    </span><span class="s1">this[Internal].trailingSlash = info.trailingSlash</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private formatPathname() {</span><span class="s3">\n    </span><span class="s1">return formatNextPathnameInfo({</span><span class="s3">\n      </span><span class="s1">basePath: this[Internal].basePath,</span><span class="s3">\n      </span><span class="s1">buildId: this[Internal].buildId,</span><span class="s3">\n      </span><span class="s1">defaultLocale: !this[Internal].options.forceLocale</span><span class="s3">\n        </span><span class="s1">? this[Internal].defaultLocale</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">locale: this[Internal].locale,</span><span class="s3">\n      </span><span class="s1">pathname: this[Internal].url.pathname,</span><span class="s3">\n      </span><span class="s1">trailingSlash: this[Internal].trailingSlash,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private formatSearch() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get buildId() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].buildId</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set buildId(buildId: string | undefined) {</span><span class="s3">\n    </span><span class="s1">this[Internal].buildId = buildId</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get locale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].locale ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set locale(locale: string) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this[Internal].locale ||</span><span class="s3">\n      </span><span class="s1">!this[Internal].options.nextConfig?.i18n?.locales.includes(locale)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(</span><span class="s3">\n        </span><span class="s1">`The NextURL configuration includes no locale </span><span class="s3">\&quot;</span><span class="s1">${locale}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[Internal].locale = locale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get defaultLocale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].defaultLocale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get domainLocale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].domainLocale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get searchParams() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.searchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get host() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.host</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set host(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.host = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get hostname() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.hostname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set hostname(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.hostname = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get port() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.port</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set port(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.port = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get protocol() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.protocol</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set protocol(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.protocol = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get href() {</span><span class="s3">\n    </span><span class="s1">const pathname = this.formatPathname()</span><span class="s3">\n    </span><span class="s1">const search = this.formatSearch()</span><span class="s3">\n    </span><span class="s1">return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set href(url: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url = parseURL(url)</span><span class="s3">\n    </span><span class="s1">this.analyze()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get origin() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.origin</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get pathname() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set pathname(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.pathname = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get hash() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.hash</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set hash(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.hash = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get search() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set search(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.search = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get password() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.password</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set password(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.password = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get username() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.username</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set username(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.username = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get basePath() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].basePath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set basePath(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].basePath = value.startsWith('/') ? value : `/${value}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return this.href</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toJSON() {</span><span class="s3">\n    </span><span class="s1">return this.href</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.for('edge-runtime.inspect.custom')]() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">href: this.href,</span><span class="s3">\n      </span><span class="s1">origin: this.origin,</span><span class="s3">\n      </span><span class="s1">protocol: this.protocol,</span><span class="s3">\n      </span><span class="s1">username: this.username,</span><span class="s3">\n      </span><span class="s1">password: this.password,</span><span class="s3">\n      </span><span class="s1">host: this.host,</span><span class="s3">\n      </span><span class="s1">hostname: this.hostname,</span><span class="s3">\n      </span><span class="s1">port: this.port,</span><span class="s3">\n      </span><span class="s1">pathname: this.pathname,</span><span class="s3">\n      </span><span class="s1">search: this.search,</span><span class="s3">\n      </span><span class="s1">searchParams: this.searchParams,</span><span class="s3">\n      </span><span class="s1">hash: this.hash,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">clone() {</span><span class="s3">\n    </span><span class="s1">return new NextURL(String(this), this[Internal].options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizeLocalePath } from '../../i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from './remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../../../../server/lib/i18n-provider'</span><span class="s3">\n\n</span><span class="s1">export interface NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The base path in case the pathname included it.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">basePath?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The buildId for when the parsed URL is a data URL. Parsing it can be</span><span class="s3">\n   </span><span class="s1">* disabled with the `parseData` option.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">buildId?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If there was a locale in the pathname, this will hold its value.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The processed pathname without a base path, locale, or data URL elements</span><span class="s3">\n   </span><span class="s1">* when parsing it is enabled.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A boolean telling if the pathname had a trailingSlash. This can be only</span><span class="s3">\n   </span><span class="s1">* true if trailingSlash is enabled.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When passed to true, this function will also parse Nextjs data URLs.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">parseData?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A partial of the Next.js configuration to parse the URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: { locales?: readonly string[] } | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If provided, this normalizer will be used to detect the locale instead of</span><span class="s3">\n   </span><span class="s1">* the default locale detection.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">i18nProvider?: I18NProvider</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getNextPathnameInfo(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">options: Options</span><span class="s3">\n</span><span class="s1">): NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">const { basePath, i18n, trailingSlash } = options.nextConfig ?? {}</span><span class="s3">\n  </span><span class="s1">const info: NextPathnameInfo = {</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (basePath &amp;&amp; pathHasPrefix(info.pathname, basePath)) {</span><span class="s3">\n    </span><span class="s1">info.pathname = removePathPrefix(info.pathname, basePath)</span><span class="s3">\n    </span><span class="s1">info.basePath = basePath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let pathnameNoDataPrefix = info.pathname</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">info.pathname.startsWith('/_next/data/') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">info.pathname.endsWith('.json')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const paths = info.pathname</span><span class="s3">\n      </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">/data</span><span class="s3">\\</span><span class="s1">//, '')</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">.json$/, '')</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n\n    </span><span class="s1">const buildId = paths[0]</span><span class="s3">\n    </span><span class="s1">info.buildId = buildId</span><span class="s3">\n    </span><span class="s1">pathnameNoDataPrefix =</span><span class="s3">\n      </span><span class="s1">paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/'</span><span class="s3">\n\n    </span><span class="s1">// update pathname with normalized if enabled although</span><span class="s3">\n    </span><span class="s1">// we use normalized to populate locale info still</span><span class="s3">\n    </span><span class="s1">if (options.parseData === true) {</span><span class="s3">\n      </span><span class="s1">info.pathname = pathnameNoDataPrefix</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If provided, use the locale route normalizer to detect the locale instead</span><span class="s3">\n  </span><span class="s1">// of the function below.</span><span class="s3">\n  </span><span class="s1">if (i18n) {</span><span class="s3">\n    </span><span class="s1">let result = options.i18nProvider</span><span class="s3">\n      </span><span class="s1">? options.i18nProvider.analyze(info.pathname)</span><span class="s3">\n      </span><span class="s1">: normalizeLocalePath(info.pathname, i18n.locales)</span><span class="s3">\n\n    </span><span class="s1">info.locale = result.detectedLocale</span><span class="s3">\n    </span><span class="s1">info.pathname = result.pathname ?? info.pathname</span><span class="s3">\n\n    </span><span class="s1">if (!result.detectedLocale &amp;&amp; info.buildId) {</span><span class="s3">\n      </span><span class="s1">result = options.i18nProvider</span><span class="s3">\n        </span><span class="s1">? options.i18nProvider.analyze(pathnameNoDataPrefix)</span><span class="s3">\n        </span><span class="s1">: normalizeLocalePath(pathnameNoDataPrefix, i18n.locales)</span><span class="s3">\n\n      </span><span class="s1">if (result.detectedLocale) {</span><span class="s3">\n        </span><span class="s1">info.locale = result.detectedLocale</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return info</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextPathnameInfo } from './get-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from './remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { addPathPrefix } from './add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { addPathSuffix } from './add-path-suffix'</span><span class="s3">\n</span><span class="s1">import { addLocale } from './add-locale'</span><span class="s3">\n\n</span><span class="s1">interface ExtendedInfo extends NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">ignorePrefix?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function formatNextPathnameInfo(info: ExtendedInfo) {</span><span class="s3">\n  </span><span class="s1">let pathname = addLocale(</span><span class="s3">\n    </span><span class="s1">info.pathname,</span><span class="s3">\n    </span><span class="s1">info.locale,</span><span class="s3">\n    </span><span class="s1">info.buildId ? undefined : info.defaultLocale,</span><span class="s3">\n    </span><span class="s1">info.ignorePrefix</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (info.buildId || !info.trailingSlash) {</span><span class="s3">\n    </span><span class="s1">pathname = removeTrailingSlash(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (info.buildId) {</span><span class="s3">\n    </span><span class="s1">pathname = addPathSuffix(</span><span class="s3">\n      </span><span class="s1">addPathPrefix(pathname, `/_next/data/${info.buildId}`),</span><span class="s3">\n      </span><span class="s1">info.pathname === '/' ? 'index.json' : '.json'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">pathname = addPathPrefix(pathname, info.basePath)</span><span class="s3">\n  </span><span class="s1">return !info.buildId &amp;&amp; info.trailingSlash</span><span class="s3">\n    </span><span class="s1">? !pathname.endsWith('/')</span><span class="s3">\n      </span><span class="s1">? addPathSuffix(pathname, '/')</span><span class="s3">\n      </span><span class="s1">: pathname</span><span class="s3">\n    </span><span class="s1">: removeTrailingSlash(pathname)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { addPathPrefix } from './add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* For a given path and a locale, if the locale is given, it will prefix the</span><span class="s3">\n </span><span class="s1">* locale. The path shouldn't be an API path. If a default locale is given the</span><span class="s3">\n </span><span class="s1">* prefix will be omitted if the locale is already the default locale.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addLocale(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">locale?: string | false,</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string,</span><span class="s3">\n  </span><span class="s1">ignorePrefix?: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// If no locale was given or the locale is the default locale, we don't need</span><span class="s3">\n  </span><span class="s1">// to prefix the path.</span><span class="s3">\n  </span><span class="s1">if (!locale || locale === defaultLocale) return path</span><span class="s3">\n\n  </span><span class="s1">const lower = path.toLowerCase()</span><span class="s3">\n\n  </span><span class="s1">// If the path is an API path or the path already has the locale prefix, we</span><span class="s3">\n  </span><span class="s1">// don't need to prefix the path.</span><span class="s3">\n  </span><span class="s1">if (!ignorePrefix) {</span><span class="s3">\n    </span><span class="s1">if (pathHasPrefix(lower, '/api')) return path</span><span class="s3">\n    </span><span class="s1">if (pathHasPrefix(lower, `/${locale.toLowerCase()}`)) return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Add the locale prefix to the path.</span><span class="s3">\n  </span><span class="s1">return addPathPrefix(path, `/${locale}`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { I18NConfig } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import { NextURL } from '../next-url'</span><span class="s3">\n</span><span class="s1">import { toNodeOutgoingHttpHeaders, validateURL } from '../utils'</span><span class="s3">\n</span><span class="s1">import { RemovedUAError, RemovedPageError } from '../error'</span><span class="s3">\n</span><span class="s1">import { RequestCookies } from './cookies'</span><span class="s3">\n\n</span><span class="s1">export const INTERNALS = Symbol('internal request')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This class extends the [Web `Request` API](https://developer.mozilla.org/docs/Web/API/Request) with additional convenience methods.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `NextRequest`](https://nextjs.org/docs/app/api-reference/functions/next-request)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class NextRequest extends Request {</span><span class="s3">\n  </span><span class="s1">/** @internal */</span><span class="s3">\n  </span><span class="s1">[INTERNALS]: {</span><span class="s3">\n    </span><span class="s1">cookies: RequestCookies</span><span class="s3">\n    </span><span class="s1">url: string</span><span class="s3">\n    </span><span class="s1">nextUrl: NextURL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(input: URL | RequestInfo, init: RequestInit = {}) {</span><span class="s3">\n    </span><span class="s1">const url =</span><span class="s3">\n      </span><span class="s1">typeof input !== 'string' &amp;&amp; 'url' in input ? input.url : String(input)</span><span class="s3">\n\n    </span><span class="s1">validateURL(url)</span><span class="s3">\n\n    </span><span class="s1">// node Request instance requires duplex option when a body</span><span class="s3">\n    </span><span class="s1">// is present or it errors, we don't handle this for</span><span class="s3">\n    </span><span class="s1">// Request being passed in since it would have already</span><span class="s3">\n    </span><span class="s1">// errored if this wasn't configured</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">if (init.body &amp;&amp; init.duplex !== 'half') {</span><span class="s3">\n        </span><span class="s1">init.duplex = 'half'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (input instanceof Request) super(input, init)</span><span class="s3">\n    </span><span class="s1">else super(url, init)</span><span class="s3">\n\n    </span><span class="s1">const nextUrl = new NextURL(url, {</span><span class="s3">\n      </span><span class="s1">headers: toNodeOutgoingHttpHeaders(this.headers),</span><span class="s3">\n      </span><span class="s1">nextConfig: init.nextConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">this[INTERNALS] = {</span><span class="s3">\n      </span><span class="s1">cookies: new RequestCookies(this.headers),</span><span class="s3">\n      </span><span class="s1">nextUrl,</span><span class="s3">\n      </span><span class="s1">url: process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE</span><span class="s3">\n        </span><span class="s1">? url</span><span class="s3">\n        </span><span class="s1">: nextUrl.toString(),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.for('edge-runtime.inspect.custom')]() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">cookies: this.cookies,</span><span class="s3">\n      </span><span class="s1">nextUrl: this.nextUrl,</span><span class="s3">\n      </span><span class="s1">url: this.url,</span><span class="s3">\n      </span><span class="s1">// rest of props come from Request</span><span class="s3">\n      </span><span class="s1">bodyUsed: this.bodyUsed,</span><span class="s3">\n      </span><span class="s1">cache: this.cache,</span><span class="s3">\n      </span><span class="s1">credentials: this.credentials,</span><span class="s3">\n      </span><span class="s1">destination: this.destination,</span><span class="s3">\n      </span><span class="s1">headers: Object.fromEntries(this.headers),</span><span class="s3">\n      </span><span class="s1">integrity: this.integrity,</span><span class="s3">\n      </span><span class="s1">keepalive: this.keepalive,</span><span class="s3">\n      </span><span class="s1">method: this.method,</span><span class="s3">\n      </span><span class="s1">mode: this.mode,</span><span class="s3">\n      </span><span class="s1">redirect: this.redirect,</span><span class="s3">\n      </span><span class="s1">referrer: this.referrer,</span><span class="s3">\n      </span><span class="s1">referrerPolicy: this.referrerPolicy,</span><span class="s3">\n      </span><span class="s1">signal: this.signal,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get cookies() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].cookies</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get nextUrl() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">* `page` has been deprecated in favour of `URLPattern`.</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-request-page</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get page() {</span><span class="s3">\n    </span><span class="s1">throw new RemovedPageError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">* `ua` has been removed in favour of </span><span class="s3">\\</span><span class="s1">`userAgent</span><span class="s3">\\</span><span class="s1">` function.</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get ua() {</span><span class="s3">\n    </span><span class="s1">throw new RemovedUAError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get url() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RequestInit extends globalThis.RequestInit {</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: I18NConfig | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n  </span><span class="s1">// see https://github.com/whatwg/fetch/pull/1457</span><span class="s3">\n  </span><span class="s1">duplex?: 'half'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { BaseNextRequest } from '../../../base-http'</span><span class="s3">\n</span><span class="s1">import type { NodeNextRequest } from '../../../base-http/node'</span><span class="s3">\n</span><span class="s1">import type { WebNextRequest } from '../../../base-http/web'</span><span class="s3">\n</span><span class="s1">import type { Writable } from 'node:stream'</span><span class="s3">\n\n</span><span class="s1">import { getRequestMeta } from '../../../request-meta'</span><span class="s3">\n</span><span class="s1">import { fromNodeOutgoingHttpHeaders } from '../../utils'</span><span class="s3">\n</span><span class="s1">import { NextRequest } from '../request'</span><span class="s3">\n</span><span class="s1">import { isNodeNextRequest, isWebNextRequest } from '../../../base-http/helpers'</span><span class="s3">\n\n</span><span class="s1">export const ResponseAbortedName = 'ResponseAborted'</span><span class="s3">\n</span><span class="s1">export class ResponseAborted extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly name = ResponseAbortedName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an AbortController tied to the closing of a ServerResponse (or other</span><span class="s3">\n </span><span class="s1">* appropriate Writable).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the `close` event is fired before the `finish` event, then we'll send the</span><span class="s3">\n </span><span class="s1">* `abort` signal.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createAbortController(response: Writable): AbortController {</span><span class="s3">\n  </span><span class="s1">const controller = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">// If `finish` fires first, then `res.end()` has been called and the close is</span><span class="s3">\n  </span><span class="s1">// just us finishing the stream on our side. If `close` fires first, then we</span><span class="s3">\n  </span><span class="s1">// know the client disconnected before we finished.</span><span class="s3">\n  </span><span class="s1">response.once('close', () =&gt; {</span><span class="s3">\n    </span><span class="s1">if (response.writableFinished) return</span><span class="s3">\n\n    </span><span class="s1">controller.abort(new ResponseAborted())</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return controller</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an AbortSignal tied to the closing of a ServerResponse (or other</span><span class="s3">\n </span><span class="s1">* appropriate Writable).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This cannot be done with the request (IncomingMessage or Readable) because</span><span class="s3">\n </span><span class="s1">* the `abort` event will not fire if to data has been fully read (because that</span><span class="s3">\n </span><span class="s1">* will </span><span class="s3">\&quot;</span><span class="s1">close</span><span class="s3">\&quot; </span><span class="s1">the readable stream and nothing fires after that).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function signalFromNodeResponse(response: Writable): AbortSignal {</span><span class="s3">\n  </span><span class="s1">const { errored, destroyed } = response</span><span class="s3">\n  </span><span class="s1">if (errored || destroyed) {</span><span class="s3">\n    </span><span class="s1">return AbortSignal.abort(errored ?? new ResponseAborted())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { signal } = createAbortController(response)</span><span class="s3">\n  </span><span class="s1">return signal</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class NextRequestAdapter {</span><span class="s3">\n  </span><span class="s1">public static fromBaseNextRequest(</span><span class="s3">\n    </span><span class="s1">request: BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal</span><span class="s3">\n  </span><span class="s1">): NextRequest {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME === 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isWebNextRequest(request)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return NextRequestAdapter.fromWebNextRequest(request)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isNodeNextRequest(request)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return NextRequestAdapter.fromNodeNextRequest(request, signal)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: Unsupported NextRequest type')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static fromNodeNextRequest(</span><span class="s3">\n    </span><span class="s1">request: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal</span><span class="s3">\n  </span><span class="s1">): NextRequest {</span><span class="s3">\n    </span><span class="s1">// HEAD and GET requests can not have a body.</span><span class="s3">\n    </span><span class="s1">let body: BodyInit | null = null</span><span class="s3">\n    </span><span class="s1">if (request.method !== 'GET' &amp;&amp; request.method !== 'HEAD' &amp;&amp; request.body) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error - this is handled by undici, when streams/web land use it instead</span><span class="s3">\n      </span><span class="s1">body = request.body</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let url: URL</span><span class="s3">\n    </span><span class="s1">if (request.url.startsWith('http')) {</span><span class="s3">\n      </span><span class="s1">url = new URL(request.url)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Grab the full URL from the request metadata.</span><span class="s3">\n      </span><span class="s1">const base = getRequestMeta(request, 'initURL')</span><span class="s3">\n      </span><span class="s1">if (!base || !base.startsWith('http')) {</span><span class="s3">\n        </span><span class="s1">// Because the URL construction relies on the fact that the URL provided</span><span class="s3">\n        </span><span class="s1">// is absolute, we need to provide a base URL. We can't use the request</span><span class="s3">\n        </span><span class="s1">// URL because it's relative, so we use a dummy URL instead.</span><span class="s3">\n        </span><span class="s1">url = new URL(request.url, 'http://n')</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">url = new URL(request.url, base)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new NextRequest(url, {</span><span class="s3">\n      </span><span class="s1">method: request.method,</span><span class="s3">\n      </span><span class="s1">headers: fromNodeOutgoingHttpHeaders(request.headers),</span><span class="s3">\n      </span><span class="s1">duplex: 'half',</span><span class="s3">\n      </span><span class="s1">signal,</span><span class="s3">\n      </span><span class="s1">// geo</span><span class="s3">\n      </span><span class="s1">// ip</span><span class="s3">\n      </span><span class="s1">// nextConfig</span><span class="s3">\n\n      </span><span class="s1">// body can not be passed if request was aborted</span><span class="s3">\n      </span><span class="s1">// or we get a Request body was disturbed error</span><span class="s3">\n      </span><span class="s1">...(signal.aborted</span><span class="s3">\n        </span><span class="s1">? {}</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">body,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static fromWebNextRequest(request: WebNextRequest): NextRequest {</span><span class="s3">\n    </span><span class="s1">// HEAD and GET requests can not have a body.</span><span class="s3">\n    </span><span class="s1">let body: ReadableStream | null = null</span><span class="s3">\n    </span><span class="s1">if (request.method !== 'GET' &amp;&amp; request.method !== 'HEAD') {</span><span class="s3">\n      </span><span class="s1">body = request.body</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new NextRequest(request.url, {</span><span class="s3">\n      </span><span class="s1">method: request.method,</span><span class="s3">\n      </span><span class="s1">headers: fromNodeOutgoingHttpHeaders(request.headers),</span><span class="s3">\n      </span><span class="s1">duplex: 'half',</span><span class="s3">\n      </span><span class="s1">signal: request.request.signal,</span><span class="s3">\n      </span><span class="s1">// geo</span><span class="s3">\n      </span><span class="s1">// ip</span><span class="s3">\n      </span><span class="s1">// nextConfig</span><span class="s3">\n\n      </span><span class="s1">// body can not be passed if request was aborted</span><span class="s3">\n      </span><span class="s1">// or we get a Request body was disturbed error</span><span class="s3">\n      </span><span class="s1">...(request.request.signal.aborted</span><span class="s3">\n        </span><span class="s1">? {}</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">body,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AppPageModule } from './route-modules/app-page/module'</span><span class="s3">\n\n</span><span class="s1">// Combined load times for loading client components</span><span class="s3">\n</span><span class="s1">let clientComponentLoadStart = 0</span><span class="s3">\n</span><span class="s1">let clientComponentLoadTimes = 0</span><span class="s3">\n</span><span class="s1">let clientComponentLoadCount = 0</span><span class="s3">\n\n</span><span class="s1">export function wrapClientComponentLoader(</span><span class="s3">\n  </span><span class="s1">ComponentMod: AppPageModule</span><span class="s3">\n</span><span class="s1">): AppPageModule['__next_app__'] {</span><span class="s3">\n  </span><span class="s1">if (!('performance' in globalThis)) {</span><span class="s3">\n    </span><span class="s1">return ComponentMod.__next_app__</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">require: (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const startTime = performance.now()</span><span class="s3">\n\n      </span><span class="s1">if (clientComponentLoadStart === 0) {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadStart = startTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadCount += 1</span><span class="s3">\n        </span><span class="s1">return ComponentMod.__next_app__.require(...args)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadTimes += performance.now() - startTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">loadChunk: (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const startTime = performance.now()</span><span class="s3">\n      </span><span class="s1">const result = ComponentMod.__next_app__.loadChunk(...args)</span><span class="s3">\n      </span><span class="s1">// Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.</span><span class="s3">\n      </span><span class="s1">// We only need to know when it's settled.</span><span class="s3">\n      </span><span class="s1">result.finally(() =&gt; {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadTimes += performance.now() - startTime</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">return result</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getClientComponentLoaderMetrics(</span><span class="s3">\n  </span><span class="s1">options: { reset?: boolean } = {}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const metrics =</span><span class="s3">\n    </span><span class="s1">clientComponentLoadStart === 0</span><span class="s3">\n      </span><span class="s1">? undefined</span><span class="s3">\n      </span><span class="s1">: {</span><span class="s3">\n          </span><span class="s1">clientComponentLoadStart,</span><span class="s3">\n          </span><span class="s1">clientComponentLoadTimes,</span><span class="s3">\n          </span><span class="s1">clientComponentLoadCount,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (options.reset) {</span><span class="s3">\n    </span><span class="s1">clientComponentLoadStart = 0</span><span class="s3">\n    </span><span class="s1">clientComponentLoadTimes = 0</span><span class="s3">\n    </span><span class="s1">clientComponentLoadCount = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return metrics</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ServerResponse } from 'node:http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ResponseAbortedName,</span><span class="s3">\n  </span><span class="s1">createAbortController,</span><span class="s3">\n</span><span class="s1">} from './web/spec-extension/adapters/next-request'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../lib/detached-promise'</span><span class="s3">\n</span><span class="s1">import { getTracer } from './lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NextNodeServerSpan } from './lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { getClientComponentLoaderMetrics } from './client-component-renderer-logger'</span><span class="s3">\n\n</span><span class="s1">export function isAbortError(e: any): e is Error &amp; { name: 'AbortError' } {</span><span class="s3">\n  </span><span class="s1">return e?.name === 'AbortError' || e?.name === ResponseAbortedName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createWriterFromResponse(</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">waitUntilForEnd?: Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">): WritableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let started = false</span><span class="s3">\n\n  </span><span class="s1">// Create a promise that will resolve once the response has drained. See</span><span class="s3">\n  </span><span class="s1">// https://nodejs.org/api/stream.html#stream_event_drain</span><span class="s3">\n  </span><span class="s1">let drained = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n  </span><span class="s1">function onDrain() {</span><span class="s3">\n    </span><span class="s1">drained.resolve()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">res.on('drain', onDrain)</span><span class="s3">\n\n  </span><span class="s1">// If the finish event fires, it means we shouldn't block and wait for the</span><span class="s3">\n  </span><span class="s1">// drain event.</span><span class="s3">\n  </span><span class="s1">res.once('close', () =&gt; {</span><span class="s3">\n    </span><span class="s1">res.off('drain', onDrain)</span><span class="s3">\n    </span><span class="s1">drained.resolve()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Create a promise that will resolve once the response has finished. See</span><span class="s3">\n  </span><span class="s1">// https://nodejs.org/api/http.html#event-finish_1</span><span class="s3">\n  </span><span class="s1">const finished = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n  </span><span class="s1">res.once('finish', () =&gt; {</span><span class="s3">\n    </span><span class="s1">finished.resolve()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Create a writable stream that will write to the response.</span><span class="s3">\n  </span><span class="s1">return new WritableStream&lt;Uint8Array&gt;({</span><span class="s3">\n    </span><span class="s1">write: async (chunk) =&gt; {</span><span class="s3">\n      </span><span class="s1">// You'd think we'd want to use `start` instead of placing this in `write`</span><span class="s3">\n      </span><span class="s1">// but this ensures that we don't actually flush the headers until we've</span><span class="s3">\n      </span><span class="s1">// started writing chunks.</span><span class="s3">\n      </span><span class="s1">if (!started) {</span><span class="s3">\n        </span><span class="s1">started = true</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">'performance' in globalThis &amp;&amp;</span><span class="s3">\n          </span><span class="s1">process.env.NEXT_OTEL_PERFORMANCE_PREFIX</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const metrics = getClientComponentLoaderMetrics()</span><span class="s3">\n          </span><span class="s1">if (metrics) {</span><span class="s3">\n            </span><span class="s1">performance.measure(</span><span class="s3">\n              </span><span class="s1">`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,</span><span class="s3">\n              </span><span class="s1">{</span><span class="s3">\n                </span><span class="s1">start: metrics.clientComponentLoadStart,</span><span class="s3">\n                </span><span class="s1">end:</span><span class="s3">\n                  </span><span class="s1">metrics.clientComponentLoadStart +</span><span class="s3">\n                  </span><span class="s1">metrics.clientComponentLoadTimes,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">res.flushHeaders()</span><span class="s3">\n        </span><span class="s1">getTracer().trace(</span><span class="s3">\n          </span><span class="s1">NextNodeServerSpan.startResponse,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">spanName: 'start response',</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">() =&gt; undefined</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const ok = res.write(chunk)</span><span class="s3">\n\n        </span><span class="s1">// Added by the `compression` middleware, this is a function that will</span><span class="s3">\n        </span><span class="s1">// flush the partially-compressed response to the client.</span><span class="s3">\n        </span><span class="s1">if ('flush' in res &amp;&amp; typeof res.flush === 'function') {</span><span class="s3">\n          </span><span class="s1">res.flush()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If the write returns false, it means there's some backpressure, so</span><span class="s3">\n        </span><span class="s1">// wait until it's streamed before continuing.</span><span class="s3">\n        </span><span class="s1">if (!ok) {</span><span class="s3">\n          </span><span class="s1">await drained.promise</span><span class="s3">\n\n          </span><span class="s1">// Reset the drained promise so that we can wait for the next drain event.</span><span class="s3">\n          </span><span class="s1">drained = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">res.end()</span><span class="s3">\n        </span><span class="s1">throw new Error('failed to write chunk to response', { cause: err })</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">abort: (err) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (res.writableFinished) return</span><span class="s3">\n\n      </span><span class="s1">res.destroy(err)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">close: async () =&gt; {</span><span class="s3">\n      </span><span class="s1">// if a waitUntil promise was passed, wait for it to resolve before</span><span class="s3">\n      </span><span class="s1">// ending the response.</span><span class="s3">\n      </span><span class="s1">if (waitUntilForEnd) {</span><span class="s3">\n        </span><span class="s1">await waitUntilForEnd</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (res.writableFinished) return</span><span class="s3">\n\n      </span><span class="s1">res.end()</span><span class="s3">\n      </span><span class="s1">return finished.promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function pipeToNodeResponse(</span><span class="s3">\n  </span><span class="s1">readable: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">waitUntilForEnd?: Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// If the response has already errored, then just return now.</span><span class="s3">\n    </span><span class="s1">const { errored, destroyed } = res</span><span class="s3">\n    </span><span class="s1">if (errored || destroyed) return</span><span class="s3">\n\n    </span><span class="s1">// Create a new AbortController so that we can abort the readable if the</span><span class="s3">\n    </span><span class="s1">// client disconnects.</span><span class="s3">\n    </span><span class="s1">const controller = createAbortController(res)</span><span class="s3">\n\n    </span><span class="s1">const writer = createWriterFromResponse(res, waitUntilForEnd)</span><span class="s3">\n\n    </span><span class="s1">await readable.pipeTo(writer, { signal: controller.signal })</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">// If this isn't related to an abort error, re-throw it.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(err)) return</span><span class="s3">\n\n    </span><span class="s1">throw new Error('failed to pipe response', { cause: err })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class InvariantError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(message: string, options?: ErrorOptions) {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">`Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,</span><span class="s3">\n      </span><span class="s1">options</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.name = 'InvariantError'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { FetchMetrics } from './base-http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">chainStreams,</span><span class="s3">\n  </span><span class="s1">streamFromBuffer,</span><span class="s3">\n  </span><span class="s1">streamFromString,</span><span class="s3">\n  </span><span class="s1">streamToString,</span><span class="s3">\n</span><span class="s1">} from './stream-utils/node-web-streams-helper'</span><span class="s3">\n</span><span class="s1">import { isAbortError, pipeToNodeResponse } from './pipe-readable'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">TEXT_PLAIN_CONTENT_TYPE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import type { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">type ContentTypeOption =</span><span class="s3">\n  </span><span class="s1">| typeof RSC_CONTENT_TYPE_HEADER // For App Page RSC responses</span><span class="s3">\n  </span><span class="s1">| typeof HTML_CONTENT_TYPE_HEADER // For App Page, Pages HTML responses</span><span class="s3">\n  </span><span class="s1">| typeof JSON_CONTENT_TYPE_HEADER // For API routes, Next.js data requests</span><span class="s3">\n  </span><span class="s1">| typeof TEXT_PLAIN_CONTENT_TYPE_HEADER // For simplified errors</span><span class="s3">\n\n</span><span class="s1">export type AppPageRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">flightData?: Buffer</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">staticBailoutInfo?: {</span><span class="s3">\n    </span><span class="s1">stack?: string</span><span class="s3">\n    </span><span class="s1">description?: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The postponed state if the render had postponed and needs to be resumed.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The headers to set on the response that were added by the render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">statusCode?: number</span><span class="s3">\n  </span><span class="s1">fetchTags?: string</span><span class="s3">\n  </span><span class="s1">fetchMetrics?: FetchMetrics</span><span class="s3">\n\n  </span><span class="s1">segmentData?: Map&lt;string, Buffer&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the resume data cache is warmed up before the render. This</span><span class="s3">\n   </span><span class="s1">* is attached to the metadata so that it can be used during the render. When</span><span class="s3">\n   </span><span class="s1">* prerendering, the filled resume data cache is also attached to the metadata</span><span class="s3">\n   </span><span class="s1">* so that it can be used when prerendering matching fallback shells.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PagesRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">pageData?: any</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">assetQueryString?: string</span><span class="s3">\n  </span><span class="s1">isNotFound?: boolean</span><span class="s3">\n  </span><span class="s1">isRedirect?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type StaticRenderResultMetadata = {}</span><span class="s3">\n\n</span><span class="s1">export type RenderResultMetadata = AppPageRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">PagesRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">StaticRenderResultMetadata</span><span class="s3">\n\n</span><span class="s1">export type RenderResultResponse =</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;[]</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">| string</span><span class="s3">\n  </span><span class="s1">| Buffer</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n\n</span><span class="s1">export type RenderResultOptions&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; = {</span><span class="s3">\n  </span><span class="s1">contentType: ContentTypeOption | null</span><span class="s3">\n  </span><span class="s1">waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n  </span><span class="s1">metadata: Metadata</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class RenderResult&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The detected content type for the response. This is used to set the</span><span class="s3">\n   </span><span class="s1">* `Content-Type` header.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly contentType: ContentTypeOption | null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The metadata for the response. This is used to set the revalidation times</span><span class="s3">\n   </span><span class="s1">* and other metadata.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly metadata: Readonly&lt;Metadata&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The response itself. This can be a string, a stream, or null. If it's a</span><span class="s3">\n   </span><span class="s1">* string, then it's a static response. If it's a stream, then it's a</span><span class="s3">\n   </span><span class="s1">* dynamic response. If it's null, then the response was not found or was</span><span class="s3">\n   </span><span class="s1">* already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private response: RenderResultResponse</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A render result that represents an empty response. This is used to</span><span class="s3">\n   </span><span class="s1">* represent a response that was not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static readonly EMPTY = new RenderResult&lt;StaticRenderResultMetadata&gt;(</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">{ metadata: {}, contentType: null }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a new RenderResult instance from a static response.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param value the static response value</span><span class="s3">\n   </span><span class="s1">* @param contentType the content type of the response</span><span class="s3">\n   </span><span class="s1">* @returns a new RenderResult instance</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static fromStatic(</span><span class="s3">\n    </span><span class="s1">value: string | Buffer,</span><span class="s3">\n    </span><span class="s1">contentType: ContentTypeOption</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return new RenderResult&lt;StaticRenderResultMetadata&gt;(value, {</span><span class="s3">\n      </span><span class="s1">metadata: {},</span><span class="s3">\n      </span><span class="s1">contentType,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private readonly waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">response: RenderResultResponse,</span><span class="s3">\n    </span><span class="s1">{ contentType, waitUntil, metadata }: RenderResultOptions&lt;Metadata&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.response = response</span><span class="s3">\n    </span><span class="s1">this.contentType = contentType</span><span class="s3">\n    </span><span class="s1">this.metadata = metadata</span><span class="s3">\n    </span><span class="s1">this.waitUntil = waitUntil</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public assignMetadata(metadata: Metadata) {</span><span class="s3">\n    </span><span class="s1">Object.assign(this.metadata, metadata)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns true if the response is null. It can be null if the response was</span><span class="s3">\n   </span><span class="s1">* not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isNull(): boolean {</span><span class="s3">\n    </span><span class="s1">return this.response === null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns false if the response is a string. It can be a string if the page</span><span class="s3">\n   </span><span class="s1">* was prerendered. If it's not, then it was generated dynamically.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isDynamic(): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.response !== 'string'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the response if it is a string. If the page was dynamic, this will</span><span class="s3">\n   </span><span class="s1">* return a promise if the `stream` option is true, or it will throw an error.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param stream Whether or not to return a promise if the response is dynamic</span><span class="s3">\n   </span><span class="s1">* @returns The response as a string</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream?: false): string</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream: true): Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream = false): Promise&lt;string&gt; | string {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty string. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response !== 'string') {</span><span class="s3">\n      </span><span class="s1">if (!stream) {</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'dynamic responses cannot be unchunked. This is a bug in Next.js'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return streamToString(this.readable)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a readable stream of the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private get readable(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return new ReadableStream&lt;Uint8Array&gt;({</span><span class="s3">\n        </span><span class="s1">start(controller) {</span><span class="s3">\n          </span><span class="s1">controller.close()</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return streamFromString(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return streamFromBuffer(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the response is an array of streams, then chain them together.</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return chainStreams(...this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Coerces the response to an array of streams. This will convert the response</span><span class="s3">\n   </span><span class="s1">* to an array of streams if it is not already one.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @returns An array of streams</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private coerce(): ReadableStream&lt;Uint8Array&gt;[] {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return []</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return [streamFromString(this.response)]</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return this.response</span><span class="s3">\n    </span><span class="s1">} else if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return [streamFromBuffer(this.response)]</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return [this.response]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Unshifts a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the start of the array. When this response is piped, all of the streams</span><span class="s3">\n   </span><span class="s1">* will be piped one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to unshift</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public unshift(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the start of the array.</span><span class="s3">\n    </span><span class="s1">this.response.unshift(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Chains a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the end. When this response is piped, all of the streams will be piped</span><span class="s3">\n   </span><span class="s1">* one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to chain</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public push(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the end of the array.</span><span class="s3">\n    </span><span class="s1">this.response.push(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a writable stream. This will close/cancel the</span><span class="s3">\n   </span><span class="s1">* writable stream if an error is encountered. If this doesn't throw, then</span><span class="s3">\n   </span><span class="s1">* the writable stream will be closed or aborted.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param writable Writable stream to pipe the response to</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeTo(writable: WritableStream&lt;Uint8Array&gt;): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">await this.readable.pipeTo(writable, {</span><span class="s3">\n        </span><span class="s1">// We want to close the writable stream ourselves so that we can wait</span><span class="s3">\n        </span><span class="s1">// for the waitUntil promise to resolve before closing it. If an error</span><span class="s3">\n        </span><span class="s1">// is encountered, we'll abort the writable stream if we swallowed the</span><span class="s3">\n        </span><span class="s1">// error.</span><span class="s3">\n        </span><span class="s1">preventClose: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// If there is a waitUntil promise, wait for it to resolve before</span><span class="s3">\n      </span><span class="s1">// closing the writable stream.</span><span class="s3">\n      </span><span class="s1">if (this.waitUntil) await this.waitUntil</span><span class="s3">\n\n      </span><span class="s1">// Close the writable stream.</span><span class="s3">\n      </span><span class="s1">await writable.close()</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">// If this is an abort error, we should abort the writable stream (as we</span><span class="s3">\n      </span><span class="s1">// took ownership of it when we started piping). We don't need to re-throw</span><span class="s3">\n      </span><span class="s1">// because we handled the error.</span><span class="s3">\n      </span><span class="s1">if (isAbortError(err)) {</span><span class="s3">\n        </span><span class="s1">// Abort the writable stream if an error is encountered.</span><span class="s3">\n        </span><span class="s1">await writable.abort(err)</span><span class="s3">\n\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We're not aborting the writer here as when this method throws it's not</span><span class="s3">\n      </span><span class="s1">// clear as to how so the caller should assume it's their responsibility</span><span class="s3">\n      </span><span class="s1">// to clean up the writer.</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a node response. This will close/cancel the node</span><span class="s3">\n   </span><span class="s1">* response if an error is encountered.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param res</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeToNodeResponse(res: ServerResponse) {</span><span class="s3">\n    </span><span class="s1">await pipeToNodeResponse(this.readable, res, this.waitUntil)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const enum RouteKind {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES` represents all the React pages that are under `pages/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES_API` represents all the API routes under `pages/api/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES_API = 'PAGES_API',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_PAGE` represents all the React pages that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `page.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `route.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `IMAGE` represents all the images that are generated by `next/image`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedAppPageValue,</span><span class="s3">\n  </span><span class="s1">type CachedPageValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">type ResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n\n</span><span class="s1">import RenderResult from '../render-result'</span><span class="s3">\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import { HTML_CONTENT_TYPE_HEADER } from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">export async function fromResponseCacheEntry(</span><span class="s3">\n  </span><span class="s1">cacheEntry: ResponseCacheEntry</span><span class="s3">\n</span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry&gt; {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...cacheEntry,</span><span class="s3">\n    </span><span class="s1">value:</span><span class="s3">\n      </span><span class="s1">cacheEntry.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n        </span><span class="s1">? {</span><span class="s3">\n            </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">html: await cacheEntry.value.html.toUnchunkedString(true),</span><span class="s3">\n            </span><span class="s1">pageData: cacheEntry.value.pageData,</span><span class="s3">\n            </span><span class="s1">headers: cacheEntry.value.headers,</span><span class="s3">\n            </span><span class="s1">status: cacheEntry.value.status,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: cacheEntry.value?.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n          </span><span class="s1">? {</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n              </span><span class="s1">html: await cacheEntry.value.html.toUnchunkedString(true),</span><span class="s3">\n              </span><span class="s1">postponed: cacheEntry.value.postponed,</span><span class="s3">\n              </span><span class="s1">rscData: cacheEntry.value.rscData,</span><span class="s3">\n              </span><span class="s1">headers: cacheEntry.value.headers,</span><span class="s3">\n              </span><span class="s1">status: cacheEntry.value.status,</span><span class="s3">\n              </span><span class="s1">segmentData: cacheEntry.value.segmentData,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">: cacheEntry.value,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function toResponseCacheEntry(</span><span class="s3">\n  </span><span class="s1">response: IncrementalResponseCacheEntry | null</span><span class="s3">\n</span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt; {</span><span class="s3">\n  </span><span class="s1">if (!response) return null</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">isMiss: response.isMiss,</span><span class="s3">\n    </span><span class="s1">isStale: response.isStale,</span><span class="s3">\n    </span><span class="s1">cacheControl: response.cacheControl,</span><span class="s3">\n    </span><span class="s1">value:</span><span class="s3">\n      </span><span class="s1">response.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n        </span><span class="s1">? ({</span><span class="s3">\n            </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">html: RenderResult.fromStatic(</span><span class="s3">\n              </span><span class="s1">response.value.html,</span><span class="s3">\n              </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">pageData: response.value.pageData,</span><span class="s3">\n            </span><span class="s1">headers: response.value.headers,</span><span class="s3">\n            </span><span class="s1">status: response.value.status,</span><span class="s3">\n          </span><span class="s1">} satisfies CachedPageValue)</span><span class="s3">\n        </span><span class="s1">: response.value?.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n          </span><span class="s1">? ({</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n              </span><span class="s1">html: RenderResult.fromStatic(</span><span class="s3">\n                </span><span class="s1">response.value.html,</span><span class="s3">\n                </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">rscData: response.value.rscData,</span><span class="s3">\n              </span><span class="s1">headers: response.value.headers,</span><span class="s3">\n              </span><span class="s1">status: response.value.status,</span><span class="s3">\n              </span><span class="s1">postponed: response.value.postponed,</span><span class="s3">\n              </span><span class="s1">segmentData: response.value.segmentData,</span><span class="s3">\n            </span><span class="s1">} satisfies CachedAppPageValue)</span><span class="s3">\n          </span><span class="s1">: response.value,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function routeKindToIncrementalCacheKind(</span><span class="s3">\n  </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n</span><span class="s1">): Exclude&lt;IncrementalCacheKind, IncrementalCacheKind.FETCH&gt; {</span><span class="s3">\n  </span><span class="s1">switch (routeKind) {</span><span class="s3">\n    </span><span class="s1">case RouteKind.PAGES:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.PAGES</span><span class="s3">\n    </span><span class="s1">case RouteKind.APP_PAGE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.APP_PAGE</span><span class="s3">\n    </span><span class="s1">case RouteKind.IMAGE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.IMAGE</span><span class="s3">\n    </span><span class="s1">case RouteKind.APP_ROUTE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n    </span><span class="s1">case RouteKind.PAGES_API:</span><span class="s3">\n      </span><span class="s1">// Pages Router API routes are not cached in the incremental cache.</span><span class="s3">\n      </span><span class="s1">throw new Error(`Unexpected route kind ${routeKind}`)</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return routeKind satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">ResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">ResponseGenerator,</span><span class="s3">\n  </span><span class="s1">ResponseCacheBase,</span><span class="s3">\n  </span><span class="s1">IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">IncrementalResponseCache,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n\n</span><span class="s1">import { Batcher } from '../../lib/batcher'</span><span class="s3">\n</span><span class="s1">import { scheduleOnNextTick } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">fromResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">routeKindToIncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">toResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './utils'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export * from './types'</span><span class="s3">\n\n</span><span class="s1">export default class ResponseCache implements ResponseCacheBase {</span><span class="s3">\n  </span><span class="s1">private readonly batcher = Batcher.create&lt;</span><span class="s3">\n    </span><span class="s1">{ key: string; isOnDemandRevalidate: boolean },</span><span class="s3">\n    </span><span class="s1">IncrementalResponseCacheEntry | null,</span><span class="s3">\n    </span><span class="s1">string</span><span class="s3">\n  </span><span class="s1">&gt;({</span><span class="s3">\n    </span><span class="s1">// Ensure on-demand revalidate doesn't block normal requests, it should be</span><span class="s3">\n    </span><span class="s1">// safe to run an on-demand revalidate for the same key as a normal request.</span><span class="s3">\n    </span><span class="s1">cacheKeyFn: ({ key, isOnDemandRevalidate }) =&gt;</span><span class="s3">\n      </span><span class="s1">`${key}-${isOnDemandRevalidate ? '1' : '0'}`,</span><span class="s3">\n    </span><span class="s1">// We wait to do any async work until after we've added our promise to</span><span class="s3">\n    </span><span class="s1">// `pendingResponses` to ensure that any any other calls will reuse the</span><span class="s3">\n    </span><span class="s1">// same promise until we've fully finished our work.</span><span class="s3">\n    </span><span class="s1">schedulerFn: scheduleOnNextTick,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">private previousCacheItem?: {</span><span class="s3">\n    </span><span class="s1">key: string</span><span class="s3">\n    </span><span class="s1">entry: IncrementalResponseCacheEntry | null</span><span class="s3">\n    </span><span class="s1">expiresAt: number</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// we don't use minimal_mode name here as this.minimal_mode is</span><span class="s3">\n  </span><span class="s1">// statically replace for server runtimes but we need it to</span><span class="s3">\n  </span><span class="s1">// be dynamic here</span><span class="s3">\n  </span><span class="s1">private minimal_mode?: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(minimal_mode: boolean) {</span><span class="s3">\n    </span><span class="s1">this.minimal_mode = minimal_mode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async get(</span><span class="s3">\n    </span><span class="s1">key: string | null,</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator,</span><span class="s3">\n    </span><span class="s1">context: {</span><span class="s3">\n      </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n      </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n      </span><span class="s1">incrementalCache: IncrementalResponseCache</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n      </span><span class="s1">isFallback?: boolean</span><span class="s3">\n      </span><span class="s1">waitUntil?: (prom: Promise&lt;any&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">// If there is no key for the cache, we can't possibly look this up in the</span><span class="s3">\n    </span><span class="s1">// cache so just return the result of the response generator.</span><span class="s3">\n    </span><span class="s1">if (!key) {</span><span class="s3">\n      </span><span class="s1">return responseGenerator({ hasResolved: false, previousCacheEntry: null })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">incrementalCache,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate = false,</span><span class="s3">\n      </span><span class="s1">isFallback = false,</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled = false,</span><span class="s3">\n      </span><span class="s1">waitUntil,</span><span class="s3">\n    </span><span class="s1">} = context</span><span class="s3">\n\n    </span><span class="s1">const response = await this.batcher.batch(</span><span class="s3">\n      </span><span class="s1">{ key, isOnDemandRevalidate },</span><span class="s3">\n      </span><span class="s1">(cacheKey, resolve) =&gt; {</span><span class="s3">\n        </span><span class="s1">const prom = (async () =&gt; {</span><span class="s3">\n          </span><span class="s1">// We keep the previous cache entry around to leverage when the</span><span class="s3">\n          </span><span class="s1">// incremental cache is disabled in minimal mode.</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">this.minimal_mode &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.previousCacheItem?.key === cacheKey &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.previousCacheItem.expiresAt &gt; Date.now()</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return this.previousCacheItem.entry</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Coerce the kindHint into a given kind for the incremental cache.</span><span class="s3">\n          </span><span class="s1">const kind = routeKindToIncrementalCacheKind(context.routeKind)</span><span class="s3">\n\n          </span><span class="s1">let resolved = false</span><span class="s3">\n          </span><span class="s1">let cachedResponse: IncrementalResponseCacheEntry | null = null</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">cachedResponse = !this.minimal_mode</span><span class="s3">\n              </span><span class="s1">? await incrementalCache.get(key, {</span><span class="s3">\n                  </span><span class="s1">kind,</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled: context.isRoutePPREnabled,</span><span class="s3">\n                  </span><span class="s1">isFallback,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">: null</span><span class="s3">\n\n            </span><span class="s1">if (cachedResponse &amp;&amp; !isOnDemandRevalidate) {</span><span class="s3">\n              </span><span class="s1">resolve(cachedResponse)</span><span class="s3">\n              </span><span class="s1">resolved = true</span><span class="s3">\n\n              </span><span class="s1">if (!cachedResponse.isStale || context.isPrefetch) {</span><span class="s3">\n                </span><span class="s1">// The cached value is still valid, so we don't need</span><span class="s3">\n                </span><span class="s1">// to update it yet.</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const cacheEntry = await responseGenerator({</span><span class="s3">\n              </span><span class="s1">hasResolved: resolved,</span><span class="s3">\n              </span><span class="s1">previousCacheEntry: cachedResponse,</span><span class="s3">\n              </span><span class="s1">isRevalidating: true,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">// If the cache entry couldn't be generated, we don't want to cache</span><span class="s3">\n            </span><span class="s1">// the result.</span><span class="s3">\n            </span><span class="s1">if (!cacheEntry) {</span><span class="s3">\n              </span><span class="s1">// Unset the previous cache item if it was set.</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) this.previousCacheItem = undefined</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const resolveValue = await fromResponseCacheEntry({</span><span class="s3">\n              </span><span class="s1">...cacheEntry,</span><span class="s3">\n              </span><span class="s1">isMiss: !cachedResponse,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">if (!resolveValue) {</span><span class="s3">\n              </span><span class="s1">// Unset the previous cache item if it was set.</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) this.previousCacheItem = undefined</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// For on-demand revalidate wait to resolve until cache is set.</span><span class="s3">\n            </span><span class="s1">// Otherwise resolve now.</span><span class="s3">\n            </span><span class="s1">if (!isOnDemandRevalidate &amp;&amp; !resolved) {</span><span class="s3">\n              </span><span class="s1">resolve(resolveValue)</span><span class="s3">\n              </span><span class="s1">resolved = true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// We want to persist the result only if it has a cache control value</span><span class="s3">\n            </span><span class="s1">// defined.</span><span class="s3">\n            </span><span class="s1">if (resolveValue.cacheControl) {</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) {</span><span class="s3">\n                </span><span class="s1">this.previousCacheItem = {</span><span class="s3">\n                  </span><span class="s1">key: cacheKey,</span><span class="s3">\n                  </span><span class="s1">entry: resolveValue,</span><span class="s3">\n                  </span><span class="s1">expiresAt: Date.now() + 1000,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">await incrementalCache.set(key, resolveValue.value, {</span><span class="s3">\n                  </span><span class="s1">cacheControl: resolveValue.cacheControl,</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n                  </span><span class="s1">isFallback,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return resolveValue</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">// When a path is erroring we automatically re-set the existing cache</span><span class="s3">\n            </span><span class="s1">// with new revalidate and expire times to prevent non-stop retrying.</span><span class="s3">\n            </span><span class="s1">if (cachedResponse?.cacheControl) {</span><span class="s3">\n              </span><span class="s1">const newRevalidate = Math.min(</span><span class="s3">\n                </span><span class="s1">Math.max(cachedResponse.cacheControl.revalidate || 3, 3),</span><span class="s3">\n                </span><span class="s1">30</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">const newExpire =</span><span class="s3">\n                </span><span class="s1">cachedResponse.cacheControl.expire === undefined</span><span class="s3">\n                  </span><span class="s1">? undefined</span><span class="s3">\n                  </span><span class="s1">: Math.max(</span><span class="s3">\n                      </span><span class="s1">newRevalidate + 3,</span><span class="s3">\n                      </span><span class="s1">cachedResponse.cacheControl.expire</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">await incrementalCache.set(key, cachedResponse.value, {</span><span class="s3">\n                </span><span class="s1">cacheControl: { revalidate: newRevalidate, expire: newExpire },</span><span class="s3">\n                </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n                </span><span class="s1">isFallback,</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// While revalidating in the background we can't reject as we already</span><span class="s3">\n            </span><span class="s1">// resolved the cache entry so log the error here.</span><span class="s3">\n            </span><span class="s1">if (resolved) {</span><span class="s3">\n              </span><span class="s1">console.error(err)</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// We haven't resolved yet, so let's throw to indicate an error.</span><span class="s3">\n            </span><span class="s1">throw err</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})()</span><span class="s3">\n\n        </span><span class="s1">// we need to ensure background revalidates are</span><span class="s3">\n        </span><span class="s1">// passed to waitUntil</span><span class="s3">\n        </span><span class="s1">if (waitUntil) {</span><span class="s3">\n          </span><span class="s1">waitUntil(prom)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return prom</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return toResponseCacheEntry(response)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from '../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import type { CacheFs } from '../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A task to be written.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type Task = [</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The directory to create.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">directory: string,</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The promise to create the directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mkdir: Promise&lt;unknown&gt;,</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The promises to write the files that are dependent on the directory being</span><span class="s3">\n   </span><span class="s1">* created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeFile: Promise&lt;unknown&gt;[],</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* MultiFileWriter is a utility for writing multiple files in parallel that</span><span class="s3">\n </span><span class="s1">* guarantees that all files will be written after their containing directory</span><span class="s3">\n </span><span class="s1">* is created, and that the directory will only be created once.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class MultiFileWriter {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The tasks to be written.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly tasks: Task[] = []</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The file system methods to use.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">private readonly fs: Pick&lt;CacheFs, 'mkdir' | 'writeFile'&gt;</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Finds or creates a task for a directory.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param directory - The directory to find or create a task for.</span><span class="s3">\n   </span><span class="s1">* @returns The task for the directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private findOrCreateTask(directory: string): Task {</span><span class="s3">\n    </span><span class="s1">// See if this directory already has a task to create it.</span><span class="s3">\n    </span><span class="s1">for (const task of this.tasks) {</span><span class="s3">\n      </span><span class="s1">if (task[0] === directory) {</span><span class="s3">\n        </span><span class="s1">return task</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const promise = this.fs.mkdir(directory)</span><span class="s3">\n\n    </span><span class="s1">// Attach a catch handler so that it doesn't throw an unhandled promise</span><span class="s3">\n    </span><span class="s1">// rejection warning.</span><span class="s3">\n    </span><span class="s1">promise.catch(() =&gt; {})</span><span class="s3">\n\n    </span><span class="s1">// Otherwise, create a new task for this directory.</span><span class="s3">\n    </span><span class="s1">const task: Task = [directory, promise, []]</span><span class="s3">\n    </span><span class="s1">this.tasks.push(task)</span><span class="s3">\n\n    </span><span class="s1">return task</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Appends a file to the writer to be written after its containing directory</span><span class="s3">\n   </span><span class="s1">* is created. The file writer should be awaited after all the files have been</span><span class="s3">\n   </span><span class="s1">* appended. Any async operation that occurs between appending and awaiting</span><span class="s3">\n   </span><span class="s1">* may cause an unhandled promise rejection warning and potentially crash the</span><span class="s3">\n   </span><span class="s1">* process.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param filePath - The path to the file to write.</span><span class="s3">\n   </span><span class="s1">* @param data - The data to write to the file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public append(filePath: string, data: Buffer | string): void {</span><span class="s3">\n    </span><span class="s1">// Find or create a task for the directory that contains the file.</span><span class="s3">\n    </span><span class="s1">const task = this.findOrCreateTask(path.dirname(filePath))</span><span class="s3">\n\n    </span><span class="s1">const promise = task[1].then(() =&gt; this.fs.writeFile(filePath, data))</span><span class="s3">\n\n    </span><span class="s1">// Attach a catch handler so that it doesn't throw an unhandled promise</span><span class="s3">\n    </span><span class="s1">// rejection warning.</span><span class="s3">\n    </span><span class="s1">promise.catch(() =&gt; {})</span><span class="s3">\n\n    </span><span class="s1">// Add the file write to the task AFTER the directory promise has resolved.</span><span class="s3">\n    </span><span class="s1">task[2].push(promise)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a promise that resolves when all the files have been written.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public wait(): Promise&lt;unknown&gt; {</span><span class="s3">\n    </span><span class="s1">return Promise.all(this.tasks.flatMap((task) =&gt; task[2]))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RouteMetadata } from '../../../export/routes/types'</span><span class="s3">\n</span><span class="s1">import type { CacheHandler, CacheHandlerContext, CacheHandlerValue } from '.'</span><span class="s3">\n</span><span class="s1">import type { CacheFs } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedFetchValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalResponseCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n\n</span><span class="s1">import type { LRUCache } from '../lru-cache'</span><span class="s3">\n</span><span class="s1">import path from '../../../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_DATA_SUFFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_META_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_PREFETCH_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENT_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SUFFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { isStale, tagsManifest } from './tags-manifest.external'</span><span class="s3">\n</span><span class="s1">import { MultiFileWriter } from '../../../lib/multi-file-writer'</span><span class="s3">\n</span><span class="s1">import { getMemoryCache } from './memory-cache.external'</span><span class="s3">\n\n</span><span class="s1">type FileSystemCacheContext = Omit&lt;</span><span class="s3">\n  </span><span class="s1">CacheHandlerContext,</span><span class="s3">\n  </span><span class="s1">'fs' | 'serverDistDir'</span><span class="s3">\n</span><span class="s1">&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">fs: CacheFs</span><span class="s3">\n  </span><span class="s1">serverDistDir: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class FileSystemCache implements CacheHandler {</span><span class="s3">\n  </span><span class="s1">private fs: FileSystemCacheContext['fs']</span><span class="s3">\n  </span><span class="s1">private flushToDisk?: FileSystemCacheContext['flushToDisk']</span><span class="s3">\n  </span><span class="s1">private serverDistDir: FileSystemCacheContext['serverDistDir']</span><span class="s3">\n  </span><span class="s1">private revalidatedTags: string[]</span><span class="s3">\n  </span><span class="s1">private static debug: boolean = !!process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">private static memoryCache: LRUCache&lt;CacheHandlerValue&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(ctx: FileSystemCacheContext) {</span><span class="s3">\n    </span><span class="s1">this.fs = ctx.fs</span><span class="s3">\n    </span><span class="s1">this.flushToDisk = ctx.flushToDisk</span><span class="s3">\n    </span><span class="s1">this.serverDistDir = ctx.serverDistDir</span><span class="s3">\n    </span><span class="s1">this.revalidatedTags = ctx.revalidatedTags</span><span class="s3">\n\n    </span><span class="s1">if (ctx.maxMemoryCacheSize) {</span><span class="s3">\n      </span><span class="s1">if (!FileSystemCache.memoryCache) {</span><span class="s3">\n        </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n          </span><span class="s1">console.log('using memory store for fetch cache')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">FileSystemCache.memoryCache = getMemoryCache(ctx.maxMemoryCacheSize)</span><span class="s3">\n      </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n        </span><span class="s1">console.log('memory store already initialized')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('not using memory store for fetch cache')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public resetRequestCache(): void {}</span><span class="s3">\n\n  </span><span class="s1">public async revalidateTag(</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;CacheHandler['revalidateTag']&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let [tags] = args</span><span class="s3">\n    </span><span class="s1">tags = typeof tags === 'string' ? [tags] : tags</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('revalidateTag', tags)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (tags.length === 0) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const tag of tags) {</span><span class="s3">\n      </span><span class="s1">if (!tagsManifest.has(tag)) {</span><span class="s3">\n        </span><span class="s1">tagsManifest.set(tag, Date.now())</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async get(...args: Parameters&lt;CacheHandler['get']&gt;) {</span><span class="s3">\n    </span><span class="s1">const [key, ctx] = args</span><span class="s3">\n    </span><span class="s1">const { kind } = ctx</span><span class="s3">\n\n    </span><span class="s1">let data = FileSystemCache.memoryCache?.get(key)</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, ctx.tags, kind, !!data)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, kind, !!data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// let's check the disk for seed data</span><span class="s3">\n    </span><span class="s1">if (!data &amp;&amp; process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (kind === IncrementalCacheKind.APP_ROUTE) {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}.body`,</span><span class="s3">\n            </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath)</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">const meta = JSON.parse(</span><span class="s3">\n            </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n              </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n              </span><span class="s1">'utf8'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">data = {</span><span class="s3">\n            </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n            </span><span class="s1">value: {</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_ROUTE,</span><span class="s3">\n              </span><span class="s1">body: fileData,</span><span class="s3">\n              </span><span class="s1">headers: meta.headers,</span><span class="s3">\n              </span><span class="s1">status: meta.status,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">kind === IncrementalCacheKind.FETCH ? key : `${key}.html`,</span><span class="s3">\n            </span><span class="s1">kind</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath, 'utf8')</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n            </span><span class="s1">const { tags, fetchIdx, fetchUrl } = ctx</span><span class="s3">\n\n            </span><span class="s1">if (!this.flushToDisk) return null</span><span class="s3">\n\n            </span><span class="s1">const lastModified = mtime.getTime()</span><span class="s3">\n            </span><span class="s1">const parsedData: CachedFetchValue = JSON.parse(fileData)</span><span class="s3">\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified,</span><span class="s3">\n              </span><span class="s1">value: parsedData,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (data.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n              </span><span class="s1">const storedTags = data.value?.tags</span><span class="s3">\n\n              </span><span class="s1">// update stored tags if a new one is being added</span><span class="s3">\n              </span><span class="s1">// TODO: remove this when we can send the tags</span><span class="s3">\n              </span><span class="s1">// via header on GET same as SET</span><span class="s3">\n              </span><span class="s1">if (!tags?.every((tag) =&gt; storedTags?.includes(tag))) {</span><span class="s3">\n                </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n                  </span><span class="s1">console.log('tags vs storedTags mismatch', tags, storedTags)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">await this.set(key, data.value, {</span><span class="s3">\n                  </span><span class="s1">fetchCache: true,</span><span class="s3">\n                  </span><span class="s1">tags,</span><span class="s3">\n                  </span><span class="s1">fetchIdx,</span><span class="s3">\n                  </span><span class="s1">fetchUrl,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.APP_PAGE) {</span><span class="s3">\n            </span><span class="s1">// We try to load the metadata file, but if it fails, we don't</span><span class="s3">\n            </span><span class="s1">// error. We also don't load it if this is a fallback.</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">meta = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} catch {}</span><span class="s3">\n\n            </span><span class="s1">let maybeSegmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n            </span><span class="s1">if (meta?.segmentPaths) {</span><span class="s3">\n              </span><span class="s1">// Collect all the segment data for this page.</span><span class="s3">\n              </span><span class="s1">// TODO: To optimize file system reads, we should consider creating</span><span class="s3">\n              </span><span class="s1">// separate cache entries for each segment, rather than storing them</span><span class="s3">\n              </span><span class="s1">// all on the page's entry. Though the behavior is</span><span class="s3">\n              </span><span class="s1">// identical regardless.</span><span class="s3">\n              </span><span class="s1">const segmentData: Map&lt;string, Buffer&gt; = new Map()</span><span class="s3">\n              </span><span class="s1">maybeSegmentData = segmentData</span><span class="s3">\n              </span><span class="s1">const segmentsDir = key + RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n              </span><span class="s1">await Promise.all(</span><span class="s3">\n                </span><span class="s1">meta.segmentPaths.map(async (segmentPath: string) =&gt; {</span><span class="s3">\n                  </span><span class="s1">const segmentDataFilePath = this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">segmentData.set(</span><span class="s3">\n                      </span><span class="s1">segmentPath,</span><span class="s3">\n                      </span><span class="s1">await this.fs.readFile(segmentDataFilePath)</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">} catch {</span><span class="s3">\n                    </span><span class="s1">// This shouldn't happen, but if for some reason we fail to</span><span class="s3">\n                    </span><span class="s1">// load a segment from the filesystem, treat it the same as if</span><span class="s3">\n                    </span><span class="s1">// the segment is dynamic and does not have a prefetch.</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">let rscData: Buffer | undefined</span><span class="s3">\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">rscData = await this.fs.readFile(</span><span class="s3">\n                </span><span class="s1">this.getFilePath(</span><span class="s3">\n                  </span><span class="s1">`${key}${ctx.isRoutePPREnabled ? RSC_PREFETCH_SUFFIX : RSC_SUFFIX}`,</span><span class="s3">\n                  </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">rscData,</span><span class="s3">\n                </span><span class="s1">postponed: meta?.postponed,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n                </span><span class="s1">segmentData: maybeSegmentData,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.PAGES) {</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">let pageData: string | object = {}</span><span class="s3">\n\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">pageData = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">`${key}${NEXT_DATA_SUFFIX}`,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.PAGES</span><span class="s3">\n                  </span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">pageData,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`Invariant: Unexpected route kind ${kind} in file system cache.`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (data) {</span><span class="s3">\n          </span><span class="s1">FileSystemCache.memoryCache?.set(key, data)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_PAGE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_ROUTE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">let cacheTags: undefined | string[]</span><span class="s3">\n      </span><span class="s1">const tagsHeader = data.value.headers?.[NEXT_CACHE_TAGS_HEADER]</span><span class="s3">\n\n      </span><span class="s1">if (typeof tagsHeader === 'string') {</span><span class="s3">\n        </span><span class="s1">cacheTags = tagsHeader.split(',')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheTags?.length) {</span><span class="s3">\n        </span><span class="s1">// we trigger a blocking validation if an ISR page</span><span class="s3">\n        </span><span class="s1">// had a tag revalidated, if we want to be a background</span><span class="s3">\n        </span><span class="s1">// revalidation instead we return data.lastModified = -1</span><span class="s3">\n        </span><span class="s1">if (isStale(cacheTags, data?.lastModified || Date.now())) {</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data?.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const combinedTags =</span><span class="s3">\n        </span><span class="s1">ctx.kind === IncrementalCacheKind.FETCH</span><span class="s3">\n          </span><span class="s1">? [...(ctx.tags || []), ...(ctx.softTags || [])]</span><span class="s3">\n          </span><span class="s1">: []</span><span class="s3">\n\n      </span><span class="s1">const wasRevalidated = combinedTags.some((tag) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (this.revalidatedTags.includes(tag)) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return isStale([tag], data?.lastModified || Date.now())</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">// When revalidate tag is called we don't return</span><span class="s3">\n      </span><span class="s1">// stale data so it's updated right away</span><span class="s3">\n      </span><span class="s1">if (wasRevalidated) {</span><span class="s3">\n        </span><span class="s1">data = undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return data ?? null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">FileSystemCache.memoryCache?.set(key, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">lastModified: Date.now(),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('set', key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.flushToDisk || !data) return</span><span class="s3">\n\n    </span><span class="s1">// Create a new writer that will prepare to write all the files to disk</span><span class="s3">\n    </span><span class="s1">// after their containing directory is created.</span><span class="s3">\n    </span><span class="s1">const writer = new MultiFileWriter(this.fs)</span><span class="s3">\n\n    </span><span class="s1">if (data.kind === CachedRouteKind.APP_ROUTE) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.body`,</span><span class="s3">\n        </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(filePath, data.body)</span><span class="s3">\n\n      </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n        </span><span class="s1">headers: data.headers,</span><span class="s3">\n        </span><span class="s1">status: data.status,</span><span class="s3">\n        </span><span class="s1">postponed: undefined,</span><span class="s3">\n        </span><span class="s1">segmentPaths: undefined,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n        </span><span class="s1">JSON.stringify(meta, null, 2)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.PAGES ||</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const isAppPath = data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n      </span><span class="s1">const htmlPath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.html`,</span><span class="s3">\n        </span><span class="s1">isAppPath ? IncrementalCacheKind.APP_PAGE : IncrementalCacheKind.PAGES</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(htmlPath, data.html)</span><span class="s3">\n\n      </span><span class="s1">// Fallbacks don't generate a data file.</span><span class="s3">\n      </span><span class="s1">if (!ctx.fetchCache &amp;&amp; !ctx.isFallback) {</span><span class="s3">\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}${</span><span class="s3">\n              </span><span class="s1">isAppPath</span><span class="s3">\n                </span><span class="s1">? ctx.isRoutePPREnabled</span><span class="s3">\n                  </span><span class="s1">? RSC_PREFETCH_SUFFIX</span><span class="s3">\n                  </span><span class="s1">: RSC_SUFFIX</span><span class="s3">\n                </span><span class="s1">: NEXT_DATA_SUFFIX</span><span class="s3">\n            </span><span class="s1">}`,</span><span class="s3">\n            </span><span class="s1">isAppPath</span><span class="s3">\n              </span><span class="s1">? IncrementalCacheKind.APP_PAGE</span><span class="s3">\n              </span><span class="s1">: IncrementalCacheKind.PAGES</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">isAppPath ? data.rscData! : JSON.stringify(data.pageData)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (data?.kind === CachedRouteKind.APP_PAGE) {</span><span class="s3">\n        </span><span class="s1">let segmentPaths: string[] | undefined</span><span class="s3">\n        </span><span class="s1">if (data.segmentData) {</span><span class="s3">\n          </span><span class="s1">segmentPaths = []</span><span class="s3">\n          </span><span class="s1">const segmentsDir = htmlPath.replace(</span><span class="s3">\n            </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.html$/,</span><span class="s3">\n            </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">for (const [segmentPath, buffer] of data.segmentData) {</span><span class="s3">\n            </span><span class="s1">segmentPaths.push(segmentPath)</span><span class="s3">\n            </span><span class="s1">const segmentDataFilePath =</span><span class="s3">\n              </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX</span><span class="s3">\n            </span><span class="s1">writer.append(segmentDataFilePath, buffer)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n          </span><span class="s1">headers: data.headers,</span><span class="s3">\n          </span><span class="s1">status: data.status,</span><span class="s3">\n          </span><span class="s1">postponed: data.postponed,</span><span class="s3">\n          </span><span class="s1">segmentPaths,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">htmlPath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n          </span><span class="s1">JSON.stringify(meta)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(key, IncrementalCacheKind.FETCH)</span><span class="s3">\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath,</span><span class="s3">\n        </span><span class="s1">JSON.stringify({</span><span class="s3">\n          </span><span class="s1">...data,</span><span class="s3">\n          </span><span class="s1">tags: ctx.fetchCache ? ctx.tags : [],</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Wait for all FS operations to complete.</span><span class="s3">\n    </span><span class="s1">await writer.wait()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private getFilePath(pathname: string, kind: IncrementalCacheKind): string {</span><span class="s3">\n    </span><span class="s1">switch (kind) {</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.FETCH:</span><span class="s3">\n        </span><span class="s1">// we store in .next/cache/fetch-cache so it can be persisted</span><span class="s3">\n        </span><span class="s1">// across deploys</span><span class="s3">\n        </span><span class="s1">return path.join(</span><span class="s3">\n          </span><span class="s1">this.serverDistDir,</span><span class="s3">\n          </span><span class="s1">'..',</span><span class="s3">\n          </span><span class="s1">'cache',</span><span class="s3">\n          </span><span class="s1">'fetch-cache',</span><span class="s3">\n          </span><span class="s1">pathname</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.PAGES:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'pages', pathname)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.IMAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_PAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_ROUTE:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'app', pathname)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">throw new Error(`Unexpected file path kind: ${kind}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This transforms a URL pathname into a route. It removes any trailing slashes</span><span class="s3">\n </span><span class="s1">* and the `/index` suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pathname - The URL path that needs to be optimized.</span><span class="s3">\n </span><span class="s1">* @returns - The route</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/example'</span><span class="s3">\n </span><span class="s1">* toRoute('/example/index/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/example'</span><span class="s3">\n </span><span class="s1">* toRoute('/example/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/'</span><span class="s3">\n </span><span class="s1">* toRoute('/index/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/'</span><span class="s3">\n </span><span class="s1">* toRoute('/');</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function toRoute(pathname: string): string {</span><span class="s3">\n  </span><span class="s1">return pathname.replace(/(?:</span><span class="s3">\\</span><span class="s1">/index)?</span><span class="s3">\\</span><span class="s1">/?$/, '') || '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { CacheFs } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { PrerenderManifest } from '../../../build'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheEntry,</span><span class="s3">\n  </span><span class="s1">type IncrementalCache as IncrementalCacheType,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">type IncrementalFetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">type GetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type GetIncrementalResponseCacheContext,</span><span class="s3">\n  </span><span class="s1">type CachedFetchValue,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalResponseCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">import FileSystemCache from './file-system-cache'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CACHE_ONE_YEAR,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { toRoute } from '../to-route'</span><span class="s3">\n</span><span class="s1">import { SharedCacheControls } from './shared-cache-controls.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getPrerenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">getRenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import type { Revalidate } from '../cache-control'</span><span class="s3">\n</span><span class="s1">import { getPreviouslyRevalidatedTags } from '../../server-utils'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../../lib/detached-promise'</span><span class="s3">\n\n</span><span class="s1">export interface CacheHandlerContext {</span><span class="s3">\n  </span><span class="s1">fs?: CacheFs</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">flushToDisk?: boolean</span><span class="s3">\n  </span><span class="s1">serverDistDir?: string</span><span class="s3">\n  </span><span class="s1">maxMemoryCacheSize?: number</span><span class="s3">\n  </span><span class="s1">fetchCacheKeyPrefix?: string</span><span class="s3">\n  </span><span class="s1">prerenderManifest?: PrerenderManifest</span><span class="s3">\n  </span><span class="s1">revalidatedTags: string[]</span><span class="s3">\n  </span><span class="s1">_requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CacheHandlerValue {</span><span class="s3">\n  </span><span class="s1">lastModified?: number</span><span class="s3">\n  </span><span class="s1">age?: number</span><span class="s3">\n  </span><span class="s1">cacheState?: string</span><span class="s3">\n  </span><span class="s1">value: IncrementalCacheValue | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class CacheHandler {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line</span><span class="s3">\n  </span><span class="s1">constructor(_ctx: CacheHandlerContext) {}</span><span class="s3">\n\n  </span><span class="s1">public async get(</span><span class="s3">\n    </span><span class="s1">_cacheKey: string,</span><span class="s3">\n    </span><span class="s1">_ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;CacheHandlerValue | null&gt; {</span><span class="s3">\n    </span><span class="s1">return {} as any</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async set(</span><span class="s3">\n    </span><span class="s1">_cacheKey: string,</span><span class="s3">\n    </span><span class="s1">_data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">_ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public async revalidateTag(</span><span class="s3">\n    </span><span class="s1">..._args: Parameters&lt;IncrementalCache['revalidateTag']&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public resetRequestCache(): void {}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class IncrementalCache implements IncrementalCacheType {</span><span class="s3">\n  </span><span class="s1">readonly dev?: boolean</span><span class="s3">\n  </span><span class="s1">readonly disableForTestmode?: boolean</span><span class="s3">\n  </span><span class="s1">readonly cacheHandler?: CacheHandler</span><span class="s3">\n  </span><span class="s1">readonly hasCustomCacheHandler: boolean</span><span class="s3">\n  </span><span class="s1">readonly prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">readonly requestHeaders: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n  </span><span class="s1">readonly allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n  </span><span class="s1">readonly minimalMode?: boolean</span><span class="s3">\n  </span><span class="s1">readonly fetchCacheKeyPrefix?: string</span><span class="s3">\n  </span><span class="s1">readonly revalidatedTags?: string[]</span><span class="s3">\n  </span><span class="s1">readonly isOnDemandRevalidate?: boolean</span><span class="s3">\n\n  </span><span class="s1">private static readonly debug: boolean =</span><span class="s3">\n    </span><span class="s1">!!process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">private readonly locks = new Map&lt;string, Promise&lt;void&gt;&gt;()</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cache controls for routes. This will source the values from the</span><span class="s3">\n   </span><span class="s1">* prerender manifest until the in-memory cache is updated with new values.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly cacheControls: SharedCacheControls</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">fs,</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">flushToDisk,</span><span class="s3">\n    </span><span class="s1">minimalMode,</span><span class="s3">\n    </span><span class="s1">serverDistDir,</span><span class="s3">\n    </span><span class="s1">requestHeaders,</span><span class="s3">\n    </span><span class="s1">maxMemoryCacheSize,</span><span class="s3">\n    </span><span class="s1">getPrerenderManifest,</span><span class="s3">\n    </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n    </span><span class="s1">CurCacheHandler,</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">fs?: CacheFs</span><span class="s3">\n    </span><span class="s1">dev: boolean</span><span class="s3">\n    </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n    </span><span class="s1">serverDistDir?: string</span><span class="s3">\n    </span><span class="s1">flushToDisk?: boolean</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n    </span><span class="s1">requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n    </span><span class="s1">maxMemoryCacheSize?: number</span><span class="s3">\n    </span><span class="s1">getPrerenderManifest: () =&gt; DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">fetchCacheKeyPrefix?: string</span><span class="s3">\n    </span><span class="s1">CurCacheHandler?: typeof CacheHandler</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">this.hasCustomCacheHandler = Boolean(CurCacheHandler)</span><span class="s3">\n\n    </span><span class="s1">const cacheHandlersSymbol = Symbol.for('@next/cache-handlers')</span><span class="s3">\n    </span><span class="s1">const _globalThis: typeof globalThis &amp; {</span><span class="s3">\n      </span><span class="s1">[cacheHandlersSymbol]?: {</span><span class="s3">\n        </span><span class="s1">FetchCache?: typeof CacheHandler</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} = globalThis</span><span class="s3">\n\n    </span><span class="s1">if (!CurCacheHandler) {</span><span class="s3">\n      </span><span class="s1">// if we have a global cache handler available leverage it</span><span class="s3">\n      </span><span class="s1">const globalCacheHandler = _globalThis[cacheHandlersSymbol]</span><span class="s3">\n\n      </span><span class="s1">if (globalCacheHandler?.FetchCache) {</span><span class="s3">\n        </span><span class="s1">CurCacheHandler = globalCacheHandler.FetchCache</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (fs &amp;&amp; serverDistDir) {</span><span class="s3">\n          </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n            </span><span class="s1">console.log('using filesystem cache handler')</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">CurCacheHandler = FileSystemCache</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (IncrementalCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('using custom cache handler', CurCacheHandler.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {</span><span class="s3">\n      </span><span class="s1">// Allow cache size to be overridden for testing purposes</span><span class="s3">\n      </span><span class="s1">maxMemoryCacheSize = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.dev = dev</span><span class="s3">\n    </span><span class="s1">this.disableForTestmode = process.env.NEXT_PRIVATE_TEST_PROXY === 'true'</span><span class="s3">\n    </span><span class="s1">// this is a hack to avoid Webpack knowing this is equal to this.minimalMode</span><span class="s3">\n    </span><span class="s1">// because we replace this.minimalMode to true in production bundles.</span><span class="s3">\n    </span><span class="s1">const minimalModeKey = 'minimalMode'</span><span class="s3">\n    </span><span class="s1">this[minimalModeKey] = minimalMode</span><span class="s3">\n    </span><span class="s1">this.requestHeaders = requestHeaders</span><span class="s3">\n    </span><span class="s1">this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys</span><span class="s3">\n    </span><span class="s1">this.prerenderManifest = getPrerenderManifest()</span><span class="s3">\n    </span><span class="s1">this.cacheControls = new SharedCacheControls(this.prerenderManifest)</span><span class="s3">\n    </span><span class="s1">this.fetchCacheKeyPrefix = fetchCacheKeyPrefix</span><span class="s3">\n    </span><span class="s1">let revalidatedTags: string[] = []</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">requestHeaders[PRERENDER_REVALIDATE_HEADER] ===</span><span class="s3">\n      </span><span class="s1">this.prerenderManifest?.preview?.previewModeId</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.isOnDemandRevalidate = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (minimalMode) {</span><span class="s3">\n      </span><span class="s1">revalidatedTags = getPreviouslyRevalidatedTags(</span><span class="s3">\n        </span><span class="s1">requestHeaders,</span><span class="s3">\n        </span><span class="s1">this.prerenderManifest?.preview?.previewModeId</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (CurCacheHandler) {</span><span class="s3">\n      </span><span class="s1">this.cacheHandler = new CurCacheHandler({</span><span class="s3">\n        </span><span class="s1">dev,</span><span class="s3">\n        </span><span class="s1">fs,</span><span class="s3">\n        </span><span class="s1">flushToDisk,</span><span class="s3">\n        </span><span class="s1">serverDistDir,</span><span class="s3">\n        </span><span class="s1">revalidatedTags,</span><span class="s3">\n        </span><span class="s1">maxMemoryCacheSize,</span><span class="s3">\n        </span><span class="s1">_requestHeaders: requestHeaders,</span><span class="s3">\n        </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private calculateRevalidate(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">fromTime: number,</span><span class="s3">\n    </span><span class="s1">dev: boolean,</span><span class="s3">\n    </span><span class="s1">isFallback: boolean | undefined</span><span class="s3">\n  </span><span class="s1">): Revalidate {</span><span class="s3">\n    </span><span class="s1">// in development we don't have a prerender-manifest</span><span class="s3">\n    </span><span class="s1">// and default to always revalidating to allow easier debugging</span><span class="s3">\n    </span><span class="s1">if (dev)</span><span class="s3">\n      </span><span class="s1">return Math.floor(performance.timeOrigin + performance.now() - 1000)</span><span class="s3">\n\n    </span><span class="s1">const cacheControl = this.cacheControls.get(toRoute(pathname))</span><span class="s3">\n\n    </span><span class="s1">// if an entry isn't present in routes we fallback to a default</span><span class="s3">\n    </span><span class="s1">// of revalidating after 1 second unless it's a fallback request.</span><span class="s3">\n    </span><span class="s1">const initialRevalidateSeconds = cacheControl</span><span class="s3">\n      </span><span class="s1">? cacheControl.revalidate</span><span class="s3">\n      </span><span class="s1">: isFallback</span><span class="s3">\n        </span><span class="s1">? false</span><span class="s3">\n        </span><span class="s1">: 1</span><span class="s3">\n\n    </span><span class="s1">const revalidateAfter =</span><span class="s3">\n      </span><span class="s1">typeof initialRevalidateSeconds === 'number'</span><span class="s3">\n        </span><span class="s1">? initialRevalidateSeconds * 1000 + fromTime</span><span class="s3">\n        </span><span class="s1">: initialRevalidateSeconds</span><span class="s3">\n\n    </span><span class="s1">return revalidateAfter</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_getPathname(pathname: string, fetchCache?: boolean) {</span><span class="s3">\n    </span><span class="s1">return fetchCache ? pathname : normalizePagePath(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">resetRequestCache() {</span><span class="s3">\n    </span><span class="s1">this.cacheHandler?.resetRequestCache?.()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async lock(cacheKey: string): Promise&lt;() =&gt; Promise&lt;void&gt; | void&gt; {</span><span class="s3">\n    </span><span class="s1">// Wait for any existing lock on this cache key to be released</span><span class="s3">\n    </span><span class="s1">// This implements a simple queue-based locking mechanism</span><span class="s3">\n    </span><span class="s1">while (true) {</span><span class="s3">\n      </span><span class="s1">const lock = this.locks.get(cacheKey)</span><span class="s3">\n\n      </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n        </span><span class="s1">console.log('lock get', cacheKey, !!lock)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If no lock exists, we can proceed to acquire it</span><span class="s3">\n      </span><span class="s1">if (!lock) break</span><span class="s3">\n\n      </span><span class="s1">// Wait for the existing lock to be released before trying again</span><span class="s3">\n      </span><span class="s1">await lock</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Create a new detached promise that will represent this lock</span><span class="s3">\n    </span><span class="s1">// The resolve function (unlock) will be returned to the caller</span><span class="s3">\n    </span><span class="s1">const { resolve, promise } = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n\n    </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('successfully locked', cacheKey)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Store the lock promise in the locks map</span><span class="s3">\n    </span><span class="s1">this.locks.set(cacheKey, promise)</span><span class="s3">\n\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">// Resolve the promise to release the lock.</span><span class="s3">\n      </span><span class="s1">resolve()</span><span class="s3">\n\n      </span><span class="s1">// Remove the lock from the map once it's released so that future gets</span><span class="s3">\n      </span><span class="s1">// can acquire the lock.</span><span class="s3">\n      </span><span class="s1">this.locks.delete(cacheKey)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async revalidateTag(tags: string | string[]): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return this.cacheHandler?.revalidateTag(tags)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23</span><span class="s3">\n  </span><span class="s1">async generateCacheKey(</span><span class="s3">\n    </span><span class="s1">url: string,</span><span class="s3">\n    </span><span class="s1">init: RequestInit | Request = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">// this should be bumped anytime a fix is made to cache entries</span><span class="s3">\n    </span><span class="s1">// that should bust the cache</span><span class="s3">\n    </span><span class="s1">const MAIN_KEY_PREFIX = 'v3'</span><span class="s3">\n\n    </span><span class="s1">const bodyChunks: string[] = []</span><span class="s3">\n\n    </span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n    </span><span class="s1">const decoder = new TextDecoder()</span><span class="s3">\n\n    </span><span class="s1">if (init.body) {</span><span class="s3">\n      </span><span class="s1">// handle Uint8Array body</span><span class="s3">\n      </span><span class="s1">if (init.body instanceof Uint8Array) {</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(decoder.decode(init.body))</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n      </span><span class="s1">} // handle ReadableStream body</span><span class="s3">\n      </span><span class="s1">else if (typeof (init.body as any).getReader === 'function') {</span><span class="s3">\n        </span><span class="s1">const readableBody = init.body as ReadableStream&lt;Uint8Array | string&gt;</span><span class="s3">\n\n        </span><span class="s1">const chunks: Uint8Array[] = []</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">await readableBody.pipeTo(</span><span class="s3">\n            </span><span class="s1">new WritableStream({</span><span class="s3">\n              </span><span class="s1">write(chunk) {</span><span class="s3">\n                </span><span class="s1">if (typeof chunk === 'string') {</span><span class="s3">\n                  </span><span class="s1">chunks.push(encoder.encode(chunk))</span><span class="s3">\n                  </span><span class="s1">bodyChunks.push(chunk)</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                  </span><span class="s1">chunks.push(chunk)</span><span class="s3">\n                  </span><span class="s1">bodyChunks.push(decoder.decode(chunk, { stream: true }))</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// Flush the decoder.</span><span class="s3">\n          </span><span class="s1">bodyChunks.push(decoder.decode())</span><span class="s3">\n\n          </span><span class="s1">// Create a new buffer with all the chunks.</span><span class="s3">\n          </span><span class="s1">const length = chunks.reduce((total, arr) =&gt; total + arr.length, 0)</span><span class="s3">\n          </span><span class="s1">const arrayBuffer = new Uint8Array(length)</span><span class="s3">\n\n          </span><span class="s1">// Push each of the chunks into the new array buffer.</span><span class="s3">\n          </span><span class="s1">let offset = 0</span><span class="s3">\n          </span><span class="s1">for (const chunk of chunks) {</span><span class="s3">\n            </span><span class="s1">arrayBuffer.set(chunk, offset)</span><span class="s3">\n            </span><span class="s1">offset += chunk.length</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">;(init as any)._ogBody = arrayBuffer</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">console.error('Problem reading body', err)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // handle FormData or URLSearchParams bodies</span><span class="s3">\n      </span><span class="s1">else if (typeof (init.body as any).keys === 'function') {</span><span class="s3">\n        </span><span class="s1">const formData = init.body as FormData</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n        </span><span class="s1">for (const key of new Set([...formData.keys()])) {</span><span class="s3">\n          </span><span class="s1">const values = formData.getAll(key)</span><span class="s3">\n          </span><span class="s1">bodyChunks.push(</span><span class="s3">\n            </span><span class="s1">`${key}=${(</span><span class="s3">\n              </span><span class="s1">await Promise.all(</span><span class="s3">\n                </span><span class="s1">values.map(async (val) =&gt; {</span><span class="s3">\n                  </span><span class="s1">if (typeof val === 'string') {</span><span class="s3">\n                    </span><span class="s1">return val</span><span class="s3">\n                  </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">return await val.text()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">).join(',')}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// handle blob body</span><span class="s3">\n      </span><span class="s1">} else if (typeof (init.body as any).arrayBuffer === 'function') {</span><span class="s3">\n        </span><span class="s1">const blob = init.body as Blob</span><span class="s3">\n        </span><span class="s1">const arrayBuffer = await blob.arrayBuffer()</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(await blob.text())</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = new Blob([arrayBuffer], { type: blob.type })</span><span class="s3">\n      </span><span class="s1">} else if (typeof init.body === 'string') {</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(init.body)</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const headers =</span><span class="s3">\n      </span><span class="s1">typeof (init.headers || {}).keys === 'function'</span><span class="s3">\n        </span><span class="s1">? Object.fromEntries(init.headers as Headers)</span><span class="s3">\n        </span><span class="s1">: Object.assign({}, init.headers)</span><span class="s3">\n\n    </span><span class="s1">// w3c trace context headers can break request caching and deduplication</span><span class="s3">\n    </span><span class="s1">// so we remove them from the cache key</span><span class="s3">\n    </span><span class="s1">if ('traceparent' in headers) delete headers['traceparent']</span><span class="s3">\n    </span><span class="s1">if ('tracestate' in headers) delete headers['tracestate']</span><span class="s3">\n\n    </span><span class="s1">const cacheString = JSON.stringify([</span><span class="s3">\n      </span><span class="s1">MAIN_KEY_PREFIX,</span><span class="s3">\n      </span><span class="s1">this.fetchCacheKeyPrefix || '',</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">init.method,</span><span class="s3">\n      </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">init.mode,</span><span class="s3">\n      </span><span class="s1">init.redirect,</span><span class="s3">\n      </span><span class="s1">init.credentials,</span><span class="s3">\n      </span><span class="s1">init.referrer,</span><span class="s3">\n      </span><span class="s1">init.referrerPolicy,</span><span class="s3">\n      </span><span class="s1">init.integrity,</span><span class="s3">\n      </span><span class="s1">init.cache,</span><span class="s3">\n      </span><span class="s1">bodyChunks,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">function bufferToHex(buffer: ArrayBuffer): string {</span><span class="s3">\n        </span><span class="s1">return Array.prototype.map</span><span class="s3">\n          </span><span class="s1">.call(new Uint8Array(buffer), (b) =&gt; b.toString(16).padStart(2, '0'))</span><span class="s3">\n          </span><span class="s1">.join('')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const buffer = encoder.encode(cacheString)</span><span class="s3">\n      </span><span class="s1">return bufferToHex(await crypto.subtle.digest('SHA-256', buffer))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const crypto = require('crypto') as typeof import('crypto')</span><span class="s3">\n      </span><span class="s1">return crypto.createHash('sha256').update(cacheString).digest('hex')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalFetchCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">// Unlike other caches if we have a resume data cache, we use it even if</span><span class="s3">\n    </span><span class="s1">// testmode would normally disable it or if requestHeaders say 'no-cache'.</span><span class="s3">\n    </span><span class="s1">if (ctx.kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const resumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getRenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">if (resumeDataCache) {</span><span class="s3">\n        </span><span class="s1">const memoryCacheData = resumeDataCache.fetch.get(cacheKey)</span><span class="s3">\n        </span><span class="s1">if (memoryCacheData?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n          </span><span class="s1">return { isStale: false, value: memoryCacheData }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// we don't leverage the prerender cache in dev mode</span><span class="s3">\n    </span><span class="s1">// so that getStaticProps is always called for easier debugging</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this.disableForTestmode ||</span><span class="s3">\n      </span><span class="s1">(this.dev &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(ctx.kind !== IncrementalCacheKind.FETCH ||</span><span class="s3">\n          </span><span class="s1">this.requestHeaders['cache-control'] === 'no-cache'))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">cacheKey = this._getPathname(</span><span class="s3">\n      </span><span class="s1">cacheKey,</span><span class="s3">\n      </span><span class="s1">ctx.kind === IncrementalCacheKind.FETCH</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const cacheData = await this.cacheHandler?.get(cacheKey, ctx)</span><span class="s3">\n\n    </span><span class="s1">if (ctx.kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">if (!cacheData) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheData.value?.kind !== CachedRouteKind.FETCH) {</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">`Expected cached value for cache key ${JSON.stringify(cacheKey)} to be a </span><span class="s3">\&quot;</span><span class="s1">FETCH</span><span class="s3">\&quot; </span><span class="s1">kind, got ${JSON.stringify(cacheData.value?.kind)} instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const combinedTags = [...(ctx.tags || []), ...(ctx.softTags || [])]</span><span class="s3">\n      </span><span class="s1">// if a tag was revalidated we don't return stale data</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">combinedTags.some(</span><span class="s3">\n          </span><span class="s1">(tag) =&gt;</span><span class="s3">\n            </span><span class="s1">this.revalidatedTags?.includes(tag) ||</span><span class="s3">\n            </span><span class="s1">workStore?.pendingRevalidatedTags?.includes(tag)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const revalidate = ctx.revalidate || cacheData.value.revalidate</span><span class="s3">\n      </span><span class="s1">const age =</span><span class="s3">\n        </span><span class="s1">(performance.timeOrigin +</span><span class="s3">\n          </span><span class="s1">performance.now() -</span><span class="s3">\n          </span><span class="s1">(cacheData.lastModified || 0)) /</span><span class="s3">\n        </span><span class="s1">1000</span><span class="s3">\n\n      </span><span class="s1">const isStale = age &gt; revalidate</span><span class="s3">\n      </span><span class="s1">const data = cacheData.value.data</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">value: { kind: CachedRouteKind.FETCH, data, revalidate },</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (cacheData?.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">`Expected cached value for cache key ${JSON.stringify(cacheKey)} not to be a ${JSON.stringify(ctx.kind)} kind, got </span><span class="s3">\&quot;</span><span class="s1">FETCH</span><span class="s3">\&quot; </span><span class="s1">instead.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let entry: IncrementalResponseCacheEntry | null = null</span><span class="s3">\n    </span><span class="s1">const cacheControl = this.cacheControls.get(toRoute(cacheKey))</span><span class="s3">\n\n    </span><span class="s1">let isStale: boolean | -1 | undefined</span><span class="s3">\n    </span><span class="s1">let revalidateAfter: Revalidate</span><span class="s3">\n\n    </span><span class="s1">if (cacheData?.lastModified === -1) {</span><span class="s3">\n      </span><span class="s1">isStale = -1</span><span class="s3">\n      </span><span class="s1">revalidateAfter = -1 * CACHE_ONE_YEAR</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">revalidateAfter = this.calculateRevalidate(</span><span class="s3">\n        </span><span class="s1">cacheKey,</span><span class="s3">\n        </span><span class="s1">cacheData?.lastModified || performance.timeOrigin + performance.now(),</span><span class="s3">\n        </span><span class="s1">this.dev ?? false,</span><span class="s3">\n        </span><span class="s1">ctx.isFallback</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">isStale =</span><span class="s3">\n        </span><span class="s1">revalidateAfter !== false &amp;&amp;</span><span class="s3">\n        </span><span class="s1">revalidateAfter &lt; performance.timeOrigin + performance.now()</span><span class="s3">\n          </span><span class="s1">? true</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (cacheData) {</span><span class="s3">\n      </span><span class="s1">entry = {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n        </span><span class="s1">revalidateAfter,</span><span class="s3">\n        </span><span class="s1">value: cacheData.value,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!cacheData &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.prerenderManifest.notFoundRoutes.includes(cacheKey)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// for the first hit after starting the server the cache</span><span class="s3">\n      </span><span class="s1">// may not have a way to save notFound: true so if</span><span class="s3">\n      </span><span class="s1">// the prerender-manifest marks this as notFound then we</span><span class="s3">\n      </span><span class="s1">// return that entry and trigger a cache set to give it a</span><span class="s3">\n      </span><span class="s1">// chance to update in-memory entries</span><span class="s3">\n      </span><span class="s1">entry = {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">value: null,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n        </span><span class="s1">revalidateAfter,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.set(cacheKey, entry.value, { ...ctx, cacheControl })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return entry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: CachedFetchValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">// Even if we otherwise disable caching for testMode or if no fetchCache is</span><span class="s3">\n    </span><span class="s1">// configured we still always stash results in the resume data cache if one</span><span class="s3">\n    </span><span class="s1">// exists. This is because this is a transient in memory cache that</span><span class="s3">\n    </span><span class="s1">// populates caches ahead of a dynamic render in dev mode to allow the RSC</span><span class="s3">\n    </span><span class="s1">// debug info to have the right environment associated to it.</span><span class="s3">\n    </span><span class="s1">if (data?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const prerenderResumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getPrerenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">if (prerenderResumeDataCache) {</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache.fetch.set(pathname, data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.disableForTestmode || (this.dev &amp;&amp; !ctx.fetchCache)) return</span><span class="s3">\n\n    </span><span class="s1">pathname = this._getPathname(pathname, ctx.fetchCache)</span><span class="s3">\n\n    </span><span class="s1">// FetchCache has upper limit of 2MB per-entry currently</span><span class="s3">\n    </span><span class="s1">const itemSize = JSON.stringify(data).length</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">ctx.fetchCache &amp;&amp;</span><span class="s3">\n      </span><span class="s1">itemSize &gt; 2 * 1024 * 1024 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We ignore the size limit when custom cache handler is being used, as it</span><span class="s3">\n      </span><span class="s1">// might not have this limit</span><span class="s3">\n      </span><span class="s1">!this.hasCustomCacheHandler &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We also ignore the size limit when it's an implicit build-time-only</span><span class="s3">\n      </span><span class="s1">// caching that the user isn't even aware of.</span><span class="s3">\n      </span><span class="s1">!ctx.isImplicitBuildTimeCache</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const warningText = `Failed to set Next.js data cache for ${ctx.fetchUrl || pathname}, items over 2MB can not be cached (${itemSize} bytes)`</span><span class="s3">\n\n      </span><span class="s1">if (this.dev) {</span><span class="s3">\n        </span><span class="s1">throw new Error(warningText)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">console.warn(warningText)</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">if (!ctx.fetchCache &amp;&amp; ctx.cacheControl) {</span><span class="s3">\n        </span><span class="s1">this.cacheControls.set(toRoute(pathname), ctx.cacheControl)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">await this.cacheHandler?.set(pathname, data, ctx)</span><span class="s3">\n    </span><span class="s1">} catch (error) {</span><span class="s3">\n      </span><span class="s1">console.warn('Failed to update prerender cache for', pathname, error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import DefaultCacheHandler from '../lib/cache-handlers/default.external'</span><span class="s3">\n</span><span class="s1">import type { CacheHandlerCompat } from '../lib/cache-handlers/types'</span><span class="s3">\n\n</span><span class="s1">const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">? (message: string, ...args: any[]) =&gt; {</span><span class="s3">\n      </span><span class="s1">console.log(`use-cache: ${message}`, ...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">const handlersSymbol = Symbol.for('@next/cache-handlers')</span><span class="s3">\n</span><span class="s1">const handlersMapSymbol = Symbol.for('@next/cache-handlers-map')</span><span class="s3">\n</span><span class="s1">const handlersSetSymbol = Symbol.for('@next/cache-handlers-set')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The reference to the cache handlers. We store the cache handlers on the</span><span class="s3">\n </span><span class="s1">* global object so that we can access the same instance across different</span><span class="s3">\n </span><span class="s1">* boundaries (such as different copies of the same module).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const reference: typeof globalThis &amp; {</span><span class="s3">\n  </span><span class="s1">[handlersSymbol]?: {</span><span class="s3">\n    </span><span class="s1">RemoteCache?: CacheHandlerCompat</span><span class="s3">\n    </span><span class="s1">DefaultCache?: CacheHandlerCompat</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[handlersMapSymbol]?: Map&lt;string, CacheHandlerCompat&gt;</span><span class="s3">\n  </span><span class="s1">[handlersSetSymbol]?: Set&lt;CacheHandlerCompat&gt;</span><span class="s3">\n</span><span class="s1">} = globalThis</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Initialize the cache handlers.</span><span class="s3">\n </span><span class="s1">* @returns `true` if the cache handlers were initialized, `false` if they were already initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function initializeCacheHandlers(): boolean {</span><span class="s3">\n  </span><span class="s1">// If the cache handlers have already been initialized, don't do it again.</span><span class="s3">\n  </span><span class="s1">if (reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">debug?.('cache handlers already initialized')</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">debug?.('initializing cache handlers')</span><span class="s3">\n  </span><span class="s1">reference[handlersMapSymbol] = new Map&lt;string, CacheHandlerCompat&gt;()</span><span class="s3">\n\n  </span><span class="s1">// Initialize the cache from the symbol contents first.</span><span class="s3">\n  </span><span class="s1">if (reference[handlersSymbol]) {</span><span class="s3">\n    </span><span class="s1">let fallback: CacheHandlerCompat</span><span class="s3">\n    </span><span class="s1">if (reference[handlersSymbol].DefaultCache) {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from symbol')</span><span class="s3">\n      </span><span class="s1">fallback = reference[handlersSymbol].DefaultCache</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n      </span><span class="s1">fallback = DefaultCacheHandler</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">reference[handlersMapSymbol].set('default', fallback)</span><span class="s3">\n\n    </span><span class="s1">if (reference[handlersSymbol].RemoteCache) {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from symbol')</span><span class="s3">\n      </span><span class="s1">reference[handlersMapSymbol].set(</span><span class="s3">\n        </span><span class="s1">'remote',</span><span class="s3">\n        </span><span class="s1">reference[handlersSymbol].RemoteCache</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n      </span><span class="s1">reference[handlersMapSymbol].set('remote', fallback)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n    </span><span class="s1">reference[handlersMapSymbol].set('default', DefaultCacheHandler)</span><span class="s3">\n    </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n    </span><span class="s1">reference[handlersMapSymbol].set('remote', DefaultCacheHandler)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Create a set of the cache handlers.</span><span class="s3">\n  </span><span class="s1">reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a cache handler by kind.</span><span class="s3">\n </span><span class="s1">* @param kind - The kind of cache handler to get.</span><span class="s3">\n </span><span class="s1">* @returns The cache handler, or `undefined` if it does not exist.</span><span class="s3">\n </span><span class="s1">* @throws If the cache handlers are not initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandler(kind: string): CacheHandlerCompat | undefined {</span><span class="s3">\n  </span><span class="s1">// This should never be called before initializeCacheHandlers.</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Cache handlers not initialized')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersMapSymbol].get(kind)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a set iterator over the cache handlers.</span><span class="s3">\n </span><span class="s1">* @returns An iterator over the cache handlers, or `undefined` if they are not</span><span class="s3">\n </span><span class="s1">* initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandlers():</span><span class="s3">\n  </span><span class="s1">| SetIterator&lt;CacheHandlerCompat&gt;</span><span class="s3">\n  </span><span class="s1">| undefined {</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersSetSymbol]) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersSetSymbol].values()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a map iterator over the cache handlers (keyed by kind).</span><span class="s3">\n </span><span class="s1">* @returns An iterator over the cache handler entries, or `undefined` if they</span><span class="s3">\n </span><span class="s1">* are not initialized.</span><span class="s3">\n </span><span class="s1">* @throws If the cache handlers are not initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandlerEntries():</span><span class="s3">\n  </span><span class="s1">| MapIterator&lt;[string, CacheHandlerCompat]&gt;</span><span class="s3">\n  </span><span class="s1">| undefined {</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersMapSymbol].entries()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set a cache handler by kind.</span><span class="s3">\n </span><span class="s1">* @param kind - The kind of cache handler to set.</span><span class="s3">\n </span><span class="s1">* @param cacheHandler - The cache handler to set.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setCacheHandler(</span><span class="s3">\n  </span><span class="s1">kind: string,</span><span class="s3">\n  </span><span class="s1">cacheHandler: CacheHandlerCompat</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// This should never be called before initializeCacheHandlers.</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Cache handlers not initialized')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">debug?.('setting cache handler for </span><span class="s3">\&quot;</span><span class="s1">%s</span><span class="s3">\&quot;</span><span class="s1">', kind)</span><span class="s3">\n  </span><span class="s1">reference[handlersMapSymbol].set(kind, cacheHandler)</span><span class="s3">\n  </span><span class="s1">reference[handlersSetSymbol].add(cacheHandler)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Interop between </span><span class="s3">\&quot;</span><span class="s1">export default</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">module.exports</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function interopDefault(mod: any) {</span><span class="s3">\n  </span><span class="s1">return mod.default || mod</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'node:http'</span><span class="s3">\n</span><span class="s1">import type { NextConfigComplete } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'node:url'</span><span class="s3">\n\n</span><span class="s1">export type RevalidateFn = (config: {</span><span class="s3">\n  </span><span class="s1">urlPath: string</span><span class="s3">\n  </span><span class="s1">revalidateHeaders: { [key: string]: string | string[] }</span><span class="s3">\n  </span><span class="s1">opts: { unstable_onlyGenerated?: boolean }</span><span class="s3">\n</span><span class="s1">}) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n</span><span class="s1">// The RouterServerContext contains instance specific</span><span class="s3">\n</span><span class="s1">// information that isn't available/relevant when</span><span class="s3">\n</span><span class="s1">// deployed in serverless environments, the key is</span><span class="s3">\n</span><span class="s1">// the relative project dir this allows separate contexts</span><span class="s3">\n</span><span class="s1">// when running multiple next instances in same process</span><span class="s3">\n</span><span class="s1">export type RouterServerContext = Record&lt;</span><span class="s3">\n  </span><span class="s1">string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">// hostname the server is started with</span><span class="s3">\n    </span><span class="s1">hostname?: string</span><span class="s3">\n    </span><span class="s1">// revalidate function to bypass going through network</span><span class="s3">\n    </span><span class="s1">// to invoke revalidate request (uses mocked req/res)</span><span class="s3">\n    </span><span class="s1">revalidate?: RevalidateFn</span><span class="s3">\n    </span><span class="s1">// function to render the 404 page</span><span class="s3">\n    </span><span class="s1">render404?: (</span><span class="s3">\n      </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n      </span><span class="s1">res: ServerResponse,</span><span class="s3">\n      </span><span class="s1">parsedUrl?: UrlWithParsedQuery,</span><span class="s3">\n      </span><span class="s1">setHeaders?: boolean</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n    </span><span class="s1">// current loaded public runtime config</span><span class="s3">\n    </span><span class="s1">publicRuntimeConfig?: NextConfigComplete['publicRuntimeConfig']</span><span class="s3">\n    </span><span class="s1">// exposing nextConfig for dev mode specifically</span><span class="s3">\n    </span><span class="s1">nextConfig?: NextConfigComplete</span><span class="s3">\n    </span><span class="s1">// whether running in custom server mode</span><span class="s3">\n    </span><span class="s1">isCustomServer?: boolean</span><span class="s3">\n    </span><span class="s1">// whether test proxy is enabled</span><span class="s3">\n    </span><span class="s1">experimentalTestProxy?: boolean</span><span class="s3">\n    </span><span class="s1">// allow dev server to log with original stack</span><span class="s3">\n    </span><span class="s1">logErrorWithOriginalStack?: (err: unknown, type: string) =&gt; void</span><span class="s3">\n    </span><span class="s1">// allow setting ISR status in dev</span><span class="s3">\n    </span><span class="s1">setIsrStatus?: (key: string, value: boolean | null) =&gt; void</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export const RouterServerContextSymbol = Symbol.for(</span><span class="s3">\n  </span><span class="s1">'@next/router-server-methods'</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export const routerServerGlobal = globalThis as typeof globalThis &amp; {</span><span class="s3">\n  </span><span class="s1">[RouterServerContextSymbol]?: RouterServerContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'node:http'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">InstrumentationOnRequestError,</span><span class="s3">\n  </span><span class="s1">RequestErrorContext,</span><span class="s3">\n</span><span class="s1">} from '../instrumentation/types'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'node:querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'node:url'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">PrerenderManifest,</span><span class="s3">\n  </span><span class="s1">RequiredServerFilesManifest,</span><span class="s3">\n</span><span class="s1">} from '../../build'</span><span class="s3">\n</span><span class="s1">import type { DevRoutesManifest } from '../lib/router-utils/setup-dev-bundler'</span><span class="s3">\n</span><span class="s1">import type { RouteDefinition } from '../route-definitions/route-definition'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">BUILD_ID_FILE,</span><span class="s3">\n  </span><span class="s1">BUILD_MANIFEST,</span><span class="s3">\n  </span><span class="s1">CLIENT_REFERENCE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">DYNAMIC_CSS_MANIFEST,</span><span class="s3">\n  </span><span class="s1">NEXT_FONT_MANIFEST,</span><span class="s3">\n  </span><span class="s1">PRERENDER_MANIFEST,</span><span class="s3">\n  </span><span class="s1">REACT_LOADABLE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">ROUTES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SERVER_FILES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SERVER_REFERENCE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SUBRESOURCE_INTEGRITY_MANIFEST,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { parseReqUrl } from '../../lib/url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">normalizeLocalePath,</span><span class="s3">\n  </span><span class="s1">type PathLocale,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { getServerUtils } from '../server-utils'</span><span class="s3">\n</span><span class="s1">import { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import { checkIsOnDemandRevalidate } from '../api-utils'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../types'</span><span class="s3">\n</span><span class="s1">import type { BuildManifest } from '../get-page-files'</span><span class="s3">\n</span><span class="s1">import type { ReactLoadableManifest } from '../load-components'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import { normalizeDataPath } from '../../shared/lib/page-path/normalize-data-path'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'</span><span class="s3">\n</span><span class="s1">import { addRequestMeta, getRequestMeta } from '../request-meta'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n</span><span class="s1">import { isStaticMetadataRoute } from '../../lib/metadata/is-metadata-route'</span><span class="s3">\n</span><span class="s1">import { IncrementalCache } from '../lib/incremental-cache'</span><span class="s3">\n</span><span class="s1">import { initializeCacheHandlers, setCacheHandler } from '../use-cache/handlers'</span><span class="s3">\n</span><span class="s1">import { interopDefault } from '../app-render/interop-default'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { I18NConfig, NextConfigComplete } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import ResponseCache, { type ResponseGenerator } from '../response-cache'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RouterServerContextSymbol,</span><span class="s3">\n  </span><span class="s1">routerServerGlobal,</span><span class="s3">\n  </span><span class="s1">type RouterServerContext,</span><span class="s3">\n</span><span class="s1">} from '../lib/router-utils/router-server-context'</span><span class="s3">\n</span><span class="s1">import { decodePathParams } from '../lib/router-utils/decode-path-params'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../../lib/generate-interception-routes-rewrites'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RouteModuleOptions is the options that are passed to the route module, other</span><span class="s3">\n </span><span class="s1">* route modules should extend this class to add specific options for their</span><span class="s3">\n </span><span class="s1">* route.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RouteModuleOptions&lt;</span><span class="s3">\n  </span><span class="s1">D extends RouteDefinition = RouteDefinition,</span><span class="s3">\n  </span><span class="s1">U = unknown,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">readonly definition: Readonly&lt;D&gt;</span><span class="s3">\n  </span><span class="s1">readonly userland: Readonly&lt;U&gt;</span><span class="s3">\n  </span><span class="s1">readonly distDir: string</span><span class="s3">\n  </span><span class="s1">readonly relativeProjectDir: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RouteHandlerContext is the base context for a route handler.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RouteModuleHandleContext {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Any matched parameters for the request. This is only defined for dynamic</span><span class="s3">\n   </span><span class="s1">* routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">params: Record&lt;string, string | string[] | undefined&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const dynamicImportEsmDefault = (id: string) =&gt;</span><span class="s3">\n  </span><span class="s1">import(/* webpackIgnore: true */ /* turbopackIgnore: true */ id).then(</span><span class="s3">\n    </span><span class="s1">(mod) =&gt; mod.default || mod</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RouteModule is the base class for all route modules. This class should be</span><span class="s3">\n </span><span class="s1">* extended by all route modules.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export abstract class RouteModule&lt;</span><span class="s3">\n  </span><span class="s1">D extends RouteDefinition = RouteDefinition,</span><span class="s3">\n  </span><span class="s1">U = unknown,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The userland module. This is the module that is exported from the user's</span><span class="s3">\n   </span><span class="s1">* code. This is marked as readonly to ensure that the module is not mutated</span><span class="s3">\n   </span><span class="s1">* because the module (when compiled) only provides getters.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly userland: Readonly&lt;U&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The definition of the route.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly definition: Readonly&lt;D&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The shared modules that are exposed and required for the route module.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static readonly sharedModules: any</span><span class="s3">\n\n  </span><span class="s1">public isDev: boolean</span><span class="s3">\n  </span><span class="s1">public distDir: string</span><span class="s3">\n  </span><span class="s1">public isAppRouter?: boolean</span><span class="s3">\n  </span><span class="s1">public relativeProjectDir: string</span><span class="s3">\n  </span><span class="s1">public incrementCache?: IncrementalCache</span><span class="s3">\n  </span><span class="s1">public responseCache?: ResponseCache</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">userland,</span><span class="s3">\n    </span><span class="s1">definition,</span><span class="s3">\n    </span><span class="s1">distDir,</span><span class="s3">\n    </span><span class="s1">relativeProjectDir,</span><span class="s3">\n  </span><span class="s1">}: RouteModuleOptions&lt;D, U&gt;) {</span><span class="s3">\n    </span><span class="s1">this.userland = userland</span><span class="s3">\n    </span><span class="s1">this.definition = definition</span><span class="s3">\n    </span><span class="s1">this.isDev = process.env.NODE_ENV === 'development'</span><span class="s3">\n    </span><span class="s1">this.distDir = distDir</span><span class="s3">\n    </span><span class="s1">this.relativeProjectDir = relativeProjectDir</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async instrumentationOnRequestError(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;InstrumentationOnRequestError&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">const { getEdgeInstrumentationModule } = await import('../web/globals')</span><span class="s3">\n      </span><span class="s1">const instrumentation = await getEdgeInstrumentationModule()</span><span class="s3">\n\n      </span><span class="s1">if (instrumentation) {</span><span class="s3">\n        </span><span class="s1">await instrumentation.onRequestError?.(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const { join } = require('node:path') as typeof import('node:path')</span><span class="s3">\n      </span><span class="s1">const absoluteProjectDir = join(</span><span class="s3">\n        </span><span class="s1">process.cwd(),</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const { instrumentationOnRequestError } = await import(</span><span class="s3">\n        </span><span class="s1">'../lib/router-utils/instrumentation-globals.external.js'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">return instrumentationOnRequestError(</span><span class="s3">\n        </span><span class="s1">absoluteProjectDir,</span><span class="s3">\n        </span><span class="s1">this.distDir,</span><span class="s3">\n        </span><span class="s1">...args</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private loadManifests(</span><span class="s3">\n    </span><span class="s1">srcPage: string,</span><span class="s3">\n    </span><span class="s1">projectDir?: string</span><span class="s3">\n  </span><span class="s1">): {</span><span class="s3">\n    </span><span class="s1">buildId: string</span><span class="s3">\n    </span><span class="s1">buildManifest: BuildManifest</span><span class="s3">\n    </span><span class="s1">fallbackBuildManifest: BuildManifest</span><span class="s3">\n    </span><span class="s1">routesManifest: DeepReadonly&lt;DevRoutesManifest&gt;</span><span class="s3">\n    </span><span class="s1">nextFontManifest: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n    </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">serverFilesManifest: RequiredServerFilesManifest</span><span class="s3">\n    </span><span class="s1">reactLoadableManifest: DeepReadonly&lt;ReactLoadableManifest&gt;</span><span class="s3">\n    </span><span class="s1">subresourceIntegrityManifest: any</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest: any</span><span class="s3">\n    </span><span class="s1">serverActionsManifest: any</span><span class="s3">\n    </span><span class="s1">dynamicCssManifest: any</span><span class="s3">\n    </span><span class="s1">interceptionRoutePatterns: RegExp[]</span><span class="s3">\n  </span><span class="s1">} {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">const { getEdgePreviewProps } =</span><span class="s3">\n        </span><span class="s1">require('../web/get-edge-preview-props') as typeof import('../web/get-edge-preview-props')</span><span class="s3">\n\n      </span><span class="s1">const maybeJSONParse = (str?: string) =&gt;</span><span class="s3">\n        </span><span class="s1">str ? JSON.parse(str) : undefined</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">buildId: process.env.__NEXT_BUILD_ID || '',</span><span class="s3">\n        </span><span class="s1">buildManifest: self.__BUILD_MANIFEST as any,</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest: {} as any,</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest: maybeJSONParse(self.__REACT_LOADABLE_MANIFEST),</span><span class="s3">\n        </span><span class="s1">nextFontManifest: maybeJSONParse(self.__NEXT_FONT_MANIFEST),</span><span class="s3">\n        </span><span class="s1">prerenderManifest: {</span><span class="s3">\n          </span><span class="s1">routes: {},</span><span class="s3">\n          </span><span class="s1">dynamicRoutes: {},</span><span class="s3">\n          </span><span class="s1">notFoundRoutes: [],</span><span class="s3">\n          </span><span class="s1">version: 4,</span><span class="s3">\n          </span><span class="s1">preview: getEdgePreviewProps(),</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">routesManifest: {</span><span class="s3">\n          </span><span class="s1">version: 4,</span><span class="s3">\n          </span><span class="s1">caseSensitive: Boolean(process.env.__NEXT_CASE_SENSITIVE_ROUTES),</span><span class="s3">\n          </span><span class="s1">basePath: process.env.__NEXT_BASE_PATH || '',</span><span class="s3">\n          </span><span class="s1">rewrites: (process.env.__NEXT_REWRITES as any) || {</span><span class="s3">\n            </span><span class="s1">beforeFiles: [],</span><span class="s3">\n            </span><span class="s1">afterFiles: [],</span><span class="s3">\n            </span><span class="s1">fallback: [],</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">redirects: [],</span><span class="s3">\n          </span><span class="s1">headers: [],</span><span class="s3">\n          </span><span class="s1">i18n:</span><span class="s3">\n            </span><span class="s1">(process.env.__NEXT_I18N_CONFIG as any as I18NConfig) || undefined,</span><span class="s3">\n          </span><span class="s1">skipMiddlewareUrlNormalize: Boolean(</span><span class="s3">\n            </span><span class="s1">process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">serverFilesManifest: {</span><span class="s3">\n          </span><span class="s1">config: (globalThis as any).nextConfig || {},</span><span class="s3">\n        </span><span class="s1">} as any,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest: self.__RSC_MANIFEST?.[srcPage],</span><span class="s3">\n        </span><span class="s1">serverActionsManifest: maybeJSONParse(self.__RSC_SERVER_MANIFEST),</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest: maybeJSONParse(</span><span class="s3">\n          </span><span class="s1">self.__SUBRESOURCE_INTEGRITY_MANIFEST</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest: maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST),</span><span class="s3">\n        </span><span class="s1">interceptionRoutePatterns: (</span><span class="s3">\n          </span><span class="s1">maybeJSONParse(self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST) ?? []</span><span class="s3">\n        </span><span class="s1">).map((rewrite: any) =&gt; new RegExp(rewrite.regex)),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (!projectDir) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Invariant: projectDir is required for node runtime')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { loadManifestFromRelativePath } =</span><span class="s3">\n        </span><span class="s1">require('../load-manifest.external') as typeof import('../load-manifest.external')</span><span class="s3">\n      </span><span class="s1">const normalizedPagePath = normalizePagePath(srcPage)</span><span class="s3">\n\n      </span><span class="s1">const [</span><span class="s3">\n        </span><span class="s1">routesManifest,</span><span class="s3">\n        </span><span class="s1">prerenderManifest,</span><span class="s3">\n        </span><span class="s1">buildManifest,</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest,</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest,</span><span class="s3">\n        </span><span class="s1">nextFontManifest,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n        </span><span class="s1">serverActionsManifest,</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n        </span><span class="s1">serverFilesManifest,</span><span class="s3">\n        </span><span class="s1">buildId,</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest,</span><span class="s3">\n      </span><span class="s1">] = [</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;DevRoutesManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: ROUTES_MANIFEST,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;PrerenderManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: PRERENDER_MANIFEST,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;BuildManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: BUILD_MANIFEST,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">srcPage === '/_error'</span><span class="s3">\n          </span><span class="s1">? loadManifestFromRelativePath&lt;BuildManifest&gt;({</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">manifest: `fallback-${BUILD_MANIFEST}`,</span><span class="s3">\n              </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n              </span><span class="s1">handleMissing: true,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: ({} as BuildManifest),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;ReactLoadableManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: process.env.TURBOPACK</span><span class="s3">\n            </span><span class="s1">? `server/${this.isAppRouter ? 'app' : 'pages'}${normalizedPagePath}/${REACT_LOADABLE_MANIFEST}`</span><span class="s3">\n            </span><span class="s1">: REACT_LOADABLE_MANIFEST,</span><span class="s3">\n          </span><span class="s1">handleMissing: true,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;NextFontManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: `server/${NEXT_FONT_MANIFEST}.json`,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">this.isAppRouter &amp;&amp; !isStaticMetadataRoute(srcPage)</span><span class="s3">\n          </span><span class="s1">? loadManifestFromRelativePath({</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">useEval: true,</span><span class="s3">\n              </span><span class="s1">handleMissing: true,</span><span class="s3">\n              </span><span class="s1">manifest: `server/app${srcPage.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST}.js`,</span><span class="s3">\n              </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n        </span><span class="s1">this.isAppRouter</span><span class="s3">\n          </span><span class="s1">? loadManifestFromRelativePath&lt;any&gt;({</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">manifest: `server/${SERVER_REFERENCE_MANIFEST}.json`,</span><span class="s3">\n              </span><span class="s1">handleMissing: true,</span><span class="s3">\n              </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: {},</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;Record&lt;string, string&gt;&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: `server/${SUBRESOURCE_INTEGRITY_MANIFEST}.json`,</span><span class="s3">\n          </span><span class="s1">handleMissing: true,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">this.isDev</span><span class="s3">\n          </span><span class="s1">? ({} as any)</span><span class="s3">\n          </span><span class="s1">: loadManifestFromRelativePath&lt;RequiredServerFilesManifest&gt;({</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">manifest: SERVER_FILES_MANIFEST,</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">this.isDev</span><span class="s3">\n          </span><span class="s1">? 'development'</span><span class="s3">\n          </span><span class="s1">: loadManifestFromRelativePath&lt;any&gt;({</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">manifest: BUILD_ID_FILE,</span><span class="s3">\n              </span><span class="s1">skipParse: true,</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;any&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: DYNAMIC_CSS_MANIFEST,</span><span class="s3">\n          </span><span class="s1">handleMissing: true,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">buildId,</span><span class="s3">\n        </span><span class="s1">buildManifest,</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest,</span><span class="s3">\n        </span><span class="s1">routesManifest,</span><span class="s3">\n        </span><span class="s1">nextFontManifest,</span><span class="s3">\n        </span><span class="s1">prerenderManifest,</span><span class="s3">\n        </span><span class="s1">serverFilesManifest,</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest: (clientReferenceManifest as any)</span><span class="s3">\n          </span><span class="s1">?.__RSC_MANIFEST?.[srcPage.replace(/%5F/g, '_')],</span><span class="s3">\n        </span><span class="s1">serverActionsManifest,</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest,</span><span class="s3">\n        </span><span class="s1">interceptionRoutePatterns: routesManifest.rewrites.beforeFiles</span><span class="s3">\n          </span><span class="s1">.filter(isInterceptionRouteRewrite)</span><span class="s3">\n          </span><span class="s1">.map((rewrite) =&gt; new RegExp(rewrite.regex)),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async loadCustomCacheHandlers(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">const { cacheHandlers } = nextConfig.experimental</span><span class="s3">\n      </span><span class="s1">if (!cacheHandlers) return</span><span class="s3">\n\n      </span><span class="s1">// If we've already initialized the cache handlers interface, don't do it</span><span class="s3">\n      </span><span class="s1">// again.</span><span class="s3">\n      </span><span class="s1">if (!initializeCacheHandlers()) return</span><span class="s3">\n\n      </span><span class="s1">for (const [kind, handler] of Object.entries(cacheHandlers)) {</span><span class="s3">\n        </span><span class="s1">if (!handler) continue</span><span class="s3">\n\n        </span><span class="s1">const { formatDynamicImportPath } =</span><span class="s3">\n          </span><span class="s1">require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')</span><span class="s3">\n\n        </span><span class="s1">const { join } = require('node:path') as typeof import('node:path')</span><span class="s3">\n        </span><span class="s1">const absoluteProjectDir = join(</span><span class="s3">\n          </span><span class="s1">process.cwd(),</span><span class="s3">\n          </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">setCacheHandler(</span><span class="s3">\n          </span><span class="s1">kind,</span><span class="s3">\n          </span><span class="s1">interopDefault(</span><span class="s3">\n            </span><span class="s1">await dynamicImportEsmDefault(</span><span class="s3">\n              </span><span class="s1">formatDynamicImportPath(</span><span class="s3">\n                </span><span class="s1">`${absoluteProjectDir}/${this.distDir}`,</span><span class="s3">\n                </span><span class="s1">handler</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async getIncrementalCache(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete,</span><span class="s3">\n    </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalCache&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">return (globalThis as any).__incrementalCache</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">let CacheHandler: any</span><span class="s3">\n      </span><span class="s1">const { cacheHandler } = nextConfig</span><span class="s3">\n\n      </span><span class="s1">if (cacheHandler) {</span><span class="s3">\n        </span><span class="s1">const { formatDynamicImportPath } =</span><span class="s3">\n          </span><span class="s1">require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')</span><span class="s3">\n\n        </span><span class="s1">CacheHandler = interopDefault(</span><span class="s3">\n          </span><span class="s1">await dynamicImportEsmDefault(</span><span class="s3">\n            </span><span class="s1">formatDynamicImportPath(this.distDir, cacheHandler)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { join } = require('node:path') as typeof import('node:path')</span><span class="s3">\n      </span><span class="s1">const projectDir = join(</span><span class="s3">\n        </span><span class="s1">process.cwd(),</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">await this.loadCustomCacheHandlers(req, nextConfig)</span><span class="s3">\n\n      </span><span class="s1">// incremental-cache is request specific</span><span class="s3">\n      </span><span class="s1">// although can have shared caches in module scope</span><span class="s3">\n      </span><span class="s1">// per-cache handler</span><span class="s3">\n      </span><span class="s1">return new IncrementalCache({</span><span class="s3">\n        </span><span class="s1">fs: (</span><span class="s3">\n          </span><span class="s1">require('../lib/node-fs-methods') as typeof import('../lib/node-fs-methods')</span><span class="s3">\n        </span><span class="s1">).nodeFs,</span><span class="s3">\n        </span><span class="s1">dev: this.isDev,</span><span class="s3">\n        </span><span class="s1">requestHeaders: req.headers,</span><span class="s3">\n        </span><span class="s1">allowedRevalidateHeaderKeys:</span><span class="s3">\n          </span><span class="s1">nextConfig.experimental.allowedRevalidateHeaderKeys,</span><span class="s3">\n        </span><span class="s1">minimalMode: getRequestMeta(req, 'minimalMode'),</span><span class="s3">\n        </span><span class="s1">serverDistDir: `${projectDir}/${this.distDir}/server`,</span><span class="s3">\n        </span><span class="s1">fetchCacheKeyPrefix: nextConfig.experimental.fetchCacheKeyPrefix,</span><span class="s3">\n        </span><span class="s1">maxMemoryCacheSize: nextConfig.cacheMaxMemorySize,</span><span class="s3">\n        </span><span class="s1">flushToDisk: nextConfig.experimental.isrFlushToDisk,</span><span class="s3">\n        </span><span class="s1">getPrerenderManifest: () =&gt; prerenderManifest,</span><span class="s3">\n        </span><span class="s1">CurCacheHandler: CacheHandler,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async onRequestError(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">err: unknown,</span><span class="s3">\n    </span><span class="s1">errorContext: RequestErrorContext,</span><span class="s3">\n    </span><span class="s1">routerServerContext?: RouterServerContext[string]</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (routerServerContext?.logErrorWithOriginalStack) {</span><span class="s3">\n      </span><span class="s1">routerServerContext.logErrorWithOriginalStack(err, 'app-dir')</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">console.error(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">await this.instrumentationOnRequestError(</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">path: req.url || '/',</span><span class="s3">\n        </span><span class="s1">headers: req.headers,</span><span class="s3">\n        </span><span class="s1">method: req.method || 'GET',</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">errorContext</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async prepare(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse | null,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">srcPage,</span><span class="s3">\n      </span><span class="s1">multiZoneDraftMode,</span><span class="s3">\n    </span><span class="s1">}: {</span><span class="s3">\n      </span><span class="s1">srcPage: string</span><span class="s3">\n      </span><span class="s1">multiZoneDraftMode?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;</span><span class="s3">\n    </span><span class="s1">| {</span><span class="s3">\n        </span><span class="s1">buildId: string</span><span class="s3">\n        </span><span class="s1">locale?: string</span><span class="s3">\n        </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n        </span><span class="s1">defaultLocale?: string</span><span class="s3">\n        </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n        </span><span class="s1">originalQuery: ParsedUrlQuery</span><span class="s3">\n        </span><span class="s1">originalPathname: string</span><span class="s3">\n        </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n        </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n        </span><span class="s1">previewData: PreviewData</span><span class="s3">\n        </span><span class="s1">pageIsDynamic: boolean</span><span class="s3">\n        </span><span class="s1">isDraftMode: boolean</span><span class="s3">\n        </span><span class="s1">resolvedPathname: string</span><span class="s3">\n        </span><span class="s1">isNextDataRequest: boolean</span><span class="s3">\n        </span><span class="s1">buildManifest: DeepReadonly&lt;BuildManifest&gt;</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest: DeepReadonly&lt;BuildManifest&gt;</span><span class="s3">\n        </span><span class="s1">nextFontManifest: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n        </span><span class="s1">serverFilesManifest: DeepReadonly&lt;RequiredServerFilesManifest&gt;</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest: DeepReadonly&lt;ReactLoadableManifest&gt;</span><span class="s3">\n        </span><span class="s1">routesManifest: DeepReadonly&lt;DevRoutesManifest&gt;</span><span class="s3">\n        </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n        </span><span class="s1">// we can't pull in the client reference type or it causes issues with</span><span class="s3">\n        </span><span class="s1">// our pre-compiled types</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest?: any</span><span class="s3">\n        </span><span class="s1">serverActionsManifest?: any</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest?: any</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest?: DeepReadonly&lt;Record&lt;string, string&gt;&gt;</span><span class="s3">\n        </span><span class="s1">isOnDemandRevalidate: boolean</span><span class="s3">\n        </span><span class="s1">revalidateOnlyGenerated: boolean</span><span class="s3">\n        </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n        </span><span class="s1">routerServerContext?: RouterServerContext[string]</span><span class="s3">\n        </span><span class="s1">interceptionRoutePatterns?: any</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">| undefined</span><span class="s3">\n  </span><span class="s1">&gt; {</span><span class="s3">\n    </span><span class="s1">let absoluteProjectDir: string | undefined</span><span class="s3">\n\n    </span><span class="s1">// edge runtime handles loading instrumentation at the edge adapter level</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">const { join, relative } =</span><span class="s3">\n        </span><span class="s1">require('node:path') as typeof import('node:path')</span><span class="s3">\n\n      </span><span class="s1">absoluteProjectDir = join(</span><span class="s3">\n        </span><span class="s1">process.cwd(),</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const absoluteDistDir = getRequestMeta(req, 'distDir')</span><span class="s3">\n\n      </span><span class="s1">if (absoluteDistDir) {</span><span class="s3">\n        </span><span class="s1">this.distDir = relative(absoluteProjectDir, absoluteDistDir)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { ensureInstrumentationRegistered } = await import(</span><span class="s3">\n        </span><span class="s1">'../lib/router-utils/instrumentation-globals.external.js'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// ensure instrumentation is registered and pass</span><span class="s3">\n      </span><span class="s1">// onRequestError below</span><span class="s3">\n      </span><span class="s1">ensureInstrumentationRegistered(absoluteProjectDir, this.distDir)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const manifests = await this.loadManifests(srcPage, absoluteProjectDir)</span><span class="s3">\n    </span><span class="s1">const { routesManifest, prerenderManifest, serverFilesManifest } = manifests</span><span class="s3">\n\n    </span><span class="s1">const { basePath, i18n, rewrites } = routesManifest</span><span class="s3">\n\n    </span><span class="s1">if (basePath) {</span><span class="s3">\n      </span><span class="s1">req.url = removePathPrefix(req.url || '/', basePath)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const parsedUrl = parseReqUrl(req.url || '/')</span><span class="s3">\n    </span><span class="s1">// if we couldn't parse the URL we can't continue</span><span class="s3">\n    </span><span class="s1">if (!parsedUrl) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let isNextDataRequest = false</span><span class="s3">\n\n    </span><span class="s1">if (pathHasPrefix(parsedUrl.pathname || '/', '/_next/data')) {</span><span class="s3">\n      </span><span class="s1">isNextDataRequest = true</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = normalizeDataPath(parsedUrl.pathname || '/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let originalPathname = parsedUrl.pathname || '/'</span><span class="s3">\n    </span><span class="s1">const originalQuery = { ...parsedUrl.query }</span><span class="s3">\n    </span><span class="s1">const pageIsDynamic = isDynamicRoute(srcPage)</span><span class="s3">\n\n    </span><span class="s1">let localeResult: PathLocale | undefined</span><span class="s3">\n    </span><span class="s1">let detectedLocale: string | undefined</span><span class="s3">\n\n    </span><span class="s1">if (i18n) {</span><span class="s3">\n      </span><span class="s1">localeResult = normalizeLocalePath(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '/',</span><span class="s3">\n        </span><span class="s1">i18n.locales</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (localeResult.detectedLocale) {</span><span class="s3">\n        </span><span class="s1">req.url = `${localeResult.pathname}${parsedUrl.search}`</span><span class="s3">\n        </span><span class="s1">originalPathname = localeResult.pathname</span><span class="s3">\n\n        </span><span class="s1">if (!detectedLocale) {</span><span class="s3">\n          </span><span class="s1">detectedLocale = localeResult.detectedLocale</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const serverUtils = getServerUtils({</span><span class="s3">\n      </span><span class="s1">page: srcPage,</span><span class="s3">\n      </span><span class="s1">i18n,</span><span class="s3">\n      </span><span class="s1">basePath,</span><span class="s3">\n      </span><span class="s1">rewrites,</span><span class="s3">\n      </span><span class="s1">pageIsDynamic,</span><span class="s3">\n      </span><span class="s1">trailingSlash: process.env.__NEXT_TRAILING_SLASH as any as boolean,</span><span class="s3">\n      </span><span class="s1">caseSensitive: Boolean(routesManifest.caseSensitive),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const domainLocale = detectDomainLocale(</span><span class="s3">\n      </span><span class="s1">i18n?.domains,</span><span class="s3">\n      </span><span class="s1">getHostname(parsedUrl, req.headers),</span><span class="s3">\n      </span><span class="s1">detectedLocale</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))</span><span class="s3">\n\n    </span><span class="s1">const defaultLocale = domainLocale?.defaultLocale || i18n?.defaultLocale</span><span class="s3">\n\n    </span><span class="s1">// Ensure parsedUrl.pathname includes locale before processing</span><span class="s3">\n    </span><span class="s1">// rewrites or they won't match correctly.</span><span class="s3">\n    </span><span class="s1">if (defaultLocale &amp;&amp; !detectedLocale) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname === '/' ? '' : parsedUrl.pathname}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const locale =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'locale') || detectedLocale || defaultLocale</span><span class="s3">\n\n    </span><span class="s1">const rewriteParamKeys = Object.keys(</span><span class="s3">\n      </span><span class="s1">serverUtils.handleRewrites(req, parsedUrl)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// after processing rewrites we want to remove locale</span><span class="s3">\n    </span><span class="s1">// from parsedUrl pathname</span><span class="s3">\n    </span><span class="s1">if (i18n) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = normalizeLocalePath(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '/',</span><span class="s3">\n        </span><span class="s1">i18n.locales</span><span class="s3">\n      </span><span class="s1">).pathname</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let params: Record&lt;string, undefined | string | string[]&gt; | undefined =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'params')</span><span class="s3">\n\n    </span><span class="s1">// attempt parsing from pathname</span><span class="s3">\n    </span><span class="s1">if (!params &amp;&amp; serverUtils.dynamicRouteMatcher) {</span><span class="s3">\n      </span><span class="s1">const paramsMatch = serverUtils.dynamicRouteMatcher(</span><span class="s3">\n        </span><span class="s1">normalizeDataPath(localeResult?.pathname || parsedUrl.pathname || '/')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const paramsResult = serverUtils.normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">paramsMatch || {},</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (paramsResult.hasValidParams) {</span><span class="s3">\n        </span><span class="s1">params = paramsResult.params</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Local </span><span class="s3">\&quot;</span><span class="s1">next start</span><span class="s3">\&quot; </span><span class="s1">expects the routing parsed query values</span><span class="s3">\n    </span><span class="s1">// to not be present in the URL although when deployed proxies</span><span class="s3">\n    </span><span class="s1">// will add query values from resolving the routes to pass to function.</span><span class="s3">\n\n    </span><span class="s1">// TODO: do we want to change expectations for </span><span class="s3">\&quot;</span><span class="s1">next start</span><span class="s3">\&quot;\n    </span><span class="s1">// to include these query values in the URL which affects asPath</span><span class="s3">\n    </span><span class="s1">// but would match deployed behavior, e.g. a rewrite from middleware</span><span class="s3">\n    </span><span class="s1">// that adds a query param would be in asPath as query but locally</span><span class="s3">\n    </span><span class="s1">// it won't be in the asPath but still available in the query object</span><span class="s3">\n    </span><span class="s1">const query = getRequestMeta(req, 'query') || {</span><span class="s3">\n      </span><span class="s1">...parsedUrl.query,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const routeParamKeys = new Set&lt;string&gt;()</span><span class="s3">\n    </span><span class="s1">const combinedParamKeys = []</span><span class="s3">\n\n    </span><span class="s1">// we don't include rewriteParamKeys in the combinedParamKeys</span><span class="s3">\n    </span><span class="s1">// for app router since the searchParams is populated from the</span><span class="s3">\n    </span><span class="s1">// URL so we don't want to strip the rewrite params from the URL</span><span class="s3">\n    </span><span class="s1">// so that searchParams can include them</span><span class="s3">\n    </span><span class="s1">if (!this.isAppRouter) {</span><span class="s3">\n      </span><span class="s1">for (const key of [</span><span class="s3">\n        </span><span class="s1">...rewriteParamKeys,</span><span class="s3">\n        </span><span class="s1">...Object.keys(serverUtils.defaultRouteMatches || {}),</span><span class="s3">\n      </span><span class="s1">]) {</span><span class="s3">\n        </span><span class="s1">// We only want to filter rewrite param keys from the URL</span><span class="s3">\n        </span><span class="s1">// if they are matches from the URL e.g. the key/value matches</span><span class="s3">\n        </span><span class="s1">// before and after applying the rewrites /:path for /hello and</span><span class="s3">\n        </span><span class="s1">// { path: 'hello' } but not for { path: 'another' } and /hello</span><span class="s3">\n        </span><span class="s1">// TODO: we should prefix rewrite param keys the same as we do</span><span class="s3">\n        </span><span class="s1">// for dynamic routes so we can identify them properly</span><span class="s3">\n        </span><span class="s1">const originalValue = Array.isArray(originalQuery[key])</span><span class="s3">\n          </span><span class="s1">? originalQuery[key].join('')</span><span class="s3">\n          </span><span class="s1">: originalQuery[key]</span><span class="s3">\n\n        </span><span class="s1">const queryValue = Array.isArray(query[key])</span><span class="s3">\n          </span><span class="s1">? query[key].join('')</span><span class="s3">\n          </span><span class="s1">: query[key]</span><span class="s3">\n\n        </span><span class="s1">if (!(key in originalQuery) || originalValue === queryValue) {</span><span class="s3">\n          </span><span class="s1">combinedParamKeys.push(key)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">serverUtils.normalizeCdnUrl(req, combinedParamKeys)</span><span class="s3">\n    </span><span class="s1">serverUtils.normalizeQueryParams(query, routeParamKeys)</span><span class="s3">\n    </span><span class="s1">serverUtils.filterInternalQuery(originalQuery, combinedParamKeys)</span><span class="s3">\n\n    </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n      </span><span class="s1">const queryResult = serverUtils.normalizeDynamicRouteParams(query, true)</span><span class="s3">\n\n      </span><span class="s1">const paramsResult = serverUtils.normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">params || {},</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const paramsToInterpolate: ParsedUrlQuery =</span><span class="s3">\n        </span><span class="s1">paramsResult.hasValidParams &amp;&amp; params</span><span class="s3">\n          </span><span class="s1">? params</span><span class="s3">\n          </span><span class="s1">: queryResult.hasValidParams</span><span class="s3">\n            </span><span class="s1">? query</span><span class="s3">\n            </span><span class="s1">: {}</span><span class="s3">\n\n      </span><span class="s1">req.url = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">req.url || '/',</span><span class="s3">\n        </span><span class="s1">paramsToInterpolate</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '/',</span><span class="s3">\n        </span><span class="s1">paramsToInterpolate</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">originalPathname = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">originalPathname,</span><span class="s3">\n        </span><span class="s1">paramsToInterpolate</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// try pulling from query if valid</span><span class="s3">\n      </span><span class="s1">if (!params) {</span><span class="s3">\n        </span><span class="s1">if (queryResult.hasValidParams) {</span><span class="s3">\n          </span><span class="s1">params = Object.assign({}, queryResult.params)</span><span class="s3">\n\n          </span><span class="s1">// If we pulled from query remove it so it's</span><span class="s3">\n          </span><span class="s1">// only in params</span><span class="s3">\n          </span><span class="s1">for (const key in serverUtils.defaultRouteMatches) {</span><span class="s3">\n            </span><span class="s1">delete query[key]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// use final params from URL matching</span><span class="s3">\n          </span><span class="s1">const paramsMatch = serverUtils.dynamicRouteMatcher?.(</span><span class="s3">\n            </span><span class="s1">normalizeDataPath(</span><span class="s3">\n              </span><span class="s1">localeResult?.pathname || parsedUrl.pathname || '/'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">// we don't normalize these as they are allowed to be</span><span class="s3">\n          </span><span class="s1">// the literal slug matches here e.g. /blog/[slug]</span><span class="s3">\n          </span><span class="s1">// actually being requested</span><span class="s3">\n          </span><span class="s1">if (paramsMatch) {</span><span class="s3">\n            </span><span class="s1">params = Object.assign({}, paramsMatch)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Remove any normalized params from the query if they</span><span class="s3">\n    </span><span class="s1">// weren't present as non-prefixed query key e.g.</span><span class="s3">\n    </span><span class="s1">// ?search=1&amp;nxtPsearch=hello we don't delete search</span><span class="s3">\n    </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n      </span><span class="s1">if (!(key in originalQuery)) {</span><span class="s3">\n        </span><span class="s1">delete query[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { isOnDemandRevalidate, revalidateOnlyGenerated } =</span><span class="s3">\n      </span><span class="s1">checkIsOnDemandRevalidate(req, prerenderManifest.preview)</span><span class="s3">\n\n    </span><span class="s1">let isDraftMode = false</span><span class="s3">\n    </span><span class="s1">let previewData: PreviewData</span><span class="s3">\n\n    </span><span class="s1">// preview data relies on non-edge utils</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge' &amp;&amp; res) {</span><span class="s3">\n      </span><span class="s1">const { tryGetPreviewData } =</span><span class="s3">\n        </span><span class="s1">require('../api-utils/node/try-get-preview-data') as typeof import('../api-utils/node/try-get-preview-data')</span><span class="s3">\n\n      </span><span class="s1">previewData = tryGetPreviewData(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">res,</span><span class="s3">\n        </span><span class="s1">prerenderManifest.preview,</span><span class="s3">\n        </span><span class="s1">Boolean(multiZoneDraftMode)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">isDraftMode = previewData !== false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const relativeProjectDir =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n\n    </span><span class="s1">const routerServerContext =</span><span class="s3">\n      </span><span class="s1">routerServerGlobal[RouterServerContextSymbol]?.[relativeProjectDir]</span><span class="s3">\n    </span><span class="s1">const nextConfig =</span><span class="s3">\n      </span><span class="s1">routerServerContext?.nextConfig || serverFilesManifest.config</span><span class="s3">\n\n    </span><span class="s1">const normalizedSrcPage = normalizeAppPath(srcPage)</span><span class="s3">\n    </span><span class="s1">let resolvedPathname =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'rewroteURL') || normalizedSrcPage</span><span class="s3">\n\n    </span><span class="s1">if (isDynamicRoute(resolvedPathname) &amp;&amp; params) {</span><span class="s3">\n      </span><span class="s1">resolvedPathname = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">resolvedPathname,</span><span class="s3">\n        </span><span class="s1">params</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (resolvedPathname === '/index') {</span><span class="s3">\n      </span><span class="s1">resolvedPathname = '/'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">resolvedPathname = decodePathParams(resolvedPathname)</span><span class="s3">\n    </span><span class="s1">} catch (_) {}</span><span class="s3">\n\n    </span><span class="s1">resolvedPathname = removeTrailingSlash(resolvedPathname)</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n      </span><span class="s1">originalQuery,</span><span class="s3">\n      </span><span class="s1">originalPathname,</span><span class="s3">\n      </span><span class="s1">params,</span><span class="s3">\n      </span><span class="s1">parsedUrl,</span><span class="s3">\n      </span><span class="s1">locale,</span><span class="s3">\n      </span><span class="s1">isNextDataRequest,</span><span class="s3">\n      </span><span class="s1">locales: i18n?.locales,</span><span class="s3">\n      </span><span class="s1">defaultLocale,</span><span class="s3">\n      </span><span class="s1">isDraftMode,</span><span class="s3">\n      </span><span class="s1">previewData,</span><span class="s3">\n      </span><span class="s1">pageIsDynamic,</span><span class="s3">\n      </span><span class="s1">resolvedPathname,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate,</span><span class="s3">\n      </span><span class="s1">revalidateOnlyGenerated,</span><span class="s3">\n      </span><span class="s1">...manifests,</span><span class="s3">\n      </span><span class="s1">serverActionsManifest: manifests.serverActionsManifest,</span><span class="s3">\n      </span><span class="s1">clientReferenceManifest: manifests.clientReferenceManifest,</span><span class="s3">\n      </span><span class="s1">nextConfig,</span><span class="s3">\n      </span><span class="s1">routerServerContext,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getResponseCache(req: IncomingMessage | BaseNextRequest) {</span><span class="s3">\n    </span><span class="s1">if (!this.responseCache) {</span><span class="s3">\n      </span><span class="s1">const minimalMode = getRequestMeta(req, 'minimalMode') ?? false</span><span class="s3">\n      </span><span class="s1">this.responseCache = new ResponseCache(minimalMode)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.responseCache</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async handleResponse({</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">nextConfig,</span><span class="s3">\n    </span><span class="s1">cacheKey,</span><span class="s3">\n    </span><span class="s1">routeKind,</span><span class="s3">\n    </span><span class="s1">isFallback,</span><span class="s3">\n    </span><span class="s1">prerenderManifest,</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n    </span><span class="s1">isOnDemandRevalidate,</span><span class="s3">\n    </span><span class="s1">revalidateOnlyGenerated,</span><span class="s3">\n    </span><span class="s1">responseGenerator,</span><span class="s3">\n    </span><span class="s1">waitUntil,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n    </span><span class="s1">cacheKey: string | null</span><span class="s3">\n    </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n    </span><span class="s1">isFallback?: boolean</span><span class="s3">\n    </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n    </span><span class="s1">revalidateOnlyGenerated?: boolean</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator</span><span class="s3">\n    </span><span class="s1">waitUntil?: (prom: Promise&lt;any&gt;) =&gt; void</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">const responseCache = this.getResponseCache(req)</span><span class="s3">\n    </span><span class="s1">const cacheEntry = await responseCache.get(cacheKey, responseGenerator, {</span><span class="s3">\n      </span><span class="s1">routeKind,</span><span class="s3">\n      </span><span class="s1">isFallback,</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate,</span><span class="s3">\n      </span><span class="s1">isPrefetch: req.headers.purpose === 'prefetch',</span><span class="s3">\n      </span><span class="s1">incrementalCache: await this.getIncrementalCache(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">nextConfig,</span><span class="s3">\n        </span><span class="s1">prerenderManifest</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">waitUntil,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (!cacheEntry) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">cacheKey &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// revalidate only generated can bail even if cacheKey is provided</span><span class="s3">\n        </span><span class="s1">!(isOnDemandRevalidate &amp;&amp; revalidateOnlyGenerated)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// A cache entry might not be generated if a response is written</span><span class="s3">\n        </span><span class="s1">// in `getInitialProps` or `getServerSideProps`, but those shouldn't</span><span class="s3">\n        </span><span class="s1">// have a cache key. If we do have a cache key but we don't end up</span><span class="s3">\n        </span><span class="s1">// with a cache entry, then either Next.js or the application has a</span><span class="s3">\n        </span><span class="s1">// bug that needs fixing.</span><span class="s3">\n        </span><span class="s1">throw new Error('invariant: cache entry required but not generated')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return cacheEntry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function isAppRouteRoute(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">return route.endsWith('/route')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* For a given page path, this function ensures that there is no backslash</span><span class="s3">\n </span><span class="s1">* escaping slashes in the path. Example:</span><span class="s3">\n </span><span class="s1">*  - `foo</span><span class="s3">\\</span><span class="s1">/bar</span><span class="s3">\\</span><span class="s1">/baz` -&gt; `foo/bar/baz`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizePathSep(path: string): string {</span><span class="s3">\n  </span><span class="s1">return path.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Key } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import { regexpToFunction } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A transformer function that will be applied to the regexp generated</span><span class="s3">\n   </span><span class="s1">* from the provided path and path-to-regexp.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">regexModifier?: (regex: string) =&gt; string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the function will remove all unnamed parameters</span><span class="s3">\n   </span><span class="s1">* from the matched parameters.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">removeUnnamedParams?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the regexp won't allow an optional trailing delimiter</span><span class="s3">\n   </span><span class="s1">* to match.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">strict?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the matcher will be case-sensitive, defaults to false</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">sensitive?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PatchMatcher = (</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">params?: Record&lt;string, any&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; Record&lt;string, any&gt; | false</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a path matcher function for a given path and options based on</span><span class="s3">\n </span><span class="s1">* path-to-regexp. By default the match will be case insensitive, non strict</span><span class="s3">\n </span><span class="s1">* and delimited by `/`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getPathMatch(path: string, options?: Options): PatchMatcher {</span><span class="s3">\n  </span><span class="s1">const keys: Key[] = []</span><span class="s3">\n  </span><span class="s1">const regexp = pathToRegexp(path, keys, {</span><span class="s3">\n    </span><span class="s1">delimiter: '/',</span><span class="s3">\n    </span><span class="s1">sensitive:</span><span class="s3">\n      </span><span class="s1">typeof options?.sensitive === 'boolean' ? options.sensitive : false,</span><span class="s3">\n    </span><span class="s1">strict: options?.strict,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const matcher = regexpToFunction&lt;Record&lt;string, any&gt;&gt;(</span><span class="s3">\n    </span><span class="s1">options?.regexModifier</span><span class="s3">\n      </span><span class="s1">? new RegExp(options.regexModifier(regexp.source), regexp.flags)</span><span class="s3">\n      </span><span class="s1">: regexp,</span><span class="s3">\n    </span><span class="s1">keys</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A matcher function that will check if a given pathname matches the path</span><span class="s3">\n   </span><span class="s1">* given in the builder function. When the path does not match it will return</span><span class="s3">\n   </span><span class="s1">* `false` but if it does it will return an object with the matched params</span><span class="s3">\n   </span><span class="s1">* merged with the params provided in the second argument.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">return (pathname, params) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If no pathname is provided it's not a match.</span><span class="s3">\n    </span><span class="s1">if (typeof pathname !== 'string') return false</span><span class="s3">\n\n    </span><span class="s1">const match = matcher(pathname)</span><span class="s3">\n\n    </span><span class="s1">// If the path did not match `false` will be returned.</span><span class="s3">\n    </span><span class="s1">if (!match) return false</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If unnamed params are not allowed they must be removed from</span><span class="s3">\n     </span><span class="s1">* the matched parameters. path-to-regexp uses </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">for named and</span><span class="s3">\n     </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">for unnamed parameters.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (options?.removeUnnamedParams) {</span><span class="s3">\n      </span><span class="s1">for (const key of keys) {</span><span class="s3">\n        </span><span class="s1">if (typeof key.name === 'number') {</span><span class="s3">\n          </span><span class="s1">delete match.params[key.name]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return { ...params, ...match.params }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isGroupSegment,</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n\n</span><span class="s1">const removeLeadingSlash = (segment: string): string =&gt; {</span><span class="s3">\n  </span><span class="s1">return segment[0] === '/' ? segment.slice(1) : segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const segmentToPathname = (segment: Segment): string =&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">// 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page</span><span class="s3">\n    </span><span class="s1">// if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.</span><span class="s3">\n    </span><span class="s1">if (segment === 'children') return ''</span><span class="s3">\n\n    </span><span class="s1">return segment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment[1]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function normalizeSegments(segments: string[]): string {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">segments.reduce((acc, segment) =&gt; {</span><span class="s3">\n      </span><span class="s1">segment = removeLeadingSlash(segment)</span><span class="s3">\n      </span><span class="s1">if (segment === '' || isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return acc</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${acc}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '') || '/'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractPathFromFlightRouterState(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">const segment = Array.isArray(flightRouterState[0])</span><span class="s3">\n    </span><span class="s1">? flightRouterState[0][1]</span><span class="s3">\n    </span><span class="s1">: flightRouterState[0]</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">segment === DEFAULT_SEGMENT_KEY ||</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some((m) =&gt; segment.startsWith(m))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n\n  </span><span class="s1">if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''</span><span class="s3">\n\n  </span><span class="s1">const segments = [segmentToPathname(segment)]</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = flightRouterState[1] ?? {}</span><span class="s3">\n\n  </span><span class="s1">const childrenPath = parallelRoutes.children</span><span class="s3">\n    </span><span class="s1">? extractPathFromFlightRouterState(parallelRoutes.children)</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">if (childrenPath !== undefined) {</span><span class="s3">\n    </span><span class="s1">segments.push(childrenPath)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of Object.entries(parallelRoutes)) {</span><span class="s3">\n      </span><span class="s1">if (key === 'children') continue</span><span class="s3">\n\n      </span><span class="s1">const childPath = extractPathFromFlightRouterState(value)</span><span class="s3">\n\n      </span><span class="s1">if (childPath !== undefined) {</span><span class="s3">\n        </span><span class="s1">segments.push(childPath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalizeSegments(segments)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeChangedPathImpl(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const [segmentA, parallelRoutesA] = treeA</span><span class="s3">\n  </span><span class="s1">const [segmentB, parallelRoutesB] = treeB</span><span class="s3">\n\n  </span><span class="s1">const normalizedSegmentA = segmentToPathname(segmentA)</span><span class="s3">\n  </span><span class="s1">const normalizedSegmentB = segmentToPathname(segmentB)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some(</span><span class="s3">\n      </span><span class="s1">(m) =&gt;</span><span class="s3">\n        </span><span class="s1">normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!matchSegment(segmentA, segmentB)) {</span><span class="s3">\n    </span><span class="s1">// once we find where the tree changed, we compute the rest of the path by traversing the tree</span><span class="s3">\n    </span><span class="s1">return extractPathFromFlightRouterState(treeB) ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRouterKey in parallelRoutesA) {</span><span class="s3">\n    </span><span class="s1">if (parallelRoutesB[parallelRouterKey]) {</span><span class="s3">\n      </span><span class="s1">const changedPath = computeChangedPathImpl(</span><span class="s3">\n        </span><span class="s1">parallelRoutesA[parallelRouterKey],</span><span class="s3">\n        </span><span class="s1">parallelRoutesB[parallelRouterKey]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (changedPath !== null) {</span><span class="s3">\n        </span><span class="s1">return `${segmentToPathname(segmentB)}/${changedPath}`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function computeChangedPath(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const changedPath = computeChangedPathImpl(treeA, treeB)</span><span class="s3">\n\n  </span><span class="s1">if (changedPath == null || changedPath === '/') {</span><span class="s3">\n    </span><span class="s1">return changedPath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// lightweight normalization to remove route groups</span><span class="s3">\n  </span><span class="s1">return normalizeSegments(changedPath.split('/'))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively extracts dynamic parameters from FlightRouterState.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSelectedParams(</span><span class="s3">\n  </span><span class="s1">currentTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">params: Params = {}</span><span class="s3">\n</span><span class="s1">): Params {</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = currentTree[1]</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRoute of Object.values(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">const segment = parallelRoute[0]</span><span class="s3">\n    </span><span class="s1">const isDynamicParameter = Array.isArray(segment)</span><span class="s3">\n    </span><span class="s1">const segmentValue = isDynamicParameter ? segment[1] : segment</span><span class="s3">\n    </span><span class="s1">if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue</span><span class="s3">\n\n    </span><span class="s1">// Ensure catchAll and optional catchall are turned into an array</span><span class="s3">\n    </span><span class="s1">const isCatchAll =</span><span class="s3">\n      </span><span class="s1">isDynamicParameter &amp;&amp; (segment[2] === 'c' || segment[2] === 'oc')</span><span class="s3">\n\n    </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1].split('/')</span><span class="s3">\n    </span><span class="s1">} else if (isDynamicParameter) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">params = getSelectedParams(parallelRoute, params)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { FlightRouterState } from './types'</span><span class="s3">\n</span><span class="s1">import { flightRouterStateSchema } from './types'</span><span class="s3">\n</span><span class="s1">import { assert } from 'next/dist/compiled/superstruct'</span><span class="s3">\n\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[]</span><span class="s3">\n</span><span class="s1">): FlightRouterState</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: undefined</span><span class="s3">\n</span><span class="s1">): undefined</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[] | undefined</span><span class="s3">\n</span><span class="s1">): FlightRouterState | undefined</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[] | undefined</span><span class="s3">\n</span><span class="s1">): FlightRouterState | undefined {</span><span class="s3">\n  </span><span class="s1">if (typeof stateHeader === 'undefined') {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(stateHeader)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Multiple router state headers were sent. This is not allowed.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We limit the size of the router state header to ~40kb. This is to prevent</span><span class="s3">\n  </span><span class="s1">// a malicious user from sending a very large header and slowing down the</span><span class="s3">\n  </span><span class="s1">// resolving of the router state.</span><span class="s3">\n  </span><span class="s1">// This is around 2,000 nested or parallel route segment states:</span><span class="s3">\n  </span><span class="s1">// '{</span><span class="s3">\&quot;</span><span class="s1">children</span><span class="s3">\&quot;</span><span class="s1">:[</span><span class="s3">\&quot;\&quot;</span><span class="s1">,{}]}'.length === 20.</span><span class="s3">\n  </span><span class="s1">if (stateHeader.length &gt; 20 * 2000) {</span><span class="s3">\n    </span><span class="s1">throw new Error('The router state header was too large.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const state = JSON.parse(decodeURIComponent(stateHeader))</span><span class="s3">\n    </span><span class="s1">assert(state, flightRouterStateSchema)</span><span class="s3">\n    </span><span class="s1">return state</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">throw new Error('The router state header was sent but could not be parsed.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">import { searchParamsToUrlQuery } from './querystring'</span><span class="s3">\n</span><span class="s1">import { parseRelativeUrl } from './parse-relative-url'</span><span class="s3">\n\n</span><span class="s1">export interface ParsedUrl {</span><span class="s3">\n  </span><span class="s1">hash: string</span><span class="s3">\n  </span><span class="s1">hostname?: string | null</span><span class="s3">\n  </span><span class="s1">href: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">port?: string | null</span><span class="s3">\n  </span><span class="s1">protocol?: string | null</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">search: string</span><span class="s3">\n  </span><span class="s1">slashes: boolean | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseUrl(url: string): ParsedUrl {</span><span class="s3">\n  </span><span class="s1">if (url.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">return parseRelativeUrl(url)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsedURL = new URL(url)</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">hash: parsedURL.hash,</span><span class="s3">\n    </span><span class="s1">hostname: parsedURL.hostname,</span><span class="s3">\n    </span><span class="s1">href: parsedURL.href,</span><span class="s3">\n    </span><span class="s1">pathname: parsedURL.pathname,</span><span class="s3">\n    </span><span class="s1">port: parsedURL.port,</span><span class="s3">\n    </span><span class="s1">protocol: parsedURL.protocol,</span><span class="s3">\n    </span><span class="s1">query: searchParamsToUrlQuery(parsedURL.searchParams),</span><span class="s3">\n    </span><span class="s1">search: parsedURL.search,</span><span class="s3">\n    </span><span class="s1">slashes:</span><span class="s3">\n      </span><span class="s1">parsedURL.href.slice(</span><span class="s3">\n        </span><span class="s1">parsedURL.protocol.length,</span><span class="s3">\n        </span><span class="s1">parsedURL.protocol.length + 2</span><span class="s3">\n      </span><span class="s1">) === '//',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import { getLocationOrigin } from '../../utils'</span><span class="s3">\n</span><span class="s1">import { searchParamsToUrlQuery } from './querystring'</span><span class="s3">\n\n</span><span class="s1">export interface ParsedRelativeUrl {</span><span class="s3">\n  </span><span class="s1">hash: string</span><span class="s3">\n  </span><span class="s1">href: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">search: string</span><span class="s3">\n  </span><span class="s1">slashes: undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative</span><span class="s3">\n </span><span class="s1">* (e.g. `./hello`) then at least base must be.</span><span class="s3">\n </span><span class="s1">* Absolute urls are rejected with one exception, in the browser, absolute urls that are on</span><span class="s3">\n </span><span class="s1">* the current origin will be parsed as relative</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base?: string,</span><span class="s3">\n  </span><span class="s1">parseQuery?: true</span><span class="s3">\n</span><span class="s1">): ParsedRelativeUrl</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base: string | undefined,</span><span class="s3">\n  </span><span class="s1">parseQuery: false</span><span class="s3">\n</span><span class="s1">): Omit&lt;ParsedRelativeUrl, 'query'&gt;</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base?: string,</span><span class="s3">\n  </span><span class="s1">parseQuery = true</span><span class="s3">\n</span><span class="s1">): ParsedRelativeUrl | Omit&lt;ParsedRelativeUrl, 'query'&gt; {</span><span class="s3">\n  </span><span class="s1">const globalBase = new URL(</span><span class="s3">\n    </span><span class="s1">typeof window === 'undefined' ? 'http://n' : getLocationOrigin()</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const resolvedBase = base</span><span class="s3">\n    </span><span class="s1">? new URL(base, globalBase)</span><span class="s3">\n    </span><span class="s1">: url.startsWith('.')</span><span class="s3">\n      </span><span class="s1">? new URL(</span><span class="s3">\n          </span><span class="s1">typeof window === 'undefined' ? 'http://n' : window.location.href</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: globalBase</span><span class="s3">\n\n  </span><span class="s1">const { pathname, searchParams, search, hash, href, origin } = new URL(</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">resolvedBase</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (origin !== globalBase.origin) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`invariant: invalid relative URL, router received ${url}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">query: parseQuery ? searchParamsToUrlQuery(searchParams) : undefined,</span><span class="s3">\n    </span><span class="s1">search,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">href: href.slice(origin.length),</span><span class="s3">\n    </span><span class="s1">// We don't know for relative URLs at this point since we set a custom, internal</span><span class="s3">\n    </span><span class="s1">// base that isn't surfaced to users.</span><span class="s3">\n    </span><span class="s1">slashes: undefined,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import escapePathDelimiters from '../../../shared/lib/router/utils/escape-path-delimiters'</span><span class="s3">\n</span><span class="s1">import { DecodeError } from '../../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We only encode path delimiters for path segments from</span><span class="s3">\n </span><span class="s1">* getStaticPaths so we need to attempt decoding the URL</span><span class="s3">\n </span><span class="s1">* to match against and only escape the path delimiters</span><span class="s3">\n </span><span class="s1">* this allows non-ascii values to be handled e.g.</span><span class="s3">\n </span><span class="s1">* Japanese characters.</span><span class="s3">\n </span><span class="s1">* */</span><span class="s3">\n</span><span class="s1">function decodePathParams(pathname: string): string {</span><span class="s3">\n  </span><span class="s1">// TODO: investigate adding this handling for non-SSG</span><span class="s3">\n  </span><span class="s1">// pages so non-ascii names also work there.</span><span class="s3">\n  </span><span class="s1">return pathname</span><span class="s3">\n    </span><span class="s1">.split('/')</span><span class="s3">\n    </span><span class="s1">.map((seg) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">seg = escapePathDelimiters(decodeURIComponent(seg), true)</span><span class="s3">\n      </span><span class="s1">} catch (_) {</span><span class="s3">\n        </span><span class="s1">// An improperly encoded URL was provided</span><span class="s3">\n        </span><span class="s1">throw new DecodeError('Failed to decode path param(s).')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return seg</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.join('/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { decodePathParams }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// escape delimiters used by path-to-regexp</span><span class="s3">\n</span><span class="s1">export default function escapePathDelimiters(</span><span class="s3">\n  </span><span class="s1">segment: string,</span><span class="s3">\n  </span><span class="s1">escapeEncoded?: boolean</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">return segment.replace(</span><span class="s3">\n    </span><span class="s1">new RegExp(`([/#?]${escapeEncoded ? '|%(2f|23|3f|5c)' : ''})`, 'gi'),</span><span class="s3">\n    </span><span class="s1">(char: string) =&gt; encodeURIComponent(char)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isPlainObject } from '../shared/lib/is-plain-object'</span><span class="s3">\n\n</span><span class="s1">// We allow some additional attached properties for Next.js errors</span><span class="s3">\n</span><span class="s1">export interface NextError extends Error {</span><span class="s3">\n  </span><span class="s1">type?: string</span><span class="s3">\n  </span><span class="s1">page?: string</span><span class="s3">\n  </span><span class="s1">code?: string | number</span><span class="s3">\n  </span><span class="s1">cancelled?: boolean</span><span class="s3">\n  </span><span class="s1">digest?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks whether the given value is a NextError.</span><span class="s3">\n </span><span class="s1">* This can be used to print a more detailed error message with properties like `code` &amp; `digest`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isError(err: unknown): err is NextError {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof err === 'object' &amp;&amp; err !== null &amp;&amp; 'name' in err &amp;&amp; 'message' in err</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function safeStringify(obj: any) {</span><span class="s3">\n  </span><span class="s1">const seen = new WeakSet()</span><span class="s3">\n\n  </span><span class="s1">return JSON.stringify(obj, (_key, value) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If value is an object and already seen, replace with </span><span class="s3">\&quot;</span><span class="s1">[Circular]</span><span class="s3">\&quot;\n    </span><span class="s1">if (typeof value === 'object' &amp;&amp; value !== null) {</span><span class="s3">\n      </span><span class="s1">if (seen.has(value)) {</span><span class="s3">\n        </span><span class="s1">return '[Circular]'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">seen.add(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getProperError(err: unknown): Error {</span><span class="s3">\n  </span><span class="s1">if (isError(err)) {</span><span class="s3">\n    </span><span class="s1">return err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">// provide better error for case where `throw undefined`</span><span class="s3">\n    </span><span class="s1">// is called in development</span><span class="s3">\n    </span><span class="s1">if (typeof err === 'undefined') {</span><span class="s3">\n      </span><span class="s1">return new Error(</span><span class="s3">\n        </span><span class="s1">'An undefined error was thrown, ' +</span><span class="s3">\n          </span><span class="s1">'see here for more info: https://nextjs.org/docs/messages/threw-undefined'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (err === null) {</span><span class="s3">\n      </span><span class="s1">return new Error(</span><span class="s3">\n        </span><span class="s1">'A null error was thrown, ' +</span><span class="s3">\n          </span><span class="s1">'see here for more info: https://nextjs.org/docs/messages/threw-undefined'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new Error(isPlainObject(err) ? safeStringify(err) : err + '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n\n</span><span class="s1">import { parse } from 'next/dist/compiled/content-type'</span><span class="s3">\n</span><span class="s1">import isError from '../../../lib/is-error'</span><span class="s3">\n</span><span class="s1">import type { SizeLimit } from '../../../types'</span><span class="s3">\n</span><span class="s1">import { ApiError } from '../index'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse `JSON` and handles invalid `JSON` strings</span><span class="s3">\n </span><span class="s1">* @param str `JSON` string</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function parseJson(str: string): object {</span><span class="s3">\n  </span><span class="s1">if (str.length === 0) {</span><span class="s3">\n    </span><span class="s1">// special-case empty json body, as it's a common client-side mistake</span><span class="s3">\n    </span><span class="s1">return {}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return JSON.parse(str)</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">throw new ApiError(400, 'Invalid JSON')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse incoming message like `json` or `urlencoded`</span><span class="s3">\n </span><span class="s1">* @param req request object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function parseBody(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">limit: SizeLimit</span><span class="s3">\n</span><span class="s1">): Promise&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">let contentType</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">contentType = parse(req.headers['content-type'] || 'text/plain')</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">contentType = parse('text/plain')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const { type, parameters } = contentType</span><span class="s3">\n  </span><span class="s1">const encoding = parameters.charset || 'utf-8'</span><span class="s3">\n\n  </span><span class="s1">let buffer</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const getRawBody =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/raw-body') as typeof import('next/dist/compiled/raw-body')</span><span class="s3">\n    </span><span class="s1">buffer = await getRawBody(req, { encoding, limit })</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">if (isError(e) &amp;&amp; e.type === 'entity.too.large') {</span><span class="s3">\n      </span><span class="s1">throw new ApiError(413, `Body exceeded ${limit} limit`)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new ApiError(400, 'Invalid body')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const body = buffer.toString()</span><span class="s3">\n\n  </span><span class="s1">if (type === 'application/json' || type === 'application/ld+json') {</span><span class="s3">\n    </span><span class="s1">return parseJson(body)</span><span class="s3">\n  </span><span class="s1">} else if (type === 'application/x-www-form-urlencoded') {</span><span class="s3">\n    </span><span class="s1">const qs = require('querystring') as typeof import('querystring')</span><span class="s3">\n    </span><span class="s1">return qs.decode(body)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return body</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { NextApiRequest, NextApiResponse } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { PageConfig, ResponseLimit } from '../../../types'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../.'</span><span class="s3">\n</span><span class="s1">import type { CookieSerializeOptions } from 'next/dist/compiled/cookie'</span><span class="s3">\n\n</span><span class="s1">import bytes from 'next/dist/compiled/bytes'</span><span class="s3">\n</span><span class="s1">import { generateETag } from '../../lib/etag'</span><span class="s3">\n</span><span class="s1">import { sendEtagResponse } from '../../send-payload'</span><span class="s3">\n</span><span class="s1">import { Stream } from 'stream'</span><span class="s3">\n</span><span class="s1">import isError from '../../../lib/is-error'</span><span class="s3">\n</span><span class="s1">import { isResSent } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { interopDefault } from '../../../lib/interop-default'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">setLazyProp,</span><span class="s3">\n  </span><span class="s1">sendStatusCode,</span><span class="s3">\n  </span><span class="s1">redirect,</span><span class="s3">\n  </span><span class="s1">clearPreviewData,</span><span class="s3">\n  </span><span class="s1">sendError,</span><span class="s3">\n  </span><span class="s1">ApiError,</span><span class="s3">\n  </span><span class="s1">COOKIE_NAME_PRERENDER_BYPASS,</span><span class="s3">\n  </span><span class="s1">COOKIE_NAME_PRERENDER_DATA,</span><span class="s3">\n  </span><span class="s1">RESPONSE_LIMIT_DEFAULT,</span><span class="s3">\n</span><span class="s1">} from './../index'</span><span class="s3">\n</span><span class="s1">import { getCookieParser } from './../get-cookie-parser'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_HEADER,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { tryGetPreviewData } from './try-get-preview-data'</span><span class="s3">\n</span><span class="s1">import { parseBody } from './parse-body'</span><span class="s3">\n</span><span class="s1">import type { RevalidateFn } from '../../lib/router-utils/router-server-context'</span><span class="s3">\n</span><span class="s1">import type { InstrumentationOnRequestError } from '../../instrumentation/types'</span><span class="s3">\n\n</span><span class="s1">type ApiContext = __ApiPreviewProps &amp; {</span><span class="s3">\n  </span><span class="s1">trustHostHeader?: boolean</span><span class="s3">\n  </span><span class="s1">allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n  </span><span class="s1">hostname?: string</span><span class="s3">\n  </span><span class="s1">multiZoneDraftMode?: boolean</span><span class="s3">\n  </span><span class="s1">dev: boolean</span><span class="s3">\n  </span><span class="s1">internalRevalidate?: RevalidateFn</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getMaxContentLength(responseLimit?: ResponseLimit) {</span><span class="s3">\n  </span><span class="s1">if (responseLimit &amp;&amp; typeof responseLimit !== 'boolean') {</span><span class="s3">\n    </span><span class="s1">return bytes.parse(responseLimit)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return RESPONSE_LIMIT_DEFAULT</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Send `any` body to response</span><span class="s3">\n </span><span class="s1">* @param req request object</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param body of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function sendData(req: NextApiRequest, res: NextApiResponse, body: any): void {</span><span class="s3">\n  </span><span class="s1">if (body === null || body === undefined) {</span><span class="s3">\n    </span><span class="s1">res.end()</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// strip irrelevant headers/body</span><span class="s3">\n  </span><span class="s1">if (res.statusCode === 204 || res.statusCode === 304) {</span><span class="s3">\n    </span><span class="s1">res.removeHeader('Content-Type')</span><span class="s3">\n    </span><span class="s1">res.removeHeader('Content-Length')</span><span class="s3">\n    </span><span class="s1">res.removeHeader('Transfer-Encoding')</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV === 'development' &amp;&amp; body) {</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">`A body was attempted to be set with a 204 statusCode for ${req.url}, this is invalid and the body was ignored.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n          </span><span class="s1">`See more info here https://nextjs.org/docs/messages/invalid-api-status-body`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">res.end()</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const contentType = res.getHeader('Content-Type')</span><span class="s3">\n\n  </span><span class="s1">if (body instanceof Stream) {</span><span class="s3">\n    </span><span class="s1">if (!contentType) {</span><span class="s3">\n      </span><span class="s1">res.setHeader('Content-Type', 'application/octet-stream')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">body.pipe(res)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const isJSONLike = ['object', 'number', 'boolean'].includes(typeof body)</span><span class="s3">\n  </span><span class="s1">const stringifiedBody = isJSONLike ? JSON.stringify(body) : body</span><span class="s3">\n  </span><span class="s1">const etag = generateETag(stringifiedBody)</span><span class="s3">\n  </span><span class="s1">if (sendEtagResponse(req, res, etag)) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Buffer.isBuffer(body)) {</span><span class="s3">\n    </span><span class="s1">if (!contentType) {</span><span class="s3">\n      </span><span class="s1">res.setHeader('Content-Type', 'application/octet-stream')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">res.setHeader('Content-Length', body.length)</span><span class="s3">\n    </span><span class="s1">res.end(body)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isJSONLike) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('Content-Type', JSON_CONTENT_TYPE_HEADER)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">res.setHeader('Content-Length', Buffer.byteLength(stringifiedBody))</span><span class="s3">\n  </span><span class="s1">res.end(stringifiedBody)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Send `JSON` object</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param jsonBody of data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function sendJson(res: NextApiResponse, jsonBody: any): void {</span><span class="s3">\n  </span><span class="s1">// Set header to application/json</span><span class="s3">\n  </span><span class="s1">res.setHeader('Content-Type', JSON_CONTENT_TYPE_HEADER)</span><span class="s3">\n\n  </span><span class="s1">// Use send to handle request</span><span class="s3">\n  </span><span class="s1">res.send(JSON.stringify(jsonBody))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isValidData(str: any): str is string {</span><span class="s3">\n  </span><span class="s1">return typeof str === 'string' &amp;&amp; str.length &gt;= 16</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function setDraftMode&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">enable: boolean</span><span class="s3">\n    </span><span class="s1">previewModeId?: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (!isValidData(options.previewModeId)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('invariant: invalid previewModeId')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const expires = options.enable ? undefined : new Date(0)</span><span class="s3">\n  </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n  </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n  </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n  </span><span class="s1">const { serialize } =</span><span class="s3">\n    </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n  </span><span class="s1">const previous = res.getHeader('Set-Cookie')</span><span class="s3">\n  </span><span class="s1">res.setHeader(`Set-Cookie`, [</span><span class="s3">\n    </span><span class="s1">...(typeof previous === 'string'</span><span class="s3">\n      </span><span class="s1">? [previous]</span><span class="s3">\n      </span><span class="s1">: Array.isArray(previous)</span><span class="s3">\n        </span><span class="s1">? previous</span><span class="s3">\n        </span><span class="s1">: []),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_BYPASS, options.previewModeId, {</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">expires,</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function setPreviewData&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">data: object | string, // TODO: strict runtime type checking</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">maxAge?: number</span><span class="s3">\n    </span><span class="s1">path?: string</span><span class="s3">\n  </span><span class="s1">} &amp; __ApiPreviewProps</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (!isValidData(options.previewModeId)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('invariant: invalid previewModeId')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isValidData(options.previewModeEncryptionKey)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('invariant: invalid previewModeEncryptionKey')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isValidData(options.previewModeSigningKey)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('invariant: invalid previewModeSigningKey')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const jsonwebtoken =</span><span class="s3">\n    </span><span class="s1">require('next/dist/compiled/jsonwebtoken') as typeof import('next/dist/compiled/jsonwebtoken')</span><span class="s3">\n  </span><span class="s1">const { encryptWithSecret } =</span><span class="s3">\n    </span><span class="s1">require('../../crypto-utils') as typeof import('../../crypto-utils')</span><span class="s3">\n  </span><span class="s1">const payload = jsonwebtoken.sign(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">data: encryptWithSecret(</span><span class="s3">\n        </span><span class="s1">Buffer.from(options.previewModeEncryptionKey),</span><span class="s3">\n        </span><span class="s1">JSON.stringify(data)</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">options.previewModeSigningKey,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">algorithm: 'HS256',</span><span class="s3">\n      </span><span class="s1">...(options.maxAge !== undefined</span><span class="s3">\n        </span><span class="s1">? { expiresIn: options.maxAge }</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// limit preview mode cookie to 2KB since we shouldn't store too much</span><span class="s3">\n  </span><span class="s1">// data here and browsers drop cookies over 4KB</span><span class="s3">\n  </span><span class="s1">if (payload.length &gt; 2048) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Preview data is limited to 2KB currently, reduce how much data you are storing as preview data to continue`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { serialize } =</span><span class="s3">\n    </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n  </span><span class="s1">const previous = res.getHeader('Set-Cookie')</span><span class="s3">\n  </span><span class="s1">res.setHeader(`Set-Cookie`, [</span><span class="s3">\n    </span><span class="s1">...(typeof previous === 'string'</span><span class="s3">\n      </span><span class="s1">? [previous]</span><span class="s3">\n      </span><span class="s1">: Array.isArray(previous)</span><span class="s3">\n        </span><span class="s1">? previous</span><span class="s3">\n        </span><span class="s1">: []),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_BYPASS, options.previewModeId, {</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.maxAge !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ maxAge: options.maxAge } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_DATA, payload, {</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.maxAge !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ maxAge: options.maxAge } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function revalidate(</span><span class="s3">\n  </span><span class="s1">urlPath: string,</span><span class="s3">\n  </span><span class="s1">opts: {</span><span class="s3">\n    </span><span class="s1">unstable_onlyGenerated?: boolean</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">context: ApiContext</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (typeof urlPath !== 'string' || !urlPath.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid urlPath provided to revalidate(), must be a path e.g. /blog/post-1, received ${urlPath}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const revalidateHeaders: HeadersInit = {</span><span class="s3">\n    </span><span class="s1">[PRERENDER_REVALIDATE_HEADER]: context.previewModeId,</span><span class="s3">\n    </span><span class="s1">...(opts.unstable_onlyGenerated</span><span class="s3">\n      </span><span class="s1">? {</span><span class="s3">\n          </span><span class="s1">[PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER]: '1',</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">: {}),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const allowedRevalidateHeaderKeys = [</span><span class="s3">\n    </span><span class="s1">...(context.allowedRevalidateHeaderKeys || []),</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">if (context.trustHostHeader || context.dev) {</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys.push('cookie')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (context.trustHostHeader) {</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys.push('x-vercel-protection-bypass')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(req.headers)) {</span><span class="s3">\n    </span><span class="s1">if (allowedRevalidateHeaderKeys.includes(key)) {</span><span class="s3">\n      </span><span class="s1">revalidateHeaders[key] = req.headers[key] as string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const internalRevalidate = context.internalRevalidate</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// We use the revalidate in router-server if available.</span><span class="s3">\n    </span><span class="s1">// If we are operating without router-server (serverless)</span><span class="s3">\n    </span><span class="s1">// we must go through network layer with fetch request</span><span class="s3">\n    </span><span class="s1">if (internalRevalidate) {</span><span class="s3">\n      </span><span class="s1">return await internalRevalidate({</span><span class="s3">\n        </span><span class="s1">urlPath,</span><span class="s3">\n        </span><span class="s1">revalidateHeaders,</span><span class="s3">\n        </span><span class="s1">opts,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (context.trustHostHeader) {</span><span class="s3">\n      </span><span class="s1">const res = await fetch(`https://${req.headers.host}${urlPath}`, {</span><span class="s3">\n        </span><span class="s1">method: 'HEAD',</span><span class="s3">\n        </span><span class="s1">headers: revalidateHeaders,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">// we use the cache header to determine successful revalidate as</span><span class="s3">\n      </span><span class="s1">// a non-200 status code can be returned from a successful revalidate</span><span class="s3">\n      </span><span class="s1">// e.g. notFound: true returns 404 status code but is successful</span><span class="s3">\n      </span><span class="s1">const cacheHeader =</span><span class="s3">\n        </span><span class="s1">res.headers.get('x-vercel-cache') || res.headers.get('x-nextjs-cache')</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">cacheHeader?.toUpperCase() !== 'REVALIDATED' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">res.status !== 200 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!(res.status === 404 &amp;&amp; opts.unstable_onlyGenerated)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw new Error(`Invalid response ${res.status}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Invariant: missing internal router-server-methods this is an internal bug`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (err: unknown) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Failed to revalidate ${urlPath}: ${isError(err) ? err.message : err}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function apiResolver(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">query: any,</span><span class="s3">\n  </span><span class="s1">resolverModule: any,</span><span class="s3">\n  </span><span class="s1">apiContext: ApiContext,</span><span class="s3">\n  </span><span class="s1">propagateError: boolean,</span><span class="s3">\n  </span><span class="s1">dev?: boolean,</span><span class="s3">\n  </span><span class="s1">page?: string,</span><span class="s3">\n  </span><span class="s1">onError?: InstrumentationOnRequestError</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">const apiReq = req as NextApiRequest</span><span class="s3">\n  </span><span class="s1">const apiRes = res as NextApiResponse</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">if (!resolverModule) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = 404</span><span class="s3">\n      </span><span class="s1">res.end('Not Found')</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const config: PageConfig = resolverModule.config || {}</span><span class="s3">\n    </span><span class="s1">const bodyParser = config.api?.bodyParser !== false</span><span class="s3">\n    </span><span class="s1">const responseLimit = config.api?.responseLimit ?? true</span><span class="s3">\n    </span><span class="s1">const externalResolver = config.api?.externalResolver || false</span><span class="s3">\n\n    </span><span class="s1">// Parsing of cookies</span><span class="s3">\n    </span><span class="s1">setLazyProp({ req: apiReq }, 'cookies', getCookieParser(req.headers))</span><span class="s3">\n    </span><span class="s1">// Parsing query string</span><span class="s3">\n    </span><span class="s1">apiReq.query = query</span><span class="s3">\n    </span><span class="s1">// Parsing preview data</span><span class="s3">\n    </span><span class="s1">setLazyProp({ req: apiReq }, 'previewData', () =&gt;</span><span class="s3">\n      </span><span class="s1">tryGetPreviewData(req, res, apiContext, !!apiContext.multiZoneDraftMode)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">// Checking if preview mode is enabled</span><span class="s3">\n    </span><span class="s1">setLazyProp({ req: apiReq }, 'preview', () =&gt;</span><span class="s3">\n      </span><span class="s1">apiReq.previewData !== false ? true : undefined</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">// Set draftMode to the same value as preview</span><span class="s3">\n    </span><span class="s1">setLazyProp({ req: apiReq }, 'draftMode', () =&gt; apiReq.preview)</span><span class="s3">\n\n    </span><span class="s1">// Parsing of body</span><span class="s3">\n    </span><span class="s1">if (bodyParser &amp;&amp; !apiReq.body) {</span><span class="s3">\n      </span><span class="s1">apiReq.body = await parseBody(</span><span class="s3">\n        </span><span class="s1">apiReq,</span><span class="s3">\n        </span><span class="s1">config.api &amp;&amp; config.api.bodyParser &amp;&amp; config.api.bodyParser.sizeLimit</span><span class="s3">\n          </span><span class="s1">? config.api.bodyParser.sizeLimit</span><span class="s3">\n          </span><span class="s1">: '1mb'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let contentLength = 0</span><span class="s3">\n    </span><span class="s1">const maxContentLength = getMaxContentLength(responseLimit)</span><span class="s3">\n    </span><span class="s1">const writeData = apiRes.write</span><span class="s3">\n    </span><span class="s1">const endResponse = apiRes.end</span><span class="s3">\n    </span><span class="s1">apiRes.write = (...args: any[2]) =&gt; {</span><span class="s3">\n      </span><span class="s1">contentLength += Buffer.byteLength(args[0] || '')</span><span class="s3">\n      </span><span class="s1">return writeData.apply(apiRes, args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">apiRes.end = (...args: any[2]) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (args.length &amp;&amp; typeof args[0] !== 'function') {</span><span class="s3">\n        </span><span class="s1">contentLength += Buffer.byteLength(args[0] || '')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (responseLimit &amp;&amp; contentLength &gt;= maxContentLength) {</span><span class="s3">\n        </span><span class="s1">console.warn(</span><span class="s3">\n          </span><span class="s1">`API response for ${req.url} exceeds ${bytes.format(</span><span class="s3">\n            </span><span class="s1">maxContentLength</span><span class="s3">\n          </span><span class="s1">)}. API Routes are meant to respond quickly. https://nextjs.org/docs/messages/api-routes-response-size-limit`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return endResponse.apply(apiRes, args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">apiRes.status = (statusCode) =&gt; sendStatusCode(apiRes, statusCode)</span><span class="s3">\n    </span><span class="s1">apiRes.send = (data) =&gt; sendData(apiReq, apiRes, data)</span><span class="s3">\n    </span><span class="s1">apiRes.json = (data) =&gt; sendJson(apiRes, data)</span><span class="s3">\n    </span><span class="s1">apiRes.redirect = (statusOrUrl: number | string, url?: string) =&gt;</span><span class="s3">\n      </span><span class="s1">redirect(apiRes, statusOrUrl, url)</span><span class="s3">\n    </span><span class="s1">apiRes.setDraftMode = (options = { enable: true }) =&gt;</span><span class="s3">\n      </span><span class="s1">setDraftMode(apiRes, Object.assign({}, apiContext, options))</span><span class="s3">\n    </span><span class="s1">apiRes.setPreviewData = (data, options = {}) =&gt;</span><span class="s3">\n      </span><span class="s1">setPreviewData(apiRes, data, Object.assign({}, apiContext, options))</span><span class="s3">\n    </span><span class="s1">apiRes.clearPreviewData = (options = {}) =&gt;</span><span class="s3">\n      </span><span class="s1">clearPreviewData(apiRes, options)</span><span class="s3">\n    </span><span class="s1">apiRes.revalidate = (</span><span class="s3">\n      </span><span class="s1">urlPath: string,</span><span class="s3">\n      </span><span class="s1">opts?: {</span><span class="s3">\n        </span><span class="s1">unstable_onlyGenerated?: boolean</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">) =&gt; revalidate(urlPath, opts || {}, req, apiContext)</span><span class="s3">\n\n    </span><span class="s1">const resolver = interopDefault(resolverModule)</span><span class="s3">\n    </span><span class="s1">let wasPiped = false</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">// listen for pipe event and don't show resolve warning</span><span class="s3">\n      </span><span class="s1">res.once('pipe', () =&gt; (wasPiped = true))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const apiRouteResult = await resolver(req, res)</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">if (typeof apiRouteResult !== 'undefined') {</span><span class="s3">\n        </span><span class="s1">if (apiRouteResult instanceof Response) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">'API route returned a Response object in the Node.js runtime, this is not supported. Please use `runtime: </span><span class="s3">\&quot;</span><span class="s1">edge</span><span class="s3">\&quot;</span><span class="s1">` instead: https://nextjs.org/docs/api-routes/edge-api-routes'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">console.warn(</span><span class="s3">\n          </span><span class="s1">`API handler should not return a value, received ${typeof apiRouteResult}.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!externalResolver &amp;&amp; !isResSent(res) &amp;&amp; !wasPiped) {</span><span class="s3">\n        </span><span class="s1">console.warn(</span><span class="s3">\n          </span><span class="s1">`API resolved without sending a response for ${req.url}, this may result in stalled requests.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">await onError?.(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">method: req.method || 'GET',</span><span class="s3">\n        </span><span class="s1">headers: req.headers,</span><span class="s3">\n        </span><span class="s1">path: req.url || '/',</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">routerKind: 'Pages Router',</span><span class="s3">\n        </span><span class="s1">routePath: page || '',</span><span class="s3">\n        </span><span class="s1">routeType: 'route',</span><span class="s3">\n        </span><span class="s1">revalidateReason: undefined,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (err instanceof ApiError) {</span><span class="s3">\n      </span><span class="s1">sendError(apiRes, err.statusCode, err.message)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (dev) {</span><span class="s3">\n        </span><span class="s1">if (isError(err)) {</span><span class="s3">\n          </span><span class="s1">err.page = page</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">console.error(err)</span><span class="s3">\n      </span><span class="s1">if (propagateError) {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">sendError(apiRes, 500, 'Internal Server Error')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* FNV-1a Hash implementation</span><span class="s3">\n </span><span class="s1">* @author Travis Webb (tjwebb) &lt;me@traviswebb.com&gt;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Ported from https://github.com/tjwebb/fnv-plus/blob/master/index.js</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Simplified, optimized and add modified for 52 bit, which provides a larger hash space</span><span class="s3">\n </span><span class="s1">* and still making use of Javascript's 53-bit integer space.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const fnv1a52 = (str: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">const len = str.length</span><span class="s3">\n  </span><span class="s1">let i = 0,</span><span class="s3">\n    </span><span class="s1">t0 = 0,</span><span class="s3">\n    </span><span class="s1">v0 = 0x2325,</span><span class="s3">\n    </span><span class="s1">t1 = 0,</span><span class="s3">\n    </span><span class="s1">v1 = 0x8422,</span><span class="s3">\n    </span><span class="s1">t2 = 0,</span><span class="s3">\n    </span><span class="s1">v2 = 0x9ce4,</span><span class="s3">\n    </span><span class="s1">t3 = 0,</span><span class="s3">\n    </span><span class="s1">v3 = 0xcbf2</span><span class="s3">\n\n  </span><span class="s1">while (i &lt; len) {</span><span class="s3">\n    </span><span class="s1">v0 ^= str.charCodeAt(i++)</span><span class="s3">\n    </span><span class="s1">t0 = v0 * 435</span><span class="s3">\n    </span><span class="s1">t1 = v1 * 435</span><span class="s3">\n    </span><span class="s1">t2 = v2 * 435</span><span class="s3">\n    </span><span class="s1">t3 = v3 * 435</span><span class="s3">\n    </span><span class="s1">t2 += v0 &lt;&lt; 8</span><span class="s3">\n    </span><span class="s1">t3 += v1 &lt;&lt; 8</span><span class="s3">\n    </span><span class="s1">t1 += t0 &gt;&gt;&gt; 16</span><span class="s3">\n    </span><span class="s1">v0 = t0 &amp; 65535</span><span class="s3">\n    </span><span class="s1">t2 += t1 &gt;&gt;&gt; 16</span><span class="s3">\n    </span><span class="s1">v1 = t1 &amp; 65535</span><span class="s3">\n    </span><span class="s1">v3 = (t3 + (t2 &gt;&gt;&gt; 16)) &amp; 65535</span><span class="s3">\n    </span><span class="s1">v2 = t2 &amp; 65535</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">(v3 &amp; 15) * 281474976710656 +</span><span class="s3">\n    </span><span class="s1">v2 * 4294967296 +</span><span class="s3">\n    </span><span class="s1">v1 * 65536 +</span><span class="s3">\n    </span><span class="s1">(v0 ^ (v3 &gt;&gt; 4))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const generateETag = (payload: string, weak = false) =&gt; {</span><span class="s3">\n  </span><span class="s1">const prefix = weak ? 'W/</span><span class="s3">\&quot;</span><span class="s1">' : '</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type RenderResult from './render-result'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n\n</span><span class="s1">import { isResSent } from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { generateETag } from './lib/etag'</span><span class="s3">\n</span><span class="s1">import fresh from 'next/dist/compiled/fresh'</span><span class="s3">\n</span><span class="s1">import { getCacheControlHeader } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import { HTML_CONTENT_TYPE_HEADER } from '../lib/constants'</span><span class="s3">\n\n</span><span class="s1">export function sendEtagResponse(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">etag: string | undefined</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (etag) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The server generating a 304 response MUST generate any of the</span><span class="s3">\n     </span><span class="s1">* following header fields that would have been sent in a 200 (OK)</span><span class="s3">\n     </span><span class="s1">* response to the same request: Cache-Control, Content-Location, Date,</span><span class="s3">\n     </span><span class="s1">* ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">res.setHeader('ETag', etag)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (fresh(req.headers, { etag })) {</span><span class="s3">\n    </span><span class="s1">res.statusCode = 304</span><span class="s3">\n    </span><span class="s1">res.end()</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function sendRenderResult({</span><span class="s3">\n  </span><span class="s1">req,</span><span class="s3">\n  </span><span class="s1">res,</span><span class="s3">\n  </span><span class="s1">result,</span><span class="s3">\n  </span><span class="s1">generateEtags,</span><span class="s3">\n  </span><span class="s1">poweredByHeader,</span><span class="s3">\n  </span><span class="s1">cacheControl,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage</span><span class="s3">\n  </span><span class="s1">res: ServerResponse</span><span class="s3">\n  </span><span class="s1">result: RenderResult</span><span class="s3">\n  </span><span class="s1">generateEtags: boolean</span><span class="s3">\n  </span><span class="s1">poweredByHeader: boolean</span><span class="s3">\n  </span><span class="s1">cacheControl: CacheControl | undefined</span><span class="s3">\n</span><span class="s1">}): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">if (isResSent(res)) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (poweredByHeader &amp;&amp; result.contentType === HTML_CONTENT_TYPE_HEADER) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('X-Powered-By', 'Next.js')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If cache control is already set on the response we don't</span><span class="s3">\n  </span><span class="s1">// override it to allow users to customize it via next.config</span><span class="s3">\n  </span><span class="s1">if (cacheControl &amp;&amp; !res.getHeader('Cache-Control')) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('Cache-Control', getCacheControlHeader(cacheControl))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const payload = result.isDynamic ? null : result.toUnchunkedString()</span><span class="s3">\n\n  </span><span class="s1">if (generateEtags &amp;&amp; payload !== null) {</span><span class="s3">\n    </span><span class="s1">const etag = generateETag(payload)</span><span class="s3">\n    </span><span class="s1">if (sendEtagResponse(req, res, etag)) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!res.getHeader('Content-Type') &amp;&amp; result.contentType) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('Content-Type', result.contentType)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (payload) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('Content-Length', Buffer.byteLength(payload))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (req.method === 'HEAD') {</span><span class="s3">\n    </span><span class="s1">res.end(null)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (payload !== null) {</span><span class="s3">\n    </span><span class="s1">res.end(payload)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Pipe the render result to the response after we get a writer for it.</span><span class="s3">\n  </span><span class="s1">await result.pipeToNodeResponse(res)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function interopDefault(mod: any) {</span><span class="s3">\n  </span><span class="s1">return mod.default || mod</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { PagesAPIRouteDefinition } from '../../route-definitions/pages-api-route-definition'</span><span class="s3">\n</span><span class="s1">import type { PageConfig } from '../../../types'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import { wrapApiHandler, type __ApiPreviewProps } from '../../api-utils'</span><span class="s3">\n</span><span class="s1">import type { RouteModuleOptions } from '../route-module'</span><span class="s3">\n\n</span><span class="s1">import { RouteModule, type RouteModuleHandleContext } from '../route-module'</span><span class="s3">\n</span><span class="s1">import { apiResolver } from '../../api-utils/node/api-resolver'</span><span class="s3">\n</span><span class="s1">import type { RevalidateFn } from '../../lib/router-utils/router-server-context'</span><span class="s3">\n\n</span><span class="s1">type PagesAPIHandleFn = (</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse</span><span class="s3">\n</span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The PagesAPIModule is the type of the module exported by the bundled Pages</span><span class="s3">\n </span><span class="s1">* API module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type PagesAPIModule = typeof import('../../../build/templates/pages-api')</span><span class="s3">\n\n</span><span class="s1">type PagesAPIUserlandModule = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The exported handler method.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly default: PagesAPIHandleFn</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The exported page config.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly config?: PageConfig</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PagesAPIRouteHandlerContext = RouteModuleHandleContext &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The incoming server request in non-edge runtime.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">req?: IncomingMessage</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The outgoing server response in non-edge runtime.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">res?: ServerResponse</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The hostname for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hostname?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Keys allowed in the revalidate call.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to trust the host header.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">trustHostHeader?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The preview props used by the `preview` API.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the server is in development mode.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">dev: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether errors should be left uncaught to handle</span><span class="s3">\n   </span><span class="s1">* higher up</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">propagateError: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The page that's being rendered.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The error handler for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">onError?: Parameters&lt;typeof apiResolver&gt;[8]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* whether multi-zone flag is enabled for draft mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">multiZoneDraftMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Internal revalidate function to avoid revalidating</span><span class="s3">\n   </span><span class="s1">* over the network</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">internalRevalidate?: RevalidateFn</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PagesAPIRouteModuleOptions = RouteModuleOptions&lt;</span><span class="s3">\n  </span><span class="s1">PagesAPIRouteDefinition,</span><span class="s3">\n  </span><span class="s1">PagesAPIUserlandModule</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export class PagesAPIRouteModule extends RouteModule&lt;</span><span class="s3">\n  </span><span class="s1">PagesAPIRouteDefinition,</span><span class="s3">\n  </span><span class="s1">PagesAPIUserlandModule</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">private apiResolverWrapped: typeof apiResolver</span><span class="s3">\n\n  </span><span class="s1">constructor(options: PagesAPIRouteModuleOptions) {</span><span class="s3">\n    </span><span class="s1">super(options)</span><span class="s3">\n\n    </span><span class="s1">if (typeof options.userland.default !== 'function') {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Page ${options.definition.page} does not export a default function.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.apiResolverWrapped = wrapApiHandler(</span><span class="s3">\n      </span><span class="s1">options.definition.page,</span><span class="s3">\n      </span><span class="s1">apiResolver</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param req the incoming server request</span><span class="s3">\n   </span><span class="s1">* @param res the outgoing server response</span><span class="s3">\n   </span><span class="s1">* @param context the context for the render</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async render(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">context: PagesAPIRouteHandlerContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">const { apiResolverWrapped } = this</span><span class="s3">\n    </span><span class="s1">await apiResolverWrapped(</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">context.query,</span><span class="s3">\n      </span><span class="s1">this.userland,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">...context.previewProps,</span><span class="s3">\n        </span><span class="s1">trustHostHeader: context.trustHostHeader,</span><span class="s3">\n        </span><span class="s1">allowedRevalidateHeaderKeys: context.allowedRevalidateHeaderKeys,</span><span class="s3">\n        </span><span class="s1">hostname: context.hostname,</span><span class="s3">\n        </span><span class="s1">multiZoneDraftMode: context.multiZoneDraftMode,</span><span class="s3">\n        </span><span class="s1">dev: context.dev,</span><span class="s3">\n        </span><span class="s1">internalRevalidate: context.internalRevalidate,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">context.propagateError,</span><span class="s3">\n      </span><span class="s1">context.dev,</span><span class="s3">\n      </span><span class="s1">context.page,</span><span class="s3">\n      </span><span class="s1">context.onError</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default PagesAPIRouteModule</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFloat&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;__dirname&quot;</span><span class="s0">,</span><span class="s1">&quot;__nccwpck_require__&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;u&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinite&quot;</span><span class="s0">,</span><span class="s1">&quot;NaN&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;HTML_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_QUERY_PARAM_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_INTERCEPTION_MARKER_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;PRERENDER_REVALIDATE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_PREFETCH_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENTS_DIR_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENT_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DATA_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_META_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATED_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;CACHE_ONE_YEAR&quot;</span><span class="s0">,</span><span class="s1">&quot;WEBPACK_LAYERS_NAMES&quot;</span><span class="s0">,</span><span class="s1">&quot;shared&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;serverSideRendering&quot;</span><span class="s0">,</span><span class="s1">&quot;actionBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;apiNode&quot;</span><span class="s0">,</span><span class="s1">&quot;apiEdge&quot;</span><span class="s0">,</span><span class="s1">&quot;middleware&quot;</span><span class="s0">,</span><span class="s1">&quot;instrument&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeAsset&quot;</span><span class="s0">,</span><span class="s1">&quot;appPagesBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirEdge&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirNode&quot;</span><span class="s0">,</span><span class="s1">&quot;GROUP&quot;</span><span class="s0">,</span><span class="s1">&quot;builtinReact&quot;</span><span class="s0">,</span><span class="s1">&quot;serverOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;neutralTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;clientOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;bundled&quot;</span><span class="s0">,</span><span class="s1">&quot;appPages&quot;</span><span class="s0">,</span><span class="s1">&quot;formatDynamicImportPath&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToFileURL&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapApiHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;setRootSpanAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;NodeSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;spanName&quot;</span><span class="s0">,</span><span class="s1">&quot;sendStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;statusOrUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;writeHead&quot;</span><span class="s0">,</span><span class="s1">&quot;Location&quot;</span><span class="s0">,</span><span class="s1">&quot;write&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;checkIsOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;previewProps&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;HeadersAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;isOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeId&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateOnlyGenerated&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;COOKIE_NAME_PRERENDER_BYPASS&quot;</span><span class="s0">,</span><span class="s1">&quot;COOKIE_NAME_PRERENDER_DATA&quot;</span><span class="s0">,</span><span class="s1">&quot;RESPONSE_LIMIT_DEFAULT&quot;</span><span class="s0">,</span><span class="s1">&quot;SYMBOL_PREVIEW_DATA&quot;</span><span class="s0">,</span><span class="s1">&quot;SYMBOL_CLEARED_COOKIES&quot;</span><span class="s0">,</span><span class="s1">&quot;clearPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;serialize&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;previous&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;expires&quot;</span><span class="s0">,</span><span class="s1">&quot;httpOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;sameSite&quot;</span><span class="s0">,</span><span class="s1">&quot;secure&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;ApiError&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;sendError&quot;</span><span class="s0">,</span><span class="s1">&quot;statusMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;setLazyProp&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;optsReset&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;tryGetPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;multiZoneDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptedPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;RequestCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;jsonwebtoken&quot;</span><span class="s0">,</span><span class="s1">&quot;verify&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeSigningKey&quot;</span><span class="s0">,</span><span class="s1">&quot;decryptWithSecret&quot;</span><span class="s0">,</span><span class="s1">&quot;decryptedPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeEncryptionKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;CIPHER_ALGORITHM&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptWithSecret&quot;</span><span class="s0">,</span><span class="s1">&quot;secret&quot;</span><span class="s0">,</span><span class="s1">&quot;iv&quot;</span><span class="s0">,</span><span class="s1">&quot;crypto&quot;</span><span class="s0">,</span><span class="s1">&quot;salt&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;cipher&quot;</span><span class="s0">,</span><span class="s1">&quot;encrypted&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;final&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;getAuthTag&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptedData&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;CIPHER_SALT_LENGTH&quot;</span><span class="s0">,</span><span class="s1">&quot;decipher&quot;</span><span class="s0">,</span><span class="s1">&quot;setAuthTag&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeFs&quot;</span><span class="s0">,</span><span class="s1">&quot;existsSync&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">,</span><span class="s1">&quot;readFileSync&quot;</span><span class="s0">,</span><span class="s1">&quot;writeFile&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;mkdir&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;stat&quot;</span><span class="s0">,</span><span class="s1">&quot;NextNodeServerSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;ReflectAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;receiver&quot;</span><span class="s0">,</span><span class="s1">&quot;Reflect&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadonlyHeadersError&quot;</span><span class="s0">,</span><span class="s1">&quot;callable&quot;</span><span class="s0">,</span><span class="s1">&quot;Headers&quot;</span><span class="s0">,</span><span class="s1">&quot;Proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;lowercased&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;original&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;seal&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;callbackfn&quot;</span><span class="s0">,</span><span class="s1">&quot;thisArg&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;COMPILER_NAMES&quot;</span><span class="s0">,</span><span class="s1">&quot;client&quot;</span><span class="s0">,</span><span class="s1">&quot;server&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeServer&quot;</span><span class="s0">,</span><span class="s1">&quot;BUILD_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;parseReqUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsed&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getAll&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;auth&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;slashes&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeLocalePath&quot;</span><span class="s0">,</span><span class="s1">&quot;locales&quot;</span><span class="s0">,</span><span class="s1">&quot;detectedLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;lowercasedLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;locale&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureLeadingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRscURL&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_ROUTE_MARKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;TEST_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;TEST_STRICT_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;strict&quot;</span><span class="s0">,</span><span class="s1">&quot;extractInterceptionRouteInformation&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;marker&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;splitInterceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePath&quot;</span><span class="s0">,</span><span class="s1">&quot;hashIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;queryIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;hasQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;pathHasPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;removePathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;withoutPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;reHasRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;reReplaceRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeStringRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAMETER_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;parseMatchedParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeKeyFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;backreferenceDuplicateKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidKey&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;SP&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;DecodeError&quot;</span><span class="s0">,</span><span class="s1">&quot;NormalizeError&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAM_SEPARATOR&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAdjacentParameterIssues&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAdjacentParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;normalized&quot;</span><span class="s0">,</span><span class="s1">&quot;safePathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;needsNormalization&quot;</span><span class="s0">,</span><span class="s1">&quot;routeToUse&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;retryError&quot;</span><span class="s0">,</span><span class="s1">&quot;safeCompile&quot;</span><span class="s0">,</span><span class="s1">&quot;compile&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;matcherFn&quot;</span><span class="s0">,</span><span class="s1">&quot;re&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;group&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;cleaned&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParamsToUrlQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyUrlQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;getCookieParser&quot;</span><span class="s0">,</span><span class="s1">&quot;cookie&quot;</span><span class="s0">,</span><span class="s1">&quot;parseCookieFn&quot;</span><span class="s0">,</span><span class="s1">&quot;unescapeSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;compileNonPath&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeNextQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeQueryPathParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;slashedProtocols&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParamTypesSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterStateSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;filterInternalQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;paramKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextQueryPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextInterceptionMarkerPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;detectDomainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;domainItems&quot;</span><span class="s0">,</span><span class="s1">&quot;domain&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;getHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDataPath&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REQUEST_META&quot;</span><span class="s0">,</span><span class="s1">&quot;for&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;posix&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPage&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_METADATA_IMAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;icon&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;extensions&quot;</span><span class="s0">,</span><span class="s1">&quot;apple&quot;</span><span class="s0">,</span><span class="s1">&quot;openGraph&quot;</span><span class="s0">,</span><span class="s1">&quot;twitter&quot;</span><span class="s0">,</span><span class="s1">&quot;getExtensionRegexString&quot;</span><span class="s0">,</span><span class="s1">&quot;staticExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;DetachedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;rej&quot;</span><span class="s0">,</span><span class="s1">&quot;Batcher&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyFn&quot;</span><span class="s0">,</span><span class="s1">&quot;schedulerFn&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;batch&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleOnNextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedRouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;voidCatch&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;encoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromString&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;streamToString&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;decoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextDecoder&quot;</span><span class="s0">,</span><span class="s1">&quot;fatal&quot;</span><span class="s0">,</span><span class="s1">&quot;string&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;suffix&quot;</span><span class="s0">,</span><span class="s1">&quot;REGEX_LOCALHOST_HOSTNAME&quot;</span><span class="s0">,</span><span class="s1">&quot;parseURL&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;Internal&quot;</span><span class="s0">,</span><span class="s1">&quot;NextURL&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;baseOrOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;analyze&quot;</span><span class="s0">,</span><span class="s1">&quot;info&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextPathnameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;i18n&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameNoDataPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;parseData&quot;</span><span class="s0">,</span><span class="s1">&quot;i18nProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_NO_MIDDLEWARE_URL_NORMALIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;domains&quot;</span><span class="s0">,</span><span class="s1">&quot;formatPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;addLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;ignorePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;lower&quot;</span><span class="s0">,</span><span class="s1">&quot;forceLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;formatSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;password&quot;</span><span class="s0">,</span><span class="s1">&quot;username&quot;</span><span class="s0">,</span><span class="s1">&quot;toJSON&quot;</span><span class="s0">,</span><span class="s1">&quot;clone&quot;</span><span class="s0">,</span><span class="s1">&quot;Request&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseAbortedName&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseAborted&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadStart&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadTimes&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadCount&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbortError&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeToNodeResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntilForEnd&quot;</span><span class="s0">,</span><span class="s1">&quot;errored&quot;</span><span class="s0">,</span><span class="s1">&quot;destroyed&quot;</span><span class="s0">,</span><span class="s1">&quot;createAbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;writableFinished&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;writer&quot;</span><span class="s0">,</span><span class="s1">&quot;createWriterFromResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;started&quot;</span><span class="s0">,</span><span class="s1">&quot;drained&quot;</span><span class="s0">,</span><span class="s1">&quot;onDrain&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;off&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;WritableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_OTEL_PERFORMANCE_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;metrics&quot;</span><span class="s0">,</span><span class="s1">&quot;getClientComponentLoaderMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;measure&quot;</span><span class="s0">,</span><span class="s1">&quot;flushHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;ok&quot;</span><span class="s0">,</span><span class="s1">&quot;flush&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">,</span><span class="s1">&quot;destroy&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeTo&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;EMPTY&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;fromStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;assignMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;isNull&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnchunkedString&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;chainStreams&quot;</span><span class="s0">,</span><span class="s1">&quot;streams&quot;</span><span class="s0">,</span><span class="s1">&quot;TransformStream&quot;</span><span class="s0">,</span><span class="s1">&quot;preventClose&quot;</span><span class="s0">,</span><span class="s1">&quot;nextStream&quot;</span><span class="s0">,</span><span class="s1">&quot;lastStream&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;coerce&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;fromResponseCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;html&quot;</span><span class="s0">,</span><span class="s1">&quot;pageData&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;rscData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;toResponseCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isMiss&quot;</span><span class="s0">,</span><span class="s1">&quot;isStale&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControl&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;minimal_mode&quot;</span><span class="s0">,</span><span class="s1">&quot;batcher&quot;</span><span class="s0">,</span><span class="s1">&quot;responseGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;hasResolved&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;isFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;prom&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheItem&quot;</span><span class="s0">,</span><span class="s1">&quot;expiresAt&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKindToIncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKind&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;isRevalidating&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveValue&quot;</span><span class="s0">,</span><span class="s1">&quot;newRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpire&quot;</span><span class="s0">,</span><span class="s1">&quot;expire&quot;</span><span class="s0">,</span><span class="s1">&quot;MultiFileWriter&quot;</span><span class="s0">,</span><span class="s1">&quot;tasks&quot;</span><span class="s0">,</span><span class="s1">&quot;findOrCreateTask&quot;</span><span class="s0">,</span><span class="s1">&quot;directory&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;wait&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;flatMap&quot;</span><span class="s0">,</span><span class="s1">&quot;FileSystemCache&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_DEBUG_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;flushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;serverDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;maxMemoryCacheSize&quot;</span><span class="s0">,</span><span class="s1">&quot;memoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;getMemoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;resetRequestCache&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateTag&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;fileData&quot;</span><span class="s0">,</span><span class="s1">&quot;mtime&quot;</span><span class="s0">,</span><span class="s1">&quot;lastModified&quot;</span><span class="s0">,</span><span class="s1">&quot;getTime&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedData&quot;</span><span class="s0">,</span><span class="s1">&quot;storedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeSegmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentsDir&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentDataFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheTags&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;combinedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;softTags&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;toRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;dev&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalMode&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCacheKeyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;CurCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedRevalidateHeaderKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;locks&quot;</span><span class="s0">,</span><span class="s1">&quot;hasCustomCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlersSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;_globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;globalCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TEST_MAX_ISR_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;disableForTestmode&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_TEST_PROXY&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControls&quot;</span><span class="s0">,</span><span class="s1">&quot;SharedCacheControls&quot;</span><span class="s0">,</span><span class="s1">&quot;preview&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreviouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;_requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;calculateRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;fromTime&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;timeOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;initialRevalidateSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;_getPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;lock&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyChunks&quot;</span><span class="s0">,</span><span class="s1">&quot;_ogBody&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;readableBody&quot;</span><span class="s0">,</span><span class="s1">&quot;chunks&quot;</span><span class="s0">,</span><span class="s1">&quot;total&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;formData&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;blob&quot;</span><span class="s0">,</span><span class="s1">&quot;Blob&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheString&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;credentials&quot;</span><span class="s0">,</span><span class="s1">&quot;referrer&quot;</span><span class="s0">,</span><span class="s1">&quot;referrerPolicy&quot;</span><span class="s0">,</span><span class="s1">&quot;integrity&quot;</span><span class="s0">,</span><span class="s1">&quot;createHash&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheData&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;resumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;memoryCacheData&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;age&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;itemSize&quot;</span><span class="s0">,</span><span class="s1">&quot;isImplicitBuildTimeCache&quot;</span><span class="s0">,</span><span class="s1">&quot;warningText&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersMapSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersSetSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;reference&quot;</span><span class="s0">,</span><span class="s1">&quot;interopDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;mod&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;RouterServerContextSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;routerServerGlobal&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicImportEsmDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteModule&quot;</span><span class="s0">,</span><span class="s1">&quot;userland&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeProjectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;isDev&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentationOnRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteProjectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;cwd&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifests&quot;</span><span class="s0">,</span><span class="s1">&quot;srcPage&quot;</span><span class="s0">,</span><span class="s1">&quot;projectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifestFromRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;routesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;buildManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackBuildManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;reactLoadableManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFontManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;clientReferenceManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;serverActionsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;subresourceIntegrityManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;serverFilesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicCssManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;manifest&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMissing&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticMetadataRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRouteRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isMetadataRouteFile&quot;</span><span class="s0">,</span><span class="s1">&quot;appDirRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;pageExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;strictlyMatchExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;suffixMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;metadataRouteFilesRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedAppDirRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;useEval&quot;</span><span class="s0">,</span><span class="s1">&quot;skipParse&quot;</span><span class="s0">,</span><span class="s1">&quot;__RSC_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionRoutePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;regex&quot;</span><span class="s0">,</span><span class="s1">&quot;loadCustomCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;initializeCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultCache&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;RemoteCache&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;getIncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;CacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheMaxMemorySize&quot;</span><span class="s0">,</span><span class="s1">&quot;isrFlushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;onRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;errorContext&quot;</span><span class="s0">,</span><span class="s1">&quot;routerServerContext&quot;</span><span class="s0">,</span><span class="s1">&quot;logErrorWithOriginalStack&quot;</span><span class="s0">,</span><span class="s1">&quot;prepare&quot;</span><span class="s0">,</span><span class="s1">&quot;localeResult&quot;</span><span class="s0">,</span><span class="s1">&quot;previewData&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureInstrumentationRegistered&quot;</span><span class="s0">,</span><span class="s1">&quot;manifests&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextDataRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;originalQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;pageIsDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;serverUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixRouteKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;includeSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;includePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInterceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;paramMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;namedParameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;namedRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;excludeOptionalTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;parameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;getParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;groupIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;markerMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;checkRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;getPathMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;regexp&quot;</span><span class="s0">,</span><span class="s1">&quot;delimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;sensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;regexpToFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;regexModifier&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;removeUnnamedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;missing&quot;</span><span class="s0">,</span><span class="s1">&quot;hasParams&quot;</span><span class="s0">,</span><span class="s1">&quot;matchHas&quot;</span><span class="s0">,</span><span class="s1">&quot;hasMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasItem&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;paramName&quot;</span><span class="s0">,</span><span class="s1">&quot;newParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;charCode&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;groupKey&quot;</span><span class="s0">,</span><span class="s1">&quot;stateHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndValidateFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;assert&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;newUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;escaped&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;parseRelativeUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;globalBase&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedBase&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedURL&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;destSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;destPath&quot;</span><span class="s0">,</span><span class="s1">&quot;destParams&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;strOrArray&quot;</span><span class="s0">,</span><span class="s1">&quot;appendParamsToQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;actualValue&quot;</span><span class="s0">,</span><span class="s1">&quot;nextInternalLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParams&quot;</span><span class="s0">,</span><span class="s1">&quot;afterFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesPage&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathnameNoSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeQueryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;routeParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;getParamsFromRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatchesHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;keyName&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDynamicRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreMissingOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;hasValidParams&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;isDefaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultVal&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeCdnUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;_parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;formatUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;urlObj&quot;</span><span class="s0">,</span><span class="s1">&quot;querystring&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolateDynamicPath&quot;</span><span class="s0">,</span><span class="s1">&quot;paramValue&quot;</span><span class="s0">,</span><span class="s1">&quot;builtParam&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceAll&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TRAILING_SLASH&quot;</span><span class="s0">,</span><span class="s1">&quot;addRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;combinedParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;originalValue&quot;</span><span class="s0">,</span><span class="s1">&quot;queryValue&quot;</span><span class="s0">,</span><span class="s1">&quot;queryResult&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsToInterpolate&quot;</span><span class="s0">,</span><span class="s1">&quot;isDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedSrcPage&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;seg&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;getResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;responseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handleResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;purpose&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBody&quot;</span><span class="s0">,</span><span class="s1">&quot;limit&quot;</span><span class="s0">,</span><span class="s1">&quot;parameters&quot;</span><span class="s0">,</span><span class="s1">&quot;encoding&quot;</span><span class="s0">,</span><span class="s1">&quot;charset&quot;</span><span class="s0">,</span><span class="s1">&quot;getRawBody&quot;</span><span class="s0">,</span><span class="s1">&quot;parseJson&quot;</span><span class="s0">,</span><span class="s1">&quot;qs&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidData&quot;</span><span class="s0">,</span><span class="s1">&quot;urlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_onlyGenerated&quot;</span><span class="s0">,</span><span class="s1">&quot;trustHostHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;internalRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;apiResolver&quot;</span><span class="s0">,</span><span class="s1">&quot;resolverModule&quot;</span><span class="s0">,</span><span class="s1">&quot;apiContext&quot;</span><span class="s0">,</span><span class="s1">&quot;propagateError&quot;</span><span class="s0">,</span><span class="s1">&quot;onError&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyParser&quot;</span><span class="s0">,</span><span class="s1">&quot;api&quot;</span><span class="s0">,</span><span class="s1">&quot;responseLimit&quot;</span><span class="s0">,</span><span class="s1">&quot;externalResolver&quot;</span><span class="s0">,</span><span class="s1">&quot;apiReq&quot;</span><span class="s0">,</span><span class="s1">&quot;sizeLimit&quot;</span><span class="s0">,</span><span class="s1">&quot;contentLength&quot;</span><span class="s0">,</span><span class="s1">&quot;maxContentLength&quot;</span><span class="s0">,</span><span class="s1">&quot;bytes&quot;</span><span class="s0">,</span><span class="s1">&quot;writeData&quot;</span><span class="s0">,</span><span class="s1">&quot;apiRes&quot;</span><span class="s0">,</span><span class="s1">&quot;endResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;byteLength&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;send&quot;</span><span class="s0">,</span><span class="s1">&quot;sendData&quot;</span><span class="s0">,</span><span class="s1">&quot;removeHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;Stream&quot;</span><span class="s0">,</span><span class="s1">&quot;pipe&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSONLike&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifiedBody&quot;</span><span class="s0">,</span><span class="s1">&quot;etag&quot;</span><span class="s0">,</span><span class="s1">&quot;generateETag&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;weak&quot;</span><span class="s0">,</span><span class="s1">&quot;fnv1a52&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;t0&quot;</span><span class="s0">,</span><span class="s1">&quot;v0&quot;</span><span class="s0">,</span><span class="s1">&quot;t1&quot;</span><span class="s0">,</span><span class="s1">&quot;v1&quot;</span><span class="s0">,</span><span class="s1">&quot;t2&quot;</span><span class="s0">,</span><span class="s1">&quot;v2&quot;</span><span class="s0">,</span><span class="s1">&quot;t3&quot;</span><span class="s0">,</span><span class="s1">&quot;v3&quot;</span><span class="s0">,</span><span class="s1">&quot;fresh&quot;</span><span class="s0">,</span><span class="s1">&quot;json&quot;</span><span class="s0">,</span><span class="s1">&quot;setDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;enable&quot;</span><span class="s0">,</span><span class="s1">&quot;setPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;sign&quot;</span><span class="s0">,</span><span class="s1">&quot;algorithm&quot;</span><span class="s0">,</span><span class="s1">&quot;maxAge&quot;</span><span class="s0">,</span><span class="s1">&quot;expiresIn&quot;</span><span class="s0">,</span><span class="s1">&quot;resolver&quot;</span><span class="s0">,</span><span class="s1">&quot;routerKind&quot;</span><span class="s0">,</span><span class="s1">&quot;routePath&quot;</span><span class="s0">,</span><span class="s1">&quot;routeType&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateReason&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesAPIRouteModule&quot;</span><span class="s0">,</span><span class="s1">&quot;apiResolverWrapped&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">33</span><span class="s0">,</span><span class="s2">34</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">38</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">40</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">51</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">53</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">55</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">57</span><span class="s0">,</span><span class="s2">58</span><span class="s0">,</span><span class="s2">59</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">61</span><span class="s0">,</span><span class="s2">62</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">64</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">68</span><span class="s0">,</span><span class="s2">69</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">73</span><span class="s0">,</span><span class="s2">74</span><span class="s0">,</span><span class="s2">75</span><span class="s0">,</span><span class="s2">76</span><span class="s0">,</span><span class="s2">77</span><span class="s0">,</span><span class="s2">78</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">80</span><span class="s0">,</span><span class="s2">81</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">85</span><span class="s0">,</span><span class="s2">86</span><span class="s0">,</span><span class="s2">87</span><span class="s0">,</span><span class="s2">88</span><span class="s0">,</span><span class="s2">89</span><span class="s0">,</span><span class="s2">90</span><span class="s0">,</span><span class="s2">91</span><span class="s0">,</span><span class="s2">92</span><span class="s0">,</span><span class="s2">93</span><span class="s0">,</span><span class="s2">94</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">96</span><span class="s0">,</span><span class="s2">97</span><span class="s0">,</span><span class="s2">98</span><span class="s0">,</span><span class="s2">99</span><span class="s0">,</span><span class="s2">100</span><span class="s0">,</span><span class="s2">101</span><span class="s0">,</span><span class="s2">102</span><span class="s0">]}</span></pre>
</body>
</html>