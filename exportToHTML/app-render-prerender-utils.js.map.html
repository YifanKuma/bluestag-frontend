<html>
<head>
<title>app-render-prerender-utils.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app-render-prerender-utils.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/app-render-prerender-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is a utility function to make scheduling sequential tasks that run back to back easier.</span><span class="s3">\n </span><span class="s1">* We schedule on the same queue (setImmediate) at the same time to ensure no other events can sneak in between.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function prerenderAndAbortInSequentialTasks&lt;R&gt;(</span><span class="s3">\n  </span><span class="s1">prerender: () =&gt; Promise&lt;R&gt;,</span><span class="s3">\n  </span><span class="s1">abort: () =&gt; void</span><span class="s3">\n</span><span class="s1">): Promise&lt;R&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      </span><span class="s1">'`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return new Promise((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">let pendingResult: Promise&lt;R&gt;</span><span class="s3">\n      </span><span class="s1">setImmediate(() =&gt; {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">pendingResult = prerender()</span><span class="s3">\n          </span><span class="s1">pendingResult.catch(() =&gt; {})</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">reject(err)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">setImmediate(() =&gt; {</span><span class="s3">\n        </span><span class="s1">abort()</span><span class="s3">\n        </span><span class="s1">resolve(pendingResult)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Like `prerenderAndAbortInSequentialTasks`, but with another task between `prerender` and `abort`,</span><span class="s3">\n </span><span class="s1">* which allows us to move a part of the render into a separate task.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function prerenderAndAbortInSequentialTasksWithStages&lt;R&gt;(</span><span class="s3">\n  </span><span class="s1">prerender: () =&gt; Promise&lt;R&gt;,</span><span class="s3">\n  </span><span class="s1">advanceStage: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">abort: () =&gt; void</span><span class="s3">\n</span><span class="s1">): Promise&lt;R&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      </span><span class="s1">'`prerenderAndAbortInSequentialTasksWithStages` should not be called in edge runtime.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return new Promise((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">let pendingResult: Promise&lt;R&gt;</span><span class="s3">\n      </span><span class="s1">setImmediate(() =&gt; {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">pendingResult = prerender()</span><span class="s3">\n          </span><span class="s1">pendingResult.catch(() =&gt; {})</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">reject(err)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">setImmediate(() =&gt; {</span><span class="s3">\n        </span><span class="s1">advanceStage()</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">setImmediate(() =&gt; {</span><span class="s3">\n        </span><span class="s1">abort()</span><span class="s3">\n        </span><span class="s1">resolve(pendingResult)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// React's RSC prerender function will emit an incomplete flight stream when using `prerender`. If the connection</span><span class="s3">\n</span><span class="s1">// closes then whatever hanging chunks exist will be errored. This is because prerender (an experimental feature)</span><span class="s3">\n</span><span class="s1">// has not yet implemented a concept of resume. For now we will simulate a paused connection by wrapping the stream</span><span class="s3">\n</span><span class="s1">// in one that doesn't close even when the underlying is complete.</span><span class="s3">\n</span><span class="s1">export class ReactServerResult {</span><span class="s3">\n  </span><span class="s1">private _stream: null | ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(stream: ReadableStream&lt;Uint8Array&gt;) {</span><span class="s3">\n    </span><span class="s1">this._stream = stream</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">tee() {</span><span class="s3">\n    </span><span class="s1">if (this._stream === null) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Cannot tee a ReactServerResult that has already been consumed'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const tee = this._stream.tee()</span><span class="s3">\n    </span><span class="s1">this._stream = tee[0]</span><span class="s3">\n    </span><span class="s1">return tee[1]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">consume() {</span><span class="s3">\n    </span><span class="s1">if (this._stream === null) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Cannot consume a ReactServerResult that has already been consumed'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const stream = this._stream</span><span class="s3">\n    </span><span class="s1">this._stream = null</span><span class="s3">\n    </span><span class="s1">return stream</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReactServerPrerenderResolveToType = {</span><span class="s3">\n  </span><span class="s1">prelude: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function createReactServerPrerenderResult(</span><span class="s3">\n  </span><span class="s1">underlying: Promise&lt;ReactServerPrerenderResolveToType&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReactServerPrerenderResult&gt; {</span><span class="s3">\n  </span><span class="s1">const chunks: Array&lt;Uint8Array&gt; = []</span><span class="s3">\n  </span><span class="s1">const { prelude } = await underlying</span><span class="s3">\n  </span><span class="s1">const reader = prelude.getReader()</span><span class="s3">\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n    </span><span class="s1">if (done) {</span><span class="s3">\n      </span><span class="s1">return new ReactServerPrerenderResult(chunks)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">chunks.push(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function createReactServerPrerenderResultFromRender(</span><span class="s3">\n  </span><span class="s1">underlying: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReactServerPrerenderResult&gt; {</span><span class="s3">\n  </span><span class="s1">const chunks: Array&lt;Uint8Array&gt; = []</span><span class="s3">\n  </span><span class="s1">const reader = underlying.getReader()</span><span class="s3">\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n    </span><span class="s1">if (done) {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">chunks.push(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return new ReactServerPrerenderResult(chunks)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class ReactServerPrerenderResult {</span><span class="s3">\n  </span><span class="s1">private _chunks: null | Array&lt;Uint8Array&gt;</span><span class="s3">\n\n  </span><span class="s1">private assertChunks(expression: string): Array&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">if (this._chunks === null) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">`Cannot </span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">` on a ReactServerPrerenderResult that has already been consumed.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this._chunks</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private consumeChunks(expression: string): Array&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">const chunks = this.assertChunks(expression)</span><span class="s3">\n    </span><span class="s1">this.consume()</span><span class="s3">\n    </span><span class="s1">return chunks</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">consume(): void {</span><span class="s3">\n    </span><span class="s1">this._chunks = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(chunks: Array&lt;Uint8Array&gt;) {</span><span class="s3">\n    </span><span class="s1">this._chunks = chunks</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">asUnclosingStream(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">const chunks = this.assertChunks('asUnclosingStream()')</span><span class="s3">\n    </span><span class="s1">return createUnclosingStream(chunks)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">consumeAsUnclosingStream(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">const chunks = this.consumeChunks('consumeAsUnclosingStream()')</span><span class="s3">\n    </span><span class="s1">return createUnclosingStream(chunks)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">asStream(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">const chunks = this.assertChunks('asStream()')</span><span class="s3">\n    </span><span class="s1">return createClosingStream(chunks)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">consumeAsStream(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">const chunks = this.consumeChunks('consumeAsStream()')</span><span class="s3">\n    </span><span class="s1">return createClosingStream(chunks)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createUnclosingStream(</span><span class="s3">\n  </span><span class="s1">chunks: Array&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">async pull(controller) {</span><span class="s3">\n      </span><span class="s1">if (i &lt; chunks.length) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunks[i++])</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// we intentionally keep the stream open. The consumer will clear</span><span class="s3">\n      </span><span class="s1">// out chunks once finished and the remaining memory will be GC'd</span><span class="s3">\n      </span><span class="s1">// when this object goes out of scope</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createClosingStream(</span><span class="s3">\n  </span><span class="s1">chunks: Array&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">async pull(controller) {</span><span class="s3">\n      </span><span class="s1">if (i &lt; chunks.length) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunks[i++])</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">controller.close()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function processPrelude(</span><span class="s3">\n  </span><span class="s1">unprocessedPrelude: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const [prelude, peek] = unprocessedPrelude.tee()</span><span class="s3">\n\n  </span><span class="s1">const reader = peek.getReader()</span><span class="s3">\n  </span><span class="s1">const firstResult = await reader.read()</span><span class="s3">\n  </span><span class="s1">reader.cancel()</span><span class="s3">\n\n  </span><span class="s1">const preludeIsEmpty = firstResult.done === true</span><span class="s3">\n\n  </span><span class="s1">return { prelude, preludeIsEmpty }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;ReactServerPrerenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;ReactServerResult&quot;</span><span class="s0">,</span><span class="s1">&quot;createReactServerPrerenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;createReactServerPrerenderResultFromRender&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderAndAbortInSequentialTasks&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderAndAbortInSequentialTasksWithStages&quot;</span><span class="s0">,</span><span class="s1">&quot;processPrelude&quot;</span><span class="s0">,</span><span class="s1">&quot;prerender&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingResult&quot;</span><span class="s0">,</span><span class="s1">&quot;setImmediate&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;advanceStage&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;_stream&quot;</span><span class="s0">,</span><span class="s1">&quot;tee&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;consume&quot;</span><span class="s0">,</span><span class="s1">&quot;underlying&quot;</span><span class="s0">,</span><span class="s1">&quot;chunks&quot;</span><span class="s0">,</span><span class="s1">&quot;prelude&quot;</span><span class="s0">,</span><span class="s1">&quot;reader&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;read&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;assertChunks&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;_chunks&quot;</span><span class="s0">,</span><span class="s1">&quot;consumeChunks&quot;</span><span class="s0">,</span><span class="s1">&quot;asUnclosingStream&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnclosingStream&quot;</span><span class="s0">,</span><span class="s1">&quot;consumeAsUnclosingStream&quot;</span><span class="s0">,</span><span class="s1">&quot;asStream&quot;</span><span class="s0">,</span><span class="s1">&quot;createClosingStream&quot;</span><span class="s0">,</span><span class="s1">&quot;consumeAsStream&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;pull&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;unprocessedPrelude&quot;</span><span class="s0">,</span><span class="s1">&quot;peek&quot;</span><span class="s0">,</span><span class="s1">&quot;firstResult&quot;</span><span class="s0">,</span><span class="s1">&quot;cancel&quot;</span><span class="s0">,</span><span class="s1">&quot;preludeIsEmpty&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>