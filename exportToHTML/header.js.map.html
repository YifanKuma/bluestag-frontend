<html>
<head>
<title>header.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
header.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;header.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/header.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// parse a 512-byte header block to a data object, or vice-versa</span><span class="s3">\n</span><span class="s1">// encode returns `true` if a pax extended header is needed, because</span><span class="s3">\n</span><span class="s1">// the data could not be faithfully encoded in a simple header.</span><span class="s3">\n</span><span class="s1">// (Also, check header.needPax to see if it needs a pax header.)</span><span class="s3">\n\n</span><span class="s1">import { posix as pathModule } from 'node:path'</span><span class="s3">\n</span><span class="s1">import * as large from './large-numbers.js'</span><span class="s3">\n</span><span class="s1">import type { EntryTypeCode, EntryTypeName } from './types.js'</span><span class="s3">\n</span><span class="s1">import * as types from './types.js'</span><span class="s3">\n\n</span><span class="s1">export type HeaderData = {</span><span class="s3">\n  </span><span class="s1">path?: string</span><span class="s3">\n  </span><span class="s1">mode?: number</span><span class="s3">\n  </span><span class="s1">uid?: number</span><span class="s3">\n  </span><span class="s1">gid?: number</span><span class="s3">\n  </span><span class="s1">size?: number</span><span class="s3">\n  </span><span class="s1">cksum?: number</span><span class="s3">\n  </span><span class="s1">type?: EntryTypeName | 'Unsupported'</span><span class="s3">\n  </span><span class="s1">linkpath?: string</span><span class="s3">\n  </span><span class="s1">uname?: string</span><span class="s3">\n  </span><span class="s1">gname?: string</span><span class="s3">\n  </span><span class="s1">devmaj?: number</span><span class="s3">\n  </span><span class="s1">devmin?: number</span><span class="s3">\n  </span><span class="s1">atime?: Date</span><span class="s3">\n  </span><span class="s1">ctime?: Date</span><span class="s3">\n  </span><span class="s1">mtime?: Date</span><span class="s3">\n\n  </span><span class="s1">// fields that are common in extended PAX headers, but not in the</span><span class="s3">\n  </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">standard</span><span class="s3">\&quot; </span><span class="s1">tar header block</span><span class="s3">\n  </span><span class="s1">charset?: string</span><span class="s3">\n  </span><span class="s1">comment?: string</span><span class="s3">\n  </span><span class="s1">dev?: number</span><span class="s3">\n  </span><span class="s1">ino?: number</span><span class="s3">\n  </span><span class="s1">nlink?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class Header implements HeaderData {</span><span class="s3">\n  </span><span class="s1">cksumValid: boolean = false</span><span class="s3">\n  </span><span class="s1">needPax: boolean = false</span><span class="s3">\n  </span><span class="s1">nullBlock: boolean = false</span><span class="s3">\n\n  </span><span class="s1">block?: Buffer</span><span class="s3">\n  </span><span class="s1">path?: string</span><span class="s3">\n  </span><span class="s1">mode?: number</span><span class="s3">\n  </span><span class="s1">uid?: number</span><span class="s3">\n  </span><span class="s1">gid?: number</span><span class="s3">\n  </span><span class="s1">size?: number</span><span class="s3">\n  </span><span class="s1">cksum?: number</span><span class="s3">\n  </span><span class="s1">#type: EntryTypeCode | 'Unsupported' = 'Unsupported'</span><span class="s3">\n  </span><span class="s1">linkpath?: string</span><span class="s3">\n  </span><span class="s1">uname?: string</span><span class="s3">\n  </span><span class="s1">gname?: string</span><span class="s3">\n  </span><span class="s1">devmaj: number = 0</span><span class="s3">\n  </span><span class="s1">devmin: number = 0</span><span class="s3">\n  </span><span class="s1">atime?: Date</span><span class="s3">\n  </span><span class="s1">ctime?: Date</span><span class="s3">\n  </span><span class="s1">mtime?: Date</span><span class="s3">\n\n  </span><span class="s1">charset?: string</span><span class="s3">\n  </span><span class="s1">comment?: string</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">data?: Buffer | HeaderData,</span><span class="s3">\n    </span><span class="s1">off: number = 0,</span><span class="s3">\n    </span><span class="s1">ex?: HeaderData,</span><span class="s3">\n    </span><span class="s1">gex?: HeaderData,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (Buffer.isBuffer(data)) {</span><span class="s3">\n      </span><span class="s1">this.decode(data, off || 0, ex, gex)</span><span class="s3">\n    </span><span class="s1">} else if (data) {</span><span class="s3">\n      </span><span class="s1">this.#slurp(data)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">decode(</span><span class="s3">\n    </span><span class="s1">buf: Buffer,</span><span class="s3">\n    </span><span class="s1">off: number,</span><span class="s3">\n    </span><span class="s1">ex?: HeaderData,</span><span class="s3">\n    </span><span class="s1">gex?: HeaderData,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!off) {</span><span class="s3">\n      </span><span class="s1">off = 0</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!buf || !(buf.length &gt;= off + 512)) {</span><span class="s3">\n      </span><span class="s1">throw new Error('need 512 bytes for header')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.path = decString(buf, off, 100)</span><span class="s3">\n    </span><span class="s1">this.mode = decNumber(buf, off + 100, 8)</span><span class="s3">\n    </span><span class="s1">this.uid = decNumber(buf, off + 108, 8)</span><span class="s3">\n    </span><span class="s1">this.gid = decNumber(buf, off + 116, 8)</span><span class="s3">\n    </span><span class="s1">this.size = decNumber(buf, off + 124, 12)</span><span class="s3">\n    </span><span class="s1">this.mtime = decDate(buf, off + 136, 12)</span><span class="s3">\n    </span><span class="s1">this.cksum = decNumber(buf, off + 148, 12)</span><span class="s3">\n\n    </span><span class="s1">// if we have extended or global extended headers, apply them now</span><span class="s3">\n    </span><span class="s1">// See https://github.com/npm/node-tar/pull/187</span><span class="s3">\n    </span><span class="s1">// Apply global before local, so it overrides</span><span class="s3">\n    </span><span class="s1">if (gex) this.#slurp(gex, true)</span><span class="s3">\n    </span><span class="s1">if (ex) this.#slurp(ex)</span><span class="s3">\n\n    </span><span class="s1">// old tar versions marked dirs as a file with a trailing /</span><span class="s3">\n    </span><span class="s1">const t = decString(buf, off + 156, 1)</span><span class="s3">\n    </span><span class="s1">if (types.isCode(t)) {</span><span class="s3">\n      </span><span class="s1">this.#type = t || '0'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.#type === '0' &amp;&amp; this.path.slice(-1) === '/') {</span><span class="s3">\n      </span><span class="s1">this.#type = '5'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// tar implementations sometimes incorrectly put the stat(dir).size</span><span class="s3">\n    </span><span class="s1">// as the size in the tarball, even though Directory entries are</span><span class="s3">\n    </span><span class="s1">// not able to have any body at all.  In the very rare chance that</span><span class="s3">\n    </span><span class="s1">// it actually DOES have a body, we weren't going to do anything with</span><span class="s3">\n    </span><span class="s1">// it anyway, and it'll just be a warning about an invalid header.</span><span class="s3">\n    </span><span class="s1">if (this.#type === '5') {</span><span class="s3">\n      </span><span class="s1">this.size = 0</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.linkpath = decString(buf, off + 157, 100)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">buf.subarray(off + 257, off + 265).toString() ===</span><span class="s3">\n      </span><span class="s1">'ustar</span><span class="s3">\\</span><span class="s1">u000000'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.uname = decString(buf, off + 265, 32)</span><span class="s3">\n      </span><span class="s1">this.gname = decString(buf, off + 297, 32)</span><span class="s3">\n      </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n      </span><span class="s1">this.devmaj = decNumber(buf, off + 329, 8) ?? 0</span><span class="s3">\n      </span><span class="s1">this.devmin = decNumber(buf, off + 337, 8) ?? 0</span><span class="s3">\n      </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n      </span><span class="s1">if (buf[off + 475] !== 0) {</span><span class="s3">\n        </span><span class="s1">// definitely a prefix, definitely &gt;130 chars.</span><span class="s3">\n        </span><span class="s1">const prefix = decString(buf, off + 345, 155)</span><span class="s3">\n        </span><span class="s1">this.path = prefix + '/' + this.path</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const prefix = decString(buf, off + 345, 130)</span><span class="s3">\n        </span><span class="s1">if (prefix) {</span><span class="s3">\n          </span><span class="s1">this.path = prefix + '/' + this.path</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.atime = decDate(buf, off + 476, 12)</span><span class="s3">\n        </span><span class="s1">this.ctime = decDate(buf, off + 488, 12)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let sum = 8 * 0x20</span><span class="s3">\n    </span><span class="s1">for (let i = off; i &lt; off + 148; i++) {</span><span class="s3">\n      </span><span class="s1">sum += buf[i] as number</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (let i = off + 156; i &lt; off + 512; i++) {</span><span class="s3">\n      </span><span class="s1">sum += buf[i] as number</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.cksumValid = sum === this.cksum</span><span class="s3">\n    </span><span class="s1">if (this.cksum === undefined &amp;&amp; sum === 8 * 0x20) {</span><span class="s3">\n      </span><span class="s1">this.nullBlock = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">#slurp(ex: HeaderData, gex: boolean = false) {</span><span class="s3">\n    </span><span class="s1">Object.assign(</span><span class="s3">\n      </span><span class="s1">this,</span><span class="s3">\n      </span><span class="s1">Object.fromEntries(</span><span class="s3">\n        </span><span class="s1">Object.entries(ex).filter(([k, v]) =&gt; {</span><span class="s3">\n          </span><span class="s1">// we slurp in everything except for the path attribute in</span><span class="s3">\n          </span><span class="s1">// a global extended header, because that's weird. Also, any</span><span class="s3">\n          </span><span class="s1">// null/undefined values are ignored.</span><span class="s3">\n          </span><span class="s1">return !(</span><span class="s3">\n            </span><span class="s1">v === null ||</span><span class="s3">\n            </span><span class="s1">v === undefined ||</span><span class="s3">\n            </span><span class="s1">(k === 'path' &amp;&amp; gex) ||</span><span class="s3">\n            </span><span class="s1">(k === 'linkpath' &amp;&amp; gex) ||</span><span class="s3">\n            </span><span class="s1">k === 'global'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">encode(buf?: Buffer, off: number = 0) {</span><span class="s3">\n    </span><span class="s1">if (!buf) {</span><span class="s3">\n      </span><span class="s1">buf = this.block = Buffer.alloc(512)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.#type === 'Unsupported') {</span><span class="s3">\n      </span><span class="s1">this.#type = '0'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!(buf.length &gt;= off + 512)) {</span><span class="s3">\n      </span><span class="s1">throw new Error('need 512 bytes for header')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const prefixSize = this.ctime || this.atime ? 130 : 155</span><span class="s3">\n    </span><span class="s1">const split = splitPrefix(this.path || '', prefixSize)</span><span class="s3">\n    </span><span class="s1">const path = split[0]</span><span class="s3">\n    </span><span class="s1">const prefix = split[1]</span><span class="s3">\n    </span><span class="s1">this.needPax = !!split[2]</span><span class="s3">\n\n    </span><span class="s1">this.needPax = encString(buf, off, 100, path) || this.needPax</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encNumber(buf, off + 100, 8, this.mode) || this.needPax</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encNumber(buf, off + 108, 8, this.uid) || this.needPax</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encNumber(buf, off + 116, 8, this.gid) || this.needPax</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encNumber(buf, off + 124, 12, this.size) || this.needPax</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encDate(buf, off + 136, 12, this.mtime) || this.needPax</span><span class="s3">\n    </span><span class="s1">buf[off + 156] = this.#type.charCodeAt(0)</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encString(buf, off + 157, 100, this.linkpath) || this.needPax</span><span class="s3">\n    </span><span class="s1">buf.write('ustar</span><span class="s3">\\</span><span class="s1">u000000', off + 257, 8)</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encString(buf, off + 265, 32, this.uname) || this.needPax</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encString(buf, off + 297, 32, this.gname) || this.needPax</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encNumber(buf, off + 329, 8, this.devmaj) || this.needPax</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encNumber(buf, off + 337, 8, this.devmin) || this.needPax</span><span class="s3">\n    </span><span class="s1">this.needPax =</span><span class="s3">\n      </span><span class="s1">encString(buf, off + 345, prefixSize, prefix) || this.needPax</span><span class="s3">\n    </span><span class="s1">if (buf[off + 475] !== 0) {</span><span class="s3">\n      </span><span class="s1">this.needPax =</span><span class="s3">\n        </span><span class="s1">encString(buf, off + 345, 155, prefix) || this.needPax</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.needPax =</span><span class="s3">\n        </span><span class="s1">encString(buf, off + 345, 130, prefix) || this.needPax</span><span class="s3">\n      </span><span class="s1">this.needPax =</span><span class="s3">\n        </span><span class="s1">encDate(buf, off + 476, 12, this.atime) || this.needPax</span><span class="s3">\n      </span><span class="s1">this.needPax =</span><span class="s3">\n        </span><span class="s1">encDate(buf, off + 488, 12, this.ctime) || this.needPax</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let sum = 8 * 0x20</span><span class="s3">\n    </span><span class="s1">for (let i = off; i &lt; off + 148; i++) {</span><span class="s3">\n      </span><span class="s1">sum += buf[i] as number</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (let i = off + 156; i &lt; off + 512; i++) {</span><span class="s3">\n      </span><span class="s1">sum += buf[i] as number</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.cksum = sum</span><span class="s3">\n    </span><span class="s1">encNumber(buf, off + 148, 8, this.cksum)</span><span class="s3">\n    </span><span class="s1">this.cksumValid = true</span><span class="s3">\n\n    </span><span class="s1">return this.needPax</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get type(): EntryTypeName {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">this.#type === 'Unsupported' ?</span><span class="s3">\n        </span><span class="s1">this.#type</span><span class="s3">\n      </span><span class="s1">: types.name.get(this.#type)) as EntryTypeName</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get typeKey(): EntryTypeCode | 'Unsupported' {</span><span class="s3">\n    </span><span class="s1">return this.#type</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set type(type: EntryTypeCode | EntryTypeName | 'Unsupported') {</span><span class="s3">\n    </span><span class="s1">const c = String(types.code.get(type as EntryTypeName))</span><span class="s3">\n    </span><span class="s1">if (types.isCode(c) || c === 'Unsupported') {</span><span class="s3">\n      </span><span class="s1">this.#type = c</span><span class="s3">\n    </span><span class="s1">} else if (types.isCode(type)) {</span><span class="s3">\n      </span><span class="s1">this.#type = type</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('invalid entry type: ' + type)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const splitPrefix = (</span><span class="s3">\n  </span><span class="s1">p: string,</span><span class="s3">\n  </span><span class="s1">prefixSize: number,</span><span class="s3">\n</span><span class="s1">): [string, string, boolean] =&gt; {</span><span class="s3">\n  </span><span class="s1">const pathSize = 100</span><span class="s3">\n  </span><span class="s1">let pp = p</span><span class="s3">\n  </span><span class="s1">let prefix = ''</span><span class="s3">\n  </span><span class="s1">let ret: undefined | [string, string, boolean] = undefined</span><span class="s3">\n  </span><span class="s1">const root = pathModule.parse(p).root || '.'</span><span class="s3">\n\n  </span><span class="s1">if (Buffer.byteLength(pp) &lt; pathSize) {</span><span class="s3">\n    </span><span class="s1">ret = [pp, prefix, false]</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// first set prefix to the dir, and path to the base</span><span class="s3">\n    </span><span class="s1">prefix = pathModule.dirname(pp)</span><span class="s3">\n    </span><span class="s1">pp = pathModule.basename(pp)</span><span class="s3">\n\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">Buffer.byteLength(pp) &lt;= pathSize &amp;&amp;</span><span class="s3">\n        </span><span class="s1">Buffer.byteLength(prefix) &lt;= prefixSize</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// both fit!</span><span class="s3">\n        </span><span class="s1">ret = [pp, prefix, false]</span><span class="s3">\n      </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">Buffer.byteLength(pp) &gt; pathSize &amp;&amp;</span><span class="s3">\n        </span><span class="s1">Buffer.byteLength(prefix) &lt;= prefixSize</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// prefix fits in prefix, but path doesn't fit in path</span><span class="s3">\n        </span><span class="s1">ret = [pp.slice(0, pathSize - 1), prefix, true]</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// make path take a bit from prefix</span><span class="s3">\n        </span><span class="s1">pp = pathModule.join(pathModule.basename(prefix), pp)</span><span class="s3">\n        </span><span class="s1">prefix = pathModule.dirname(prefix)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} while (prefix !== root &amp;&amp; ret === undefined)</span><span class="s3">\n\n    </span><span class="s1">// at this point, found no resolution, just truncate</span><span class="s3">\n    </span><span class="s1">if (!ret) {</span><span class="s3">\n      </span><span class="s1">ret = [p.slice(0, pathSize - 1), '', true]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ret</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const decString = (buf: Buffer, off: number, size: number) =&gt;</span><span class="s3">\n  </span><span class="s1">buf</span><span class="s3">\n    </span><span class="s1">.subarray(off, off + size)</span><span class="s3">\n    </span><span class="s1">.toString('utf8')</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">0.*/, '')</span><span class="s3">\n\n</span><span class="s1">const decDate = (buf: Buffer, off: number, size: number) =&gt;</span><span class="s3">\n  </span><span class="s1">numToDate(decNumber(buf, off, size))</span><span class="s3">\n\n</span><span class="s1">const numToDate = (num?: number) =&gt;</span><span class="s3">\n  </span><span class="s1">num === undefined ? undefined : new Date(num * 1000)</span><span class="s3">\n\n</span><span class="s1">const decNumber = (buf: Buffer, off: number, size: number) =&gt;</span><span class="s3">\n  </span><span class="s1">Number(buf[off]) &amp; 0x80 ?</span><span class="s3">\n    </span><span class="s1">large.parse(buf.subarray(off, off + size))</span><span class="s3">\n  </span><span class="s1">: decSmallNumber(buf, off, size)</span><span class="s3">\n\n</span><span class="s1">const nanUndef = (value: number) =&gt; (isNaN(value) ? undefined : value)</span><span class="s3">\n\n</span><span class="s1">const decSmallNumber = (buf: Buffer, off: number, size: number) =&gt;</span><span class="s3">\n  </span><span class="s1">nanUndef(</span><span class="s3">\n    </span><span class="s1">parseInt(</span><span class="s3">\n      </span><span class="s1">buf</span><span class="s3">\n        </span><span class="s1">.subarray(off, off + size)</span><span class="s3">\n        </span><span class="s1">.toString('utf8')</span><span class="s3">\n        </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">0.*$/, '')</span><span class="s3">\n        </span><span class="s1">.trim(),</span><span class="s3">\n      </span><span class="s1">8,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">// the maximum encodable as a null-terminated octal, by field size</span><span class="s3">\n</span><span class="s1">const MAXNUM = {</span><span class="s3">\n  </span><span class="s1">12: 0o77777777777,</span><span class="s3">\n  </span><span class="s1">8: 0o7777777,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const encNumber = (</span><span class="s3">\n  </span><span class="s1">buf: Buffer,</span><span class="s3">\n  </span><span class="s1">off: number,</span><span class="s3">\n  </span><span class="s1">size: 12 | 8,</span><span class="s3">\n  </span><span class="s1">num?: number,</span><span class="s3">\n</span><span class="s1">) =&gt;</span><span class="s3">\n  </span><span class="s1">num === undefined ? false</span><span class="s3">\n  </span><span class="s1">: num &gt; MAXNUM[size] || num &lt; 0 ?</span><span class="s3">\n    </span><span class="s1">(large.encode(num, buf.subarray(off, off + size)), true)</span><span class="s3">\n  </span><span class="s1">: (encSmallNumber(buf, off, size, num), false)</span><span class="s3">\n\n</span><span class="s1">const encSmallNumber = (</span><span class="s3">\n  </span><span class="s1">buf: Buffer,</span><span class="s3">\n  </span><span class="s1">off: number,</span><span class="s3">\n  </span><span class="s1">size: number,</span><span class="s3">\n  </span><span class="s1">num: number,</span><span class="s3">\n</span><span class="s1">) =&gt; buf.write(octalString(num, size), off, size, 'ascii')</span><span class="s3">\n\n</span><span class="s1">const octalString = (num: number, size: number) =&gt;</span><span class="s3">\n  </span><span class="s1">padOctal(Math.floor(num).toString(8), size)</span><span class="s3">\n\n</span><span class="s1">const padOctal = (str: string, size: number) =&gt;</span><span class="s3">\n  </span><span class="s1">(str.length === size - 1 ?</span><span class="s3">\n    </span><span class="s1">str</span><span class="s3">\n  </span><span class="s1">: new Array(size - str.length - 1).join('0') + str + ' ') + '</span><span class="s3">\\</span><span class="s1">0'</span><span class="s3">\n\n</span><span class="s1">const encDate = (</span><span class="s3">\n  </span><span class="s1">buf: Buffer,</span><span class="s3">\n  </span><span class="s1">off: number,</span><span class="s3">\n  </span><span class="s1">size: 8 | 12,</span><span class="s3">\n  </span><span class="s1">date?: Date,</span><span class="s3">\n</span><span class="s1">) =&gt;</span><span class="s3">\n  </span><span class="s1">date === undefined ? false : (</span><span class="s3">\n    </span><span class="s1">encNumber(buf, off, size, date.getTime() / 1000)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">// enough to fill the longest string we've got</span><span class="s3">\n</span><span class="s1">const NULLS = new Array(156).join('</span><span class="s3">\\</span><span class="s1">0')</span><span class="s3">\n</span><span class="s1">// pad with nulls, return true if it's longer or non-ascii</span><span class="s3">\n</span><span class="s1">const encString = (</span><span class="s3">\n  </span><span class="s1">buf: Buffer,</span><span class="s3">\n  </span><span class="s1">off: number,</span><span class="s3">\n  </span><span class="s1">size: number,</span><span class="s3">\n  </span><span class="s1">str?: string,</span><span class="s3">\n</span><span class="s1">) =&gt;</span><span class="s3">\n  </span><span class="s1">str === undefined ? false : (</span><span class="s3">\n    </span><span class="s1">(buf.write(str + NULLS, off, size, 'utf8'),</span><span class="s3">\n    </span><span class="s1">str.length !== Buffer.byteLength(str) || str.length &gt; size)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>