<html>
<head>
<title>react-refresh-babel.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
.s7 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-refresh-babel.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@license </span><span class="s0">React</span>
 <span class="s0">* react-refresh-babel.development.js</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) Facebook, Inc. and its affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s3">'use strict'</span><span class="s2">;</span>

<span class="s4">if </span><span class="s2">(process.env.NODE_ENV !== </span><span class="s3">&quot;production&quot;</span><span class="s2">) {</span>
  <span class="s2">(</span><span class="s4">function</span><span class="s2">() {</span>
<span class="s3">'use strict'</span><span class="s2">;</span>

<span class="s4">function </span><span class="s2">ReactFreshBabelPlugin (babel) {</span>
  <span class="s4">var </span><span class="s2">opts = arguments.length &gt; </span><span class="s5">1 </span><span class="s2">&amp;&amp; arguments[</span><span class="s5">1</span><span class="s2">] !== undefined ? arguments[</span><span class="s5">1</span><span class="s2">] : {};</span>

  <span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">babel.env === </span><span class="s3">'function'</span><span class="s2">) {</span>
    <span class="s0">// Only available in Babel 7.</span>
    <span class="s4">var </span><span class="s2">env = babel.env();</span>

    <span class="s4">if </span><span class="s2">(env !== </span><span class="s3">'development' </span><span class="s2">&amp;&amp; !opts.skipEnvCheck) {</span>
      <span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">'React Refresh Babel transform should only be enabled in development environment. ' </span><span class="s2">+ </span><span class="s3">'Instead, the environment is: &quot;' </span><span class="s2">+ env + </span><span class="s3">'&quot;. If you want to override this check, pass {skipEnvCheck: true} as plugin options.'</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s4">var </span><span class="s2">t = babel.types;</span>
  <span class="s4">var </span><span class="s2">refreshReg = t.identifier(opts.refreshReg || </span><span class="s3">'$RefreshReg$'</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">refreshSig = t.identifier(opts.refreshSig || </span><span class="s3">'$RefreshSig$'</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">registrationsByProgramPath = </span><span class="s4">new </span><span class="s2">Map();</span>

  <span class="s4">function </span><span class="s2">createRegistration(programPath, persistentID) {</span>
    <span class="s4">var </span><span class="s2">handle = programPath.scope.generateUidIdentifier(</span><span class="s3">'c'</span><span class="s2">);</span>

    <span class="s4">if </span><span class="s2">(!registrationsByProgramPath.has(programPath)) {</span>
      <span class="s2">registrationsByProgramPath.set(programPath, []);</span>
    <span class="s2">}</span>

    <span class="s4">var </span><span class="s2">registrations = registrationsByProgramPath.get(programPath);</span>
    <span class="s2">registrations.push({</span>
      <span class="s2">handle: handle,</span>
      <span class="s2">persistentID: persistentID</span>
    <span class="s2">});</span>
    <span class="s4">return </span><span class="s2">handle;</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">isComponentishName(name) {</span>
    <span class="s4">return typeof </span><span class="s2">name === </span><span class="s3">'string' </span><span class="s2">&amp;&amp; name[</span><span class="s5">0</span><span class="s2">] &gt;= </span><span class="s3">'A' </span><span class="s2">&amp;&amp; name[</span><span class="s5">0</span><span class="s2">] &lt;= </span><span class="s3">'Z'</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">findInnerComponents(inferredName, path, callback) {</span>
    <span class="s4">var </span><span class="s2">node = path.node;</span>

    <span class="s4">switch </span><span class="s2">(node.type) {</span>
      <span class="s4">case </span><span class="s3">'Identifier'</span><span class="s2">:</span>
        <span class="s2">{</span>
          <span class="s4">if </span><span class="s2">(!isComponentishName(node.name)) {</span>
            <span class="s4">return false</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s0">// export default hoc(Foo)</span>
          <span class="s0">// const X = hoc(Foo)</span>


          <span class="s2">callback(inferredName, node, </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s4">return true</span><span class="s2">;</span>
        <span class="s2">}</span>

      <span class="s4">case </span><span class="s3">'FunctionDeclaration'</span><span class="s2">:</span>
        <span class="s2">{</span>
          <span class="s0">// function Foo() {}</span>
          <span class="s0">// export function Foo() {}</span>
          <span class="s0">// export default function Foo() {}</span>
          <span class="s2">callback(inferredName, node.id, </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s4">return true</span><span class="s2">;</span>
        <span class="s2">}</span>

      <span class="s4">case </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">:</span>
        <span class="s2">{</span>
          <span class="s4">if </span><span class="s2">(node.body.type === </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">) {</span>
            <span class="s4">return false</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s0">// let Foo = () =&gt; {}</span>
          <span class="s0">// export default hoc1(hoc2(() =&gt; {}))</span>


          <span class="s2">callback(inferredName, node, path);</span>
          <span class="s4">return true</span><span class="s2">;</span>
        <span class="s2">}</span>

      <span class="s4">case </span><span class="s3">'FunctionExpression'</span><span class="s2">:</span>
        <span class="s2">{</span>
          <span class="s0">// let Foo = function() {}</span>
          <span class="s0">// const Foo = hoc1(forwardRef(function renderFoo() {}))</span>
          <span class="s0">// export default memo(function() {})</span>
          <span class="s2">callback(inferredName, node, path);</span>
          <span class="s4">return true</span><span class="s2">;</span>
        <span class="s2">}</span>

      <span class="s4">case </span><span class="s3">'CallExpression'</span><span class="s2">:</span>
        <span class="s2">{</span>
          <span class="s4">var </span><span class="s2">argsPath = path.get(</span><span class="s3">'arguments'</span><span class="s2">);</span>

          <span class="s4">if </span><span class="s2">(argsPath === undefined || argsPath.length === </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s4">return false</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">var </span><span class="s2">calleePath = path.get(</span><span class="s3">'callee'</span><span class="s2">);</span>

          <span class="s4">switch </span><span class="s2">(calleePath.node.type) {</span>
            <span class="s4">case </span><span class="s3">'MemberExpression'</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">'Identifier'</span><span class="s2">:</span>
              <span class="s2">{</span>
                <span class="s4">var </span><span class="s2">calleeSource = calleePath.getSource();</span>
                <span class="s4">var </span><span class="s2">firstArgPath = argsPath[</span><span class="s5">0</span><span class="s2">];</span>
                <span class="s4">var </span><span class="s2">innerName = inferredName + </span><span class="s3">'$' </span><span class="s2">+ calleeSource;</span>
                <span class="s4">var </span><span class="s2">foundInside = findInnerComponents(innerName, firstArgPath, callback);</span>

                <span class="s4">if </span><span class="s2">(!foundInside) {</span>
                  <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">} </span><span class="s0">// const Foo = hoc1(hoc2(() =&gt; {}))</span>
                <span class="s0">// export default memo(React.forwardRef(function() {}))</span>


                <span class="s2">callback(inferredName, node, path);</span>
                <span class="s4">return true</span><span class="s2">;</span>
              <span class="s2">}</span>

            <span class="s4">default</span><span class="s2">:</span>
              <span class="s2">{</span>
                <span class="s4">return false</span><span class="s2">;</span>
              <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">}</span>

      <span class="s4">case </span><span class="s3">'VariableDeclarator'</span><span class="s2">:</span>
        <span class="s2">{</span>
          <span class="s4">var </span><span class="s2">init = node.init;</span>

          <span class="s4">if </span><span class="s2">(init === </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s4">return false</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">var </span><span class="s2">name = node.id.name;</span>

          <span class="s4">if </span><span class="s2">(!isComponentishName(name)) {</span>
            <span class="s4">return false</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">switch </span><span class="s2">(init.type) {</span>
            <span class="s4">case </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">'FunctionExpression'</span><span class="s2">:</span>
              <span class="s0">// Likely component definitions.</span>
              <span class="s4">break</span><span class="s2">;</span>

            <span class="s4">case </span><span class="s3">'CallExpression'</span><span class="s2">:</span>
              <span class="s2">{</span>
                <span class="s0">// Maybe a HOC.</span>
                <span class="s0">// Try to determine if this is some form of import.</span>
                <span class="s4">var </span><span class="s2">callee = init.callee;</span>
                <span class="s4">var </span><span class="s2">calleeType = callee.type;</span>

                <span class="s4">if </span><span class="s2">(calleeType === </span><span class="s3">'Import'</span><span class="s2">) {</span>
                  <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">} </span><span class="s4">else if </span><span class="s2">(calleeType === </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
                  <span class="s4">if </span><span class="s2">(callee.name.indexOf(</span><span class="s3">'require'</span><span class="s2">) === </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                  <span class="s2">} </span><span class="s4">else if </span><span class="s2">(callee.name.indexOf(</span><span class="s3">'import'</span><span class="s2">) === </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                  <span class="s2">} </span><span class="s0">// Neither require nor import. Might be a HOC.</span>
                  <span class="s0">// Pass through.</span>

                <span class="s2">}</span>

                <span class="s4">break</span><span class="s2">;</span>
              <span class="s2">}</span>

            <span class="s4">case </span><span class="s3">'TaggedTemplateExpression'</span><span class="s2">:</span>
              <span class="s0">// Maybe something like styled.div`...`</span>
              <span class="s4">break</span><span class="s2">;</span>

            <span class="s4">default</span><span class="s2">:</span>
              <span class="s4">return false</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">var </span><span class="s2">initPath = path.get(</span><span class="s3">'init'</span><span class="s2">);</span>

          <span class="s4">var </span><span class="s2">_foundInside = findInnerComponents(inferredName, initPath, callback);</span>

          <span class="s4">if </span><span class="s2">(_foundInside) {</span>
            <span class="s4">return true</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s0">// See if this identifier is used in JSX. Then it's a component.</span>


          <span class="s4">var </span><span class="s2">binding = path.scope.getBinding(name);</span>

          <span class="s4">if </span><span class="s2">(binding === undefined) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">var </span><span class="s2">isLikelyUsedAsType = </span><span class="s4">false</span><span class="s2">;</span>
          <span class="s4">var </span><span class="s2">referencePaths = binding.referencePaths;</span>

          <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; referencePaths.length; i++) {</span>
            <span class="s4">var </span><span class="s2">ref = referencePaths[i];</span>

            <span class="s4">if </span><span class="s2">(ref.node &amp;&amp; ref.node.type !== </span><span class="s3">'JSXIdentifier' </span><span class="s2">&amp;&amp; ref.node.type !== </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
              <span class="s4">continue</span><span class="s2">;</span>
            <span class="s2">}</span>

            <span class="s4">var </span><span class="s2">refParent = ref.parent;</span>

            <span class="s4">if </span><span class="s2">(refParent.type === </span><span class="s3">'JSXOpeningElement'</span><span class="s2">) {</span>
              <span class="s2">isLikelyUsedAsType = </span><span class="s4">true</span><span class="s2">;</span>
            <span class="s2">} </span><span class="s4">else if </span><span class="s2">(refParent.type === </span><span class="s3">'CallExpression'</span><span class="s2">) {</span>
              <span class="s4">var </span><span class="s2">_callee = refParent.callee;</span>
              <span class="s4">var </span><span class="s2">fnName = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>

              <span class="s4">switch </span><span class="s2">(_callee.type) {</span>
                <span class="s4">case </span><span class="s3">'Identifier'</span><span class="s2">:</span>
                  <span class="s2">fnName = _callee.name;</span>
                  <span class="s4">break</span><span class="s2">;</span>

                <span class="s4">case </span><span class="s3">'MemberExpression'</span><span class="s2">:</span>
                  <span class="s2">fnName = _callee.property.name;</span>
                  <span class="s4">break</span><span class="s2">;</span>
              <span class="s2">}</span>

              <span class="s4">switch </span><span class="s2">(fnName) {</span>
                <span class="s4">case </span><span class="s3">'createElement'</span><span class="s2">:</span>
                <span class="s4">case </span><span class="s3">'jsx'</span><span class="s2">:</span>
                <span class="s4">case </span><span class="s3">'jsxDEV'</span><span class="s2">:</span>
                <span class="s4">case </span><span class="s3">'jsxs'</span><span class="s2">:</span>
                  <span class="s2">isLikelyUsedAsType = </span><span class="s4">true</span><span class="s2">;</span>
                  <span class="s4">break</span><span class="s2">;</span>
              <span class="s2">}</span>
            <span class="s2">}</span>

            <span class="s4">if </span><span class="s2">(isLikelyUsedAsType) {</span>
              <span class="s0">// const X = ... + later &lt;X /&gt;</span>
              <span class="s2">callback(inferredName, init, initPath);</span>
              <span class="s4">return true</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s4">return false</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">isBuiltinHook(hookName) {</span>
    <span class="s4">switch </span><span class="s2">(hookName) {</span>
      <span class="s4">case </span><span class="s3">'useState'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useState'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'useReducer'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useReducer'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'useEffect'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useEffect'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'useLayoutEffect'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useLayoutEffect'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'useMemo'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useMemo'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'useCallback'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useCallback'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'useRef'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useRef'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'useContext'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useContext'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'useImperativeHandle'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useImperativeHandle'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'useDebugValue'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'React.useDebugValue'</span><span class="s2">:</span>
        <span class="s4">return true</span><span class="s2">;</span>

      <span class="s4">default</span><span class="s2">:</span>
        <span class="s4">return false</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">getHookCallsSignature(functionNode) {</span>
    <span class="s4">var </span><span class="s2">fnHookCalls = hookCalls.get(functionNode);</span>

    <span class="s4">if </span><span class="s2">(fnHookCalls === undefined) {</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s4">return </span><span class="s2">{</span>
      <span class="s2">key: fnHookCalls.map(</span><span class="s4">function </span><span class="s2">(call) {</span>
        <span class="s4">return </span><span class="s2">call.name + </span><span class="s3">'{' </span><span class="s2">+ call.key + </span><span class="s3">'}'</span><span class="s2">;</span>
      <span class="s2">}).join(</span><span class="s3">'</span><span class="s6">\n</span><span class="s3">'</span><span class="s2">),</span>
      <span class="s2">customHooks: fnHookCalls.filter(</span><span class="s4">function </span><span class="s2">(call) {</span>
        <span class="s4">return </span><span class="s2">!isBuiltinHook(call.name);</span>
      <span class="s2">}).map(</span><span class="s4">function </span><span class="s2">(call) {</span>
        <span class="s4">return </span><span class="s2">t.cloneDeep(call.callee);</span>
      <span class="s2">})</span>
    <span class="s2">};</span>
  <span class="s2">}</span>

  <span class="s4">var </span><span class="s2">hasForceResetCommentByFile = </span><span class="s4">new </span><span class="s2">WeakMap(); </span><span class="s0">// We let user do /* @refresh reset */ to reset state in the whole file.</span>

  <span class="s4">function </span><span class="s2">hasForceResetComment(path) {</span>
    <span class="s4">var </span><span class="s2">file = path.hub.file;</span>
    <span class="s4">var </span><span class="s2">hasForceReset = hasForceResetCommentByFile.get(file);</span>

    <span class="s4">if </span><span class="s2">(hasForceReset !== undefined) {</span>
      <span class="s4">return </span><span class="s2">hasForceReset;</span>
    <span class="s2">}</span>

    <span class="s2">hasForceReset = </span><span class="s4">false</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">comments = file.ast.comments;</span>

    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; comments.length; i++) {</span>
      <span class="s4">var </span><span class="s2">cmt = comments[i];</span>

      <span class="s4">if </span><span class="s2">(cmt.value.indexOf(</span><span class="s3">'@refresh reset'</span><span class="s2">) !== -</span><span class="s5">1</span><span class="s2">) {</span>
        <span class="s2">hasForceReset = </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s2">hasForceResetCommentByFile.set(file, hasForceReset);</span>
    <span class="s4">return </span><span class="s2">hasForceReset;</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">createArgumentsForSignature(node, signature, scope) {</span>
    <span class="s4">var </span><span class="s2">key = signature.key,</span>
        <span class="s2">customHooks = signature.customHooks;</span>
    <span class="s4">var </span><span class="s2">forceReset = hasForceResetComment(scope.path);</span>
    <span class="s4">var </span><span class="s2">customHooksInScope = [];</span>
    <span class="s2">customHooks.forEach(</span><span class="s4">function </span><span class="s2">(callee) {</span>
      <span class="s0">// Check if a corresponding binding exists where we emit the signature.</span>
      <span class="s4">var </span><span class="s2">bindingName;</span>

      <span class="s4">switch </span><span class="s2">(callee.type) {</span>
        <span class="s4">case </span><span class="s3">'MemberExpression'</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(callee.object.type === </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
            <span class="s2">bindingName = callee.object.name;</span>
          <span class="s2">}</span>

          <span class="s4">break</span><span class="s2">;</span>

        <span class="s4">case </span><span class="s3">'Identifier'</span><span class="s2">:</span>
          <span class="s2">bindingName = callee.name;</span>
          <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">(scope.hasBinding(bindingName)) {</span>
        <span class="s2">customHooksInScope.push(callee);</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
        <span class="s0">// We don't have anything to put in the array because Hook is out of scope.</span>
        <span class="s0">// Since it could potentially have been edited, remount the component.</span>
        <span class="s2">forceReset = </span><span class="s4">true</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">});</span>
    <span class="s4">var </span><span class="s2">finalKey = key;</span>

    <span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">require === </span><span class="s3">'function' </span><span class="s2">&amp;&amp; !opts.emitFullSignatures) {</span>
      <span class="s0">// Prefer to hash when we can (e.g. outside of ASTExplorer).</span>
      <span class="s0">// This makes it deterministically compact, even if there's</span>
      <span class="s0">// e.g. a useState initializer with some code inside.</span>
      <span class="s0">// We also need it for www that has transforms like cx()</span>
      <span class="s0">// that don't understand if something is part of a string.</span>
      <span class="s2">finalKey = require(</span><span class="s3">'crypto'</span><span class="s2">).createHash(</span><span class="s3">'sha1'</span><span class="s2">).update(key).digest(</span><span class="s3">'base64'</span><span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s4">var </span><span class="s2">args = [node, t.stringLiteral(finalKey)];</span>

    <span class="s4">if </span><span class="s2">(forceReset || customHooksInScope.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
      <span class="s2">args.push(t.booleanLiteral(forceReset));</span>
    <span class="s2">}</span>

    <span class="s4">if </span><span class="s2">(customHooksInScope.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
      <span class="s2">args.push( </span><span class="s0">// TODO: We could use an arrow here to be more compact.</span>
      <span class="s0">// However, don't do it until AMA can run them natively.</span>
      <span class="s2">t.functionExpression(</span><span class="s4">null</span><span class="s2">, [], t.blockStatement([t.returnStatement(t.arrayExpression(customHooksInScope))])));</span>
    <span class="s2">}</span>

    <span class="s4">return </span><span class="s2">args;</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">findHOCCallPathsAbove(path) {</span>
    <span class="s4">var </span><span class="s2">calls = [];</span>

    <span class="s4">while </span><span class="s2">(</span><span class="s4">true</span><span class="s2">) {</span>
      <span class="s4">if </span><span class="s2">(!path) {</span>
        <span class="s4">return </span><span class="s2">calls;</span>
      <span class="s2">}</span>

      <span class="s4">var </span><span class="s2">parentPath = path.parentPath;</span>

      <span class="s4">if </span><span class="s2">(!parentPath) {</span>
        <span class="s4">return </span><span class="s2">calls;</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">( </span><span class="s0">// hoc(_c = function() { })</span>
      <span class="s2">parentPath.node.type === </span><span class="s3">'AssignmentExpression' </span><span class="s2">&amp;&amp; path.node === parentPath.node.right) {</span>
        <span class="s0">// Ignore registrations.</span>
        <span class="s2">path = parentPath;</span>
        <span class="s4">continue</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">( </span><span class="s0">// hoc1(hoc2(...))</span>
      <span class="s2">parentPath.node.type === </span><span class="s3">'CallExpression' </span><span class="s2">&amp;&amp; path.node !== parentPath.node.callee) {</span>
        <span class="s2">calls.push(parentPath);</span>
        <span class="s2">path = parentPath;</span>
        <span class="s4">continue</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">return </span><span class="s2">calls; </span><span class="s0">// Stop at other types.</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s4">var </span><span class="s2">seenForRegistration = </span><span class="s4">new </span><span class="s2">WeakSet();</span>
  <span class="s4">var </span><span class="s2">seenForSignature = </span><span class="s4">new </span><span class="s2">WeakSet();</span>
  <span class="s4">var </span><span class="s2">seenForOutro = </span><span class="s4">new </span><span class="s2">WeakSet();</span>
  <span class="s4">var </span><span class="s2">hookCalls = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
  <span class="s4">var </span><span class="s2">HookCallsVisitor = {</span>
    <span class="s2">CallExpression: </span><span class="s4">function </span><span class="s2">(path) {</span>
      <span class="s4">var </span><span class="s2">node = path.node;</span>
      <span class="s4">var </span><span class="s2">callee = node.callee; </span><span class="s0">// Note: this visitor MUST NOT mutate the tree in any way.</span>
      <span class="s0">// It runs early in a separate traversal and should be very fast.</span>

      <span class="s4">var </span><span class="s2">name = </span><span class="s4">null</span><span class="s2">;</span>

      <span class="s4">switch </span><span class="s2">(callee.type) {</span>
        <span class="s4">case </span><span class="s3">'Identifier'</span><span class="s2">:</span>
          <span class="s2">name = callee.name;</span>
          <span class="s4">break</span><span class="s2">;</span>

        <span class="s4">case </span><span class="s3">'MemberExpression'</span><span class="s2">:</span>
          <span class="s2">name = callee.property.name;</span>
          <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">(name === </span><span class="s4">null </span><span class="s2">|| !</span><span class="s7">/^use[A-Z]/</span><span class="s2">.test(name)) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">var </span><span class="s2">fnScope = path.scope.getFunctionParent();</span>

      <span class="s4">if </span><span class="s2">(fnScope === </span><span class="s4">null</span><span class="s2">) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s0">// This is a Hook call. Record it.</span>


      <span class="s4">var </span><span class="s2">fnNode = fnScope.block;</span>

      <span class="s4">if </span><span class="s2">(!hookCalls.has(fnNode)) {</span>
        <span class="s2">hookCalls.set(fnNode, []);</span>
      <span class="s2">}</span>

      <span class="s4">var </span><span class="s2">hookCallsForFn = hookCalls.get(fnNode);</span>
      <span class="s4">var </span><span class="s2">key = </span><span class="s3">''</span><span class="s2">;</span>

      <span class="s4">if </span><span class="s2">(path.parent.type === </span><span class="s3">'VariableDeclarator'</span><span class="s2">) {</span>
        <span class="s0">// TODO: if there is no LHS, consider some other heuristic.</span>
        <span class="s2">key = path.parentPath.get(</span><span class="s3">'id'</span><span class="s2">).getSource();</span>
      <span class="s2">} </span><span class="s0">// Some built-in Hooks reset on edits to arguments.</span>


      <span class="s4">var </span><span class="s2">args = path.get(</span><span class="s3">'arguments'</span><span class="s2">);</span>

      <span class="s4">if </span><span class="s2">(name === </span><span class="s3">'useState' </span><span class="s2">&amp;&amp; args.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s0">// useState second argument is initial state.</span>
        <span class="s2">key += </span><span class="s3">'(' </span><span class="s2">+ args[</span><span class="s5">0</span><span class="s2">].getSource() + </span><span class="s3">')'</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s4">else if </span><span class="s2">(name === </span><span class="s3">'useReducer' </span><span class="s2">&amp;&amp; args.length &gt; </span><span class="s5">1</span><span class="s2">) {</span>
        <span class="s0">// useReducer second argument is initial state.</span>
        <span class="s2">key += </span><span class="s3">'(' </span><span class="s2">+ args[</span><span class="s5">1</span><span class="s2">].getSource() + </span><span class="s3">')'</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s2">hookCallsForFn.push({</span>
        <span class="s2">callee: path.node.callee,</span>
        <span class="s2">name: name,</span>
        <span class="s2">key: key</span>
      <span class="s2">});</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">visitor: {</span>
      <span class="s2">ExportDefaultDeclaration: </span><span class="s4">function </span><span class="s2">(path) {</span>
        <span class="s4">var </span><span class="s2">node = path.node;</span>
        <span class="s4">var </span><span class="s2">decl = node.declaration;</span>
        <span class="s4">var </span><span class="s2">declPath = path.get(</span><span class="s3">'declaration'</span><span class="s2">);</span>

        <span class="s4">if </span><span class="s2">(decl.type !== </span><span class="s3">'CallExpression'</span><span class="s2">) {</span>
          <span class="s0">// For now, we only support possible HOC calls here.</span>
          <span class="s0">// Named function declarations are handled in FunctionDeclaration.</span>
          <span class="s0">// Anonymous direct exports like export default function() {}</span>
          <span class="s0">// are currently ignored.</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
        <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


        <span class="s4">if </span><span class="s2">(seenForRegistration.has(node)) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s2">seenForRegistration.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>
        <span class="s0">// This code path handles nested cases like:</span>
        <span class="s0">// export default memo(() =&gt; {})</span>
        <span class="s0">// In those cases it is more plausible people will omit names</span>
        <span class="s0">// so they're worth handling despite possible false positives.</span>
        <span class="s0">// More importantly, it handles the named case:</span>
        <span class="s0">// export default memo(function Named() {})</span>

        <span class="s4">var </span><span class="s2">inferredName = </span><span class="s3">'%default%'</span><span class="s2">;</span>
        <span class="s4">var </span><span class="s2">programPath = path.parentPath;</span>
        <span class="s2">findInnerComponents(inferredName, declPath, </span><span class="s4">function </span><span class="s2">(persistentID, targetExpr, targetPath) {</span>
          <span class="s4">if </span><span class="s2">(targetPath === </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s0">// For case like:</span>
            <span class="s0">// export default hoc(Foo)</span>
            <span class="s0">// we don't want to wrap Foo inside the call.</span>
            <span class="s0">// Instead we assume it's registered at definition.</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">var </span><span class="s2">handle = createRegistration(programPath, persistentID);</span>
          <span class="s2">targetPath.replaceWith(t.assignmentExpression(</span><span class="s3">'='</span><span class="s2">, handle, targetExpr));</span>
        <span class="s2">});</span>
      <span class="s2">},</span>
      <span class="s2">FunctionDeclaration: {</span>
        <span class="s2">enter: </span><span class="s4">function </span><span class="s2">(path) {</span>
          <span class="s4">var </span><span class="s2">node = path.node;</span>
          <span class="s4">var </span><span class="s2">programPath;</span>
          <span class="s4">var </span><span class="s2">insertAfterPath;</span>
          <span class="s4">var </span><span class="s2">modulePrefix = </span><span class="s3">''</span><span class="s2">;</span>

          <span class="s4">switch </span><span class="s2">(path.parent.type) {</span>
            <span class="s4">case </span><span class="s3">'Program'</span><span class="s2">:</span>
              <span class="s2">insertAfterPath = path;</span>
              <span class="s2">programPath = path.parentPath;</span>
              <span class="s4">break</span><span class="s2">;</span>

            <span class="s4">case </span><span class="s3">'TSModuleBlock'</span><span class="s2">:</span>
              <span class="s2">insertAfterPath = path;</span>
              <span class="s2">programPath = insertAfterPath.parentPath.parentPath;</span>
              <span class="s4">break</span><span class="s2">;</span>

            <span class="s4">case </span><span class="s3">'ExportNamedDeclaration'</span><span class="s2">:</span>
              <span class="s2">insertAfterPath = path.parentPath;</span>
              <span class="s2">programPath = insertAfterPath.parentPath;</span>
              <span class="s4">break</span><span class="s2">;</span>

            <span class="s4">case </span><span class="s3">'ExportDefaultDeclaration'</span><span class="s2">:</span>
              <span class="s2">insertAfterPath = path.parentPath;</span>
              <span class="s2">programPath = insertAfterPath.parentPath;</span>
              <span class="s4">break</span><span class="s2">;</span>

            <span class="s4">default</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s0">// These types can be nested in typescript namespace</span>
          <span class="s0">// We need to find the export chain</span>
          <span class="s0">// Or return if it stays local</span>


          <span class="s4">if </span><span class="s2">(path.parent.type === </span><span class="s3">'TSModuleBlock' </span><span class="s2">|| path.parent.type === </span><span class="s3">'ExportNamedDeclaration'</span><span class="s2">) {</span>
            <span class="s4">while </span><span class="s2">(programPath.type !== </span><span class="s3">'Program'</span><span class="s2">) {</span>
              <span class="s4">if </span><span class="s2">(programPath.type === </span><span class="s3">'TSModuleDeclaration'</span><span class="s2">) {</span>
                <span class="s4">if </span><span class="s2">(programPath.parentPath.type !== </span><span class="s3">'Program' </span><span class="s2">&amp;&amp; programPath.parentPath.type !== </span><span class="s3">'ExportNamedDeclaration'</span><span class="s2">) {</span>
                  <span class="s4">return</span><span class="s2">;</span>
                <span class="s2">}</span>

                <span class="s2">modulePrefix = programPath.node.id.name + </span><span class="s3">'$' </span><span class="s2">+ modulePrefix;</span>
              <span class="s2">}</span>

              <span class="s2">programPath = programPath.parentPath;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>

          <span class="s4">var </span><span class="s2">id = node.id;</span>

          <span class="s4">if </span><span class="s2">(id === </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s0">// We don't currently handle anonymous default exports.</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">var </span><span class="s2">inferredName = id.name;</span>

          <span class="s4">if </span><span class="s2">(!isComponentishName(inferredName)) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
          <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


          <span class="s4">if </span><span class="s2">(seenForRegistration.has(node)) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s2">seenForRegistration.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>

          <span class="s4">var </span><span class="s2">innerName = modulePrefix + inferredName; </span><span class="s0">// export function Named() {}</span>
          <span class="s0">// function Named() {}</span>

          <span class="s2">findInnerComponents(innerName, path, </span><span class="s4">function </span><span class="s2">(persistentID, targetExpr) {</span>
            <span class="s4">var </span><span class="s2">handle = createRegistration(programPath, persistentID);</span>
            <span class="s2">insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression(</span><span class="s3">'='</span><span class="s2">, handle, targetExpr)));</span>
          <span class="s2">});</span>
        <span class="s2">},</span>
        <span class="s2">exit: </span><span class="s4">function </span><span class="s2">(path) {</span>
          <span class="s4">var </span><span class="s2">node = path.node;</span>
          <span class="s4">var </span><span class="s2">id = node.id;</span>

          <span class="s4">if </span><span class="s2">(id === </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">var </span><span class="s2">signature = getHookCallsSignature(node);</span>

          <span class="s4">if </span><span class="s2">(signature === </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
          <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


          <span class="s4">if </span><span class="s2">(seenForSignature.has(node)) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s2">seenForSignature.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>

          <span class="s4">var </span><span class="s2">sigCallID = path.scope.generateUidIdentifier(</span><span class="s3">'_s'</span><span class="s2">);</span>
          <span class="s2">path.scope.parent.push({</span>
            <span class="s2">id: sigCallID,</span>
            <span class="s2">init: t.callExpression(refreshSig, [])</span>
          <span class="s2">}); </span><span class="s0">// The signature call is split in two parts. One part is called inside the function.</span>
          <span class="s0">// This is used to signal when first render happens.</span>

          <span class="s2">path.get(</span><span class="s3">'body'</span><span class="s2">).unshiftContainer(</span><span class="s3">'body'</span><span class="s2">, t.expressionStatement(t.callExpression(sigCallID, []))); </span><span class="s0">// The second call is around the function itself.</span>
          <span class="s0">// This is used to associate a type with a signature.</span>
          <span class="s0">// Unlike with $RefreshReg$, this needs to work for nested</span>
          <span class="s0">// declarations too. So we need to search for a path where</span>
          <span class="s0">// we can insert a statement rather than hard coding it.</span>

          <span class="s4">var </span><span class="s2">insertAfterPath = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">path.find(</span><span class="s4">function </span><span class="s2">(p) {</span>
            <span class="s4">if </span><span class="s2">(p.parentPath.isBlock()) {</span>
              <span class="s2">insertAfterPath = p;</span>
              <span class="s4">return true</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">});</span>

          <span class="s4">if </span><span class="s2">(insertAfterPath === </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s2">insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(id, signature, insertAfterPath.scope))));</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s3">'ArrowFunctionExpression|FunctionExpression'</span><span class="s2">: {</span>
        <span class="s2">exit: </span><span class="s4">function </span><span class="s2">(path) {</span>
          <span class="s4">var </span><span class="s2">node = path.node;</span>
          <span class="s4">var </span><span class="s2">signature = getHookCallsSignature(node);</span>

          <span class="s4">if </span><span class="s2">(signature === </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
          <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


          <span class="s4">if </span><span class="s2">(seenForSignature.has(node)) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s2">seenForSignature.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>

          <span class="s4">var </span><span class="s2">sigCallID = path.scope.generateUidIdentifier(</span><span class="s3">'_s'</span><span class="s2">);</span>
          <span class="s2">path.scope.parent.push({</span>
            <span class="s2">id: sigCallID,</span>
            <span class="s2">init: t.callExpression(refreshSig, [])</span>
          <span class="s2">}); </span><span class="s0">// The signature call is split in two parts. One part is called inside the function.</span>
          <span class="s0">// This is used to signal when first render happens.</span>

          <span class="s4">if </span><span class="s2">(path.node.body.type !== </span><span class="s3">'BlockStatement'</span><span class="s2">) {</span>
            <span class="s2">path.node.body = t.blockStatement([t.returnStatement(path.node.body)]);</span>
          <span class="s2">}</span>

          <span class="s2">path.get(</span><span class="s3">'body'</span><span class="s2">).unshiftContainer(</span><span class="s3">'body'</span><span class="s2">, t.expressionStatement(t.callExpression(sigCallID, []))); </span><span class="s0">// The second call is around the function itself.</span>
          <span class="s0">// This is used to associate a type with a signature.</span>

          <span class="s4">if </span><span class="s2">(path.parent.type === </span><span class="s3">'VariableDeclarator'</span><span class="s2">) {</span>
            <span class="s4">var </span><span class="s2">insertAfterPath = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">path.find(</span><span class="s4">function </span><span class="s2">(p) {</span>
              <span class="s4">if </span><span class="s2">(p.parentPath.isBlock()) {</span>
                <span class="s2">insertAfterPath = p;</span>
                <span class="s4">return true</span><span class="s2">;</span>
              <span class="s2">}</span>
            <span class="s2">});</span>

            <span class="s4">if </span><span class="s2">(insertAfterPath === </span><span class="s4">null</span><span class="s2">) {</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">} </span><span class="s0">// Special case when a function would get an inferred name:</span>
            <span class="s0">// let Foo = () =&gt; {}</span>
            <span class="s0">// let Foo = function() {}</span>
            <span class="s0">// We'll add signature it on next line so that</span>
            <span class="s0">// we don't mess up the inferred 'Foo' function name.</span>


            <span class="s2">insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(path.parent.id, signature, insertAfterPath.scope)))); </span><span class="s0">// Result: let Foo = () =&gt; {}; __signature(Foo, ...);</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
            <span class="s0">// let Foo = hoc(() =&gt; {})</span>
            <span class="s4">var </span><span class="s2">paths = [path].concat(findHOCCallPathsAbove(path));</span>
            <span class="s2">paths.forEach(</span><span class="s4">function </span><span class="s2">(p) {</span>
              <span class="s2">p.replaceWith(t.callExpression(sigCallID, createArgumentsForSignature(p.node, signature, p.scope)));</span>
            <span class="s2">}); </span><span class="s0">// Result: let Foo = __signature(hoc(__signature(() =&gt; {}, ...)), ...)</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">VariableDeclaration: </span><span class="s4">function </span><span class="s2">(path) {</span>
        <span class="s4">var </span><span class="s2">node = path.node;</span>
        <span class="s4">var </span><span class="s2">programPath;</span>
        <span class="s4">var </span><span class="s2">insertAfterPath;</span>
        <span class="s4">var </span><span class="s2">modulePrefix = </span><span class="s3">''</span><span class="s2">;</span>

        <span class="s4">switch </span><span class="s2">(path.parent.type) {</span>
          <span class="s4">case </span><span class="s3">'Program'</span><span class="s2">:</span>
            <span class="s2">insertAfterPath = path;</span>
            <span class="s2">programPath = path.parentPath;</span>
            <span class="s4">break</span><span class="s2">;</span>

          <span class="s4">case </span><span class="s3">'TSModuleBlock'</span><span class="s2">:</span>
            <span class="s2">insertAfterPath = path;</span>
            <span class="s2">programPath = insertAfterPath.parentPath.parentPath;</span>
            <span class="s4">break</span><span class="s2">;</span>

          <span class="s4">case </span><span class="s3">'ExportNamedDeclaration'</span><span class="s2">:</span>
            <span class="s2">insertAfterPath = path.parentPath;</span>
            <span class="s2">programPath = insertAfterPath.parentPath;</span>
            <span class="s4">break</span><span class="s2">;</span>

          <span class="s4">case </span><span class="s3">'ExportDefaultDeclaration'</span><span class="s2">:</span>
            <span class="s2">insertAfterPath = path.parentPath;</span>
            <span class="s2">programPath = insertAfterPath.parentPath;</span>
            <span class="s4">break</span><span class="s2">;</span>

          <span class="s4">default</span><span class="s2">:</span>
            <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s0">// These types can be nested in typescript namespace</span>
        <span class="s0">// We need to find the export chain</span>
        <span class="s0">// Or return if it stays local</span>


        <span class="s4">if </span><span class="s2">(path.parent.type === </span><span class="s3">'TSModuleBlock' </span><span class="s2">|| path.parent.type === </span><span class="s3">'ExportNamedDeclaration'</span><span class="s2">) {</span>
          <span class="s4">while </span><span class="s2">(programPath.type !== </span><span class="s3">'Program'</span><span class="s2">) {</span>
            <span class="s4">if </span><span class="s2">(programPath.type === </span><span class="s3">'TSModuleDeclaration'</span><span class="s2">) {</span>
              <span class="s4">if </span><span class="s2">(programPath.parentPath.type !== </span><span class="s3">'Program' </span><span class="s2">&amp;&amp; programPath.parentPath.type !== </span><span class="s3">'ExportNamedDeclaration'</span><span class="s2">) {</span>
                <span class="s4">return</span><span class="s2">;</span>
              <span class="s2">}</span>

              <span class="s2">modulePrefix = programPath.node.id.name + </span><span class="s3">'$' </span><span class="s2">+ modulePrefix;</span>
            <span class="s2">}</span>

            <span class="s2">programPath = programPath.parentPath;</span>
          <span class="s2">}</span>
        <span class="s2">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
        <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


        <span class="s4">if </span><span class="s2">(seenForRegistration.has(node)) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s2">seenForRegistration.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>

        <span class="s4">var </span><span class="s2">declPaths = path.get(</span><span class="s3">'declarations'</span><span class="s2">);</span>

        <span class="s4">if </span><span class="s2">(declPaths.length !== </span><span class="s5">1</span><span class="s2">) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s4">var </span><span class="s2">declPath = declPaths[</span><span class="s5">0</span><span class="s2">];</span>
        <span class="s4">var </span><span class="s2">inferredName = declPath.node.id.name;</span>
        <span class="s4">var </span><span class="s2">innerName = modulePrefix + inferredName;</span>
        <span class="s2">findInnerComponents(innerName, declPath, </span><span class="s4">function </span><span class="s2">(persistentID, targetExpr, targetPath) {</span>
          <span class="s4">if </span><span class="s2">(targetPath === </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s0">// For case like:</span>
            <span class="s0">// export const Something = hoc(Foo)</span>
            <span class="s0">// we don't want to wrap Foo inside the call.</span>
            <span class="s0">// Instead we assume it's registered at definition.</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s4">var </span><span class="s2">handle = createRegistration(programPath, persistentID);</span>

          <span class="s4">if </span><span class="s2">(targetPath.parent.type === </span><span class="s3">'VariableDeclarator'</span><span class="s2">) {</span>
            <span class="s0">// Special case when a variable would get an inferred name:</span>
            <span class="s0">// let Foo = () =&gt; {}</span>
            <span class="s0">// let Foo = function() {}</span>
            <span class="s0">// let Foo = styled.div``;</span>
            <span class="s0">// We'll register it on next line so that</span>
            <span class="s0">// we don't mess up the inferred 'Foo' function name.</span>
            <span class="s0">// (eg: with @babel/plugin-transform-react-display-name or</span>
            <span class="s0">// babel-plugin-styled-components)</span>
            <span class="s2">insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression(</span><span class="s3">'='</span><span class="s2">, handle, declPath.node.id))); </span><span class="s0">// Result: let Foo = () =&gt; {}; _c1 = Foo;</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
            <span class="s0">// let Foo = hoc(() =&gt; {})</span>
            <span class="s2">targetPath.replaceWith(t.assignmentExpression(</span><span class="s3">'='</span><span class="s2">, handle, targetExpr)); </span><span class="s0">// Result: let Foo = hoc(_c1 = () =&gt; {})</span>
          <span class="s2">}</span>
        <span class="s2">});</span>
      <span class="s2">},</span>
      <span class="s2">Program: {</span>
        <span class="s2">enter: </span><span class="s4">function </span><span class="s2">(path) {</span>
          <span class="s0">// This is a separate early visitor because we need to collect Hook calls</span>
          <span class="s0">// and &quot;const [foo, setFoo] = ...&quot; signatures before the destructuring</span>
          <span class="s0">// transform mangles them. This extra traversal is not ideal for perf,</span>
          <span class="s0">// but it's the best we can do until we stop transpiling destructuring.</span>
          <span class="s2">path.traverse(HookCallsVisitor);</span>
        <span class="s2">},</span>
        <span class="s2">exit: </span><span class="s4">function </span><span class="s2">(path) {</span>
          <span class="s4">var </span><span class="s2">registrations = registrationsByProgramPath.get(path);</span>

          <span class="s4">if </span><span class="s2">(registrations === undefined) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
          <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


          <span class="s4">var </span><span class="s2">node = path.node;</span>

          <span class="s4">if </span><span class="s2">(seenForOutro.has(node)) {</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s2">seenForOutro.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>

          <span class="s2">registrationsByProgramPath.delete(path);</span>
          <span class="s4">var </span><span class="s2">declarators = [];</span>
          <span class="s2">path.pushContainer(</span><span class="s3">'body'</span><span class="s2">, t.variableDeclaration(</span><span class="s3">'var'</span><span class="s2">, declarators));</span>
          <span class="s2">registrations.forEach(</span><span class="s4">function </span><span class="s2">(_ref) {</span>
            <span class="s4">var </span><span class="s2">handle = _ref.handle,</span>
                <span class="s2">persistentID = _ref.persistentID;</span>
            <span class="s2">path.pushContainer(</span><span class="s3">'body'</span><span class="s2">, t.expressionStatement(t.callExpression(refreshReg, [handle, t.stringLiteral(persistentID)])));</span>
            <span class="s2">declarators.push(t.variableDeclarator(handle));</span>
          <span class="s2">});</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
<span class="s2">}</span>

<span class="s2">module.exports = ReactFreshBabelPlugin;</span>
  <span class="s2">})();</span>
<span class="s2">}</span>
</pre>
</body>
</html>