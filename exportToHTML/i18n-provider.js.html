<html>
<head>
<title>i18n-provider.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
i18n-provider.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;I18NProvider&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">I18NProvider;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_requestmeta = require(</span><span class="s0">&quot;../request-meta&quot;</span><span class="s1">);</span>
<span class="s2">class </span><span class="s1">I18NProvider {</span>
    <span class="s1">constructor(config){</span>
        <span class="s2">var </span><span class="s1">_config_domains;</span>
        <span class="s2">this</span><span class="s1">.config = config;</span>
        <span class="s2">if </span><span class="s1">(!config.locales.length) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: No locales provided'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E510&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.lowerCaseLocales = config.locales.map((locale)=&gt;locale.toLowerCase());</span>
        <span class="s2">this</span><span class="s1">.lowerCaseDomains = (_config_domains = config.domains) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _config_domains.map((domainLocale)=&gt;{</span>
            <span class="s2">var </span><span class="s1">_domainLocale_locales;</span>
            <span class="s2">const </span><span class="s1">domain = domainLocale.domain.toLowerCase();</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">defaultLocale: domainLocale.defaultLocale.toLowerCase(),</span>
                <span class="s1">hostname: domain.split(</span><span class="s0">':'</span><span class="s1">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">],</span>
                <span class="s1">domain,</span>
                <span class="s1">locales: (_domainLocale_locales = domainLocale.locales) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _domainLocale_locales.map((locale)=&gt;locale.toLowerCase()),</span>
                <span class="s1">http: domainLocale.http</span>
            <span class="s1">};</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* Detects the domain locale from the hostname and the detected locale if</span>
   <span class="s4">* provided.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">hostname The hostname to detect the domain locale from, this must be lowercased.</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">detectedLocale The detected locale to use if the hostname does not match.</span>
   <span class="s4">* </span><span class="s5">@returns </span><span class="s4">The domain locale if found, `undefined` otherwise.</span>
   <span class="s4">*/ </span><span class="s1">detectDomainLocale(hostname, detectedLocale) {</span>
        <span class="s2">if </span><span class="s1">(!hostname || !</span><span class="s2">this</span><span class="s1">.lowerCaseDomains || !</span><span class="s2">this</span><span class="s1">.config.domains) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(detectedLocale) detectedLocale = detectedLocale.toLowerCase();</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">.lowerCaseDomains.length; i++){</span>
            <span class="s2">var </span><span class="s4">// Configuration validation ensures that the locale is not repeated in</span>
            <span class="s4">// other domains locales.</span>
            <span class="s1">_domainLocale_locales;</span>
            <span class="s2">const </span><span class="s1">domainLocale = </span><span class="s2">this</span><span class="s1">.lowerCaseDomains[i];</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s4">// We assume that the hostname is already lowercased.</span>
            <span class="s1">domainLocale.hostname === hostname || ((_domainLocale_locales = domainLocale.locales) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _domainLocale_locales.some((locale)=&gt;locale === detectedLocale))) {</span>
                <span class="s2">return this</span><span class="s1">.config.domains[i];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* Pulls the pre-computed locale and inference results from the query</span>
   <span class="s4">* object.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">req the request object</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">pathname the pathname that could contain a locale prefix</span>
   <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the locale analysis result</span>
   <span class="s4">*/ </span><span class="s1">fromRequest(req, pathname) {</span>
        <span class="s2">const </span><span class="s1">detectedLocale = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">);</span>
        <span class="s4">// If a locale was detected on the query, analyze the pathname to ensure</span>
        <span class="s4">// that the locale matches.</span>
        <span class="s2">if </span><span class="s1">(detectedLocale) {</span>
            <span class="s2">const </span><span class="s1">analysis = </span><span class="s2">this</span><span class="s1">.analyze(pathname);</span>
            <span class="s4">// If the analysis contained a locale we should validate it against the</span>
            <span class="s4">// query and strip it from the pathname.</span>
            <span class="s2">if </span><span class="s1">(analysis.detectedLocale) {</span>
                <span class="s2">if </span><span class="s1">(analysis.detectedLocale !== detectedLocale) {</span>
                    <span class="s1">console.warn(</span><span class="s0">`The detected locale does not match the locale in the query. Expected to find '</span><span class="s1">${detectedLocale}</span><span class="s0">' in '</span><span class="s1">${pathname}</span><span class="s0">' but found '</span><span class="s1">${analysis.detectedLocale}</span><span class="s0">'}`</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">pathname = analysis.pathname;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">pathname,</span>
            <span class="s1">detectedLocale,</span>
            <span class="s1">inferredFromDefault: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'localeInferredFromDefault'</span><span class="s1">) ?? </span><span class="s2">false</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* Analyzes the pathname for a locale and returns the pathname without it.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">pathname The pathname that could contain a locale prefix.</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">options The options to use when matching the locale.</span>
   <span class="s4">* </span><span class="s5">@returns </span><span class="s4">The matched locale and the pathname without the locale prefix</span>
   <span class="s4">*          (if any).</span>
   <span class="s4">*/ </span><span class="s1">analyze(pathname, options = {}) {</span>
        <span class="s2">let </span><span class="s1">detectedLocale = options.defaultLocale;</span>
        <span class="s4">// By default, we assume that the default locale was inferred if there was</span>
        <span class="s4">// no detected locale.</span>
        <span class="s2">let </span><span class="s1">inferredFromDefault = </span><span class="s2">typeof </span><span class="s1">detectedLocale === </span><span class="s0">'string'</span><span class="s1">;</span>
        <span class="s4">// The first segment will be empty, because it has a leading `/`. If</span>
        <span class="s4">// there is no further segment, there is no locale (or it's the default).</span>
        <span class="s2">const </span><span class="s1">segments = pathname.split(</span><span class="s0">'/'</span><span class="s1">, </span><span class="s3">2</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(!segments[</span><span class="s3">1</span><span class="s1">]) </span><span class="s2">return </span><span class="s1">{</span>
            <span class="s1">detectedLocale,</span>
            <span class="s1">pathname,</span>
            <span class="s1">inferredFromDefault</span>
        <span class="s1">};</span>
        <span class="s4">// The second segment will contain the locale part if any.</span>
        <span class="s2">const </span><span class="s1">segment = segments[</span><span class="s3">1</span><span class="s1">].toLowerCase();</span>
        <span class="s4">// See if the segment matches one of the locales. If it doesn't, there is</span>
        <span class="s4">// no locale (or it's the default).</span>
        <span class="s2">const </span><span class="s1">index = </span><span class="s2">this</span><span class="s1">.lowerCaseLocales.indexOf(segment);</span>
        <span class="s2">if </span><span class="s1">(index &lt; </span><span class="s3">0</span><span class="s1">) </span><span class="s2">return </span><span class="s1">{</span>
            <span class="s1">detectedLocale,</span>
            <span class="s1">pathname,</span>
            <span class="s1">inferredFromDefault</span>
        <span class="s1">};</span>
        <span class="s4">// Return the case-sensitive locale.</span>
        <span class="s1">detectedLocale = </span><span class="s2">this</span><span class="s1">.config.locales[index];</span>
        <span class="s1">inferredFromDefault = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s4">// Remove the `/${locale}` part of the pathname.</span>
        <span class="s1">pathname = pathname.slice(detectedLocale.length + </span><span class="s3">1</span><span class="s1">) || </span><span class="s0">'/'</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">detectedLocale,</span>
            <span class="s1">pathname,</span>
            <span class="s1">inferredFromDefault</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=i18n-provider.js.map</span></pre>
</body>
</html>