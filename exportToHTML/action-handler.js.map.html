<html>
<head>
<title>action-handler.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
action-handler.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/action-handler.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'node:http'</span><span class="s3">\n</span><span class="s1">import type { SizeLimit } from '../../types'</span><span class="s3">\n</span><span class="s1">import type { RequestStore } from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type { AppRenderContext, GenerateFlight } from './app-render'</span><span class="s3">\n</span><span class="s1">import type { AppPageModule } from '../route-modules/app-page/module'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest, BaseNextResponse } from '../base-http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">RSC_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">ACTION_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ACTION_NOT_FOUND_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_URL,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getAccessFallbackHTTPStatus,</span><span class="s3">\n  </span><span class="s1">isHTTPAccessFallbackError,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/http-access-fallback/http-access-fallback'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getRedirectTypeFromError,</span><span class="s3">\n  </span><span class="s1">getURLFromRedirectError,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/redirect'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isRedirectError,</span><span class="s3">\n  </span><span class="s1">type RedirectType,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/redirect-error'</span><span class="s3">\n</span><span class="s1">import RenderResult, {</span><span class="s3">\n  </span><span class="s1">type AppPageRenderResultMetadata,</span><span class="s3">\n</span><span class="s1">} from '../render-result'</span><span class="s3">\n</span><span class="s1">import type { WorkStore } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { FlightRenderResult } from './flight-render-result'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">filterReqHeaders,</span><span class="s3">\n  </span><span class="s1">actionsForbiddenHeaders,</span><span class="s3">\n</span><span class="s1">} from '../lib/server-ipc/utils'</span><span class="s3">\n</span><span class="s1">import { getModifiedCookieValues } from '../web/spec-extension/adapters/request-cookies'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATED_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { getServerActionRequestMetadata } from '../lib/server-action-request-meta'</span><span class="s3">\n</span><span class="s1">import { isCsrfOriginAllowed } from './csrf-protection'</span><span class="s3">\n</span><span class="s1">import { warn } from '../../build/output/log'</span><span class="s3">\n</span><span class="s1">import { RequestCookies, ResponseCookies } from '../web/spec-extension/cookies'</span><span class="s3">\n</span><span class="s1">import { HeadersAdapter } from '../web/spec-extension/adapters/headers'</span><span class="s3">\n</span><span class="s1">import { fromNodeOutgoingHttpHeaders } from '../web/utils'</span><span class="s3">\n</span><span class="s1">import { selectWorkerForForwarding } from './action-utils'</span><span class="s3">\n</span><span class="s1">import { isNodeNextRequest, isWebNextRequest } from '../base-http/helpers'</span><span class="s3">\n</span><span class="s1">import { RedirectStatusCode } from '../../client/components/redirect-status-code'</span><span class="s3">\n</span><span class="s1">import { synchronizeMutableCookies } from '../async-storage/request-store'</span><span class="s3">\n</span><span class="s1">import type { TemporaryReferenceSet } from 'react-server-dom-webpack/server'</span><span class="s3">\n</span><span class="s1">import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import { executeRevalidates } from '../revalidation-utils'</span><span class="s3">\n</span><span class="s1">import { getRequestMeta } from '../request-meta'</span><span class="s3">\n</span><span class="s1">import { setCacheBustingSearchParam } from '../../client/components/router-reducer/set-cache-busting-search-param'</span><span class="s3">\n\n</span><span class="s1">function formDataFromSearchQueryString(query: string) {</span><span class="s3">\n  </span><span class="s1">const searchParams = new URLSearchParams(query)</span><span class="s3">\n  </span><span class="s1">const formData = new FormData()</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of searchParams) {</span><span class="s3">\n    </span><span class="s1">formData.append(key, value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return formData</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function nodeHeadersToRecord(</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders | OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const record: Record&lt;string, string&gt; = {}</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of Object.entries(headers)) {</span><span class="s3">\n    </span><span class="s1">if (value !== undefined) {</span><span class="s3">\n      </span><span class="s1">record[key] = Array.isArray(value) ? value.join(', ') : `${value}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return record</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getForwardedHeaders(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse</span><span class="s3">\n</span><span class="s1">): Headers {</span><span class="s3">\n  </span><span class="s1">// Get request headers and cookies</span><span class="s3">\n  </span><span class="s1">const requestHeaders = req.headers</span><span class="s3">\n  </span><span class="s1">const requestCookies = new RequestCookies(HeadersAdapter.from(requestHeaders))</span><span class="s3">\n\n  </span><span class="s1">// Get response headers and cookies</span><span class="s3">\n  </span><span class="s1">const responseHeaders = res.getHeaders()</span><span class="s3">\n  </span><span class="s1">const responseCookies = new ResponseCookies(</span><span class="s3">\n    </span><span class="s1">fromNodeOutgoingHttpHeaders(responseHeaders)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Merge request and response headers</span><span class="s3">\n  </span><span class="s1">const mergedHeaders = filterReqHeaders(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">...nodeHeadersToRecord(requestHeaders),</span><span class="s3">\n      </span><span class="s1">...nodeHeadersToRecord(responseHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">actionsForbiddenHeaders</span><span class="s3">\n  </span><span class="s1">) as Record&lt;string, string&gt;</span><span class="s3">\n\n  </span><span class="s1">// Merge cookies into requestCookies, so responseCookies always take precedence</span><span class="s3">\n  </span><span class="s1">// and overwrite/delete those from requestCookies.</span><span class="s3">\n  </span><span class="s1">responseCookies.getAll().forEach((cookie) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (typeof cookie.value === 'undefined') {</span><span class="s3">\n      </span><span class="s1">requestCookies.delete(cookie.name)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">requestCookies.set(cookie)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Update the 'cookie' header with the merged cookies</span><span class="s3">\n  </span><span class="s1">mergedHeaders['cookie'] = requestCookies.toString()</span><span class="s3">\n\n  </span><span class="s1">// Remove headers that should not be forwarded</span><span class="s3">\n  </span><span class="s1">delete mergedHeaders['transfer-encoding']</span><span class="s3">\n\n  </span><span class="s1">return new Headers(mergedHeaders)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addRevalidationHeader(</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">requestStore,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">workStore: WorkStore</span><span class="s3">\n    </span><span class="s1">requestStore: RequestStore</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// If a tag was revalidated, the client router needs to invalidate all the</span><span class="s3">\n  </span><span class="s1">// client router cache as they may be stale. And if a path was revalidated, the</span><span class="s3">\n  </span><span class="s1">// client needs to invalidate all subtrees below that path.</span><span class="s3">\n\n  </span><span class="s1">// To keep the header size small, we use a tuple of</span><span class="s3">\n  </span><span class="s1">// [[revalidatedPaths], isTagRevalidated ? 1 : 0, isCookieRevalidated ? 1 : 0]</span><span class="s3">\n  </span><span class="s1">// instead of a JSON object.</span><span class="s3">\n\n  </span><span class="s1">// TODO-APP: Currently the prefetch cache doesn't have subtree information,</span><span class="s3">\n  </span><span class="s1">// so we need to invalidate the entire cache if a path was revalidated.</span><span class="s3">\n  </span><span class="s1">// TODO-APP: Currently paths are treated as tags, so the second element of the tuple</span><span class="s3">\n  </span><span class="s1">// is always empty.</span><span class="s3">\n\n  </span><span class="s1">const isTagRevalidated = workStore.pendingRevalidatedTags?.length ? 1 : 0</span><span class="s3">\n  </span><span class="s1">const isCookieRevalidated = getModifiedCookieValues(</span><span class="s3">\n    </span><span class="s1">requestStore.mutableCookies</span><span class="s3">\n  </span><span class="s1">).length</span><span class="s3">\n    </span><span class="s1">? 1</span><span class="s3">\n    </span><span class="s1">: 0</span><span class="s3">\n\n  </span><span class="s1">res.setHeader(</span><span class="s3">\n    </span><span class="s1">'x-action-revalidated',</span><span class="s3">\n    </span><span class="s1">JSON.stringify([[], isTagRevalidated, isCookieRevalidated])</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function createForwardedActionResponse(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">host: Host,</span><span class="s3">\n  </span><span class="s1">workerPathname: string,</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!host) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Invariant: Missing `host` header from a forwarded Server Actions request.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const forwardedHeaders = getForwardedHeaders(req, res)</span><span class="s3">\n\n  </span><span class="s1">// indicate that this action request was forwarded from another worker</span><span class="s3">\n  </span><span class="s1">// we use this to skip rendering the flight tree so that we don't update the UI</span><span class="s3">\n  </span><span class="s1">// with the response from the forwarded worker</span><span class="s3">\n  </span><span class="s1">forwardedHeaders.set('x-action-forwarded', '1')</span><span class="s3">\n\n  </span><span class="s1">const proto =</span><span class="s3">\n    </span><span class="s1">getRequestMeta(req, 'initProtocol')?.replace(/:+$/, '') || 'https'</span><span class="s3">\n\n  </span><span class="s1">// For standalone or the serverful mode, use the internal origin directly</span><span class="s3">\n  </span><span class="s1">// other than the host headers from the request.</span><span class="s3">\n  </span><span class="s1">const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`</span><span class="s3">\n\n  </span><span class="s1">const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`)</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">let body: BodyInit | ReadableStream&lt;Uint8Array&gt; | undefined</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME === 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isWebNextRequest(req)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (!req.body) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Invariant: missing request body.')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">body = req.body</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isNodeNextRequest(req)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">body = req.stream()</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: Unknown request type.')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Forward the request to the new worker</span><span class="s3">\n    </span><span class="s1">const response = await fetch(fetchUrl, {</span><span class="s3">\n      </span><span class="s1">method: 'POST',</span><span class="s3">\n      </span><span class="s1">body,</span><span class="s3">\n      </span><span class="s1">duplex: 'half',</span><span class="s3">\n      </span><span class="s1">headers: forwardedHeaders,</span><span class="s3">\n      </span><span class="s1">redirect: 'manual',</span><span class="s3">\n      </span><span class="s1">next: {</span><span class="s3">\n        </span><span class="s1">// @ts-ignore</span><span class="s3">\n        </span><span class="s1">internal: 1,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">response.headers.get('content-type')?.startsWith(RSC_CONTENT_TYPE_HEADER)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// copy the headers from the redirect response to the response we're sending</span><span class="s3">\n      </span><span class="s1">for (const [key, value] of response.headers) {</span><span class="s3">\n        </span><span class="s1">if (!actionsForbiddenHeaders.includes(key)) {</span><span class="s3">\n          </span><span class="s1">res.setHeader(key, value)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return new FlightRenderResult(response.body!)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Since we aren't consuming the response body, we cancel it to avoid memory leaks</span><span class="s3">\n      </span><span class="s1">response.body?.cancel()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">// we couldn't stream the forwarded response, so we'll just return an empty response</span><span class="s3">\n    </span><span class="s1">console.error(`failed to forward action response`, err)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return RenderResult.fromStatic('{}', JSON_CONTENT_TYPE_HEADER)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the parsed redirect URL if we deem that it is hosted by us.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* We handle both relative and absolute redirect URLs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In case the redirect URL is not relative to the application we return `null`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getAppRelativeRedirectUrl(</span><span class="s3">\n  </span><span class="s1">basePath: string,</span><span class="s3">\n  </span><span class="s1">host: Host,</span><span class="s3">\n  </span><span class="s1">redirectUrl: string</span><span class="s3">\n</span><span class="s1">): URL | null {</span><span class="s3">\n  </span><span class="s1">if (redirectUrl.startsWith('/') || redirectUrl.startsWith('.')) {</span><span class="s3">\n    </span><span class="s1">// Make sure we are appending the basePath to relative URLS</span><span class="s3">\n    </span><span class="s1">return new URL(`${basePath}${redirectUrl}`, 'http://n')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsedRedirectUrl = new URL(redirectUrl)</span><span class="s3">\n\n  </span><span class="s1">if (host?.value !== parsedRedirectUrl.host) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// At this point the hosts are the same, just confirm we</span><span class="s3">\n  </span><span class="s1">// are routing to a path underneath the `basePath`</span><span class="s3">\n  </span><span class="s1">return parsedRedirectUrl.pathname.startsWith(basePath)</span><span class="s3">\n    </span><span class="s1">? parsedRedirectUrl</span><span class="s3">\n    </span><span class="s1">: null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function createRedirectRenderResult(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">originalHost: Host,</span><span class="s3">\n  </span><span class="s1">redirectUrl: string,</span><span class="s3">\n  </span><span class="s1">redirectType: RedirectType,</span><span class="s3">\n  </span><span class="s1">basePath: string,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`)</span><span class="s3">\n\n  </span><span class="s1">// If we're redirecting to another route of this Next.js application, we'll</span><span class="s3">\n  </span><span class="s1">// try to stream the response from the other worker path. When that works,</span><span class="s3">\n  </span><span class="s1">// we can save an extra roundtrip and avoid a full page reload.</span><span class="s3">\n  </span><span class="s1">// When the redirect URL starts with a `/` or is to the same host, under the</span><span class="s3">\n  </span><span class="s1">// `basePath` we treat it as an app-relative redirect;</span><span class="s3">\n  </span><span class="s1">const appRelativeRedirectUrl = getAppRelativeRedirectUrl(</span><span class="s3">\n    </span><span class="s1">basePath,</span><span class="s3">\n    </span><span class="s1">originalHost,</span><span class="s3">\n    </span><span class="s1">redirectUrl</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (appRelativeRedirectUrl) {</span><span class="s3">\n    </span><span class="s1">if (!originalHost) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Invariant: Missing `host` header from a forwarded Server Actions request.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const forwardedHeaders = getForwardedHeaders(req, res)</span><span class="s3">\n    </span><span class="s1">forwardedHeaders.set(RSC_HEADER, '1')</span><span class="s3">\n\n    </span><span class="s1">const proto =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'initProtocol')?.replace(/:+$/, '') || 'https'</span><span class="s3">\n\n    </span><span class="s1">// For standalone or the serverful mode, use the internal origin directly</span><span class="s3">\n    </span><span class="s1">// other than the host headers from the request.</span><span class="s3">\n    </span><span class="s1">const origin =</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`</span><span class="s3">\n\n    </span><span class="s1">const fetchUrl = new URL(</span><span class="s3">\n      </span><span class="s1">`${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (workStore.pendingRevalidatedTags) {</span><span class="s3">\n      </span><span class="s1">forwardedHeaders.set(</span><span class="s3">\n        </span><span class="s1">NEXT_CACHE_REVALIDATED_TAGS_HEADER,</span><span class="s3">\n        </span><span class="s1">workStore.pendingRevalidatedTags.join(',')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">forwardedHeaders.set(</span><span class="s3">\n        </span><span class="s1">NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,</span><span class="s3">\n        </span><span class="s1">workStore.incrementalCache?.prerenderManifest?.preview?.previewModeId ||</span><span class="s3">\n          </span><span class="s1">''</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Ensures that when the path was revalidated we don't return a partial response on redirects</span><span class="s3">\n    </span><span class="s1">forwardedHeaders.delete(NEXT_ROUTER_STATE_TREE_HEADER)</span><span class="s3">\n    </span><span class="s1">// When an action follows a redirect, it's no longer handling an action: it's just a normal RSC request</span><span class="s3">\n    </span><span class="s1">// to the requested URL. We should remove the `next-action` header so that it's not treated as an action</span><span class="s3">\n    </span><span class="s1">forwardedHeaders.delete(ACTION_HEADER)</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">setCacheBustingSearchParam(fetchUrl, {</span><span class="s3">\n        </span><span class="s1">[NEXT_ROUTER_PREFETCH_HEADER]: forwardedHeaders.get(</span><span class="s3">\n          </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">? ('1' as const)</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n        </span><span class="s1">[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]:</span><span class="s3">\n          </span><span class="s1">forwardedHeaders.get(NEXT_ROUTER_SEGMENT_PREFETCH_HEADER) ??</span><span class="s3">\n          </span><span class="s1">undefined,</span><span class="s3">\n        </span><span class="s1">[NEXT_ROUTER_STATE_TREE_HEADER]:</span><span class="s3">\n          </span><span class="s1">forwardedHeaders.get(NEXT_ROUTER_STATE_TREE_HEADER) ?? undefined,</span><span class="s3">\n        </span><span class="s1">[NEXT_URL]: forwardedHeaders.get(NEXT_URL) ?? undefined,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">const response = await fetch(fetchUrl, {</span><span class="s3">\n        </span><span class="s1">method: 'GET',</span><span class="s3">\n        </span><span class="s1">headers: forwardedHeaders,</span><span class="s3">\n        </span><span class="s1">next: {</span><span class="s3">\n          </span><span class="s1">// @ts-ignore</span><span class="s3">\n          </span><span class="s1">internal: 1,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">response.headers</span><span class="s3">\n          </span><span class="s1">.get('content-type')</span><span class="s3">\n          </span><span class="s1">?.startsWith(RSC_CONTENT_TYPE_HEADER)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// copy the headers from the redirect response to the response we're sending</span><span class="s3">\n        </span><span class="s1">for (const [key, value] of response.headers) {</span><span class="s3">\n          </span><span class="s1">if (!actionsForbiddenHeaders.includes(key)) {</span><span class="s3">\n            </span><span class="s1">res.setHeader(key, value)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return new FlightRenderResult(response.body!)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Since we aren't consuming the response body, we cancel it to avoid memory leaks</span><span class="s3">\n        </span><span class="s1">response.body?.cancel()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">// we couldn't stream the redirect response, so we'll just do a normal redirect</span><span class="s3">\n      </span><span class="s1">console.error(`failed to get redirect response`, err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return RenderResult.EMPTY</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Used to compare Host header and Origin header.</span><span class="s3">\n</span><span class="s1">const enum HostType {</span><span class="s3">\n  </span><span class="s1">XForwardedHost = 'x-forwarded-host',</span><span class="s3">\n  </span><span class="s1">Host = 'host',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">type Host =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: HostType.XForwardedHost</span><span class="s3">\n      </span><span class="s1">value: string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: HostType.Host</span><span class="s3">\n      </span><span class="s1">value: string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| undefined</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensures the value of the header can't create long logs.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function limitUntrustedHeaderValueForLogs(value: string) {</span><span class="s3">\n  </span><span class="s1">return value.length &gt; 100 ? value.slice(0, 100) + '...' : value</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseHostHeader(</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">originDomain?: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const forwardedHostHeader = headers['x-forwarded-host']</span><span class="s3">\n  </span><span class="s1">const forwardedHostHeaderValue =</span><span class="s3">\n    </span><span class="s1">forwardedHostHeader &amp;&amp; Array.isArray(forwardedHostHeader)</span><span class="s3">\n      </span><span class="s1">? forwardedHostHeader[0]</span><span class="s3">\n      </span><span class="s1">: forwardedHostHeader?.split(',')?.[0]?.trim()</span><span class="s3">\n  </span><span class="s1">const hostHeader = headers['host']</span><span class="s3">\n\n  </span><span class="s1">if (originDomain) {</span><span class="s3">\n    </span><span class="s1">return forwardedHostHeaderValue === originDomain</span><span class="s3">\n      </span><span class="s1">? {</span><span class="s3">\n          </span><span class="s1">type: HostType.XForwardedHost,</span><span class="s3">\n          </span><span class="s1">value: forwardedHostHeaderValue,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">: hostHeader === originDomain</span><span class="s3">\n        </span><span class="s1">? {</span><span class="s3">\n            </span><span class="s1">type: HostType.Host,</span><span class="s3">\n            </span><span class="s1">value: hostHeader,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return forwardedHostHeaderValue</span><span class="s3">\n    </span><span class="s1">? {</span><span class="s3">\n        </span><span class="s1">type: HostType.XForwardedHost,</span><span class="s3">\n        </span><span class="s1">value: forwardedHostHeaderValue,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: hostHeader</span><span class="s3">\n      </span><span class="s1">? {</span><span class="s3">\n          </span><span class="s1">type: HostType.Host,</span><span class="s3">\n          </span><span class="s1">value: hostHeader,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ServerModuleMap = Record&lt;</span><span class="s3">\n  </span><span class="s1">string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">id: string</span><span class="s3">\n    </span><span class="s1">chunks: string[]</span><span class="s3">\n    </span><span class="s1">name: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">type ServerActionsConfig = {</span><span class="s3">\n  </span><span class="s1">bodySizeLimit?: SizeLimit</span><span class="s3">\n  </span><span class="s1">allowedOrigins?: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type HandleActionResult =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">/** An MPA action threw notFound(), and we need to render the appropriate HTML */</span><span class="s3">\n      </span><span class="s1">type: 'not-found'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'done'</span><span class="s3">\n      </span><span class="s1">result: RenderResult | undefined</span><span class="s3">\n      </span><span class="s1">formState?: any</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/** The request turned out not to be a server action. */</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n\n</span><span class="s1">export async function handleAction({</span><span class="s3">\n  </span><span class="s1">req,</span><span class="s3">\n  </span><span class="s1">res,</span><span class="s3">\n  </span><span class="s1">ComponentMod,</span><span class="s3">\n  </span><span class="s1">serverModuleMap,</span><span class="s3">\n  </span><span class="s1">generateFlight,</span><span class="s3">\n  </span><span class="s1">workStore,</span><span class="s3">\n  </span><span class="s1">requestStore,</span><span class="s3">\n  </span><span class="s1">serverActions,</span><span class="s3">\n  </span><span class="s1">ctx,</span><span class="s3">\n  </span><span class="s1">metadata,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse</span><span class="s3">\n  </span><span class="s1">ComponentMod: AppPageModule</span><span class="s3">\n  </span><span class="s1">serverModuleMap: ServerModuleMap</span><span class="s3">\n  </span><span class="s1">generateFlight: GenerateFlight</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore</span><span class="s3">\n  </span><span class="s1">serverActions?: ServerActionsConfig</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext</span><span class="s3">\n  </span><span class="s1">metadata: AppPageRenderResultMetadata</span><span class="s3">\n</span><span class="s1">}): Promise&lt;HandleActionResult&gt; {</span><span class="s3">\n  </span><span class="s1">const contentType = req.headers['content-type']</span><span class="s3">\n  </span><span class="s1">const { serverActionsManifest, page } = ctx.renderOpts</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">actionId,</span><span class="s3">\n    </span><span class="s1">isURLEncodedAction,</span><span class="s3">\n    </span><span class="s1">isMultipartAction,</span><span class="s3">\n    </span><span class="s1">isFetchAction,</span><span class="s3">\n    </span><span class="s1">isPossibleServerAction,</span><span class="s3">\n  </span><span class="s1">} = getServerActionRequestMetadata(req)</span><span class="s3">\n\n  </span><span class="s1">// If it can't be a Server Action, skip handling.</span><span class="s3">\n  </span><span class="s1">// Note that this can be a false positive -- any multipart/urlencoded POST can get us here,</span><span class="s3">\n  </span><span class="s1">// But won't know if it's an MPA action or not until we call `decodeAction` below.</span><span class="s3">\n  </span><span class="s1">if (!isPossibleServerAction) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (workStore.isStaticGeneration) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Invariant: server actions can't be handled during static rendering</span><span class="s3">\&quot;\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let temporaryReferences: TemporaryReferenceSet | undefined</span><span class="s3">\n\n  </span><span class="s1">// When running actions the default is no-store, you can still `cache: 'force-cache'`</span><span class="s3">\n  </span><span class="s1">workStore.fetchCache = 'default-no-store'</span><span class="s3">\n\n  </span><span class="s1">const originDomain =</span><span class="s3">\n    </span><span class="s1">typeof req.headers['origin'] === 'string'</span><span class="s3">\n      </span><span class="s1">? new URL(req.headers['origin']).host</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n  </span><span class="s1">const host = parseHostHeader(req.headers)</span><span class="s3">\n\n  </span><span class="s1">let warning: string | undefined = undefined</span><span class="s3">\n\n  </span><span class="s1">function warnBadServerActionRequest() {</span><span class="s3">\n    </span><span class="s1">if (warning) {</span><span class="s3">\n      </span><span class="s1">warn(warning)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to</span><span class="s3">\n  </span><span class="s1">// ensure that the request is coming from the same host.</span><span class="s3">\n  </span><span class="s1">if (!originDomain) {</span><span class="s3">\n    </span><span class="s1">// This might be an old browser that doesn't send `host` header. We ignore</span><span class="s3">\n    </span><span class="s1">// this case.</span><span class="s3">\n    </span><span class="s1">warning = 'Missing `origin` header from a forwarded Server Actions request.'</span><span class="s3">\n  </span><span class="s1">} else if (!host || originDomain !== host.value) {</span><span class="s3">\n    </span><span class="s1">// If the customer sets a list of allowed origins, we'll allow the request.</span><span class="s3">\n    </span><span class="s1">// These are considered safe but might be different from forwarded host set</span><span class="s3">\n    </span><span class="s1">// by the infra (i.e. reverse proxies).</span><span class="s3">\n    </span><span class="s1">if (isCsrfOriginAllowed(originDomain, serverActions?.allowedOrigins)) {</span><span class="s3">\n      </span><span class="s1">// Ignore it</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (host) {</span><span class="s3">\n        </span><span class="s1">// This seems to be an CSRF attack. We should not proceed the action.</span><span class="s3">\n        </span><span class="s1">console.error(</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`${</span><span class="s3">\n            </span><span class="s1">host.type</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\\</span><span class="s1">` header with value </span><span class="s3">\\</span><span class="s1">`${limitUntrustedHeaderValueForLogs(</span><span class="s3">\n            </span><span class="s1">host.value</span><span class="s3">\n          </span><span class="s1">)}</span><span class="s3">\\</span><span class="s1">` does not match </span><span class="s3">\\</span><span class="s1">`origin</span><span class="s3">\\</span><span class="s1">` header with value </span><span class="s3">\\</span><span class="s1">`${limitUntrustedHeaderValueForLogs(</span><span class="s3">\n            </span><span class="s1">originDomain</span><span class="s3">\n          </span><span class="s1">)}</span><span class="s3">\\</span><span class="s1">` from a forwarded Server Actions request. Aborting the action.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// This is an attack. We should not proceed the action.</span><span class="s3">\n        </span><span class="s1">console.error(</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`x-forwarded-host</span><span class="s3">\\</span><span class="s1">` or </span><span class="s3">\\</span><span class="s1">`host</span><span class="s3">\\</span><span class="s1">` headers are not provided. One of these is needed to compare the </span><span class="s3">\\</span><span class="s1">`origin</span><span class="s3">\\</span><span class="s1">` header from a forwarded Server Actions request. Aborting the action.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const error = new Error('Invalid Server Actions request.')</span><span class="s3">\n\n      </span><span class="s1">if (isFetchAction) {</span><span class="s3">\n        </span><span class="s1">res.statusCode = 500</span><span class="s3">\n        </span><span class="s1">metadata.statusCode = 500</span><span class="s3">\n\n        </span><span class="s1">const promise = Promise.reject(error)</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">// we need to await the promise to trigger the rejection early</span><span class="s3">\n          </span><span class="s1">// so that it's already handled by the time we call</span><span class="s3">\n          </span><span class="s1">// the RSC runtime. Otherwise, it will throw an unhandled</span><span class="s3">\n          </span><span class="s1">// promise rejection error in the renderer.</span><span class="s3">\n          </span><span class="s1">await promise</span><span class="s3">\n        </span><span class="s1">} catch {</span><span class="s3">\n          </span><span class="s1">// swallow error, it's gonna be handled on the client</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">type: 'done',</span><span class="s3">\n          </span><span class="s1">result: await generateFlight(req, ctx, requestStore, {</span><span class="s3">\n            </span><span class="s1">actionResult: promise,</span><span class="s3">\n            </span><span class="s1">// We didn't execute an action, so no revalidations could have occurred. We can skip rendering the page.</span><span class="s3">\n            </span><span class="s1">skipFlight: true,</span><span class="s3">\n            </span><span class="s1">temporaryReferences,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">throw error</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// ensure we avoid caching server actions unexpectedly</span><span class="s3">\n  </span><span class="s1">res.setHeader(</span><span class="s3">\n    </span><span class="s1">'Cache-Control',</span><span class="s3">\n    </span><span class="s1">'no-cache, no-store, max-age=0, must-revalidate'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const { actionAsyncStorage } = ComponentMod</span><span class="s3">\n\n  </span><span class="s1">const actionWasForwarded = Boolean(req.headers['x-action-forwarded'])</span><span class="s3">\n\n  </span><span class="s1">if (actionId) {</span><span class="s3">\n    </span><span class="s1">const forwardedWorker = selectWorkerForForwarding(</span><span class="s3">\n      </span><span class="s1">actionId,</span><span class="s3">\n      </span><span class="s1">page,</span><span class="s3">\n      </span><span class="s1">serverActionsManifest</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// If forwardedWorker is truthy, it means there isn't a worker for the action</span><span class="s3">\n    </span><span class="s1">// in the current handler, so we forward the request to a worker that has the action.</span><span class="s3">\n    </span><span class="s1">if (forwardedWorker) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">type: 'done',</span><span class="s3">\n        </span><span class="s1">result: await createForwardedActionResponse(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">res,</span><span class="s3">\n          </span><span class="s1">host,</span><span class="s3">\n          </span><span class="s1">forwardedWorker,</span><span class="s3">\n          </span><span class="s1">ctx.renderOpts.basePath</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const handleUnrecognizedFetchAction = (err: unknown): HandleActionResult =&gt; {</span><span class="s3">\n    </span><span class="s1">// If the deployment doesn't have skew protection, this is expected to occasionally happen,</span><span class="s3">\n    </span><span class="s1">// so we use a warning instead of an error.</span><span class="s3">\n    </span><span class="s1">console.warn(err)</span><span class="s3">\n\n    </span><span class="s1">// Return an empty response with a header that the client router will interpret.</span><span class="s3">\n    </span><span class="s1">// We don't need to waste time encoding a flight response, and using a blank body + header</span><span class="s3">\n    </span><span class="s1">// means that unrecognized actions can also be handled at the infra level</span><span class="s3">\n    </span><span class="s1">// (i.e. without needing to invoke a lambda)</span><span class="s3">\n    </span><span class="s1">res.setHeader(NEXT_ACTION_NOT_FOUND_HEADER, '1')</span><span class="s3">\n    </span><span class="s1">res.setHeader('content-type', 'text/plain')</span><span class="s3">\n    </span><span class="s1">res.statusCode = 404</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">type: 'done',</span><span class="s3">\n      </span><span class="s1">result: RenderResult.fromStatic('Server action not found.', 'text/plain'),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return await actionAsyncStorage.run(</span><span class="s3">\n      </span><span class="s1">{ isAction: true },</span><span class="s3">\n      </span><span class="s1">async (): Promise&lt;HandleActionResult&gt; =&gt; {</span><span class="s3">\n        </span><span class="s1">// We only use these for fetch actions -- MPA actions handle them inside `decodeAction`.</span><span class="s3">\n        </span><span class="s1">let actionModId: string | undefined</span><span class="s3">\n        </span><span class="s1">let boundActionArguments: unknown[] = []</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n          </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n          </span><span class="s1">process.env.NEXT_RUNTIME === 'edge' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">isWebNextRequest(req)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">if (!req.body) {</span><span class="s3">\n            </span><span class="s1">throw new Error('invariant: Missing request body.')</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// TODO: add body limit</span><span class="s3">\n\n          </span><span class="s1">// Use react-server-dom-webpack/server</span><span class="s3">\n          </span><span class="s1">const {</span><span class="s3">\n            </span><span class="s1">createTemporaryReferenceSet,</span><span class="s3">\n            </span><span class="s1">decodeReply,</span><span class="s3">\n            </span><span class="s1">decodeAction,</span><span class="s3">\n            </span><span class="s1">decodeFormState,</span><span class="s3">\n          </span><span class="s1">} = ComponentMod</span><span class="s3">\n\n          </span><span class="s1">temporaryReferences = createTemporaryReferenceSet()</span><span class="s3">\n\n          </span><span class="s1">if (isMultipartAction) {</span><span class="s3">\n            </span><span class="s1">// TODO-APP: Add streaming support</span><span class="s3">\n            </span><span class="s1">const formData = await req.request.formData()</span><span class="s3">\n            </span><span class="s1">if (isFetchAction) {</span><span class="s3">\n              </span><span class="s1">// A fetch action with a multipart body.</span><span class="s3">\n              </span><span class="s1">boundActionArguments = await decodeReply(</span><span class="s3">\n                </span><span class="s1">formData,</span><span class="s3">\n                </span><span class="s1">serverModuleMap,</span><span class="s3">\n                </span><span class="s1">{ temporaryReferences }</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// Multipart POST, but not a fetch action.</span><span class="s3">\n              </span><span class="s1">// Potentially an MPA action, we have to try decoding it to check.</span><span class="s3">\n              </span><span class="s1">const action = await decodeAction(formData, serverModuleMap)</span><span class="s3">\n              </span><span class="s1">if (typeof action === 'function') {</span><span class="s3">\n                </span><span class="s1">// an MPA action.</span><span class="s3">\n\n                </span><span class="s1">// Only warn if it's a server action, otherwise skip for other post requests</span><span class="s3">\n                </span><span class="s1">warnBadServerActionRequest()</span><span class="s3">\n\n                </span><span class="s1">const actionReturnedState =</span><span class="s3">\n                  </span><span class="s1">await executeActionAndPrepareForRender(</span><span class="s3">\n                    </span><span class="s1">action as () =&gt; Promise&lt;unknown&gt;,</span><span class="s3">\n                    </span><span class="s1">[],</span><span class="s3">\n                    </span><span class="s1">workStore,</span><span class="s3">\n                    </span><span class="s1">requestStore</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">const formState = await decodeFormState(</span><span class="s3">\n                  </span><span class="s1">actionReturnedState,</span><span class="s3">\n                  </span><span class="s1">formData,</span><span class="s3">\n                  </span><span class="s1">serverModuleMap</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">// Skip the fetch path.</span><span class="s3">\n                </span><span class="s1">// We need to render a full HTML version of the page for the response, we'll handle that in app-render.</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                  </span><span class="s1">type: 'done',</span><span class="s3">\n                  </span><span class="s1">result: undefined,</span><span class="s3">\n                  </span><span class="s1">formState,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">// We couldn't decode an action, so this POST request turned out not to be a server action request.</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// POST with non-multipart body.</span><span class="s3">\n\n            </span><span class="s1">// If it's not multipart AND not a fetch action,</span><span class="s3">\n            </span><span class="s1">// then it can't be an action request.</span><span class="s3">\n            </span><span class="s1">if (!isFetchAction) {</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">actionModId = getActionModIdOrError(actionId, serverModuleMap)</span><span class="s3">\n            </span><span class="s1">} catch (err) {</span><span class="s3">\n              </span><span class="s1">return handleUnrecognizedFetchAction(err)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// A fetch action with a non-multipart body.</span><span class="s3">\n            </span><span class="s1">// In practice, this happens if `encodeReply` returned a string instead of FormData,</span><span class="s3">\n            </span><span class="s1">// which can happen for very simple JSON-like values that don't need multiple flight rows.</span><span class="s3">\n\n            </span><span class="s1">const chunks: Buffer[] = []</span><span class="s3">\n            </span><span class="s1">const reader = req.body.getReader()</span><span class="s3">\n            </span><span class="s1">while (true) {</span><span class="s3">\n              </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n              </span><span class="s1">if (done) {</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">chunks.push(value)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const actionData = Buffer.concat(chunks).toString('utf-8')</span><span class="s3">\n\n            </span><span class="s1">if (isURLEncodedAction) {</span><span class="s3">\n              </span><span class="s1">const formData = formDataFromSearchQueryString(actionData)</span><span class="s3">\n              </span><span class="s1">boundActionArguments = await decodeReply(</span><span class="s3">\n                </span><span class="s1">formData,</span><span class="s3">\n                </span><span class="s1">serverModuleMap,</span><span class="s3">\n                </span><span class="s1">{ temporaryReferences }</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">boundActionArguments = await decodeReply(</span><span class="s3">\n                </span><span class="s1">actionData,</span><span class="s3">\n                </span><span class="s1">serverModuleMap,</span><span class="s3">\n                </span><span class="s1">{ temporaryReferences }</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n          </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n          </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">isNodeNextRequest(req)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// Use react-server-dom-webpack/server.node which supports streaming</span><span class="s3">\n          </span><span class="s1">const {</span><span class="s3">\n            </span><span class="s1">createTemporaryReferenceSet,</span><span class="s3">\n            </span><span class="s1">decodeReply,</span><span class="s3">\n            </span><span class="s1">decodeReplyFromBusboy,</span><span class="s3">\n            </span><span class="s1">decodeAction,</span><span class="s3">\n            </span><span class="s1">decodeFormState,</span><span class="s3">\n          </span><span class="s1">} = require(</span><span class="s3">\n            </span><span class="s1">`./react-server.node`</span><span class="s3">\n          </span><span class="s1">) as typeof import('./react-server.node')</span><span class="s3">\n\n          </span><span class="s1">temporaryReferences = createTemporaryReferenceSet()</span><span class="s3">\n\n          </span><span class="s1">const { Transform, pipeline } =</span><span class="s3">\n            </span><span class="s1">require('node:stream') as typeof import('node:stream')</span><span class="s3">\n\n          </span><span class="s1">const defaultBodySizeLimit = '1 MB'</span><span class="s3">\n          </span><span class="s1">const bodySizeLimit =</span><span class="s3">\n            </span><span class="s1">serverActions?.bodySizeLimit ?? defaultBodySizeLimit</span><span class="s3">\n          </span><span class="s1">const bodySizeLimitBytes =</span><span class="s3">\n            </span><span class="s1">bodySizeLimit !== defaultBodySizeLimit</span><span class="s3">\n              </span><span class="s1">? (</span><span class="s3">\n                  </span><span class="s1">require('next/dist/compiled/bytes') as typeof import('next/dist/compiled/bytes')</span><span class="s3">\n                </span><span class="s1">).parse(bodySizeLimit)</span><span class="s3">\n              </span><span class="s1">: 1024 * 1024 // 1 MB</span><span class="s3">\n\n          </span><span class="s1">let size = 0</span><span class="s3">\n          </span><span class="s1">const sizeLimitTransform = new Transform({</span><span class="s3">\n            </span><span class="s1">transform(chunk, encoding, callback) {</span><span class="s3">\n              </span><span class="s1">size += Buffer.byteLength(chunk, encoding)</span><span class="s3">\n              </span><span class="s1">if (size &gt; bodySizeLimitBytes) {</span><span class="s3">\n                </span><span class="s1">const { ApiError } =</span><span class="s3">\n                  </span><span class="s1">require('../api-utils') as typeof import('../api-utils')</span><span class="s3">\n\n                </span><span class="s1">callback(</span><span class="s3">\n                  </span><span class="s1">new ApiError(</span><span class="s3">\n                    </span><span class="s1">413,</span><span class="s3">\n                    </span><span class="s1">`Body exceeded ${bodySizeLimit} limit.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                      </span><span class="s1">`To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">return</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">callback(null, chunk)</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">const sizeLimitedBody = pipeline(</span><span class="s3">\n            </span><span class="s1">req.body,</span><span class="s3">\n            </span><span class="s1">sizeLimitTransform,</span><span class="s3">\n            </span><span class="s1">// Avoid unhandled errors from `pipeline()` by passing an empty completion callback.</span><span class="s3">\n            </span><span class="s1">// We'll propagate the errors properly when consuming the stream.</span><span class="s3">\n            </span><span class="s1">() =&gt; {}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">if (isMultipartAction) {</span><span class="s3">\n            </span><span class="s1">if (isFetchAction) {</span><span class="s3">\n              </span><span class="s1">// A fetch action with a multipart body.</span><span class="s3">\n\n              </span><span class="s1">const busboy = (</span><span class="s3">\n                </span><span class="s1">require('next/dist/compiled/busboy') as typeof import('next/dist/compiled/busboy')</span><span class="s3">\n              </span><span class="s1">)({</span><span class="s3">\n                </span><span class="s1">defParamCharset: 'utf8',</span><span class="s3">\n                </span><span class="s1">headers: req.headers,</span><span class="s3">\n                </span><span class="s1">limits: { fieldSize: bodySizeLimitBytes },</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n\n              </span><span class="s1">// We need to use `pipeline(one, two)` instead of `one.pipe(two)` to propagate size limit errors correctly.</span><span class="s3">\n              </span><span class="s1">pipeline(</span><span class="s3">\n                </span><span class="s1">sizeLimitedBody,</span><span class="s3">\n                </span><span class="s1">busboy,</span><span class="s3">\n                </span><span class="s1">// Avoid unhandled errors from `pipeline()` by passing an empty completion callback.</span><span class="s3">\n                </span><span class="s1">// We'll propagate the errors properly when consuming the stream.</span><span class="s3">\n                </span><span class="s1">() =&gt; {}</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">boundActionArguments = await decodeReplyFromBusboy(</span><span class="s3">\n                </span><span class="s1">busboy,</span><span class="s3">\n                </span><span class="s1">serverModuleMap,</span><span class="s3">\n                </span><span class="s1">{ temporaryReferences }</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// Multipart POST, but not a fetch action.</span><span class="s3">\n              </span><span class="s1">// Potentially an MPA action, we have to try decoding it to check.</span><span class="s3">\n\n              </span><span class="s1">// React doesn't yet publish a busboy version of decodeAction</span><span class="s3">\n              </span><span class="s1">// so we polyfill the parsing of FormData.</span><span class="s3">\n              </span><span class="s1">const fakeRequest = new Request('http://localhost', {</span><span class="s3">\n                </span><span class="s1">method: 'POST',</span><span class="s3">\n                </span><span class="s1">// @ts-expect-error</span><span class="s3">\n                </span><span class="s1">headers: { 'Content-Type': contentType },</span><span class="s3">\n                </span><span class="s1">body: new ReadableStream({</span><span class="s3">\n                  </span><span class="s1">start: (controller) =&gt; {</span><span class="s3">\n                    </span><span class="s1">sizeLimitedBody.on('data', (chunk) =&gt; {</span><span class="s3">\n                      </span><span class="s1">controller.enqueue(new Uint8Array(chunk))</span><span class="s3">\n                    </span><span class="s1">})</span><span class="s3">\n                    </span><span class="s1">sizeLimitedBody.on('end', () =&gt; {</span><span class="s3">\n                      </span><span class="s1">controller.close()</span><span class="s3">\n                    </span><span class="s1">})</span><span class="s3">\n                    </span><span class="s1">sizeLimitedBody.on('error', (err) =&gt; {</span><span class="s3">\n                      </span><span class="s1">controller.error(err)</span><span class="s3">\n                    </span><span class="s1">})</span><span class="s3">\n                  </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">}),</span><span class="s3">\n                </span><span class="s1">duplex: 'half',</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">const formData = await fakeRequest.formData()</span><span class="s3">\n              </span><span class="s1">const action = await decodeAction(formData, serverModuleMap)</span><span class="s3">\n              </span><span class="s1">if (typeof action === 'function') {</span><span class="s3">\n                </span><span class="s1">// an MPA action.</span><span class="s3">\n\n                </span><span class="s1">// Only warn if it's a server action, otherwise skip for other post requests</span><span class="s3">\n                </span><span class="s1">warnBadServerActionRequest()</span><span class="s3">\n\n                </span><span class="s1">const actionReturnedState =</span><span class="s3">\n                  </span><span class="s1">await executeActionAndPrepareForRender(</span><span class="s3">\n                    </span><span class="s1">action as () =&gt; Promise&lt;unknown&gt;,</span><span class="s3">\n                    </span><span class="s1">[],</span><span class="s3">\n                    </span><span class="s1">workStore,</span><span class="s3">\n                    </span><span class="s1">requestStore</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">const formState = await decodeFormState(</span><span class="s3">\n                  </span><span class="s1">actionReturnedState,</span><span class="s3">\n                  </span><span class="s1">formData,</span><span class="s3">\n                  </span><span class="s1">serverModuleMap</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">// Skip the fetch path.</span><span class="s3">\n                </span><span class="s1">// We need to render a full HTML version of the page for the response, we'll handle that in app-render.</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                  </span><span class="s1">type: 'done',</span><span class="s3">\n                  </span><span class="s1">result: undefined,</span><span class="s3">\n                  </span><span class="s1">formState,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">// We couldn't decode an action, so this POST request turned out not to be a server action request.</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// POST with non-multipart body.</span><span class="s3">\n\n            </span><span class="s1">// If it's not multipart AND not a fetch action,</span><span class="s3">\n            </span><span class="s1">// then it can't be an action request.</span><span class="s3">\n            </span><span class="s1">if (!isFetchAction) {</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">actionModId = getActionModIdOrError(actionId, serverModuleMap)</span><span class="s3">\n            </span><span class="s1">} catch (err) {</span><span class="s3">\n              </span><span class="s1">return handleUnrecognizedFetchAction(err)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// A fetch action with a non-multipart body.</span><span class="s3">\n            </span><span class="s1">// In practice, this happens if `encodeReply` returned a string instead of FormData,</span><span class="s3">\n            </span><span class="s1">// which can happen for very simple JSON-like values that don't need multiple flight rows.</span><span class="s3">\n\n            </span><span class="s1">const chunks: Buffer[] = []</span><span class="s3">\n            </span><span class="s1">for await (const chunk of sizeLimitedBody) {</span><span class="s3">\n              </span><span class="s1">chunks.push(Buffer.from(chunk))</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const actionData = Buffer.concat(chunks).toString('utf-8')</span><span class="s3">\n\n            </span><span class="s1">if (isURLEncodedAction) {</span><span class="s3">\n              </span><span class="s1">const formData = formDataFromSearchQueryString(actionData)</span><span class="s3">\n              </span><span class="s1">boundActionArguments = await decodeReply(</span><span class="s3">\n                </span><span class="s1">formData,</span><span class="s3">\n                </span><span class="s1">serverModuleMap,</span><span class="s3">\n                </span><span class="s1">{ temporaryReferences }</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">boundActionArguments = await decodeReply(</span><span class="s3">\n                </span><span class="s1">actionData,</span><span class="s3">\n                </span><span class="s1">serverModuleMap,</span><span class="s3">\n                </span><span class="s1">{ temporaryReferences }</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">throw new Error('Invariant: Unknown request type.')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// actions.js</span><span class="s3">\n        </span><span class="s1">// app/page.js</span><span class="s3">\n        </span><span class="s1">//   action worker1</span><span class="s3">\n        </span><span class="s1">//     appRender1</span><span class="s3">\n\n        </span><span class="s1">// app/foo/page.js</span><span class="s3">\n        </span><span class="s1">//   action worker2</span><span class="s3">\n        </span><span class="s1">//     appRender</span><span class="s3">\n\n        </span><span class="s1">// / -&gt; fire action -&gt; POST / -&gt; appRender1 -&gt; modId for the action file</span><span class="s3">\n        </span><span class="s1">// /foo -&gt; fire action -&gt; POST /foo -&gt; appRender2 -&gt; modId for the action file</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">actionModId =</span><span class="s3">\n            </span><span class="s1">actionModId ?? getActionModIdOrError(actionId, serverModuleMap)</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">return handleUnrecognizedFetchAction(err)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const actionMod = (await ComponentMod.__next_app__.require(</span><span class="s3">\n          </span><span class="s1">actionModId</span><span class="s3">\n        </span><span class="s1">)) as Record&lt;string, (...args: unknown[]) =&gt; Promise&lt;unknown&gt;&gt;</span><span class="s3">\n        </span><span class="s1">const actionHandler =</span><span class="s3">\n          </span><span class="s1">actionMod[</span><span class="s3">\n            </span><span class="s1">// `actionId` must exist if we got here, as otherwise we would have thrown an error above</span><span class="s3">\n            </span><span class="s1">actionId!</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n\n        </span><span class="s1">const returnVal = await executeActionAndPrepareForRender(</span><span class="s3">\n          </span><span class="s1">actionHandler,</span><span class="s3">\n          </span><span class="s1">boundActionArguments,</span><span class="s3">\n          </span><span class="s1">workStore,</span><span class="s3">\n          </span><span class="s1">requestStore</span><span class="s3">\n        </span><span class="s1">).finally(() =&gt; {</span><span class="s3">\n          </span><span class="s1">addRevalidationHeader(res, { workStore, requestStore })</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">// For form actions, we need to continue rendering the page.</span><span class="s3">\n        </span><span class="s1">if (isFetchAction) {</span><span class="s3">\n          </span><span class="s1">const actionResult = await generateFlight(req, ctx, requestStore, {</span><span class="s3">\n            </span><span class="s1">actionResult: Promise.resolve(returnVal),</span><span class="s3">\n            </span><span class="s1">// if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree</span><span class="s3">\n            </span><span class="s1">skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,</span><span class="s3">\n            </span><span class="s1">temporaryReferences,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: 'done',</span><span class="s3">\n            </span><span class="s1">result: actionResult,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// TODO: this shouldn't be reachable, because all non-fetch codepaths return early.</span><span class="s3">\n          </span><span class="s1">// this will be handled in a follow-up refactor PR.</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">if (isRedirectError(err)) {</span><span class="s3">\n      </span><span class="s1">const redirectUrl = getURLFromRedirectError(err)</span><span class="s3">\n      </span><span class="s1">const redirectType = getRedirectTypeFromError(err)</span><span class="s3">\n\n      </span><span class="s1">// if it's a fetch action, we'll set the status code for logging/debugging purposes</span><span class="s3">\n      </span><span class="s1">// but we won't set a Location header, as the redirect will be handled by the client router</span><span class="s3">\n      </span><span class="s1">res.statusCode = RedirectStatusCode.SeeOther</span><span class="s3">\n      </span><span class="s1">metadata.statusCode = RedirectStatusCode.SeeOther</span><span class="s3">\n\n      </span><span class="s1">if (isFetchAction) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">type: 'done',</span><span class="s3">\n          </span><span class="s1">result: await createRedirectRenderResult(</span><span class="s3">\n            </span><span class="s1">req,</span><span class="s3">\n            </span><span class="s1">res,</span><span class="s3">\n            </span><span class="s1">host,</span><span class="s3">\n            </span><span class="s1">redirectUrl,</span><span class="s3">\n            </span><span class="s1">redirectType,</span><span class="s3">\n            </span><span class="s1">ctx.renderOpts.basePath,</span><span class="s3">\n            </span><span class="s1">workStore</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// For an MPA action, the redirect doesn't need a body, just a Location header.</span><span class="s3">\n      </span><span class="s1">res.setHeader('Location', redirectUrl)</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">type: 'done',</span><span class="s3">\n        </span><span class="s1">result: RenderResult.EMPTY,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (isHTTPAccessFallbackError(err)) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = getAccessFallbackHTTPStatus(err)</span><span class="s3">\n      </span><span class="s1">metadata.statusCode = res.statusCode</span><span class="s3">\n\n      </span><span class="s1">if (isFetchAction) {</span><span class="s3">\n        </span><span class="s1">const promise = Promise.reject(err)</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">// we need to await the promise to trigger the rejection early</span><span class="s3">\n          </span><span class="s1">// so that it's already handled by the time we call</span><span class="s3">\n          </span><span class="s1">// the RSC runtime. Otherwise, it will throw an unhandled</span><span class="s3">\n          </span><span class="s1">// promise rejection error in the renderer.</span><span class="s3">\n          </span><span class="s1">await promise</span><span class="s3">\n        </span><span class="s1">} catch {</span><span class="s3">\n          </span><span class="s1">// swallow error, it's gonna be handled on the client</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">type: 'done',</span><span class="s3">\n          </span><span class="s1">result: await generateFlight(req, ctx, requestStore, {</span><span class="s3">\n            </span><span class="s1">skipFlight: false,</span><span class="s3">\n            </span><span class="s1">actionResult: promise,</span><span class="s3">\n            </span><span class="s1">temporaryReferences,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// For an MPA action, we need to render a HTML response. We'll handle that in app-render.</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">type: 'not-found',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// An error that didn't come from `redirect()` or `notFound()`, likely thrown from user code</span><span class="s3">\n    </span><span class="s1">// (but it could also be a bug in our code!)</span><span class="s3">\n\n    </span><span class="s1">if (isFetchAction) {</span><span class="s3">\n      </span><span class="s1">// TODO: consider checking if the error is an `ApiError` and change status code</span><span class="s3">\n      </span><span class="s1">// so that we can respond with a 413 to requests that break the body size limit</span><span class="s3">\n      </span><span class="s1">// (but if we do that, we also need to make sure that whatever handles the non-fetch error path below does the same)</span><span class="s3">\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n      </span><span class="s1">metadata.statusCode = 500</span><span class="s3">\n      </span><span class="s1">const promise = Promise.reject(err)</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// we need to await the promise to trigger the rejection early</span><span class="s3">\n        </span><span class="s1">// so that it's already handled by the time we call</span><span class="s3">\n        </span><span class="s1">// the RSC runtime. Otherwise, it will throw an unhandled</span><span class="s3">\n        </span><span class="s1">// promise rejection error in the renderer.</span><span class="s3">\n        </span><span class="s1">await promise</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// swallow error, it's gonna be handled on the client</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">type: 'done',</span><span class="s3">\n        </span><span class="s1">result: await generateFlight(req, ctx, requestStore, {</span><span class="s3">\n          </span><span class="s1">actionResult: promise,</span><span class="s3">\n          </span><span class="s1">// if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree</span><span class="s3">\n          </span><span class="s1">skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,</span><span class="s3">\n          </span><span class="s1">temporaryReferences,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// For an MPA action, we need to render a HTML response. We'll rethrow the error and let it be handled above.</span><span class="s3">\n    </span><span class="s1">throw err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function executeActionAndPrepareForRender&lt;</span><span class="s3">\n  </span><span class="s1">TFn extends (...args: any[]) =&gt; Promise&lt;any&gt;,</span><span class="s3">\n</span><span class="s1">&gt;(</span><span class="s3">\n  </span><span class="s1">action: TFn,</span><span class="s3">\n  </span><span class="s1">args: Parameters&lt;TFn&gt;,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;Awaited&lt;ReturnType&lt;TFn&gt;&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">requestStore.phase = 'action'</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return await workUnitAsyncStorage.run(requestStore, () =&gt;</span><span class="s3">\n      </span><span class="s1">action.apply(null, args)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">requestStore.phase = 'render'</span><span class="s3">\n\n    </span><span class="s1">// When we switch to the render phase, cookies() will return</span><span class="s3">\n    </span><span class="s1">// `workUnitStore.cookies` instead of `workUnitStore.userspaceMutableCookies`.</span><span class="s3">\n    </span><span class="s1">// We want the render to see any cookie writes that we performed during the action,</span><span class="s3">\n    </span><span class="s1">// so we need to update the immutable cookies to reflect the changes.</span><span class="s3">\n    </span><span class="s1">synchronizeMutableCookies(requestStore)</span><span class="s3">\n\n    </span><span class="s1">// The server action might have toggled draft mode, so we need to reflect</span><span class="s3">\n    </span><span class="s1">// that in the work store to be up-to-date for subsequent rendering.</span><span class="s3">\n    </span><span class="s1">workStore.isDraftMode = requestStore.draftMode.isEnabled</span><span class="s3">\n\n    </span><span class="s1">// If the action called revalidateTag/revalidatePath, then that might affect data used by the subsequent render,</span><span class="s3">\n    </span><span class="s1">// so we need to make sure all revalidations are applied before that</span><span class="s3">\n    </span><span class="s1">await executeRevalidates(workStore)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where</span><span class="s3">\n </span><span class="s1">* the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.</span><span class="s3">\n </span><span class="s1">* In either case, we'll throw an error to be handled by the caller.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getActionModIdOrError(</span><span class="s3">\n  </span><span class="s1">actionId: string | null,</span><span class="s3">\n  </span><span class="s1">serverModuleMap: ServerModuleMap</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">// if we're missing the action ID header, we can't do any further processing</span><span class="s3">\n  </span><span class="s1">if (!actionId) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\&quot;</span><span class="s1">Missing 'next-action' header.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const actionModId = serverModuleMap[actionId]?.id</span><span class="s3">\n\n  </span><span class="s1">if (!actionModId) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Failed to find Server Action </span><span class="s3">\&quot;</span><span class="s1">${actionId}</span><span class="s3">\&quot;</span><span class="s1">. This request might be from an older or newer deployment.</span><span class="s3">\\</span><span class="s1">nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return actionModId</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;handleAction&quot;</span><span class="s0">,</span><span class="s1">&quot;parseHostHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;formDataFromSearchQueryString&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;formData&quot;</span><span class="s0">,</span><span class="s1">&quot;FormData&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeHeadersToRecord&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;record&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;getForwardedHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;requestCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;RequestCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;HeadersAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;responseHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;responseCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;fromNodeOutgoingHttpHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;mergedHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;filterReqHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;actionsForbiddenHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getAll&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;cookie&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;Headers&quot;</span><span class="s0">,</span><span class="s1">&quot;addRevalidationHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;requestStore&quot;</span><span class="s0">,</span><span class="s1">&quot;isTagRevalidated&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isCookieRevalidated&quot;</span><span class="s0">,</span><span class="s1">&quot;getModifiedCookieValues&quot;</span><span class="s0">,</span><span class="s1">&quot;mutableCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;createForwardedActionResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;workerPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;forwardedHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;proto&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_PRIVATE_ORIGIN&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;isWebNextRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isNodeNextRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;duplex&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;internal&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;FlightRenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;cancel&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;fromStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppRelativeRedirectUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedRedirectUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;createRedirectRenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;originalHost&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectType&quot;</span><span class="s0">,</span><span class="s1">&quot;appRelativeRedirectUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATED_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;preview&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeId&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;setCacheBustingSearchParam&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_SEGMENT_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;EMPTY&quot;</span><span class="s0">,</span><span class="s1">&quot;limitUntrustedHeaderValueForLogs&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;originDomain&quot;</span><span class="s0">,</span><span class="s1">&quot;forwardedHostHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;forwardedHostHeaderValue&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;trim&quot;</span><span class="s0">,</span><span class="s1">&quot;hostHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;ComponentMod&quot;</span><span class="s0">,</span><span class="s1">&quot;serverModuleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;generateFlight&quot;</span><span class="s0">,</span><span class="s1">&quot;serverActions&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;serverActionsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;actionId&quot;</span><span class="s0">,</span><span class="s1">&quot;isURLEncodedAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isMultipartAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isFetchAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isPossibleServerAction&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerActionRequestMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;temporaryReferences&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;warning&quot;</span><span class="s0">,</span><span class="s1">&quot;warnBadServerActionRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;isCsrfOriginAllowed&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedOrigins&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;actionResult&quot;</span><span class="s0">,</span><span class="s1">&quot;skipFlight&quot;</span><span class="s0">,</span><span class="s1">&quot;actionAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;actionWasForwarded&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;forwardedWorker&quot;</span><span class="s0">,</span><span class="s1">&quot;selectWorkerForForwarding&quot;</span><span class="s0">,</span><span class="s1">&quot;handleUnrecognizedFetchAction&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ACTION_NOT_FOUND_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;isAction&quot;</span><span class="s0">,</span><span class="s1">&quot;actionModId&quot;</span><span class="s0">,</span><span class="s1">&quot;boundActionArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;createTemporaryReferenceSet&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeReply&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeAction&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeFormState&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;actionReturnedState&quot;</span><span class="s0">,</span><span class="s1">&quot;executeActionAndPrepareForRender&quot;</span><span class="s0">,</span><span class="s1">&quot;formState&quot;</span><span class="s0">,</span><span class="s1">&quot;getActionModIdOrError&quot;</span><span class="s0">,</span><span class="s1">&quot;chunks&quot;</span><span class="s0">,</span><span class="s1">&quot;reader&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;read&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;actionData&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeReplyFromBusboy&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;Transform&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeline&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultBodySizeLimit&quot;</span><span class="s0">,</span><span class="s1">&quot;bodySizeLimit&quot;</span><span class="s0">,</span><span class="s1">&quot;bodySizeLimitBytes&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;sizeLimitTransform&quot;</span><span class="s0">,</span><span class="s1">&quot;transform&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;encoding&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;byteLength&quot;</span><span class="s0">,</span><span class="s1">&quot;ApiError&quot;</span><span class="s0">,</span><span class="s1">&quot;sizeLimitedBody&quot;</span><span class="s0">,</span><span class="s1">&quot;busboy&quot;</span><span class="s0">,</span><span class="s1">&quot;defParamCharset&quot;</span><span class="s0">,</span><span class="s1">&quot;limits&quot;</span><span class="s0">,</span><span class="s1">&quot;fieldSize&quot;</span><span class="s0">,</span><span class="s1">&quot;fakeRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;Request&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;actionMod&quot;</span><span class="s0">,</span><span class="s1">&quot;__next_app__&quot;</span><span class="s0">,</span><span class="s1">&quot;actionHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;returnVal&quot;</span><span class="s0">,</span><span class="s1">&quot;finally&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;pathWasRevalidated&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;getURLFromRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectTypeFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;SeeOther&quot;</span><span class="s0">,</span><span class="s1">&quot;isHTTPAccessFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;getAccessFallbackHTTPStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;synchronizeMutableCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;isDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;draftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;isEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;executeRevalidates&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>