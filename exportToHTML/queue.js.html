<html>
<head>
<title>queue.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
queue.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span>

<span class="s2">/* eslint-disable no-var */</span>

<span class="s3">var </span><span class="s1">reusify = require(</span><span class="s0">'reusify'</span><span class="s1">)</span>

<span class="s3">function </span><span class="s1">fastqueue (context, worker, _concurrency) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">context === </span><span class="s0">'function'</span><span class="s1">) {</span>
    <span class="s1">_concurrency = worker</span>
    <span class="s1">worker = context</span>
    <span class="s1">context = </span><span class="s3">null</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!(_concurrency &gt;= </span><span class="s4">1</span><span class="s1">)) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'fastqueue concurrency must be equal to or greater than 1'</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">cache = reusify(Task)</span>
  <span class="s3">var </span><span class="s1">queueHead = </span><span class="s3">null</span>
  <span class="s3">var </span><span class="s1">queueTail = </span><span class="s3">null</span>
  <span class="s3">var </span><span class="s1">_running = </span><span class="s4">0</span>
  <span class="s3">var </span><span class="s1">errorHandler = </span><span class="s3">null</span>

  <span class="s3">var </span><span class="s1">self = {</span>
    <span class="s1">push: push,</span>
    <span class="s1">drain: noop,</span>
    <span class="s1">saturated: noop,</span>
    <span class="s1">pause: pause,</span>
    <span class="s1">paused: </span><span class="s3">false</span><span class="s1">,</span>

    <span class="s1">get concurrency () {</span>
      <span class="s3">return </span><span class="s1">_concurrency</span>
    <span class="s1">},</span>
    <span class="s1">set concurrency (value) {</span>
      <span class="s3">if </span><span class="s1">(!(value &gt;= </span><span class="s4">1</span><span class="s1">)) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'fastqueue concurrency must be equal to or greater than 1'</span><span class="s1">)</span>
      <span class="s1">}</span>
      <span class="s1">_concurrency = value</span>

      <span class="s3">if </span><span class="s1">(self.paused) </span><span class="s3">return</span>
      <span class="s3">for </span><span class="s1">(; queueHead &amp;&amp; _running &lt; _concurrency;) {</span>
        <span class="s1">_running++</span>
        <span class="s1">release()</span>
      <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">running: running,</span>
    <span class="s1">resume: resume,</span>
    <span class="s1">idle: idle,</span>
    <span class="s1">length: length,</span>
    <span class="s1">getQueue: getQueue,</span>
    <span class="s1">unshift: unshift,</span>
    <span class="s1">empty: noop,</span>
    <span class="s1">kill: kill,</span>
    <span class="s1">killAndDrain: killAndDrain,</span>
    <span class="s1">error: error</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">self</span>

  <span class="s3">function </span><span class="s1">running () {</span>
    <span class="s3">return </span><span class="s1">_running</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pause () {</span>
    <span class="s1">self.paused = </span><span class="s3">true</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">length () {</span>
    <span class="s3">var </span><span class="s1">current = queueHead</span>
    <span class="s3">var </span><span class="s1">counter = </span><span class="s4">0</span>

    <span class="s3">while </span><span class="s1">(current) {</span>
      <span class="s1">current = current.next</span>
      <span class="s1">counter++</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">counter</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getQueue () {</span>
    <span class="s3">var </span><span class="s1">current = queueHead</span>
    <span class="s3">var </span><span class="s1">tasks = []</span>

    <span class="s3">while </span><span class="s1">(current) {</span>
      <span class="s1">tasks.push(current.value)</span>
      <span class="s1">current = current.next</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">tasks</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">resume () {</span>
    <span class="s3">if </span><span class="s1">(!self.paused) </span><span class="s3">return</span>
    <span class="s1">self.paused = </span><span class="s3">false</span>
    <span class="s3">if </span><span class="s1">(queueHead === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">_running++</span>
      <span class="s1">release()</span>
      <span class="s3">return</span>
    <span class="s1">}</span>
    <span class="s3">for </span><span class="s1">(; queueHead &amp;&amp; _running &lt; _concurrency;) {</span>
      <span class="s1">_running++</span>
      <span class="s1">release()</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">idle () {</span>
    <span class="s3">return </span><span class="s1">_running === </span><span class="s4">0 </span><span class="s1">&amp;&amp; self.length() === </span><span class="s4">0</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">push (value, done) {</span>
    <span class="s3">var </span><span class="s1">current = cache.get()</span>

    <span class="s1">current.context = context</span>
    <span class="s1">current.release = release</span>
    <span class="s1">current.value = value</span>
    <span class="s1">current.callback = done || noop</span>
    <span class="s1">current.errorHandler = errorHandler</span>

    <span class="s3">if </span><span class="s1">(_running &gt;= _concurrency || self.paused) {</span>
      <span class="s3">if </span><span class="s1">(queueTail) {</span>
        <span class="s1">queueTail.next = current</span>
        <span class="s1">queueTail = current</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">queueHead = current</span>
        <span class="s1">queueTail = current</span>
        <span class="s1">self.saturated()</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">_running++</span>
      <span class="s1">worker.call(context, current.value, current.worked)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unshift (value, done) {</span>
    <span class="s3">var </span><span class="s1">current = cache.get()</span>

    <span class="s1">current.context = context</span>
    <span class="s1">current.release = release</span>
    <span class="s1">current.value = value</span>
    <span class="s1">current.callback = done || noop</span>
    <span class="s1">current.errorHandler = errorHandler</span>

    <span class="s3">if </span><span class="s1">(_running &gt;= _concurrency || self.paused) {</span>
      <span class="s3">if </span><span class="s1">(queueHead) {</span>
        <span class="s1">current.next = queueHead</span>
        <span class="s1">queueHead = current</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">queueHead = current</span>
        <span class="s1">queueTail = current</span>
        <span class="s1">self.saturated()</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">_running++</span>
      <span class="s1">worker.call(context, current.value, current.worked)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">release (holder) {</span>
    <span class="s3">if </span><span class="s1">(holder) {</span>
      <span class="s1">cache.release(holder)</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">next = queueHead</span>
    <span class="s3">if </span><span class="s1">(next &amp;&amp; _running &lt;= _concurrency) {</span>
      <span class="s3">if </span><span class="s1">(!self.paused) {</span>
        <span class="s3">if </span><span class="s1">(queueTail === queueHead) {</span>
          <span class="s1">queueTail = </span><span class="s3">null</span>
        <span class="s1">}</span>
        <span class="s1">queueHead = next.next</span>
        <span class="s1">next.next = </span><span class="s3">null</span>
        <span class="s1">worker.call(context, next.value, next.worked)</span>
        <span class="s3">if </span><span class="s1">(queueTail === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">self.empty()</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">_running--</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(--_running === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">self.drain()</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">kill () {</span>
    <span class="s1">queueHead = </span><span class="s3">null</span>
    <span class="s1">queueTail = </span><span class="s3">null</span>
    <span class="s1">self.drain = noop</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">killAndDrain () {</span>
    <span class="s1">queueHead = </span><span class="s3">null</span>
    <span class="s1">queueTail = </span><span class="s3">null</span>
    <span class="s1">self.drain()</span>
    <span class="s1">self.drain = noop</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">error (handler) {</span>
    <span class="s1">errorHandler = handler</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">noop () {}</span>

<span class="s3">function </span><span class="s1">Task () {</span>
  <span class="s3">this</span><span class="s1">.value = </span><span class="s3">null</span>
  <span class="s3">this</span><span class="s1">.callback = noop</span>
  <span class="s3">this</span><span class="s1">.next = </span><span class="s3">null</span>
  <span class="s3">this</span><span class="s1">.release = noop</span>
  <span class="s3">this</span><span class="s1">.context = </span><span class="s3">null</span>
  <span class="s3">this</span><span class="s1">.errorHandler = </span><span class="s3">null</span>

  <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span>

  <span class="s3">this</span><span class="s1">.worked = </span><span class="s3">function </span><span class="s1">worked (err, result) {</span>
    <span class="s3">var </span><span class="s1">callback = self.callback</span>
    <span class="s3">var </span><span class="s1">errorHandler = self.errorHandler</span>
    <span class="s3">var </span><span class="s1">val = self.value</span>
    <span class="s1">self.value = </span><span class="s3">null</span>
    <span class="s1">self.callback = noop</span>
    <span class="s3">if </span><span class="s1">(self.errorHandler) {</span>
      <span class="s1">errorHandler(err, val)</span>
    <span class="s1">}</span>
    <span class="s1">callback.call(self.context, err, result)</span>
    <span class="s1">self.release(self)</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">queueAsPromised (context, worker, _concurrency) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">context === </span><span class="s0">'function'</span><span class="s1">) {</span>
    <span class="s1">_concurrency = worker</span>
    <span class="s1">worker = context</span>
    <span class="s1">context = </span><span class="s3">null</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">asyncWrapper (arg, cb) {</span>
    <span class="s1">worker.call(</span><span class="s3">this</span><span class="s1">, arg)</span>
      <span class="s1">.then(</span><span class="s3">function </span><span class="s1">(res) {</span>
        <span class="s1">cb(</span><span class="s3">null</span><span class="s1">, res)</span>
      <span class="s1">}, cb)</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">queue = fastqueue(context, asyncWrapper, _concurrency)</span>

  <span class="s3">var </span><span class="s1">pushCb = queue.push</span>
  <span class="s3">var </span><span class="s1">unshiftCb = queue.unshift</span>

  <span class="s1">queue.push = push</span>
  <span class="s1">queue.unshift = unshift</span>
  <span class="s1">queue.drained = drained</span>

  <span class="s3">return </span><span class="s1">queue</span>

  <span class="s3">function </span><span class="s1">push (value) {</span>
    <span class="s3">var </span><span class="s1">p = </span><span class="s3">new </span><span class="s1">Promise(</span><span class="s3">function </span><span class="s1">(resolve, reject) {</span>
      <span class="s1">pushCb(value, </span><span class="s3">function </span><span class="s1">(err, result) {</span>
        <span class="s3">if </span><span class="s1">(err) {</span>
          <span class="s1">reject(err)</span>
          <span class="s3">return</span>
        <span class="s1">}</span>
        <span class="s1">resolve(result)</span>
      <span class="s1">})</span>
    <span class="s1">})</span>

    <span class="s2">// Let's fork the promise chain to</span>
    <span class="s2">// make the error bubble up to the user but</span>
    <span class="s2">// not lead to a unhandledRejection</span>
    <span class="s1">p.catch(noop)</span>

    <span class="s3">return </span><span class="s1">p</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unshift (value) {</span>
    <span class="s3">var </span><span class="s1">p = </span><span class="s3">new </span><span class="s1">Promise(</span><span class="s3">function </span><span class="s1">(resolve, reject) {</span>
      <span class="s1">unshiftCb(value, </span><span class="s3">function </span><span class="s1">(err, result) {</span>
        <span class="s3">if </span><span class="s1">(err) {</span>
          <span class="s1">reject(err)</span>
          <span class="s3">return</span>
        <span class="s1">}</span>
        <span class="s1">resolve(result)</span>
      <span class="s1">})</span>
    <span class="s1">})</span>

    <span class="s2">// Let's fork the promise chain to</span>
    <span class="s2">// make the error bubble up to the user but</span>
    <span class="s2">// not lead to a unhandledRejection</span>
    <span class="s1">p.catch(noop)</span>

    <span class="s3">return </span><span class="s1">p</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">drained () {</span>
    <span class="s3">var </span><span class="s1">p = </span><span class="s3">new </span><span class="s1">Promise(</span><span class="s3">function </span><span class="s1">(resolve) {</span>
      <span class="s1">process.nextTick(</span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">if </span><span class="s1">(queue.idle()) {</span>
          <span class="s1">resolve()</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">previousDrain = queue.drain</span>
          <span class="s1">queue.drain = </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">previousDrain === </span><span class="s0">'function'</span><span class="s1">) previousDrain()</span>
            <span class="s1">resolve()</span>
            <span class="s1">queue.drain = previousDrain</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">})</span>
    <span class="s1">})</span>

    <span class="s3">return </span><span class="s1">p</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">module.exports = fastqueue</span>
<span class="s1">module.exports.promise = queueAsPromised</span>
</pre>
</body>
</html>