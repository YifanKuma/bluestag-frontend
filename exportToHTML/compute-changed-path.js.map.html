<html>
<head>
<title>compute-changed-path.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compute-changed-path.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/compute-changed-path.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isGroupSegment,</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n\n</span><span class="s1">const removeLeadingSlash = (segment: string): string =&gt; {</span><span class="s3">\n  </span><span class="s1">return segment[0] === '/' ? segment.slice(1) : segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const segmentToPathname = (segment: Segment): string =&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">// 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page</span><span class="s3">\n    </span><span class="s1">// if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.</span><span class="s3">\n    </span><span class="s1">if (segment === 'children') return ''</span><span class="s3">\n\n    </span><span class="s1">return segment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment[1]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function normalizeSegments(segments: string[]): string {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">segments.reduce((acc, segment) =&gt; {</span><span class="s3">\n      </span><span class="s1">segment = removeLeadingSlash(segment)</span><span class="s3">\n      </span><span class="s1">if (segment === '' || isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return acc</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${acc}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '') || '/'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractPathFromFlightRouterState(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">const segment = Array.isArray(flightRouterState[0])</span><span class="s3">\n    </span><span class="s1">? flightRouterState[0][1]</span><span class="s3">\n    </span><span class="s1">: flightRouterState[0]</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">segment === DEFAULT_SEGMENT_KEY ||</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some((m) =&gt; segment.startsWith(m))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n\n  </span><span class="s1">if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''</span><span class="s3">\n\n  </span><span class="s1">const segments = [segmentToPathname(segment)]</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = flightRouterState[1] ?? {}</span><span class="s3">\n\n  </span><span class="s1">const childrenPath = parallelRoutes.children</span><span class="s3">\n    </span><span class="s1">? extractPathFromFlightRouterState(parallelRoutes.children)</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">if (childrenPath !== undefined) {</span><span class="s3">\n    </span><span class="s1">segments.push(childrenPath)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of Object.entries(parallelRoutes)) {</span><span class="s3">\n      </span><span class="s1">if (key === 'children') continue</span><span class="s3">\n\n      </span><span class="s1">const childPath = extractPathFromFlightRouterState(value)</span><span class="s3">\n\n      </span><span class="s1">if (childPath !== undefined) {</span><span class="s3">\n        </span><span class="s1">segments.push(childPath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalizeSegments(segments)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeChangedPathImpl(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const [segmentA, parallelRoutesA] = treeA</span><span class="s3">\n  </span><span class="s1">const [segmentB, parallelRoutesB] = treeB</span><span class="s3">\n\n  </span><span class="s1">const normalizedSegmentA = segmentToPathname(segmentA)</span><span class="s3">\n  </span><span class="s1">const normalizedSegmentB = segmentToPathname(segmentB)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some(</span><span class="s3">\n      </span><span class="s1">(m) =&gt;</span><span class="s3">\n        </span><span class="s1">normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!matchSegment(segmentA, segmentB)) {</span><span class="s3">\n    </span><span class="s1">// once we find where the tree changed, we compute the rest of the path by traversing the tree</span><span class="s3">\n    </span><span class="s1">return extractPathFromFlightRouterState(treeB) ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRouterKey in parallelRoutesA) {</span><span class="s3">\n    </span><span class="s1">if (parallelRoutesB[parallelRouterKey]) {</span><span class="s3">\n      </span><span class="s1">const changedPath = computeChangedPathImpl(</span><span class="s3">\n        </span><span class="s1">parallelRoutesA[parallelRouterKey],</span><span class="s3">\n        </span><span class="s1">parallelRoutesB[parallelRouterKey]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (changedPath !== null) {</span><span class="s3">\n        </span><span class="s1">return `${segmentToPathname(segmentB)}/${changedPath}`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function computeChangedPath(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const changedPath = computeChangedPathImpl(treeA, treeB)</span><span class="s3">\n\n  </span><span class="s1">if (changedPath == null || changedPath === '/') {</span><span class="s3">\n    </span><span class="s1">return changedPath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// lightweight normalization to remove route groups</span><span class="s3">\n  </span><span class="s1">return normalizeSegments(changedPath.split('/'))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively extracts dynamic parameters from FlightRouterState.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSelectedParams(</span><span class="s3">\n  </span><span class="s1">currentTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">params: Params = {}</span><span class="s3">\n</span><span class="s1">): Params {</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = currentTree[1]</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRoute of Object.values(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">const segment = parallelRoute[0]</span><span class="s3">\n    </span><span class="s1">const isDynamicParameter = Array.isArray(segment)</span><span class="s3">\n    </span><span class="s1">const segmentValue = isDynamicParameter ? segment[1] : segment</span><span class="s3">\n    </span><span class="s1">if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue</span><span class="s3">\n\n    </span><span class="s1">// Ensure catchAll and optional catchall are turned into an array</span><span class="s3">\n    </span><span class="s1">const isCatchAll =</span><span class="s3">\n      </span><span class="s1">isDynamicParameter &amp;&amp; (segment[2] === 'c' || segment[2] === 'oc')</span><span class="s3">\n\n    </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1].split('/')</span><span class="s3">\n    </span><span class="s1">} else if (isDynamicParameter) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">params = getSelectedParams(parallelRoute, params)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;computeChangedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;extractPathFromFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;removeLeadingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentToPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;acc&quot;</span><span class="s0">,</span><span class="s1">&quot;isGroupSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_ROUTE_MARKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;childrenPath&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;childPath&quot;</span><span class="s0">,</span><span class="s1">&quot;computeChangedPathImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;treeA&quot;</span><span class="s0">,</span><span class="s1">&quot;treeB&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentA&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutesA&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentB&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutesB&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedSegmentA&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedSegmentB&quot;</span><span class="s0">,</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouterKey&quot;</span><span class="s0">,</span><span class="s1">&quot;changedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isCatchAll&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;IAwHgBA,kBAAkB;eAAlBA;;IA9EAC,gCAAgC;eAAhCA;;IA+FAC,iBAAiB;eAAjBA;;;oCArI2B;yBAMpC;+BACsB;AAE7B,MAAMC,qBAAqB,CAACC;IAC1B,OAAOA,OAAO,CAAC,EAAE,KAAK,MAAMA,QAAQC,KAAK,CAAC,KAAKD;AACjD;AAEA,MAAME,oBAAoB,CAACF;IACzB,IAAI,OAAOA,YAAY,UAAU;QAC/B,uHAAuH;QACvH,gHAAgH;QAChH,IAAIA,YAAY,YAAY,OAAO;QAEnC,OAAOA;IACT;IAEA,OAAOA,OAAO,CAAC,EAAE;AACnB;AAEA,SAASG,kBAAkBC,QAAkB;IAC3C,OACEA,SAASC,MAAM,CAAC,CAACC,KAAKN;QACpBA,UAAUD,mBAAmBC;QAC7B,IAAIA,YAAY,MAAMO,IAAAA,uBAAc,EAACP,UAAU;YAC7C,OAAOM;QACT;QAEA,OAAO,AAAGA,MAAI,MAAGN;IACnB,GAAG,OAAO;AAEd;AAEO,SAASH,iCACdW,iBAAoC;IAEpC,MAAMR,UAAUS,MAAMC,OAAO,CAACF,iBAAiB,CAAC,EAAE,IAC9CA,iBAAiB,CAAC,EAAE,CAAC,EAAE,GACvBA,iBAAiB,CAAC,EAAE;IAExB,IACER,YAAYW,4BAAmB,IAC/BC,8CAA0B,CAACC,IAAI,CAAC,CAACC,IAAMd,QAAQe,UAAU,CAACD,KAE1D,OAAOE;IAET,IAAIhB,QAAQe,UAAU,CAACE,yBAAgB,GAAG,OAAO;IAEjD,MAAMb,WAAW;QAACF,kBAAkBF;KAAS;QACtBQ;IAAvB,MAAMU,iBAAiBV,CAAAA,sBAAAA,iBAAiB,CAAC,EAAE,YAApBA,sBAAwB,CAAC;IAEhD,MAAMW,eAAeD,eAAeE,QAAQ,GACxCvB,iCAAiCqB,eAAeE,QAAQ,IACxDJ;IAEJ,IAAIG,iBAAiBH,WAAW;QAC9BZ,SAASiB,IAAI,CAACF;IAChB,OAAO;QACL,KAAK,MAAM,CAACG,KAAKC,MAAM,IAAIC,OAAOC,OAAO,CAACP,gBAAiB;YACzD,IAAII,QAAQ,YAAY;YAExB,MAAMI,YAAY7B,iCAAiC0B;YAEnD,IAAIG,cAAcV,WAAW;gBAC3BZ,SAASiB,IAAI,CAACK;YAChB;QACF;IACF;IAEA,OAAOvB,kBAAkBC;AAC3B;AAEA,SAASuB,uBACPC,KAAwB,EACxBC,KAAwB;IAExB,MAAM,CAACC,UAAUC,gBAAgB,GAAGH;IACpC,MAAM,CAACI,UAAUC,gBAAgB,GAAGJ;IAEpC,MAAMK,qBAAqBhC,kBAAkB4B;IAC7C,MAAMK,qBAAqBjC,kBAAkB8B;IAE7C,IACEpB,8CAA0B,CAACC,IAAI,CAC7B,CAACC,IACCoB,mBAAmBnB,UAAU,CAACD,MAAMqB,mBAAmBpB,UAAU,CAACD,KAEtE;QACA,OAAO;IACT;IAEA,IAAI,CAACsB,IAAAA,2BAAY,EAACN,UAAUE,WAAW;YAE9BnC;QADP,8FAA8F;QAC9F,OAAOA,CAAAA,oCAAAA,iCAAiCgC,kBAAjChC,oCAA2C;IACpD;IAEA,IAAK,MAAMwC,qBAAqBN,gBAAiB;QAC/C,IAAIE,eAAe,CAACI,kBAAkB,EAAE;YACtC,MAAMC,cAAcX,uBAClBI,eAAe,CAACM,kBAAkB,EAClCJ,eAAe,CAACI,kBAAkB;YAEpC,IAAIC,gBAAgB,MAAM;gBACxB,OAAO,AAAGpC,kBAAkB8B,YAAU,MAAGM;YAC3C;QACF;IACF;IAEA,OAAO;AACT;AAEO,SAAS1C,mBACdgC,KAAwB,EACxBC,KAAwB;IAExB,MAAMS,cAAcX,uBAAuBC,OAAOC;IAElD,IAAIS,eAAe,QAAQA,gBAAgB,KAAK;QAC9C,OAAOA;IACT;IAEA,mDAAmD;IACnD,OAAOnC,kBAAkBmC,YAAYC,KAAK,CAAC;AAC7C;AAKO,SAASzC,kBACd0C,WAA8B,EAC9BC,MAAmB;IAAnBA,IAAAA,mBAAAA,SAAiB,CAAC;IAElB,MAAMvB,iBAAiBsB,WAAW,CAAC,EAAE;IAErC,KAAK,MAAME,iBAAiBlB,OAAOmB,MAAM,CAACzB,gBAAiB;QACzD,MAAMlB,UAAU0C,aAAa,CAAC,EAAE;QAChC,MAAME,qBAAqBnC,MAAMC,OAAO,CAACV;QACzC,MAAM6C,eAAeD,qBAAqB5C,OAAO,CAAC,EAAE,GAAGA;QACvD,IAAI,CAAC6C,gBAAgBA,aAAa9B,UAAU,CAACE,yBAAgB,GAAG;QAEhE,iEAAiE;QACjE,MAAM6B,aACJF,sBAAuB5C,CAAAA,OAAO,CAAC,EAAE,KAAK,OAAOA,OAAO,CAAC,EAAE,KAAK,IAAG;QAEjE,IAAI8C,YAAY;YACdL,MAAM,CAACzC,OAAO,CAAC,EAAE,CAAC,GAAGA,OAAO,CAAC,EAAE,CAACuC,KAAK,CAAC;QACxC,OAAO,IAAIK,oBAAoB;YAC7BH,MAAM,CAACzC,OAAO,CAAC,EAAE,CAAC,GAAGA,OAAO,CAAC,EAAE;QACjC;QAEAyC,SAAS3C,kBAAkB4C,eAAeD;IAC5C;IAEA,OAAOA;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>