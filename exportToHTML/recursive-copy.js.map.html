<html>
<head>
<title>recursive-copy.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
recursive-copy.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/lib/recursive-copy.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import path from 'path'</span><span class="s3">\n</span><span class="s1">import type { Dirent, Stats } from 'fs'</span><span class="s3">\n</span><span class="s1">import { promises, constants } from 'fs'</span><span class="s3">\n</span><span class="s1">import { Sema } from 'next/dist/compiled/async-sema'</span><span class="s3">\n</span><span class="s1">import isError from './is-error'</span><span class="s3">\n\n</span><span class="s1">const COPYFILE_EXCL = constants.COPYFILE_EXCL</span><span class="s3">\n\n</span><span class="s1">export async function recursiveCopy(</span><span class="s3">\n  </span><span class="s1">source: string,</span><span class="s3">\n  </span><span class="s1">dest: string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">concurrency = 32,</span><span class="s3">\n    </span><span class="s1">overwrite = false,</span><span class="s3">\n    </span><span class="s1">filter = () =&gt; true,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">concurrency?: number</span><span class="s3">\n    </span><span class="s1">overwrite?: boolean</span><span class="s3">\n    </span><span class="s1">filter?(filePath: string): boolean</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">const cwdPath = process.cwd()</span><span class="s3">\n  </span><span class="s1">const from = path.resolve(cwdPath, source)</span><span class="s3">\n  </span><span class="s1">const to = path.resolve(cwdPath, dest)</span><span class="s3">\n\n  </span><span class="s1">const sema = new Sema(concurrency)</span><span class="s3">\n\n  </span><span class="s1">// deep copy the file/directory</span><span class="s3">\n  </span><span class="s1">async function _copy(item: string, lstats?: Stats | Dirent): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">const target = item.replace(from, to)</span><span class="s3">\n\n    </span><span class="s1">await sema.acquire()</span><span class="s3">\n\n    </span><span class="s1">if (!lstats) {</span><span class="s3">\n      </span><span class="s1">// after lock on first run</span><span class="s3">\n      </span><span class="s1">lstats = await promises.lstat(from)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// readdir &amp; lstat do not follow symbolic links</span><span class="s3">\n    </span><span class="s1">// if part is a symbolic link, follow it with stat</span><span class="s3">\n    </span><span class="s1">let isFile = lstats.isFile()</span><span class="s3">\n    </span><span class="s1">let isDirectory = lstats.isDirectory()</span><span class="s3">\n    </span><span class="s1">if (lstats.isSymbolicLink()) {</span><span class="s3">\n      </span><span class="s1">const stats = await promises.stat(item)</span><span class="s3">\n      </span><span class="s1">isFile = stats.isFile()</span><span class="s3">\n      </span><span class="s1">isDirectory = stats.isDirectory()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isDirectory) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">await promises.mkdir(target, { recursive: true })</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">// do not throw `folder already exists` errors</span><span class="s3">\n        </span><span class="s1">if (isError(err) &amp;&amp; err.code !== 'EEXIST') {</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">sema.release()</span><span class="s3">\n      </span><span class="s1">const files = await promises.readdir(item, { withFileTypes: true })</span><span class="s3">\n      </span><span class="s1">await Promise.all(</span><span class="s3">\n        </span><span class="s1">files.map((file) =&gt; _copy(path.join(item, file.name), file))</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">isFile &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// before we send the path to filter</span><span class="s3">\n      </span><span class="s1">// we remove the base path (from) and replace </span><span class="s3">\\ </span><span class="s1">by / (windows)</span><span class="s3">\n      </span><span class="s1">filter(item.replace(from, '').replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/'))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">await promises</span><span class="s3">\n        </span><span class="s1">.copyFile(item, target, overwrite ? undefined : COPYFILE_EXCL)</span><span class="s3">\n        </span><span class="s1">.catch((err) =&gt; {</span><span class="s3">\n          </span><span class="s1">// if overwrite is false we shouldn't fail on EEXIST</span><span class="s3">\n          </span><span class="s1">if (err.code !== 'EEXIST') {</span><span class="s3">\n            </span><span class="s1">throw err</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">sema.release()</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">sema.release()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">await _copy(from)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;recursiveCopy&quot;</span><span class="s0">,</span><span class="s1">&quot;COPYFILE_EXCL&quot;</span><span class="s0">,</span><span class="s1">&quot;constants&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;dest&quot;</span><span class="s0">,</span><span class="s1">&quot;concurrency&quot;</span><span class="s0">,</span><span class="s1">&quot;overwrite&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;cwdPath&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;cwd&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;to&quot;</span><span class="s0">,</span><span class="s1">&quot;sema&quot;</span><span class="s0">,</span><span class="s1">&quot;Sema&quot;</span><span class="s0">,</span><span class="s1">&quot;_copy&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;lstats&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;acquire&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;lstat&quot;</span><span class="s0">,</span><span class="s1">&quot;isFile&quot;</span><span class="s0">,</span><span class="s1">&quot;isDirectory&quot;</span><span class="s0">,</span><span class="s1">&quot;isSymbolicLink&quot;</span><span class="s0">,</span><span class="s1">&quot;stats&quot;</span><span class="s0">,</span><span class="s1">&quot;stat&quot;</span><span class="s0">,</span><span class="s1">&quot;mkdir&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;release&quot;</span><span class="s0">,</span><span class="s1">&quot;files&quot;</span><span class="s0">,</span><span class="s1">&quot;readdir&quot;</span><span class="s0">,</span><span class="s1">&quot;withFileTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;copyFile&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAQsBA;;;eAAAA;;;6DARL;oBAEmB;2BACf;gEACD;;;;;;AAEpB,MAAMC,gBAAgBC,aAAS,CAACD,aAAa;AAEtC,eAAeD,cACpBG,MAAc,EACdC,IAAY,EACZ,EACEC,cAAc,EAAE,EAChBC,YAAY,KAAK,EACjBC,SAAS,IAAM,IAAI,EAKpB,GAAG,CAAC,CAAC;IAEN,MAAMC,UAAUC,QAAQC,GAAG;IAC3B,MAAMC,OAAOC,aAAI,CAACC,OAAO,CAACL,SAASL;IACnC,MAAMW,KAAKF,aAAI,CAACC,OAAO,CAACL,SAASJ;IAEjC,MAAMW,OAAO,IAAIC,eAAI,CAACX;IAEtB,+BAA+B;IAC/B,eAAeY,MAAMC,IAAY,EAAEC,MAAuB;QACxD,MAAMC,SAASF,KAAKG,OAAO,CAACV,MAAMG;QAElC,MAAMC,KAAKO,OAAO;QAElB,IAAI,CAACH,QAAQ;YACX,0BAA0B;YAC1BA,SAAS,MAAMI,YAAQ,CAACC,KAAK,CAACb;QAChC;QAEA,+CAA+C;QAC/C,kDAAkD;QAClD,IAAIc,SAASN,OAAOM,MAAM;QAC1B,IAAIC,cAAcP,OAAOO,WAAW;QACpC,IAAIP,OAAOQ,cAAc,IAAI;YAC3B,MAAMC,QAAQ,MAAML,YAAQ,CAACM,IAAI,CAACX;YAClCO,SAASG,MAAMH,MAAM;YACrBC,cAAcE,MAAMF,WAAW;QACjC;QAEA,IAAIA,aAAa;YACf,IAAI;gBACF,MAAMH,YAAQ,CAACO,KAAK,CAACV,QAAQ;oBAAEW,WAAW;gBAAK;YACjD,EAAE,OAAOC,KAAK;gBACZ,8CAA8C;gBAC9C,IAAIC,IAAAA,gBAAO,EAACD,QAAQA,IAAIE,IAAI,KAAK,UAAU;oBACzC,MAAMF;gBACR;YACF;YACAjB,KAAKoB,OAAO;YACZ,MAAMC,QAAQ,MAAMb,YAAQ,CAACc,OAAO,CAACnB,MAAM;gBAAEoB,eAAe;YAAK;YACjE,MAAMC,QAAQC,GAAG,CACfJ,MAAMK,GAAG,CAAC,CAACC,OAASzB,MAAML,aAAI,CAAC+B,IAAI,CAACzB,MAAMwB,KAAKE,IAAI,GAAGF;QAE1D,OAAO,IACLjB,UACA,oCAAoC;QACpC,8DAA8D;QAC9DlB,OAAOW,KAAKG,OAAO,CAACV,MAAM,IAAIU,OAAO,CAAC,OAAO,OAC7C;YACA,MAAME,YAAQ,CACXsB,QAAQ,CAAC3B,MAAME,QAAQd,YAAYwC,YAAY7C,eAC/C8C,KAAK,CAAC,CAACf;gBACN,oDAAoD;gBACpD,IAAIA,IAAIE,IAAI,KAAK,UAAU;oBACzB,MAAMF;gBACR;YACF;YACFjB,KAAKoB,OAAO;QACd,OAAO;YACLpB,KAAKoB,OAAO;QACd;IACF;IAEA,MAAMlB,MAAMN;AACd&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>