<html>
<head>
<title>fill-lazy-items-till-leaf-with-head.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fill-lazy-items-till-leaf-with-head.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PrefetchCacheEntryStatus,</span><span class="s3">\n  </span><span class="s1">type PrefetchCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './router-reducer-types'</span><span class="s3">\n\n</span><span class="s1">export function fillLazyItemsTillLeafWithHead(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode | undefined,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">cacheNodeSeedData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">head: React.ReactNode,</span><span class="s3">\n  </span><span class="s1">prefetchEntry: PrefetchCacheEntry | undefined</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const isLastSegment = Object.keys(routerState[1]).length === 0</span><span class="s3">\n  </span><span class="s1">if (isLastSegment) {</span><span class="s3">\n    </span><span class="s1">newCache.head = head</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Remove segment that we got data for so that it is filled in during rendering of rsc.</span><span class="s3">\n  </span><span class="s1">for (const key in routerState[1]) {</span><span class="s3">\n    </span><span class="s1">const parallelRouteState = routerState[1][key]</span><span class="s3">\n    </span><span class="s1">const segmentForParallelRoute = parallelRouteState[0]</span><span class="s3">\n    </span><span class="s1">const cacheKey = createRouterCacheKey(segmentForParallelRoute)</span><span class="s3">\n\n    </span><span class="s1">// TODO: We should traverse the cacheNodeSeedData tree instead of the router</span><span class="s3">\n    </span><span class="s1">// state tree. Ideally, they would always be the same shape, but because of</span><span class="s3">\n    </span><span class="s1">// the loading.js pattern, cacheNodeSeedData sometimes only represents a</span><span class="s3">\n    </span><span class="s1">// partial tree. That's why this node is sometimes null. Once PPR lands,</span><span class="s3">\n    </span><span class="s1">// loading.js will no longer have special behavior and we can traverse the</span><span class="s3">\n    </span><span class="s1">// data tree instead.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// We should also consider merging the router state tree and the data tree</span><span class="s3">\n    </span><span class="s1">// in the response format, so that we don't have to send the keys twice.</span><span class="s3">\n    </span><span class="s1">// Then the client can convert them into separate representations.</span><span class="s3">\n    </span><span class="s1">const parallelSeedData =</span><span class="s3">\n      </span><span class="s1">cacheNodeSeedData !== null &amp;&amp; cacheNodeSeedData[2][key] !== undefined</span><span class="s3">\n        </span><span class="s1">? cacheNodeSeedData[2][key]</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n    </span><span class="s1">if (existingCache) {</span><span class="s3">\n      </span><span class="s1">const existingParallelRoutesCacheNode =</span><span class="s3">\n        </span><span class="s1">existingCache.parallelRoutes.get(key)</span><span class="s3">\n      </span><span class="s1">if (existingParallelRoutesCacheNode) {</span><span class="s3">\n        </span><span class="s1">const hasReusablePrefetch =</span><span class="s3">\n          </span><span class="s1">prefetchEntry?.kind === 'auto' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">prefetchEntry.status === PrefetchCacheEntryStatus.reusable</span><span class="s3">\n\n        </span><span class="s1">let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)</span><span class="s3">\n        </span><span class="s1">const existingCacheNode = parallelRouteCacheNode.get(cacheKey)</span><span class="s3">\n        </span><span class="s1">let newCacheNode: CacheNode</span><span class="s3">\n        </span><span class="s1">if (parallelSeedData !== null) {</span><span class="s3">\n          </span><span class="s1">// New data was sent from the server.</span><span class="s3">\n          </span><span class="s1">const seedNode = parallelSeedData[1]</span><span class="s3">\n          </span><span class="s1">const loading = parallelSeedData[3]</span><span class="s3">\n          </span><span class="s1">newCacheNode = {</span><span class="s3">\n            </span><span class="s1">lazyData: null,</span><span class="s3">\n            </span><span class="s1">rsc: seedNode,</span><span class="s3">\n            </span><span class="s1">// This is a PPR-only field. When PPR is enabled, we shouldn't hit</span><span class="s3">\n            </span><span class="s1">// this path during a navigation, but until PPR is fully implemented</span><span class="s3">\n            </span><span class="s1">// yet it's possible the existing node does have a non-null</span><span class="s3">\n            </span><span class="s1">// `prefetchRsc`. As an incremental step, we'll just de-opt to the</span><span class="s3">\n            </span><span class="s1">// old behavior â€” no PPR value.</span><span class="s3">\n            </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n            </span><span class="s1">head: null,</span><span class="s3">\n            </span><span class="s1">prefetchHead: null,</span><span class="s3">\n            </span><span class="s1">loading,</span><span class="s3">\n            </span><span class="s1">parallelRoutes: new Map(existingCacheNode?.parallelRoutes),</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (hasReusablePrefetch &amp;&amp; existingCacheNode) {</span><span class="s3">\n          </span><span class="s1">// No new data was sent from the server, but the existing cache node</span><span class="s3">\n          </span><span class="s1">// was prefetched, so we should reuse that.</span><span class="s3">\n          </span><span class="s1">newCacheNode = {</span><span class="s3">\n            </span><span class="s1">lazyData: existingCacheNode.lazyData,</span><span class="s3">\n            </span><span class="s1">rsc: existingCacheNode.rsc,</span><span class="s3">\n            </span><span class="s1">// This is a PPR-only field. Unlike the previous branch, since we're</span><span class="s3">\n            </span><span class="s1">// just cloning the existing cache node, we might as well keep the</span><span class="s3">\n            </span><span class="s1">// PPR value, if it exists.</span><span class="s3">\n            </span><span class="s1">prefetchRsc: existingCacheNode.prefetchRsc,</span><span class="s3">\n            </span><span class="s1">head: existingCacheNode.head,</span><span class="s3">\n            </span><span class="s1">prefetchHead: existingCacheNode.prefetchHead,</span><span class="s3">\n            </span><span class="s1">parallelRoutes: new Map(existingCacheNode.parallelRoutes),</span><span class="s3">\n            </span><span class="s1">loading: existingCacheNode.loading,</span><span class="s3">\n          </span><span class="s1">} as CacheNode</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// No data available for this node. This will trigger a lazy fetch</span><span class="s3">\n          </span><span class="s1">// during render.</span><span class="s3">\n          </span><span class="s1">newCacheNode = {</span><span class="s3">\n            </span><span class="s1">lazyData: null,</span><span class="s3">\n            </span><span class="s1">rsc: null,</span><span class="s3">\n            </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n            </span><span class="s1">head: null,</span><span class="s3">\n            </span><span class="s1">prefetchHead: null,</span><span class="s3">\n            </span><span class="s1">parallelRoutes: new Map(existingCacheNode?.parallelRoutes),</span><span class="s3">\n            </span><span class="s1">loading: null,</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Overrides the cache key with the new cache node.</span><span class="s3">\n        </span><span class="s1">parallelRouteCacheNode.set(cacheKey, newCacheNode)</span><span class="s3">\n        </span><span class="s1">// Traverse deeper to apply the head / fill lazy items till the head.</span><span class="s3">\n        </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">newCacheNode,</span><span class="s3">\n          </span><span class="s1">existingCacheNode,</span><span class="s3">\n          </span><span class="s1">parallelRouteState,</span><span class="s3">\n          </span><span class="s1">parallelSeedData ? parallelSeedData : null,</span><span class="s3">\n          </span><span class="s1">head,</span><span class="s3">\n          </span><span class="s1">prefetchEntry</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">newCache.parallelRoutes.set(key, parallelRouteCacheNode)</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let newCacheNode: CacheNode</span><span class="s3">\n    </span><span class="s1">if (parallelSeedData !== null) {</span><span class="s3">\n      </span><span class="s1">// New data was sent from the server.</span><span class="s3">\n      </span><span class="s1">const seedNode = parallelSeedData[1]</span><span class="s3">\n      </span><span class="s1">const loading = parallelSeedData[3]</span><span class="s3">\n      </span><span class="s1">newCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: seedNode,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading,</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// No data available for this node. This will trigger a lazy fetch</span><span class="s3">\n      </span><span class="s1">// during render.</span><span class="s3">\n      </span><span class="s1">newCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: null,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading: null,</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const existingParallelRoutes = newCache.parallelRoutes.get(key)</span><span class="s3">\n    </span><span class="s1">if (existingParallelRoutes) {</span><span class="s3">\n      </span><span class="s1">existingParallelRoutes.set(cacheKey, newCacheNode)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">newCacheNode,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">parallelRouteState,</span><span class="s3">\n      </span><span class="s1">parallelSeedData,</span><span class="s3">\n      </span><span class="s1">head,</span><span class="s3">\n      </span><span class="s1">prefetchEntry</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;routerState&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteState&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentForParallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;existingParallelRoutesCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;hasReusablePrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchCacheEntryStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;reusable&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;seedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;existingParallelRoutes&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>