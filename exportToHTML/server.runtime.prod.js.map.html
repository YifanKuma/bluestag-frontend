<html>
<head>
<title>server.runtime.prod.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
server.runtime.prod.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;server.runtime.prod.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://next/../../node_modules/.pnpm/react@19.2.0-canary-0bdb9206-20250818/node_modules/react/cjs/react.production.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/../../node_modules/.pnpm/react@19.2.0-canary-0bdb9206-20250818/node_modules/react/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/../next-env/dist/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/@edge-runtime/cookies/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/cookie/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/fresh/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/p-queue/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/path-to-regexp/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/node-environment-baseline.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/node-polyfill-crypto.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/isomorphic/path.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/modern-browserslist-target.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/superstruct/index.cjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/compat_get_default_export&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/define_property_getters&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/has_own_property&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/make_namespace_object&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/node-environment-extensions/web-crypto.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/source-maps.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/picocolors.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/lru-cache.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/parse-stack.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/is-internal.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/patch-error-inspect.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/node-environment-extensions/error-inspect.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/next-devtools/server/shared.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/dynamic-rendering-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/invariant-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/dynamic-rendering.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/node-environment-extensions/utils.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/node-environment-extensions/random.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/node-environment-extensions/date.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/node-environment-extensions/node-crypto.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/require-hook.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/route-pattern-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-match-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/request-meta.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/find-pages-dir.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/reflect.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/headers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/redirect-status-code.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/get-cookie-parser.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/base-http/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/base-http/node.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/send-payload.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/cache-control.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/etag.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/querystring.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-relative-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/build/output/log.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/is-ipv6.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/ensure-leading-slash.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/app-paths.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/segment.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/interception-routes.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/is-dynamic.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/html-bots.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/is-bot.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/stream-utils/node-web-streams-helper.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/stream-utils/encoded-tags.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/remove-trailing-slash.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-path-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-path-suffix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/path-has-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/get-hostname.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/i18n/normalize-locale-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/remove-path-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/get-next-pathname-info.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/next-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/i18n/detect-domain-locale.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/format-next-pathname-info.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-locale.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/request.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/next-request.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/detached-promise.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/trace/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/client-component-renderer-logger.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/pipe-readable.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/render-result.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-path-sep.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/denormalize-page-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/path-match.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/escape-regexp.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/get-dynamic-param.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-regex.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/prepare-destination.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/decode-query-path-parameter.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/format-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/types.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/app-router-headers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/generate-interception-routes-rewrites.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/server-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/is-plain-object.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/locale-route-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/sorted-routes.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matchers/route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matchers/locale-route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matcher-managers/default-route-matcher-manager.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/normalizers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/prefixing-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-page-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/underscore-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/built/app/app-bundle-path-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/built/app/app-filename-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-app-route-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/metadata/is-metadata-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/wrap-normalizer-fn.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/built/app/app-pathname-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/built/app/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-kind.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matchers/app-page-route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matcher-providers/helpers/cached-route-matcher-provider.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matcher-providers/manifest-route-matcher-provider.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matcher-providers/app-page-route-matcher-provider.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-app-page-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matchers/app-route-route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matcher-providers/app-route-route-matcher-provider.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-api-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matchers/pages-api-route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/built/pages/pages-bundle-path-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/built/pages/pages-filename-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/built/pages/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matcher-providers/pages-api-route-matcher-provider.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matchers/pages-route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matcher-providers/pages-route-matcher-provider.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matcher-providers/helpers/manifest-loaders/server-manifest-loader.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/i18n-provider.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/send-response.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/match-next-data-pathname.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/request/suffix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/request/rsc.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/request/prefetch-rsc.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/request/prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/request/next-data.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/to-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/async-local-storage.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/after/builtin-request-context.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/fetch-event.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/response.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/request-cookies.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/use-cache/handlers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/adapter.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/normalizers/request/segment-prefix-rsc.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/base-server.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/strip-flight-headers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/get-route-from-asset-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/format-hostname.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/experimental/ppr.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/patch-set-header.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/fix-mojibake.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/router-reducer/compute-changed-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/parse-and-validate-flight-router-state.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/streaming-metadata.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/fallback.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/server-action-request-meta.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/checks.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/require.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/interop-default.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/wait.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/encryption-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/load-components.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/action-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/middleware-route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/batcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/scheduler.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/types.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/multi-file-writer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/incremental-cache/file-system-cache.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/incremental-cache/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/node-fs-methods.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/mock-request.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/format-dynamic-import-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/async-callback-set.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/router-utils/is-postpone.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/module-loader/node-module-loader.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/router-utils/router-server-context.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/next-server.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-matches/pages-api-route-match.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/setup-http-agent-env.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/static-env.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/body-streams.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* @license React</span><span class="s3">\n </span><span class="s1">* react.production.js</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Copyright (c) Meta Platforms, Inc. and affiliates.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This source code is licensed under the MIT license found in the</span><span class="s3">\n </span><span class="s1">* LICENSE file in the root directory of this source tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var REACT_ELEMENT_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.transitional.element</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_PORTAL_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.portal</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_FRAGMENT_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.fragment</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_STRICT_MODE_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.strict_mode</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_PROFILER_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.profiler</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_CONSUMER_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.consumer</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_CONTEXT_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.context</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_FORWARD_REF_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.forward_ref</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_SUSPENSE_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.suspense</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_MEMO_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.memo</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_LAZY_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.lazy</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span><span class="s3">\n</span><span class="s1">function getIteratorFn(maybeIterable) {</span><span class="s3">\n  </span><span class="s1">if (null === maybeIterable || </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">!== typeof maybeIterable) return null;</span><span class="s3">\n  </span><span class="s1">maybeIterable =</span><span class="s3">\n    </span><span class="s1">(MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span><span class="s3">\n    </span><span class="s1">maybeIterable[</span><span class="s3">\&quot;</span><span class="s1">@@iterator</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof maybeIterable ? maybeIterable : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var ReactNoopUpdateQueue = {</span><span class="s3">\n    </span><span class="s1">isMounted: function () {</span><span class="s3">\n      </span><span class="s1">return !1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">enqueueForceUpdate: function () {},</span><span class="s3">\n    </span><span class="s1">enqueueReplaceState: function () {},</span><span class="s3">\n    </span><span class="s1">enqueueSetState: function () {}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">assign = Object.assign,</span><span class="s3">\n  </span><span class="s1">emptyObject = {};</span><span class="s3">\n</span><span class="s1">function Component(props, context, updater) {</span><span class="s3">\n  </span><span class="s1">this.props = props;</span><span class="s3">\n  </span><span class="s1">this.context = context;</span><span class="s3">\n  </span><span class="s1">this.refs = emptyObject;</span><span class="s3">\n  </span><span class="s1">this.updater = updater || ReactNoopUpdateQueue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Component.prototype.isReactComponent = {};</span><span class="s3">\n</span><span class="s1">Component.prototype.setState = function (partialState, callback) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">!== typeof partialState &amp;&amp;</span><span class="s3">\n    \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">!== typeof partialState &amp;&amp;</span><span class="s3">\n    </span><span class="s1">null != partialState</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">throw Error(</span><span class="s3">\n      \&quot;</span><span class="s1">takes an object of state variables to update or a function which returns an object of state variables.</span><span class="s3">\&quot;\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.updater.enqueueSetState(this, partialState, callback, </span><span class="s3">\&quot;</span><span class="s1">setState</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">Component.prototype.forceUpdate = function (callback) {</span><span class="s3">\n  </span><span class="s1">this.updater.enqueueForceUpdate(this, callback, </span><span class="s3">\&quot;</span><span class="s1">forceUpdate</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function ComponentDummy() {}</span><span class="s3">\n</span><span class="s1">ComponentDummy.prototype = Component.prototype;</span><span class="s3">\n</span><span class="s1">function PureComponent(props, context, updater) {</span><span class="s3">\n  </span><span class="s1">this.props = props;</span><span class="s3">\n  </span><span class="s1">this.context = context;</span><span class="s3">\n  </span><span class="s1">this.refs = emptyObject;</span><span class="s3">\n  </span><span class="s1">this.updater = updater || ReactNoopUpdateQueue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());</span><span class="s3">\n</span><span class="s1">pureComponentPrototype.constructor = PureComponent;</span><span class="s3">\n</span><span class="s1">assign(pureComponentPrototype, Component.prototype);</span><span class="s3">\n</span><span class="s1">pureComponentPrototype.isPureReactComponent = !0;</span><span class="s3">\n</span><span class="s1">var isArrayImpl = Array.isArray;</span><span class="s3">\n</span><span class="s1">function noop() {}</span><span class="s3">\n</span><span class="s1">var ReactSharedInternals = { H: null, A: null, T: null, S: null },</span><span class="s3">\n  </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty;</span><span class="s3">\n</span><span class="s1">function ReactElement(type, key, props) {</span><span class="s3">\n  </span><span class="s1">var refProp = props.ref;</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_ELEMENT_TYPE,</span><span class="s3">\n    </span><span class="s1">type: type,</span><span class="s3">\n    </span><span class="s1">key: key,</span><span class="s3">\n    </span><span class="s1">ref: void 0 !== refProp ? refProp : null,</span><span class="s3">\n    </span><span class="s1">props: props</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cloneAndReplaceKey(oldElement, newKey) {</span><span class="s3">\n  </span><span class="s1">return ReactElement(oldElement.type, newKey, oldElement.props);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isValidElement(object) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof object &amp;&amp;</span><span class="s3">\n    </span><span class="s1">null !== object &amp;&amp;</span><span class="s3">\n    </span><span class="s1">object.$$typeof === REACT_ELEMENT_TYPE</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function escape(key) {</span><span class="s3">\n  </span><span class="s1">var escaperLookup = { </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">=0</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">=2</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    \&quot;</span><span class="s1">$</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    </span><span class="s1">key.replace(/[=:]/g, function (match) {</span><span class="s3">\n      </span><span class="s1">return escaperLookup[match];</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var userProvidedKeyEscapeRegex = /</span><span class="s3">\\</span><span class="s1">/+/g;</span><span class="s3">\n</span><span class="s1">function getElementKey(element, index) {</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof element &amp;&amp; null !== element &amp;&amp; null != element.key</span><span class="s3">\n    </span><span class="s1">? escape(</span><span class="s3">\&quot;\&quot; </span><span class="s1">+ element.key)</span><span class="s3">\n    </span><span class="s1">: index.toString(36);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveThenable(thenable) {</span><span class="s3">\n  </span><span class="s1">switch (thenable.status) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">fulfilled</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return thenable.value;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">rejected</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">throw thenable.reason;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">switch (</span><span class="s3">\n        </span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">=== typeof thenable.status</span><span class="s3">\n          </span><span class="s1">? thenable.then(noop, noop)</span><span class="s3">\n          </span><span class="s1">: ((thenable.status = </span><span class="s3">\&quot;</span><span class="s1">pending</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">thenable.then(</span><span class="s3">\n              </span><span class="s1">function (fulfilledValue) {</span><span class="s3">\n                \&quot;</span><span class="s1">pending</span><span class="s3">\&quot; </span><span class="s1">=== thenable.status &amp;&amp;</span><span class="s3">\n                  </span><span class="s1">((thenable.status = </span><span class="s3">\&quot;</span><span class="s1">fulfilled</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">(thenable.value = fulfilledValue));</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">function (error) {</span><span class="s3">\n                \&quot;</span><span class="s1">pending</span><span class="s3">\&quot; </span><span class="s1">=== thenable.status &amp;&amp;</span><span class="s3">\n                  </span><span class="s1">((thenable.status = </span><span class="s3">\&quot;</span><span class="s1">rejected</span><span class="s3">\&quot;</span><span class="s1">), (thenable.reason = error));</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">)),</span><span class="s3">\n        </span><span class="s1">thenable.status)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">fulfilled</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">return thenable.value;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">rejected</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">throw thenable.reason;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw thenable;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {</span><span class="s3">\n  </span><span class="s1">var type = typeof children;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">=== type || </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">=== type) children = null;</span><span class="s3">\n  </span><span class="s1">var invokeCallback = !1;</span><span class="s3">\n  </span><span class="s1">if (null === children) invokeCallback = !0;</span><span class="s3">\n  </span><span class="s1">else</span><span class="s3">\n    </span><span class="s1">switch (type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">invokeCallback = !0;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">switch (children.$$typeof) {</span><span class="s3">\n          </span><span class="s1">case REACT_ELEMENT_TYPE:</span><span class="s3">\n          </span><span class="s1">case REACT_PORTAL_TYPE:</span><span class="s3">\n            </span><span class="s1">invokeCallback = !0;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case REACT_LAZY_TYPE:</span><span class="s3">\n            </span><span class="s1">return (</span><span class="s3">\n              </span><span class="s1">(invokeCallback = children._init),</span><span class="s3">\n              </span><span class="s1">mapIntoArray(</span><span class="s3">\n                </span><span class="s1">invokeCallback(children._payload),</span><span class="s3">\n                </span><span class="s1">array,</span><span class="s3">\n                </span><span class="s1">escapedPrefix,</span><span class="s3">\n                </span><span class="s1">nameSoFar,</span><span class="s3">\n                </span><span class="s1">callback</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (invokeCallback)</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">(callback = callback(children)),</span><span class="s3">\n      </span><span class="s1">(invokeCallback =</span><span class="s3">\n        \&quot;\&quot; </span><span class="s1">=== nameSoFar ? </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ getElementKey(children, 0) : nameSoFar),</span><span class="s3">\n      </span><span class="s1">isArrayImpl(callback)</span><span class="s3">\n        </span><span class="s1">? ((escapedPrefix = </span><span class="s3">\&quot;\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">null != invokeCallback &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(escapedPrefix =</span><span class="s3">\n              </span><span class="s1">invokeCallback.replace(userProvidedKeyEscapeRegex, </span><span class="s3">\&quot;</span><span class="s1">$&amp;/</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">mapIntoArray(callback, array, escapedPrefix, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, function (c) {</span><span class="s3">\n            </span><span class="s1">return c;</span><span class="s3">\n          </span><span class="s1">}))</span><span class="s3">\n        </span><span class="s1">: null != callback &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(isValidElement(callback) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(callback = cloneAndReplaceKey(</span><span class="s3">\n              </span><span class="s1">callback,</span><span class="s3">\n              </span><span class="s1">escapedPrefix +</span><span class="s3">\n                </span><span class="s1">(null == callback.key ||</span><span class="s3">\n                </span><span class="s1">(children &amp;&amp; children.key === callback.key)</span><span class="s3">\n                  </span><span class="s1">? </span><span class="s3">\&quot;\&quot;\n                  </span><span class="s1">: (</span><span class="s3">\&quot;\&quot; </span><span class="s1">+ callback.key).replace(</span><span class="s3">\n                      </span><span class="s1">userProvidedKeyEscapeRegex,</span><span class="s3">\n                      \&quot;</span><span class="s1">$&amp;/</span><span class="s3">\&quot;\n                    </span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) +</span><span class="s3">\n                </span><span class="s1">invokeCallback</span><span class="s3">\n            </span><span class="s1">)),</span><span class="s3">\n          </span><span class="s1">array.push(callback)),</span><span class="s3">\n      </span><span class="s1">1</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">invokeCallback = 0;</span><span class="s3">\n  </span><span class="s1">var nextNamePrefix = </span><span class="s3">\&quot;\&quot; </span><span class="s1">=== nameSoFar ? </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">: nameSoFar + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">if (isArrayImpl(children))</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; children.length; i++)</span><span class="s3">\n      </span><span class="s1">(nameSoFar = children[i]),</span><span class="s3">\n        </span><span class="s1">(type = nextNamePrefix + getElementKey(nameSoFar, i)),</span><span class="s3">\n        </span><span class="s1">(invokeCallback += mapIntoArray(</span><span class="s3">\n          </span><span class="s1">nameSoFar,</span><span class="s3">\n          </span><span class="s1">array,</span><span class="s3">\n          </span><span class="s1">escapedPrefix,</span><span class="s3">\n          </span><span class="s1">type,</span><span class="s3">\n          </span><span class="s1">callback</span><span class="s3">\n        </span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">else if (((i = getIteratorFn(children)), </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof i))</span><span class="s3">\n    </span><span class="s1">for (</span><span class="s3">\n      </span><span class="s1">children = i.call(children), i = 0;</span><span class="s3">\n      </span><span class="s1">!(nameSoFar = children.next()).done;</span><span class="s3">\n\n    </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">(nameSoFar = nameSoFar.value),</span><span class="s3">\n        </span><span class="s1">(type = nextNamePrefix + getElementKey(nameSoFar, i++)),</span><span class="s3">\n        </span><span class="s1">(invokeCallback += mapIntoArray(</span><span class="s3">\n          </span><span class="s1">nameSoFar,</span><span class="s3">\n          </span><span class="s1">array,</span><span class="s3">\n          </span><span class="s1">escapedPrefix,</span><span class="s3">\n          </span><span class="s1">type,</span><span class="s3">\n          </span><span class="s1">callback</span><span class="s3">\n        </span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">else if (</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== type) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof children.then)</span><span class="s3">\n      </span><span class="s1">return mapIntoArray(</span><span class="s3">\n        </span><span class="s1">resolveThenable(children),</span><span class="s3">\n        </span><span class="s1">array,</span><span class="s3">\n        </span><span class="s1">escapedPrefix,</span><span class="s3">\n        </span><span class="s1">nameSoFar,</span><span class="s3">\n        </span><span class="s1">callback</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">array = String(children);</span><span class="s3">\n    </span><span class="s1">throw Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Objects are not valid as a React child (found: </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        </span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">[object Object]</span><span class="s3">\&quot; </span><span class="s1">=== array</span><span class="s3">\n          </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">object with keys {</span><span class="s3">\&quot; </span><span class="s1">+ Object.keys(children).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;\n          </span><span class="s1">: array) +</span><span class="s3">\n        \&quot;</span><span class="s1">). If you meant to render a collection of children, use an array instead.</span><span class="s3">\&quot;\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return invokeCallback;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mapChildren(children, func, context) {</span><span class="s3">\n  </span><span class="s1">if (null == children) return children;</span><span class="s3">\n  </span><span class="s1">var result = [],</span><span class="s3">\n    </span><span class="s1">count = 0;</span><span class="s3">\n  </span><span class="s1">mapIntoArray(children, result, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, function (child) {</span><span class="s3">\n    </span><span class="s1">return func.call(context, child, count++);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function lazyInitializer(payload) {</span><span class="s3">\n  </span><span class="s1">if (-1 === payload._status) {</span><span class="s3">\n    </span><span class="s1">var ctor = payload._result;</span><span class="s3">\n    </span><span class="s1">ctor = ctor();</span><span class="s3">\n    </span><span class="s1">ctor.then(</span><span class="s3">\n      </span><span class="s1">function (moduleObject) {</span><span class="s3">\n        </span><span class="s1">if (0 === payload._status || -1 === payload._status)</span><span class="s3">\n          </span><span class="s1">(payload._status = 1), (payload._result = moduleObject);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">function (error) {</span><span class="s3">\n        </span><span class="s1">if (0 === payload._status || -1 === payload._status)</span><span class="s3">\n          </span><span class="s1">(payload._status = 2), (payload._result = error);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">-1 === payload._status &amp;&amp; ((payload._status = 0), (payload._result = ctor));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (1 === payload._status) return payload._result.default;</span><span class="s3">\n  </span><span class="s1">throw payload._result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var reportGlobalError =</span><span class="s3">\n  \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof reportError</span><span class="s3">\n    </span><span class="s1">? reportError</span><span class="s3">\n    </span><span class="s1">: function (error) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof window &amp;&amp;</span><span class="s3">\n          \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof window.ErrorEvent</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">var event = new window.ErrorEvent(</span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n            </span><span class="s1">bubbles: !0,</span><span class="s3">\n            </span><span class="s1">cancelable: !0,</span><span class="s3">\n            </span><span class="s1">message:</span><span class="s3">\n              \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof error &amp;&amp;</span><span class="s3">\n              </span><span class="s1">null !== error &amp;&amp;</span><span class="s3">\n              \&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">=== typeof error.message</span><span class="s3">\n                </span><span class="s1">? String(error.message)</span><span class="s3">\n                </span><span class="s1">: String(error),</span><span class="s3">\n            </span><span class="s1">error: error</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">if (!window.dispatchEvent(event)) return;</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof process &amp;&amp;</span><span class="s3">\n          \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof process.emit</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">process.emit(</span><span class="s3">\&quot;</span><span class="s1">uncaughtException</span><span class="s3">\&quot;</span><span class="s1">, error);</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">console.error(error);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.Children = {</span><span class="s3">\n  </span><span class="s1">map: mapChildren,</span><span class="s3">\n  </span><span class="s1">forEach: function (children, forEachFunc, forEachContext) {</span><span class="s3">\n    </span><span class="s1">mapChildren(</span><span class="s3">\n      </span><span class="s1">children,</span><span class="s3">\n      </span><span class="s1">function () {</span><span class="s3">\n        </span><span class="s1">forEachFunc.apply(this, arguments);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">forEachContext</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">count: function (children) {</span><span class="s3">\n    </span><span class="s1">var n = 0;</span><span class="s3">\n    </span><span class="s1">mapChildren(children, function () {</span><span class="s3">\n      </span><span class="s1">n++;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return n;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">toArray: function (children) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">mapChildren(children, function (child) {</span><span class="s3">\n        </span><span class="s1">return child;</span><span class="s3">\n      </span><span class="s1">}) || []</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">only: function (children) {</span><span class="s3">\n    </span><span class="s1">if (!isValidElement(children))</span><span class="s3">\n      </span><span class="s1">throw Error(</span><span class="s3">\n        \&quot;</span><span class="s1">React.Children.only expected to receive a single React element child.</span><span class="s3">\&quot;\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return children;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.Component = Component;</span><span class="s3">\n</span><span class="s1">exports.Fragment = REACT_FRAGMENT_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Profiler = REACT_PROFILER_TYPE;</span><span class="s3">\n</span><span class="s1">exports.PureComponent = PureComponent;</span><span class="s3">\n</span><span class="s1">exports.StrictMode = REACT_STRICT_MODE_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Suspense = REACT_SUSPENSE_TYPE;</span><span class="s3">\n</span><span class="s1">exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =</span><span class="s3">\n  </span><span class="s1">ReactSharedInternals;</span><span class="s3">\n</span><span class="s1">exports.__COMPILER_RUNTIME = {</span><span class="s3">\n  </span><span class="s1">__proto__: null,</span><span class="s3">\n  </span><span class="s1">c: function (size) {</span><span class="s3">\n    </span><span class="s1">return ReactSharedInternals.H.useMemoCache(size);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.cache = function (fn) {</span><span class="s3">\n  </span><span class="s1">return function () {</span><span class="s3">\n    </span><span class="s1">return fn.apply(null, arguments);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.cacheSignal = function () {</span><span class="s3">\n  </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.cloneElement = function (element, config, children) {</span><span class="s3">\n  </span><span class="s1">if (null === element || void 0 === element)</span><span class="s3">\n    </span><span class="s1">throw Error(</span><span class="s3">\n      \&quot;</span><span class="s1">The argument must be a React element, but you passed </span><span class="s3">\&quot; </span><span class="s1">+ element + </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">var props = assign({}, element.props),</span><span class="s3">\n    </span><span class="s1">key = element.key;</span><span class="s3">\n  </span><span class="s1">if (null != config)</span><span class="s3">\n    </span><span class="s1">for (propName in (void 0 !== config.key &amp;&amp; (key = </span><span class="s3">\&quot;\&quot; </span><span class="s1">+ config.key), config))</span><span class="s3">\n      </span><span class="s1">!hasOwnProperty.call(config, propName) ||</span><span class="s3">\n        \&quot;</span><span class="s1">key</span><span class="s3">\&quot; </span><span class="s1">=== propName ||</span><span class="s3">\n        \&quot;</span><span class="s1">__self</span><span class="s3">\&quot; </span><span class="s1">=== propName ||</span><span class="s3">\n        \&quot;</span><span class="s1">__source</span><span class="s3">\&quot; </span><span class="s1">=== propName ||</span><span class="s3">\n        </span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">ref</span><span class="s3">\&quot; </span><span class="s1">=== propName &amp;&amp; void 0 === config.ref) ||</span><span class="s3">\n        </span><span class="s1">(props[propName] = config[propName]);</span><span class="s3">\n  </span><span class="s1">var propName = arguments.length - 2;</span><span class="s3">\n  </span><span class="s1">if (1 === propName) props.children = children;</span><span class="s3">\n  </span><span class="s1">else if (1 &lt; propName) {</span><span class="s3">\n    </span><span class="s1">for (var childArray = Array(propName), i = 0; i &lt; propName; i++)</span><span class="s3">\n      </span><span class="s1">childArray[i] = arguments[i + 2];</span><span class="s3">\n    </span><span class="s1">props.children = childArray;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ReactElement(element.type, key, props);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.createContext = function (defaultValue) {</span><span class="s3">\n  </span><span class="s1">defaultValue = {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_CONTEXT_TYPE,</span><span class="s3">\n    </span><span class="s1">_currentValue: defaultValue,</span><span class="s3">\n    </span><span class="s1">_currentValue2: defaultValue,</span><span class="s3">\n    </span><span class="s1">_threadCount: 0,</span><span class="s3">\n    </span><span class="s1">Provider: null,</span><span class="s3">\n    </span><span class="s1">Consumer: null</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">defaultValue.Provider = defaultValue;</span><span class="s3">\n  </span><span class="s1">defaultValue.Consumer = {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_CONSUMER_TYPE,</span><span class="s3">\n    </span><span class="s1">_context: defaultValue</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return defaultValue;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.createElement = function (type, config, children) {</span><span class="s3">\n  </span><span class="s1">var propName,</span><span class="s3">\n    </span><span class="s1">props = {},</span><span class="s3">\n    </span><span class="s1">key = null;</span><span class="s3">\n  </span><span class="s1">if (null != config)</span><span class="s3">\n    </span><span class="s1">for (propName in (void 0 !== config.key &amp;&amp; (key = </span><span class="s3">\&quot;\&quot; </span><span class="s1">+ config.key), config))</span><span class="s3">\n      </span><span class="s1">hasOwnProperty.call(config, propName) &amp;&amp;</span><span class="s3">\n        \&quot;</span><span class="s1">key</span><span class="s3">\&quot; </span><span class="s1">!== propName &amp;&amp;</span><span class="s3">\n        \&quot;</span><span class="s1">__self</span><span class="s3">\&quot; </span><span class="s1">!== propName &amp;&amp;</span><span class="s3">\n        \&quot;</span><span class="s1">__source</span><span class="s3">\&quot; </span><span class="s1">!== propName &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(props[propName] = config[propName]);</span><span class="s3">\n  </span><span class="s1">var childrenLength = arguments.length - 2;</span><span class="s3">\n  </span><span class="s1">if (1 === childrenLength) props.children = children;</span><span class="s3">\n  </span><span class="s1">else if (1 &lt; childrenLength) {</span><span class="s3">\n    </span><span class="s1">for (var childArray = Array(childrenLength), i = 0; i &lt; childrenLength; i++)</span><span class="s3">\n      </span><span class="s1">childArray[i] = arguments[i + 2];</span><span class="s3">\n    </span><span class="s1">props.children = childArray;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (type &amp;&amp; type.defaultProps)</span><span class="s3">\n    </span><span class="s1">for (propName in ((childrenLength = type.defaultProps), childrenLength))</span><span class="s3">\n      </span><span class="s1">void 0 === props[propName] &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(props[propName] = childrenLength[propName]);</span><span class="s3">\n  </span><span class="s1">return ReactElement(type, key, props);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.createRef = function () {</span><span class="s3">\n  </span><span class="s1">return { current: null };</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.forwardRef = function (render) {</span><span class="s3">\n  </span><span class="s1">return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isValidElement = isValidElement;</span><span class="s3">\n</span><span class="s1">exports.lazy = function (ctor) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_LAZY_TYPE,</span><span class="s3">\n    </span><span class="s1">_payload: { _status: -1, _result: ctor },</span><span class="s3">\n    </span><span class="s1">_init: lazyInitializer</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.memo = function (type, compare) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_MEMO_TYPE,</span><span class="s3">\n    </span><span class="s1">type: type,</span><span class="s3">\n    </span><span class="s1">compare: void 0 === compare ? null : compare</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.startTransition = function (scope) {</span><span class="s3">\n  </span><span class="s1">var prevTransition = ReactSharedInternals.T,</span><span class="s3">\n    </span><span class="s1">currentTransition = {};</span><span class="s3">\n  </span><span class="s1">ReactSharedInternals.T = currentTransition;</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">var returnValue = scope(),</span><span class="s3">\n      </span><span class="s1">onStartTransitionFinish = ReactSharedInternals.S;</span><span class="s3">\n    </span><span class="s1">null !== onStartTransitionFinish &amp;&amp;</span><span class="s3">\n      </span><span class="s1">onStartTransitionFinish(currentTransition, returnValue);</span><span class="s3">\n    \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof returnValue &amp;&amp;</span><span class="s3">\n      </span><span class="s1">null !== returnValue &amp;&amp;</span><span class="s3">\n      \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof returnValue.then &amp;&amp;</span><span class="s3">\n      </span><span class="s1">returnValue.then(noop, reportGlobalError);</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">reportGlobalError(error);</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">null !== prevTransition &amp;&amp;</span><span class="s3">\n      </span><span class="s1">null !== currentTransition.types &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(prevTransition.types = currentTransition.types),</span><span class="s3">\n      </span><span class="s1">(ReactSharedInternals.T = prevTransition);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.unstable_useCacheRefresh = function () {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useCacheRefresh();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.use = function (usable) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.use(usable);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useActionState = function (action, initialState, permalink) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useActionState(action, initialState, permalink);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useCallback = function (callback, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useCallback(callback, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useContext = function (Context) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useContext(Context);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useDebugValue = function () {};</span><span class="s3">\n</span><span class="s1">exports.useDeferredValue = function (value, initialValue) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useDeferredValue(value, initialValue);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useEffect = function (create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useEffect(create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useId = function () {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useId();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useImperativeHandle = function (ref, create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useInsertionEffect = function (create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useInsertionEffect(create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useLayoutEffect = function (create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useLayoutEffect(create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useMemo = function (create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useMemo(create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useOptimistic = function (passthrough, reducer) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useOptimistic(passthrough, reducer);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useReducer = function (reducer, initialArg, init) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useReducer(reducer, initialArg, init);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useRef = function (initialValue) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useRef(initialValue);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useState = function (initialState) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useState(initialState);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useSyncExternalStore = function (</span><span class="s3">\n  </span><span class="s1">subscribe,</span><span class="s3">\n  </span><span class="s1">getSnapshot,</span><span class="s3">\n  </span><span class="s1">getServerSnapshot</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useSyncExternalStore(</span><span class="s3">\n    </span><span class="s1">subscribe,</span><span class="s3">\n    </span><span class="s1">getSnapshot,</span><span class="s3">\n    </span><span class="s1">getServerSnapshot</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useTransition = function () {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useTransition();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.version = </span><span class="s3">\&quot;</span><span class="s1">19.2.0-canary-0bdb9206-20250818</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n  </span><span class="s1">module.exports = require('./cjs/react.production.js');</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">module.exports = require('./cjs/react.development.js');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{var e={383:e=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;function _searchLast(e,t){const n=Array.from(e.matchAll(t));return n.length&gt;0?n.slice(-1)[0].index:-1}function _interpolate(e,t,n){const r=_searchLast(e,/(?!(?&lt;=</span><span class="s3">\\\\</span><span class="s1">))</span><span class="s3">\\</span><span class="s1">$/g);if(r===-1)return e;const o=e.slice(r);const s=/((?!(?&lt;=</span><span class="s3">\\\\</span><span class="s1">))</span><span class="s3">\\</span><span class="s1">${?([</span><span class="s3">\\</span><span class="s1">w]+)(?::-([^}</span><span class="s3">\\\\</span><span class="s1">]*))?}?)/;const i=o.match(s);if(i!=null){const[,r,o,s]=i;return _interpolate(e.replace(r,t[o]||s||n.parsed[o]||</span><span class="s3">\&quot;\&quot;</span><span class="s1">),t,n)}return e}function _resolveEscapeSequences(e){return e.replace(/</span><span class="s3">\\\\\\</span><span class="s1">$/g,</span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">)}function expand(e){const t=e.ignoreProcessEnv?{}:process.env;for(const n in e.parsed){const r=Object.prototype.hasOwnProperty.call(t,n)?t[n]:e.parsed[n];e.parsed[n]=_resolveEscapeSequences(_interpolate(r,t,e))}for(const n in e.parsed){t[n]=e.parsed[n]}return e}e.exports.j=expand},234:(e,t,n)=&gt;{const r=n(147);const o=n(17);const s=n(37);const i=n(113);const c=n(803);const a=c.version;const p=/(?:^|^)</span><span class="s3">\\</span><span class="s1">s*(?:export</span><span class="s3">\\</span><span class="s1">s+)?([</span><span class="s3">\\</span><span class="s1">w.-]+)(?:</span><span class="s3">\\</span><span class="s1">s*=</span><span class="s3">\\</span><span class="s1">s*?|:</span><span class="s3">\\</span><span class="s1">s+?)(</span><span class="s3">\\</span><span class="s1">s*'(?:</span><span class="s3">\\\\</span><span class="s1">'|[^'])*'|</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\\&quot;</span><span class="s1">|[^</span><span class="s3">\&quot;</span><span class="s1">])*</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">s*`(?:</span><span class="s3">\\\\</span><span class="s1">`|[^`])*`|[^#</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n]+)?</span><span class="s3">\\</span><span class="s1">s*(?:#.*)?(?:$|$)/gm;function parse(e){const t={};let n=e.toString();n=n.replace(/</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?/gm,</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);let r;while((r=p.exec(n))!=null){const e=r[1];let n=r[2]||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;n=n.trim();const o=n[0];n=n.replace(/^(['</span><span class="s3">\&quot;</span><span class="s1">`])([</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*)</span><span class="s3">\\</span><span class="s1">1$/gm,</span><span class="s3">\&quot;</span><span class="s1">$2</span><span class="s3">\&quot;</span><span class="s1">);if(o==='</span><span class="s3">\&quot;</span><span class="s1">'){n=n.replace(/</span><span class="s3">\\\\</span><span class="s1">n/g,</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);n=n.replace(/</span><span class="s3">\\\\</span><span class="s1">r/g,</span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">)}t[e]=n}return t}function _parseVault(e){const t=_vaultPath(e);const n=l.configDotenv({path:t});if(!n.parsed){throw new Error(`MISSING_DATA: Cannot parse ${t} for an unknown reason`)}const r=_dotenvKey(e).split(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);const o=r.length;let s;for(let e=0;e&lt;o;e++){try{const t=r[e].trim();const o=_instructions(n,t);s=l.decrypt(o.ciphertext,o.key);break}catch(t){if(e+1&gt;=o){throw t}}}return l.parse(s)}function _log(e){console.log(`[dotenv@${a}][INFO] ${e}`)}function _warn(e){console.log(`[dotenv@${a}][WARN] ${e}`)}function _debug(e){console.log(`[dotenv@${a}][DEBUG] ${e}`)}function _dotenvKey(e){if(e&amp;&amp;e.DOTENV_KEY&amp;&amp;e.DOTENV_KEY.length&gt;0){return e.DOTENV_KEY}if(process.env.DOTENV_KEY&amp;&amp;process.env.DOTENV_KEY.length&gt;0){return process.env.DOTENV_KEY}return</span><span class="s3">\&quot;\&quot;</span><span class="s1">}function _instructions(e,t){let n;try{n=new URL(t)}catch(e){if(e.code===</span><span class="s3">\&quot;</span><span class="s1">ERR_INVALID_URL</span><span class="s3">\&quot;</span><span class="s1">){throw new Error(</span><span class="s3">\&quot;</span><span class="s1">INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development</span><span class="s3">\&quot;</span><span class="s1">)}throw e}const r=n.password;if(!r){throw new Error(</span><span class="s3">\&quot;</span><span class="s1">INVALID_DOTENV_KEY: Missing key part</span><span class="s3">\&quot;</span><span class="s1">)}const o=n.searchParams.get(</span><span class="s3">\&quot;</span><span class="s1">environment</span><span class="s3">\&quot;</span><span class="s1">);if(!o){throw new Error(</span><span class="s3">\&quot;</span><span class="s1">INVALID_DOTENV_KEY: Missing environment part</span><span class="s3">\&quot;</span><span class="s1">)}const s=`DOTENV_VAULT_${o.toUpperCase()}`;const i=e.parsed[s];if(!i){throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${s} in your .env.vault file.`)}return{ciphertext:i,key:r}}function _vaultPath(e){let t=o.resolve(process.cwd(),</span><span class="s3">\&quot;</span><span class="s1">.env</span><span class="s3">\&quot;</span><span class="s1">);if(e&amp;&amp;e.path&amp;&amp;e.path.length&gt;0){t=e.path}return t.endsWith(</span><span class="s3">\&quot;</span><span class="s1">.vault</span><span class="s3">\&quot;</span><span class="s1">)?t:`${t}.vault`}function _resolveHome(e){return e[0]===</span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">?o.join(s.homedir(),e.slice(1)):e}function _configVault(e){_log(</span><span class="s3">\&quot;</span><span class="s1">Loading env from encrypted .env.vault</span><span class="s3">\&quot;</span><span class="s1">);const t=l._parseVault(e);let n=process.env;if(e&amp;&amp;e.processEnv!=null){n=e.processEnv}l.populate(n,t,e);return{parsed:t}}function configDotenv(e){let t=o.resolve(process.cwd(),</span><span class="s3">\&quot;</span><span class="s1">.env</span><span class="s3">\&quot;</span><span class="s1">);let n=</span><span class="s3">\&quot;</span><span class="s1">utf8</span><span class="s3">\&quot;</span><span class="s1">;const s=Boolean(e&amp;&amp;e.debug);if(e){if(e.path!=null){t=_resolveHome(e.path)}if(e.encoding!=null){n=e.encoding}}try{const o=l.parse(r.readFileSync(t,{encoding:n}));let s=process.env;if(e&amp;&amp;e.processEnv!=null){s=e.processEnv}l.populate(s,o,e);return{parsed:o}}catch(e){if(s){_debug(`Failed to load ${t} ${e.message}`)}return{error:e}}}function config(e){const t=_vaultPath(e);if(_dotenvKey(e).length===0){return l.configDotenv(e)}if(!r.existsSync(t)){_warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${t}. Did you forget to build it?`);return l.configDotenv(e)}return l._configVault(e)}function decrypt(e,t){const n=Buffer.from(t.slice(-64),</span><span class="s3">\&quot;</span><span class="s1">hex</span><span class="s3">\&quot;</span><span class="s1">);let r=Buffer.from(e,</span><span class="s3">\&quot;</span><span class="s1">base64</span><span class="s3">\&quot;</span><span class="s1">);const o=r.slice(0,12);const s=r.slice(-16);r=r.slice(12,-16);try{const e=i.createDecipheriv(</span><span class="s3">\&quot;</span><span class="s1">aes-256-gcm</span><span class="s3">\&quot;</span><span class="s1">,n,o);e.setAuthTag(s);return`${e.update(r)}${e.final()}`}catch(e){const t=e instanceof RangeError;const n=e.message===</span><span class="s3">\&quot;</span><span class="s1">Invalid key length</span><span class="s3">\&quot;</span><span class="s1">;const r=e.message===</span><span class="s3">\&quot;</span><span class="s1">Unsupported state or unable to authenticate data</span><span class="s3">\&quot;</span><span class="s1">;if(t||n){const e=</span><span class="s3">\&quot;</span><span class="s1">INVALID_DOTENV_KEY: It must be 64 characters long (or more)</span><span class="s3">\&quot;</span><span class="s1">;throw new Error(e)}else if(r){const e=</span><span class="s3">\&quot;</span><span class="s1">DECRYPTION_FAILED: Please check your DOTENV_KEY</span><span class="s3">\&quot;</span><span class="s1">;throw new Error(e)}else{console.error(</span><span class="s3">\&quot;</span><span class="s1">Error: </span><span class="s3">\&quot;</span><span class="s1">,e.code);console.error(</span><span class="s3">\&quot;</span><span class="s1">Error: </span><span class="s3">\&quot;</span><span class="s1">,e.message);throw e}}}function populate(e,t,n={}){const r=Boolean(n&amp;&amp;n.debug);const o=Boolean(n&amp;&amp;n.override);if(typeof t!==</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">){throw new Error(</span><span class="s3">\&quot;</span><span class="s1">OBJECT_REQUIRED: Please check the processEnv argument being passed to populate</span><span class="s3">\&quot;</span><span class="s1">)}for(const n of Object.keys(t)){if(Object.prototype.hasOwnProperty.call(e,n)){if(o===true){e[n]=t[n]}if(r){if(o===true){_debug(`</span><span class="s3">\&quot;</span><span class="s1">${n}</span><span class="s3">\&quot; </span><span class="s1">is already defined and WAS overwritten`)}else{_debug(`</span><span class="s3">\&quot;</span><span class="s1">${n}</span><span class="s3">\&quot; </span><span class="s1">is already defined and was NOT overwritten`)}}}else{e[n]=t[n]}}}const l={configDotenv:configDotenv,_configVault:_configVault,_parseVault:_parseVault,config:config,decrypt:decrypt,parse:parse,populate:populate};e.exports.configDotenv=l.configDotenv;e.exports._configVault=l._configVault;e.exports._parseVault=l._parseVault;e.exports.config=l.config;e.exports.decrypt=l.decrypt;e.exports.parse=l.parse;e.exports.populate=l.populate;e.exports=l},113:e=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;e.exports=require(</span><span class="s3">\&quot;</span><span class="s1">crypto</span><span class="s3">\&quot;</span><span class="s1">)},147:e=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;e.exports=require(</span><span class="s3">\&quot;</span><span class="s1">fs</span><span class="s3">\&quot;</span><span class="s1">)},37:e=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;e.exports=require(</span><span class="s3">\&quot;</span><span class="s1">os</span><span class="s3">\&quot;</span><span class="s1">)},17:e=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;e.exports=require(</span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">)},803:e=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;e.exports=JSON.parse('{</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">dotenv</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">version</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">16.3.1</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">description</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Loads environment variables from .env file</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">main</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">lib/main.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">lib/main.d.ts</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">exports</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./lib/main.d.ts</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">require</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./lib/main.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./lib/main.js</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">./config</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./config.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">./config.js</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./config.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">./lib/env-options</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./lib/env-options.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">./lib/env-options.js</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./lib/env-options.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">./lib/cli-options</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./lib/cli-options.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">./lib/cli-options.js</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./lib/cli-options.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">./package.json</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">./package.json</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">scripts</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">dts-check</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">tsc --project tests/types/tsconfig.json</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">lint</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">standard</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">lint-readme</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">standard-markdown</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">pretest</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">npm run lint &amp;&amp; npm run dts-check</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">tap tests/*.js --100 -Rspec</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">prerelease</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">npm test</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">release</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">standard-version</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">repository</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">git</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">git://github.com/motdotla/dotenv.git</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">funding</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">https://github.com/motdotla/dotenv?sponsor=1</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">keywords</span><span class="s3">\&quot;</span><span class="s1">:[</span><span class="s3">\&quot;</span><span class="s1">dotenv</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">env</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">.env</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">environment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">variables</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">config</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">settings</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\&quot;</span><span class="s1">readmeFilename</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">README.md</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">license</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">BSD-2-Clause</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">devDependencies</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">@definitelytyped/dtslint</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^0.0.133</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">@types/node</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^18.11.3</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">decache</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^4.6.1</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">sinon</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^14.0.1</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">standard</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^17.0.0</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">standard-markdown</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^7.1.0</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">standard-version</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^9.5.0</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">tap</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^16.3.0</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">tar</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^6.1.11</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">typescript</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">^4.8.4</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">engines</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">&gt;=12</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">browser</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">fs</span><span class="s3">\&quot;</span><span class="s1">:false}}')}};var t={};function __nccwpck_require__(n){var r=t[n];if(r!==undefined){return r.exports}var o=t[n]={exports:{}};var s=true;try{e[n](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete t[n]}return o.exports}(()=&gt;{__nccwpck_require__.n=e=&gt;{var t=e&amp;&amp;e.__esModule?()=&gt;e[</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">]:()=&gt;e;__nccwpck_require__.d(t,{a:t});return t}})();(()=&gt;{__nccwpck_require__.d=(e,t)=&gt;{for(var n in t){if(__nccwpck_require__.o(t,n)&amp;&amp;!__nccwpck_require__.o(e,n)){Object.defineProperty(e,n,{enumerable:true,get:t[n]})}}}})();(()=&gt;{__nccwpck_require__.o=(e,t)=&gt;Object.prototype.hasOwnProperty.call(e,t)})();(()=&gt;{__nccwpck_require__.r=e=&gt;{if(typeof Symbol!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;Symbol.toStringTag){Object.defineProperty(e,Symbol.toStringTag,{value:</span><span class="s3">\&quot;</span><span class="s1">Module</span><span class="s3">\&quot;</span><span class="s1">})}Object.defineProperty(e,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true})}})();if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var n={};(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;__nccwpck_require__.r(n);__nccwpck_require__.d(n,{initialEnv:()=&gt;a,updateInitialEnv:()=&gt;updateInitialEnv,processEnv:()=&gt;processEnv,resetEnv:()=&gt;resetEnv,loadEnvConfig:()=&gt;loadEnvConfig});var e=__nccwpck_require__(147);var t=__nccwpck_require__.n(e);var r=__nccwpck_require__(17);var o=__nccwpck_require__.n(r);var s=__nccwpck_require__(234);var i=__nccwpck_require__.n(s);var c=__nccwpck_require__(383);let a=undefined;let p=undefined;let l=undefined;let u=[];let _=[];function updateInitialEnv(e){Object.assign(a||{},e)}function replaceProcessEnv(e){Object.keys(process.env).forEach((t=&gt;{if(!t.startsWith(</span><span class="s3">\&quot;</span><span class="s1">__NEXT_PRIVATE</span><span class="s3">\&quot;</span><span class="s1">)){if(e[t]===undefined||e[t]===</span><span class="s3">\&quot;\&quot;</span><span class="s1">){delete process.env[t]}}}));Object.entries(e).forEach((([e,t])=&gt;{process.env[e]=t}))}function processEnv(e,t,n=console,o=false,i){var p;if(!a){a=Object.assign({},process.env)}if(!o&amp;&amp;(process.env.__NEXT_PROCESSED_ENV||e.length===0)){return[process.env]}process.env.__NEXT_PROCESSED_ENV=</span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">;const l=Object.assign({},a);const u={};for(const o of e){try{let e={};e.parsed=s.parse(o.contents);e=(0,c.j)(e);if(e.parsed&amp;&amp;!_.some((e=&gt;e.contents===o.contents&amp;&amp;e.path===o.path))){i===null||i===void 0?void 0:i(o.path)}for(const t of Object.keys(e.parsed||{})){if(typeof u[t]===</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;typeof l[t]===</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">){u[t]=(p=e.parsed)===null||p===void 0?void 0:p[t]}}o.env=e.parsed||{}}catch(e){n.error(`Failed to load env from ${r.join(t||</span><span class="s3">\&quot;\&quot;</span><span class="s1">,o.path)}`,e)}}return[Object.assign(process.env,u),u]}function resetEnv(){if(a){replaceProcessEnv(a)}}function loadEnvConfig(t,n,o=console,s=false,i){if(!a){a=Object.assign({},process.env)}if(p&amp;&amp;!s){return{combinedEnv:p,parsedEnv:l,loadedEnvFiles:u}}replaceProcessEnv(a);_=u;u=[];const c=process.env.NODE_ENV===</span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">;const d=c?</span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">:n?</span><span class="s3">\&quot;</span><span class="s1">development</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot;</span><span class="s1">;const f=[`.env.${d}.local`,d!==</span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;`.env.local`,`.env.${d}`,</span><span class="s3">\&quot;</span><span class="s1">.env</span><span class="s3">\&quot;</span><span class="s1">].filter(Boolean);for(const n of f){const s=r.join(t,n);try{const t=e.statSync(s);if(!t.isFile()&amp;&amp;!t.isFIFO()){continue}const r=e.readFileSync(s,</span><span class="s3">\&quot;</span><span class="s1">utf8</span><span class="s3">\&quot;</span><span class="s1">);u.push({path:n,contents:r,env:{}})}catch(e){if(e.code!==</span><span class="s3">\&quot;</span><span class="s1">ENOENT</span><span class="s3">\&quot;</span><span class="s1">){o.error(`Failed to load env from ${n}`,e)}}}[p,l]=processEnv(u,t,o,s,i);return{combinedEnv:p,parsedEnv:l,loadedEnvFiles:u}}})();module.exports=n})();&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var __defProp = Object.defineProperty;</span><span class="s3">\n</span><span class="s1">var __getOwnPropDesc = Object.getOwnPropertyDescriptor;</span><span class="s3">\n</span><span class="s1">var __getOwnPropNames = Object.getOwnPropertyNames;</span><span class="s3">\n</span><span class="s1">var __hasOwnProp = Object.prototype.hasOwnProperty;</span><span class="s3">\n</span><span class="s1">var __export = (target, all) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (var name in all)</span><span class="s3">\n    </span><span class="s1">__defProp(target, name, { get: all[name], enumerable: true });</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var __copyProps = (to, from, except, desc) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (from &amp;&amp; typeof from === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| typeof from === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (let key of __getOwnPropNames(from))</span><span class="s3">\n      </span><span class="s1">if (!__hasOwnProp.call(to, key) &amp;&amp; key !== except)</span><span class="s3">\n        </span><span class="s1">__defProp(to, key, { get: () =&gt; from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return to;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var __toCommonJS = (mod) =&gt; __copyProps(__defProp({}, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true }), mod);</span><span class="s3">\n\n</span><span class="s1">// src/index.ts</span><span class="s3">\n</span><span class="s1">var src_exports = {};</span><span class="s3">\n</span><span class="s1">__export(src_exports, {</span><span class="s3">\n  </span><span class="s1">RequestCookies: () =&gt; RequestCookies,</span><span class="s3">\n  </span><span class="s1">ResponseCookies: () =&gt; ResponseCookies,</span><span class="s3">\n  </span><span class="s1">parseCookie: () =&gt; parseCookie,</span><span class="s3">\n  </span><span class="s1">parseSetCookie: () =&gt; parseSetCookie,</span><span class="s3">\n  </span><span class="s1">stringifyCookie: () =&gt; stringifyCookie</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">module.exports = __toCommonJS(src_exports);</span><span class="s3">\n\n</span><span class="s1">// src/serialize.ts</span><span class="s3">\n</span><span class="s1">function stringifyCookie(c) {</span><span class="s3">\n  </span><span class="s1">var _a;</span><span class="s3">\n  </span><span class="s1">const attrs = [</span><span class="s3">\n    \&quot;</span><span class="s1">path</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.path &amp;&amp; `Path=${c.path}`,</span><span class="s3">\n    \&quot;</span><span class="s1">expires</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; (c.expires || c.expires === 0) &amp;&amp; `Expires=${(typeof c.expires === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? new Date(c.expires) : c.expires).toUTCString()}`,</span><span class="s3">\n    \&quot;</span><span class="s1">maxAge</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; typeof c.maxAge === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; `Max-Age=${c.maxAge}`,</span><span class="s3">\n    \&quot;</span><span class="s1">domain</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.domain &amp;&amp; `Domain=${c.domain}`,</span><span class="s3">\n    \&quot;</span><span class="s1">secure</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.secure &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">Secure</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">httpOnly</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.httpOnly &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">HttpOnly</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">sameSite</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.sameSite &amp;&amp; `SameSite=${c.sameSite}`,</span><span class="s3">\n    \&quot;</span><span class="s1">partitioned</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.partitioned &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">Partitioned</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">priority</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.priority &amp;&amp; `Priority=${c.priority}`</span><span class="s3">\n  </span><span class="s1">].filter(Boolean);</span><span class="s3">\n  </span><span class="s1">const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : </span><span class="s3">\&quot;\&quot;</span><span class="s1">)}`;</span><span class="s3">\n  </span><span class="s1">return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseCookie(cookie) {</span><span class="s3">\n  </span><span class="s1">const map = /* @__PURE__ */ new Map();</span><span class="s3">\n  </span><span class="s1">for (const pair of cookie.split(/; */)) {</span><span class="s3">\n    </span><span class="s1">if (!pair)</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">const splitAt = pair.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (splitAt === -1) {</span><span class="s3">\n      </span><span class="s1">map.set(pair, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">map.set(key, decodeURIComponent(value != null ? value : </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return map;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseSetCookie(setCookie) {</span><span class="s3">\n  </span><span class="s1">if (!setCookie) {</span><span class="s3">\n    </span><span class="s1">return void 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const [[name, value], ...attributes] = parseCookie(setCookie);</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">domain,</span><span class="s3">\n    </span><span class="s1">expires,</span><span class="s3">\n    </span><span class="s1">httponly,</span><span class="s3">\n    </span><span class="s1">maxage,</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">samesite,</span><span class="s3">\n    </span><span class="s1">secure,</span><span class="s3">\n    </span><span class="s1">partitioned,</span><span class="s3">\n    </span><span class="s1">priority</span><span class="s3">\n  </span><span class="s1">} = Object.fromEntries(</span><span class="s3">\n    </span><span class="s1">attributes.map(([key, value2]) =&gt; [</span><span class="s3">\n      </span><span class="s1">key.toLowerCase().replace(/-/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">value2</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const cookie = {</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">value: decodeURIComponent(value),</span><span class="s3">\n    </span><span class="s1">domain,</span><span class="s3">\n    </span><span class="s1">...expires &amp;&amp; { expires: new Date(expires) },</span><span class="s3">\n    </span><span class="s1">...httponly &amp;&amp; { httpOnly: true },</span><span class="s3">\n    </span><span class="s1">...typeof maxage === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; { maxAge: Number(maxage) },</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">...samesite &amp;&amp; { sameSite: parseSameSite(samesite) },</span><span class="s3">\n    </span><span class="s1">...secure &amp;&amp; { secure: true },</span><span class="s3">\n    </span><span class="s1">...priority &amp;&amp; { priority: parsePriority(priority) },</span><span class="s3">\n    </span><span class="s1">...partitioned &amp;&amp; { partitioned: true }</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return compact(cookie);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function compact(t) {</span><span class="s3">\n  </span><span class="s1">const newT = {};</span><span class="s3">\n  </span><span class="s1">for (const key in t) {</span><span class="s3">\n    </span><span class="s1">if (t[key]) {</span><span class="s3">\n      </span><span class="s1">newT[key] = t[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newT;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var SAME_SITE = [</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">lax</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">function parseSameSite(string) {</span><span class="s3">\n  </span><span class="s1">string = string.toLowerCase();</span><span class="s3">\n  </span><span class="s1">return SAME_SITE.includes(string) ? string : void 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var PRIORITY = [</span><span class="s3">\&quot;</span><span class="s1">low</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">medium</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">high</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">function parsePriority(string) {</span><span class="s3">\n  </span><span class="s1">string = string.toLowerCase();</span><span class="s3">\n  </span><span class="s1">return PRIORITY.includes(string) ? string : void 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function splitCookiesString(cookiesString) {</span><span class="s3">\n  </span><span class="s1">if (!cookiesString)</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">var cookiesStrings = [];</span><span class="s3">\n  </span><span class="s1">var pos = 0;</span><span class="s3">\n  </span><span class="s1">var start;</span><span class="s3">\n  </span><span class="s1">var ch;</span><span class="s3">\n  </span><span class="s1">var lastComma;</span><span class="s3">\n  </span><span class="s1">var nextStart;</span><span class="s3">\n  </span><span class="s1">var cookiesSeparatorFound;</span><span class="s3">\n  </span><span class="s1">function skipWhitespace() {</span><span class="s3">\n    </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(cookiesString.charAt(pos))) {</span><span class="s3">\n      </span><span class="s1">pos += 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos &lt; cookiesString.length;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function notSpecialChar() {</span><span class="s3">\n    </span><span class="s1">ch = cookiesString.charAt(pos);</span><span class="s3">\n    </span><span class="s1">return ch !== </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ch !== </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ch !== </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (pos &lt; cookiesString.length) {</span><span class="s3">\n    </span><span class="s1">start = pos;</span><span class="s3">\n    </span><span class="s1">cookiesSeparatorFound = false;</span><span class="s3">\n    </span><span class="s1">while (skipWhitespace()) {</span><span class="s3">\n      </span><span class="s1">ch = cookiesString.charAt(pos);</span><span class="s3">\n      </span><span class="s1">if (ch === </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">lastComma = pos;</span><span class="s3">\n        </span><span class="s1">pos += 1;</span><span class="s3">\n        </span><span class="s1">skipWhitespace();</span><span class="s3">\n        </span><span class="s1">nextStart = pos;</span><span class="s3">\n        </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; notSpecialChar()) {</span><span class="s3">\n          </span><span class="s1">pos += 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (pos &lt; cookiesString.length &amp;&amp; cookiesString.charAt(pos) === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">cookiesSeparatorFound = true;</span><span class="s3">\n          </span><span class="s1">pos = nextStart;</span><span class="s3">\n          </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, lastComma));</span><span class="s3">\n          </span><span class="s1">start = pos;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">pos = lastComma + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pos += 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!cookiesSeparatorFound || pos &gt;= cookiesString.length) {</span><span class="s3">\n      </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, cookiesString.length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cookiesStrings;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// src/request-cookies.ts</span><span class="s3">\n</span><span class="s1">var RequestCookies = class {</span><span class="s3">\n  </span><span class="s1">constructor(requestHeaders) {</span><span class="s3">\n    </span><span class="s1">/** @internal */</span><span class="s3">\n    </span><span class="s1">this._parsed = /* @__PURE__ */ new Map();</span><span class="s3">\n    </span><span class="s1">this._headers = requestHeaders;</span><span class="s3">\n    </span><span class="s1">const header = requestHeaders.get(</span><span class="s3">\&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (header) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseCookie(header);</span><span class="s3">\n      </span><span class="s1">for (const [name, value] of parsed) {</span><span class="s3">\n        </span><span class="s1">this._parsed.set(name, { name, value });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[Symbol.iterator]() {</span><span class="s3">\n    </span><span class="s1">return this._parsed[Symbol.iterator]();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The amount of cookies received from the client</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get size() {</span><span class="s3">\n    </span><span class="s1">return this._parsed.size;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">get(...args) {</span><span class="s3">\n    </span><span class="s1">const name = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : args[0].name;</span><span class="s3">\n    </span><span class="s1">return this._parsed.get(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">getAll(...args) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const all = Array.from(this._parsed);</span><span class="s3">\n    </span><span class="s1">if (!args.length) {</span><span class="s3">\n      </span><span class="s1">return all.map(([_, value]) =&gt; value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const name = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : (_a = args[0]) == null ? void 0 : _a.name;</span><span class="s3">\n    </span><span class="s1">return all.filter(([n]) =&gt; n === name).map(([_, value]) =&gt; value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">has(name) {</span><span class="s3">\n    </span><span class="s1">return this._parsed.has(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">set(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">map.set(name, { name, value });</span><span class="s3">\n    </span><span class="s1">this._headers.set(</span><span class="s3">\n      \&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">Array.from(map).map(([_, value2]) =&gt; stringifyCookie(value2)).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Delete the cookies matching the passed name or names in the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete(names) {</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">const result = !Array.isArray(names) ? map.delete(names) : names.map((name) =&gt; map.delete(name));</span><span class="s3">\n    </span><span class="s1">this._headers.set(</span><span class="s3">\n      \&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">Array.from(map).map(([_, value]) =&gt; stringifyCookie(value)).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Delete all the cookies in the cookies in the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clear() {</span><span class="s3">\n    </span><span class="s1">this.delete(Array.from(this._parsed.keys()));</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Format the cookies in the request as a string for logging</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">edge-runtime.inspect.custom</span><span class="s3">\&quot;</span><span class="s1">)]() {</span><span class="s3">\n    </span><span class="s1">return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return [...this._parsed.values()].map((v) =&gt; `${v.name}=${encodeURIComponent(v.value)}`).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/response-cookies.ts</span><span class="s3">\n</span><span class="s1">var ResponseCookies = class {</span><span class="s3">\n  </span><span class="s1">constructor(responseHeaders) {</span><span class="s3">\n    </span><span class="s1">/** @internal */</span><span class="s3">\n    </span><span class="s1">this._parsed = /* @__PURE__ */ new Map();</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n    </span><span class="s1">this._headers = responseHeaders;</span><span class="s3">\n    </span><span class="s1">const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">)) != null ? _c : [];</span><span class="s3">\n    </span><span class="s1">const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);</span><span class="s3">\n    </span><span class="s1">for (const cookieString of cookieStrings) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseSetCookie(cookieString);</span><span class="s3">\n      </span><span class="s1">if (parsed)</span><span class="s3">\n        </span><span class="s1">this._parsed.set(parsed.name, parsed);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get(...args) {</span><span class="s3">\n    </span><span class="s1">const key = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : args[0].name;</span><span class="s3">\n    </span><span class="s1">return this._parsed.get(key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getAll(...args) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const all = Array.from(this._parsed.values());</span><span class="s3">\n    </span><span class="s1">if (!args.length) {</span><span class="s3">\n      </span><span class="s1">return all;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const key = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : (_a = args[0]) == null ? void 0 : _a.name;</span><span class="s3">\n    </span><span class="s1">return all.filter((c) =&gt; c.name === key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">has(name) {</span><span class="s3">\n    </span><span class="s1">return this._parsed.has(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">set(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">map.set(name, normalizeCookie({ name, value, ...cookie }));</span><span class="s3">\n    </span><span class="s1">replace(map, this._headers);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, options] = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? [args[0]] : [args[0].name, args[0]];</span><span class="s3">\n    </span><span class="s1">return this.set({ ...options, name, value: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, expires: /* @__PURE__ */ new Date(0) });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">edge-runtime.inspect.custom</span><span class="s3">\&quot;</span><span class="s1">)]() {</span><span class="s3">\n    </span><span class="s1">return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return [...this._parsed.values()].map(stringifyCookie).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function replace(bag, headers) {</span><span class="s3">\n  </span><span class="s1">headers.delete(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">for (const [, value] of bag) {</span><span class="s3">\n    </span><span class="s1">const serialized = stringifyCookie(value);</span><span class="s3">\n    </span><span class="s1">headers.append(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">, serialized);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function normalizeCookie(cookie = { name: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, value: </span><span class="s3">\&quot;\&quot; </span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">if (typeof cookie.expires === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">cookie.expires = new Date(cookie.expires);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (cookie.maxAge) {</span><span class="s3">\n    </span><span class="s1">cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (cookie.path === null || cookie.path === void 0) {</span><span class="s3">\n    </span><span class="s1">cookie.path = </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cookie;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Annotate the CommonJS export names for ESM import in node:</span><span class="s3">\n</span><span class="s1">0 &amp;&amp; (module.exports = {</span><span class="s3">\n  </span><span class="s1">RequestCookies,</span><span class="s3">\n  </span><span class="s1">ResponseCookies,</span><span class="s3">\n  </span><span class="s1">parseCookie,</span><span class="s3">\n  </span><span class="s1">parseSetCookie,</span><span class="s3">\n  </span><span class="s1">stringifyCookie</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var e={};(()=&gt;{var r=e;</span><span class="s3">\n</span><span class="s1">/*!</span><span class="s3">\n </span><span class="s1">* cookie</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2012-2014 Roman Shtylman</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2015 Douglas Christopher Wilson</span><span class="s3">\n </span><span class="s1">* MIT Licensed</span><span class="s3">\n </span><span class="s1">*/r.parse=parse;r.serialize=serialize;var i=decodeURIComponent;var t=encodeURIComponent;var a=/; */;var n=/^[</span><span class="s3">\\</span><span class="s1">u0009</span><span class="s3">\\</span><span class="s1">u0020-</span><span class="s3">\\</span><span class="s1">u007e</span><span class="s3">\\</span><span class="s1">u0080-</span><span class="s3">\\</span><span class="s1">u00ff]+$/;function parse(e,r){if(typeof e!==</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument str must be a string</span><span class="s3">\&quot;</span><span class="s1">)}var t={};var n=r||{};var o=e.split(a);var s=n.decode||i;for(var p=0;p&lt;o.length;p++){var f=o[p];var u=f.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);if(u&lt;0){continue}var v=f.substr(0,u).trim();var c=f.substr(++u,f.length).trim();if('</span><span class="s3">\&quot;</span><span class="s1">'==c[0]){c=c.slice(1,-1)}if(undefined==t[v]){t[v]=tryDecode(c,s)}}return t}function serialize(e,r,i){var a=i||{};var o=a.encode||t;if(typeof o!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option encode is invalid</span><span class="s3">\&quot;</span><span class="s1">)}if(!n.test(e)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument name is invalid</span><span class="s3">\&quot;</span><span class="s1">)}var s=o(r);if(s&amp;&amp;!n.test(s)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument val is invalid</span><span class="s3">\&quot;</span><span class="s1">)}var p=e+</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">+s;if(null!=a.maxAge){var f=a.maxAge-0;if(isNaN(f)||!isFinite(f)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option maxAge is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Max-Age=</span><span class="s3">\&quot;</span><span class="s1">+Math.floor(f)}if(a.domain){if(!n.test(a.domain)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option domain is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Domain=</span><span class="s3">\&quot;</span><span class="s1">+a.domain}if(a.path){if(!n.test(a.path)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option path is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Path=</span><span class="s3">\&quot;</span><span class="s1">+a.path}if(a.expires){if(typeof a.expires.toUTCString!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option expires is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Expires=</span><span class="s3">\&quot;</span><span class="s1">+a.expires.toUTCString()}if(a.httpOnly){p+=</span><span class="s3">\&quot;</span><span class="s1">; HttpOnly</span><span class="s3">\&quot;</span><span class="s1">}if(a.secure){p+=</span><span class="s3">\&quot;</span><span class="s1">; Secure</span><span class="s3">\&quot;</span><span class="s1">}if(a.sameSite){var u=typeof a.sameSite===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?a.sameSite.toLowerCase():a.sameSite;switch(u){case true:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">lax</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Lax</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=None</span><span class="s3">\&quot;</span><span class="s1">;break;default:throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option sameSite is invalid</span><span class="s3">\&quot;</span><span class="s1">)}}return p}function tryDecode(e,r){try{return r(e)}catch(r){return e}}})();module.exports=e})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;var e={695:e=&gt;{</span><span class="s3">\n</span><span class="s1">/*!</span><span class="s3">\n </span><span class="s1">* fresh</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2012 TJ Holowaychuk</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2016-2017 Douglas Christopher Wilson</span><span class="s3">\n </span><span class="s1">* MIT Licensed</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var r=/(?:^|,)</span><span class="s3">\\</span><span class="s1">s*?no-cache</span><span class="s3">\\</span><span class="s1">s*?(?:,|$)/;e.exports=fresh;function fresh(e,a){var t=e[</span><span class="s3">\&quot;</span><span class="s1">if-modified-since</span><span class="s3">\&quot;</span><span class="s1">];var s=e[</span><span class="s3">\&quot;</span><span class="s1">if-none-match</span><span class="s3">\&quot;</span><span class="s1">];if(!t&amp;&amp;!s){return false}var i=e[</span><span class="s3">\&quot;</span><span class="s1">cache-control</span><span class="s3">\&quot;</span><span class="s1">];if(i&amp;&amp;r.test(i)){return false}if(s&amp;&amp;s!==</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){var f=a[</span><span class="s3">\&quot;</span><span class="s1">etag</span><span class="s3">\&quot;</span><span class="s1">];if(!f){return false}var n=true;var u=parseTokenList(s);for(var _=0;_&lt;u.length;_++){var o=u[_];if(o===f||o===</span><span class="s3">\&quot;</span><span class="s1">W/</span><span class="s3">\&quot;</span><span class="s1">+f||</span><span class="s3">\&quot;</span><span class="s1">W/</span><span class="s3">\&quot;</span><span class="s1">+o===f){n=false;break}}if(n){return false}}if(t){var p=a[</span><span class="s3">\&quot;</span><span class="s1">last-modified</span><span class="s3">\&quot;</span><span class="s1">];var v=!p||!(parseHttpDate(p)&lt;=parseHttpDate(t));if(v){return false}}return true}function parseHttpDate(e){var r=e&amp;&amp;Date.parse(e);return typeof r===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">?r:NaN}function parseTokenList(e){var r=0;var a=[];var t=0;for(var s=0,i=e.length;s&lt;i;s++){switch(e.charCodeAt(s)){case 32:if(t===r){t=r=s+1}break;case 44:a.push(e.substring(t,r));t=r=s+1;break;default:r=s+1;break}}a.push(e.substring(t,r));return a}}};var r={};function __nccwpck_require__(a){var t=r[a];if(t!==undefined){return t.exports}var s=r[a]={exports:{}};var i=true;try{e[a](s,s.exports,__nccwpck_require__);i=false}finally{if(i)delete r[a]}return s.exports}if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var a=__nccwpck_require__(695);module.exports=a})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;var e={993:e=&gt;{var t=Object.prototype.hasOwnProperty,n=</span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">;function Events(){}if(Object.create){Events.prototype=Object.create(null);if(!(new Events).__proto__)n=false}function EE(e,t,n){this.fn=e;this.context=t;this.once=n||false}function addListener(e,t,r,i,s){if(typeof r!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">The listener must be a function</span><span class="s3">\&quot;</span><span class="s1">)}var o=new EE(r,i||e,s),u=n?n+t:t;if(!e._events[u])e._events[u]=o,e._eventsCount++;else if(!e._events[u].fn)e._events[u].push(o);else e._events[u]=[e._events[u],o];return e}function clearEvent(e,t){if(--e._eventsCount===0)e._events=new Events;else delete e._events[t]}function EventEmitter(){this._events=new Events;this._eventsCount=0}EventEmitter.prototype.eventNames=function eventNames(){var e=[],r,i;if(this._eventsCount===0)return e;for(i in r=this._events){if(t.call(r,i))e.push(n?i.slice(1):i)}if(Object.getOwnPropertySymbols){return e.concat(Object.getOwnPropertySymbols(r))}return e};EventEmitter.prototype.listeners=function listeners(e){var t=n?n+e:e,r=this._events[t];if(!r)return[];if(r.fn)return[r.fn];for(var i=0,s=r.length,o=new Array(s);i&lt;s;i++){o[i]=r[i].fn}return o};EventEmitter.prototype.listenerCount=function listenerCount(e){var t=n?n+e:e,r=this._events[t];if(!r)return 0;if(r.fn)return 1;return r.length};EventEmitter.prototype.emit=function emit(e,t,r,i,s,o){var u=n?n+e:e;if(!this._events[u])return false;var a=this._events[u],l=arguments.length,c,h;if(a.fn){if(a.once)this.removeListener(e,a.fn,undefined,true);switch(l){case 1:return a.fn.call(a.context),true;case 2:return a.fn.call(a.context,t),true;case 3:return a.fn.call(a.context,t,r),true;case 4:return a.fn.call(a.context,t,r,i),true;case 5:return a.fn.call(a.context,t,r,i,s),true;case 6:return a.fn.call(a.context,t,r,i,s,o),true}for(h=1,c=new Array(l-1);h&lt;l;h++){c[h-1]=arguments[h]}a.fn.apply(a.context,c)}else{var _=a.length,f;for(h=0;h&lt;_;h++){if(a[h].once)this.removeListener(e,a[h].fn,undefined,true);switch(l){case 1:a[h].fn.call(a[h].context);break;case 2:a[h].fn.call(a[h].context,t);break;case 3:a[h].fn.call(a[h].context,t,r);break;case 4:a[h].fn.call(a[h].context,t,r,i);break;default:if(!c)for(f=1,c=new Array(l-1);f&lt;l;f++){c[f-1]=arguments[f]}a[h].fn.apply(a[h].context,c)}}}return true};EventEmitter.prototype.on=function on(e,t,n){return addListener(this,e,t,n,false)};EventEmitter.prototype.once=function once(e,t,n){return addListener(this,e,t,n,true)};EventEmitter.prototype.removeListener=function removeListener(e,t,r,i){var s=n?n+e:e;if(!this._events[s])return this;if(!t){clearEvent(this,s);return this}var o=this._events[s];if(o.fn){if(o.fn===t&amp;&amp;(!i||o.once)&amp;&amp;(!r||o.context===r)){clearEvent(this,s)}}else{for(var u=0,a=[],l=o.length;u&lt;l;u++){if(o[u].fn!==t||i&amp;&amp;!o[u].once||r&amp;&amp;o[u].context!==r){a.push(o[u])}}if(a.length)this._events[s]=a.length===1?a[0]:a;else clearEvent(this,s)}return this};EventEmitter.prototype.removeAllListeners=function removeAllListeners(e){var t;if(e){t=n?n+e:e;if(this._events[t])clearEvent(this,t)}else{this._events=new Events;this._eventsCount=0}return this};EventEmitter.prototype.off=EventEmitter.prototype.removeListener;EventEmitter.prototype.addListener=EventEmitter.prototype.on;EventEmitter.prefixed=n;EventEmitter.EventEmitter=EventEmitter;if(true){e.exports=EventEmitter}},213:e=&gt;{e.exports=(e,t)=&gt;{t=t||(()=&gt;{});return e.then((e=&gt;new Promise((e=&gt;{e(t())})).then((()=&gt;e))),(e=&gt;new Promise((e=&gt;{e(t())})).then((()=&gt;{throw e}))))}},574:(e,t)=&gt;{Object.defineProperty(t,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});function lowerBound(e,t,n){let r=0;let i=e.length;while(i&gt;0){const s=i/2|0;let o=r+s;if(n(e[o],t)&lt;=0){r=++o;i-=s+1}else{i=s}}return r}t[</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">]=lowerBound},821:(e,t,n)=&gt;{Object.defineProperty(t,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});const r=n(574);class PriorityQueue{constructor(){this._queue=[]}enqueue(e,t){t=Object.assign({priority:0},t);const n={priority:t.priority,run:e};if(this.size&amp;&amp;this._queue[this.size-1].priority&gt;=t.priority){this._queue.push(n);return}const i=r.default(this._queue,n,((e,t)=&gt;t.priority-e.priority));this._queue.splice(i,0,n)}dequeue(){const e=this._queue.shift();return e===null||e===void 0?void 0:e.run}filter(e){return this._queue.filter((t=&gt;t.priority===e.priority)).map((e=&gt;e.run))}get size(){return this._queue.length}}t[</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">]=PriorityQueue},816:(e,t,n)=&gt;{const r=n(213);class TimeoutError extends Error{constructor(e){super(e);this.name=</span><span class="s3">\&quot;</span><span class="s1">TimeoutError</span><span class="s3">\&quot;</span><span class="s1">}}const pTimeout=(e,t,n)=&gt;new Promise(((i,s)=&gt;{if(typeof t!==</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||t&lt;0){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Expected `milliseconds` to be a positive number</span><span class="s3">\&quot;</span><span class="s1">)}if(t===Infinity){i(e);return}const o=setTimeout((()=&gt;{if(typeof n===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){try{i(n())}catch(e){s(e)}return}const r=typeof n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?n:`Promise timed out after ${t} milliseconds`;const o=n instanceof Error?n:new TimeoutError(r);if(typeof e.cancel===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){e.cancel()}s(o)}),t);r(e.then(i,s),(()=&gt;{clearTimeout(o)}))}));e.exports=pTimeout;e.exports[</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">]=pTimeout;e.exports.TimeoutError=TimeoutError}};var t={};function __nccwpck_require__(n){var r=t[n];if(r!==undefined){return r.exports}var i=t[n]={exports:{}};var s=true;try{e[n](i,i.exports,__nccwpck_require__);s=false}finally{if(s)delete t[n]}return i.exports}if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var n={};(()=&gt;{var e=n;Object.defineProperty(e,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});const t=__nccwpck_require__(993);const r=__nccwpck_require__(816);const i=__nccwpck_require__(821);const empty=()=&gt;{};const s=new r.TimeoutError;class PQueue extends t{constructor(e){var t,n,r,s;super();this._intervalCount=0;this._intervalEnd=0;this._pendingCount=0;this._resolveEmpty=empty;this._resolveIdle=empty;e=Object.assign({carryoverConcurrencyCount:false,intervalCap:Infinity,interval:0,concurrency:Infinity,autoStart:true,queueClass:i.default},e);if(!(typeof e.intervalCap===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;e.intervalCap&gt;=1)){throw new TypeError(`Expected </span><span class="s3">\\</span><span class="s1">`intervalCap</span><span class="s3">\\</span><span class="s1">` to be a number from 1 and up, got </span><span class="s3">\\</span><span class="s1">`${(n=(t=e.intervalCap)===null||t===void 0?void 0:t.toString())!==null&amp;&amp;n!==void 0?n:</span><span class="s3">\&quot;\&quot;</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">` (${typeof e.intervalCap})`)}if(e.interval===undefined||!(Number.isFinite(e.interval)&amp;&amp;e.interval&gt;=0)){throw new TypeError(`Expected </span><span class="s3">\\</span><span class="s1">`interval</span><span class="s3">\\</span><span class="s1">` to be a finite number &gt;= 0, got </span><span class="s3">\\</span><span class="s1">`${(s=(r=e.interval)===null||r===void 0?void 0:r.toString())!==null&amp;&amp;s!==void 0?s:</span><span class="s3">\&quot;\&quot;</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">` (${typeof e.interval})`)}this._carryoverConcurrencyCount=e.carryoverConcurrencyCount;this._isIntervalIgnored=e.intervalCap===Infinity||e.interval===0;this._intervalCap=e.intervalCap;this._interval=e.interval;this._queue=new e.queueClass;this._queueClass=e.queueClass;this.concurrency=e.concurrency;this._timeout=e.timeout;this._throwOnTimeout=e.throwOnTimeout===true;this._isPaused=e.autoStart===false}get _doesIntervalAllowAnother(){return this._isIntervalIgnored||this._intervalCount&lt;this._intervalCap}get _doesConcurrentAllowAnother(){return this._pendingCount&lt;this._concurrency}_next(){this._pendingCount--;this._tryToStartAnother();this.emit(</span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">)}_resolvePromises(){this._resolveEmpty();this._resolveEmpty=empty;if(this._pendingCount===0){this._resolveIdle();this._resolveIdle=empty;this.emit(</span><span class="s3">\&quot;</span><span class="s1">idle</span><span class="s3">\&quot;</span><span class="s1">)}}_onResumeInterval(){this._onInterval();this._initializeIntervalIfNeeded();this._timeoutId=undefined}_isIntervalPaused(){const e=Date.now();if(this._intervalId===undefined){const t=this._intervalEnd-e;if(t&lt;0){this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0}else{if(this._timeoutId===undefined){this._timeoutId=setTimeout((()=&gt;{this._onResumeInterval()}),t)}return true}}return false}_tryToStartAnother(){if(this._queue.size===0){if(this._intervalId){clearInterval(this._intervalId)}this._intervalId=undefined;this._resolvePromises();return false}if(!this._isPaused){const e=!this._isIntervalPaused();if(this._doesIntervalAllowAnother&amp;&amp;this._doesConcurrentAllowAnother){const t=this._queue.dequeue();if(!t){return false}this.emit(</span><span class="s3">\&quot;</span><span class="s1">active</span><span class="s3">\&quot;</span><span class="s1">);t();if(e){this._initializeIntervalIfNeeded()}return true}}return false}_initializeIntervalIfNeeded(){if(this._isIntervalIgnored||this._intervalId!==undefined){return}this._intervalId=setInterval((()=&gt;{this._onInterval()}),this._interval);this._intervalEnd=Date.now()+this._interval}_onInterval(){if(this._intervalCount===0&amp;&amp;this._pendingCount===0&amp;&amp;this._intervalId){clearInterval(this._intervalId);this._intervalId=undefined}this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0;this._processQueue()}_processQueue(){while(this._tryToStartAnother()){}}get concurrency(){return this._concurrency}set concurrency(e){if(!(typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;e&gt;=1)){throw new TypeError(`Expected </span><span class="s3">\\</span><span class="s1">`concurrency</span><span class="s3">\\</span><span class="s1">` to be a number from 1 and up, got </span><span class="s3">\\</span><span class="s1">`${e}</span><span class="s3">\\</span><span class="s1">` (${typeof e})`)}this._concurrency=e;this._processQueue()}async add(e,t={}){return new Promise(((n,i)=&gt;{const run=async()=&gt;{this._pendingCount++;this._intervalCount++;try{const o=this._timeout===undefined&amp;&amp;t.timeout===undefined?e():r.default(Promise.resolve(e()),t.timeout===undefined?this._timeout:t.timeout,(()=&gt;{if(t.throwOnTimeout===undefined?this._throwOnTimeout:t.throwOnTimeout){i(s)}return undefined}));n(await o)}catch(e){i(e)}this._next()};this._queue.enqueue(run,t);this._tryToStartAnother();this.emit(</span><span class="s3">\&quot;</span><span class="s1">add</span><span class="s3">\&quot;</span><span class="s1">)}))}async addAll(e,t){return Promise.all(e.map((async e=&gt;this.add(e,t))))}start(){if(!this._isPaused){return this}this._isPaused=false;this._processQueue();return this}pause(){this._isPaused=true}clear(){this._queue=new this._queueClass}async onEmpty(){if(this._queue.size===0){return}return new Promise((e=&gt;{const t=this._resolveEmpty;this._resolveEmpty=()=&gt;{t();e()}}))}async onIdle(){if(this._pendingCount===0&amp;&amp;this._queue.size===0){return}return new Promise((e=&gt;{const t=this._resolveIdle;this._resolveIdle=()=&gt;{t();e()}}))}get size(){return this._queue.size}sizeBy(e){return this._queue.filter(e).length}get pending(){return this._pendingCount}get isPaused(){return this._isPaused}get timeout(){return this._timeout}set timeout(e){this._timeout=e}}e[</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">]=PQueue})();module.exports=n})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var e={};(()=&gt;{var n=e;Object.defineProperty(n,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});n.pathToRegexp=n.tokensToRegexp=n.regexpToFunction=n.match=n.tokensToFunction=n.compile=n.parse=void 0;function lexer(e){var n=[];var r=0;while(r&lt;e.length){var t=e[r];if(t===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||t===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||t===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">,index:r++,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">OPEN</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">CLOSE</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">){var a=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var i=r+1;while(i&lt;e.length){var o=e.charCodeAt(i);if(o&gt;=48&amp;&amp;o&lt;=57||o&gt;=65&amp;&amp;o&lt;=90||o&gt;=97&amp;&amp;o&lt;=122||o===95){a+=e[i++];continue}break}if(!a)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Missing parameter name at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));n.push({type:</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:a});r=i;continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">){var c=1;var f=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var i=r+1;if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError('Pattern cannot start with </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">at '.concat(i))}while(i&lt;e.length){if(e[i]===</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">){f+=e[i++]+e[i++];continue}if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">){c--;if(c===0){i++;break}}else if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">){c++;if(e[i+1]!==</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Capturing groups are not allowed at </span><span class="s3">\&quot;</span><span class="s1">.concat(i))}}f+=e[i++]}if(c)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Unbalanced pattern at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));if(!f)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Missing pattern at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));n.push({type:</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:f});r=i;continue}n.push({type:</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]})}n.push({type:</span><span class="s3">\&quot;</span><span class="s1">END</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:</span><span class="s3">\&quot;\&quot;</span><span class="s1">});return n}function parse(e,n){if(n===void 0){n={}}var r=lexer(e);var t=n.prefixes,a=t===void 0?</span><span class="s3">\&quot;</span><span class="s1">./</span><span class="s3">\&quot;</span><span class="s1">:t,i=n.delimiter,o=i===void 0?</span><span class="s3">\&quot;</span><span class="s1">/#?</span><span class="s3">\&quot;</span><span class="s1">:i;var c=[];var f=0;var u=0;var p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var tryConsume=function(e){if(u&lt;r.length&amp;&amp;r[u].type===e)return r[u++].value};var mustConsume=function(e){var n=tryConsume(e);if(n!==undefined)return n;var t=r[u],a=t.type,i=t.index;throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Unexpected </span><span class="s3">\&quot;</span><span class="s1">.concat(a,</span><span class="s3">\&quot; </span><span class="s1">at </span><span class="s3">\&quot;</span><span class="s1">).concat(i,</span><span class="s3">\&quot;</span><span class="s1">, expected </span><span class="s3">\&quot;</span><span class="s1">).concat(e))};var consumeText=function(){var e=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var n;while(n=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">)||tryConsume(</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">)){e+=n}return e};var isSafe=function(e){for(var n=0,r=o;n&lt;r.length;n++){var t=r[n];if(e.indexOf(t)&gt;-1)return true}return false};var safePattern=function(e){var n=c[c.length-1];var r=e||(n&amp;&amp;typeof n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?n:</span><span class="s3">\&quot;\&quot;</span><span class="s1">);if(n&amp;&amp;!r){throw new TypeError('Must have text between two parameters, missing text after </span><span class="s3">\&quot;</span><span class="s1">'.concat(n.name,'</span><span class="s3">\&quot;</span><span class="s1">'))}if(!r||isSafe(r))return</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(o),</span><span class="s3">\&quot;</span><span class="s1">]+?</span><span class="s3">\&quot;</span><span class="s1">);return</span><span class="s3">\&quot;</span><span class="s1">(?:(?!</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(r),</span><span class="s3">\&quot;</span><span class="s1">)[^</span><span class="s3">\&quot;</span><span class="s1">).concat(escapeString(o),</span><span class="s3">\&quot;</span><span class="s1">])+?</span><span class="s3">\&quot;</span><span class="s1">)};while(u&lt;r.length){var v=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">);var s=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">);var d=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">);if(s||d){var g=v||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;if(a.indexOf(g)===-1){p+=g;g=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}if(p){c.push(p);p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}c.push({name:s||f++,prefix:g,suffix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,pattern:d||safePattern(g),modifier:tryConsume(</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">});continue}var x=v||tryConsume(</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">);if(x){p+=x;continue}if(p){c.push(p);p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}var h=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">OPEN</span><span class="s3">\&quot;</span><span class="s1">);if(h){var g=consumeText();var l=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var m=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var T=consumeText();mustConsume(</span><span class="s3">\&quot;</span><span class="s1">CLOSE</span><span class="s3">\&quot;</span><span class="s1">);c.push({name:l||(m?f++:</span><span class="s3">\&quot;\&quot;</span><span class="s1">),pattern:l&amp;&amp;!m?safePattern(g):m,prefix:g,suffix:T,modifier:tryConsume(</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">});continue}mustConsume(</span><span class="s3">\&quot;</span><span class="s1">END</span><span class="s3">\&quot;</span><span class="s1">)}return c}n.parse=parse;function compile(e,n){return tokensToFunction(parse(e,n),n)}n.compile=compile;function tokensToFunction(e,n){if(n===void 0){n={}}var r=flags(n);var t=n.encode,a=t===void 0?function(e){return e}:t,i=n.validate,o=i===void 0?true:i;var c=e.map((function(e){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">){return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(e.pattern,</span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">),r)}}));return function(n){var r=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(var t=0;t&lt;e.length;t++){var i=e[t];if(typeof i===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){r+=i;continue}var f=n?n[i.name]:undefined;var u=i.modifier===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">||i.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">;var p=i.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||i.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">;if(Array.isArray(f)){if(!p){throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to not repeat, but got an array'))}if(f.length===0){if(u)continue;throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to not be empty'))}for(var v=0;v&lt;f.length;v++){var s=a(f[v],i);if(o&amp;&amp;!c[t].test(s)){throw new TypeError('Expected all </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to match </span><span class="s3">\&quot;</span><span class="s1">').concat(i.pattern,'</span><span class="s3">\&quot;</span><span class="s1">, but got </span><span class="s3">\&quot;</span><span class="s1">').concat(s,'</span><span class="s3">\&quot;</span><span class="s1">'))}r+=i.prefix+s+i.suffix}continue}if(typeof f===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||typeof f===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">){var s=a(String(f),i);if(o&amp;&amp;!c[t].test(s)){throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to match </span><span class="s3">\&quot;</span><span class="s1">').concat(i.pattern,'</span><span class="s3">\&quot;</span><span class="s1">, but got </span><span class="s3">\&quot;</span><span class="s1">').concat(s,'</span><span class="s3">\&quot;</span><span class="s1">'))}r+=i.prefix+s+i.suffix;continue}if(u)continue;var d=p?</span><span class="s3">\&quot;</span><span class="s1">an array</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">a string</span><span class="s3">\&quot;</span><span class="s1">;throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to be ').concat(d))}return r}}n.tokensToFunction=tokensToFunction;function match(e,n){var r=[];var t=pathToRegexp(e,r,n);return regexpToFunction(t,r,n)}n.match=match;function regexpToFunction(e,n,r){if(r===void 0){r={}}var t=r.decode,a=t===void 0?function(e){return e}:t;return function(r){var t=e.exec(r);if(!t)return false;var i=t[0],o=t.index;var c=Object.create(null);var _loop_1=function(e){if(t[e]===undefined)return</span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">;var r=n[e-1];if(r.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||r.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">){c[r.name]=t[e].split(r.prefix+r.suffix).map((function(e){return a(e,r)}))}else{c[r.name]=a(t[e],r)}};for(var f=1;f&lt;t.length;f++){_loop_1(f)}return{path:i,index:o,params:c}}}n.regexpToFunction=regexpToFunction;function escapeString(e){return e.replace(/([.+*?=^!:${}()[</span><span class="s3">\\</span><span class="s1">]|/</span><span class="s3">\\\\</span><span class="s1">])/g,</span><span class="s3">\&quot;\\\\</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)}function flags(e){return e&amp;&amp;e.sensitive?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">}function regexpToRegexp(e,n){if(!n)return e;var r=/</span><span class="s3">\\</span><span class="s1">((?:</span><span class="s3">\\</span><span class="s1">?&lt;(.*?)&gt;)?(?!</span><span class="s3">\\</span><span class="s1">?)/g;var t=0;var a=r.exec(e.source);while(a){n.push({name:a[1]||t++,prefix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,suffix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,modifier:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,pattern:</span><span class="s3">\&quot;\&quot;</span><span class="s1">});a=r.exec(e.source)}return e}function arrayToRegexp(e,n,r){var t=e.map((function(e){return pathToRegexp(e,n,r).source}));return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(t.join(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">),flags(r))}function stringToRegexp(e,n,r){return tokensToRegexp(parse(e,r),n,r)}function tokensToRegexp(e,n,r){if(r===void 0){r={}}var t=r.strict,a=t===void 0?false:t,i=r.start,o=i===void 0?true:i,c=r.end,f=c===void 0?true:c,u=r.encode,p=u===void 0?function(e){return e}:u,v=r.delimiter,s=v===void 0?</span><span class="s3">\&quot;</span><span class="s1">/#?</span><span class="s3">\&quot;</span><span class="s1">:v,d=r.endsWith,g=d===void 0?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:d;var x=</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(g),</span><span class="s3">\&quot;</span><span class="s1">]|$</span><span class="s3">\&quot;</span><span class="s1">);var h=</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(s),</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);var l=o?</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(var m=0,T=e;m&lt;T.length;m++){var E=T[m];if(typeof E===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){l+=escapeString(p(E))}else{var w=escapeString(p(E.prefix));var y=escapeString(p(E.suffix));if(E.pattern){if(n)n.push(E);if(w||y){if(E.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){var R=E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;\&quot;</span><span class="s1">;l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w,</span><span class="s3">\&quot;</span><span class="s1">((?:</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)(?:</span><span class="s3">\&quot;</span><span class="s1">).concat(y).concat(w,</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">))*)</span><span class="s3">\&quot;</span><span class="s1">).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(R)}else{l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w,</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}else{if(E.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError('Can not repeat </span><span class="s3">\&quot;</span><span class="s1">'.concat(E.name,'</span><span class="s3">\&quot; </span><span class="s1">without a prefix and suffix'))}l+=</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">.concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}else{l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}}if(f){if(!a)l+=</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);l+=!r.endsWith?</span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">.concat(x,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)}else{var A=e[e.length-1];var _=typeof A===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?h.indexOf(A[A.length-1])&gt;-1:A===undefined;if(!a){l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">).concat(x,</span><span class="s3">\&quot;</span><span class="s1">))?</span><span class="s3">\&quot;</span><span class="s1">)}if(!_){l+=</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">).concat(x,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)}}return new RegExp(l,flags(r))}n.tokensToRegexp=tokensToRegexp;function pathToRegexp(e,n,r){if(e instanceof RegExp)return regexpToRegexp(e,n);if(Array.isArray(e))return arrayToRegexp(e,n,r);return stringToRegexp(e,n,r)}n.pathToRegexp=pathToRegexp})();module.exports=e})();&quot;</span><span class="s0">,</span><span class="s1">&quot;// This file should be imported before any others. It sets up the environment</span><span class="s3">\n</span><span class="s1">// for later imports to work properly.</span><span class="s3">\n\n</span><span class="s1">// expose AsyncLocalStorage on global for react usage if it isn't already provided by the environment</span><span class="s3">\n</span><span class="s1">if (typeof (globalThis as any).AsyncLocalStorage !== 'function') {</span><span class="s3">\n  </span><span class="s1">const { AsyncLocalStorage } =</span><span class="s3">\n    </span><span class="s1">require('async_hooks') as typeof import('async_hooks')</span><span class="s3">\n  </span><span class="s1">;(globalThis as any).AsyncLocalStorage = AsyncLocalStorage</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">if (typeof (globalThis as any).WebSocket !== 'function') {</span><span class="s3">\n  </span><span class="s1">Object.defineProperty(globalThis, 'WebSocket', {</span><span class="s3">\n    </span><span class="s1">configurable: true,</span><span class="s3">\n    </span><span class="s1">get() {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">require('next/dist/compiled/ws') as typeof import('next/dist/compiled/ws')</span><span class="s3">\n      </span><span class="s1">).WebSocket</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set(value) {</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(globalThis, 'WebSocket', {</span><span class="s3">\n        </span><span class="s1">configurable: true,</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Polyfill crypto() in the Node.js environment</span><span class="s3">\n\n</span><span class="s1">if (!global.crypto) {</span><span class="s3">\n  </span><span class="s1">let webcrypto: Crypto | undefined</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(global, 'crypto', {</span><span class="s3">\n    </span><span class="s1">enumerable: false,</span><span class="s3">\n    </span><span class="s1">configurable: true,</span><span class="s3">\n    </span><span class="s1">get() {</span><span class="s3">\n      </span><span class="s1">if (!webcrypto) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error -- TODO: Is this actually safe?</span><span class="s3">\n        </span><span class="s1">webcrypto = (require('node:crypto') as typeof import('node:crypto'))</span><span class="s3">\n          </span><span class="s1">.webcrypto</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return webcrypto</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set(value: Crypto) {</span><span class="s3">\n      </span><span class="s1">webcrypto = value</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This module is for next.js server internal usage of path module.</span><span class="s3">\n </span><span class="s1">* It will use native path module for nodejs runtime.</span><span class="s3">\n </span><span class="s1">* It will use path-browserify polyfill for edge runtime.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let path</span><span class="s3">\n\n</span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n  </span><span class="s1">path = require('next/dist/compiled/path-browserify')</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">path = require('path')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = path</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Note: This file is JS because it's used by the taskfile-swc.js file, which is JS.</span><span class="s3">\n</span><span class="s1">// Keep file changes in sync with the corresponding `.d.ts` files.</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* These are the browser versions that support all of the following:</span><span class="s3">\n </span><span class="s1">* static import: https://caniuse.com/es6-module</span><span class="s3">\n </span><span class="s1">* dynamic import: https://caniuse.com/es6-module-dynamic-import</span><span class="s3">\n </span><span class="s1">* import.meta: https://caniuse.com/mdn-javascript_operators_import_meta</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MODERN_BROWSERSLIST_TARGET = [</span><span class="s3">\n  </span><span class="s1">'chrome 64',</span><span class="s3">\n  </span><span class="s1">'edge 79',</span><span class="s3">\n  </span><span class="s1">'firefox 67',</span><span class="s3">\n  </span><span class="s1">'opera 51',</span><span class="s3">\n  </span><span class="s1">'safari 12',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">module.exports = MODERN_BROWSERSLIST_TARGET</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{var e={318:function(e,t){(function(e,n){true?n(t):0})(this,(function(e){</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;class StructError extends TypeError{constructor(e,t){let n;const{message:r,explanation:i,...c}=e;const{path:o}=e;const a=o.length===0?r:`At path: ${o.join(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)} -- ${r}`;super(i??a);if(i!=null)this.cause=a;Object.assign(this,c);this.name=this.constructor.name;this.failures=()=&gt;n??(n=[e,...t()])}}function isIterable(e){return isObject(e)&amp;&amp;typeof e[Symbol.iterator]===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">}function isObject(e){return typeof e===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;e!=null}function isPlainObject(e){if(Object.prototype.toString.call(e)!==</span><span class="s3">\&quot;</span><span class="s1">[object Object]</span><span class="s3">\&quot;</span><span class="s1">){return false}const t=Object.getPrototypeOf(e);return t===null||t===Object.prototype}function print(e){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot;</span><span class="s1">){return e.toString()}return typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?JSON.stringify(e):`${e}`}function shiftIterator(e){const{done:t,value:n}=e.next();return t?undefined:n}function toFailure(e,t,n,r){if(e===true){return}else if(e===false){e={}}else if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){e={message:e}}const{path:i,branch:c}=t;const{type:o}=n;const{refinement:a,message:s=`Expected a value of type </span><span class="s3">\\</span><span class="s1">`${o}</span><span class="s3">\\</span><span class="s1">`${a?` with refinement </span><span class="s3">\\</span><span class="s1">`${a}</span><span class="s3">\\</span><span class="s1">``:</span><span class="s3">\&quot;\&quot;</span><span class="s1">}, but received: </span><span class="s3">\\</span><span class="s1">`${print(r)}</span><span class="s3">\\</span><span class="s1">``}=e;return{value:r,type:o,refinement:a,key:i[i.length-1],path:i,branch:c,...e,message:s}}function*toFailures(e,t,n,r){if(!isIterable(e)){e=[e]}for(const i of e){const e=toFailure(i,t,n,r);if(e){yield e}}}function*run(e,t,n={}){const{path:r=[],branch:i=[e],coerce:c=false,mask:o=false}=n;const a={path:r,branch:i};if(c){e=t.coercer(e,a);if(o&amp;&amp;t.type!==</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;isObject(t.schema)&amp;&amp;isObject(e)&amp;&amp;!Array.isArray(e)){for(const n in e){if(t.schema[n]===undefined){delete e[n]}}}}let s=</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">;for(const r of t.validator(e,a)){r.explanation=n.message;s=</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">;yield[r,undefined]}for(let[u,f,l]of t.entries(e,a)){const t=run(f,l,{path:u===undefined?r:[...r,u],branch:u===undefined?i:[...i,f],coerce:c,mask:o,message:n.message});for(const n of t){if(n[0]){s=n[0].refinement!=null?</span><span class="s3">\&quot;</span><span class="s1">not_refined</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">;yield[n[0],undefined]}else if(c){f=n[1];if(u===undefined){e=f}else if(e instanceof Map){e.set(u,f)}else if(e instanceof Set){e.add(f)}else if(isObject(e)){if(f!==undefined||u in e)e[u]=f}}}}if(s!==</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">){for(const r of t.refiner(e,a)){r.explanation=n.message;s=</span><span class="s3">\&quot;</span><span class="s1">not_refined</span><span class="s3">\&quot;</span><span class="s1">;yield[r,undefined]}}if(s===</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">){yield[undefined,e]}}class Struct{constructor(e){const{type:t,schema:n,validator:r,refiner:i,coercer:c=(e=&gt;e),entries:o=function*(){}}=e;this.type=t;this.schema=n;this.entries=o;this.coercer=c;if(r){this.validator=(e,t)=&gt;{const n=r(e,t);return toFailures(n,t,this,e)}}else{this.validator=()=&gt;[]}if(i){this.refiner=(e,t)=&gt;{const n=i(e,t);return toFailures(n,t,this,e)}}else{this.refiner=()=&gt;[]}}assert(e,t){return assert(e,this,t)}create(e,t){return create(e,this,t)}is(e){return is(e,this)}mask(e,t){return mask(e,this,t)}validate(e,t={}){return validate(e,this,t)}}function assert(e,t,n){const r=validate(e,t,{message:n});if(r[0]){throw r[0]}}function create(e,t,n){const r=validate(e,t,{coerce:true,message:n});if(r[0]){throw r[0]}else{return r[1]}}function mask(e,t,n){const r=validate(e,t,{coerce:true,mask:true,message:n});if(r[0]){throw r[0]}else{return r[1]}}function is(e,t){const n=validate(e,t);return!n[0]}function validate(e,t,n={}){const r=run(e,t,n);const i=shiftIterator(r);if(i[0]){const e=new StructError(i[0],(function*(){for(const e of r){if(e[0]){yield e[0]}}}));return[e,undefined]}else{const e=i[1];return[undefined,e]}}function assign(...e){const t=e[0].type===</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">;const n=e.map((e=&gt;e.schema));const r=Object.assign({},...n);return t?type(r):object(r)}function define(e,t){return new Struct({type:e,schema:null,validator:t})}function deprecated(e,t){return new Struct({...e,refiner:(t,n)=&gt;t===undefined||e.refiner(t,n),validator(n,r){if(n===undefined){return true}else{t(n,r);return e.validator(n,r)}}})}function dynamic(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">dynamic</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t,n){const r=e(t,n);yield*r.entries(t,n)},validator(t,n){const r=e(t,n);return r.validator(t,n)},coercer(t,n){const r=e(t,n);return r.coercer(t,n)},refiner(t,n){const r=e(t,n);return r.refiner(t,n)}})}function lazy(e){let t;return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">lazy</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n,r){t??(t=e());yield*t.entries(n,r)},validator(n,r){t??(t=e());return t.validator(n,r)},coercer(n,r){t??(t=e());return t.coercer(n,r)},refiner(n,r){t??(t=e());return t.refiner(n,r)}})}function omit(e,t){const{schema:n}=e;const r={...n};for(const e of t){delete r[e]}switch(e.type){case</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:return type(r);default:return object(r)}}function partial(e){const t=e instanceof Struct?{...e.schema}:{...e};for(const e in t){t[e]=optional(t[e])}return object(t)}function pick(e,t){const{schema:n}=e;const r={};for(const e of t){r[e]=n[e]}return object(r)}function struct(e,t){console.warn(</span><span class="s3">\&quot;</span><span class="s1">superstruct@0.11 - The `struct` helper has been renamed to `define`.</span><span class="s3">\&quot;</span><span class="s1">);return define(e,t)}function any(){return define(</span><span class="s3">\&quot;</span><span class="s1">any</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;true))}function array(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,schema:e,*entries(t){if(e&amp;&amp;Array.isArray(t)){for(const[n,r]of t.entries()){yield[n,r,e]}}},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${print(e)}`}})}function bigint(){return define(</span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">))}function boolean(){return define(</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">))}function date(){return define(</span><span class="s3">\&quot;</span><span class="s1">date</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;e instanceof Date&amp;&amp;!isNaN(e.getTime())||`Expected a valid </span><span class="s3">\\</span><span class="s1">`Date</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`))}function enums(e){const t={};const n=e.map((e=&gt;print(e))).join();for(const n of e){t[n]=n}return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">enums</span><span class="s3">\&quot;</span><span class="s1">,schema:t,validator(t){return e.includes(t)||`Expected one of </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(t)}`}})}function func(){return define(</span><span class="s3">\&quot;</span><span class="s1">func</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">||`Expected a function, but received: ${print(e)}`))}function instance(e){return define(</span><span class="s3">\&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;t instanceof e||`Expected a </span><span class="s3">\\</span><span class="s1">`${e.name}</span><span class="s3">\\</span><span class="s1">` instance, but received: ${print(t)}`))}function integer(){return define(</span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;!isNaN(e)&amp;&amp;Number.isInteger(e)||`Expected an integer, but received: ${print(e)}`))}function intersection(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">intersection</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t,n){for(const r of e){yield*r.entries(t,n)}},*validator(t,n){for(const r of e){yield*r.validator(t,n)}},*refiner(t,n){for(const r of e){yield*r.refiner(t,n)}}})}function literal(e){const t=print(e);const n=typeof e;return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">literal</span><span class="s3">\&quot;</span><span class="s1">,schema:n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||n===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||n===</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">?e:null,validator(n){return n===e||`Expected the literal </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(n)}`}})}function map(e,t){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">map</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(e&amp;&amp;t&amp;&amp;n instanceof Map){for(const[r,i]of n.entries()){yield[r,r,e];yield[r,i,t]}}},coercer(e){return e instanceof Map?new Map(e):e},validator(e){return e instanceof Map||`Expected a </span><span class="s3">\\</span><span class="s1">`Map</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`}})}function never(){return define(</span><span class="s3">\&quot;</span><span class="s1">never</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;false))}function nullable(e){return new Struct({...e,validator:(t,n)=&gt;t===null||e.validator(t,n),refiner:(t,n)=&gt;t===null||e.refiner(t,n)})}function number(){return define(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;!isNaN(e)||`Expected a number, but received: ${print(e)}`))}function object(e){const t=e?Object.keys(e):[];const n=never();return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,schema:e?e:null,*entries(r){if(e&amp;&amp;isObject(r)){const i=new Set(Object.keys(r));for(const n of t){i.delete(n);yield[n,r[n],e[n]]}for(const e of i){yield[e,r[e],n]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`},coercer(e){return isObject(e)?{...e}:e}})}function optional(e){return new Struct({...e,validator:(t,n)=&gt;t===undefined||e.validator(t,n),refiner:(t,n)=&gt;t===undefined||e.refiner(t,n)})}function record(e,t){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">record</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(isObject(n)){for(const r in n){const i=n[r];yield[r,r,e];yield[r,i,t]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`}})}function regexp(){return define(</span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;e instanceof RegExp))}function set(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t){if(e&amp;&amp;t instanceof Set){for(const n of t){yield[n,n,e]}}},coercer(e){return e instanceof Set?new Set(e):e},validator(e){return e instanceof Set||`Expected a </span><span class="s3">\\</span><span class="s1">`Set</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`}})}function string(){return define(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||`Expected a string, but received: ${print(e)}`))}function tuple(e){const t=never();return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">tuple</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(Array.isArray(n)){const r=Math.max(e.length,n.length);for(let i=0;i&lt;r;i++){yield[i,n[i],e[i]||t]}}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${print(e)}`}})}function type(e){const t=Object.keys(e);return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">,schema:e,*entries(n){if(isObject(n)){for(const r of t){yield[r,n[r],e[r]]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`},coercer(e){return isObject(e)?{...e}:e}})}function union(e){const t=e.map((e=&gt;e.type)).join(</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">);return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">union</span><span class="s3">\&quot;</span><span class="s1">,schema:null,coercer(t){for(const n of e){const[e,r]=n.validate(t,{coerce:true});if(!e){return r}}return t},validator(n,r){const i=[];for(const t of e){const[...e]=run(n,t,r);const[c]=e;if(!c[0]){return[]}else{for(const[t]of e){if(t){i.push(t)}}}}return[`Expected the value to satisfy a union of </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(n)}`,...i]}})}function unknown(){return define(</span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;true))}function coerce(e,t,n){return new Struct({...e,coercer:(r,i)=&gt;is(r,t)?e.coercer(n(r,i),i):e.coercer(r,i)})}function defaulted(e,t,n={}){return coerce(e,unknown(),(e=&gt;{const r=typeof t===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">?t():t;if(e===undefined){return r}if(!n.strict&amp;&amp;isPlainObject(e)&amp;&amp;isPlainObject(r)){const t={...e};let n=false;for(const e in r){if(t[e]===undefined){t[e]=r[e];n=true}}if(n){return t}}return e}))}function trimmed(e){return coerce(e,string(),(e=&gt;e.trim()))}function empty(e){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">empty</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;{const n=getSize(t);return n===0||`Expected an empty ${e.type} but received one with a size of </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``}))}function getSize(e){if(e instanceof Map||e instanceof Set){return e.size}else{return e.length}}function max(e,t,n={}){const{exclusive:r}=n;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">max</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;r?n&lt;t:n&lt;=t||`Expected a ${e.type} less than ${r?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">or equal to </span><span class="s3">\&quot;</span><span class="s1">}${t} but received </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``))}function min(e,t,n={}){const{exclusive:r}=n;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">min</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;r?n&gt;t:n&gt;=t||`Expected a ${e.type} greater than ${r?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">or equal to </span><span class="s3">\&quot;</span><span class="s1">}${t} but received </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``))}function nonempty(e){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">nonempty</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;{const n=getSize(t);return n&gt;0||`Expected a nonempty ${e.type} but received an empty one`}))}function pattern(e,t){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;t.test(n)||`Expected a ${e.type} matching </span><span class="s3">\\</span><span class="s1">`/${t.source}/</span><span class="s3">\\</span><span class="s1">` but received </span><span class="s3">\&quot;</span><span class="s1">${n}</span><span class="s3">\&quot;</span><span class="s1">`))}function size(e,t,n=t){const r=`Expected a ${e.type}`;const i=t===n?`of </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">``:`between </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">` and </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;{if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||e instanceof Date){return t&lt;=e&amp;&amp;e&lt;=n||`${r} ${i} but received </span><span class="s3">\\</span><span class="s1">`${e}</span><span class="s3">\\</span><span class="s1">``}else if(e instanceof Map||e instanceof Set){const{size:c}=e;return t&lt;=c&amp;&amp;c&lt;=n||`${r} with a size ${i} but received one with a size of </span><span class="s3">\\</span><span class="s1">`${c}</span><span class="s3">\\</span><span class="s1">``}else{const{length:c}=e;return t&lt;=c&amp;&amp;c&lt;=n||`${r} with a length ${i} but received one with a length of </span><span class="s3">\\</span><span class="s1">`${c}</span><span class="s3">\\</span><span class="s1">``}}))}function refine(e,t,n){return new Struct({...e,*refiner(r,i){yield*e.refiner(r,i);const c=n(r,i);const o=toFailures(c,i,e,r);for(const e of o){yield{...e,refinement:t}}}})}e.Struct=Struct;e.StructError=StructError;e.any=any;e.array=array;e.assert=assert;e.assign=assign;e.bigint=bigint;e.boolean=boolean;e.coerce=coerce;e.create=create;e.date=date;e.defaulted=defaulted;e.define=define;e.deprecated=deprecated;e.dynamic=dynamic;e.empty=empty;e.enums=enums;e.func=func;e.instance=instance;e.integer=integer;e.intersection=intersection;e.is=is;e.lazy=lazy;e.literal=literal;e.map=map;e.mask=mask;e.max=max;e.min=min;e.never=never;e.nonempty=nonempty;e.nullable=nullable;e.number=number;e.object=object;e.omit=omit;e.optional=optional;e.partial=partial;e.pattern=pattern;e.pick=pick;e.record=record;e.refine=refine;e.regexp=regexp;e.set=set;e.size=size;e.string=string;e.struct=struct;e.trimmed=trimmed;e.tuple=tuple;e.type=type;e.union=union;e.unknown=unknown;e.validate=validate}))}};if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var t={};e[318](0,t);module.exports=t})();&quot;</span><span class="s0">,</span><span class="s1">&quot;// getDefaultExport function for compatibility with non-ESM modules</span><span class="s3">\n</span><span class="s1">__webpack_require__.n = (module) =&gt; {</span><span class="s3">\n\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n\t\t</span><span class="s1">() =&gt; (module['default']) :</span><span class="s3">\n\t\t</span><span class="s1">() =&gt; (module);</span><span class="s3">\n\t</span><span class="s1">__webpack_require__.d(getter, { a: getter });</span><span class="s3">\n\t</span><span class="s1">return getter;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__.d = (exports, definition) =&gt; {</span><span class="s3">\n\t</span><span class="s1">for(var key in definition) {</span><span class="s3">\n        </span><span class="s1">if(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) {</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__.o = (obj, prop) =&gt; (Object.prototype.hasOwnProperty.call(obj, prop))&quot;</span><span class="s0">,</span><span class="s1">&quot;// define __esModule on exports</span><span class="s3">\n</span><span class="s1">__webpack_require__.r = (exports) =&gt; {</span><span class="s3">\n\t</span><span class="s1">if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {</span><span class="s3">\n\t\t</span><span class="s1">Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">Object.defineProperty(exports, '__esModule', { value: true });</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* We extend Web Crypto APIs during builds and revalidates to ensure that prerenders don't observe random bytes</span><span class="s3">\n </span><span class="s1">* When cacheComponents is enabled. Random bytes are a form of IO even if they resolve synchronously. When cacheComponents is</span><span class="s3">\n </span><span class="s1">* enabled we need to ensure that random bytes are excluded from prerenders unless they are cached.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The extensions here never error nor alter the underlying return values and thus should be transparent to callers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import { io } from './utils'</span><span class="s3">\n\n</span><span class="s1">let webCrypto: typeof crypto</span><span class="s3">\n</span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n  </span><span class="s1">webCrypto = crypto</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">if (typeof crypto === 'undefined') {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error -- TODO: Is this actually safe?</span><span class="s3">\n    </span><span class="s1">webCrypto = (require('node:crypto') as typeof import('node:crypto'))</span><span class="s3">\n      </span><span class="s1">.webcrypto</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">webCrypto = crypto</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const getRandomValuesExpression = '`crypto.getRandomValues()`'</span><span class="s3">\n</span><span class="s1">try {</span><span class="s3">\n  </span><span class="s1">const _getRandomValues = webCrypto.getRandomValues</span><span class="s3">\n  </span><span class="s1">webCrypto.getRandomValues = function getRandomValues() {</span><span class="s3">\n    </span><span class="s1">io(getRandomValuesExpression, 'crypto')</span><span class="s3">\n    </span><span class="s1">return _getRandomValues.apply(webCrypto, arguments as any)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">} catch {</span><span class="s3">\n  </span><span class="s1">console.error(</span><span class="s3">\n    </span><span class="s1">`Failed to install ${getRandomValuesExpression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function will not correctly trigger dynamic behavior.`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const randomUUIDExpression = '`crypto.randomUUID()`'</span><span class="s3">\n</span><span class="s1">try {</span><span class="s3">\n  </span><span class="s1">const _randomUUID = webCrypto.randomUUID</span><span class="s3">\n  </span><span class="s1">webCrypto.randomUUID = function randomUUID() {</span><span class="s3">\n    </span><span class="s1">io(randomUUIDExpression, 'crypto')</span><span class="s3">\n    </span><span class="s1">return _randomUUID.apply(webCrypto, arguments as any)</span><span class="s3">\n  </span><span class="s1">} as typeof _randomUUID</span><span class="s3">\n</span><span class="s1">} catch {</span><span class="s3">\n  </span><span class="s1">console.error(</span><span class="s3">\n    </span><span class="s1">`Failed to install ${getRandomValuesExpression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function will not correctly trigger dynamic behavior.`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { SourceMap } from 'module'</span><span class="s3">\n</span><span class="s1">import { LRUCache } from './lru-cache'</span><span class="s3">\n\n</span><span class="s1">function noSourceMap(): SourceMap | undefined {</span><span class="s3">\n  </span><span class="s1">return undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Edge runtime does not implement `module`</span><span class="s3">\n</span><span class="s1">const nativeFindSourceMap =</span><span class="s3">\n  </span><span class="s1">process.env.NEXT_RUNTIME === 'edge'</span><span class="s3">\n    </span><span class="s1">? noSourceMap</span><span class="s3">\n    </span><span class="s1">: (require('module') as typeof import('module')).findSourceMap</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* https://tc39.es/source-map/#index-map</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">interface IndexSourceMapSection {</span><span class="s3">\n  </span><span class="s1">offset: {</span><span class="s3">\n    </span><span class="s1">line: number</span><span class="s3">\n    </span><span class="s1">column: number</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">map: BasicSourceMapPayload</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// TODO(veil): Upstream types</span><span class="s3">\n</span><span class="s1">/** https://tc39.es/ecma426/#sec-index-source-map */</span><span class="s3">\n</span><span class="s1">interface IndexSourceMap {</span><span class="s3">\n  </span><span class="s1">version: number</span><span class="s3">\n  </span><span class="s1">file: string</span><span class="s3">\n  </span><span class="s1">sections: IndexSourceMapSection[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** https://tc39.es/ecma426/#sec-source-map-format */</span><span class="s3">\n</span><span class="s1">export interface BasicSourceMapPayload {</span><span class="s3">\n  </span><span class="s1">version: number</span><span class="s3">\n  </span><span class="s1">// TODO: Move to https://github.com/jridgewell/sourcemaps which is actively maintained</span><span class="s3">\n  </span><span class="s1">/** WARNING: `file` is optional. */</span><span class="s3">\n  </span><span class="s1">file: string</span><span class="s3">\n  </span><span class="s1">sourceRoot?: string</span><span class="s3">\n  </span><span class="s1">// TODO: Move to https://github.com/jridgewell/sourcemaps which is actively maintained</span><span class="s3">\n  </span><span class="s1">/** WARNING: `sources[number]` can be `null`. */</span><span class="s3">\n  </span><span class="s1">sources: Array&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">names: Array&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">mappings: string</span><span class="s3">\n  </span><span class="s1">ignoreList?: number[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ModernSourceMapPayload = BasicSourceMapPayload | IndexSourceMap</span><span class="s3">\n\n</span><span class="s1">export function sourceMapIgnoreListsEverything(</span><span class="s3">\n  </span><span class="s1">sourceMap: BasicSourceMapPayload</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">sourceMap.ignoreList !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">sourceMap.sources.length === sourceMap.ignoreList.length</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Finds the sourcemap payload applicable to a given frame.</span><span class="s3">\n </span><span class="s1">* Equal to the input unless an Index Source Map is used.</span><span class="s3">\n </span><span class="s1">* @param line0 - The line number of the frame, 0-based.</span><span class="s3">\n </span><span class="s1">* @param column0 - The column number of the frame, 0-based.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findApplicableSourceMapPayload(</span><span class="s3">\n  </span><span class="s1">line0: number,</span><span class="s3">\n  </span><span class="s1">column0: number,</span><span class="s3">\n  </span><span class="s1">payload: ModernSourceMapPayload</span><span class="s3">\n</span><span class="s1">): BasicSourceMapPayload | undefined {</span><span class="s3">\n  </span><span class="s1">if ('sections' in payload) {</span><span class="s3">\n    </span><span class="s1">if (payload.sections.length === 0) {</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Sections must not overlap and must be sorted: https://tc39.es/source-map/#section-object</span><span class="s3">\n    </span><span class="s1">// Therefore the last section that has an offset less than or equal to the frame is the applicable one.</span><span class="s3">\n    </span><span class="s1">const sections = payload.sections</span><span class="s3">\n    </span><span class="s1">let left = 0</span><span class="s3">\n    </span><span class="s1">let right = sections.length - 1</span><span class="s3">\n    </span><span class="s1">let result: IndexSourceMapSection | null = null</span><span class="s3">\n\n    </span><span class="s1">while (left &lt;= right) {</span><span class="s3">\n      </span><span class="s1">// fast Math.floor</span><span class="s3">\n      </span><span class="s1">const middle = ~~((left + right) / 2)</span><span class="s3">\n      </span><span class="s1">const section = sections[middle]</span><span class="s3">\n      </span><span class="s1">const offset = section.offset</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">offset.line &lt; line0 ||</span><span class="s3">\n        </span><span class="s1">(offset.line === line0 &amp;&amp; offset.column &lt;= column0)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">result = section</span><span class="s3">\n        </span><span class="s1">left = middle + 1</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">right = middle - 1</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return result === null ? undefined : result.map</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return payload</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const didWarnAboutInvalidSourceMapDEV = new Set&lt;string&gt;()</span><span class="s3">\n\n</span><span class="s1">const findSourceMap: (scriptNameOrSourceURL: string) =&gt; SourceMap | undefined =</span><span class="s3">\n  </span><span class="s1">process.env.NEXT_RUNTIME === 'nodejs' &amp;&amp;</span><span class="s3">\n  </span><span class="s1">process.versions.node?.startsWith('18')</span><span class="s3">\n    </span><span class="s1">? // Node.js 18 has a horribly slow `findSourceMap` implementation</span><span class="s3">\n      </span><span class="s1">noSourceMap</span><span class="s3">\n    </span><span class="s1">: nativeFindSourceMap</span><span class="s3">\n\n</span><span class="s1">export function filterStackFrameDEV(</span><span class="s3">\n  </span><span class="s1">sourceURL: string,</span><span class="s3">\n  </span><span class="s1">functionName: string,</span><span class="s3">\n  </span><span class="s1">line1: number,</span><span class="s3">\n  </span><span class="s1">column1: number</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (sourceURL === '') {</span><span class="s3">\n    </span><span class="s1">// The default implementation filters out &lt;anonymous&gt; stack frames</span><span class="s3">\n    </span><span class="s1">// but we want to retain them because current Server Components and</span><span class="s3">\n    </span><span class="s1">// built-in Components in parent stacks don't have source location.</span><span class="s3">\n    </span><span class="s1">// Filter out frames that show up in Promises to get good names in React's</span><span class="s3">\n    </span><span class="s1">// Server Request track until we come up with a better heuristic.</span><span class="s3">\n    </span><span class="s1">return functionName !== 'new Promise'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (sourceURL.startsWith('node:') || sourceURL.includes('node_modules')) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// Node.js loads source maps eagerly so this call is cheap.</span><span class="s3">\n    </span><span class="s1">// TODO: ESM sourcemaps are O(1) but CommonJS sourcemaps are O(Number of CJS modules).</span><span class="s3">\n    </span><span class="s1">// Make sure this doesn't adversely affect performance when CJS is used by Next.js.</span><span class="s3">\n    </span><span class="s1">const sourceMap = findSourceMap(sourceURL)</span><span class="s3">\n    </span><span class="s1">if (sourceMap === undefined) {</span><span class="s3">\n      </span><span class="s1">// No source map assoicated.</span><span class="s3">\n      </span><span class="s1">// TODO: Node.js types should reflect that `findSourceMap` can return `undefined`.</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const sourceMapPayload = findApplicableSourceMapPayload(</span><span class="s3">\n      </span><span class="s1">line1 - 1,</span><span class="s3">\n      </span><span class="s1">column1 - 1,</span><span class="s3">\n      </span><span class="s1">sourceMap.payload</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (sourceMapPayload === undefined) {</span><span class="s3">\n      </span><span class="s1">// No source map section applicable to the frame.</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return !sourceMapIgnoreListsEverything(sourceMapPayload)</span><span class="s3">\n  </span><span class="s1">} catch (cause) {</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">// TODO: Share cache with patch-error-inspect</span><span class="s3">\n      </span><span class="s1">if (!didWarnAboutInvalidSourceMapDEV.has(sourceURL)) {</span><span class="s3">\n        </span><span class="s1">didWarnAboutInvalidSourceMapDEV.add(sourceURL)</span><span class="s3">\n        </span><span class="s1">// We should not log an actual error instance here because that will re-enter</span><span class="s3">\n        </span><span class="s1">// this codepath during error inspection and could lead to infinite recursion.</span><span class="s3">\n        </span><span class="s1">console.error(</span><span class="s3">\n          </span><span class="s1">`${sourceURL}: Invalid source map. Only conformant source maps can be used to filter stack frames. Cause: ${cause}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const invalidSourceMap = Symbol('invalid-source-map')</span><span class="s3">\n</span><span class="s1">const sourceMapURLs = new LRUCache&lt;string | typeof invalidSourceMap&gt;(</span><span class="s3">\n  </span><span class="s1">512 * 1024 * 1024,</span><span class="s3">\n  </span><span class="s1">(url) =&gt;</span><span class="s3">\n    </span><span class="s1">url === invalidSourceMap</span><span class="s3">\n      </span><span class="s1">? // Ideally we'd account for key length. So we just guestimate a small source map</span><span class="s3">\n        </span><span class="s1">// so that we don't create a huge cache with empty source maps.</span><span class="s3">\n        </span><span class="s1">8 * 1024</span><span class="s3">\n      </span><span class="s1">: // these URLs contain only ASCII characters so .length is equal to Buffer.byteLength</span><span class="s3">\n        </span><span class="s1">url.length</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export function findSourceMapURLDEV(</span><span class="s3">\n  </span><span class="s1">scriptNameOrSourceURL: string</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">let sourceMapURL = sourceMapURLs.get(scriptNameOrSourceURL)</span><span class="s3">\n  </span><span class="s1">if (sourceMapURL === undefined) {</span><span class="s3">\n    </span><span class="s1">let sourceMapPayload: ModernSourceMapPayload | undefined</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">sourceMapPayload = findSourceMap(scriptNameOrSourceURL)?.payload</span><span class="s3">\n    </span><span class="s1">} catch (cause) {</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`${scriptNameOrSourceURL}: Invalid source map. Only conformant source maps can be used to find the original code. Cause: ${cause}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (sourceMapPayload === undefined) {</span><span class="s3">\n      </span><span class="s1">sourceMapURL = invalidSourceMap</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// TODO: Might be more efficient to extract the relevant section from Index Maps.</span><span class="s3">\n      </span><span class="s1">// Unclear if that search is worth the smaller payload we have to stringify.</span><span class="s3">\n      </span><span class="s1">const sourceMapJSON = JSON.stringify(sourceMapPayload)</span><span class="s3">\n      </span><span class="s1">const sourceMapURLData = Buffer.from(sourceMapJSON, 'utf8').toString(</span><span class="s3">\n        </span><span class="s1">'base64'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">sourceMapURL = `data:application/json;base64,${sourceMapURLData}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">sourceMapURLs.set(scriptNameOrSourceURL, sourceMapURL)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return sourceMapURL === invalidSourceMap ? null : sourceMapURL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function devirtualizeReactServerURL(sourceURL: string): string {</span><span class="s3">\n  </span><span class="s1">if (sourceURL.startsWith('about://React/')) {</span><span class="s3">\n    </span><span class="s1">// about://React/Server/file://&lt;filename&gt;?42 =&gt; file://&lt;filename&gt;</span><span class="s3">\n    </span><span class="s1">const envIdx = sourceURL.indexOf('/', 'about://React/'.length)</span><span class="s3">\n    </span><span class="s1">const suffixIdx = sourceURL.lastIndexOf('?')</span><span class="s3">\n    </span><span class="s1">if (envIdx &gt; -1 &amp;&amp; suffixIdx &gt; -1) {</span><span class="s3">\n      </span><span class="s1">return decodeURI(sourceURL.slice(envIdx + 1, suffixIdx))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return sourceURL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isAnonymousFrameLikelyJSNative(methodName: string): boolean {</span><span class="s3">\n  </span><span class="s1">// Anonymous frames can also be produced in React parent stacks either from</span><span class="s3">\n  </span><span class="s1">// host components or Server Components. We don't want to ignore those.</span><span class="s3">\n  </span><span class="s1">// This could hide user-space methods that are named like native JS methods but</span><span class="s3">\n  </span><span class="s1">// should you really do that?</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">// e.g. JSON.parse</span><span class="s3">\n    </span><span class="s1">methodName.startsWith('JSON.') ||</span><span class="s3">\n    </span><span class="s1">// E.g. Promise.withResolves</span><span class="s3">\n    </span><span class="s1">methodName.startsWith('Function.') ||</span><span class="s3">\n    </span><span class="s1">// various JS built-ins</span><span class="s3">\n    </span><span class="s1">methodName.startsWith('Promise.') ||</span><span class="s3">\n    </span><span class="s1">methodName.startsWith('Array.') ||</span><span class="s3">\n    </span><span class="s1">methodName.startsWith('Set.') ||</span><span class="s3">\n    </span><span class="s1">methodName.startsWith('Map.')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ignoreListAnonymousStackFramesIfSandwiched&lt;Frame&gt;(</span><span class="s3">\n  </span><span class="s1">frames: Frame[],</span><span class="s3">\n  </span><span class="s1">isAnonymousFrame: (frame: Frame) =&gt; boolean,</span><span class="s3">\n  </span><span class="s1">isIgnoredFrame: (frame: Frame) =&gt; boolean,</span><span class="s3">\n  </span><span class="s1">getMethodName: (frame: Frame) =&gt; string,</span><span class="s3">\n  </span><span class="s1">/** only passes frames for which `isAnonymousFrame` and their method is a native JS method or `isIgnoredFrame` return true */</span><span class="s3">\n  </span><span class="s1">ignoreFrame: (frame: Frame) =&gt; void</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">for (let i = 1; i &lt; frames.length; i++) {</span><span class="s3">\n    </span><span class="s1">const currentFrame = frames[i]</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!(</span><span class="s3">\n        </span><span class="s1">isAnonymousFrame(currentFrame) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isAnonymousFrameLikelyJSNative(getMethodName(currentFrame))</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const previousFrameIsIgnored = isIgnoredFrame(frames[i - 1])</span><span class="s3">\n    </span><span class="s1">if (previousFrameIsIgnored &amp;&amp; i &lt; frames.length - 1) {</span><span class="s3">\n      </span><span class="s1">let ignoreSandwich = false</span><span class="s3">\n      </span><span class="s1">let j = i + 1</span><span class="s3">\n      </span><span class="s1">for (j; j &lt; frames.length; j++) {</span><span class="s3">\n        </span><span class="s1">const nextFrame = frames[j]</span><span class="s3">\n        </span><span class="s1">const nextFrameIsAnonymous =</span><span class="s3">\n          </span><span class="s1">isAnonymousFrame(nextFrame) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">isAnonymousFrameLikelyJSNative(getMethodName(nextFrame))</span><span class="s3">\n        </span><span class="s1">if (nextFrameIsAnonymous) {</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const nextFrameIsIgnored = isIgnoredFrame(nextFrame)</span><span class="s3">\n        </span><span class="s1">if (nextFrameIsIgnored) {</span><span class="s3">\n          </span><span class="s1">ignoreSandwich = true</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (ignoreSandwich) {</span><span class="s3">\n        </span><span class="s1">for (i; i &lt; j; i++) {</span><span class="s3">\n          </span><span class="s1">ignoreFrame(frames[i])</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// ISC License</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) 2021 Alexey Raspopov, Kostiantyn Denysov, Anton Verinov</span><span class="s3">\n\n</span><span class="s1">// Permission to use, copy, modify, and/or distribute this software for any</span><span class="s3">\n</span><span class="s1">// purpose with or without fee is hereby granted, provided that the above</span><span class="s3">\n</span><span class="s1">// copyright notice and this permission notice appear in all copies.</span><span class="s3">\n\n</span><span class="s1">// THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot; </span><span class="s1">AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span><span class="s3">\n</span><span class="s1">// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span><span class="s3">\n</span><span class="s1">// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span><span class="s3">\n</span><span class="s1">// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span><span class="s3">\n</span><span class="s1">// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span><span class="s3">\n</span><span class="s1">// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span><span class="s3">\n</span><span class="s1">// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// https://github.com/alexeyraspopov/picocolors/blob/b6261487e7b81aaab2440e397a356732cad9e342/picocolors.js#L1</span><span class="s3">\n\n</span><span class="s1">const { env, stdout } = globalThis?.process ?? {}</span><span class="s3">\n\n</span><span class="s1">const enabled =</span><span class="s3">\n  </span><span class="s1">env &amp;&amp;</span><span class="s3">\n  </span><span class="s1">!env.NO_COLOR &amp;&amp;</span><span class="s3">\n  </span><span class="s1">(env.FORCE_COLOR || (stdout?.isTTY &amp;&amp; !env.CI &amp;&amp; env.TERM !== 'dumb'))</span><span class="s3">\n\n</span><span class="s1">const replaceClose = (</span><span class="s3">\n  </span><span class="s1">str: string,</span><span class="s3">\n  </span><span class="s1">close: string,</span><span class="s3">\n  </span><span class="s1">replace: string,</span><span class="s3">\n  </span><span class="s1">index: number</span><span class="s3">\n</span><span class="s1">): string =&gt; {</span><span class="s3">\n  </span><span class="s1">const start = str.substring(0, index) + replace</span><span class="s3">\n  </span><span class="s1">const end = str.substring(index + close.length)</span><span class="s3">\n  </span><span class="s1">const nextIndex = end.indexOf(close)</span><span class="s3">\n  </span><span class="s1">return ~nextIndex</span><span class="s3">\n    </span><span class="s1">? start + replaceClose(end, close, replace, nextIndex)</span><span class="s3">\n    </span><span class="s1">: start + end</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const formatter = (open: string, close: string, replace = open) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!enabled) return String</span><span class="s3">\n  </span><span class="s1">return (input: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const string = '' + input</span><span class="s3">\n    </span><span class="s1">const index = string.indexOf(close, open.length)</span><span class="s3">\n    </span><span class="s1">return ~index</span><span class="s3">\n      </span><span class="s1">? open + replaceClose(string, close, replace, index) + close</span><span class="s3">\n      </span><span class="s1">: open + string + close</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const reset = enabled ? (s: string) =&gt; `</span><span class="s3">\\</span><span class="s1">x1b[0m${s}</span><span class="s3">\\</span><span class="s1">x1b[0m` : String</span><span class="s3">\n</span><span class="s1">export const bold = formatter('</span><span class="s3">\\</span><span class="s1">x1b[1m', '</span><span class="s3">\\</span><span class="s1">x1b[22m', '</span><span class="s3">\\</span><span class="s1">x1b[22m</span><span class="s3">\\</span><span class="s1">x1b[1m')</span><span class="s3">\n</span><span class="s1">export const dim = formatter('</span><span class="s3">\\</span><span class="s1">x1b[2m', '</span><span class="s3">\\</span><span class="s1">x1b[22m', '</span><span class="s3">\\</span><span class="s1">x1b[22m</span><span class="s3">\\</span><span class="s1">x1b[2m')</span><span class="s3">\n</span><span class="s1">export const italic = formatter('</span><span class="s3">\\</span><span class="s1">x1b[3m', '</span><span class="s3">\\</span><span class="s1">x1b[23m')</span><span class="s3">\n</span><span class="s1">export const underline = formatter('</span><span class="s3">\\</span><span class="s1">x1b[4m', '</span><span class="s3">\\</span><span class="s1">x1b[24m')</span><span class="s3">\n</span><span class="s1">export const inverse = formatter('</span><span class="s3">\\</span><span class="s1">x1b[7m', '</span><span class="s3">\\</span><span class="s1">x1b[27m')</span><span class="s3">\n</span><span class="s1">export const hidden = formatter('</span><span class="s3">\\</span><span class="s1">x1b[8m', '</span><span class="s3">\\</span><span class="s1">x1b[28m')</span><span class="s3">\n</span><span class="s1">export const strikethrough = formatter('</span><span class="s3">\\</span><span class="s1">x1b[9m', '</span><span class="s3">\\</span><span class="s1">x1b[29m')</span><span class="s3">\n</span><span class="s1">export const black = formatter('</span><span class="s3">\\</span><span class="s1">x1b[30m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const red = formatter('</span><span class="s3">\\</span><span class="s1">x1b[31m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const green = formatter('</span><span class="s3">\\</span><span class="s1">x1b[32m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const yellow = formatter('</span><span class="s3">\\</span><span class="s1">x1b[33m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const blue = formatter('</span><span class="s3">\\</span><span class="s1">x1b[34m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const magenta = formatter('</span><span class="s3">\\</span><span class="s1">x1b[35m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const purple = formatter('</span><span class="s3">\\</span><span class="s1">x1b[38;2;173;127;168m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const cyan = formatter('</span><span class="s3">\\</span><span class="s1">x1b[36m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const white = formatter('</span><span class="s3">\\</span><span class="s1">x1b[37m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const gray = formatter('</span><span class="s3">\\</span><span class="s1">x1b[90m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const bgBlack = formatter('</span><span class="s3">\\</span><span class="s1">x1b[40m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgRed = formatter('</span><span class="s3">\\</span><span class="s1">x1b[41m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgGreen = formatter('</span><span class="s3">\\</span><span class="s1">x1b[42m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgYellow = formatter('</span><span class="s3">\\</span><span class="s1">x1b[43m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgBlue = formatter('</span><span class="s3">\\</span><span class="s1">x1b[44m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgMagenta = formatter('</span><span class="s3">\\</span><span class="s1">x1b[45m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgCyan = formatter('</span><span class="s3">\\</span><span class="s1">x1b[46m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgWhite = formatter('</span><span class="s3">\\</span><span class="s1">x1b[47m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Node in the doubly-linked list used for LRU tracking.</span><span class="s3">\n </span><span class="s1">* Each node represents a cache entry with bidirectional pointers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class LRUNode&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">public readonly key: string</span><span class="s3">\n  </span><span class="s1">public data: T</span><span class="s3">\n  </span><span class="s1">public size: number</span><span class="s3">\n  </span><span class="s1">public prev: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n  </span><span class="s1">public next: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n\n  </span><span class="s1">constructor(key: string, data: T, size: number) {</span><span class="s3">\n    </span><span class="s1">this.key = key</span><span class="s3">\n    </span><span class="s1">this.data = data</span><span class="s3">\n    </span><span class="s1">this.size = size</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sentinel node used for head/tail boundaries.</span><span class="s3">\n </span><span class="s1">* These nodes don't contain actual cache data but simplify list operations.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SentinelNode&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">public prev: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n  </span><span class="s1">public next: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* LRU (Least Recently Used) Cache implementation using a doubly-linked list</span><span class="s3">\n </span><span class="s1">* and hash map for O(1) operations.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Algorithm:</span><span class="s3">\n </span><span class="s1">* - Uses a doubly-linked list to maintain access order (most recent at head)</span><span class="s3">\n </span><span class="s1">* - Hash map provides O(1) key-to-node lookup</span><span class="s3">\n </span><span class="s1">* - Sentinel head/tail nodes simplify edge case handling</span><span class="s3">\n </span><span class="s1">* - Size-based eviction supports custom size calculation functions</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Data Structure Layout:</span><span class="s3">\n </span><span class="s1">* HEAD &lt;-&gt; [most recent] &lt;-&gt; ... &lt;-&gt; [least recent] &lt;-&gt; TAIL</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Operations:</span><span class="s3">\n </span><span class="s1">* - get(): Move accessed node to head (mark as most recent)</span><span class="s3">\n </span><span class="s1">* - set(): Add new node at head, evict from tail if over capacity</span><span class="s3">\n </span><span class="s1">* - Eviction: Remove least recent node (tail.prev) when size exceeds limit</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class LRUCache&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly cache: Map&lt;string, LRUNode&lt;T&gt;&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">private readonly head: SentinelNode&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">private readonly tail: SentinelNode&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">private totalSize: number = 0</span><span class="s3">\n  </span><span class="s1">private readonly maxSize: number</span><span class="s3">\n  </span><span class="s1">private readonly calculateSize: ((value: T) =&gt; number) | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(maxSize: number, calculateSize?: (value: T) =&gt; number) {</span><span class="s3">\n    </span><span class="s1">this.maxSize = maxSize</span><span class="s3">\n    </span><span class="s1">this.calculateSize = calculateSize</span><span class="s3">\n\n    </span><span class="s1">// Create sentinel nodes to simplify doubly-linked list operations</span><span class="s3">\n    </span><span class="s1">// HEAD &lt;-&gt; TAIL (empty list)</span><span class="s3">\n    </span><span class="s1">this.head = new SentinelNode&lt;T&gt;()</span><span class="s3">\n    </span><span class="s1">this.tail = new SentinelNode&lt;T&gt;()</span><span class="s3">\n    </span><span class="s1">this.head.next = this.tail</span><span class="s3">\n    </span><span class="s1">this.tail.prev = this.head</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Adds a node immediately after the head (marks as most recently used).</span><span class="s3">\n   </span><span class="s1">* Used when inserting new items or when an item is accessed.</span><span class="s3">\n   </span><span class="s1">* PRECONDITION: node must be disconnected (prev/next should be null)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private addToHead(node: LRUNode&lt;T&gt;): void {</span><span class="s3">\n    </span><span class="s1">node.prev = this.head</span><span class="s3">\n    </span><span class="s1">node.next = this.head.next</span><span class="s3">\n    </span><span class="s1">// head.next is always non-null (points to tail or another node)</span><span class="s3">\n    </span><span class="s1">this.head.next!.prev = node</span><span class="s3">\n    </span><span class="s1">this.head.next = node</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes a node from its current position in the doubly-linked list.</span><span class="s3">\n   </span><span class="s1">* Updates the prev/next pointers of adjacent nodes to maintain list integrity.</span><span class="s3">\n   </span><span class="s1">* PRECONDITION: node must be connected (prev/next are non-null)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private removeNode(node: LRUNode&lt;T&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Connected nodes always have non-null prev/next</span><span class="s3">\n    </span><span class="s1">node.prev!.next = node.next</span><span class="s3">\n    </span><span class="s1">node.next!.prev = node.prev</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Moves an existing node to the head position (marks as most recently used).</span><span class="s3">\n   </span><span class="s1">* This is the core LRU operation - accessed items become most recent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private moveToHead(node: LRUNode&lt;T&gt;): void {</span><span class="s3">\n    </span><span class="s1">this.removeNode(node)</span><span class="s3">\n    </span><span class="s1">this.addToHead(node)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes and returns the least recently used node (the one before tail).</span><span class="s3">\n   </span><span class="s1">* This is called during eviction when the cache exceeds capacity.</span><span class="s3">\n   </span><span class="s1">* PRECONDITION: cache is not empty (ensured by caller)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private removeTail(): LRUNode&lt;T&gt; {</span><span class="s3">\n    </span><span class="s1">const lastNode = this.tail.prev as LRUNode&lt;T&gt;</span><span class="s3">\n    </span><span class="s1">// tail.prev is always non-null and always LRUNode when cache is not empty</span><span class="s3">\n    </span><span class="s1">this.removeNode(lastNode)</span><span class="s3">\n    </span><span class="s1">return lastNode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Sets a key-value pair in the cache.</span><span class="s3">\n   </span><span class="s1">* If the key exists, updates the value and moves to head.</span><span class="s3">\n   </span><span class="s1">* If new, adds at head and evicts from tail if necessary.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity:</span><span class="s3">\n   </span><span class="s1">* - O(1) for uniform item sizes</span><span class="s3">\n   </span><span class="s1">* - O(k) where k is the number of items evicted (can be O(N) for variable sizes)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public set(key: string, value: T): void {</span><span class="s3">\n    </span><span class="s1">const size = this.calculateSize?.(value) ?? 1</span><span class="s3">\n    </span><span class="s1">if (size &gt; this.maxSize) {</span><span class="s3">\n      </span><span class="s1">console.warn('Single item size exceeds maxSize')</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const existing = this.cache.get(key)</span><span class="s3">\n    </span><span class="s1">if (existing) {</span><span class="s3">\n      </span><span class="s1">// Update existing node: adjust size and move to head (most recent)</span><span class="s3">\n      </span><span class="s1">existing.data = value</span><span class="s3">\n      </span><span class="s1">this.totalSize = this.totalSize - existing.size + size</span><span class="s3">\n      </span><span class="s1">existing.size = size</span><span class="s3">\n      </span><span class="s1">this.moveToHead(existing)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Add new node at head (most recent position)</span><span class="s3">\n      </span><span class="s1">const newNode = new LRUNode(key, value, size)</span><span class="s3">\n      </span><span class="s1">this.cache.set(key, newNode)</span><span class="s3">\n      </span><span class="s1">this.addToHead(newNode)</span><span class="s3">\n      </span><span class="s1">this.totalSize += size</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Evict least recently used items until under capacity</span><span class="s3">\n    </span><span class="s1">while (this.totalSize &gt; this.maxSize &amp;&amp; this.cache.size &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const tail = this.removeTail()</span><span class="s3">\n      </span><span class="s1">this.cache.delete(tail.key)</span><span class="s3">\n      </span><span class="s1">this.totalSize -= tail.size</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Checks if a key exists in the cache.</span><span class="s3">\n   </span><span class="s1">* This is a pure query operation - does NOT update LRU order.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity: O(1)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public has(key: string): boolean {</span><span class="s3">\n    </span><span class="s1">return this.cache.has(key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Retrieves a value by key and marks it as most recently used.</span><span class="s3">\n   </span><span class="s1">* Moving to head maintains the LRU property for future evictions.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity: O(1)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get(key: string): T | undefined {</span><span class="s3">\n    </span><span class="s1">const node = this.cache.get(key)</span><span class="s3">\n    </span><span class="s1">if (!node) return undefined</span><span class="s3">\n\n    </span><span class="s1">// Mark as most recently used by moving to head</span><span class="s3">\n    </span><span class="s1">this.moveToHead(node)</span><span class="s3">\n\n    </span><span class="s1">return node.data</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns an iterator over the cache entries. The order is outputted in the</span><span class="s3">\n   </span><span class="s1">* order of most recently used to least recently used.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public *[Symbol.iterator](): IterableIterator&lt;[string, T]&gt; {</span><span class="s3">\n    </span><span class="s1">let current = this.head.next</span><span class="s3">\n    </span><span class="s1">while (current &amp;&amp; current !== this.tail) {</span><span class="s3">\n      </span><span class="s1">// Between head and tail, current is always LRUNode</span><span class="s3">\n      </span><span class="s1">const node = current as LRUNode&lt;T&gt;</span><span class="s3">\n      </span><span class="s1">yield [node.key, node.data]</span><span class="s3">\n      </span><span class="s1">current = current.next</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes a specific key from the cache.</span><span class="s3">\n   </span><span class="s1">* Updates both the hash map and doubly-linked list.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity: O(1)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public remove(key: string): void {</span><span class="s3">\n    </span><span class="s1">const node = this.cache.get(key)</span><span class="s3">\n    </span><span class="s1">if (!node) return</span><span class="s3">\n\n    </span><span class="s1">this.removeNode(node)</span><span class="s3">\n    </span><span class="s1">this.cache.delete(key)</span><span class="s3">\n    </span><span class="s1">this.totalSize -= node.size</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the number of items in the cache.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get size(): number {</span><span class="s3">\n    </span><span class="s1">return this.cache.size</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the current total size of all cached items.</span><span class="s3">\n   </span><span class="s1">* This uses the custom size calculation if provided.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get currentSize(): number {</span><span class="s3">\n    </span><span class="s1">return this.totalSize</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parse } from 'next/dist/compiled/stacktrace-parser'</span><span class="s3">\n\n</span><span class="s1">const regexNextStatic = /</span><span class="s3">\\</span><span class="s1">/_next(</span><span class="s3">\\</span><span class="s1">/static</span><span class="s3">\\</span><span class="s1">/.+)/</span><span class="s3">\n\n</span><span class="s1">export interface StackFrame {</span><span class="s3">\n  </span><span class="s1">file: string | null</span><span class="s3">\n  </span><span class="s1">methodName: string</span><span class="s3">\n  </span><span class="s1">arguments: string[]</span><span class="s3">\n  </span><span class="s1">/** 1-based */</span><span class="s3">\n  </span><span class="s1">line1: number | null</span><span class="s3">\n  </span><span class="s1">/** 1-based */</span><span class="s3">\n  </span><span class="s1">column1: number | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseStack(</span><span class="s3">\n  </span><span class="s1">stack: string,</span><span class="s3">\n  </span><span class="s1">distDir = process.env.__NEXT_DIST_DIR</span><span class="s3">\n</span><span class="s1">): StackFrame[] {</span><span class="s3">\n  </span><span class="s1">if (!stack) return []</span><span class="s3">\n\n  </span><span class="s1">// throw away eval information that stacktrace-parser doesn't support</span><span class="s3">\n  </span><span class="s1">// adapted from https://github.com/stacktracejs/error-stack-parser/blob/9f33c224b5d7b607755eb277f9d51fcdb7287e24/error-stack-parser.js#L59C33-L59C62</span><span class="s3">\n  </span><span class="s1">stack = stack</span><span class="s3">\n    </span><span class="s1">.split('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n    </span><span class="s1">.map((line) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (line.includes('(eval ')) {</span><span class="s3">\n        </span><span class="s1">line = line</span><span class="s3">\n          </span><span class="s1">.replace(/eval code/g, 'eval')</span><span class="s3">\n          </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">(eval at [^()]* </span><span class="s3">\\</span><span class="s1">(/, '(file://')</span><span class="s3">\n          </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">),.*$/g, ')')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return line</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.join('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n\n  </span><span class="s1">const frames = parse(stack)</span><span class="s3">\n  </span><span class="s1">return frames.map((frame) =&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const url = new URL(frame.file!)</span><span class="s3">\n      </span><span class="s1">const res = regexNextStatic.exec(url.pathname)</span><span class="s3">\n      </span><span class="s1">if (res) {</span><span class="s3">\n        </span><span class="s1">const effectiveDistDir = distDir</span><span class="s3">\n          </span><span class="s1">?.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n          </span><span class="s1">?.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '')</span><span class="s3">\n        </span><span class="s1">if (effectiveDistDir) {</span><span class="s3">\n          </span><span class="s1">frame.file =</span><span class="s3">\n            </span><span class="s1">'file://' + effectiveDistDir.concat(res.pop()!) + url.search</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch {}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">file: frame.file,</span><span class="s3">\n      </span><span class="s1">line1: frame.lineNumber,</span><span class="s3">\n      </span><span class="s1">column1: frame.column,</span><span class="s3">\n      </span><span class="s1">methodName: frame.methodName,</span><span class="s3">\n      </span><span class="s1">arguments: frame.arguments,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** React that's compiled with `next`. Used by App Router. */</span><span class="s3">\n</span><span class="s1">export const reactVendoredRe =</span><span class="s3">\n  </span><span class="s1">/[</span><span class="s3">\\\\</span><span class="s1">/]next[</span><span class="s3">\\\\</span><span class="s1">/]dist[</span><span class="s3">\\\\</span><span class="s1">/]compiled[</span><span class="s3">\\\\</span><span class="s1">/](react|react-dom|react-server-dom-(webpack|turbopack)|scheduler)[</span><span class="s3">\\\\</span><span class="s1">/]/</span><span class="s3">\n\n</span><span class="s1">/** React the user installed. Used by Pages Router, or user imports in App Router. */</span><span class="s3">\n</span><span class="s1">export const reactNodeModulesRe =</span><span class="s3">\n  </span><span class="s1">/node_modules[</span><span class="s3">\\\\</span><span class="s1">/](react|react-dom|scheduler)[</span><span class="s3">\\\\</span><span class="s1">/]/</span><span class="s3">\n\n</span><span class="s1">export const nextInternalsRe =</span><span class="s3">\n  </span><span class="s1">/(node_modules[</span><span class="s3">\\\\</span><span class="s1">/]next[</span><span class="s3">\\\\</span><span class="s1">/]|[</span><span class="s3">\\\\</span><span class="s1">/].next[</span><span class="s3">\\\\</span><span class="s1">/]static[</span><span class="s3">\\\\</span><span class="s1">/]chunks[</span><span class="s3">\\\\</span><span class="s1">/]webpack</span><span class="s3">\\</span><span class="s1">.js$|(edge-runtime-webpack|webpack-runtime)</span><span class="s3">\\</span><span class="s1">.js$)/</span><span class="s3">\n\n</span><span class="s1">export default function isInternal(file: string | null) {</span><span class="s3">\n  </span><span class="s1">if (!file) return false</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">nextInternalsRe.test(file) ||</span><span class="s3">\n    </span><span class="s1">reactVendoredRe.test(file) ||</span><span class="s3">\n    </span><span class="s1">reactNodeModulesRe.test(file)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { findSourceMap as nativeFindSourceMap } from 'module'</span><span class="s3">\n</span><span class="s1">import * as path from 'path'</span><span class="s3">\n</span><span class="s1">import * as url from 'url'</span><span class="s3">\n</span><span class="s1">import type * as util from 'util'</span><span class="s3">\n</span><span class="s1">import { SourceMapConsumer as SyncSourceMapConsumer } from 'next/dist/compiled/source-map'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type ModernSourceMapPayload,</span><span class="s3">\n  </span><span class="s1">findApplicableSourceMapPayload,</span><span class="s3">\n  </span><span class="s1">ignoreListAnonymousStackFramesIfSandwiched as ignoreListAnonymousStackFramesIfSandwichedGeneric,</span><span class="s3">\n  </span><span class="s1">sourceMapIgnoreListsEverything,</span><span class="s3">\n</span><span class="s1">} from './lib/source-maps'</span><span class="s3">\n</span><span class="s1">import { parseStack, type StackFrame } from './lib/parse-stack'</span><span class="s3">\n</span><span class="s1">import { getOriginalCodeFrame } from '../next-devtools/server/shared'</span><span class="s3">\n</span><span class="s1">import { workUnitAsyncStorage } from './app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { dim } from '../lib/picocolors'</span><span class="s3">\n\n</span><span class="s1">type FindSourceMapPayload = (</span><span class="s3">\n  </span><span class="s1">sourceURL: string</span><span class="s3">\n</span><span class="s1">) =&gt; ModernSourceMapPayload | undefined</span><span class="s3">\n</span><span class="s1">// Find a source map using the bundler's API.</span><span class="s3">\n</span><span class="s1">// This is only a fallback for when Node.js fails to due to bugs e.g. https://github.com/nodejs/node/issues/52102</span><span class="s3">\n</span><span class="s1">// TODO: Remove once all supported Node.js versions are fixed.</span><span class="s3">\n</span><span class="s1">// TODO(veil): Set from Webpack as well</span><span class="s3">\n</span><span class="s1">let bundlerFindSourceMapPayload: FindSourceMapPayload = () =&gt; undefined</span><span class="s3">\n\n</span><span class="s1">export function setBundlerFindSourceMapImplementation(</span><span class="s3">\n  </span><span class="s1">findSourceMapImplementation: FindSourceMapPayload</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">bundlerFindSourceMapPayload = findSourceMapImplementation</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface IgnorableStackFrame extends StackFrame {</span><span class="s3">\n  </span><span class="s1">ignored: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SourceMapCache = Map&lt;</span><span class="s3">\n  </span><span class="s1">string,</span><span class="s3">\n  </span><span class="s1">null | { map: SyncSourceMapConsumer; payload: ModernSourceMapPayload }</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">function frameToString(</span><span class="s3">\n  </span><span class="s1">methodName: string | null,</span><span class="s3">\n  </span><span class="s1">sourceURL: string | null,</span><span class="s3">\n  </span><span class="s1">line1: number | null,</span><span class="s3">\n  </span><span class="s1">column1: number | null</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">let sourceLocation = line1 !== null ? `:${line1}` : ''</span><span class="s3">\n  </span><span class="s1">if (column1 !== null &amp;&amp; sourceLocation !== '') {</span><span class="s3">\n    </span><span class="s1">sourceLocation += `:${column1}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let fileLocation: string | null</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">sourceURL !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">sourceURL.startsWith('file://') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">URL.canParse(sourceURL)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// If not relative to CWD, the path is ambiguous to IDEs and clicking will prompt to select the file first.</span><span class="s3">\n    </span><span class="s1">// In a multi-app repo, this leads to potentially larger file names but will make clicking snappy.</span><span class="s3">\n    </span><span class="s1">// There's no tradeoff for the cases where `dir` in `next dev [dir]` is omitted</span><span class="s3">\n    </span><span class="s1">// since relative to cwd is both the shortest and snappiest.</span><span class="s3">\n    </span><span class="s1">fileLocation = path.relative(process.cwd(), url.fileURLToPath(sourceURL))</span><span class="s3">\n  </span><span class="s1">} else if (sourceURL !== null &amp;&amp; sourceURL.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">fileLocation = path.relative(process.cwd(), sourceURL)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">fileLocation = sourceURL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return methodName</span><span class="s3">\n    </span><span class="s1">? `    at ${methodName} (${fileLocation}${sourceLocation})`</span><span class="s3">\n    </span><span class="s1">: `    at ${fileLocation}${sourceLocation}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeErrorName(error: Error): string {</span><span class="s3">\n  </span><span class="s1">// TODO: Node.js seems to use a different algorithm</span><span class="s3">\n  </span><span class="s1">// class ReadonlyRequestCookiesError extends Error {}` would read `ReadonlyRequestCookiesError: [...]`</span><span class="s3">\n  </span><span class="s1">// in the stack i.e. seems like under certain conditions it favors the constructor name.</span><span class="s3">\n  </span><span class="s1">return error.name || 'Error'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function prepareUnsourcemappedStackTrace(</span><span class="s3">\n  </span><span class="s1">error: Error,</span><span class="s3">\n  </span><span class="s1">structuredStackTrace: any[]</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const name = computeErrorName(error)</span><span class="s3">\n  </span><span class="s1">const message = error.message || ''</span><span class="s3">\n  </span><span class="s1">let stack = name + ': ' + message</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; structuredStackTrace.length; i++) {</span><span class="s3">\n    </span><span class="s1">stack += '</span><span class="s3">\\</span><span class="s1">n    at ' + structuredStackTrace[i].toString()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return stack</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldIgnoreListGeneratedFrame(file: string): boolean {</span><span class="s3">\n  </span><span class="s1">return file.startsWith('node:') || file.includes('node_modules')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldIgnoreListOriginalFrame(file: string): boolean {</span><span class="s3">\n  </span><span class="s1">return file.includes('node_modules')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface SourcemappableStackFrame extends StackFrame {</span><span class="s3">\n  </span><span class="s1">file: NonNullable&lt;StackFrame['file']&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface SourceMappedFrame {</span><span class="s3">\n  </span><span class="s1">stack: IgnorableStackFrame</span><span class="s3">\n  </span><span class="s1">// DEV only</span><span class="s3">\n  </span><span class="s1">code: string | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createUnsourcemappedFrame(</span><span class="s3">\n  </span><span class="s1">frame: SourcemappableStackFrame</span><span class="s3">\n</span><span class="s1">): SourceMappedFrame {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">stack: {</span><span class="s3">\n      </span><span class="s1">file: frame.file,</span><span class="s3">\n      </span><span class="s1">line1: frame.line1,</span><span class="s3">\n      </span><span class="s1">column1: frame.column1,</span><span class="s3">\n      </span><span class="s1">methodName: frame.methodName,</span><span class="s3">\n      </span><span class="s1">arguments: frame.arguments,</span><span class="s3">\n      </span><span class="s1">ignored: shouldIgnoreListGeneratedFrame(frame.file),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">code: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ignoreListAnonymousStackFramesIfSandwiched(</span><span class="s3">\n  </span><span class="s1">sourceMappedFrames: Array&lt;{</span><span class="s3">\n    </span><span class="s1">stack: IgnorableStackFrame</span><span class="s3">\n    </span><span class="s1">code: string | null</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return ignoreListAnonymousStackFramesIfSandwichedGeneric(</span><span class="s3">\n    </span><span class="s1">sourceMappedFrames,</span><span class="s3">\n    </span><span class="s1">(frame) =&gt; frame.stack.file === '&lt;anonymous&gt;',</span><span class="s3">\n    </span><span class="s1">(frame) =&gt; frame.stack.ignored,</span><span class="s3">\n    </span><span class="s1">(frame) =&gt; frame.stack.methodName,</span><span class="s3">\n    </span><span class="s1">(frame) =&gt; {</span><span class="s3">\n      </span><span class="s1">frame.stack.ignored = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param frame</span><span class="s3">\n </span><span class="s1">* @param sourceMapCache</span><span class="s3">\n </span><span class="s1">* @returns The original frame if not sourcemapped.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getSourcemappedFrameIfPossible(</span><span class="s3">\n  </span><span class="s1">frame: SourcemappableStackFrame,</span><span class="s3">\n  </span><span class="s1">sourceMapCache: SourceMapCache,</span><span class="s3">\n  </span><span class="s1">inspectOptions: util.InspectOptions</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">stack: IgnorableStackFrame</span><span class="s3">\n  </span><span class="s1">code: string | null</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const sourceMapCacheEntry = sourceMapCache.get(frame.file)</span><span class="s3">\n  </span><span class="s1">let sourceMapConsumer: SyncSourceMapConsumer</span><span class="s3">\n  </span><span class="s1">let sourceMapPayload: ModernSourceMapPayload</span><span class="s3">\n  </span><span class="s1">if (sourceMapCacheEntry === undefined) {</span><span class="s3">\n    </span><span class="s1">let sourceURL = frame.file</span><span class="s3">\n    </span><span class="s1">// e.g. </span><span class="s3">\&quot;</span><span class="s1">/APP/.next/server/chunks/ssr/[root-of-the-server]__2934a0._.js</span><span class="s3">\&quot;\n    </span><span class="s1">// will be keyed by Node.js as </span><span class="s3">\&quot;</span><span class="s1">file:///APP/.next/server/chunks/ssr/[root-of-the-server]__2934a0._.js</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n    </span><span class="s1">// This is likely caused by `callsite.toString()` in `Error.prepareStackTrace converting file URLs to paths.</span><span class="s3">\n    </span><span class="s1">if (sourceURL.startsWith('/')) {</span><span class="s3">\n      </span><span class="s1">sourceURL = url.pathToFileURL(frame.file).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let maybeSourceMapPayload: ModernSourceMapPayload | undefined</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const sourceMap = nativeFindSourceMap(sourceURL)</span><span class="s3">\n      </span><span class="s1">maybeSourceMapPayload = sourceMap?.payload</span><span class="s3">\n    </span><span class="s1">} catch (cause) {</span><span class="s3">\n      </span><span class="s1">// We should not log an actual error instance here because that will re-enter</span><span class="s3">\n      </span><span class="s1">// this codepath during error inspection and could lead to infinite recursion.</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`${sourceURL}: Invalid source map. Only conformant source maps can be used to find the original code. Cause: ${cause}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// If loading fails once, it'll fail every time.</span><span class="s3">\n      </span><span class="s1">// So set the cache to avoid duplicate errors.</span><span class="s3">\n      </span><span class="s1">sourceMapCache.set(frame.file, null)</span><span class="s3">\n      </span><span class="s1">// Don't even fall back to the bundler because it might be not as strict</span><span class="s3">\n      </span><span class="s1">// with regards to parsing and then we fail later once we consume the</span><span class="s3">\n      </span><span class="s1">// source map payload.</span><span class="s3">\n      </span><span class="s1">// This essentially avoids a redundant error where we fail here and then</span><span class="s3">\n      </span><span class="s1">// later on consumption because the bundler just handed back an invalid</span><span class="s3">\n      </span><span class="s1">// source map.</span><span class="s3">\n      </span><span class="s1">return createUnsourcemappedFrame(frame)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (maybeSourceMapPayload === undefined) {</span><span class="s3">\n      </span><span class="s1">maybeSourceMapPayload = bundlerFindSourceMapPayload(sourceURL)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (maybeSourceMapPayload === undefined) {</span><span class="s3">\n      </span><span class="s1">return createUnsourcemappedFrame(frame)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sourceMapPayload = maybeSourceMapPayload</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">sourceMapConsumer = new SyncSourceMapConsumer(</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error -- Module.SourceMap['version'] is number but SyncSourceMapConsumer wants a string</span><span class="s3">\n        </span><span class="s1">sourceMapPayload</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} catch (cause) {</span><span class="s3">\n      </span><span class="s1">// We should not log an actual error instance here because that will re-enter</span><span class="s3">\n      </span><span class="s1">// this codepath during error inspection and could lead to infinite recursion.</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`${sourceURL}: Invalid source map. Only conformant source maps can be used to find the original code. Cause: ${cause}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// If creating the consumer fails once, it'll fail every time.</span><span class="s3">\n      </span><span class="s1">// So set the cache to avoid duplicate errors.</span><span class="s3">\n      </span><span class="s1">sourceMapCache.set(frame.file, null)</span><span class="s3">\n      </span><span class="s1">return createUnsourcemappedFrame(frame)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sourceMapCache.set(frame.file, {</span><span class="s3">\n      </span><span class="s1">map: sourceMapConsumer,</span><span class="s3">\n      </span><span class="s1">payload: sourceMapPayload,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} else if (sourceMapCacheEntry === null) {</span><span class="s3">\n    </span><span class="s1">// We failed earlier getting the payload or consumer.</span><span class="s3">\n    </span><span class="s1">// Just return an unsourcemapped frame.</span><span class="s3">\n    </span><span class="s1">// Errors will already be logged.</span><span class="s3">\n    </span><span class="s1">return createUnsourcemappedFrame(frame)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">sourceMapConsumer = sourceMapCacheEntry.map</span><span class="s3">\n    </span><span class="s1">sourceMapPayload = sourceMapCacheEntry.payload</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const sourcePosition = sourceMapConsumer.originalPositionFor({</span><span class="s3">\n    </span><span class="s1">column: (frame.column1 ?? 1) - 1,</span><span class="s3">\n    </span><span class="s1">line: frame.line1 ?? 1,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const applicableSourceMap = findApplicableSourceMapPayload(</span><span class="s3">\n    </span><span class="s1">(frame.line1 ?? 1) - 1,</span><span class="s3">\n    </span><span class="s1">(frame.column1 ?? 1) - 1,</span><span class="s3">\n    </span><span class="s1">sourceMapPayload</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">let ignored =</span><span class="s3">\n    </span><span class="s1">applicableSourceMap !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">sourceMapIgnoreListsEverything(applicableSourceMap)</span><span class="s3">\n  </span><span class="s1">if (sourcePosition.source === null) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">stack: {</span><span class="s3">\n        </span><span class="s1">arguments: frame.arguments,</span><span class="s3">\n        </span><span class="s1">file: frame.file,</span><span class="s3">\n        </span><span class="s1">line1: frame.line1,</span><span class="s3">\n        </span><span class="s1">column1: frame.column1,</span><span class="s3">\n        </span><span class="s1">methodName: frame.methodName,</span><span class="s3">\n        </span><span class="s1">ignored: ignored || shouldIgnoreListGeneratedFrame(frame.file),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">code: null,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO(veil): Upstream a method to sourcemap consumer that immediately says if a frame is ignored or not.</span><span class="s3">\n  </span><span class="s1">if (applicableSourceMap === undefined) {</span><span class="s3">\n    </span><span class="s1">console.error('No applicable source map found in sections for frame', frame)</span><span class="s3">\n  </span><span class="s1">} else if (!ignored &amp;&amp; shouldIgnoreListOriginalFrame(sourcePosition.source)) {</span><span class="s3">\n    </span><span class="s1">// Externals may be libraries that don't ship ignoreLists.</span><span class="s3">\n    </span><span class="s1">// This is really taking control away from libraries.</span><span class="s3">\n    </span><span class="s1">// They should still ship `ignoreList` so that attached debuggers ignore-list their frames.</span><span class="s3">\n    </span><span class="s1">// TODO: Maybe only ignore library sourcemaps if `ignoreList` is absent?</span><span class="s3">\n    </span><span class="s1">// Though keep in mind that Turbopack omits empty `ignoreList`.</span><span class="s3">\n    </span><span class="s1">// So if we establish this convention, we should communicate it to the ecosystem.</span><span class="s3">\n    </span><span class="s1">ignored = true</span><span class="s3">\n  </span><span class="s1">} else if (!ignored) {</span><span class="s3">\n    </span><span class="s1">// TODO: O(n^2). Consider moving `ignoreList` into a Set</span><span class="s3">\n    </span><span class="s1">const sourceIndex = applicableSourceMap.sources.indexOf(</span><span class="s3">\n      </span><span class="s1">sourcePosition.source</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">ignored = applicableSourceMap.ignoreList?.includes(sourceIndex) ?? false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const originalFrame: IgnorableStackFrame = {</span><span class="s3">\n    </span><span class="s1">// We ignore the sourcemapped name since it won't be the correct name.</span><span class="s3">\n    </span><span class="s1">// The callsite will point to the column of the variable name instead of the</span><span class="s3">\n    </span><span class="s1">// name of the enclosing function.</span><span class="s3">\n    </span><span class="s1">// TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.</span><span class="s3">\n    </span><span class="s1">methodName: frame.methodName</span><span class="s3">\n      </span><span class="s1">?.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')</span><span class="s3">\n      </span><span class="s1">?.replace('__webpack_exports__.', ''),</span><span class="s3">\n    </span><span class="s1">file: sourcePosition.source,</span><span class="s3">\n    </span><span class="s1">line1: sourcePosition.line,</span><span class="s3">\n    </span><span class="s1">column1: sourcePosition.column + 1,</span><span class="s3">\n    </span><span class="s1">// TODO: c&amp;p from async createOriginalStackFrame but why not frame.arguments?</span><span class="s3">\n    </span><span class="s1">arguments: [],</span><span class="s3">\n    </span><span class="s1">ignored,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/** undefined = not yet computed*/</span><span class="s3">\n  </span><span class="s1">let codeFrame: string | null | undefined</span><span class="s3">\n\n  </span><span class="s1">return Object.defineProperty(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">stack: originalFrame,</span><span class="s3">\n      </span><span class="s1">code: null,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">'code',</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">get: () =&gt; {</span><span class="s3">\n        </span><span class="s1">if (codeFrame === undefined) {</span><span class="s3">\n          </span><span class="s1">const sourceContent: string | null =</span><span class="s3">\n            </span><span class="s1">sourceMapConsumer.sourceContentFor(</span><span class="s3">\n              </span><span class="s1">sourcePosition.source,</span><span class="s3">\n              </span><span class="s1">/* returnNullOnMissing */ true</span><span class="s3">\n            </span><span class="s1">) ?? null</span><span class="s3">\n          </span><span class="s1">codeFrame = getOriginalCodeFrame(</span><span class="s3">\n            </span><span class="s1">originalFrame,</span><span class="s3">\n            </span><span class="s1">sourceContent,</span><span class="s3">\n            </span><span class="s1">inspectOptions.colors</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return codeFrame</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function parseAndSourceMap(</span><span class="s3">\n  </span><span class="s1">error: Error,</span><span class="s3">\n  </span><span class="s1">inspectOptions: util.InspectOptions</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">// TODO(veil): Expose as CLI arg or config option. Useful for local debugging.</span><span class="s3">\n  </span><span class="s1">const showIgnoreListed = false</span><span class="s3">\n  </span><span class="s1">// We overwrote Error.prepareStackTrace earlier so error.stack is not sourcemapped.</span><span class="s3">\n  </span><span class="s1">let unparsedStack = String(error.stack)</span><span class="s3">\n  </span><span class="s1">// We could just read it from `error.stack`.</span><span class="s3">\n  </span><span class="s1">// This works around cases where a 3rd party `Error.prepareStackTrace` implementation</span><span class="s3">\n  </span><span class="s1">// doesn't implement the name computation correctly.</span><span class="s3">\n  </span><span class="s1">const errorName = computeErrorName(error)</span><span class="s3">\n\n  </span><span class="s1">let idx = unparsedStack.indexOf('react_stack_bottom_frame')</span><span class="s3">\n  </span><span class="s1">if (idx !== -1) {</span><span class="s3">\n    </span><span class="s1">idx = unparsedStack.lastIndexOf('</span><span class="s3">\\</span><span class="s1">n', idx)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">idx = unparsedStack.indexOf('react-stack-bottom-frame')</span><span class="s3">\n    </span><span class="s1">if (idx !== -1) {</span><span class="s3">\n      </span><span class="s1">idx = unparsedStack.lastIndexOf('</span><span class="s3">\\</span><span class="s1">n', idx)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (idx !== -1 &amp;&amp; !showIgnoreListed) {</span><span class="s3">\n    </span><span class="s1">// Cut off everything after the bottom frame since it'll be React internals.</span><span class="s3">\n    </span><span class="s1">unparsedStack = unparsedStack.slice(0, idx)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const unsourcemappedStack = parseStack(unparsedStack)</span><span class="s3">\n  </span><span class="s1">const sourceMapCache: SourceMapCache = new Map()</span><span class="s3">\n\n  </span><span class="s1">const sourceMappedFrames: Array&lt;{</span><span class="s3">\n    </span><span class="s1">stack: IgnorableStackFrame</span><span class="s3">\n    </span><span class="s1">code: string | null</span><span class="s3">\n  </span><span class="s1">}&gt; = []</span><span class="s3">\n  </span><span class="s1">let sourceFrame: null | string = null</span><span class="s3">\n  </span><span class="s1">for (const frame of unsourcemappedStack) {</span><span class="s3">\n    </span><span class="s1">if (frame.file === null) {</span><span class="s3">\n      </span><span class="s1">sourceMappedFrames.push({</span><span class="s3">\n        </span><span class="s1">code: null,</span><span class="s3">\n        </span><span class="s1">stack: {</span><span class="s3">\n          </span><span class="s1">file: frame.file,</span><span class="s3">\n          </span><span class="s1">line1: frame.line1,</span><span class="s3">\n          </span><span class="s1">column1: frame.column1,</span><span class="s3">\n          </span><span class="s1">methodName: frame.methodName,</span><span class="s3">\n          </span><span class="s1">arguments: frame.arguments,</span><span class="s3">\n          </span><span class="s1">ignored: false,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const sourcemappedFrame = getSourcemappedFrameIfPossible(</span><span class="s3">\n        </span><span class="s1">// We narrowed this earlier by bailing if `frame.file` is null.</span><span class="s3">\n        </span><span class="s1">frame as SourcemappableStackFrame,</span><span class="s3">\n        </span><span class="s1">sourceMapCache,</span><span class="s3">\n        </span><span class="s1">inspectOptions</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">sourceMappedFrames.push(sourcemappedFrame)</span><span class="s3">\n\n      </span><span class="s1">// We can determine the sourceframe here.</span><span class="s3">\n      </span><span class="s1">// anonymous frames won't have a sourceframe so we don't need to scan</span><span class="s3">\n      </span><span class="s1">// all stacks again to check if they are sandwiched between ignored frames.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">sourceFrame === null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// TODO: Is this the right choice?</span><span class="s3">\n        </span><span class="s1">!sourcemappedFrame.stack.ignored &amp;&amp;</span><span class="s3">\n        </span><span class="s1">sourcemappedFrame.code !== null</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">sourceFrame = sourcemappedFrame.code</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">ignoreListAnonymousStackFramesIfSandwiched(sourceMappedFrames)</span><span class="s3">\n\n  </span><span class="s1">let sourceMappedStack = ''</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; sourceMappedFrames.length; i++) {</span><span class="s3">\n    </span><span class="s1">const frame = sourceMappedFrames[i]</span><span class="s3">\n\n    </span><span class="s1">if (!frame.stack.ignored) {</span><span class="s3">\n      </span><span class="s1">sourceMappedStack +=</span><span class="s3">\n        </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n        </span><span class="s1">frameToString(</span><span class="s3">\n          </span><span class="s1">frame.stack.methodName,</span><span class="s3">\n          </span><span class="s1">frame.stack.file,</span><span class="s3">\n          </span><span class="s1">frame.stack.line1,</span><span class="s3">\n          </span><span class="s1">frame.stack.column1</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (showIgnoreListed) {</span><span class="s3">\n      </span><span class="s1">sourceMappedStack +=</span><span class="s3">\n        </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n        </span><span class="s1">dim(</span><span class="s3">\n          </span><span class="s1">frameToString(</span><span class="s3">\n            </span><span class="s1">frame.stack.methodName,</span><span class="s3">\n            </span><span class="s1">frame.stack.file,</span><span class="s3">\n            </span><span class="s1">frame.stack.line1,</span><span class="s3">\n            </span><span class="s1">frame.stack.column1</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">errorName +</span><span class="s3">\n    </span><span class="s1">': ' +</span><span class="s3">\n    </span><span class="s1">error.message +</span><span class="s3">\n    </span><span class="s1">sourceMappedStack +</span><span class="s3">\n    </span><span class="s1">(sourceFrame !== null ? '</span><span class="s3">\\</span><span class="s1">n' + sourceFrame : '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sourceMapError(</span><span class="s3">\n  </span><span class="s1">this: void,</span><span class="s3">\n  </span><span class="s1">error: Error,</span><span class="s3">\n  </span><span class="s1">inspectOptions: util.InspectOptions</span><span class="s3">\n</span><span class="s1">): Error {</span><span class="s3">\n  </span><span class="s1">// Create a new Error object with the source mapping applied and then use native</span><span class="s3">\n  </span><span class="s1">// Node.js formatting on the result.</span><span class="s3">\n  </span><span class="s1">const newError =</span><span class="s3">\n    </span><span class="s1">error.cause !== undefined</span><span class="s3">\n      </span><span class="s1">? // Setting an undefined `cause` would print `[cause]: undefined`</span><span class="s3">\n        </span><span class="s1">new Error(error.message, { cause: error.cause })</span><span class="s3">\n      </span><span class="s1">: new Error(error.message)</span><span class="s3">\n\n  </span><span class="s1">// TODO: Ensure `class MyError extends Error {}` prints `MyError` as the name</span><span class="s3">\n  </span><span class="s1">newError.stack = parseAndSourceMap(error, inspectOptions)</span><span class="s3">\n\n  </span><span class="s1">for (const key in error) {</span><span class="s3">\n    </span><span class="s1">if (!Object.prototype.hasOwnProperty.call(newError, key)) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error -- We're copying all enumerable properties.</span><span class="s3">\n      </span><span class="s1">// So they definitely exist on `this` and obviously have no type on `newError` (yet)</span><span class="s3">\n      </span><span class="s1">newError[key] = error[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return newError</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function patchErrorInspectNodeJS(</span><span class="s3">\n  </span><span class="s1">errorConstructor: ErrorConstructor</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const inspectSymbol = Symbol.for('nodejs.util.inspect.custom')</span><span class="s3">\n\n  </span><span class="s1">errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error -- TODO upstream types</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-extend-native -- We're not extending but overriding.</span><span class="s3">\n  </span><span class="s1">errorConstructor.prototype[inspectSymbol] = function (</span><span class="s3">\n    </span><span class="s1">depth: number,</span><span class="s3">\n    </span><span class="s1">inspectOptions: util.InspectOptions,</span><span class="s3">\n    </span><span class="s1">inspect: typeof util.inspect</span><span class="s3">\n  </span><span class="s1">): string {</span><span class="s3">\n    </span><span class="s1">// avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.</span><span class="s3">\n    </span><span class="s1">return workUnitAsyncStorage.exit(() =&gt; {</span><span class="s3">\n      </span><span class="s1">const newError = sourceMapError(this, inspectOptions)</span><span class="s3">\n\n      </span><span class="s1">const originalCustomInspect = (newError as any)[inspectSymbol]</span><span class="s3">\n      </span><span class="s1">// Prevent infinite recursion.</span><span class="s3">\n      </span><span class="s1">// { customInspect: false } would result in `error.cause` not using our inspect.</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(newError, inspectSymbol, {</span><span class="s3">\n        </span><span class="s1">value: undefined,</span><span class="s3">\n        </span><span class="s1">enumerable: false,</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return inspect(newError, {</span><span class="s3">\n          </span><span class="s1">...inspectOptions,</span><span class="s3">\n          </span><span class="s1">depth:</span><span class="s3">\n            </span><span class="s1">(inspectOptions.depth ??</span><span class="s3">\n              </span><span class="s1">// Default in Node.js</span><span class="s3">\n              </span><span class="s1">2) - depth,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">;(newError as any)[inspectSymbol] = originalCustomInspect</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function patchErrorInspectEdgeLite(</span><span class="s3">\n  </span><span class="s1">errorConstructor: ErrorConstructor</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const inspectSymbol = Symbol.for('edge-runtime.inspect.custom')</span><span class="s3">\n\n  </span><span class="s1">errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error -- TODO upstream types</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-extend-native -- We're not extending but overriding.</span><span class="s3">\n  </span><span class="s1">errorConstructor.prototype[inspectSymbol] = function ({</span><span class="s3">\n    </span><span class="s1">format,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">format: (...args: unknown[]) =&gt; string</span><span class="s3">\n  </span><span class="s1">}): string {</span><span class="s3">\n    </span><span class="s1">// avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.</span><span class="s3">\n    </span><span class="s1">return workUnitAsyncStorage.exit(() =&gt; {</span><span class="s3">\n      </span><span class="s1">const newError = sourceMapError(this, {})</span><span class="s3">\n\n      </span><span class="s1">const originalCustomInspect = (newError as any)[inspectSymbol]</span><span class="s3">\n      </span><span class="s1">// Prevent infinite recursion.</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(newError, inspectSymbol, {</span><span class="s3">\n        </span><span class="s1">value: undefined,</span><span class="s3">\n        </span><span class="s1">enumerable: false,</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return format(newError)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">;(newError as any)[inspectSymbol] = originalCustomInspect</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { patchErrorInspectNodeJS } from '../patch-error-inspect'</span><span class="s3">\n\n</span><span class="s1">patchErrorInspectNodeJS(globalThis.Error)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { codeFrameColumns } from 'next/dist/compiled/babel/code-frame'</span><span class="s3">\n</span><span class="s1">import isInternal from '../../shared/lib/is-internal'</span><span class="s3">\n</span><span class="s1">import type { StackFrame } from '../../server/lib/parse-stack'</span><span class="s3">\n</span><span class="s1">import { ignoreListAnonymousStackFramesIfSandwiched as ignoreListAnonymousStackFramesIfSandwichedGeneric } from '../../server/lib/source-maps'</span><span class="s3">\n\n</span><span class="s1">export type { StackFrame }</span><span class="s3">\n\n</span><span class="s1">export interface IgnorableStackFrame extends StackFrame {</span><span class="s3">\n  </span><span class="s1">ignored: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface OriginalStackFramesRequest {</span><span class="s3">\n  </span><span class="s1">frames: readonly StackFrame[]</span><span class="s3">\n  </span><span class="s1">isServer: boolean</span><span class="s3">\n  </span><span class="s1">isEdgeServer: boolean</span><span class="s3">\n  </span><span class="s1">isAppDirectory: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type OriginalStackFramesResponse = OriginalStackFrameResponseResult[]</span><span class="s3">\n\n</span><span class="s1">export type OriginalStackFrameResponseResult =</span><span class="s3">\n  </span><span class="s1">PromiseSettledResult&lt;OriginalStackFrameResponse&gt;</span><span class="s3">\n\n</span><span class="s1">export interface OriginalStackFrameResponse {</span><span class="s3">\n  </span><span class="s1">originalStackFrame: (StackFrame &amp; { ignored: boolean }) | null</span><span class="s3">\n  </span><span class="s1">originalCodeFrame: string | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ignoreListAnonymousStackFramesIfSandwiched(</span><span class="s3">\n  </span><span class="s1">responses: OriginalStackFramesResponse</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">ignoreListAnonymousStackFramesIfSandwichedGeneric(</span><span class="s3">\n    </span><span class="s1">responses,</span><span class="s3">\n    </span><span class="s1">(response) =&gt; {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">response.status === 'fulfilled' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">response.value.originalStackFrame !== null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">response.value.originalStackFrame.file === '&lt;anonymous&gt;'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">(response) =&gt; {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">response.status === 'fulfilled' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">response.value.originalStackFrame !== null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">response.value.originalStackFrame.ignored === true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">(response) =&gt; {</span><span class="s3">\n      </span><span class="s1">return response.status === 'fulfilled' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">response.value.originalStackFrame !== null</span><span class="s3">\n        </span><span class="s1">? response.value.originalStackFrame.methodName</span><span class="s3">\n        </span><span class="s1">: ''</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">(response) =&gt; {</span><span class="s3">\n      </span><span class="s1">;(</span><span class="s3">\n        </span><span class="s1">response as PromiseFulfilledResult&lt;OriginalStackFrameResponse&gt;</span><span class="s3">\n      </span><span class="s1">).value.originalStackFrame!.ignored = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* It looks up the code frame of the traced source.</span><span class="s3">\n </span><span class="s1">* @note It ignores Next.js/React internals, as these can often be huge bundled files.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getOriginalCodeFrame(</span><span class="s3">\n  </span><span class="s1">frame: IgnorableStackFrame,</span><span class="s3">\n  </span><span class="s1">source: string | null,</span><span class="s3">\n  </span><span class="s1">colors: boolean = process.stdout.isTTY</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">if (!source || isInternal(frame.file)) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return codeFrameColumns(</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">start: {</span><span class="s3">\n        </span><span class="s1">// 1-based, but -1 means start line without highlighting</span><span class="s3">\n        </span><span class="s1">line: frame.line1 ?? -1,</span><span class="s3">\n        </span><span class="s1">// 1-based, but 0 means whole line without column highlighting</span><span class="s3">\n        </span><span class="s1">column: frame.column1 ?? 0,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ forceColor: colors }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function isHangingPromiseRejectionError(</span><span class="s3">\n  </span><span class="s1">err: unknown</span><span class="s3">\n</span><span class="s1">): err is HangingPromiseRejectionError {</span><span class="s3">\n  </span><span class="s1">if (typeof err !== 'object' || err === null || !('digest' in err)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return err.digest === HANGING_PROMISE_REJECTION</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'</span><span class="s3">\n\n</span><span class="s1">class HangingPromiseRejectionError extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly digest = HANGING_PROMISE_REJECTION</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">public readonly route: string,</span><span class="s3">\n    </span><span class="s1">public readonly expression: string</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using </span><span class="s3">\\</span><span class="s1">`setTimeout</span><span class="s3">\\</span><span class="s1">`, </span><span class="s3">\\</span><span class="s1">`after</span><span class="s3">\\</span><span class="s1">`, or similar functions you may observe this error and you should handle it in that context. This occurred at route </span><span class="s3">\&quot;</span><span class="s1">${route}</span><span class="s3">\&quot;</span><span class="s1">.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type AbortListeners = Array&lt;(err: unknown) =&gt; void&gt;</span><span class="s3">\n</span><span class="s1">const abortListenersBySignal = new WeakMap&lt;AbortSignal, AbortListeners&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function constructs a promise that will never resolve. This is primarily</span><span class="s3">\n </span><span class="s1">* useful for cacheComponents where we use promise resolution timing to determine which</span><span class="s3">\n </span><span class="s1">* parts of a render can be included in a prerender.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function makeHangingPromise&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">signal: AbortSignal,</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">): Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (signal.aborted) {</span><span class="s3">\n    </span><span class="s1">return Promise.reject(new HangingPromiseRejectionError(route, expression))</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const hangingPromise = new Promise&lt;T&gt;((_, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">const boundRejection = reject.bind(</span><span class="s3">\n        </span><span class="s1">null,</span><span class="s3">\n        </span><span class="s1">new HangingPromiseRejectionError(route, expression)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">let currentListeners = abortListenersBySignal.get(signal)</span><span class="s3">\n      </span><span class="s1">if (currentListeners) {</span><span class="s3">\n        </span><span class="s1">currentListeners.push(boundRejection)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const listeners = [boundRejection]</span><span class="s3">\n        </span><span class="s1">abortListenersBySignal.set(signal, listeners)</span><span class="s3">\n        </span><span class="s1">signal.addEventListener(</span><span class="s3">\n          </span><span class="s1">'abort',</span><span class="s3">\n          </span><span class="s1">() =&gt; {</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; listeners.length; i++) {</span><span class="s3">\n              </span><span class="s1">listeners[i]()</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">{ once: true }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">// We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so</span><span class="s3">\n    </span><span class="s1">// we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct</span><span class="s3">\n    </span><span class="s1">// your own promise out of it you'll need to ensure you handle the error when it rejects.</span><span class="s3">\n    </span><span class="s1">hangingPromise.catch(ignoreReject)</span><span class="s3">\n    </span><span class="s1">return hangingPromise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ignoreReject() {}</span><span class="s3">\n\n</span><span class="s1">export function makeDevtoolsIOAwarePromise&lt;T&gt;(underlying: T): Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">// in React DevTools if we resolve in a setTimeout we will observe</span><span class="s3">\n  </span><span class="s1">// the promise resolution as something that can suspend a boundary or root.</span><span class="s3">\n  </span><span class="s1">return new Promise&lt;T&gt;((resolve) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Must use setTimeout to be considered IO React DevTools. setImmediate will not work.</span><span class="s3">\n    </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n      </span><span class="s1">resolve(underlying)</span><span class="s3">\n    </span><span class="s1">}, 0)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class InvariantError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(message: string, options?: ErrorOptions) {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">`Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,</span><span class="s3">\n      </span><span class="s1">options</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.name = 'InvariantError'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The functions provided by this module are used to communicate certain properties</span><span class="s3">\n </span><span class="s1">* about the currently running code so that Next.js can make decisions on how to handle</span><span class="s3">\n </span><span class="s1">* the current execution in different rendering modes such as pre-rendering, resuming, and SSR.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.</span><span class="s3">\n </span><span class="s1">* Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts</span><span class="s3">\n </span><span class="s1">* of a React tree as dynamic while still keeping other parts static. There are really two different kinds of</span><span class="s3">\n </span><span class="s1">* Dynamic indications.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The first is simply an intention to be dynamic. unstable_noStore is an example of this where</span><span class="s3">\n </span><span class="s1">* the currently executing code simply declares that the current scope is dynamic but if you use it</span><span class="s3">\n </span><span class="s1">* inside unstable_cache it can still be cached. This type of indication can be removed if we ever</span><span class="s3">\n </span><span class="s1">* make the default dynamic to begin with because the only way you would ever be static is inside</span><span class="s3">\n </span><span class="s1">* a cache scope which this indication does not affect.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The second is an indication that a dynamic data source was read. This is a stronger form of dynamic</span><span class="s3">\n </span><span class="s1">* because it means that it is inappropriate to cache this at all. using a dynamic data source inside</span><span class="s3">\n </span><span class="s1">* unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should</span><span class="s3">\n </span><span class="s1">* read that data outside the cache and pass it in as an argument to the cached function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type { WorkStore } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">WorkUnitStore,</span><span class="s3">\n  </span><span class="s1">RequestStore,</span><span class="s3">\n  </span><span class="s1">PrerenderStoreLegacy,</span><span class="s3">\n  </span><span class="s1">PrerenderStoreModern,</span><span class="s3">\n  </span><span class="s1">PrerenderStoreModernRuntime,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">// Once postpone is in stable we should switch to importing the postpone export directly</span><span class="s3">\n</span><span class="s1">import React from 'react'</span><span class="s3">\n\n</span><span class="s1">import { DynamicServerError } from '../../client/components/hooks-server-context'</span><span class="s3">\n</span><span class="s1">import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getRuntimeStagePromise,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from './work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { makeHangingPromise } from '../dynamic-rendering-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">METADATA_BOUNDARY_NAME,</span><span class="s3">\n  </span><span class="s1">VIEWPORT_BOUNDARY_NAME,</span><span class="s3">\n  </span><span class="s1">OUTLET_BOUNDARY_NAME,</span><span class="s3">\n  </span><span class="s1">ROOT_LAYOUT_BOUNDARY_NAME,</span><span class="s3">\n</span><span class="s1">} from '../../lib/framework/boundary-constants'</span><span class="s3">\n</span><span class="s1">import { scheduleOnNextTick } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">const hasPostpone = typeof React.unstable_postpone === 'function'</span><span class="s3">\n\n</span><span class="s1">export type DynamicAccess = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If debugging, this will contain the stack trace of where the dynamic access</span><span class="s3">\n   </span><span class="s1">* occurred. This is used to provide more information to the user about why</span><span class="s3">\n   </span><span class="s1">* their page is being rendered dynamically.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">stack?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The expression that was accessed dynamically.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Stores dynamic reasons used during an RSC render.</span><span class="s3">\n</span><span class="s1">export type DynamicTrackingState = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, stack information will also be tracked during dynamic access.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly isDebugDynamicAccesses: boolean | undefined</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The dynamic accesses that occurred during the render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly dynamicAccesses: Array&lt;DynamicAccess&gt;</span><span class="s3">\n\n  </span><span class="s1">syncDynamicErrorWithStack: null | Error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Stores dynamic reasons used during an SSR render.</span><span class="s3">\n</span><span class="s1">export type DynamicValidationState = {</span><span class="s3">\n  </span><span class="s1">hasSuspenseAboveBody: boolean</span><span class="s3">\n  </span><span class="s1">hasDynamicMetadata: boolean</span><span class="s3">\n  </span><span class="s1">hasDynamicViewport: boolean</span><span class="s3">\n  </span><span class="s1">hasAllowedDynamic: boolean</span><span class="s3">\n  </span><span class="s1">dynamicErrors: Array&lt;Error&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createDynamicTrackingState(</span><span class="s3">\n  </span><span class="s1">isDebugDynamicAccesses: boolean | undefined</span><span class="s3">\n</span><span class="s1">): DynamicTrackingState {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">isDebugDynamicAccesses,</span><span class="s3">\n    </span><span class="s1">dynamicAccesses: [],</span><span class="s3">\n    </span><span class="s1">syncDynamicErrorWithStack: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createDynamicValidationState(): DynamicValidationState {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">hasSuspenseAboveBody: false,</span><span class="s3">\n    </span><span class="s1">hasDynamicMetadata: false,</span><span class="s3">\n    </span><span class="s1">hasDynamicViewport: false,</span><span class="s3">\n    </span><span class="s1">hasAllowedDynamic: false,</span><span class="s3">\n    </span><span class="s1">dynamicErrors: [],</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getFirstDynamicReason(</span><span class="s3">\n  </span><span class="s1">trackingState: DynamicTrackingState</span><span class="s3">\n</span><span class="s1">): undefined | string {</span><span class="s3">\n  </span><span class="s1">return trackingState.dynamicAccesses[0]?.expression</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function communicates that the current scope should be treated as dynamic.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In most cases this function is a no-op but if called during</span><span class="s3">\n </span><span class="s1">* a PPR prerender it will postpone the current sub-tree and calling</span><span class="s3">\n </span><span class="s1">* it during a normal prerender will cause the entire prerender to abort</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function markCurrentScopeAsDynamic(</span><span class="s3">\n  </span><span class="s1">store: WorkStore,</span><span class="s3">\n  </span><span class="s1">workUnitStore: undefined | Exclude&lt;WorkUnitStore, PrerenderStoreModern&gt;,</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">// Inside cache scopes, marking a scope as dynamic has no effect,</span><span class="s3">\n        </span><span class="s1">// because the outer cache scope creates a cache boundary. This is</span><span class="s3">\n        </span><span class="s1">// subtly different from reading a dynamic data source, which is</span><span class="s3">\n        </span><span class="s1">// forbidden inside a cache scope.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">// A private cache scope is already dynamic by definition.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we're forcing dynamic rendering or we're forcing static rendering, we</span><span class="s3">\n  </span><span class="s1">// don't need to do anything here because the entire page is already dynamic</span><span class="s3">\n  </span><span class="s1">// or it's static and it should not throw or postpone here.</span><span class="s3">\n  </span><span class="s1">if (store.forceDynamic || store.forceStatic) return</span><span class="s3">\n\n  </span><span class="s1">if (store.dynamicShouldError) {</span><span class="s3">\n    </span><span class="s1">throw new StaticGenBailoutError(</span><span class="s3">\n      </span><span class="s1">`Route ${store.route} with </span><span class="s3">\\</span><span class="s1">`dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;\\</span><span class="s1">` couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n        </span><span class="s1">return postponeWithTracking(</span><span class="s3">\n          </span><span class="s1">store.route,</span><span class="s3">\n          </span><span class="s1">expression,</span><span class="s3">\n          </span><span class="s1">workUnitStore.dynamicTracking</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">workUnitStore.revalidate = 0</span><span class="s3">\n\n        </span><span class="s1">// We aren't prerendering, but we are generating a static page. We need</span><span class="s3">\n        </span><span class="s1">// to bail out of static generation.</span><span class="s3">\n        </span><span class="s1">const err = new DynamicServerError(</span><span class="s3">\n          </span><span class="s1">`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">store.dynamicUsageDescription = expression</span><span class="s3">\n        </span><span class="s1">store.dynamicUsageStack = err.stack</span><span class="s3">\n\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n          </span><span class="s1">workUnitStore.usedDynamic = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is meant to be used when prerendering without cacheComponents or PPR.</span><span class="s3">\n </span><span class="s1">* When called during a build it will cause Next.js to consider the route as dynamic.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function throwToInterruptStaticGeneration(</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">store: WorkStore,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreLegacy</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">// We aren't prerendering but we are generating a static page. We need to bail out of static generation</span><span class="s3">\n  </span><span class="s1">const err = new DynamicServerError(</span><span class="s3">\n    </span><span class="s1">`Route ${store.route} couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">prerenderStore.revalidate = 0</span><span class="s3">\n\n  </span><span class="s1">store.dynamicUsageDescription = expression</span><span class="s3">\n  </span><span class="s1">store.dynamicUsageStack = err.stack</span><span class="s3">\n\n  </span><span class="s1">throw err</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function should be used to track whether something dynamic happened even when</span><span class="s3">\n </span><span class="s1">* we are in a dynamic render. This is useful for Dev where all renders are dynamic but</span><span class="s3">\n </span><span class="s1">* we still track whether dynamic APIs were accessed for helpful messaging</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {</span><span class="s3">\n  </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n    </span><span class="s1">case 'cache':</span><span class="s3">\n    </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n      </span><span class="s1">// Inside cache scopes, marking a scope as dynamic has no effect,</span><span class="s3">\n      </span><span class="s1">// because the outer cache scope creates a cache boundary. This is</span><span class="s3">\n      </span><span class="s1">// subtly different from reading a dynamic data source, which is</span><span class="s3">\n      </span><span class="s1">// forbidden inside a cache scope.</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">// A private cache scope is already dynamic by definition.</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">case 'prerender':</span><span class="s3">\n    </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n    </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n    </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n    </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n        </span><span class="s1">workUnitStore.usedDynamic = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function abortOnSynchronousDynamicDataAccess(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`</span><span class="s3">\n\n  </span><span class="s1">const error = createPrerenderInterruptedError(reason)</span><span class="s3">\n\n  </span><span class="s1">prerenderStore.controller.abort(error)</span><span class="s3">\n\n  </span><span class="s1">const dynamicTracking = prerenderStore.dynamicTracking</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n    </span><span class="s1">dynamicTracking.dynamicAccesses.push({</span><span class="s3">\n      </span><span class="s1">// When we aren't debugging, we don't need to create another error for the</span><span class="s3">\n      </span><span class="s1">// stack trace.</span><span class="s3">\n      </span><span class="s1">stack: dynamicTracking.isDebugDynamicAccesses</span><span class="s3">\n        </span><span class="s1">? new Error().stack</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function abortOnSynchronousPlatformIOAccess(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">errorWithStack: Error,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const dynamicTracking = prerenderStore.dynamicTracking</span><span class="s3">\n  </span><span class="s1">abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)</span><span class="s3">\n  </span><span class="s1">// It is important that we set this tracking value after aborting. Aborts are executed</span><span class="s3">\n  </span><span class="s1">// synchronously except for the case where you abort during render itself. By setting this</span><span class="s3">\n  </span><span class="s1">// value late we can use it to determine if any of the aborted tasks are the task that</span><span class="s3">\n  </span><span class="s1">// called the sync IO expression in the first place.</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n    </span><span class="s1">if (dynamicTracking.syncDynamicErrorWithStack === null) {</span><span class="s3">\n      </span><span class="s1">dynamicTracking.syncDynamicErrorWithStack = errorWithStack</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function trackSynchronousPlatformIOAccessInDev(</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// We don't actually have a controller to abort but we do the semantic equivalent by</span><span class="s3">\n  </span><span class="s1">// advancing the request store out of prerender mode</span><span class="s3">\n  </span><span class="s1">requestStore.prerenderPhase = false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* use this function when prerendering with cacheComponents. If we are doing a</span><span class="s3">\n </span><span class="s1">* prospective prerender we don't actually abort because we want to discover</span><span class="s3">\n </span><span class="s1">* all caches for the shell. If this is the actual prerender we do abort.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function accepts a prerenderStore but the caller should ensure we're</span><span class="s3">\n </span><span class="s1">* actually running in cacheComponents mode.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function abortAndThrowOnSynchronousRequestDataAccess(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">errorWithStack: Error,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">const prerenderSignal = prerenderStore.controller.signal</span><span class="s3">\n  </span><span class="s1">if (prerenderSignal.aborted === false) {</span><span class="s3">\n    </span><span class="s1">// TODO it would be better to move this aborted check into the callsite so we can avoid making</span><span class="s3">\n    </span><span class="s1">// the error object when it isn't relevant to the aborting of the prerender however</span><span class="s3">\n    </span><span class="s1">// since we need the throw semantics regardless of whether we abort it is easier to land</span><span class="s3">\n    </span><span class="s1">// this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer</span><span class="s3">\n    </span><span class="s1">// to ideal implementation</span><span class="s3">\n    </span><span class="s1">abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)</span><span class="s3">\n    </span><span class="s1">// It is important that we set this tracking value after aborting. Aborts are executed</span><span class="s3">\n    </span><span class="s1">// synchronously except for the case where you abort during render itself. By setting this</span><span class="s3">\n    </span><span class="s1">// value late we can use it to determine if any of the aborted tasks are the task that</span><span class="s3">\n    </span><span class="s1">// called the sync IO expression in the first place.</span><span class="s3">\n    </span><span class="s1">const dynamicTracking = prerenderStore.dynamicTracking</span><span class="s3">\n    </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n      </span><span class="s1">if (dynamicTracking.syncDynamicErrorWithStack === null) {</span><span class="s3">\n        </span><span class="s1">dynamicTracking.syncDynamicErrorWithStack = errorWithStack</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw createPrerenderInterruptedError(</span><span class="s3">\n    </span><span class="s1">`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Use this function when dynamically prerendering with dynamicIO.</span><span class="s3">\n </span><span class="s1">* We don't want to error, because it's better to return something</span><span class="s3">\n </span><span class="s1">* (and we've already aborted the render at the point where the sync dynamic error occured),</span><span class="s3">\n </span><span class="s1">* but we should log an error server-side.</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function warnOnSyncDynamicError(dynamicTracking: DynamicTrackingState) {</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking.syncDynamicErrorWithStack) {</span><span class="s3">\n    </span><span class="s1">// the server did something sync dynamic, likely</span><span class="s3">\n    </span><span class="s1">// leading to an early termination of the prerender.</span><span class="s3">\n    </span><span class="s1">console.error(dynamicTracking.syncDynamicErrorWithStack)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// For now these implementations are the same so we just reexport</span><span class="s3">\n</span><span class="s1">export const trackSynchronousRequestDataAccessInDev =</span><span class="s3">\n  </span><span class="s1">trackSynchronousPlatformIOAccessInDev</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This component will call `React.postpone` that throws the postponed error.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type PostponeProps = {</span><span class="s3">\n  </span><span class="s1">reason: string</span><span class="s3">\n  </span><span class="s1">route: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function Postpone({ reason, route }: PostponeProps): never {</span><span class="s3">\n  </span><span class="s1">const prerenderStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">const dynamicTracking =</span><span class="s3">\n    </span><span class="s1">prerenderStore &amp;&amp; prerenderStore.type === 'prerender-ppr'</span><span class="s3">\n      </span><span class="s1">? prerenderStore.dynamicTracking</span><span class="s3">\n      </span><span class="s1">: null</span><span class="s3">\n  </span><span class="s1">postponeWithTracking(route, reason, dynamicTracking)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function postponeWithTracking(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">dynamicTracking: null | DynamicTrackingState</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">assertPostpone()</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n    </span><span class="s1">dynamicTracking.dynamicAccesses.push({</span><span class="s3">\n      </span><span class="s1">// When we aren't debugging, we don't need to create another error for the</span><span class="s3">\n      </span><span class="s1">// stack trace.</span><span class="s3">\n      </span><span class="s1">stack: dynamicTracking.isDebugDynamicAccesses</span><span class="s3">\n        </span><span class="s1">? new Error().stack</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">React.unstable_postpone(createPostponeReason(route, expression))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPostponeReason(route: string, expression: string) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">`Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +</span><span class="s3">\n    </span><span class="s1">`React throws this special object to indicate where. It should not be caught by ` +</span><span class="s3">\n    </span><span class="s1">`your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isDynamicPostpone(err: unknown) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof err === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">err !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof (err as any).message === 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return isDynamicPostponeReason((err as any).message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isDynamicPostponeReason(reason: string) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">reason.includes(</span><span class="s3">\n      </span><span class="s1">'needs to bail out of prerendering at this point because it used'</span><span class="s3">\n    </span><span class="s1">) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">reason.includes(</span><span class="s3">\n      </span><span class="s1">'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    </span><span class="s1">'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'</span><span class="s3">\n\n</span><span class="s1">function createPrerenderInterruptedError(message: string): Error {</span><span class="s3">\n  </span><span class="s1">const error = new Error(message)</span><span class="s3">\n  </span><span class="s1">;(error as any).digest = NEXT_PRERENDER_INTERRUPTED</span><span class="s3">\n  </span><span class="s1">return error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type DigestError = Error &amp; {</span><span class="s3">\n  </span><span class="s1">digest: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isPrerenderInterruptedError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is DigestError {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof error === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(error as any).digest === NEXT_PRERENDER_INTERRUPTED &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'name' in error &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'message' in error &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error instanceof Error</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function accessedDynamicData(</span><span class="s3">\n  </span><span class="s1">dynamicAccesses: Array&lt;DynamicAccess&gt;</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return dynamicAccesses.length &gt; 0</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function consumeDynamicAccess(</span><span class="s3">\n  </span><span class="s1">serverDynamic: DynamicTrackingState,</span><span class="s3">\n  </span><span class="s1">clientDynamic: DynamicTrackingState</span><span class="s3">\n</span><span class="s1">): DynamicTrackingState['dynamicAccesses'] {</span><span class="s3">\n  </span><span class="s1">// We mutate because we only call this once we are no longer writing</span><span class="s3">\n  </span><span class="s1">// to the dynamicTrackingState and it's more efficient than creating a new</span><span class="s3">\n  </span><span class="s1">// array.</span><span class="s3">\n  </span><span class="s1">serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)</span><span class="s3">\n  </span><span class="s1">return serverDynamic.dynamicAccesses</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function formatDynamicAPIAccesses(</span><span class="s3">\n  </span><span class="s1">dynamicAccesses: Array&lt;DynamicAccess&gt;</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">return dynamicAccesses</span><span class="s3">\n    </span><span class="s1">.filter(</span><span class="s3">\n      </span><span class="s1">(access): access is Required&lt;DynamicAccess&gt; =&gt;</span><span class="s3">\n        </span><span class="s1">typeof access.stack === 'string' &amp;&amp; access.stack.length &gt; 0</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">.map(({ expression, stack }) =&gt; {</span><span class="s3">\n      </span><span class="s1">stack = stack</span><span class="s3">\n        </span><span class="s1">.split('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n        </span><span class="s1">// Remove the </span><span class="s3">\&quot;</span><span class="s1">Error: </span><span class="s3">\&quot; </span><span class="s1">prefix from the first line of the stack trace as</span><span class="s3">\n        </span><span class="s1">// well as the first 4 lines of the stack trace which is the distance</span><span class="s3">\n        </span><span class="s1">// from the user code and the `new Error().stack` call.</span><span class="s3">\n        </span><span class="s1">.slice(4)</span><span class="s3">\n        </span><span class="s1">.filter((line) =&gt; {</span><span class="s3">\n          </span><span class="s1">// Exclude Next.js internals from the stack trace.</span><span class="s3">\n          </span><span class="s1">if (line.includes('node_modules/next/')) {</span><span class="s3">\n            </span><span class="s1">return false</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Exclude anonymous functions from the stack trace.</span><span class="s3">\n          </span><span class="s1">if (line.includes(' (&lt;anonymous&gt;)')) {</span><span class="s3">\n            </span><span class="s1">return false</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Exclude Node.js internals from the stack trace.</span><span class="s3">\n          </span><span class="s1">if (line.includes(' (node:')) {</span><span class="s3">\n            </span><span class="s1">return false</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">.join('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n      </span><span class="s1">return `Dynamic API Usage Debug - ${expression}:</span><span class="s3">\\</span><span class="s1">n${stack}`</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assertPostpone() {</span><span class="s3">\n  </span><span class="s1">if (!hasPostpone) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's</span><span class="s3">\n </span><span class="s1">* abort semantics slightly.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createRenderInBrowserAbortSignal(): AbortSignal {</span><span class="s3">\n  </span><span class="s1">const controller = new AbortController()</span><span class="s3">\n  </span><span class="s1">controller.abort(new BailoutToCSRError('Render in Browser'))</span><span class="s3">\n  </span><span class="s1">return controller.signal</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* In a prerender, we may end up with hanging Promises as inputs due them</span><span class="s3">\n </span><span class="s1">* stalling on connection() or because they're loading dynamic data. In that</span><span class="s3">\n </span><span class="s1">* case we need to abort the encoding of arguments since they'll never complete.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createHangingInputAbortSignal(</span><span class="s3">\n  </span><span class="s1">workUnitStore: WorkUnitStore</span><span class="s3">\n</span><span class="s1">): AbortSignal | undefined {</span><span class="s3">\n  </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n    </span><span class="s1">case 'prerender':</span><span class="s3">\n    </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">const controller = new AbortController()</span><span class="s3">\n\n      </span><span class="s1">if (workUnitStore.cacheSignal) {</span><span class="s3">\n        </span><span class="s1">// If we have a cacheSignal it means we're in a prospective render. If</span><span class="s3">\n        </span><span class="s1">// the input we're waiting on is coming from another cache, we do want</span><span class="s3">\n        </span><span class="s1">// to wait for it so that we can resolve this cache entry too.</span><span class="s3">\n        </span><span class="s1">workUnitStore.cacheSignal.inputReady().then(() =&gt; {</span><span class="s3">\n          </span><span class="s1">controller.abort()</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Otherwise we're in the final render and we should already have all</span><span class="s3">\n        </span><span class="s1">// our caches filled.</span><span class="s3">\n        </span><span class="s1">// If the prerender uses stages, we have wait until the runtime stage,</span><span class="s3">\n        </span><span class="s1">// at which point all runtime inputs will be resolved.</span><span class="s3">\n        </span><span class="s1">// (otherwise, a runtime prerender might consider `cookies()` hanging</span><span class="s3">\n        </span><span class="s1">//  even though they'd resolve in the next task.)</span><span class="s3">\n        </span><span class="s1">//</span><span class="s3">\n        </span><span class="s1">// We might still be waiting on some microtasks so we</span><span class="s3">\n        </span><span class="s1">// wait one tick before giving up. When we give up, we still want to</span><span class="s3">\n        </span><span class="s1">// render the content of this cache as deeply as we can so that we can</span><span class="s3">\n        </span><span class="s1">// suspend as deeply as possible in the tree or not at all if we don't</span><span class="s3">\n        </span><span class="s1">// end up waiting for the input.</span><span class="s3">\n        </span><span class="s1">const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)</span><span class="s3">\n        </span><span class="s1">if (runtimeStagePromise) {</span><span class="s3">\n          </span><span class="s1">runtimeStagePromise.then(() =&gt;</span><span class="s3">\n            </span><span class="s1">scheduleOnNextTick(() =&gt; controller.abort())</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">scheduleOnNextTick(() =&gt; controller.abort())</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return controller.signal</span><span class="s3">\n    </span><span class="s1">case 'prerender-client':</span><span class="s3">\n    </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n    </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n    </span><span class="s1">case 'request':</span><span class="s3">\n    </span><span class="s1">case 'cache':</span><span class="s3">\n    </span><span class="s1">case 'private-cache':</span><span class="s3">\n    </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function annotateDynamicAccess(</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const dynamicTracking = prerenderStore.dynamicTracking</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n    </span><span class="s1">dynamicTracking.dynamicAccesses.push({</span><span class="s3">\n      </span><span class="s1">stack: dynamicTracking.isDebugDynamicAccesses</span><span class="s3">\n        </span><span class="s1">? new Error().stack</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function useDynamicRouteParams(expression: string) {</span><span class="s3">\n  </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workStore &amp;&amp; workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender': {</span><span class="s3">\n        </span><span class="s1">const fallbackParams = workUnitStore.fallbackRouteParams</span><span class="s3">\n        </span><span class="s1">if (fallbackParams &amp;&amp; fallbackParams.size &gt; 0) {</span><span class="s3">\n          </span><span class="s1">// We are in a prerender with cacheComponents semantics. We are going to</span><span class="s3">\n          </span><span class="s1">// hang here and never resolve. This will cause the currently</span><span class="s3">\n          </span><span class="s1">// rendering component to effectively be a dynamic hole.</span><span class="s3">\n          </span><span class="s1">React.use(</span><span class="s3">\n            </span><span class="s1">makeHangingPromise(</span><span class="s3">\n              </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n              </span><span class="s1">workStore.route,</span><span class="s3">\n              </span><span class="s1">expression</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr': {</span><span class="s3">\n        </span><span class="s1">const fallbackParams = workUnitStore.fallbackRouteParams</span><span class="s3">\n        </span><span class="s1">if (fallbackParams &amp;&amp; fallbackParams.size &gt; 0) {</span><span class="s3">\n          </span><span class="s1">return postponeWithTracking(</span><span class="s3">\n            </span><span class="s1">workStore.route,</span><span class="s3">\n            </span><span class="s1">expression,</span><span class="s3">\n            </span><span class="s1">workUnitStore.dynamicTracking</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const hasSuspenseRegex = /</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">s+at Suspense </span><span class="s3">\\</span><span class="s1">(&lt;anonymous&gt;</span><span class="s3">\\</span><span class="s1">)/</span><span class="s3">\n\n</span><span class="s1">// Common implicit body tags that React will treat as body when placed directly in html</span><span class="s3">\n</span><span class="s1">const bodyAndImplicitTags =</span><span class="s3">\n  </span><span class="s1">'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'</span><span class="s3">\n\n</span><span class="s1">// Detects when RootLayoutBoundary (our framework marker component) appears</span><span class="s3">\n</span><span class="s1">// after Suspense in the component stack, indicating the root layout is wrapped</span><span class="s3">\n</span><span class="s1">// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Example matches:</span><span class="s3">\n</span><span class="s1">//   at Suspense (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">//   at __next_root_layout_boundary__ (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Or with other components in between (but not body/html/implicit-body):</span><span class="s3">\n</span><span class="s1">//   at Suspense (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">//   at SomeComponent (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">//   at __next_root_layout_boundary__ (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">const hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(</span><span class="s3">\n  </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at Suspense </span><span class="s3">\\\\</span><span class="s1">(&lt;anonymous&gt;</span><span class="s3">\\\\</span><span class="s1">)(?:(?!</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at (?:${bodyAndImplicitTags}) </span><span class="s3">\\\\</span><span class="s1">(&lt;anonymous&gt;</span><span class="s3">\\\\</span><span class="s1">))[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S])*?</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at ${ROOT_LAYOUT_BOUNDARY_NAME} </span><span class="s3">\\\\</span><span class="s1">([^</span><span class="s3">\\\\</span><span class="s1">n]*</span><span class="s3">\\\\</span><span class="s1">)`</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">const hasMetadataRegex = new RegExp(</span><span class="s3">\n  </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at ${METADATA_BOUNDARY_NAME}[</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s]`</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const hasViewportRegex = new RegExp(</span><span class="s3">\n  </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at ${VIEWPORT_BOUNDARY_NAME}[</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s]`</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const hasOutletRegex = new RegExp(`</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at ${OUTLET_BOUNDARY_NAME}[</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s]`)</span><span class="s3">\n\n</span><span class="s1">export function trackAllowedDynamicAccess(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">componentStack: string,</span><span class="s3">\n  </span><span class="s1">dynamicValidation: DynamicValidationState,</span><span class="s3">\n  </span><span class="s1">clientDynamic: DynamicTrackingState</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (hasOutletRegex.test(componentStack)) {</span><span class="s3">\n    </span><span class="s1">// We don't need to track that this is dynamic. It is only so when something else is also dynamic.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (hasMetadataRegex.test(componentStack)) {</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasDynamicMetadata = true</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (hasViewportRegex.test(componentStack)) {</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasDynamicViewport = true</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(</span><span class="s3">\n      </span><span class="s1">componentStack</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.</span><span class="s3">\n    </span><span class="s1">// But if you have Suspense above body, the prelude is empty but we allow that because having Suspense</span><span class="s3">\n    </span><span class="s1">// is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasAllowedDynamic = true</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasSuspenseAboveBody = true</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (hasSuspenseRegex.test(componentStack)) {</span><span class="s3">\n    </span><span class="s1">// this error had a Suspense boundary above it so we don't need to report it as a source</span><span class="s3">\n    </span><span class="s1">// of disallowed</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasAllowedDynamic = true</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (clientDynamic.syncDynamicErrorWithStack) {</span><span class="s3">\n    </span><span class="s1">// This task was the task that called the sync error.</span><span class="s3">\n    </span><span class="s1">dynamicValidation.dynamicErrors.push(</span><span class="s3">\n      </span><span class="s1">clientDynamic.syncDynamicErrorWithStack</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const message = `Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot;</span><span class="s1">: A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`</span><span class="s3">\n    </span><span class="s1">const error = createErrorWithComponentOrOwnerStack(message, componentStack)</span><span class="s3">\n    </span><span class="s1">dynamicValidation.dynamicErrors.push(error)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* In dev mode, we prefer using the owner stack, otherwise the provided</span><span class="s3">\n </span><span class="s1">* component stack is used.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createErrorWithComponentOrOwnerStack(</span><span class="s3">\n  </span><span class="s1">message: string,</span><span class="s3">\n  </span><span class="s1">componentStack: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const ownerStack =</span><span class="s3">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; React.captureOwnerStack</span><span class="s3">\n      </span><span class="s1">? React.captureOwnerStack()</span><span class="s3">\n      </span><span class="s1">: null</span><span class="s3">\n\n  </span><span class="s1">const error = new Error(message)</span><span class="s3">\n  </span><span class="s1">error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)</span><span class="s3">\n  </span><span class="s1">return error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export enum PreludeState {</span><span class="s3">\n  </span><span class="s1">Full = 0,</span><span class="s3">\n  </span><span class="s1">Empty = 1,</span><span class="s3">\n  </span><span class="s1">Errored = 2,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function logDisallowedDynamicError(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">error: Error</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">console.error(error)</span><span class="s3">\n\n  </span><span class="s1">if (!workStore.dev) {</span><span class="s3">\n    </span><span class="s1">if (workStore.hasReadableErrorStacks) {</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running </span><span class="s3">\\</span><span class="s1">`next dev</span><span class="s3">\\</span><span class="s1">`, then open </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">in your browser to investigate the error.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:</span><span class="s3">\n  </span><span class="s1">- Start the app in development mode by running </span><span class="s3">\\</span><span class="s1">`next dev</span><span class="s3">\\</span><span class="s1">`, then open </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">in your browser to investigate the error.</span><span class="s3">\n  </span><span class="s1">- Rerun the production build with </span><span class="s3">\\</span><span class="s1">`next build --debug-prerender</span><span class="s3">\\</span><span class="s1">` to generate better stack traces.`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function throwIfDisallowedDynamic(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">prelude: PreludeState,</span><span class="s3">\n  </span><span class="s1">dynamicValidation: DynamicValidationState,</span><span class="s3">\n  </span><span class="s1">serverDynamic: DynamicTrackingState</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">if (prelude !== PreludeState.Full) {</span><span class="s3">\n    </span><span class="s1">if (dynamicValidation.hasSuspenseAboveBody) {</span><span class="s3">\n      </span><span class="s1">// This route has opted into allowing fully dynamic rendering</span><span class="s3">\n      </span><span class="s1">// by including a Suspense boundary above the body. In this case</span><span class="s3">\n      </span><span class="s1">// a lack of a shell is not considered disallowed so we simply return</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (serverDynamic.syncDynamicErrorWithStack) {</span><span class="s3">\n      </span><span class="s1">// There is no shell and the server did something sync dynamic likely</span><span class="s3">\n      </span><span class="s1">// leading to an early termination of the prerender before the shell</span><span class="s3">\n      </span><span class="s1">// could be completed. We terminate the build/validating render.</span><span class="s3">\n      </span><span class="s1">logDisallowedDynamicError(</span><span class="s3">\n        </span><span class="s1">workStore,</span><span class="s3">\n        </span><span class="s1">serverDynamic.syncDynamicErrorWithStack</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We didn't have any sync bailouts but there may be user code which</span><span class="s3">\n    </span><span class="s1">// blocked the root. We would have captured these during the prerender</span><span class="s3">\n    </span><span class="s1">// and can log them here and then terminate the build/validating render</span><span class="s3">\n    </span><span class="s1">const dynamicErrors = dynamicValidation.dynamicErrors</span><span class="s3">\n    </span><span class="s1">if (dynamicErrors.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; dynamicErrors.length; i++) {</span><span class="s3">\n        </span><span class="s1">logDisallowedDynamicError(workStore, dynamicErrors[i])</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we got this far then the only other thing that could be blocking</span><span class="s3">\n    </span><span class="s1">// the root is dynamic Viewport. If this is dynamic then</span><span class="s3">\n    </span><span class="s1">// you need to opt into that by adding a Suspense boundary above the body</span><span class="s3">\n    </span><span class="s1">// to indicate your are ok with fully dynamic rendering.</span><span class="s3">\n    </span><span class="s1">if (dynamicValidation.hasDynamicViewport) {</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">has a </span><span class="s3">\\</span><span class="s1">`generateViewport</span><span class="s3">\\</span><span class="s1">` that depends on Request data (</span><span class="s3">\\</span><span class="s1">`cookies()</span><span class="s3">\\</span><span class="s1">`, etc...) or uncached external data (</span><span class="s3">\\</span><span class="s1">`fetch(...)</span><span class="s3">\\</span><span class="s1">`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (prelude === PreludeState.Empty) {</span><span class="s3">\n      </span><span class="s1">// If we ever get this far then we messed up the tracking of invalid dynamic.</span><span class="s3">\n      </span><span class="s1">// We still adhere to the constraint that you must produce a shell but invite the</span><span class="s3">\n      </span><span class="s1">// user to report this as a bug in Next.js.</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">dynamicValidation.hasAllowedDynamic === false &amp;&amp;</span><span class="s3">\n      </span><span class="s1">dynamicValidation.hasDynamicMetadata</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">has a </span><span class="s3">\\</span><span class="s1">`generateMetadata</span><span class="s3">\\</span><span class="s1">` that depends on Request data (</span><span class="s3">\\</span><span class="s1">`cookies()</span><span class="s3">\\</span><span class="s1">`, etc...) or uncached external data (</span><span class="s3">\\</span><span class="s1">`fetch(...)</span><span class="s3">\\</span><span class="s1">`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function delayUntilRuntimeStage&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModernRuntime,</span><span class="s3">\n  </span><span class="s1">result: Promise&lt;T&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (prerenderStore.runtimeStagePromise) {</span><span class="s3">\n    </span><span class="s1">return prerenderStore.runtimeStagePromise.then(() =&gt; result)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { workAsyncStorage } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type PrerenderStoreModern,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">abortOnSynchronousPlatformIOAccess,</span><span class="s3">\n  </span><span class="s1">trackSynchronousPlatformIOAccessInDev,</span><span class="s3">\n</span><span class="s1">} from '../app-render/dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">type ApiType = 'time' | 'random' | 'crypto'</span><span class="s3">\n\n</span><span class="s1">export function io(expression: string, type: ApiType) {</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n\n  </span><span class="s1">if (!workUnitStore || !workStore) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n    </span><span class="s1">case 'prerender':</span><span class="s3">\n    </span><span class="s1">case 'prerender-runtime': {</span><span class="s3">\n      </span><span class="s1">const prerenderSignal = workUnitStore.controller.signal</span><span class="s3">\n\n      </span><span class="s1">if (prerenderSignal.aborted === false) {</span><span class="s3">\n        </span><span class="s1">// If the prerender signal is already aborted we don't need to construct</span><span class="s3">\n        </span><span class="s1">// any stacks because something else actually terminated the prerender.</span><span class="s3">\n        </span><span class="s1">let message: string</span><span class="s3">\n        </span><span class="s1">switch (type) {</span><span class="s3">\n          </span><span class="s1">case 'time':</span><span class="s3">\n            </span><span class="s1">message = `Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">used ${expression} instead of using </span><span class="s3">\\</span><span class="s1">`performance</span><span class="s3">\\</span><span class="s1">` or without explicitly calling </span><span class="s3">\\</span><span class="s1">`await connection()</span><span class="s3">\\</span><span class="s1">` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">case 'random':</span><span class="s3">\n            </span><span class="s1">message = `Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">used ${expression} outside of </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;\\</span><span class="s1">` and without explicitly calling </span><span class="s3">\\</span><span class="s1">`await connection()</span><span class="s3">\\</span><span class="s1">` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-random`</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">case 'crypto':</span><span class="s3">\n            </span><span class="s1">message = `Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">used ${expression} outside of </span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;\\</span><span class="s1">` and without explicitly calling </span><span class="s3">\\</span><span class="s1">`await connection()</span><span class="s3">\\</span><span class="s1">` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">throw new InvariantError(</span><span class="s3">\n              </span><span class="s1">'Unknown expression type in abortOnSynchronousPlatformIOAccess.'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">abortOnSynchronousPlatformIOAccess(</span><span class="s3">\n          </span><span class="s1">workStore.route,</span><span class="s3">\n          </span><span class="s1">expression,</span><span class="s3">\n          </span><span class="s1">applyOwnerStack(new Error(message), workUnitStore),</span><span class="s3">\n          </span><span class="s1">workUnitStore</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case 'prerender-client': {</span><span class="s3">\n      </span><span class="s1">const prerenderSignal = workUnitStore.controller.signal</span><span class="s3">\n\n      </span><span class="s1">if (prerenderSignal.aborted === false) {</span><span class="s3">\n        </span><span class="s1">// If the prerender signal is already aborted we don't need to construct</span><span class="s3">\n        </span><span class="s1">// any stacks because something else actually terminated the prerender.</span><span class="s3">\n        </span><span class="s1">let message: string</span><span class="s3">\n        </span><span class="s1">switch (type) {</span><span class="s3">\n          </span><span class="s1">case 'time':</span><span class="s3">\n            </span><span class="s1">message = `Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time-client`</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">case 'random':</span><span class="s3">\n            </span><span class="s1">message = `Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-random-client`</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">case 'crypto':</span><span class="s3">\n            </span><span class="s1">message = `Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto-client`</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">throw new InvariantError(</span><span class="s3">\n              </span><span class="s1">'Unknown expression type in abortOnSynchronousPlatformIOAccess.'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">abortOnSynchronousPlatformIOAccess(</span><span class="s3">\n          </span><span class="s1">workStore.route,</span><span class="s3">\n          </span><span class="s1">expression,</span><span class="s3">\n          </span><span class="s1">applyOwnerStack(new Error(message), workUnitStore),</span><span class="s3">\n          </span><span class="s1">workUnitStore</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">if (workUnitStore.prerenderPhase === true) {</span><span class="s3">\n        </span><span class="s1">trackSynchronousPlatformIOAccessInDev(workUnitStore)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n    </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n    </span><span class="s1">case 'cache':</span><span class="s3">\n    </span><span class="s1">case 'private-cache':</span><span class="s3">\n    </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyOwnerStack(error: Error, workUnitStore: PrerenderStoreModern) {</span><span class="s3">\n  </span><span class="s1">// TODO: Instead of stitching the stacks here, we should log the original</span><span class="s3">\n  </span><span class="s1">// error as-is when it occurs, and let `patchErrorInspect` handle adding the</span><span class="s3">\n  </span><span class="s1">// owner stack, instead of logging it deferred in the `LogSafely` component</span><span class="s3">\n  </span><span class="s1">// via `throwIfDisallowedDynamic`.</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">workUnitStore.captureOwnerStack</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const ownerStack = workUnitStore.captureOwnerStack()</span><span class="s3">\n\n    </span><span class="s1">if (ownerStack) {</span><span class="s3">\n      </span><span class="s1">let stack = ownerStack</span><span class="s3">\n\n      </span><span class="s1">if (error.stack) {</span><span class="s3">\n        </span><span class="s1">const frames: string[] = []</span><span class="s3">\n\n        </span><span class="s1">for (const frame of error.stack.split('</span><span class="s3">\\</span><span class="s1">n').slice(1)) {</span><span class="s3">\n          </span><span class="s1">if (frame.includes('react_stack_bottom_frame')) {</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">frames.push(frame)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">stack = '</span><span class="s3">\\</span><span class="s1">n' + frames.join('</span><span class="s3">\\</span><span class="s1">n') + stack</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">error.stack = error.name + ': ' + error.message + stack</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* We extend Math.random() during builds and revalidates to ensure that prerenders don't observe randomness</span><span class="s3">\n </span><span class="s1">* When cacheComponents is enabled. randomness is a form of IO even though it resolves synchronously. When cacheComponents is</span><span class="s3">\n </span><span class="s1">* enabled we need to ensure that randomness is excluded from prerenders.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The extensions here never error nor alter the random generation itself and thus should be transparent to callers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import { io } from './utils'</span><span class="s3">\n\n</span><span class="s1">const expression = '`Math.random()`'</span><span class="s3">\n</span><span class="s1">try {</span><span class="s3">\n  </span><span class="s1">const _random = Math.random</span><span class="s3">\n  </span><span class="s1">Math.random = function random() {</span><span class="s3">\n    </span><span class="s1">io(expression, 'random')</span><span class="s3">\n    </span><span class="s1">return _random.apply(null, arguments as any)</span><span class="s3">\n\n    </span><span class="s1">// We bind here to alter the `toString` printing to match `Math.random`'s native `toString`.</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line no-extra-bind</span><span class="s3">\n  </span><span class="s1">}.bind(null)</span><span class="s3">\n  </span><span class="s1">Object.defineProperty(Math.random, 'name', { value: 'random' })</span><span class="s3">\n</span><span class="s1">} catch {</span><span class="s3">\n  </span><span class="s1">console.error(</span><span class="s3">\n    </span><span class="s1">`Failed to install ${expression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function will not correctly trigger dynamic behavior.`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* We extend `Date` during builds and revalidates to ensure that prerenders don't observe the clock as a source of IO</span><span class="s3">\n </span><span class="s1">* When cacheComponents is enabled. The current time is a form of IO even though it resolves synchronously. When cacheComponents is</span><span class="s3">\n </span><span class="s1">* enabled we need to ensure that clock time is excluded from prerenders unless it is cached.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* There is tension here because time is used for both output and introspection. While arbitrary we intend to reserve</span><span class="s3">\n </span><span class="s1">* `Date` for output use cases and `performance` for introspection use cases. If you want to measure</span><span class="s3">\n </span><span class="s1">* how long something takes use `performance.timeOrigin` and `performance.now()` rather than `Date.now()` for instance.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The extensions here never error nor alter the underlying Date objects, strings, and numbers created and thus should be transparent to callers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">import { io } from './utils'</span><span class="s3">\n\n</span><span class="s1">function createNow(originalNow: typeof Date.now) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">now: function now() {</span><span class="s3">\n      </span><span class="s1">io('`Date.now()`', 'time')</span><span class="s3">\n      </span><span class="s1">return originalNow()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}['now'.slice() as 'now'].bind(null)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createDate(originalConstructor: typeof Date): typeof Date {</span><span class="s3">\n  </span><span class="s1">const properties = Object.getOwnPropertyDescriptors(originalConstructor)</span><span class="s3">\n  </span><span class="s1">properties.now.value = createNow(originalConstructor.now)</span><span class="s3">\n\n  </span><span class="s1">const apply = Reflect.apply</span><span class="s3">\n  </span><span class="s1">const construct = Reflect.construct</span><span class="s3">\n\n  </span><span class="s1">const newConstructor = Object.defineProperties(</span><span class="s3">\n    </span><span class="s1">// Ideally this should not minify the name.</span><span class="s3">\n    </span><span class="s1">function Date() {</span><span class="s3">\n      </span><span class="s1">if (new.target === undefined) {</span><span class="s3">\n        </span><span class="s1">io('`Date()`', 'time')</span><span class="s3">\n        </span><span class="s1">return apply(originalConstructor, undefined, arguments)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (arguments.length === 0) {</span><span class="s3">\n        </span><span class="s1">io('`new Date()`', 'time')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return construct(originalConstructor, arguments, new.target)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">properties</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">Object.defineProperty(originalConstructor.prototype, 'constructor', {</span><span class="s3">\n    </span><span class="s1">value: newConstructor,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return newConstructor as typeof Date</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">try {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-native-reassign</span><span class="s3">\n  </span><span class="s1">Date = createDate(Date)</span><span class="s3">\n</span><span class="s1">} catch {</span><span class="s3">\n  </span><span class="s1">console.error(</span><span class="s3">\n    </span><span class="s1">'Failed to install `Date` class extension. When using `experimental.cacheComponents`, APIs that read the current time will not correctly trigger dynamic behavior.'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* We extend node:crypto APIs during builds and revalidates to ensure that prerenders don't observe random bytes</span><span class="s3">\n </span><span class="s1">* When cacheComponents is enabled. Random bytes are a form of IO even if they resolve synchronously. When cacheComponents is</span><span class="s3">\n </span><span class="s1">* enabled we need to ensure that random bytes are excluded from prerenders unless they are cached.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The extensions here never error nor alter the underlying return values and thus should be transparent to callers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import { io } from './utils'</span><span class="s3">\n\n</span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n  </span><span class="s1">// nothing to patch</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">const nodeCrypto = require('node:crypto') as typeof import('node:crypto')</span><span class="s3">\n\n  </span><span class="s1">// require('node:crypto').getRandomValues is an alias for</span><span class="s3">\n  </span><span class="s1">// crypto.getRandomValues which is extended in web-crypto.tsx</span><span class="s3">\n\n  </span><span class="s1">// require('node:crypto').randomUUID is not an alias for crypto.randomUUID</span><span class="s3">\n\n  </span><span class="s1">const randomUUIDExpression = </span><span class="s3">\&quot;</span><span class="s1">`require('node:crypto').randomUUID()`</span><span class="s3">\&quot;\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const _randomUUID = nodeCrypto.randomUUID</span><span class="s3">\n    </span><span class="s1">nodeCrypto.randomUUID = function randomUUID() {</span><span class="s3">\n      </span><span class="s1">io(randomUUIDExpression, 'random')</span><span class="s3">\n      </span><span class="s1">return _randomUUID.apply(this, arguments as any)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`Failed to install ${randomUUIDExpression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function will not correctly trigger dynamic behavior.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const randomBytesExpression = </span><span class="s3">\&quot;</span><span class="s1">`require('node:crypto').randomBytes(size)`</span><span class="s3">\&quot;\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const _randomBytes = nodeCrypto.randomBytes</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error -- TODO: tell TS the overloads are preserved</span><span class="s3">\n    </span><span class="s1">nodeCrypto.randomBytes = function randomBytes() {</span><span class="s3">\n      </span><span class="s1">if (typeof arguments[1] !== 'function') {</span><span class="s3">\n        </span><span class="s1">// randomBytes is sync if the second arg is undefined</span><span class="s3">\n        </span><span class="s1">io(randomBytesExpression, 'random')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return _randomBytes.apply(this, arguments as any)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`Failed to install ${randomBytesExpression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function without a callback argument will not correctly trigger dynamic behavior.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const randomFillSyncExpression =</span><span class="s3">\n    \&quot;</span><span class="s1">`require('node:crypto').randomFillSync(...)`</span><span class="s3">\&quot;\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const _randomFillSync = nodeCrypto.randomFillSync</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error -- TODO: tell TS the overloads are preserved</span><span class="s3">\n    </span><span class="s1">nodeCrypto.randomFillSync = function randomFillSync() {</span><span class="s3">\n      </span><span class="s1">io(randomFillSyncExpression, 'random')</span><span class="s3">\n      </span><span class="s1">return _randomFillSync.apply(this, arguments as any)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`Failed to install ${randomFillSyncExpression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function will not correctly trigger dynamic behavior.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const randomIntExpression = </span><span class="s3">\&quot;</span><span class="s1">`require('node:crypto').randomInt(min, max)`</span><span class="s3">\&quot;\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const _randomInt = nodeCrypto.randomInt</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error -- TODO: tell TS the overloads are preserved</span><span class="s3">\n    </span><span class="s1">nodeCrypto.randomInt = function randomInt() {</span><span class="s3">\n      </span><span class="s1">if (typeof arguments[2] !== 'function') {</span><span class="s3">\n        </span><span class="s1">// randomInt is sync if the third arg is undefined</span><span class="s3">\n        </span><span class="s1">io(randomIntExpression, 'random')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return _randomInt.apply(this, arguments as any)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`Failed to install ${randomBytesExpression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function without a callback argument will not correctly trigger dynamic behavior.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const generatePrimeSyncExpression =</span><span class="s3">\n    \&quot;</span><span class="s1">`require('node:crypto').generatePrimeSync(...)`</span><span class="s3">\&quot;\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const _generatePrimeSync = nodeCrypto.generatePrimeSync</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error -- TODO: tell TS the overloads are preserved</span><span class="s3">\n    </span><span class="s1">nodeCrypto.generatePrimeSync = function generatePrimeSync() {</span><span class="s3">\n      </span><span class="s1">io(generatePrimeSyncExpression, 'random')</span><span class="s3">\n      </span><span class="s1">return _generatePrimeSync.apply(this, arguments as any)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`Failed to install ${generatePrimeSyncExpression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function will not correctly trigger dynamic behavior.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const generateKeyPairSyncExpression =</span><span class="s3">\n    \&quot;</span><span class="s1">`require('node:crypto').generateKeyPairSync(...)`</span><span class="s3">\&quot;\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const _generateKeyPairSync = nodeCrypto.generateKeyPairSync</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error -- TODO: tell TS the overloads are preserved</span><span class="s3">\n    </span><span class="s1">nodeCrypto.generateKeyPairSync = function generateKeyPairSync() {</span><span class="s3">\n      </span><span class="s1">io(generateKeyPairSyncExpression, 'random')</span><span class="s3">\n      </span><span class="s1">return _generateKeyPairSync.apply(this, arguments as any)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`Failed to install ${generateKeyPairSyncExpression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function will not correctly trigger dynamic behavior.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const generateKeySyncExpression =</span><span class="s3">\n    \&quot;</span><span class="s1">`require('node:crypto').generateKeySync(...)`</span><span class="s3">\&quot;\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const _generateKeySync = nodeCrypto.generateKeySync</span><span class="s3">\n    </span><span class="s1">nodeCrypto.generateKeySync = function generateKeySync() {</span><span class="s3">\n      </span><span class="s1">io(generateKeySyncExpression, 'random')</span><span class="s3">\n      </span><span class="s1">return _generateKeySync.apply(this, arguments as any)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`Failed to install ${generateKeySyncExpression} extension. When using </span><span class="s3">\\</span><span class="s1">`experimental.cacheComponents</span><span class="s3">\\</span><span class="s1">` calling this function will not correctly trigger dynamic behavior.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Synchronously inject a require hook for webpack and webpack/. It's required to use the internal ncc webpack version.</span><span class="s3">\n</span><span class="s1">// This is needed for userland plugins to attach to the same webpack instance as Next.js'.</span><span class="s3">\n</span><span class="s1">// Individually compiled modules are as defined for the compilation in bundles/webpack/packages/*.</span><span class="s3">\n\n</span><span class="s1">// This module will only be loaded once per process.</span><span class="s3">\n</span><span class="s1">const path = require('path') as typeof import('path')</span><span class="s3">\n</span><span class="s1">const mod = require('module') as typeof import('module')</span><span class="s3">\n</span><span class="s1">const originalRequire = mod.prototype.require</span><span class="s3">\n</span><span class="s1">const resolveFilename =</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error</span><span class="s3">\n  </span><span class="s1">mod._resolveFilename</span><span class="s3">\n\n</span><span class="s1">let resolve: typeof require.resolve = process.env.NEXT_MINIMAL</span><span class="s3">\n  </span><span class="s1">? // @ts-ignore</span><span class="s3">\n    </span><span class="s1">__non_webpack_require__.resolve</span><span class="s3">\n  </span><span class="s1">: require.resolve</span><span class="s3">\n\n</span><span class="s1">export const hookPropertyMap = new Map()</span><span class="s3">\n\n</span><span class="s1">export const defaultOverrides = {</span><span class="s3">\n  </span><span class="s1">'styled-jsx': path.dirname(resolve('styled-jsx/package.json')),</span><span class="s3">\n  </span><span class="s1">'styled-jsx/style': resolve('styled-jsx/style'),</span><span class="s3">\n  </span><span class="s1">'styled-jsx/style.js': resolve('styled-jsx/style'),</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const toResolveMap = (map: Record&lt;string, string&gt;): [string, string][] =&gt;</span><span class="s3">\n  </span><span class="s1">Object.entries(map).map(([key, value]) =&gt; [key, resolve(value)])</span><span class="s3">\n\n</span><span class="s1">export function addHookAliases(aliases: [string, string][] = []) {</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of aliases) {</span><span class="s3">\n    </span><span class="s1">hookPropertyMap.set(key, value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">addHookAliases(toResolveMap(defaultOverrides))</span><span class="s3">\n\n</span><span class="s1">// @ts-expect-error</span><span class="s3">\n</span><span class="s1">mod._resolveFilename = function (</span><span class="s3">\n  </span><span class="s1">originalResolveFilename: (</span><span class="s3">\n    </span><span class="s1">request: string,</span><span class="s3">\n    </span><span class="s1">parent: string,</span><span class="s3">\n    </span><span class="s1">isMain: boolean,</span><span class="s3">\n    </span><span class="s1">opts: any</span><span class="s3">\n  </span><span class="s1">) =&gt; string,</span><span class="s3">\n  </span><span class="s1">requestMap: Map&lt;string, string&gt;,</span><span class="s3">\n  </span><span class="s1">request: string,</span><span class="s3">\n  </span><span class="s1">parent: string,</span><span class="s3">\n  </span><span class="s1">isMain: boolean,</span><span class="s3">\n  </span><span class="s1">options: any</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const hookResolved = requestMap.get(request)</span><span class="s3">\n  </span><span class="s1">if (hookResolved) request = hookResolved</span><span class="s3">\n\n  </span><span class="s1">return originalResolveFilename.call(mod, request, parent, isMain, options)</span><span class="s3">\n\n  </span><span class="s1">// We use `bind` here to avoid referencing outside variables to create potential memory leaks.</span><span class="s3">\n</span><span class="s1">}.bind(null, resolveFilename, hookPropertyMap)</span><span class="s3">\n\n</span><span class="s1">// @ts-expect-error</span><span class="s3">\n</span><span class="s1">// This is a hack to make sure that if a user requires a Next.js module that wasn't bundled</span><span class="s3">\n</span><span class="s1">// that needs to point to the rendering runtime version, it will point to the correct one.</span><span class="s3">\n</span><span class="s1">// This can happen on `pages` when a user requires a dependency that uses next/image for example.</span><span class="s3">\n</span><span class="s1">mod.prototype.require = function (request: string) {</span><span class="s3">\n  </span><span class="s1">if (request.endsWith('.shared-runtime')) {</span><span class="s3">\n    </span><span class="s1">return originalRequire.call(</span><span class="s3">\n      </span><span class="s1">this,</span><span class="s3">\n      </span><span class="s1">`next/dist/server/route-modules/pages/vendored/contexts/${path.basename(</span><span class="s3">\n        </span><span class="s1">request,</span><span class="s3">\n        </span><span class="s1">'.shared-runtime'</span><span class="s3">\n      </span><span class="s1">)}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return originalRequire.call(this, request)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { HtmlProps } from './html-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { ComponentType, JSX } from 'react'</span><span class="s3">\n</span><span class="s1">import type { DomainLocale } from '../../server/config'</span><span class="s3">\n</span><span class="s1">import type { Env } from '@next/env'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { NextRouter } from './router/router'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../types'</span><span class="s3">\n</span><span class="s1">import type { COMPILER_NAMES } from './constants'</span><span class="s3">\n</span><span class="s1">import type fs from 'fs'</span><span class="s3">\n\n</span><span class="s1">export type NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">Context extends BaseContext = NextPageContext,</span><span class="s3">\n  </span><span class="s1">InitialProps = {},</span><span class="s3">\n  </span><span class="s1">Props = {},</span><span class="s3">\n</span><span class="s1">&gt; = ComponentType&lt;Props&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.</span><span class="s3">\n   </span><span class="s1">* Make sure to return plain `Object` without using `Date`, `Map`, `Set`.</span><span class="s3">\n   </span><span class="s1">* @param context Context of `page`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getInitialProps?(context: Context): InitialProps | Promise&lt;InitialProps&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentType = NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">DocumentContext,</span><span class="s3">\n  </span><span class="s1">DocumentInitialProps,</span><span class="s3">\n  </span><span class="s1">DocumentProps</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppType&lt;P = {}&gt; = NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">AppContextType,</span><span class="s3">\n  </span><span class="s1">P,</span><span class="s3">\n  </span><span class="s1">AppPropsType&lt;any, P&gt;</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppTreeType = ComponentType&lt;</span><span class="s3">\n  </span><span class="s1">AppInitialProps &amp; { [name: string]: any }</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.</span><span class="s3">\n </span><span class="s1">* https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const</span><span class="s3">\n</span><span class="s1">export type NextWebVitalsMetric = {</span><span class="s3">\n  </span><span class="s1">id: string</span><span class="s3">\n  </span><span class="s1">startTime: number</span><span class="s3">\n  </span><span class="s1">value: number</span><span class="s3">\n  </span><span class="s1">attribution?: { [key: string]: unknown }</span><span class="s3">\n</span><span class="s1">} &amp; (</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">label: 'web-vital'</span><span class="s3">\n      </span><span class="s1">name: (typeof WEB_VITALS)[number]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">label: 'custom'</span><span class="s3">\n      </span><span class="s1">name:</span><span class="s3">\n        </span><span class="s1">| 'Next.js-hydration'</span><span class="s3">\n        </span><span class="s1">| 'Next.js-route-change-to-render'</span><span class="s3">\n        </span><span class="s1">| 'Next.js-render'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export type Enhancer&lt;C&gt; = (Component: C) =&gt; C</span><span class="s3">\n\n</span><span class="s1">export type ComponentsEnhancer =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">enhanceApp?: Enhancer&lt;AppType&gt;</span><span class="s3">\n      </span><span class="s1">enhanceComponent?: Enhancer&lt;NextComponentType&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| Enhancer&lt;NextComponentType&gt;</span><span class="s3">\n\n</span><span class="s1">export type RenderPageResult = {</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">head?: Array&lt;JSX.Element | null&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderPage = (</span><span class="s3">\n  </span><span class="s1">options?: ComponentsEnhancer</span><span class="s3">\n</span><span class="s1">) =&gt; DocumentInitialProps | Promise&lt;DocumentInitialProps&gt;</span><span class="s3">\n\n</span><span class="s1">export type BaseContext = {</span><span class="s3">\n  </span><span class="s1">res?: ServerResponse</span><span class="s3">\n  </span><span class="s1">[k: string]: any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NEXT_DATA = {</span><span class="s3">\n  </span><span class="s1">props: Record&lt;string, any&gt;</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">runtimeConfig?: { [key: string]: any }</span><span class="s3">\n  </span><span class="s1">nextExport?: boolean</span><span class="s3">\n  </span><span class="s1">autoExport?: boolean</span><span class="s3">\n  </span><span class="s1">isFallback?: boolean</span><span class="s3">\n  </span><span class="s1">isExperimentalCompile?: boolean</span><span class="s3">\n  </span><span class="s1">dynamicIds?: (string | number)[]</span><span class="s3">\n  </span><span class="s1">err?: Error &amp; {</span><span class="s3">\n    </span><span class="s1">statusCode?: number</span><span class="s3">\n    </span><span class="s1">source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">gsp?: boolean</span><span class="s3">\n  </span><span class="s1">gssp?: boolean</span><span class="s3">\n  </span><span class="s1">customServer?: boolean</span><span class="s3">\n  </span><span class="s1">gip?: boolean</span><span class="s3">\n  </span><span class="s1">appGip?: boolean</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">domainLocales?: readonly DomainLocale[]</span><span class="s3">\n  </span><span class="s1">scriptLoader?: any[]</span><span class="s3">\n  </span><span class="s1">isPreview?: boolean</span><span class="s3">\n  </span><span class="s1">notFoundSrcPage?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* `Next` context</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NextPageContext {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Error object if encountered during rendering</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">err?: (Error &amp; { statusCode?: number }) | null</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `HTTP` request object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">req?: IncomingMessage</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `HTTP` response object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">res?: ServerResponse</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Path section of `URL`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Query string section of `URL` parsed as an object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `String` of the actual path including query.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">asPath?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The currently active locale</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* All configured locales</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The configured default locale</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `Component` the tree of the App to use if needing to render separately</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">AppTree: AppTreeType</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppContextType&lt;Router extends NextRouter = NextRouter&gt; = {</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType&lt;NextPageContext&gt;</span><span class="s3">\n  </span><span class="s1">AppTree: AppTreeType</span><span class="s3">\n  </span><span class="s1">ctx: NextPageContext</span><span class="s3">\n  </span><span class="s1">router: Router</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppInitialProps&lt;PageProps = any&gt; = {</span><span class="s3">\n  </span><span class="s1">pageProps: PageProps</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppPropsType&lt;</span><span class="s3">\n  </span><span class="s1">Router extends NextRouter = NextRouter,</span><span class="s3">\n  </span><span class="s1">PageProps = {},</span><span class="s3">\n</span><span class="s1">&gt; = AppInitialProps&lt;PageProps&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType&lt;NextPageContext, any, any&gt;</span><span class="s3">\n  </span><span class="s1">router: Router</span><span class="s3">\n  </span><span class="s1">__N_SSG?: boolean</span><span class="s3">\n  </span><span class="s1">__N_SSP?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentContext = NextPageContext &amp; {</span><span class="s3">\n  </span><span class="s1">renderPage: RenderPage</span><span class="s3">\n  </span><span class="s1">defaultGetInitialProps(</span><span class="s3">\n    </span><span class="s1">ctx: DocumentContext,</span><span class="s3">\n    </span><span class="s1">options?: { nonce?: string }</span><span class="s3">\n  </span><span class="s1">): Promise&lt;DocumentInitialProps&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentInitialProps = RenderPageResult &amp; {</span><span class="s3">\n  </span><span class="s1">styles?: React.ReactElement[] | Iterable&lt;React.ReactNode&gt; | JSX.Element</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentProps = DocumentInitialProps &amp; HtmlProps</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route request</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NextApiRequest extends IncomingMessage {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object of `query` values from url</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: Partial&lt;{</span><span class="s3">\n    </span><span class="s1">[key: string]: string | string[]</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object of `cookies` from header</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cookies: Partial&lt;{</span><span class="s3">\n    </span><span class="s1">[key: string]: string</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n\n  </span><span class="s1">body: any</span><span class="s3">\n\n  </span><span class="s1">env: Env</span><span class="s3">\n\n  </span><span class="s1">draftMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">preview?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Preview data set on the request, if any</span><span class="s3">\n   </span><span class="s1">* */</span><span class="s3">\n  </span><span class="s1">previewData?: PreviewData</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Send body of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type Send&lt;T&gt; = (body: T) =&gt; void</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NextApiResponse&lt;Data = any&gt; = ServerResponse &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Send data `any` data in response</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">send: Send&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Send data `json` data in response</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">json: Send&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">status: (statusCode: number) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">redirect(url: string): NextApiResponse&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">redirect(status: number, url: string): NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set draft mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setDraftMode: (options: { enable: boolean }) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set preview data for Next.js' prerender mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setPreviewData: (</span><span class="s3">\n    </span><span class="s1">data: object | string,</span><span class="s3">\n    </span><span class="s1">options?: {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Specifies the number (in seconds) for the preview session to last for.</span><span class="s3">\n       </span><span class="s1">* The given number will be converted to an integer by rounding down.</span><span class="s3">\n       </span><span class="s1">* By default, no maximum age is set and the preview session finishes</span><span class="s3">\n       </span><span class="s1">* when the client shuts down (browser is closed).</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">maxAge?: number</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Specifies the path for the preview session to work under. By default,</span><span class="s3">\n       </span><span class="s1">* the path is considered the </span><span class="s3">\&quot;</span><span class="s1">default path</span><span class="s3">\&quot;</span><span class="s1">, i.e., any pages under </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">path?: string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Clear preview data for Next.js' prerender mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clearPreviewData: (options?: { path?: string }) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Revalidate a specific page and regenerate it using On-Demand Incremental</span><span class="s3">\n   </span><span class="s1">* Static Regeneration.</span><span class="s3">\n   </span><span class="s1">* The path should be an actual path, not a rewritten path. E.g. for</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">/blog/[slug]</span><span class="s3">\&quot; </span><span class="s1">this should be </span><span class="s3">\&quot;</span><span class="s1">/blog/post-1</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n   </span><span class="s1">* @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">revalidate: (</span><span class="s3">\n    </span><span class="s1">urlPath: string,</span><span class="s3">\n    </span><span class="s1">opts?: {</span><span class="s3">\n      </span><span class="s1">unstable_onlyGenerated?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route handler</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NextApiHandler&lt;T = any&gt; = (</span><span class="s3">\n  </span><span class="s1">req: NextApiRequest,</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; unknown | Promise&lt;unknown&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utils</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function execOnce&lt;T extends (...args: any[]) =&gt; ReturnType&lt;T&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">fn: T</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">let used = false</span><span class="s3">\n  </span><span class="s1">let result: ReturnType&lt;T&gt;</span><span class="s3">\n\n  </span><span class="s1">return ((...args: any[]) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!used) {</span><span class="s3">\n      </span><span class="s1">used = true</span><span class="s3">\n      </span><span class="s1">result = fn(...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1</span><span class="s3">\n</span><span class="s1">// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3</span><span class="s3">\n</span><span class="s1">const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z</span><span class="s3">\\</span><span class="s1">d+</span><span class="s3">\\</span><span class="s1">-.]*?:/</span><span class="s3">\n</span><span class="s1">export const isAbsoluteUrl = (url: string) =&gt; ABSOLUTE_URL_REGEX.test(url)</span><span class="s3">\n\n</span><span class="s1">export function getLocationOrigin() {</span><span class="s3">\n  </span><span class="s1">const { protocol, hostname, port } = window.location</span><span class="s3">\n  </span><span class="s1">return `${protocol}//${hostname}${port ? ':' + port : ''}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getURL() {</span><span class="s3">\n  </span><span class="s1">const { href } = window.location</span><span class="s3">\n  </span><span class="s1">const origin = getLocationOrigin()</span><span class="s3">\n  </span><span class="s1">return href.substring(origin.length)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getDisplayName&lt;P&gt;(Component: ComponentType&lt;P&gt;) {</span><span class="s3">\n  </span><span class="s1">return typeof Component === 'string'</span><span class="s3">\n    </span><span class="s1">? Component</span><span class="s3">\n    </span><span class="s1">: Component.displayName || Component.name || 'Unknown'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isResSent(res: ServerResponse) {</span><span class="s3">\n  </span><span class="s1">return res.finished || res.headersSent</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeRepeatedSlashes(url: string) {</span><span class="s3">\n  </span><span class="s1">const urlParts = url.split('?')</span><span class="s3">\n  </span><span class="s1">const urlNoQuery = urlParts[0]</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">urlNoQuery</span><span class="s3">\n      </span><span class="s1">// first we replace any non-encoded backslashes with forward</span><span class="s3">\n      </span><span class="s1">// then normalize repeated forward slashes</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/+/g, '/') +</span><span class="s3">\n    </span><span class="s1">(urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function loadGetInitialProps&lt;</span><span class="s3">\n  </span><span class="s1">C extends BaseContext,</span><span class="s3">\n  </span><span class="s1">IP = {},</span><span class="s3">\n  </span><span class="s1">P = {},</span><span class="s3">\n</span><span class="s1">&gt;(App: NextComponentType&lt;C, IP, P&gt;, ctx: C): Promise&lt;IP&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">if (App.prototype?.getInitialProps) {</span><span class="s3">\n      </span><span class="s1">const message = `</span><span class="s3">\&quot;</span><span class="s1">${getDisplayName(</span><span class="s3">\n        </span><span class="s1">App</span><span class="s3">\n      </span><span class="s1">)}.getInitialProps()</span><span class="s3">\&quot; </span><span class="s1">is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`</span><span class="s3">\n      </span><span class="s1">throw new Error(message)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// when called from _app `ctx` is nested in `ctx`</span><span class="s3">\n  </span><span class="s1">const res = ctx.res || (ctx.ctx &amp;&amp; ctx.ctx.res)</span><span class="s3">\n\n  </span><span class="s1">if (!App.getInitialProps) {</span><span class="s3">\n    </span><span class="s1">if (ctx.ctx &amp;&amp; ctx.Component) {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore pageProps default</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {} as IP</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const props = await App.getInitialProps(ctx)</span><span class="s3">\n\n  </span><span class="s1">if (res &amp;&amp; isResSent(res)) {</span><span class="s3">\n    </span><span class="s1">return props</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!props) {</span><span class="s3">\n    </span><span class="s1">const message = `</span><span class="s3">\&quot;</span><span class="s1">${getDisplayName(</span><span class="s3">\n      </span><span class="s1">App</span><span class="s3">\n    </span><span class="s1">)}.getInitialProps()</span><span class="s3">\&quot; </span><span class="s1">should resolve to an object. But found </span><span class="s3">\&quot;</span><span class="s1">${props}</span><span class="s3">\&quot; </span><span class="s1">instead.`</span><span class="s3">\n    </span><span class="s1">throw new Error(message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">if (Object.keys(props).length === 0 &amp;&amp; !ctx.ctx) {</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">`${getDisplayName(</span><span class="s3">\n          </span><span class="s1">App</span><span class="s3">\n        </span><span class="s1">)} returned an empty object from </span><span class="s3">\\</span><span class="s1">`getInitialProps</span><span class="s3">\\</span><span class="s1">`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return props</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const SP = typeof performance !== 'undefined'</span><span class="s3">\n</span><span class="s1">export const ST =</span><span class="s3">\n  </span><span class="s1">SP &amp;&amp;</span><span class="s3">\n  </span><span class="s1">(['mark', 'measure', 'getEntriesByName'] as const).every(</span><span class="s3">\n    </span><span class="s1">(method) =&gt; typeof performance[method] === 'function'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export class DecodeError extends Error {}</span><span class="s3">\n</span><span class="s1">export class NormalizeError extends Error {}</span><span class="s3">\n</span><span class="s1">export class PageNotFoundError extends Error {</span><span class="s3">\n  </span><span class="s1">code: string</span><span class="s3">\n\n  </span><span class="s1">constructor(page: string) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.code = 'ENOENT'</span><span class="s3">\n    </span><span class="s1">this.name = 'PageNotFoundError'</span><span class="s3">\n    </span><span class="s1">this.message = `Cannot find module for page: ${page}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MissingStaticPage extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(page: string, message: string) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.message = `Failed to load static file for page: ${page} ${message}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MiddlewareNotFoundError extends Error {</span><span class="s3">\n  </span><span class="s1">code: string</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.code = 'ENOENT'</span><span class="s3">\n    </span><span class="s1">this.message = `Cannot find the middleware module`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CacheFs {</span><span class="s3">\n  </span><span class="s1">existsSync: typeof fs.existsSync</span><span class="s3">\n  </span><span class="s1">readFile: typeof fs.promises.readFile</span><span class="s3">\n  </span><span class="s1">readFileSync: typeof fs.readFileSync</span><span class="s3">\n  </span><span class="s1">writeFile(f: string, d: any): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">mkdir(dir: string): Promise&lt;void | string&gt;</span><span class="s3">\n  </span><span class="s1">stat(f: string): Promise&lt;{ mtime: Date }&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stringifyError(error: Error) {</span><span class="s3">\n  </span><span class="s1">return JSON.stringify({ message: error.message, stack: error.stack })</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Token } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Route pattern normalization utilities for path-to-regexp compatibility.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* path-to-regexp 6.3.0+ introduced stricter validation that rejects certain</span><span class="s3">\n </span><span class="s1">* patterns commonly used in Next.js interception routes. This module provides</span><span class="s3">\n </span><span class="s1">* normalization functions to make Next.js route patterns compatible with the</span><span class="s3">\n </span><span class="s1">* updated library while preserving all functionality.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Internal separator used to normalize adjacent parameter patterns.</span><span class="s3">\n </span><span class="s1">* This unique marker is inserted between adjacent parameters and stripped out</span><span class="s3">\n </span><span class="s1">* during parameter extraction to avoid conflicts with real URL content.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const PARAM_SEPARATOR = '_NEXTSEP_'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Detects if a route pattern needs normalization for path-to-regexp compatibility.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hasAdjacentParameterIssues(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">if (typeof route !== 'string') return false</span><span class="s3">\n\n  </span><span class="s1">// Check for interception route markers followed immediately by parameters</span><span class="s3">\n  </span><span class="s1">// Pattern: /(.):param, /(..):param, /(...):param, /(.)(.):param etc.</span><span class="s3">\n  </span><span class="s1">// These patterns cause </span><span class="s3">\&quot;</span><span class="s1">Must have text between two parameters</span><span class="s3">\&quot; </span><span class="s1">errors</span><span class="s3">\n  </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">.{1,3}</span><span class="s3">\\</span><span class="s1">):[^/</span><span class="s3">\\</span><span class="s1">s]+/.test(route)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check for basic adjacent parameters without separators</span><span class="s3">\n  </span><span class="s1">// Pattern: :param1:param2 (but not :param* or other URL patterns)</span><span class="s3">\n  </span><span class="s1">if (/:[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z_][a-zA-Z0-9_]*/.test(route)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes route patterns that have adjacent parameters without text between them.</span><span class="s3">\n </span><span class="s1">* Inserts a unique separator that can be safely stripped out later.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeAdjacentParameters(route: string): string {</span><span class="s3">\n  </span><span class="s1">let normalized = route</span><span class="s3">\n\n  </span><span class="s1">// Handle interception route patterns: (.):param -&gt; (.)_NEXTSEP_:param</span><span class="s3">\n  </span><span class="s1">normalized = normalized.replace(</span><span class="s3">\n    </span><span class="s1">/(</span><span class="s3">\\</span><span class="s1">([^)]*</span><span class="s3">\\</span><span class="s1">)):([^/</span><span class="s3">\\</span><span class="s1">s]+)/g,</span><span class="s3">\n    </span><span class="s1">`$1${PARAM_SEPARATOR}:$2`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Handle other adjacent parameter patterns: :param1:param2 -&gt; :param1_NEXTSEP_:param2</span><span class="s3">\n  </span><span class="s1">normalized = normalized.replace(/:([^:/</span><span class="s3">\\</span><span class="s1">s)]+)(?=:)/g, `:$1${PARAM_SEPARATOR}`)</span><span class="s3">\n\n  </span><span class="s1">return normalized</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes tokens that have repeating modifiers (* or +) but empty prefix and suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* path-to-regexp 6.3.0+ introduced validation that throws:</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">Can not repeat without prefix/suffix</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This occurs when a token has modifier: '*' or '+' with both prefix: '' and suffix: ''</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeTokensForRegexp(tokens: Token[]): Token[] {</span><span class="s3">\n  </span><span class="s1">return tokens.map((token) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Token union type: Token = string | TokenObject</span><span class="s3">\n    </span><span class="s1">// Literal path segments are strings, parameters/wildcards are objects</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">typeof token === 'object' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">token !== null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Not all token objects have 'modifier' property (e.g., simple text tokens)</span><span class="s3">\n      </span><span class="s1">'modifier' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Only repeating modifiers (* or +) cause the validation error</span><span class="s3">\n      </span><span class="s1">// Other modifiers like '?' (optional) are fine</span><span class="s3">\n      </span><span class="s1">(token.modifier === '*' || token.modifier === '+') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Token objects can have different shapes depending on route pattern</span><span class="s3">\n      </span><span class="s1">'prefix' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">'suffix' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Both prefix and suffix must be empty strings</span><span class="s3">\n      </span><span class="s1">// This is what causes the validation error in path-to-regexp</span><span class="s3">\n      </span><span class="s1">token.prefix === '' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">token.suffix === ''</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Add minimal prefix to satisfy path-to-regexp validation</span><span class="s3">\n      </span><span class="s1">// We use '/' as it's the most common path delimiter and won't break route matching</span><span class="s3">\n      </span><span class="s1">// The prefix gets used in regex generation but doesn't affect parameter extraction</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">...token,</span><span class="s3">\n        </span><span class="s1">prefix: '/',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return token</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips normalization separators from extracted route parameters.</span><span class="s3">\n </span><span class="s1">* Used by both server and client code to clean up parameters after route matching.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function stripParameterSeparators(</span><span class="s3">\n  </span><span class="s1">params: Record&lt;string, any&gt;</span><span class="s3">\n</span><span class="s1">): Record&lt;string, any&gt; {</span><span class="s3">\n  </span><span class="s1">const cleaned: Record&lt;string, any&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const [key, value] of Object.entries(params)) {</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">// Remove the separator if it appears at the start of parameter values</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">// Handle array parameters (from repeated route segments)</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value.map((item) =&gt;</span><span class="s3">\n        </span><span class="s1">typeof item === 'string'</span><span class="s3">\n          </span><span class="s1">? item.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')</span><span class="s3">\n          </span><span class="s1">: item</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return cleaned</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Client-safe utilities for route matching that don't import server-side</span><span class="s3">\n </span><span class="s1">* utilities to avoid bundling issues with Turbopack</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Key,</span><span class="s3">\n  </span><span class="s1">TokensToRegexpOptions,</span><span class="s3">\n  </span><span class="s1">ParseOptions,</span><span class="s3">\n  </span><span class="s1">TokensToFunctionOptions,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">pathToRegexp,</span><span class="s3">\n  </span><span class="s1">compile,</span><span class="s3">\n  </span><span class="s1">regexpToFunction,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">hasAdjacentParameterIssues,</span><span class="s3">\n  </span><span class="s1">normalizeAdjacentParameters,</span><span class="s3">\n  </span><span class="s1">stripParameterSeparators,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/route-pattern-normalizer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around pathToRegexp that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* This includes both </span><span class="s3">\&quot;</span><span class="s1">Can not repeat without prefix/suffix</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">Must have text between parameters</span><span class="s3">\&quot; </span><span class="s1">errors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safePathToRegexp(</span><span class="s3">\n  </span><span class="s1">route: string | RegExp | Array&lt;string | RegExp&gt;,</span><span class="s3">\n  </span><span class="s1">keys?: Key[],</span><span class="s3">\n  </span><span class="s1">options?: TokensToRegexpOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">): RegExp {</span><span class="s3">\n  </span><span class="s1">if (typeof route !== 'string') {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(route, keys, options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(routeToUse, keys, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return pathToRegexp(normalizedRoute, keys, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around compile that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* No server-side error reporting to avoid bundling issues.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeCompile(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">options?: TokensToFunctionOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return compile(routeToUse, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return compile(normalizedRoute, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around regexpToFunction that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRegexpToFunction&lt;</span><span class="s3">\n  </span><span class="s1">T extends Record&lt;string, any&gt; = Record&lt;string, any&gt;,</span><span class="s3">\n</span><span class="s1">&gt;(regexp: RegExp, keys?: Key[]): (pathname: string) =&gt; { params: T } | false {</span><span class="s3">\n  </span><span class="s1">const originalMatcher = regexpToFunction&lt;T&gt;(regexp, keys || [])</span><span class="s3">\n\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = originalMatcher(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">...result,</span><span class="s3">\n      </span><span class="s1">params: stripParameterSeparators(result.params as any) as T,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Safe wrapper for route matcher functions that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">* This is client-safe and doesn't import path-to-regexp.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRouteMatcher&lt;T extends Record&lt;string, any&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">matcherFn: (pathname: string) =&gt; false | T</span><span class="s3">\n</span><span class="s1">): (pathname: string) =&gt; false | T {</span><span class="s3">\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = matcherFn(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return stripParameterSeparators(result) as T</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Group } from './route-regex'</span><span class="s3">\n</span><span class="s1">import { DecodeError } from '../../utils'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { safeRouteMatcher } from './route-match-utils'</span><span class="s3">\n\n</span><span class="s1">export interface RouteMatchFn {</span><span class="s3">\n  </span><span class="s1">(pathname: string): false | Params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RouteMatcherOptions = {</span><span class="s3">\n  </span><span class="s1">// We only use the exec method of the RegExp object. This helps us avoid using</span><span class="s3">\n  </span><span class="s1">// type assertions that the passed in properties are of the correct type.</span><span class="s3">\n  </span><span class="s1">re: Pick&lt;RegExp, 'exec'&gt;</span><span class="s3">\n  </span><span class="s1">groups: Record&lt;string, Group&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRouteMatcher({</span><span class="s3">\n  </span><span class="s1">re,</span><span class="s3">\n  </span><span class="s1">groups,</span><span class="s3">\n</span><span class="s1">}: RouteMatcherOptions): RouteMatchFn {</span><span class="s3">\n  </span><span class="s1">const rawMatcher = (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const routeMatch = re.exec(pathname)</span><span class="s3">\n    </span><span class="s1">if (!routeMatch) return false</span><span class="s3">\n\n    </span><span class="s1">const decode = (param: string) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return decodeURIComponent(param)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">throw new DecodeError('failed to decode param')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const params: Params = {}</span><span class="s3">\n    </span><span class="s1">for (const [key, group] of Object.entries(groups)) {</span><span class="s3">\n      </span><span class="s1">const match = routeMatch[group.pos]</span><span class="s3">\n      </span><span class="s1">if (match !== undefined) {</span><span class="s3">\n        </span><span class="s1">if (group.repeat) {</span><span class="s3">\n          </span><span class="s1">params[key] = match.split('/').map((entry) =&gt; decode(entry))</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params[key] = decode(match)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Wrap with safe matcher to handle parameter cleaning</span><span class="s3">\n  </span><span class="s1">return safeRouteMatcher(rawMatcher)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* eslint-disable no-redeclare */</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { CloneableBody } from './body-streams'</span><span class="s3">\n</span><span class="s1">import type { RouteMatch } from './route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import type { ServerComponentsHmrCache } from './response-cache'</span><span class="s3">\n</span><span class="s1">import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'</span><span class="s3">\n\n</span><span class="s1">// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules</span><span class="s3">\n</span><span class="s1">export const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')</span><span class="s3">\n\n</span><span class="s1">export type NextIncomingMessage = (BaseNextRequest | IncomingMessage) &amp; {</span><span class="s3">\n  </span><span class="s1">[NEXT_REQUEST_META]?: RequestMeta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RequestMeta {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initQuery?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The URL that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The protocol that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initProtocol?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The body that was read from the request. This is used to allow the body to</span><span class="s3">\n   </span><span class="s1">* be read multiple times.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clonableBody?: CloneableBody</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request matched a locale domain that was configured in the</span><span class="s3">\n   </span><span class="s1">* next.config.js file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isLocaleDomain?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information stripped from the pathname</span><span class="s3">\n   </span><span class="s1">* part of the URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">didStripLocale?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If the request had it's URL rewritten, this is the URL it was rewritten to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rewroteURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cookies that were added by middleware and were added to the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareCookie?: string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The match on the request for a given route.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">match?: RouteMatch</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The incremental cache to use for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">incrementalCache?: any</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The server components HMR cache, only for dev.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache?: ServerComponentsHmrCache</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Equals the segment path that was used for the prefetch RSC request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">segmentPrefetchRSCRequest?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the prefetch flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isPrefetchRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A search param set by the Next.js client when performing RSC requests.</span><span class="s3">\n   </span><span class="s1">* Because some CDNs do not vary their cache entries on our custom headers,</span><span class="s3">\n   </span><span class="s1">* this search param represents a hash of the header values. For any cached</span><span class="s3">\n   </span><span class="s1">* RSC request, we should verify that the hash matches before responding.</span><span class="s3">\n   </span><span class="s1">* Otherwise this can lead to cache poisoning.</span><span class="s3">\n   </span><span class="s1">* TODO: Consider not using custom request headers at all, and instead encode</span><span class="s3">\n   </span><span class="s1">* everything into the search param.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cacheBustingSearchParam?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the `/_next/data` route using the pages</span><span class="s3">\n   </span><span class="s1">* router.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isNextDataReq?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Postponed state to use for resumption. If present it's assumed that the</span><span class="s3">\n   </span><span class="s1">* request is for a page that has postponed (there are no guarantees that the</span><span class="s3">\n   </span><span class="s1">* page actually has postponed though as it would incur an additional cache</span><span class="s3">\n   </span><span class="s1">* lookup).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If provided, this will be called when a response cache entry was generated</span><span class="s3">\n   </span><span class="s1">* or looked up in the cache.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">onCacheEntry?: (</span><span class="s3">\n    </span><span class="s1">cacheEntry: any,</span><span class="s3">\n    </span><span class="s1">requestMeta: any</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;boolean | void&gt; | boolean | void</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The previous revalidate before rendering 404 page for notFound: true</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">notFoundRevalidate?: number | false</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the original source page that returned a 404.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">developmentNotFoundSourcePage?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The path we routed to and should be invoked</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokePath?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The specific page output we should be matching</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeOutput?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The status we are invoking the request with from routing</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeStatus?: number</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The routing error we are invoking with</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeError?: Error</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query parsed for the invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeQuery?: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is a middleware invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareInvoke?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request should render the fallback shell or not.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderFallbackShell?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is for the custom error page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">customErrorRender?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to bubble up the NoFallbackError to the caller when a 404 is</span><span class="s3">\n   </span><span class="s1">* returned.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">bubbleNoFallback?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information inferred from the default</span><span class="s3">\n   </span><span class="s1">* locale.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">localeInferredFromDefault?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The default locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The relative project dir the server is running in from project root</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">relativeProjectDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The dist directory the server is currently using</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">distDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The params after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The AMP validator to use in development</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ampValidator?: (html: string, pathname: string) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* ErrorOverlay component to use in development for pages router</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PagesErrorDebug?: PagesDevOverlayBridgeType</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether server is in minimal mode (this will be replaced with more</span><span class="s3">\n   </span><span class="s1">* specific flags in future)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* DEV only: The fallback params that should be used when validating prerenders during dev</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">devValidatingFallbackParams?: Map&lt;string, string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the request metadata. If no key is provided, the entire metadata object</span><span class="s3">\n </span><span class="s1">* is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to get the metadata from</span><span class="s3">\n </span><span class="s1">* @param key the key to get from the metadata (optional)</span><span class="s3">\n </span><span class="s1">* @returns the value for the key or the entire metadata object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRequestMeta(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: undefined</span><span class="s3">\n</span><span class="s1">): RequestMeta</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">): RequestMeta[K]</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: K</span><span class="s3">\n</span><span class="s1">): RequestMeta | RequestMeta[K] {</span><span class="s3">\n  </span><span class="s1">const meta = req[NEXT_REQUEST_META] || {}</span><span class="s3">\n  </span><span class="s1">return typeof key === 'string' ? meta[key] : meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to set the metadata on</span><span class="s3">\n </span><span class="s1">* @param meta the metadata to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {</span><span class="s3">\n  </span><span class="s1">req[NEXT_REQUEST_META] = meta</span><span class="s3">\n  </span><span class="s1">return meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds a value to the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to set</span><span class="s3">\n </span><span class="s1">* @param value the value to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K,</span><span class="s3">\n  </span><span class="s1">value: RequestMeta[K]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">meta[key] = value</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes a key from the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to remove</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removeRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">delete meta[key]</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type NextQueryMetadata = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `_rsc` query parameter used for cache busting to ensure that the RSC</span><span class="s3">\n   </span><span class="s1">* requests do not get cached by the browser explicitly.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[NEXT_RSC_UNION_QUERY]?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NextParsedUrlQuery = ParsedUrlQuery &amp;</span><span class="s3">\n  </span><span class="s1">NextQueryMetadata &amp; {</span><span class="s3">\n    </span><span class="s1">amp?: '1'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface NextUrlWithParsedQuery extends UrlWithParsedQuery {</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import MODERN_BROWSERSLIST_TARGET from './modern-browserslist-target'</span><span class="s3">\n\n</span><span class="s1">export { MODERN_BROWSERSLIST_TARGET }</span><span class="s3">\n\n</span><span class="s1">export type ValueOf&lt;T&gt; = Required&lt;T&gt;[keyof T]</span><span class="s3">\n\n</span><span class="s1">export const COMPILER_NAMES = {</span><span class="s3">\n  </span><span class="s1">client: 'client',</span><span class="s3">\n  </span><span class="s1">server: 'server',</span><span class="s3">\n  </span><span class="s1">edgeServer: 'edge-server',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export type CompilerNameValues = ValueOf&lt;typeof COMPILER_NAMES&gt;</span><span class="s3">\n\n</span><span class="s1">export enum AdapterOutputType {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES` represents all the React pages that are under `pages/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES_API` represents all the API routes under `pages/api/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES_API = 'PAGES_API',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_PAGE` represents all the React pages that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `page.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `route.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PRERENDER` represents an ISR enabled route that might</span><span class="s3">\n   </span><span class="s1">* have a seeded cache entry or fallback generated during build</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PRERENDER = 'PRERENDER',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `STATIC_FILE` represents a static file (ie /_next/static)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">STATIC_FILE = 'STATIC_FILE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `MIDDLEWARE` represents the middleware output if present</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">MIDDLEWARE = 'MIDDLEWARE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const COMPILER_INDEXES: {</span><span class="s3">\n  </span><span class="s1">[compilerKey in CompilerNameValues]: number</span><span class="s3">\n</span><span class="s1">} = {</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.client]: 0,</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.server]: 1,</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.edgeServer]: 2,</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export const UNDERSCORE_NOT_FOUND_ROUTE = '/_not-found'</span><span class="s3">\n</span><span class="s1">export const UNDERSCORE_NOT_FOUND_ROUTE_ENTRY = `${UNDERSCORE_NOT_FOUND_ROUTE}/page`</span><span class="s3">\n</span><span class="s1">export const PHASE_EXPORT = 'phase-export'</span><span class="s3">\n</span><span class="s1">export const PHASE_PRODUCTION_BUILD = 'phase-production-build'</span><span class="s3">\n</span><span class="s1">export const PHASE_PRODUCTION_SERVER = 'phase-production-server'</span><span class="s3">\n</span><span class="s1">export const PHASE_DEVELOPMENT_SERVER = 'phase-development-server'</span><span class="s3">\n</span><span class="s1">export const PHASE_TEST = 'phase-test'</span><span class="s3">\n</span><span class="s1">export const PHASE_INFO = 'phase-info'</span><span class="s3">\n</span><span class="s1">export const PAGES_MANIFEST = 'pages-manifest.json'</span><span class="s3">\n</span><span class="s1">export const WEBPACK_STATS = 'webpack-stats.json'</span><span class="s3">\n</span><span class="s1">export const APP_PATHS_MANIFEST = 'app-paths-manifest.json'</span><span class="s3">\n</span><span class="s1">export const APP_PATH_ROUTES_MANIFEST = 'app-path-routes-manifest.json'</span><span class="s3">\n</span><span class="s1">export const BUILD_MANIFEST = 'build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const APP_BUILD_MANIFEST = 'app-build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const FUNCTIONS_CONFIG_MANIFEST = 'functions-config-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SUBRESOURCE_INTEGRITY_MANIFEST = 'subresource-integrity-manifest'</span><span class="s3">\n</span><span class="s1">export const NEXT_FONT_MANIFEST = 'next-font-manifest'</span><span class="s3">\n</span><span class="s1">export const EXPORT_MARKER = 'export-marker.json'</span><span class="s3">\n</span><span class="s1">export const EXPORT_DETAIL = 'export-detail.json'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_MANIFEST = 'prerender-manifest.json'</span><span class="s3">\n</span><span class="s1">export const ROUTES_MANIFEST = 'routes-manifest.json'</span><span class="s3">\n</span><span class="s1">export const IMAGES_MANIFEST = 'images-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SERVER_FILES_MANIFEST = 'required-server-files.json'</span><span class="s3">\n</span><span class="s1">export const DEV_CLIENT_PAGES_MANIFEST = '_devPagesManifest.json'</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_MANIFEST = 'middleware-manifest.json'</span><span class="s3">\n</span><span class="s1">export const TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'_clientMiddlewareManifest.json'</span><span class="s3">\n</span><span class="s1">export const TURBOPACK_CLIENT_BUILD_MANIFEST = 'client-build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const DEV_CLIENT_MIDDLEWARE_MANIFEST = '_devMiddlewareManifest.json'</span><span class="s3">\n</span><span class="s1">export const REACT_LOADABLE_MANIFEST = 'react-loadable-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SERVER_DIRECTORY = 'server'</span><span class="s3">\n</span><span class="s1">export const CONFIG_FILES = [</span><span class="s3">\n  </span><span class="s1">'next.config.js',</span><span class="s3">\n  </span><span class="s1">'next.config.mjs',</span><span class="s3">\n  </span><span class="s1">'next.config.ts',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">export const BUILD_ID_FILE = 'BUILD_ID'</span><span class="s3">\n</span><span class="s1">export const BLOCKED_PAGES = ['/_document', '/_app', '/_error']</span><span class="s3">\n</span><span class="s1">export const CLIENT_PUBLIC_FILES_PATH = 'public'</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_PATH = 'static'</span><span class="s3">\n</span><span class="s1">export const STRING_LITERAL_DROP_BUNDLE = '__NEXT_DROP_CLIENT_FILE__'</span><span class="s3">\n</span><span class="s1">export const NEXT_BUILTIN_DOCUMENT = '__NEXT_BUILTIN_DOCUMENT__'</span><span class="s3">\n</span><span class="s1">export const BARREL_OPTIMIZATION_PREFIX = '__barrel_optimize__'</span><span class="s3">\n\n</span><span class="s1">// server/[entry]/page_client-reference-manifest.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_REFERENCE_MANIFEST = 'client-reference-manifest'</span><span class="s3">\n</span><span class="s1">// server/server-reference-manifest</span><span class="s3">\n</span><span class="s1">export const SERVER_REFERENCE_MANIFEST = 'server-reference-manifest'</span><span class="s3">\n</span><span class="s1">// server/middleware-build-manifest.js</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_BUILD_MANIFEST = 'middleware-build-manifest'</span><span class="s3">\n</span><span class="s1">// server/middleware-react-loadable-manifest.js</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_REACT_LOADABLE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'middleware-react-loadable-manifest'</span><span class="s3">\n</span><span class="s1">// server/interception-route-rewrite-manifest.js</span><span class="s3">\n</span><span class="s1">export const INTERCEPTION_ROUTE_REWRITE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'interception-route-rewrite-manifest'</span><span class="s3">\n</span><span class="s1">// server/dynamic-css-manifest.js</span><span class="s3">\n</span><span class="s1">export const DYNAMIC_CSS_MANIFEST = 'dynamic-css-manifest'</span><span class="s3">\n\n</span><span class="s1">// static/runtime/main.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_MAIN = `main`</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_MAIN_APP = `${CLIENT_STATIC_FILES_RUNTIME_MAIN}-app`</span><span class="s3">\n</span><span class="s1">// next internal client components chunk for layouts</span><span class="s3">\n</span><span class="s1">export const APP_CLIENT_INTERNALS = 'app-pages-internals'</span><span class="s3">\n</span><span class="s1">// static/runtime/react-refresh.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH = `react-refresh`</span><span class="s3">\n</span><span class="s1">// static/runtime/amp.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_AMP = `amp`</span><span class="s3">\n</span><span class="s1">// static/runtime/webpack.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_WEBPACK = `webpack`</span><span class="s3">\n</span><span class="s1">// static/runtime/polyfills.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_POLYFILLS = 'polyfills'</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL = Symbol(</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_POLYFILLS</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const DEFAULT_RUNTIME_WEBPACK = 'webpack-runtime'</span><span class="s3">\n</span><span class="s1">export const EDGE_RUNTIME_WEBPACK = 'edge-runtime-webpack'</span><span class="s3">\n</span><span class="s1">export const STATIC_PROPS_ID = '__N_SSG'</span><span class="s3">\n</span><span class="s1">export const SERVER_PROPS_ID = '__N_SSP'</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SERIF_FONT = {</span><span class="s3">\n  </span><span class="s1">name: 'Times New Roman',</span><span class="s3">\n  </span><span class="s1">xAvgCharWidth: 821,</span><span class="s3">\n  </span><span class="s1">azAvgWidth: 854.3953488372093,</span><span class="s3">\n  </span><span class="s1">unitsPerEm: 2048,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SANS_SERIF_FONT = {</span><span class="s3">\n  </span><span class="s1">name: 'Arial',</span><span class="s3">\n  </span><span class="s1">xAvgCharWidth: 904,</span><span class="s3">\n  </span><span class="s1">azAvgWidth: 934.5116279069767,</span><span class="s3">\n  </span><span class="s1">unitsPerEm: 2048,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const STATIC_STATUS_PAGES = ['/500']</span><span class="s3">\n</span><span class="s1">export const TRACE_OUTPUT_VERSION = 1</span><span class="s3">\n</span><span class="s1">// in `MB`</span><span class="s3">\n</span><span class="s1">export const TURBO_TRACE_DEFAULT_MEMORY_LIMIT = 6000</span><span class="s3">\n\n</span><span class="s1">export const RSC_MODULE_TYPES = {</span><span class="s3">\n  </span><span class="s1">client: 'client',</span><span class="s3">\n  </span><span class="s1">server: 'server',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">// comparing</span><span class="s3">\n</span><span class="s1">// https://nextjs.org/docs/api-reference/edge-runtime</span><span class="s3">\n</span><span class="s1">// with</span><span class="s3">\n</span><span class="s1">// https://nodejs.org/docs/latest/api/globals.html</span><span class="s3">\n</span><span class="s1">export const EDGE_UNSUPPORTED_NODE_APIS = [</span><span class="s3">\n  </span><span class="s1">'clearImmediate',</span><span class="s3">\n  </span><span class="s1">'setImmediate',</span><span class="s3">\n  </span><span class="s1">'BroadcastChannel',</span><span class="s3">\n  </span><span class="s1">'ByteLengthQueuingStrategy',</span><span class="s3">\n  </span><span class="s1">'CompressionStream',</span><span class="s3">\n  </span><span class="s1">'CountQueuingStrategy',</span><span class="s3">\n  </span><span class="s1">'DecompressionStream',</span><span class="s3">\n  </span><span class="s1">'DomException',</span><span class="s3">\n  </span><span class="s1">'MessageChannel',</span><span class="s3">\n  </span><span class="s1">'MessageEvent',</span><span class="s3">\n  </span><span class="s1">'MessagePort',</span><span class="s3">\n  </span><span class="s1">'ReadableByteStreamController',</span><span class="s3">\n  </span><span class="s1">'ReadableStreamBYOBRequest',</span><span class="s3">\n  </span><span class="s1">'ReadableStreamDefaultController',</span><span class="s3">\n  </span><span class="s1">'TransformStreamDefaultController',</span><span class="s3">\n  </span><span class="s1">'WritableStreamDefaultController',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export const SYSTEM_ENTRYPOINTS = new Set&lt;string&gt;([</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_MAIN,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_AMP,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_MAIN_APP,</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import fs from 'fs'</span><span class="s3">\n</span><span class="s1">import path from 'path'</span><span class="s3">\n\n</span><span class="s1">export function findDir(dir: string, name: 'pages' | 'app'): string | null {</span><span class="s3">\n  </span><span class="s1">// prioritize ./${name} over ./src/${name}</span><span class="s3">\n  </span><span class="s1">let curDir = path.join(dir, name)</span><span class="s3">\n  </span><span class="s1">if (fs.existsSync(curDir)) return curDir</span><span class="s3">\n\n  </span><span class="s1">curDir = path.join(dir, 'src', name)</span><span class="s3">\n  </span><span class="s1">if (fs.existsSync(curDir)) return curDir</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function findPagesDir(dir: string): {</span><span class="s3">\n  </span><span class="s1">pagesDir: string | undefined</span><span class="s3">\n  </span><span class="s1">appDir: string | undefined</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const pagesDir = findDir(dir, 'pages') || undefined</span><span class="s3">\n  </span><span class="s1">const appDir = findDir(dir, 'app') || undefined</span><span class="s3">\n\n  </span><span class="s1">if (appDir == null &amp;&amp; pagesDir == null) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">&gt; Couldn't find any `pages` or `app` directory. Please create one under the project root</span><span class="s3">\&quot;\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">pagesDir,</span><span class="s3">\n    </span><span class="s1">appDir,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class ReflectAdapter {</span><span class="s3">\n  </span><span class="s1">static get&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">receiver: unknown</span><span class="s3">\n  </span><span class="s1">): any {</span><span class="s3">\n    </span><span class="s1">const value = Reflect.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'function') {</span><span class="s3">\n      </span><span class="s1">return value.bind(target)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static set&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">value: any,</span><span class="s3">\n    </span><span class="s1">receiver: any</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.set(target, prop, value, receiver)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static has&lt;T extends object&gt;(target: T, prop: string | symbol): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.has(target, prop)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static deleteProperty&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.deleteProperty(target, prop)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingHttpHeaders } from 'http'</span><span class="s3">\n\n</span><span class="s1">import { ReflectAdapter } from './reflect'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ReadonlyHeadersError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static callable() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyHeadersError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReadonlyHeaders = Headers &amp; {</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">append(...args: any[]): void</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">set(...args: any[]): void</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">delete(...args: any[]): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class HeadersAdapter extends Headers {</span><span class="s3">\n  </span><span class="s1">private readonly headers: IncomingHttpHeaders</span><span class="s3">\n\n  </span><span class="s1">constructor(headers: IncomingHttpHeaders) {</span><span class="s3">\n    </span><span class="s1">// We've already overridden the methods that would be called, so we're just</span><span class="s3">\n    </span><span class="s1">// calling the super constructor to ensure that the instanceof check works.</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n\n    </span><span class="s1">this.headers = new Proxy(headers, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">// Because this is just an object, we expect that all </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">operations</span><span class="s3">\n        </span><span class="s1">// are for properties. If it's a </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">for a symbol, we'll just return</span><span class="s3">\n        </span><span class="s1">// the symbol.</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') {</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return undefined.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, return the value.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, original, receiver)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">set(target, prop, value, receiver) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') {</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.set(target, prop, value, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, use the prop as the key.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.set(target, original ?? prop, value, receiver)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">has(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return false.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return false</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, return true.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.has(target, original)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">deleteProperty(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol')</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.deleteProperty(target, prop)</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return true.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return true</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, delete the property.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.deleteProperty(target, original)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Seals a Headers instance to prevent modification by throwing an error when</span><span class="s3">\n   </span><span class="s1">* any mutating method is called.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static seal(headers: Headers): ReadonlyHeaders {</span><span class="s3">\n    </span><span class="s1">return new Proxy&lt;ReadonlyHeaders&gt;(headers, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">switch (prop) {</span><span class="s3">\n          </span><span class="s1">case 'append':</span><span class="s3">\n          </span><span class="s1">case 'delete':</span><span class="s3">\n          </span><span class="s1">case 'set':</span><span class="s3">\n            </span><span class="s1">return ReadonlyHeadersError.callable</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Merges a header value into a string. This stores multiple values as an</span><span class="s3">\n   </span><span class="s1">* array, so we need to merge them into a string.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param value a header value</span><span class="s3">\n   </span><span class="s1">* @returns a merged header value (a string)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private merge(value: string | string[]): string {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) return value.join(', ')</span><span class="s3">\n\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a Headers instance from a plain object or a Headers instance.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param headers a plain object or a Headers instance</span><span class="s3">\n   </span><span class="s1">* @returns a headers instance</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static from(headers: IncomingHttpHeaders | Headers): Headers {</span><span class="s3">\n    </span><span class="s1">if (headers instanceof Headers) return headers</span><span class="s3">\n\n    </span><span class="s1">return new HeadersAdapter(headers)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public append(name: string, value: string): void {</span><span class="s3">\n    </span><span class="s1">const existing = this.headers[name]</span><span class="s3">\n    </span><span class="s1">if (typeof existing === 'string') {</span><span class="s3">\n      </span><span class="s1">this.headers[name] = [existing, value]</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(existing)) {</span><span class="s3">\n      </span><span class="s1">existing.push(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.headers[name] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public delete(name: string): void {</span><span class="s3">\n    </span><span class="s1">delete this.headers[name]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get(name: string): string | null {</span><span class="s3">\n    </span><span class="s1">const value = this.headers[name]</span><span class="s3">\n    </span><span class="s1">if (typeof value !== 'undefined') return this.merge(value)</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public has(name: string): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.headers[name] !== 'undefined'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set(name: string, value: string): void {</span><span class="s3">\n    </span><span class="s1">this.headers[name] = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public forEach(</span><span class="s3">\n    </span><span class="s1">callbackfn: (value: string, name: string, parent: Headers) =&gt; void,</span><span class="s3">\n    </span><span class="s1">thisArg?: any</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">for (const [name, value] of this.entries()) {</span><span class="s3">\n      </span><span class="s1">callbackfn.call(thisArg, value, name, this)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *entries(): HeadersIterator&lt;[string, string]&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">const name = key.toLowerCase()</span><span class="s3">\n      </span><span class="s1">// We assert here that this is a string because we got it from the</span><span class="s3">\n      </span><span class="s1">// Object.keys() call above.</span><span class="s3">\n      </span><span class="s1">const value = this.get(name) as string</span><span class="s3">\n\n      </span><span class="s1">yield [name, value] as [string, string]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *keys(): HeadersIterator&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">const name = key.toLowerCase()</span><span class="s3">\n      </span><span class="s1">yield name</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *values(): HeadersIterator&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">// We assert here that this is a string because we got it from the</span><span class="s3">\n      </span><span class="s1">// Object.keys() call above.</span><span class="s3">\n      </span><span class="s1">const value = this.get(key) as string</span><span class="s3">\n\n      </span><span class="s1">yield value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public [Symbol.iterator](): HeadersIterator&lt;[string, string]&gt; {</span><span class="s3">\n    </span><span class="s1">return this.entries()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ServerRuntime } from '../types'</span><span class="s3">\n\n</span><span class="s1">export const TEXT_PLAIN_CONTENT_TYPE_HEADER = 'text/plain'</span><span class="s3">\n</span><span class="s1">export const HTML_CONTENT_TYPE_HEADER = 'text/html; charset=utf-8'</span><span class="s3">\n</span><span class="s1">export const JSON_CONTENT_TYPE_HEADER = 'application/json; charset=utf-8'</span><span class="s3">\n</span><span class="s1">export const NEXT_QUERY_PARAM_PREFIX = 'nxtP'</span><span class="s3">\n</span><span class="s1">export const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI'</span><span class="s3">\n\n</span><span class="s1">export const MATCHED_PATH_HEADER = 'x-matched-path'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER =</span><span class="s3">\n  </span><span class="s1">'x-prerender-revalidate-if-generated'</span><span class="s3">\n\n</span><span class="s1">export const RSC_PREFETCH_SUFFIX = '.prefetch.rsc'</span><span class="s3">\n</span><span class="s1">export const RSC_SEGMENTS_DIR_SUFFIX = '.segments'</span><span class="s3">\n</span><span class="s1">export const RSC_SEGMENT_SUFFIX = '.segment.rsc'</span><span class="s3">\n</span><span class="s1">export const RSC_SUFFIX = '.rsc'</span><span class="s3">\n</span><span class="s1">export const ACTION_SUFFIX = '.action'</span><span class="s3">\n</span><span class="s1">export const NEXT_DATA_SUFFIX = '.json'</span><span class="s3">\n</span><span class="s1">export const NEXT_META_SUFFIX = '.meta'</span><span class="s3">\n</span><span class="s1">export const NEXT_BODY_SUFFIX = '.body'</span><span class="s3">\n\n</span><span class="s1">export const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags'</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags'</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER =</span><span class="s3">\n  </span><span class="s1">'x-next-revalidate-tag-token'</span><span class="s3">\n\n</span><span class="s1">export const NEXT_RESUME_HEADER = 'next-resume'</span><span class="s3">\n\n</span><span class="s1">// if these change make sure we update the related</span><span class="s3">\n</span><span class="s1">// documentation as well</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_TAG_MAX_ITEMS = 128</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_TAG_MAX_LENGTH = 256</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_'</span><span class="s3">\n\n</span><span class="s1">// in seconds</span><span class="s3">\n</span><span class="s1">export const CACHE_ONE_YEAR = 31536000</span><span class="s3">\n\n</span><span class="s1">// in seconds, represents revalidate=false. I.e. never revaliate.</span><span class="s3">\n</span><span class="s1">// We use this value since it can be represented as a V8 SMI for optimal performance.</span><span class="s3">\n</span><span class="s1">// It can also be serialized as JSON if it ever leaks accidentally as an actual value.</span><span class="s3">\n</span><span class="s1">export const INFINITE_CACHE = 0xfffffffe</span><span class="s3">\n\n</span><span class="s1">// Patterns to detect middleware files</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_FILENAME = 'middleware'</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`</span><span class="s3">\n\n</span><span class="s1">// Pattern to detect instrumentation hooks file</span><span class="s3">\n</span><span class="s1">export const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation'</span><span class="s3">\n\n</span><span class="s1">// Because on Windows absolute paths in the generated code can break because of numbers, eg 1 in the path,</span><span class="s3">\n</span><span class="s1">// we have to use a private alias</span><span class="s3">\n</span><span class="s1">export const PAGES_DIR_ALIAS = 'private-next-pages'</span><span class="s3">\n</span><span class="s1">export const DOT_NEXT_ALIAS = 'private-dot-next'</span><span class="s3">\n</span><span class="s1">export const ROOT_DIR_ALIAS = 'private-next-root-dir'</span><span class="s3">\n</span><span class="s1">export const APP_DIR_ALIAS = 'private-next-app-dir'</span><span class="s3">\n</span><span class="s1">export const RSC_MOD_REF_PROXY_ALIAS = 'private-next-rsc-mod-ref-proxy'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference'</span><span class="s3">\n</span><span class="s1">export const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper'</span><span class="s3">\n</span><span class="s1">export const RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS =</span><span class="s3">\n  </span><span class="s1">'private-next-rsc-track-dynamic-import'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_CLIENT_WRAPPER_ALIAS =</span><span class="s3">\n  </span><span class="s1">'private-next-rsc-action-client-wrapper'</span><span class="s3">\n\n</span><span class="s1">export const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`</span><span class="s3">\n\n</span><span class="s1">export const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`</span><span class="s3">\n\n</span><span class="s1">export const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_EXPORT_ERROR = `pages with </span><span class="s3">\\</span><span class="s1">`getServerSideProps</span><span class="s3">\\</span><span class="s1">` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`</span><span class="s3">\n\n</span><span class="s1">export const GSP_NO_RETURNED_VALUE =</span><span class="s3">\n  </span><span class="s1">'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?'</span><span class="s3">\n</span><span class="s1">export const GSSP_NO_RETURNED_VALUE =</span><span class="s3">\n  </span><span class="s1">'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?'</span><span class="s3">\n\n</span><span class="s1">export const UNSTABLE_REVALIDATE_RENAME_ERROR =</span><span class="s3">\n  </span><span class="s1">'The `unstable_revalidate` property is available for general use.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n  </span><span class="s1">'Please use `revalidate` instead.'</span><span class="s3">\n\n</span><span class="s1">export const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`</span><span class="s3">\n\n</span><span class="s1">export const NON_STANDARD_NODE_ENV = `You are using a non-standard </span><span class="s3">\&quot;</span><span class="s1">NODE_ENV</span><span class="s3">\&quot; </span><span class="s1">value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`</span><span class="s3">\n\n</span><span class="s1">export const SSG_FALLBACK_EXPORT_ERROR = `Pages with </span><span class="s3">\\</span><span class="s1">`fallback</span><span class="s3">\\</span><span class="s1">` enabled in </span><span class="s3">\\</span><span class="s1">`getStaticPaths</span><span class="s3">\\</span><span class="s1">` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`</span><span class="s3">\n\n</span><span class="s1">export const ESLINT_DEFAULT_DIRS = ['app', 'pages', 'components', 'lib', 'src']</span><span class="s3">\n\n</span><span class="s1">export const SERVER_RUNTIME: Record&lt;string, ServerRuntime&gt; = {</span><span class="s3">\n  </span><span class="s1">edge: 'edge',</span><span class="s3">\n  </span><span class="s1">experimentalEdge: 'experimental-edge',</span><span class="s3">\n  </span><span class="s1">nodejs: 'nodejs',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The names of the webpack layers. These layers are the primitives for the</span><span class="s3">\n </span><span class="s1">* webpack chunks.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const WEBPACK_LAYERS_NAMES = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the shared code between the client and server bundles.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">shared: 'shared',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for server-only runtime and picking up `react-server` export conditions.</span><span class="s3">\n   </span><span class="s1">* Including app router RSC pages and app router custom routes and metadata routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">reactServerComponents: 'rsc',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Server Side Rendering layer for app (ssr).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">serverSideRendering: 'ssr',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for actions.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">actionBrowser: 'action-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Node.js bundle layer for the API routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apiNode: 'api-node',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Edge Lite bundle layer for the API routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apiEdge: 'api-edge',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the middleware code.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middleware: 'middleware',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the instrumentation hooks.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">instrument: 'instrument',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for assets on the edge.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">edgeAsset: 'edge-asset',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for App directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">appPagesBrowser: 'app-pages-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirBrowser: 'pages-dir-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Edge Lite bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirEdge: 'pages-dir-edge',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Node.js bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirNode: 'pages-dir-node',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export type WebpackLayerName =</span><span class="s3">\n  </span><span class="s1">(typeof WEBPACK_LAYERS_NAMES)[keyof typeof WEBPACK_LAYERS_NAMES]</span><span class="s3">\n\n</span><span class="s1">const WEBPACK_LAYERS = {</span><span class="s3">\n  </span><span class="s1">...WEBPACK_LAYERS_NAMES,</span><span class="s3">\n  </span><span class="s1">GROUP: {</span><span class="s3">\n    </span><span class="s1">builtinReact: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">serverOnly: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.instrument,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.middleware,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">neutralTarget: [</span><span class="s3">\n      </span><span class="s1">// pages api</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.apiNode,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.apiEdge,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">clientOnly: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">bundled: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.shared,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.instrument,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.middleware,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">appPages: [</span><span class="s3">\n      </span><span class="s1">// app router pages and layouts</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const WEBPACK_RESOURCE_QUERIES = {</span><span class="s3">\n  </span><span class="s1">edgeSSREntry: '__next_edge_ssr_entry__',</span><span class="s3">\n  </span><span class="s1">metadata: '__next_metadata__',</span><span class="s3">\n  </span><span class="s1">metadataRoute: '__next_metadata_route__',</span><span class="s3">\n  </span><span class="s1">metadataImageMeta: '__next_metadata_image_meta__',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { WEBPACK_LAYERS, WEBPACK_RESOURCE_QUERIES }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { CookieSerializeOptions } from 'next/dist/compiled/cookie'</span><span class="s3">\n</span><span class="s1">import type { NextApiResponse } from '../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">import { HeadersAdapter } from '../web/spec-extension/adapters/headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_HEADER,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NodeSpan } from '../lib/trace/constants'</span><span class="s3">\n\n</span><span class="s1">export type NextApiRequestCookies = Partial&lt;{ [key: string]: string }&gt;</span><span class="s3">\n</span><span class="s1">export type NextApiRequestQuery = Partial&lt;{ [key: string]: string | string[] }&gt;</span><span class="s3">\n\n</span><span class="s1">export type __ApiPreviewProps = {</span><span class="s3">\n  </span><span class="s1">previewModeId: string</span><span class="s3">\n  </span><span class="s1">previewModeEncryptionKey: string</span><span class="s3">\n  </span><span class="s1">previewModeSigningKey: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function wrapApiHandler&lt;T extends (...args: any[]) =&gt; any&gt;(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">handler: T</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">return ((...args) =&gt; {</span><span class="s3">\n    </span><span class="s1">getTracer().setRootSpanAttribute('next.route', page)</span><span class="s3">\n    </span><span class="s1">// Call API route method</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">NodeSpan.runHandler,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">spanName: `executing api route (pages) ${page}`,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">() =&gt; handler(...args)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param statusCode `HTTP` status code of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sendStatusCode(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusCode: number</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">res.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param [statusOrUrl] `HTTP` status code of redirect</span><span class="s3">\n </span><span class="s1">* @param url URL of redirect</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function redirect(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusOrUrl: string | number,</span><span class="s3">\n  </span><span class="s1">url?: string</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof statusOrUrl === 'string') {</span><span class="s3">\n    </span><span class="s1">url = statusOrUrl</span><span class="s3">\n    </span><span class="s1">statusOrUrl = 307</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">res.writeHead(statusOrUrl, { Location: url })</span><span class="s3">\n  </span><span class="s1">res.write(url)</span><span class="s3">\n  </span><span class="s1">res.end()</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function checkIsOnDemandRevalidate(</span><span class="s3">\n  </span><span class="s1">req: Request | IncomingMessage | BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">isOnDemandRevalidate: boolean</span><span class="s3">\n  </span><span class="s1">revalidateOnlyGenerated: boolean</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const headers = HeadersAdapter.from(req.headers)</span><span class="s3">\n\n  </span><span class="s1">const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)</span><span class="s3">\n  </span><span class="s1">const isOnDemandRevalidate = previewModeId === previewProps.previewModeId</span><span class="s3">\n\n  </span><span class="s1">const revalidateOnlyGenerated = headers.has(</span><span class="s3">\n    </span><span class="s1">PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return { isOnDemandRevalidate, revalidateOnlyGenerated }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`</span><span class="s3">\n</span><span class="s1">export const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`</span><span class="s3">\n\n</span><span class="s1">export const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024</span><span class="s3">\n\n</span><span class="s1">export const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)</span><span class="s3">\n</span><span class="s1">export const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)</span><span class="s3">\n\n</span><span class="s1">export function clearPreviewData&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">path?: string</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (SYMBOL_CLEARED_COOKIES in res) {</span><span class="s3">\n    </span><span class="s1">return res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { serialize } =</span><span class="s3">\n    </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n  </span><span class="s1">const previous = res.getHeader('Set-Cookie')</span><span class="s3">\n  </span><span class="s1">res.setHeader(`Set-Cookie`, [</span><span class="s3">\n    </span><span class="s1">...(typeof previous === 'string'</span><span class="s3">\n      </span><span class="s1">? [previous]</span><span class="s3">\n      </span><span class="s1">: Array.isArray(previous)</span><span class="s3">\n        </span><span class="s1">? previous</span><span class="s3">\n        </span><span class="s1">: []),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {</span><span class="s3">\n      </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n      </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n      </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n      </span><span class="s1">expires: new Date(0),</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_DATA, '', {</span><span class="s3">\n      </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n      </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n      </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n      </span><span class="s1">expires: new Date(0),</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {</span><span class="s3">\n    </span><span class="s1">value: true,</span><span class="s3">\n    </span><span class="s1">enumerable: false,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Custom error class</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ApiError extends Error {</span><span class="s3">\n  </span><span class="s1">readonly statusCode: number</span><span class="s3">\n\n  </span><span class="s1">constructor(statusCode: number, message: string) {</span><span class="s3">\n    </span><span class="s1">super(message)</span><span class="s3">\n    </span><span class="s1">this.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sends error in `response`</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param statusCode of response</span><span class="s3">\n </span><span class="s1">* @param message of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sendError(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusCode: number,</span><span class="s3">\n  </span><span class="s1">message: string</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">res.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">res.statusMessage = message</span><span class="s3">\n  </span><span class="s1">res.end(message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface LazyProps {</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Execute getter function only if its needed</span><span class="s3">\n </span><span class="s1">* @param LazyProps `req` and `params` for lazyProp</span><span class="s3">\n </span><span class="s1">* @param prop name of property</span><span class="s3">\n </span><span class="s1">* @param getter function to get data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setLazyProp&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">{ req }: LazyProps,</span><span class="s3">\n  </span><span class="s1">prop: string,</span><span class="s3">\n  </span><span class="s1">getter: () =&gt; T</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const opts = { configurable: true, enumerable: true }</span><span class="s3">\n  </span><span class="s1">const optsReset = { ...opts, writable: true }</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(req, prop, {</span><span class="s3">\n    </span><span class="s1">...opts,</span><span class="s3">\n    </span><span class="s1">get: () =&gt; {</span><span class="s3">\n      </span><span class="s1">const value = getter()</span><span class="s3">\n      </span><span class="s1">// we set the property on the object to avoid recalculating it</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(req, prop, { ...optsReset, value })</span><span class="s3">\n      </span><span class="s1">return value</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set: (value) =&gt; {</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(req, prop, { ...optsReset, value })</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export enum RedirectStatusCode {</span><span class="s3">\n  </span><span class="s1">SeeOther = 303,</span><span class="s3">\n  </span><span class="s1">TemporaryRedirect = 307,</span><span class="s3">\n  </span><span class="s1">PermanentRedirect = 308,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextApiRequestCookies } from '.'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse cookies from the `headers` of request</span><span class="s3">\n </span><span class="s1">* @param req request object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function getCookieParser(headers: {</span><span class="s3">\n  </span><span class="s1">[key: string]: string | string[] | null | undefined</span><span class="s3">\n</span><span class="s1">}): () =&gt; NextApiRequestCookies {</span><span class="s3">\n  </span><span class="s1">return function parseCookie(): NextApiRequestCookies {</span><span class="s3">\n    </span><span class="s1">const { cookie } = headers</span><span class="s3">\n\n    </span><span class="s1">if (!cookie) {</span><span class="s3">\n      </span><span class="s1">return {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { parse: parseCookieFn } =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n    </span><span class="s1">return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type { I18NConfig } from '../config-shared'</span><span class="s3">\n\n</span><span class="s1">import { RedirectStatusCode } from '../../client/components/redirect-status-code'</span><span class="s3">\n</span><span class="s1">import type { NextApiRequestCookies } from '../api-utils'</span><span class="s3">\n</span><span class="s1">import { getCookieParser } from '../api-utils/get-cookie-parser'</span><span class="s3">\n\n</span><span class="s1">export interface BaseNextRequestConfig {</span><span class="s3">\n  </span><span class="s1">basePath: string | undefined</span><span class="s3">\n  </span><span class="s1">i18n?: I18NConfig</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FetchMetric = {</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">idx: number</span><span class="s3">\n  </span><span class="s1">end: number</span><span class="s3">\n  </span><span class="s1">start: number</span><span class="s3">\n  </span><span class="s1">method: string</span><span class="s3">\n  </span><span class="s1">status: number</span><span class="s3">\n  </span><span class="s1">cacheReason: string</span><span class="s3">\n  </span><span class="s1">cacheStatus: 'hit' | 'miss' | 'skip' | 'hmr'</span><span class="s3">\n  </span><span class="s1">cacheWarning?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FetchMetrics = Array&lt;FetchMetric&gt;</span><span class="s3">\n\n</span><span class="s1">export abstract class BaseNextRequest&lt;Body = any&gt; {</span><span class="s3">\n  </span><span class="s1">protected _cookies: NextApiRequestCookies | undefined</span><span class="s3">\n  </span><span class="s1">public abstract headers: IncomingHttpHeaders</span><span class="s3">\n  </span><span class="s1">public abstract fetchMetrics: FetchMetric[] | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">public method: string,</span><span class="s3">\n    </span><span class="s1">public url: string,</span><span class="s3">\n    </span><span class="s1">public body: Body</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n\n  </span><span class="s1">// Utils implemented using the abstract methods above</span><span class="s3">\n\n  </span><span class="s1">public get cookies() {</span><span class="s3">\n    </span><span class="s1">if (this._cookies) return this._cookies</span><span class="s3">\n    </span><span class="s1">return (this._cookies = getCookieParser(this.headers)())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export abstract class BaseNextResponse&lt;Destination = any&gt; {</span><span class="s3">\n  </span><span class="s1">abstract statusCode: number | undefined</span><span class="s3">\n  </span><span class="s1">abstract statusMessage: string | undefined</span><span class="s3">\n  </span><span class="s1">abstract get sent(): boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(public destination: Destination) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Sets a value for the header overwriting existing values</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">abstract setHeader(name: string, value: string | string[]): this</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes a header</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">abstract removeHeader(name: string): this</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Appends value for the given header name</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">abstract appendHeader(name: string, value: string): this</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Get all values for a header as an array or undefined if no value is present</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">abstract getHeaderValues(name: string): string[] | undefined</span><span class="s3">\n\n  </span><span class="s1">abstract hasHeader(name: string): boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Get values for a header concatenated using `,` or undefined if no value is present</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">abstract getHeader(name: string): string | undefined</span><span class="s3">\n\n  </span><span class="s1">abstract getHeaders(): OutgoingHttpHeaders</span><span class="s3">\n\n  </span><span class="s1">abstract body(value: string): this</span><span class="s3">\n\n  </span><span class="s1">abstract send(): void</span><span class="s3">\n\n  </span><span class="s1">abstract onClose(callback: () =&gt; void): void</span><span class="s3">\n\n  </span><span class="s1">// Utils implemented using the abstract methods above</span><span class="s3">\n\n  </span><span class="s1">public redirect(destination: string, statusCode: number) {</span><span class="s3">\n    </span><span class="s1">this.setHeader('Location', destination)</span><span class="s3">\n    </span><span class="s1">this.statusCode = statusCode</span><span class="s3">\n\n    </span><span class="s1">// Since IE11 doesn't support the 308 header add backwards</span><span class="s3">\n    </span><span class="s1">// compatibility using refresh header</span><span class="s3">\n    </span><span class="s1">if (statusCode === RedirectStatusCode.PermanentRedirect) {</span><span class="s3">\n      </span><span class="s1">this.setHeader('Refresh', `0;url=${destination}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ServerResponse, IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { Writable, Readable } from 'stream'</span><span class="s3">\n\n</span><span class="s1">import { SYMBOL_CLEARED_COOKIES } from '../api-utils'</span><span class="s3">\n</span><span class="s1">import type { NextApiRequestCookies } from '../api-utils'</span><span class="s3">\n\n</span><span class="s1">import { NEXT_REQUEST_META } from '../request-meta'</span><span class="s3">\n</span><span class="s1">import type { RequestMeta } from '../request-meta'</span><span class="s3">\n\n</span><span class="s1">import { BaseNextRequest, BaseNextResponse, type FetchMetric } from './index'</span><span class="s3">\n</span><span class="s1">import type { OutgoingHttpHeaders } from 'node:http'</span><span class="s3">\n\n</span><span class="s1">type Req = IncomingMessage &amp; {</span><span class="s3">\n  </span><span class="s1">[NEXT_REQUEST_META]?: RequestMeta</span><span class="s3">\n  </span><span class="s1">cookies?: NextApiRequestCookies</span><span class="s3">\n  </span><span class="s1">fetchMetrics?: FetchMetric[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class NodeNextRequest extends BaseNextRequest&lt;Readable&gt; {</span><span class="s3">\n  </span><span class="s1">public headers = this._req.headers</span><span class="s3">\n  </span><span class="s1">public fetchMetrics: FetchMetric[] | undefined = this._req?.fetchMetrics;</span><span class="s3">\n\n  </span><span class="s1">[NEXT_REQUEST_META]: RequestMeta = this._req[NEXT_REQUEST_META] || {}</span><span class="s3">\n\n  </span><span class="s1">constructor(private _req: Req) {</span><span class="s3">\n    </span><span class="s1">super(_req.method!.toUpperCase(), _req.url!, _req)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get originalRequest() {</span><span class="s3">\n    </span><span class="s1">// Need to mimic these changes to the original req object for places where we use it:</span><span class="s3">\n    </span><span class="s1">// render.tsx, api/ssg requests</span><span class="s3">\n    </span><span class="s1">this._req[NEXT_REQUEST_META] = this[NEXT_REQUEST_META]</span><span class="s3">\n    </span><span class="s1">this._req.url = this.url</span><span class="s3">\n    </span><span class="s1">this._req.cookies = this.cookies</span><span class="s3">\n    </span><span class="s1">return this._req</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set originalRequest(value: Req) {</span><span class="s3">\n    </span><span class="s1">this._req = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private streaming = false</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the request body as a Web Readable Stream. The body here can only</span><span class="s3">\n   </span><span class="s1">* be read once as the body will start flowing as soon as the data handler</span><span class="s3">\n   </span><span class="s1">* is attached.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @internal</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public stream() {</span><span class="s3">\n    </span><span class="s1">if (this.streaming) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Invariant: NodeNextRequest.stream() can only be called once'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.streaming = true</span><span class="s3">\n\n    </span><span class="s1">return new ReadableStream({</span><span class="s3">\n      </span><span class="s1">start: (controller) =&gt; {</span><span class="s3">\n        </span><span class="s1">this._req.on('data', (chunk) =&gt; {</span><span class="s3">\n          </span><span class="s1">controller.enqueue(new Uint8Array(chunk))</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">this._req.on('end', () =&gt; {</span><span class="s3">\n          </span><span class="s1">controller.close()</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">this._req.on('error', (err) =&gt; {</span><span class="s3">\n          </span><span class="s1">controller.error(err)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class NodeNextResponse extends BaseNextResponse&lt;Writable&gt; {</span><span class="s3">\n  </span><span class="s1">private textBody: string | undefined = undefined</span><span class="s3">\n\n  </span><span class="s1">public [SYMBOL_CLEARED_COOKIES]?: boolean</span><span class="s3">\n\n  </span><span class="s1">get originalResponse() {</span><span class="s3">\n    </span><span class="s1">if (SYMBOL_CLEARED_COOKIES in this) {</span><span class="s3">\n      </span><span class="s1">this._res[SYMBOL_CLEARED_COOKIES] = this[SYMBOL_CLEARED_COOKIES]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this._res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">private _res: ServerResponse &amp; { [SYMBOL_CLEARED_COOKIES]?: boolean }</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">super(_res)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get sent() {</span><span class="s3">\n    </span><span class="s1">return this._res.finished || this._res.headersSent</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get statusCode() {</span><span class="s3">\n    </span><span class="s1">return this._res.statusCode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set statusCode(value: number) {</span><span class="s3">\n    </span><span class="s1">this._res.statusCode = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get statusMessage() {</span><span class="s3">\n    </span><span class="s1">return this._res.statusMessage</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set statusMessage(value: string) {</span><span class="s3">\n    </span><span class="s1">this._res.statusMessage = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">setHeader(name: string, value: string | string[]): this {</span><span class="s3">\n    </span><span class="s1">this._res.setHeader(name, value)</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">removeHeader(name: string): this {</span><span class="s3">\n    </span><span class="s1">this._res.removeHeader(name)</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getHeaderValues(name: string): string[] | undefined {</span><span class="s3">\n    </span><span class="s1">const values = this._res.getHeader(name)</span><span class="s3">\n\n    </span><span class="s1">if (values === undefined) return undefined</span><span class="s3">\n\n    </span><span class="s1">return (Array.isArray(values) ? values : [values]).map((value) =&gt;</span><span class="s3">\n      </span><span class="s1">value.toString()</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">hasHeader(name: string): boolean {</span><span class="s3">\n    </span><span class="s1">return this._res.hasHeader(name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getHeader(name: string): string | undefined {</span><span class="s3">\n    </span><span class="s1">const values = this.getHeaderValues(name)</span><span class="s3">\n    </span><span class="s1">return Array.isArray(values) ? values.join(',') : undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getHeaders(): OutgoingHttpHeaders {</span><span class="s3">\n    </span><span class="s1">return this._res.getHeaders()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">appendHeader(name: string, value: string): this {</span><span class="s3">\n    </span><span class="s1">const currentValues = this.getHeaderValues(name) ?? []</span><span class="s3">\n\n    </span><span class="s1">if (!currentValues.includes(value)) {</span><span class="s3">\n      </span><span class="s1">this._res.setHeader(name, [...currentValues, value])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">body(value: string) {</span><span class="s3">\n    </span><span class="s1">this.textBody = value</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">send() {</span><span class="s3">\n    </span><span class="s1">this._res.end(this.textBody)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public onClose(callback: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">this.originalResponse.on('close', callback)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type RenderResult from './render-result'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n\n</span><span class="s1">import { isResSent } from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { generateETag } from './lib/etag'</span><span class="s3">\n</span><span class="s1">import fresh from 'next/dist/compiled/fresh'</span><span class="s3">\n</span><span class="s1">import { getCacheControlHeader } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import { HTML_CONTENT_TYPE_HEADER } from '../lib/constants'</span><span class="s3">\n\n</span><span class="s1">export function sendEtagResponse(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">etag: string | undefined</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (etag) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The server generating a 304 response MUST generate any of the</span><span class="s3">\n     </span><span class="s1">* following header fields that would have been sent in a 200 (OK)</span><span class="s3">\n     </span><span class="s1">* response to the same request: Cache-Control, Content-Location, Date,</span><span class="s3">\n     </span><span class="s1">* ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">res.setHeader('ETag', etag)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (fresh(req.headers, { etag })) {</span><span class="s3">\n    </span><span class="s1">res.statusCode = 304</span><span class="s3">\n    </span><span class="s1">res.end()</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function sendRenderResult({</span><span class="s3">\n  </span><span class="s1">req,</span><span class="s3">\n  </span><span class="s1">res,</span><span class="s3">\n  </span><span class="s1">result,</span><span class="s3">\n  </span><span class="s1">generateEtags,</span><span class="s3">\n  </span><span class="s1">poweredByHeader,</span><span class="s3">\n  </span><span class="s1">cacheControl,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage</span><span class="s3">\n  </span><span class="s1">res: ServerResponse</span><span class="s3">\n  </span><span class="s1">result: RenderResult</span><span class="s3">\n  </span><span class="s1">generateEtags: boolean</span><span class="s3">\n  </span><span class="s1">poweredByHeader: boolean</span><span class="s3">\n  </span><span class="s1">cacheControl: CacheControl | undefined</span><span class="s3">\n</span><span class="s1">}): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">if (isResSent(res)) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (poweredByHeader &amp;&amp; result.contentType === HTML_CONTENT_TYPE_HEADER) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('X-Powered-By', 'Next.js')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If cache control is already set on the response we don't</span><span class="s3">\n  </span><span class="s1">// override it to allow users to customize it via next.config</span><span class="s3">\n  </span><span class="s1">if (cacheControl &amp;&amp; !res.getHeader('Cache-Control')) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('Cache-Control', getCacheControlHeader(cacheControl))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const payload = result.isDynamic ? null : result.toUnchunkedString()</span><span class="s3">\n\n  </span><span class="s1">if (generateEtags &amp;&amp; payload !== null) {</span><span class="s3">\n    </span><span class="s1">const etag = generateETag(payload)</span><span class="s3">\n    </span><span class="s1">if (sendEtagResponse(req, res, etag)) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!res.getHeader('Content-Type') &amp;&amp; result.contentType) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('Content-Type', result.contentType)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (payload) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('Content-Length', Buffer.byteLength(payload))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (req.method === 'HEAD') {</span><span class="s3">\n    </span><span class="s1">res.end(null)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (payload !== null) {</span><span class="s3">\n    </span><span class="s1">res.end(payload)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Pipe the render result to the response after we get a writer for it.</span><span class="s3">\n  </span><span class="s1">await result.pipeToNodeResponse(res)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { CACHE_ONE_YEAR } from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The revalidate option used internally for pages. A value of `false` means</span><span class="s3">\n </span><span class="s1">* that the page should not be revalidated. A number means that the page</span><span class="s3">\n </span><span class="s1">* should be revalidated after the given number of seconds (this also includes</span><span class="s3">\n </span><span class="s1">* `1` which means to revalidate after 1 second). A value of `0` is not a valid</span><span class="s3">\n </span><span class="s1">* value for this option.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type Revalidate = number | false</span><span class="s3">\n\n</span><span class="s1">export interface CacheControl {</span><span class="s3">\n  </span><span class="s1">revalidate: Revalidate</span><span class="s3">\n  </span><span class="s1">expire: number | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getCacheControlHeader({</span><span class="s3">\n  </span><span class="s1">revalidate,</span><span class="s3">\n  </span><span class="s1">expire,</span><span class="s3">\n</span><span class="s1">}: CacheControl): string {</span><span class="s3">\n  </span><span class="s1">const swrHeader =</span><span class="s3">\n    </span><span class="s1">typeof revalidate === 'number' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">expire !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">revalidate &lt; expire</span><span class="s3">\n      </span><span class="s1">? `, stale-while-revalidate=${expire - revalidate}`</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">if (revalidate === 0) {</span><span class="s3">\n    </span><span class="s1">return 'private, no-cache, no-store, max-age=0, must-revalidate'</span><span class="s3">\n  </span><span class="s1">} else if (typeof revalidate === 'number') {</span><span class="s3">\n    </span><span class="s1">return `s-maxage=${revalidate}${swrHeader}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return `s-maxage=${CACHE_ONE_YEAR}${swrHeader}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* FNV-1a Hash implementation</span><span class="s3">\n </span><span class="s1">* @author Travis Webb (tjwebb) &lt;me@traviswebb.com&gt;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Ported from https://github.com/tjwebb/fnv-plus/blob/master/index.js</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Simplified, optimized and add modified for 52 bit, which provides a larger hash space</span><span class="s3">\n </span><span class="s1">* and still making use of Javascript's 53-bit integer space.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const fnv1a52 = (str: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">const len = str.length</span><span class="s3">\n  </span><span class="s1">let i = 0,</span><span class="s3">\n    </span><span class="s1">t0 = 0,</span><span class="s3">\n    </span><span class="s1">v0 = 0x2325,</span><span class="s3">\n    </span><span class="s1">t1 = 0,</span><span class="s3">\n    </span><span class="s1">v1 = 0x8422,</span><span class="s3">\n    </span><span class="s1">t2 = 0,</span><span class="s3">\n    </span><span class="s1">v2 = 0x9ce4,</span><span class="s3">\n    </span><span class="s1">t3 = 0,</span><span class="s3">\n    </span><span class="s1">v3 = 0xcbf2</span><span class="s3">\n\n  </span><span class="s1">while (i &lt; len) {</span><span class="s3">\n    </span><span class="s1">v0 ^= str.charCodeAt(i++)</span><span class="s3">\n    </span><span class="s1">t0 = v0 * 435</span><span class="s3">\n    </span><span class="s1">t1 = v1 * 435</span><span class="s3">\n    </span><span class="s1">t2 = v2 * 435</span><span class="s3">\n    </span><span class="s1">t3 = v3 * 435</span><span class="s3">\n    </span><span class="s1">t2 += v0 &lt;&lt; 8</span><span class="s3">\n    </span><span class="s1">t3 += v1 &lt;&lt; 8</span><span class="s3">\n    </span><span class="s1">t1 += t0 &gt;&gt;&gt; 16</span><span class="s3">\n    </span><span class="s1">v0 = t0 &amp; 65535</span><span class="s3">\n    </span><span class="s1">t2 += t1 &gt;&gt;&gt; 16</span><span class="s3">\n    </span><span class="s1">v1 = t1 &amp; 65535</span><span class="s3">\n    </span><span class="s1">v3 = (t3 + (t2 &gt;&gt;&gt; 16)) &amp; 65535</span><span class="s3">\n    </span><span class="s1">v2 = t2 &amp; 65535</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">(v3 &amp; 15) * 281474976710656 +</span><span class="s3">\n    </span><span class="s1">v2 * 4294967296 +</span><span class="s3">\n    </span><span class="s1">v1 * 65536 +</span><span class="s3">\n    </span><span class="s1">(v0 ^ (v3 &gt;&gt; 4))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const generateETag = (payload: string, weak = false) =&gt; {</span><span class="s3">\n  </span><span class="s1">const prefix = weak ? 'W/</span><span class="s3">\&quot;</span><span class="s1">' : '</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">export function searchParamsToUrlQuery(</span><span class="s3">\n  </span><span class="s1">searchParams: URLSearchParams</span><span class="s3">\n</span><span class="s1">): ParsedUrlQuery {</span><span class="s3">\n  </span><span class="s1">const query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of searchParams.entries()) {</span><span class="s3">\n    </span><span class="s1">const existing = query[key]</span><span class="s3">\n    </span><span class="s1">if (typeof existing === 'undefined') {</span><span class="s3">\n      </span><span class="s1">query[key] = value</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(existing)) {</span><span class="s3">\n      </span><span class="s1">existing.push(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">query[key] = [existing, value]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return query</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function stringifyUrlQueryParam(param: unknown): string {</span><span class="s3">\n  </span><span class="s1">if (typeof param === 'string') {</span><span class="s3">\n    </span><span class="s1">return param</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(typeof param === 'number' &amp;&amp; !isNaN(param)) ||</span><span class="s3">\n    </span><span class="s1">typeof param === 'boolean'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return String(param)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function urlQueryToSearchParams(query: ParsedUrlQuery): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">const searchParams = new URLSearchParams()</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">for (const item of value) {</span><span class="s3">\n        </span><span class="s1">searchParams.append(key, stringifyUrlQueryParam(item))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">searchParams.set(key, stringifyUrlQueryParam(value))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return searchParams</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assign(</span><span class="s3">\n  </span><span class="s1">target: URLSearchParams,</span><span class="s3">\n  </span><span class="s1">...searchParamsList: URLSearchParams[]</span><span class="s3">\n</span><span class="s1">): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">for (const searchParams of searchParamsList) {</span><span class="s3">\n    </span><span class="s1">for (const key of searchParams.keys()) {</span><span class="s3">\n      </span><span class="s1">target.delete(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [key, value] of searchParams.entries()) {</span><span class="s3">\n      </span><span class="s1">target.append(key, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return target</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">import { searchParamsToUrlQuery } from './querystring'</span><span class="s3">\n</span><span class="s1">import { parseRelativeUrl } from './parse-relative-url'</span><span class="s3">\n\n</span><span class="s1">export interface ParsedUrl {</span><span class="s3">\n  </span><span class="s1">hash: string</span><span class="s3">\n  </span><span class="s1">hostname?: string | null</span><span class="s3">\n  </span><span class="s1">href: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">port?: string | null</span><span class="s3">\n  </span><span class="s1">protocol?: string | null</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">search: string</span><span class="s3">\n  </span><span class="s1">slashes: boolean | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseUrl(url: string): ParsedUrl {</span><span class="s3">\n  </span><span class="s1">if (url.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">return parseRelativeUrl(url)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsedURL = new URL(url)</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">hash: parsedURL.hash,</span><span class="s3">\n    </span><span class="s1">hostname: parsedURL.hostname,</span><span class="s3">\n    </span><span class="s1">href: parsedURL.href,</span><span class="s3">\n    </span><span class="s1">pathname: parsedURL.pathname,</span><span class="s3">\n    </span><span class="s1">port: parsedURL.port,</span><span class="s3">\n    </span><span class="s1">protocol: parsedURL.protocol,</span><span class="s3">\n    </span><span class="s1">query: searchParamsToUrlQuery(parsedURL.searchParams),</span><span class="s3">\n    </span><span class="s1">search: parsedURL.search,</span><span class="s3">\n    </span><span class="s1">slashes:</span><span class="s3">\n      </span><span class="s1">parsedURL.href.slice(</span><span class="s3">\n        </span><span class="s1">parsedURL.protocol.length,</span><span class="s3">\n        </span><span class="s1">parsedURL.protocol.length + 2</span><span class="s3">\n      </span><span class="s1">) === '//',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import { getLocationOrigin } from '../../utils'</span><span class="s3">\n</span><span class="s1">import { searchParamsToUrlQuery } from './querystring'</span><span class="s3">\n\n</span><span class="s1">export interface ParsedRelativeUrl {</span><span class="s3">\n  </span><span class="s1">hash: string</span><span class="s3">\n  </span><span class="s1">href: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">search: string</span><span class="s3">\n  </span><span class="s1">slashes: undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative</span><span class="s3">\n </span><span class="s1">* (e.g. `./hello`) then at least base must be.</span><span class="s3">\n </span><span class="s1">* Absolute urls are rejected with one exception, in the browser, absolute urls that are on</span><span class="s3">\n </span><span class="s1">* the current origin will be parsed as relative</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base?: string,</span><span class="s3">\n  </span><span class="s1">parseQuery?: true</span><span class="s3">\n</span><span class="s1">): ParsedRelativeUrl</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base: string | undefined,</span><span class="s3">\n  </span><span class="s1">parseQuery: false</span><span class="s3">\n</span><span class="s1">): Omit&lt;ParsedRelativeUrl, 'query'&gt;</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base?: string,</span><span class="s3">\n  </span><span class="s1">parseQuery = true</span><span class="s3">\n</span><span class="s1">): ParsedRelativeUrl | Omit&lt;ParsedRelativeUrl, 'query'&gt; {</span><span class="s3">\n  </span><span class="s1">const globalBase = new URL(</span><span class="s3">\n    </span><span class="s1">typeof window === 'undefined' ? 'http://n' : getLocationOrigin()</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const resolvedBase = base</span><span class="s3">\n    </span><span class="s1">? new URL(base, globalBase)</span><span class="s3">\n    </span><span class="s1">: url.startsWith('.')</span><span class="s3">\n      </span><span class="s1">? new URL(</span><span class="s3">\n          </span><span class="s1">typeof window === 'undefined' ? 'http://n' : window.location.href</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: globalBase</span><span class="s3">\n\n  </span><span class="s1">const { pathname, searchParams, search, hash, href, origin } = new URL(</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">resolvedBase</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (origin !== globalBase.origin) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`invariant: invalid relative URL, router received ${url}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">query: parseQuery ? searchParamsToUrlQuery(searchParams) : undefined,</span><span class="s3">\n    </span><span class="s1">search,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">href: href.slice(origin.length),</span><span class="s3">\n    </span><span class="s1">// We don't know for relative URLs at this point since we set a custom, internal</span><span class="s3">\n    </span><span class="s1">// base that isn't surfaced to users.</span><span class="s3">\n    </span><span class="s1">slashes: undefined,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { bold, green, magenta, red, yellow, white } from '../../lib/picocolors'</span><span class="s3">\n</span><span class="s1">import { LRUCache } from '../../server/lib/lru-cache'</span><span class="s3">\n\n</span><span class="s1">export const prefixes = {</span><span class="s3">\n  </span><span class="s1">wait: white(bold('')),</span><span class="s3">\n  </span><span class="s1">error: red(bold('')),</span><span class="s3">\n  </span><span class="s1">warn: yellow(bold('')),</span><span class="s3">\n  </span><span class="s1">ready: '', // no color</span><span class="s3">\n  </span><span class="s1">info: white(bold(' ')),</span><span class="s3">\n  </span><span class="s1">event: green(bold('')),</span><span class="s3">\n  </span><span class="s1">trace: magenta(bold('')),</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">const LOGGING_METHOD = {</span><span class="s3">\n  </span><span class="s1">log: 'log',</span><span class="s3">\n  </span><span class="s1">warn: 'warn',</span><span class="s3">\n  </span><span class="s1">error: 'error',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">function prefixedLog(prefixType: keyof typeof prefixes, ...message: any[]) {</span><span class="s3">\n  </span><span class="s1">if ((message[0] === '' || message[0] === undefined) &amp;&amp; message.length === 1) {</span><span class="s3">\n    </span><span class="s1">message.shift()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const consoleMethod: keyof typeof LOGGING_METHOD =</span><span class="s3">\n    </span><span class="s1">prefixType in LOGGING_METHOD</span><span class="s3">\n      </span><span class="s1">? LOGGING_METHOD[prefixType as keyof typeof LOGGING_METHOD]</span><span class="s3">\n      </span><span class="s1">: 'log'</span><span class="s3">\n\n  </span><span class="s1">const prefix = prefixes[prefixType]</span><span class="s3">\n  </span><span class="s1">// If there's no message, don't print the prefix but a new line</span><span class="s3">\n  </span><span class="s1">if (message.length === 0) {</span><span class="s3">\n    </span><span class="s1">console[consoleMethod]('')</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Ensure if there's ANSI escape codes it's concatenated into one string.</span><span class="s3">\n    </span><span class="s1">// Chrome DevTool can only handle color if it's in one string.</span><span class="s3">\n    </span><span class="s1">if (message.length === 1 &amp;&amp; typeof message[0] === 'string') {</span><span class="s3">\n      </span><span class="s1">console[consoleMethod](' ' + prefix + ' ' + message[0])</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">console[consoleMethod](' ' + prefix, ...message)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function bootstrap(...message: string[]) {</span><span class="s3">\n  </span><span class="s1">// logging format: ' &lt;prefix&gt; &lt;message&gt;'</span><span class="s3">\n  </span><span class="s1">// e.g. '  Compiled successfully'</span><span class="s3">\n  </span><span class="s1">// Add spaces to align with the indent of other logs</span><span class="s3">\n  </span><span class="s1">console.log('   ' + message.join(' '))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function wait(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('wait', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function error(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('error', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function warn(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('warn', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ready(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('ready', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function info(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('info', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function event(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('event', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function trace(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('trace', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const warnOnceCache = new LRUCache&lt;string&gt;(10_000, (value) =&gt; value.length)</span><span class="s3">\n</span><span class="s1">export function warnOnce(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">const key = message.join(' ')</span><span class="s3">\n  </span><span class="s1">if (!warnOnceCache.has(key)) {</span><span class="s3">\n    </span><span class="s1">warnOnceCache.set(key, key)</span><span class="s3">\n    </span><span class="s1">warn(...message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Regex from `node/lib/internal/net.js`: https://github.com/nodejs/node/blob/9fc57006c27564ed7f75eee090eca86786508f51/lib/internal/net.js#L19-L29</span><span class="s3">\n</span><span class="s1">// License included below:</span><span class="s3">\n</span><span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span><span class="s3">\n</span><span class="s1">// copy of this software and associated documentation files (the</span><span class="s3">\n</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Software</span><span class="s3">\&quot;</span><span class="s1">), to deal in the Software without restriction, including</span><span class="s3">\n</span><span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span><span class="s3">\n</span><span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span><span class="s3">\n</span><span class="s1">// persons to whom the Software is furnished to do so, subject to the</span><span class="s3">\n</span><span class="s1">// following conditions:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The above copyright notice and this permission notice shall be included</span><span class="s3">\n</span><span class="s1">// in all copies or substantial portions of the Software.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot;</span><span class="s1">, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span><span class="s3">\n</span><span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span><span class="s3">\n</span><span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span><span class="s3">\n</span><span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span><span class="s3">\n</span><span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span><span class="s3">\n</span><span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span><span class="s3">\n</span><span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span><span class="s3">\n\n</span><span class="s1">const v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'</span><span class="s3">\n</span><span class="s1">const v4Str = `(${v4Seg}[.]){3}${v4Seg}`</span><span class="s3">\n</span><span class="s1">const v6Seg = '(?:[0-9a-fA-F]{1,4})'</span><span class="s3">\n</span><span class="s1">const IPv6Reg = new RegExp(</span><span class="s3">\n  </span><span class="s1">'^(' +</span><span class="s3">\n    </span><span class="s1">`(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +</span><span class="s3">\n    </span><span class="s1">`(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +</span><span class="s3">\n    </span><span class="s1">`(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +</span><span class="s3">\n    </span><span class="s1">`(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +</span><span class="s3">\n    </span><span class="s1">`(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +</span><span class="s3">\n    </span><span class="s1">`(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +</span><span class="s3">\n    </span><span class="s1">`(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +</span><span class="s3">\n    </span><span class="s1">`(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +</span><span class="s3">\n    </span><span class="s1">')(%[0-9a-zA-Z-.:]{1,})?$'</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export function isIPv6(s: string) {</span><span class="s3">\n  </span><span class="s1">return IPv6Reg.test(s)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* For a given page path, this function ensures that there is a leading slash.</span><span class="s3">\n </span><span class="s1">* If there is not a leading slash, one is added, otherwise it is noop.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function ensureLeadingSlash(path: string) {</span><span class="s3">\n  </span><span class="s1">return path.startsWith('/') ? path : `/${path}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { isGroupSegment } from '../../segment'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes an app route so it represents the actual request path. Essentially</span><span class="s3">\n </span><span class="s1">* performing the following transformations:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/user/[id]/page` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/account/page` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/user/[id]/page` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/account/page` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/page` to `/`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/user/[id]/route` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/account/route` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/user/[id]/route` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/account/route` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/route` to `/`</span><span class="s3">\n </span><span class="s1">* - `/` to `/`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param route the app route to normalize</span><span class="s3">\n </span><span class="s1">* @returns the normalized pathname</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeAppPath(route: string) {</span><span class="s3">\n  </span><span class="s1">return ensureLeadingSlash(</span><span class="s3">\n    </span><span class="s1">route.split('/').reduce((pathname, segment, index, segments) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Empty segments are ignored.</span><span class="s3">\n      </span><span class="s1">if (!segment) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Groups are ignored.</span><span class="s3">\n      </span><span class="s1">if (isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Parallel segments are ignored.</span><span class="s3">\n      </span><span class="s1">if (segment[0] === '@') {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// The last segment (if it's a leaf) should be ignored.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(segment === 'page' || segment === 'route') &amp;&amp;</span><span class="s3">\n        </span><span class="s1">index === segments.length - 1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${pathname}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips the `.rsc` extension if it's in the pathname.</span><span class="s3">\n </span><span class="s1">* Since this function is used on full urls it checks `?` for searchParams handling.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeRscURL(url: string) {</span><span class="s3">\n  </span><span class="s1">return url.replace(</span><span class="s3">\n    </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.rsc($|</span><span class="s3">\\</span><span class="s1">?)/,</span><span class="s3">\n    </span><span class="s1">// $1 ensures `?` is preserved</span><span class="s3">\n    </span><span class="s1">'$1'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Segment } from '../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">export function isGroupSegment(segment: string) {</span><span class="s3">\n  </span><span class="s1">// Use array[0] for performant purpose</span><span class="s3">\n  </span><span class="s1">return segment[0] === '(' &amp;&amp; segment.endsWith(')')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isParallelRouteSegment(segment: string) {</span><span class="s3">\n  </span><span class="s1">return segment.startsWith('@') &amp;&amp; segment !== '@children'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function addSearchParamsIfPageSegment(</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">searchParams: Record&lt;string, string | string[] | undefined&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)</span><span class="s3">\n\n  </span><span class="s1">if (isPageSegment) {</span><span class="s3">\n    </span><span class="s1">const stringifiedQuery = JSON.stringify(searchParams)</span><span class="s3">\n    </span><span class="s1">return stringifiedQuery !== '{}'</span><span class="s3">\n      </span><span class="s1">? PAGE_SEGMENT_KEY + '?' + stringifiedQuery</span><span class="s3">\n      </span><span class="s1">: PAGE_SEGMENT_KEY</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const PAGE_SEGMENT_KEY = '__PAGE__'</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SEGMENT_KEY = '__DEFAULT__'</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizeAppPath } from './app-paths'</span><span class="s3">\n\n</span><span class="s1">// order matters here, the first match will be used</span><span class="s3">\n</span><span class="s1">export const INTERCEPTION_ROUTE_MARKERS = [</span><span class="s3">\n  </span><span class="s1">'(..)(..)',</span><span class="s3">\n  </span><span class="s1">'(.)',</span><span class="s3">\n  </span><span class="s1">'(..)',</span><span class="s3">\n  </span><span class="s1">'(...)',</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteAppPath(path: string): boolean {</span><span class="s3">\n  </span><span class="s1">// TODO-APP: add more serious validation</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">path</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n      </span><span class="s1">.find((segment) =&gt;</span><span class="s3">\n        </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n      </span><span class="s1">) !== undefined</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractInterceptionRouteInformation(path: string) {</span><span class="s3">\n  </span><span class="s1">let interceptingRoute: string | undefined,</span><span class="s3">\n    </span><span class="s1">marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,</span><span class="s3">\n    </span><span class="s1">interceptedRoute: string | undefined</span><span class="s3">\n\n  </span><span class="s1">for (const segment of path.split('/')) {</span><span class="s3">\n    </span><span class="s1">marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n    </span><span class="s1">if (marker) {</span><span class="s3">\n      </span><span class="s1">;[interceptingRoute, interceptedRoute] = path.split(marker, 2)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!interceptingRoute || !marker || !interceptedRoute) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid interception route: ${path}. Must be in the format /&lt;intercepting route&gt;/(..|...|..)(..)/&lt;intercepted route&gt;`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -&gt; /feed</span><span class="s3">\n\n  </span><span class="s1">switch (marker) {</span><span class="s3">\n    </span><span class="s1">case '(.)':</span><span class="s3">\n      </span><span class="s1">// (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = `/${interceptedRoute}`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = interceptingRoute + '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)':</span><span class="s3">\n      </span><span class="s1">// (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">interceptedRoute = interceptingRoute</span><span class="s3">\n        </span><span class="s1">.split('/')</span><span class="s3">\n        </span><span class="s1">.slice(0, -1)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(...)':</span><span class="s3">\n      </span><span class="s1">// (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route</span><span class="s3">\n      </span><span class="s1">interceptedRoute = '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)(..)':</span><span class="s3">\n      </span><span class="s1">// (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route</span><span class="s3">\n\n      </span><span class="s1">const splitInterceptingRoute = interceptingRoute.split('/')</span><span class="s3">\n      </span><span class="s1">if (splitInterceptingRoute.length &lt;= 2) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">interceptedRoute = splitInterceptingRoute</span><span class="s3">\n        </span><span class="s1">.slice(0, -2)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: unexpected marker')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { interceptingRoute, interceptedRoute }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from './interception-routes'</span><span class="s3">\n\n</span><span class="s1">// Identify /.*[param].*/ in route string</span><span class="s3">\n</span><span class="s1">const TEST_ROUTE = /</span><span class="s3">\\</span><span class="s1">/[^/]*</span><span class="s3">\\</span><span class="s1">[[^/]+</span><span class="s3">\\</span><span class="s1">][^/]*(?=</span><span class="s3">\\</span><span class="s1">/|$)/</span><span class="s3">\n\n</span><span class="s1">// Identify /[param]/ in route string</span><span class="s3">\n</span><span class="s1">const TEST_STRICT_ROUTE = /</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">[[^/]+</span><span class="s3">\\</span><span class="s1">](?=</span><span class="s3">\\</span><span class="s1">/|$)/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if a route is dynamic.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param route - The route to check.</span><span class="s3">\n </span><span class="s1">* @param strict - Whether to use strict mode which prohibits segments with prefixes/suffixes (default: true).</span><span class="s3">\n </span><span class="s1">* @returns Whether the route is dynamic.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isDynamicRoute(route: string, strict: boolean = true): boolean {</span><span class="s3">\n  </span><span class="s1">if (isInterceptionRouteAppPath(route)) {</span><span class="s3">\n    </span><span class="s1">route = extractInterceptionRouteInformation(route).interceptedRoute</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (strict) {</span><span class="s3">\n    </span><span class="s1">return TEST_STRICT_ROUTE.test(route)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return TEST_ROUTE.test(route)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// This regex contains the bots that we need to do a blocking render for and can't safely stream the response</span><span class="s3">\n</span><span class="s1">// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.</span><span class="s3">\n</span><span class="s1">// Note: The pattern [</span><span class="s3">\\</span><span class="s1">w-]+-Google captures all Google crawlers with </span><span class="s3">\&quot;</span><span class="s1">-Google</span><span class="s3">\&quot; </span><span class="s1">suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)</span><span class="s3">\n</span><span class="s1">// as well as crawlers starting with </span><span class="s3">\&quot;</span><span class="s1">Google-</span><span class="s3">\&quot; </span><span class="s1">(e.g., Google-PageRenderer, Google-InspectionTool)</span><span class="s3">\n</span><span class="s1">export const HTML_LIMITED_BOT_UA_RE =</span><span class="s3">\n  </span><span class="s1">/[</span><span class="s3">\\</span><span class="s1">w-]+-Google|Google-[</span><span class="s3">\\</span><span class="s1">w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { HTML_LIMITED_BOT_UA_RE } from './html-bots'</span><span class="s3">\n\n</span><span class="s1">// Bot crawler that will spin up a headless browser and execute JS.</span><span class="s3">\n</span><span class="s1">// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.</span><span class="s3">\n</span><span class="s1">// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers</span><span class="s3">\n</span><span class="s1">// This regex specifically matches </span><span class="s3">\&quot;</span><span class="s1">Googlebot</span><span class="s3">\&quot; </span><span class="s1">but NOT </span><span class="s3">\&quot;</span><span class="s1">Mediapartners-Google</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">AdsBot-Google</span><span class="s3">\&quot;</span><span class="s1">, etc.</span><span class="s3">\n</span><span class="s1">const HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i</span><span class="s3">\n\n</span><span class="s1">export const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source</span><span class="s3">\n\n</span><span class="s1">export { HTML_LIMITED_BOT_UA_RE }</span><span class="s3">\n\n</span><span class="s1">function isDomBotUA(userAgent: string) {</span><span class="s3">\n  </span><span class="s1">return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isHtmlLimitedBotUA(userAgent: string) {</span><span class="s3">\n  </span><span class="s1">return HTML_LIMITED_BOT_UA_RE.test(userAgent)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isBot(userAgent: string): boolean {</span><span class="s3">\n  </span><span class="s1">return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getBotType(userAgent: string): 'dom' | 'html' | undefined {</span><span class="s3">\n  </span><span class="s1">if (isDomBotUA(userAgent)) {</span><span class="s3">\n    </span><span class="s1">return 'dom'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isHtmlLimitedBotUA(userAgent)) {</span><span class="s3">\n    </span><span class="s1">return 'html'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ReactDOMServerReadableStream } from 'react-dom/server'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { AppRenderSpan } from '../lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../lib/detached-promise'</span><span class="s3">\n</span><span class="s1">import { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import { ENCODED_TAGS } from './encoded-tags'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">indexOfUint8Array,</span><span class="s3">\n  </span><span class="s1">isEquivalentUint8Arrays,</span><span class="s3">\n  </span><span class="s1">removeFromUint8Array,</span><span class="s3">\n</span><span class="s1">} from './uint8array-helpers'</span><span class="s3">\n</span><span class="s1">import { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'</span><span class="s3">\n</span><span class="s1">import { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'</span><span class="s3">\n\n</span><span class="s1">function voidCatch() {</span><span class="s3">\n  </span><span class="s1">// this catcher is designed to be used with pipeTo where we expect the underlying</span><span class="s3">\n  </span><span class="s1">// pipe implementation to forward errors but we don't want the pipeTo promise to reject</span><span class="s3">\n  </span><span class="s1">// and be unhandled</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We can share the same encoder instance everywhere</span><span class="s3">\n</span><span class="s1">// Notably we cannot do the same for TextDecoder because it is stateful</span><span class="s3">\n</span><span class="s1">// when handling streaming data</span><span class="s3">\n</span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n\n</span><span class="s1">export function chainStreams&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">...streams: ReadableStream&lt;T&gt;[]</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">// If we have no streams, return an empty stream. This behavior is</span><span class="s3">\n  </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n  </span><span class="s1">if (streams.length === 0) {</span><span class="s3">\n    </span><span class="s1">return new ReadableStream&lt;T&gt;({</span><span class="s3">\n      </span><span class="s1">start(controller) {</span><span class="s3">\n        </span><span class="s1">controller.close()</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we only have 1 stream we fast path it by returning just this stream</span><span class="s3">\n  </span><span class="s1">if (streams.length === 1) {</span><span class="s3">\n    </span><span class="s1">return streams[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { readable, writable } = new TransformStream()</span><span class="s3">\n\n  </span><span class="s1">// We always initiate pipeTo immediately. We know we have at least 2 streams</span><span class="s3">\n  </span><span class="s1">// so we need to avoid closing the writable when this one finishes.</span><span class="s3">\n  </span><span class="s1">let promise = streams[0].pipeTo(writable, { preventClose: true })</span><span class="s3">\n\n  </span><span class="s1">let i = 1</span><span class="s3">\n  </span><span class="s1">for (; i &lt; streams.length - 1; i++) {</span><span class="s3">\n    </span><span class="s1">const nextStream = streams[i]</span><span class="s3">\n    </span><span class="s1">promise = promise.then(() =&gt;</span><span class="s3">\n      </span><span class="s1">nextStream.pipeTo(writable, { preventClose: true })</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We can omit the length check because we halted before the last stream and there</span><span class="s3">\n  </span><span class="s1">// is at least two streams so the lastStream here will always be defined</span><span class="s3">\n  </span><span class="s1">const lastStream = streams[i]</span><span class="s3">\n  </span><span class="s1">promise = promise.then(() =&gt; lastStream.pipeTo(writable))</span><span class="s3">\n\n  </span><span class="s1">// Catch any errors from the streams and ignore them, they will be handled</span><span class="s3">\n  </span><span class="s1">// by whatever is consuming the readable stream.</span><span class="s3">\n  </span><span class="s1">promise.catch(voidCatch)</span><span class="s3">\n\n  </span><span class="s1">return readable</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function streamFromString(str: string): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(encoder.encode(str))</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function streamFromBuffer(chunk: Buffer): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function streamToBuffer(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;Buffer&gt; {</span><span class="s3">\n  </span><span class="s1">const reader = stream.getReader()</span><span class="s3">\n  </span><span class="s1">const chunks: Uint8Array[] = []</span><span class="s3">\n\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n    </span><span class="s1">if (done) {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">chunks.push(value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return Buffer.concat(chunks)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function streamToString(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n</span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n  </span><span class="s1">const decoder = new TextDecoder('utf-8', { fatal: true })</span><span class="s3">\n  </span><span class="s1">let string = ''</span><span class="s3">\n\n  </span><span class="s1">for await (const chunk of stream) {</span><span class="s3">\n    </span><span class="s1">if (signal?.aborted) {</span><span class="s3">\n      </span><span class="s1">return string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">string += decoder.decode(chunk, { stream: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">string += decoder.decode()</span><span class="s3">\n\n  </span><span class="s1">return string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createBufferedTransformStream(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">let bufferedChunks: Array&lt;Uint8Array&gt; = []</span><span class="s3">\n  </span><span class="s1">let bufferByteLength: number = 0</span><span class="s3">\n  </span><span class="s1">let pending: DetachedPromise&lt;void&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const flush = (controller: TransformStreamDefaultController) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If we already have a pending flush, then return early.</span><span class="s3">\n    </span><span class="s1">if (pending) return</span><span class="s3">\n\n    </span><span class="s1">const detached = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">pending = detached</span><span class="s3">\n\n    </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const chunk = new Uint8Array(bufferByteLength)</span><span class="s3">\n        </span><span class="s1">let copiedBytes = 0</span><span class="s3">\n\n        </span><span class="s1">for (let i = 0; i &lt; bufferedChunks.length; i++) {</span><span class="s3">\n          </span><span class="s1">const bufferedChunk = bufferedChunks[i]</span><span class="s3">\n          </span><span class="s1">chunk.set(bufferedChunk, copiedBytes)</span><span class="s3">\n          </span><span class="s1">copiedBytes += bufferedChunk.byteLength</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// We just wrote all the buffered chunks so we need to reset the bufferedChunks array</span><span class="s3">\n        </span><span class="s1">// and our bufferByteLength to prepare for the next round of buffered chunks</span><span class="s3">\n        </span><span class="s1">bufferedChunks.length = 0</span><span class="s3">\n        </span><span class="s1">bufferByteLength = 0</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// If an error occurs while enqueuing it can't be due to this</span><span class="s3">\n        </span><span class="s1">// transformers fault. It's likely due to the controller being</span><span class="s3">\n        </span><span class="s1">// errored due to the stream being cancelled.</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">pending = undefined</span><span class="s3">\n        </span><span class="s1">detached.resolve()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// Combine the previous buffer with the new chunk.</span><span class="s3">\n      </span><span class="s1">bufferedChunks.push(chunk)</span><span class="s3">\n      </span><span class="s1">bufferByteLength += chunk.byteLength</span><span class="s3">\n\n      </span><span class="s1">// Flush the buffer to the controller.</span><span class="s3">\n      </span><span class="s1">flush(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush() {</span><span class="s3">\n      </span><span class="s1">if (!pending) return</span><span class="s3">\n\n      </span><span class="s1">return pending.promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPrefetchCommentStream(</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean,</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">// Insert an extra comment at the beginning of the HTML document. This must</span><span class="s3">\n  </span><span class="s1">// come after the DOCTYPE, which is inserted by React.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// The first chunk sent by React will contain the doctype. After that, we can</span><span class="s3">\n  </span><span class="s1">// pass through the rest of the chunks as-is.</span><span class="s3">\n  </span><span class="s1">let didTransformFirstChunk = false</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">if (isBuildTimePrerendering &amp;&amp; !didTransformFirstChunk) {</span><span class="s3">\n        </span><span class="s1">didTransformFirstChunk = true</span><span class="s3">\n        </span><span class="s1">const decoder = new TextDecoder('utf-8', { fatal: true })</span><span class="s3">\n        </span><span class="s1">const chunkStr = decoder.decode(chunk, {</span><span class="s3">\n          </span><span class="s1">stream: true,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)</span><span class="s3">\n        </span><span class="s1">controller.enqueue(encoder.encode(updatedChunkStr))</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function renderToInitialFizzStream({</span><span class="s3">\n  </span><span class="s1">ReactDOMServer,</span><span class="s3">\n  </span><span class="s1">element,</span><span class="s3">\n  </span><span class="s1">streamOptions,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">ReactDOMServer: {</span><span class="s3">\n    </span><span class="s1">renderToReadableStream: typeof import('react-dom/server').renderToReadableStream</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">element: React.ReactElement</span><span class="s3">\n  </span><span class="s1">streamOptions?: Parameters&lt;typeof ReactDOMServer.renderToReadableStream&gt;[1]</span><span class="s3">\n</span><span class="s1">}): Promise&lt;ReactDOMServerReadableStream&gt; {</span><span class="s3">\n  </span><span class="s1">return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =&gt;</span><span class="s3">\n    </span><span class="s1">ReactDOMServer.renderToReadableStream(element, streamOptions)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createMetadataTransformStream(</span><span class="s3">\n  </span><span class="s1">insert: () =&gt; Promise&lt;string&gt; | string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let chunkIndex = -1</span><span class="s3">\n  </span><span class="s1">let isMarkRemoved = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">let iconMarkIndex = -1</span><span class="s3">\n      </span><span class="s1">let closedHeadIndex = -1</span><span class="s3">\n      </span><span class="s1">chunkIndex++</span><span class="s3">\n\n      </span><span class="s1">if (isMarkRemoved) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">let iconMarkLength = 0</span><span class="s3">\n      </span><span class="s1">// Only search for the closed head tag once</span><span class="s3">\n      </span><span class="s1">if (iconMarkIndex === -1) {</span><span class="s3">\n        </span><span class="s1">iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)</span><span class="s3">\n        </span><span class="s1">if (iconMarkIndex === -1) {</span><span class="s3">\n          </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// When we found the `&lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">nxt-icon</span><span class="s3">\&quot;</span><span class="s1">` tag prefix, we will remove it from the chunk.</span><span class="s3">\n          </span><span class="s1">// Its close tag could either be `/&gt;` or `&gt;`, checking the next char to ensure we cover both cases.</span><span class="s3">\n          </span><span class="s1">iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length</span><span class="s3">\n          </span><span class="s1">// Check if next char is /, this is for xml mode.</span><span class="s3">\n          </span><span class="s1">if (chunk[iconMarkIndex + iconMarkLength] === 47) {</span><span class="s3">\n            </span><span class="s1">iconMarkLength += 2</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The last char is `&gt;`</span><span class="s3">\n            </span><span class="s1">iconMarkLength++</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check if icon mark is inside &lt;head&gt; tag in the first chunk.</span><span class="s3">\n      </span><span class="s1">if (chunkIndex === 0) {</span><span class="s3">\n        </span><span class="s1">closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)</span><span class="s3">\n        </span><span class="s1">if (iconMarkIndex !== -1) {</span><span class="s3">\n          </span><span class="s1">// The mark icon is located in the 1st chunk before the head tag.</span><span class="s3">\n          </span><span class="s1">// We do not need to insert the script tag in this case because it's in the head.</span><span class="s3">\n          </span><span class="s1">// Just remove the icon mark from the chunk.</span><span class="s3">\n          </span><span class="s1">if (iconMarkIndex &lt; closedHeadIndex) {</span><span class="s3">\n            </span><span class="s1">const replaced = new Uint8Array(chunk.length - iconMarkLength)</span><span class="s3">\n\n            </span><span class="s1">// Remove the icon mark from the chunk.</span><span class="s3">\n            </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n            </span><span class="s1">replaced.set(</span><span class="s3">\n              </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n              </span><span class="s1">iconMarkIndex</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">chunk = replaced</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The icon mark is after the head tag, replace and insert the script tag at that position.</span><span class="s3">\n            </span><span class="s1">const insertion = await insert()</span><span class="s3">\n            </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n            </span><span class="s1">const insertionLength = encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">const replaced = new Uint8Array(</span><span class="s3">\n              </span><span class="s1">chunk.length - iconMarkLength + insertionLength</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n            </span><span class="s1">replaced.set(encodedInsertion, iconMarkIndex)</span><span class="s3">\n            </span><span class="s1">replaced.set(</span><span class="s3">\n              </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n              </span><span class="s1">iconMarkIndex + insertionLength</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">chunk = replaced</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">isMarkRemoved = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If there's no icon mark located, it will be handled later when if present in the following chunks.</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// When it's appeared in the following chunks, we'll need to</span><span class="s3">\n        </span><span class="s1">// remove the mark and then insert the script tag at that position.</span><span class="s3">\n        </span><span class="s1">const insertion = await insert()</span><span class="s3">\n        </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n        </span><span class="s1">const insertionLength = encodedInsertion.length</span><span class="s3">\n        </span><span class="s1">// Replace the icon mark with the hoist script or empty string.</span><span class="s3">\n        </span><span class="s1">const replaced = new Uint8Array(</span><span class="s3">\n          </span><span class="s1">chunk.length - iconMarkLength + insertionLength</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">// Set the first part of the chunk, before the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n        </span><span class="s1">// Set the insertion after the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(encodedInsertion, iconMarkIndex)</span><span class="s3">\n\n        </span><span class="s1">// Set the rest of the chunk after the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(</span><span class="s3">\n          </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n          </span><span class="s1">iconMarkIndex + insertionLength</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">chunk = replaced</span><span class="s3">\n        </span><span class="s1">isMarkRemoved = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createHeadInsertionTransformStream(</span><span class="s3">\n  </span><span class="s1">insert: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let inserted = false</span><span class="s3">\n\n  </span><span class="s1">// We need to track if this transform saw any bytes because if it didn't</span><span class="s3">\n  </span><span class="s1">// we won't want to insert any server HTML at all</span><span class="s3">\n  </span><span class="s1">let hasBytes = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">hasBytes = true</span><span class="s3">\n\n      </span><span class="s1">const insertion = await insert()</span><span class="s3">\n      </span><span class="s1">if (inserted) {</span><span class="s3">\n        </span><span class="s1">if (insertion) {</span><span class="s3">\n          </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n          </span><span class="s1">controller.enqueue(encodedInsertion)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.</span><span class="s3">\n        </span><span class="s1">const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)</span><span class="s3">\n        </span><span class="s1">// In fully static rendering or non PPR rendering cases:</span><span class="s3">\n        </span><span class="s1">// `/head&gt;` will always be found in the chunk in first chunk rendering.</span><span class="s3">\n        </span><span class="s1">if (index !== -1) {</span><span class="s3">\n          </span><span class="s1">if (insertion) {</span><span class="s3">\n            </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n            </span><span class="s1">// Get the total count of the bytes in the chunk and the insertion</span><span class="s3">\n            </span><span class="s1">// e.g.</span><span class="s3">\n            </span><span class="s1">// chunk = &lt;head&gt;&lt;meta charset=</span><span class="s3">\&quot;</span><span class="s1">utf-8</span><span class="s3">\&quot;</span><span class="s1">&gt;&lt;/head&gt;</span><span class="s3">\n            </span><span class="s1">// insertion = &lt;script&gt;...&lt;/script&gt;</span><span class="s3">\n            </span><span class="s1">// output = &lt;head&gt;&lt;meta charset=</span><span class="s3">\&quot;</span><span class="s1">utf-8</span><span class="s3">\&quot;</span><span class="s1">&gt; [ &lt;script&gt;...&lt;/script&gt; ] &lt;/head&gt;</span><span class="s3">\n            </span><span class="s1">const insertedHeadContent = new Uint8Array(</span><span class="s3">\n              </span><span class="s1">chunk.length + encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">// Append the first part of the chunk, before the head tag</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(chunk.slice(0, index))</span><span class="s3">\n            </span><span class="s1">// Append the server inserted content</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(encodedInsertion, index)</span><span class="s3">\n            </span><span class="s1">// Append the rest of the chunk</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(</span><span class="s3">\n              </span><span class="s1">chunk.slice(index),</span><span class="s3">\n              </span><span class="s1">index + encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">controller.enqueue(insertedHeadContent)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">inserted = true</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// This will happens in PPR rendering during next start, when the page is partially rendered.</span><span class="s3">\n          </span><span class="s1">// When the page resumes, the head tag will be found in the middle of the chunk.</span><span class="s3">\n          </span><span class="s1">// Where we just need to append the insertion and chunk to the current stream.</span><span class="s3">\n          </span><span class="s1">// e.g.</span><span class="s3">\n          </span><span class="s1">// PPR-static: &lt;head&gt;...&lt;/head&gt;&lt;body&gt; [ resume content ] &lt;/body&gt;</span><span class="s3">\n          </span><span class="s1">// PPR-resume: [ insertion ] [ rest content ]</span><span class="s3">\n          </span><span class="s1">if (insertion) {</span><span class="s3">\n            </span><span class="s1">controller.enqueue(encoder.encode(insertion))</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">inserted = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">async flush(controller) {</span><span class="s3">\n      </span><span class="s1">// Check before closing if there's anything remaining to insert.</span><span class="s3">\n      </span><span class="s1">if (hasBytes) {</span><span class="s3">\n        </span><span class="s1">const insertion = await insert()</span><span class="s3">\n        </span><span class="s1">if (insertion) {</span><span class="s3">\n          </span><span class="s1">controller.enqueue(encoder.encode(insertion))</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Suffix after main body content - scripts before &lt;/body&gt;,</span><span class="s3">\n</span><span class="s1">// but wait for the major chunks to be enqueued.</span><span class="s3">\n</span><span class="s1">function createDeferredSuffixStream(</span><span class="s3">\n  </span><span class="s1">suffix: string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let flushed = false</span><span class="s3">\n  </span><span class="s1">let pending: DetachedPromise&lt;void&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const flush = (controller: TransformStreamDefaultController) =&gt; {</span><span class="s3">\n    </span><span class="s1">const detached = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">pending = detached</span><span class="s3">\n\n    </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(encoder.encode(suffix))</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// If an error occurs while enqueuing it can't be due to this</span><span class="s3">\n        </span><span class="s1">// transformers fault. It's likely due to the controller being</span><span class="s3">\n        </span><span class="s1">// errored due to the stream being cancelled.</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">pending = undefined</span><span class="s3">\n        </span><span class="s1">detached.resolve()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n\n      </span><span class="s1">// If we've already flushed, we're done.</span><span class="s3">\n      </span><span class="s1">if (flushed) return</span><span class="s3">\n\n      </span><span class="s1">// Schedule the flush to happen.</span><span class="s3">\n      </span><span class="s1">flushed = true</span><span class="s3">\n      </span><span class="s1">flush(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">if (pending) return pending.promise</span><span class="s3">\n      </span><span class="s1">if (flushed) return</span><span class="s3">\n\n      </span><span class="s1">// Flush now.</span><span class="s3">\n      </span><span class="s1">controller.enqueue(encoder.encode(suffix))</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createFlightDataInjectionTransformStream(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">delayDataUntilFirstHtmlChunk: boolean</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let htmlStreamFinished = false</span><span class="s3">\n\n  </span><span class="s1">let pull: Promise&lt;void&gt; | null = null</span><span class="s3">\n  </span><span class="s1">let donePulling = false</span><span class="s3">\n\n  </span><span class="s1">function startOrContinuePulling(</span><span class="s3">\n    </span><span class="s1">controller: TransformStreamDefaultController</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!pull) {</span><span class="s3">\n      </span><span class="s1">pull = startPulling(controller)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pull</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async function startPulling(controller: TransformStreamDefaultController) {</span><span class="s3">\n    </span><span class="s1">const reader = stream.getReader()</span><span class="s3">\n\n    </span><span class="s1">if (delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n      </span><span class="s1">// NOTE: streaming flush</span><span class="s3">\n      </span><span class="s1">// We are buffering here for the inlined data stream because the</span><span class="s3">\n      </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">shell</span><span class="s3">\&quot; </span><span class="s1">stream might be chunkenized again by the underlying stream</span><span class="s3">\n      </span><span class="s1">// implementation, e.g. with a specific high-water mark. To ensure it's</span><span class="s3">\n      </span><span class="s1">// the safe timing to pipe the data stream, this extra tick is</span><span class="s3">\n      </span><span class="s1">// necessary.</span><span class="s3">\n\n      </span><span class="s1">// We don't start reading until we've left the current Task to ensure</span><span class="s3">\n      </span><span class="s1">// that it's inserted after flushing the shell. Note that this implementation</span><span class="s3">\n      </span><span class="s1">// might get stale if impl details of Fizz change in the future.</span><span class="s3">\n      </span><span class="s1">await atLeastOneTask()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n        </span><span class="s1">if (done) {</span><span class="s3">\n          </span><span class="s1">donePulling = true</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// We want to prioritize HTML over RSC data.</span><span class="s3">\n        </span><span class="s1">// The SSR render is based on the same RSC stream, so when we get a new RSC chunk,</span><span class="s3">\n        </span><span class="s1">// we're likely to produce an HTML chunk as well, so give it a chance to flush first.</span><span class="s3">\n        </span><span class="s1">if (!delayDataUntilFirstHtmlChunk &amp;&amp; !htmlStreamFinished) {</span><span class="s3">\n          </span><span class="s1">await atLeastOneTask()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">controller.enqueue(value)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">controller.error(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">if (!delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n        </span><span class="s1">startOrContinuePulling(controller)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n\n      </span><span class="s1">// Start the streaming if it hasn't already been started yet.</span><span class="s3">\n      </span><span class="s1">if (delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n        </span><span class="s1">startOrContinuePulling(controller)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">htmlStreamFinished = true</span><span class="s3">\n      </span><span class="s1">if (donePulling) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return startOrContinuePulling(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const CLOSE_TAG = '&lt;/body&gt;&lt;/html&gt;'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This transform stream moves the suffix to the end of the stream, so results</span><span class="s3">\n </span><span class="s1">* like `&lt;/body&gt;&lt;/html&gt;&lt;script&gt;...&lt;/script&gt;` will be transformed to</span><span class="s3">\n </span><span class="s1">* `&lt;script&gt;...&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createMoveSuffixStream(): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let foundSuffix = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">if (foundSuffix) {</span><span class="s3">\n        </span><span class="s1">return controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)</span><span class="s3">\n      </span><span class="s1">if (index &gt; -1) {</span><span class="s3">\n        </span><span class="s1">foundSuffix = true</span><span class="s3">\n\n        </span><span class="s1">// If the whole chunk is the suffix, then don't write anything, it will</span><span class="s3">\n        </span><span class="s1">// be written in the flush.</span><span class="s3">\n        </span><span class="s1">if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Write out the part before the suffix.</span><span class="s3">\n        </span><span class="s1">const before = chunk.slice(0, index)</span><span class="s3">\n        </span><span class="s1">controller.enqueue(before)</span><span class="s3">\n\n        </span><span class="s1">// In the case where the suffix is in the middle of the chunk, we need</span><span class="s3">\n        </span><span class="s1">// to split the chunk into two parts.</span><span class="s3">\n        </span><span class="s1">if (chunk.length &gt; ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {</span><span class="s3">\n          </span><span class="s1">// Write out the part after the suffix.</span><span class="s3">\n          </span><span class="s1">const after = chunk.slice(</span><span class="s3">\n            </span><span class="s1">index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">controller.enqueue(after)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">// Even if we didn't find the suffix, the HTML is not valid if we don't</span><span class="s3">\n      </span><span class="s1">// add it, so insert it at the end.</span><span class="s3">\n      </span><span class="s1">controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createStripDocumentClosingTagsTransform(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// We rely on the assumption that chunks will never break across a code unit.</span><span class="s3">\n      </span><span class="s1">// This is reasonable because we currently concat all of React's output from a single</span><span class="s3">\n      </span><span class="s1">// flush into one chunk before streaming it forward which means the chunk will represent</span><span class="s3">\n      </span><span class="s1">// a single coherent utf-8 string. This is not safe to use if we change our streaming to no</span><span class="s3">\n      </span><span class="s1">// longer do this large buffered chunk</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// the entire chunk is the closing tags; return without enqueueing anything.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We assume these tags will go at together at the end of the document and that</span><span class="s3">\n      </span><span class="s1">// they won't appear anywhere else in the document. This is not really a safe assumption</span><span class="s3">\n      </span><span class="s1">// but until we revamp our streaming infra this is a performant way to string the tags</span><span class="s3">\n      </span><span class="s1">chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)</span><span class="s3">\n      </span><span class="s1">chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Checks if the root layout is missing the html or body tags</span><span class="s3">\n </span><span class="s1">* and if so, it will inject a script tag to throw an error in the browser, showing the user</span><span class="s3">\n </span><span class="s1">* the error message in the error overlay.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createRootLayoutValidatorStream(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">let foundHtml = false</span><span class="s3">\n  </span><span class="s1">let foundBody = false</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// Peek into the streamed chunk to see if the tags are present.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!foundHtml &amp;&amp;</span><span class="s3">\n        </span><span class="s1">indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) &gt; -1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">foundHtml = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!foundBody &amp;&amp;</span><span class="s3">\n        </span><span class="s1">indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) &gt; -1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">foundBody = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">const missingTags: ('html' | 'body')[] = []</span><span class="s3">\n      </span><span class="s1">if (!foundHtml) missingTags.push('html')</span><span class="s3">\n      </span><span class="s1">if (!foundBody) missingTags.push('body')</span><span class="s3">\n\n      </span><span class="s1">if (!missingTags.length) return</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(</span><span class="s3">\n        </span><span class="s1">encoder.encode(</span><span class="s3">\n          </span><span class="s1">`&lt;html id=</span><span class="s3">\&quot;</span><span class="s1">__next_error__</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\n            </span><span class="s1">&lt;template</span><span class="s3">\n              </span><span class="s1">data-next-error-message=</span><span class="s3">\&quot;</span><span class="s1">Missing ${missingTags</span><span class="s3">\n                </span><span class="s1">.map((c) =&gt; `&lt;${c}&gt;`)</span><span class="s3">\n                </span><span class="s1">.join(</span><span class="s3">\n                  </span><span class="s1">missingTags.length &gt; 1 ? ' and ' : ''</span><span class="s3">\n                </span><span class="s1">)} tags in the root layout.</span><span class="s3">\\</span><span class="s1">nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags</span><span class="s3">\&quot;\n              </span><span class="s1">data-next-error-digest=</span><span class="s3">\&quot;</span><span class="s1">${MISSING_ROOT_TAGS_ERROR}</span><span class="s3">\&quot;\n              </span><span class="s1">data-next-error-stack=</span><span class="s3">\&quot;\&quot;\n            </span><span class="s1">&gt;&lt;/template&gt;</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function chainTransformers&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">readable: ReadableStream&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">transformers: ReadonlyArray&lt;TransformStream&lt;T, T&gt; | null&gt;</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">let stream = readable</span><span class="s3">\n  </span><span class="s1">for (const transformer of transformers) {</span><span class="s3">\n    </span><span class="s1">if (!transformer) continue</span><span class="s3">\n\n    </span><span class="s1">stream = stream.pipeThrough(transformer)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return stream</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ContinueStreamOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt; | undefined</span><span class="s3">\n  </span><span class="s1">isStaticGeneration: boolean</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">validateRootLayout?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Suffix to inject after the buffered data, but before the close tags.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">suffix?: string | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueFizzStream(</span><span class="s3">\n  </span><span class="s1">renderStream: ReactDOMServerReadableStream,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">suffix,</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">isStaticGeneration,</span><span class="s3">\n    </span><span class="s1">isBuildTimePrerendering,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n    </span><span class="s1">validateRootLayout,</span><span class="s3">\n  </span><span class="s1">}: ContinueStreamOptions</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadableStream&lt;Uint8Array&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">// Suffix itself might contain close tags at the end, so we need to split it.</span><span class="s3">\n  </span><span class="s1">const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null</span><span class="s3">\n\n  </span><span class="s1">// If we're generating static HTML we need to wait for it to resolve before continuing.</span><span class="s3">\n  </span><span class="s1">if (isStaticGeneration) {</span><span class="s3">\n    </span><span class="s1">await renderStream.allReady</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return chainTransformers(renderStream, [</span><span class="s3">\n    </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n    </span><span class="s1">createBufferedTransformStream(),</span><span class="s3">\n\n    </span><span class="s1">// Add build id comment to start of the HTML document (in export mode)</span><span class="s3">\n    </span><span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId),</span><span class="s3">\n\n    </span><span class="s1">// Transform metadata</span><span class="s3">\n    </span><span class="s1">createMetadataTransformStream(getServerInsertedMetadata),</span><span class="s3">\n\n    </span><span class="s1">// Insert suffix content</span><span class="s3">\n    </span><span class="s1">suffixUnclosed != null &amp;&amp; suffixUnclosed.length &gt; 0</span><span class="s3">\n      </span><span class="s1">? createDeferredSuffixStream(suffixUnclosed)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n\n    </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n    </span><span class="s1">inlinedDataStream</span><span class="s3">\n      </span><span class="s1">? createFlightDataInjectionTransformStream(inlinedDataStream, true)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n\n    </span><span class="s1">// Validate the root layout for missing html or body tags</span><span class="s3">\n    </span><span class="s1">validateRootLayout ? createRootLayoutValidatorStream() : null,</span><span class="s3">\n\n    </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n    </span><span class="s1">createMoveSuffixStream(),</span><span class="s3">\n\n    </span><span class="s1">// Special head insertions</span><span class="s3">\n    </span><span class="s1">// TODO-APP: Insert server side html to end of head in app layout rendering, to avoid</span><span class="s3">\n    </span><span class="s1">// hydration errors. Remove this once it's ready to be handled by react itself.</span><span class="s3">\n    </span><span class="s1">createHeadInsertionTransformStream(getServerInsertedHTML),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueDynamicPrerenderOptions = {</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueDynamicPrerender(</span><span class="s3">\n  </span><span class="s1">prerenderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n  </span><span class="s1">}: ContinueDynamicPrerenderOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prerenderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createStripDocumentClosingTagsTransform())</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueStaticPrerenderOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueStaticPrerender(</span><span class="s3">\n  </span><span class="s1">prerenderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n    </span><span class="s1">isBuildTimePrerendering,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n  </span><span class="s1">}: ContinueStaticPrerenderOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prerenderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">// Add build id comment to start of the HTML document (in export mode)</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n      </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createFlightDataInjectionTransformStream(inlinedDataStream, true)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMoveSuffixStream())</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueResumeOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">delayDataUntilFirstHtmlChunk: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueDynamicHTMLResume(</span><span class="s3">\n  </span><span class="s1">renderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">delayDataUntilFirstHtmlChunk,</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n  </span><span class="s1">}: ContinueResumeOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">renderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n      </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createFlightDataInjectionTransformStream(</span><span class="s3">\n          </span><span class="s1">inlinedDataStream,</span><span class="s3">\n          </span><span class="s1">delayDataUntilFirstHtmlChunk</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMoveSuffixStream())</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createDocumentClosingStream(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return streamFromString(CLOSE_TAG)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const ENCODED_TAGS = {</span><span class="s3">\n  </span><span class="s1">// opening tags do not have the closing `&gt;` since they can contain other attributes such as `&lt;body className=''&gt;`</span><span class="s3">\n  </span><span class="s1">OPENING: {</span><span class="s3">\n    </span><span class="s1">// &lt;html</span><span class="s3">\n    </span><span class="s1">HTML: new Uint8Array([60, 104, 116, 109, 108]),</span><span class="s3">\n    </span><span class="s1">// &lt;body</span><span class="s3">\n    </span><span class="s1">BODY: new Uint8Array([60, 98, 111, 100, 121]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">CLOSED: {</span><span class="s3">\n    </span><span class="s1">// &lt;/head&gt;</span><span class="s3">\n    </span><span class="s1">HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/body&gt;</span><span class="s3">\n    </span><span class="s1">BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/html&gt;</span><span class="s3">\n    </span><span class="s1">HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/body&gt;&lt;/html&gt;</span><span class="s3">\n    </span><span class="s1">BODY_AND_HTML: new Uint8Array([</span><span class="s3">\n      </span><span class="s1">60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">META: {</span><span class="s3">\n    </span><span class="s1">// Only the match the prefix cause the suffix can be different wether it's xml compatible or not </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">/&gt;</span><span class="s3">\&quot;\n    </span><span class="s1">// &lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">nxt-icon</span><span class="s3">\&quot;\n    </span><span class="s1">// This is a special mark that will be replaced by the icon insertion script tag.</span><span class="s3">\n    </span><span class="s1">ICON_MARK: new Uint8Array([</span><span class="s3">\n      </span><span class="s1">60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,</span><span class="s3">\n      </span><span class="s1">116, 45, 105, 99, 111, 110, 194, 187, 34,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Node.js IncomingHttpHeaders object to a Headers object. Any</span><span class="s3">\n </span><span class="s1">* headers with multiple values will be joined with a comma and space. Any</span><span class="s3">\n </span><span class="s1">* headers that have an undefined value will be ignored and others will be</span><span class="s3">\n </span><span class="s1">* coerced to strings.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param nodeHeaders the headers object to convert</span><span class="s3">\n </span><span class="s1">* @returns the converted headers object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function fromNodeOutgoingHttpHeaders(</span><span class="s3">\n  </span><span class="s1">nodeHeaders: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">): Headers {</span><span class="s3">\n  </span><span class="s1">const headers = new Headers()</span><span class="s3">\n  </span><span class="s1">for (let [key, value] of Object.entries(nodeHeaders)) {</span><span class="s3">\n    </span><span class="s1">const values = Array.isArray(value) ? value : [value]</span><span class="s3">\n    </span><span class="s1">for (let v of values) {</span><span class="s3">\n      </span><span class="s1">if (typeof v === 'undefined') continue</span><span class="s3">\n      </span><span class="s1">if (typeof v === 'number') {</span><span class="s3">\n        </span><span class="s1">v = v.toString()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">headers.append(key, v)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return headers</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n  </span><span class="s1">Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas</span><span class="s3">\n  </span><span class="s1">that are within a single set-cookie field-value, such as in the Expires portion.</span><span class="s3">\n  </span><span class="s1">This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2</span><span class="s3">\n  </span><span class="s1">Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128</span><span class="s3">\n  </span><span class="s1">React Native's fetch does this for *every* header, including set-cookie.</span><span class="s3">\n  \n  </span><span class="s1">Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25</span><span class="s3">\n  </span><span class="s1">Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function splitCookiesString(cookiesString: string) {</span><span class="s3">\n  </span><span class="s1">var cookiesStrings = []</span><span class="s3">\n  </span><span class="s1">var pos = 0</span><span class="s3">\n  </span><span class="s1">var start</span><span class="s3">\n  </span><span class="s1">var ch</span><span class="s3">\n  </span><span class="s1">var lastComma</span><span class="s3">\n  </span><span class="s1">var nextStart</span><span class="s3">\n  </span><span class="s1">var cookiesSeparatorFound</span><span class="s3">\n\n  </span><span class="s1">function skipWhitespace() {</span><span class="s3">\n    </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(cookiesString.charAt(pos))) {</span><span class="s3">\n      </span><span class="s1">pos += 1</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos &lt; cookiesString.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function notSpecialChar() {</span><span class="s3">\n    </span><span class="s1">ch = cookiesString.charAt(pos)</span><span class="s3">\n\n    </span><span class="s1">return ch !== '=' &amp;&amp; ch !== ';' &amp;&amp; ch !== ','</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (pos &lt; cookiesString.length) {</span><span class="s3">\n    </span><span class="s1">start = pos</span><span class="s3">\n    </span><span class="s1">cookiesSeparatorFound = false</span><span class="s3">\n\n    </span><span class="s1">while (skipWhitespace()) {</span><span class="s3">\n      </span><span class="s1">ch = cookiesString.charAt(pos)</span><span class="s3">\n      </span><span class="s1">if (ch === ',') {</span><span class="s3">\n        </span><span class="s1">// ',' is a cookie separator if we have later first '=', not ';' or ','</span><span class="s3">\n        </span><span class="s1">lastComma = pos</span><span class="s3">\n        </span><span class="s1">pos += 1</span><span class="s3">\n\n        </span><span class="s1">skipWhitespace()</span><span class="s3">\n        </span><span class="s1">nextStart = pos</span><span class="s3">\n\n        </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; notSpecialChar()) {</span><span class="s3">\n          </span><span class="s1">pos += 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// currently special character</span><span class="s3">\n        </span><span class="s1">if (pos &lt; cookiesString.length &amp;&amp; cookiesString.charAt(pos) === '=') {</span><span class="s3">\n          </span><span class="s1">// we found cookies separator</span><span class="s3">\n          </span><span class="s1">cookiesSeparatorFound = true</span><span class="s3">\n          </span><span class="s1">// pos is inside the next cookie, so back up and return it.</span><span class="s3">\n          </span><span class="s1">pos = nextStart</span><span class="s3">\n          </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, lastComma))</span><span class="s3">\n          </span><span class="s1">start = pos</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// in param ',' or param separator ';',</span><span class="s3">\n          </span><span class="s1">// we continue from that comma</span><span class="s3">\n          </span><span class="s1">pos = lastComma + 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pos += 1</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!cookiesSeparatorFound || pos &gt;= cookiesString.length) {</span><span class="s3">\n      </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, cookiesString.length))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return cookiesStrings</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Headers object to a Node.js OutgoingHttpHeaders object. This is</span><span class="s3">\n </span><span class="s1">* required to support the set-cookie header, which may have multiple values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param headers the headers object to convert</span><span class="s3">\n </span><span class="s1">* @returns the converted headers object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function toNodeOutgoingHttpHeaders(</span><span class="s3">\n  </span><span class="s1">headers: Headers</span><span class="s3">\n</span><span class="s1">): OutgoingHttpHeaders {</span><span class="s3">\n  </span><span class="s1">const nodeHeaders: OutgoingHttpHeaders = {}</span><span class="s3">\n  </span><span class="s1">const cookies: string[] = []</span><span class="s3">\n  </span><span class="s1">if (headers) {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of headers.entries()) {</span><span class="s3">\n      </span><span class="s1">if (key.toLowerCase() === 'set-cookie') {</span><span class="s3">\n        </span><span class="s1">// We may have gotten a comma joined string of cookies, or multiple</span><span class="s3">\n        </span><span class="s1">// set-cookie headers. We need to merge them into one header array</span><span class="s3">\n        </span><span class="s1">// to represent all the cookies.</span><span class="s3">\n        </span><span class="s1">cookies.push(...splitCookiesString(value))</span><span class="s3">\n        </span><span class="s1">nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">nodeHeaders[key] = value</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return nodeHeaders</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Validate the correctness of a user-provided URL.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function validateURL(url: string | URL): string {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return String(new URL(String(url)))</span><span class="s3">\n  </span><span class="s1">} catch (error: any) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`URL is malformed </span><span class="s3">\&quot;</span><span class="s1">${String(</span><span class="s3">\n        </span><span class="s1">url</span><span class="s3">\n      </span><span class="s1">)}</span><span class="s3">\&quot;</span><span class="s1">. Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`,</span><span class="s3">\n      </span><span class="s1">{ cause: error }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes `nxtP` and `nxtI` query param values to remove the prefix.</span><span class="s3">\n </span><span class="s1">* This function does not mutate the input key.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeNextQueryParam(key: string): null | string {</span><span class="s3">\n  </span><span class="s1">const prefixes = [NEXT_QUERY_PARAM_PREFIX, NEXT_INTERCEPTION_MARKER_PREFIX]</span><span class="s3">\n  </span><span class="s1">for (const prefix of prefixes) {</span><span class="s3">\n    </span><span class="s1">if (key !== prefix &amp;&amp; key.startsWith(prefix)) {</span><span class="s3">\n      </span><span class="s1">return key.substring(prefix.length)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Removes the trailing slash for a given route or page path. Preserves the</span><span class="s3">\n </span><span class="s1">* root page. Examples:</span><span class="s3">\n </span><span class="s1">*   - `/foo/bar/` -&gt; `/foo/bar`</span><span class="s3">\n </span><span class="s1">*   - `/foo/bar` -&gt; `/foo/bar`</span><span class="s3">\n </span><span class="s1">*   - `/` -&gt; `/`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removeTrailingSlash(route: string) {</span><span class="s3">\n  </span><span class="s1">return route.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '') || '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Given a path this function will find the pathname, query and hash and return</span><span class="s3">\n </span><span class="s1">* them. This is useful to parse full paths on the client side.</span><span class="s3">\n </span><span class="s1">* @param path A path to parse e.g. /foo/bar?id=1#hash</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parsePath(path: string) {</span><span class="s3">\n  </span><span class="s1">const hashIndex = path.indexOf('#')</span><span class="s3">\n  </span><span class="s1">const queryIndex = path.indexOf('?')</span><span class="s3">\n  </span><span class="s1">const hasQuery = queryIndex &gt; -1 &amp;&amp; (hashIndex &lt; 0 || queryIndex &lt; hashIndex)</span><span class="s3">\n\n  </span><span class="s1">if (hasQuery || hashIndex &gt; -1) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),</span><span class="s3">\n      </span><span class="s1">query: hasQuery</span><span class="s3">\n        </span><span class="s1">? path.substring(queryIndex, hashIndex &gt; -1 ? hashIndex : undefined)</span><span class="s3">\n        </span><span class="s1">: '',</span><span class="s3">\n      </span><span class="s1">hash: hashIndex &gt; -1 ? path.slice(hashIndex) : '',</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { pathname: path, query: '', hash: '' }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds the provided prefix to the given path. It first ensures that the path</span><span class="s3">\n </span><span class="s1">* is indeed starting with a slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addPathPrefix(path: string, prefix?: string) {</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/') || !prefix) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname, query, hash } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return `${prefix}${pathname}${query}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Similarly to `addPathPrefix`, this function adds a suffix at the end on the</span><span class="s3">\n </span><span class="s1">* provided path. It also works only for paths ensuring the argument starts</span><span class="s3">\n </span><span class="s1">* with a slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addPathSuffix(path: string, suffix?: string) {</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/') || !suffix) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname, query, hash } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return `${pathname}${suffix}${query}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a given path starts with a given prefix. It ensures it matches</span><span class="s3">\n </span><span class="s1">* exactly without containing extra chars. e.g. prefix /docs should replace</span><span class="s3">\n </span><span class="s1">* for /docs, /docs/, /docs/a but not /docsss</span><span class="s3">\n </span><span class="s1">* @param path The path to check.</span><span class="s3">\n </span><span class="s1">* @param prefix The prefix to check against.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function pathHasPrefix(path: string, prefix: string) {</span><span class="s3">\n  </span><span class="s1">if (typeof path !== 'string') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return pathname === prefix || pathname.startsWith(prefix + '/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes an object with a hostname property (like a parsed URL) and some</span><span class="s3">\n </span><span class="s1">* headers that may contain Host and returns the preferred hostname.</span><span class="s3">\n </span><span class="s1">* @param parsed An object containing a hostname property.</span><span class="s3">\n </span><span class="s1">* @param headers A dictionary with headers containing a `host`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getHostname(</span><span class="s3">\n  </span><span class="s1">parsed: { hostname?: string | null },</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">// Get the hostname from the headers if it exists, otherwise use the parsed</span><span class="s3">\n  </span><span class="s1">// hostname.</span><span class="s3">\n  </span><span class="s1">let hostname: string</span><span class="s3">\n  </span><span class="s1">if (headers?.host &amp;&amp; !Array.isArray(headers.host)) {</span><span class="s3">\n    </span><span class="s1">hostname = headers.host.toString().split(':', 1)[0]</span><span class="s3">\n  </span><span class="s1">} else if (parsed.hostname) {</span><span class="s3">\n    </span><span class="s1">hostname = parsed.hostname</span><span class="s3">\n  </span><span class="s1">} else return</span><span class="s3">\n\n  </span><span class="s1">return hostname.toLowerCase()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export interface PathLocale {</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache of lowercased locales for each list of locales. This is stored as a</span><span class="s3">\n </span><span class="s1">* WeakMap so if the locales are garbage collected, the cache entry will be</span><span class="s3">\n </span><span class="s1">* removed as well.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cache = new WeakMap&lt;readonly string[], readonly string[]&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* For a pathname that may include a locale from a list of locales, it</span><span class="s3">\n </span><span class="s1">* removes the locale from the pathname returning it alongside with the</span><span class="s3">\n </span><span class="s1">* detected locale.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pathname A pathname that may include a locale.</span><span class="s3">\n </span><span class="s1">* @param locales A list of locales.</span><span class="s3">\n </span><span class="s1">* @returns The detected locale and pathname without locale</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeLocalePath(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n</span><span class="s1">): PathLocale {</span><span class="s3">\n  </span><span class="s1">// If locales is undefined, return the pathname as is.</span><span class="s3">\n  </span><span class="s1">if (!locales) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// Get the cached lowercased locales or create a new cache entry.</span><span class="s3">\n  </span><span class="s1">let lowercasedLocales = cache.get(locales)</span><span class="s3">\n  </span><span class="s1">if (!lowercasedLocales) {</span><span class="s3">\n    </span><span class="s1">lowercasedLocales = locales.map((locale) =&gt; locale.toLowerCase())</span><span class="s3">\n    </span><span class="s1">cache.set(locales, lowercasedLocales)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let detectedLocale: string | undefined</span><span class="s3">\n\n  </span><span class="s1">// The first segment will be empty, because it has a leading `/`. If</span><span class="s3">\n  </span><span class="s1">// there is no further segment, there is no locale (or it's the default).</span><span class="s3">\n  </span><span class="s1">const segments = pathname.split('/', 2)</span><span class="s3">\n\n  </span><span class="s1">// If there's no second segment (ie, the pathname is just `/`), there's no</span><span class="s3">\n  </span><span class="s1">// locale.</span><span class="s3">\n  </span><span class="s1">if (!segments[1]) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// The second segment will contain the locale part if any.</span><span class="s3">\n  </span><span class="s1">const segment = segments[1].toLowerCase()</span><span class="s3">\n\n  </span><span class="s1">// See if the segment matches one of the locales. If it doesn't, there is</span><span class="s3">\n  </span><span class="s1">// no locale (or it's the default).</span><span class="s3">\n  </span><span class="s1">const index = lowercasedLocales.indexOf(segment)</span><span class="s3">\n  </span><span class="s1">if (index &lt; 0) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// Return the case-sensitive locale.</span><span class="s3">\n  </span><span class="s1">detectedLocale = locales[index]</span><span class="s3">\n\n  </span><span class="s1">// Remove the `/${locale}` part of the pathname.</span><span class="s3">\n  </span><span class="s1">pathname = pathname.slice(detectedLocale.length + 1) || '/'</span><span class="s3">\n\n  </span><span class="s1">return { pathname, detectedLocale }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a path and a prefix it will remove the prefix when it exists in the</span><span class="s3">\n </span><span class="s1">* given path. It ensures it matches exactly without containing extra chars</span><span class="s3">\n </span><span class="s1">* and if the prefix is not there it will be noop.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param path The path to remove the prefix from.</span><span class="s3">\n </span><span class="s1">* @param prefix The prefix to be removed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removePathPrefix(path: string, prefix: string): string {</span><span class="s3">\n  </span><span class="s1">// If the path doesn't start with the prefix we can return it as is. This</span><span class="s3">\n  </span><span class="s1">// protects us from situations where the prefix is a substring of the path</span><span class="s3">\n  </span><span class="s1">// prefix such as:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// For prefix: /blog</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   /blog -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blog/ -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blog/1 -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blogging -&gt; false</span><span class="s3">\n  </span><span class="s1">//   /blogging/ -&gt; false</span><span class="s3">\n  </span><span class="s1">//   /blogging/1 -&gt; false</span><span class="s3">\n  </span><span class="s1">if (!pathHasPrefix(path, prefix)) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Remove the prefix from the path via slicing.</span><span class="s3">\n  </span><span class="s1">const withoutPrefix = path.slice(prefix.length)</span><span class="s3">\n\n  </span><span class="s1">// If the path without the prefix starts with a `/` we can return it as is.</span><span class="s3">\n  </span><span class="s1">if (withoutPrefix.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">return withoutPrefix</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If the path without the prefix doesn't start with a `/` we need to add it</span><span class="s3">\n  </span><span class="s1">// back to the path to make sure it's a valid path.</span><span class="s3">\n  </span><span class="s1">return `/${withoutPrefix}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizeLocalePath } from '../../i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from './remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../../../../server/lib/i18n-provider'</span><span class="s3">\n\n</span><span class="s1">export interface NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The base path in case the pathname included it.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">basePath?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The buildId for when the parsed URL is a data URL. Parsing it can be</span><span class="s3">\n   </span><span class="s1">* disabled with the `parseData` option.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">buildId?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If there was a locale in the pathname, this will hold its value.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The processed pathname without a base path, locale, or data URL elements</span><span class="s3">\n   </span><span class="s1">* when parsing it is enabled.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A boolean telling if the pathname had a trailingSlash. This can be only</span><span class="s3">\n   </span><span class="s1">* true if trailingSlash is enabled.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When passed to true, this function will also parse Nextjs data URLs.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">parseData?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A partial of the Next.js configuration to parse the URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: { locales?: readonly string[] } | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If provided, this normalizer will be used to detect the locale instead of</span><span class="s3">\n   </span><span class="s1">* the default locale detection.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">i18nProvider?: I18NProvider</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getNextPathnameInfo(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">options: Options</span><span class="s3">\n</span><span class="s1">): NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">const { basePath, i18n, trailingSlash } = options.nextConfig ?? {}</span><span class="s3">\n  </span><span class="s1">const info: NextPathnameInfo = {</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (basePath &amp;&amp; pathHasPrefix(info.pathname, basePath)) {</span><span class="s3">\n    </span><span class="s1">info.pathname = removePathPrefix(info.pathname, basePath)</span><span class="s3">\n    </span><span class="s1">info.basePath = basePath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let pathnameNoDataPrefix = info.pathname</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">info.pathname.startsWith('/_next/data/') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">info.pathname.endsWith('.json')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const paths = info.pathname</span><span class="s3">\n      </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">/data</span><span class="s3">\\</span><span class="s1">//, '')</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">.json$/, '')</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n\n    </span><span class="s1">const buildId = paths[0]</span><span class="s3">\n    </span><span class="s1">info.buildId = buildId</span><span class="s3">\n    </span><span class="s1">pathnameNoDataPrefix =</span><span class="s3">\n      </span><span class="s1">paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/'</span><span class="s3">\n\n    </span><span class="s1">// update pathname with normalized if enabled although</span><span class="s3">\n    </span><span class="s1">// we use normalized to populate locale info still</span><span class="s3">\n    </span><span class="s1">if (options.parseData === true) {</span><span class="s3">\n      </span><span class="s1">info.pathname = pathnameNoDataPrefix</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If provided, use the locale route normalizer to detect the locale instead</span><span class="s3">\n  </span><span class="s1">// of the function below.</span><span class="s3">\n  </span><span class="s1">if (i18n) {</span><span class="s3">\n    </span><span class="s1">let result = options.i18nProvider</span><span class="s3">\n      </span><span class="s1">? options.i18nProvider.analyze(info.pathname)</span><span class="s3">\n      </span><span class="s1">: normalizeLocalePath(info.pathname, i18n.locales)</span><span class="s3">\n\n    </span><span class="s1">info.locale = result.detectedLocale</span><span class="s3">\n    </span><span class="s1">info.pathname = result.pathname ?? info.pathname</span><span class="s3">\n\n    </span><span class="s1">if (!result.detectedLocale &amp;&amp; info.buildId) {</span><span class="s3">\n      </span><span class="s1">result = options.i18nProvider</span><span class="s3">\n        </span><span class="s1">? options.i18nProvider.analyze(pathnameNoDataPrefix)</span><span class="s3">\n        </span><span class="s1">: normalizeLocalePath(pathnameNoDataPrefix, i18n.locales)</span><span class="s3">\n\n      </span><span class="s1">if (result.detectedLocale) {</span><span class="s3">\n        </span><span class="s1">info.locale = result.detectedLocale</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return info</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type { DomainLocale, I18NConfig } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../lib/i18n-provider'</span><span class="s3">\n\n</span><span class="s1">import { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale'</span><span class="s3">\n</span><span class="s1">import { formatNextPathnameInfo } from '../../shared/lib/router/utils/format-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import { getNextPathnameInfo } from '../../shared/lib/router/utils/get-next-pathname-info'</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">base?: string | URL</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">forceLocale?: boolean</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: I18NConfig | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">i18nProvider?: I18NProvider</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const REGEX_LOCALHOST_HOSTNAME =</span><span class="s3">\n  </span><span class="s1">/(?!^https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/)(127(?:</span><span class="s3">\\</span><span class="s1">.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|</span><span class="s3">\\</span><span class="s1">[::1</span><span class="s3">\\</span><span class="s1">]|localhost)/</span><span class="s3">\n\n</span><span class="s1">function parseURL(url: string | URL, base?: string | URL) {</span><span class="s3">\n  </span><span class="s1">return new URL(</span><span class="s3">\n    </span><span class="s1">String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'),</span><span class="s3">\n    </span><span class="s1">base &amp;&amp; String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const Internal = Symbol('NextURLInternal')</span><span class="s3">\n\n</span><span class="s1">export class NextURL {</span><span class="s3">\n  </span><span class="s1">private [Internal]: {</span><span class="s3">\n    </span><span class="s1">basePath: string</span><span class="s3">\n    </span><span class="s1">buildId?: string</span><span class="s3">\n    </span><span class="s1">flightSearchParameters?: Record&lt;string, string&gt;</span><span class="s3">\n    </span><span class="s1">defaultLocale?: string</span><span class="s3">\n    </span><span class="s1">domainLocale?: DomainLocale</span><span class="s3">\n    </span><span class="s1">locale?: string</span><span class="s3">\n    </span><span class="s1">options: Options</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n    </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(input: string | URL, base?: string | URL, opts?: Options)</span><span class="s3">\n  </span><span class="s1">constructor(input: string | URL, opts?: Options)</span><span class="s3">\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">input: string | URL,</span><span class="s3">\n    </span><span class="s1">baseOrOpts?: string | URL | Options,</span><span class="s3">\n    </span><span class="s1">opts?: Options</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let base: undefined | string | URL</span><span class="s3">\n    </span><span class="s1">let options: Options</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(typeof baseOrOpts === 'object' &amp;&amp; 'pathname' in baseOrOpts) ||</span><span class="s3">\n      </span><span class="s1">typeof baseOrOpts === 'string'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">base = baseOrOpts</span><span class="s3">\n      </span><span class="s1">options = opts || {}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">options = opts || baseOrOpts || {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[Internal] = {</span><span class="s3">\n      </span><span class="s1">url: parseURL(input, base ?? options.base),</span><span class="s3">\n      </span><span class="s1">options: options,</span><span class="s3">\n      </span><span class="s1">basePath: '',</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.analyze()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private analyze() {</span><span class="s3">\n    </span><span class="s1">const info = getNextPathnameInfo(this[Internal].url.pathname, {</span><span class="s3">\n      </span><span class="s1">nextConfig: this[Internal].options.nextConfig,</span><span class="s3">\n      </span><span class="s1">parseData: !process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE,</span><span class="s3">\n      </span><span class="s1">i18nProvider: this[Internal].options.i18nProvider,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const hostname = getHostname(</span><span class="s3">\n      </span><span class="s1">this[Internal].url,</span><span class="s3">\n      </span><span class="s1">this[Internal].options.headers</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this[Internal].domainLocale = this[Internal].options.i18nProvider</span><span class="s3">\n      </span><span class="s1">? this[Internal].options.i18nProvider.detectDomainLocale(hostname)</span><span class="s3">\n      </span><span class="s1">: detectDomainLocale(</span><span class="s3">\n          </span><span class="s1">this[Internal].options.nextConfig?.i18n?.domains,</span><span class="s3">\n          </span><span class="s1">hostname</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const defaultLocale =</span><span class="s3">\n      </span><span class="s1">this[Internal].domainLocale?.defaultLocale ||</span><span class="s3">\n      </span><span class="s1">this[Internal].options.nextConfig?.i18n?.defaultLocale</span><span class="s3">\n\n    </span><span class="s1">this[Internal].url.pathname = info.pathname</span><span class="s3">\n    </span><span class="s1">this[Internal].defaultLocale = defaultLocale</span><span class="s3">\n    </span><span class="s1">this[Internal].basePath = info.basePath ?? ''</span><span class="s3">\n    </span><span class="s1">this[Internal].buildId = info.buildId</span><span class="s3">\n    </span><span class="s1">this[Internal].locale = info.locale ?? defaultLocale</span><span class="s3">\n    </span><span class="s1">this[Internal].trailingSlash = info.trailingSlash</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private formatPathname() {</span><span class="s3">\n    </span><span class="s1">return formatNextPathnameInfo({</span><span class="s3">\n      </span><span class="s1">basePath: this[Internal].basePath,</span><span class="s3">\n      </span><span class="s1">buildId: this[Internal].buildId,</span><span class="s3">\n      </span><span class="s1">defaultLocale: !this[Internal].options.forceLocale</span><span class="s3">\n        </span><span class="s1">? this[Internal].defaultLocale</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">locale: this[Internal].locale,</span><span class="s3">\n      </span><span class="s1">pathname: this[Internal].url.pathname,</span><span class="s3">\n      </span><span class="s1">trailingSlash: this[Internal].trailingSlash,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private formatSearch() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get buildId() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].buildId</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set buildId(buildId: string | undefined) {</span><span class="s3">\n    </span><span class="s1">this[Internal].buildId = buildId</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get locale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].locale ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set locale(locale: string) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this[Internal].locale ||</span><span class="s3">\n      </span><span class="s1">!this[Internal].options.nextConfig?.i18n?.locales.includes(locale)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(</span><span class="s3">\n        </span><span class="s1">`The NextURL configuration includes no locale </span><span class="s3">\&quot;</span><span class="s1">${locale}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[Internal].locale = locale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get defaultLocale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].defaultLocale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get domainLocale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].domainLocale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get searchParams() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.searchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get host() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.host</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set host(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.host = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get hostname() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.hostname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set hostname(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.hostname = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get port() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.port</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set port(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.port = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get protocol() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.protocol</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set protocol(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.protocol = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get href() {</span><span class="s3">\n    </span><span class="s1">const pathname = this.formatPathname()</span><span class="s3">\n    </span><span class="s1">const search = this.formatSearch()</span><span class="s3">\n    </span><span class="s1">return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set href(url: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url = parseURL(url)</span><span class="s3">\n    </span><span class="s1">this.analyze()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get origin() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.origin</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get pathname() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set pathname(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.pathname = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get hash() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.hash</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set hash(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.hash = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get search() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set search(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.search = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get password() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.password</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set password(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.password = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get username() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.username</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set username(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.username = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get basePath() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].basePath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set basePath(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].basePath = value.startsWith('/') ? value : `/${value}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return this.href</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toJSON() {</span><span class="s3">\n    </span><span class="s1">return this.href</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.for('edge-runtime.inspect.custom')]() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">href: this.href,</span><span class="s3">\n      </span><span class="s1">origin: this.origin,</span><span class="s3">\n      </span><span class="s1">protocol: this.protocol,</span><span class="s3">\n      </span><span class="s1">username: this.username,</span><span class="s3">\n      </span><span class="s1">password: this.password,</span><span class="s3">\n      </span><span class="s1">host: this.host,</span><span class="s3">\n      </span><span class="s1">hostname: this.hostname,</span><span class="s3">\n      </span><span class="s1">port: this.port,</span><span class="s3">\n      </span><span class="s1">pathname: this.pathname,</span><span class="s3">\n      </span><span class="s1">search: this.search,</span><span class="s3">\n      </span><span class="s1">searchParams: this.searchParams,</span><span class="s3">\n      </span><span class="s1">hash: this.hash,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">clone() {</span><span class="s3">\n    </span><span class="s1">return new NextURL(String(this), this[Internal].options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { DomainLocale } from '../../../server/config-shared'</span><span class="s3">\n\n</span><span class="s1">export function detectDomainLocale(</span><span class="s3">\n  </span><span class="s1">domainItems?: readonly DomainLocale[],</span><span class="s3">\n  </span><span class="s1">hostname?: string,</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!domainItems) return</span><span class="s3">\n\n  </span><span class="s1">if (detectedLocale) {</span><span class="s3">\n    </span><span class="s1">detectedLocale = detectedLocale.toLowerCase()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const item of domainItems) {</span><span class="s3">\n    </span><span class="s1">// remove port if present</span><span class="s3">\n    </span><span class="s1">const domainHostname = item.domain?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">hostname === domainHostname ||</span><span class="s3">\n      </span><span class="s1">detectedLocale === item.defaultLocale.toLowerCase() ||</span><span class="s3">\n      </span><span class="s1">item.locales?.some((locale) =&gt; locale.toLowerCase() === detectedLocale)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return item</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextPathnameInfo } from './get-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from './remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { addPathPrefix } from './add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { addPathSuffix } from './add-path-suffix'</span><span class="s3">\n</span><span class="s1">import { addLocale } from './add-locale'</span><span class="s3">\n\n</span><span class="s1">interface ExtendedInfo extends NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">ignorePrefix?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function formatNextPathnameInfo(info: ExtendedInfo) {</span><span class="s3">\n  </span><span class="s1">let pathname = addLocale(</span><span class="s3">\n    </span><span class="s1">info.pathname,</span><span class="s3">\n    </span><span class="s1">info.locale,</span><span class="s3">\n    </span><span class="s1">info.buildId ? undefined : info.defaultLocale,</span><span class="s3">\n    </span><span class="s1">info.ignorePrefix</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (info.buildId || !info.trailingSlash) {</span><span class="s3">\n    </span><span class="s1">pathname = removeTrailingSlash(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (info.buildId) {</span><span class="s3">\n    </span><span class="s1">pathname = addPathSuffix(</span><span class="s3">\n      </span><span class="s1">addPathPrefix(pathname, `/_next/data/${info.buildId}`),</span><span class="s3">\n      </span><span class="s1">info.pathname === '/' ? 'index.json' : '.json'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">pathname = addPathPrefix(pathname, info.basePath)</span><span class="s3">\n  </span><span class="s1">return !info.buildId &amp;&amp; info.trailingSlash</span><span class="s3">\n    </span><span class="s1">? !pathname.endsWith('/')</span><span class="s3">\n      </span><span class="s1">? addPathSuffix(pathname, '/')</span><span class="s3">\n      </span><span class="s1">: pathname</span><span class="s3">\n    </span><span class="s1">: removeTrailingSlash(pathname)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { addPathPrefix } from './add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* For a given path and a locale, if the locale is given, it will prefix the</span><span class="s3">\n </span><span class="s1">* locale. The path shouldn't be an API path. If a default locale is given the</span><span class="s3">\n </span><span class="s1">* prefix will be omitted if the locale is already the default locale.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addLocale(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">locale?: string | false,</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string,</span><span class="s3">\n  </span><span class="s1">ignorePrefix?: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// If no locale was given or the locale is the default locale, we don't need</span><span class="s3">\n  </span><span class="s1">// to prefix the path.</span><span class="s3">\n  </span><span class="s1">if (!locale || locale === defaultLocale) return path</span><span class="s3">\n\n  </span><span class="s1">const lower = path.toLowerCase()</span><span class="s3">\n\n  </span><span class="s1">// If the path is an API path or the path already has the locale prefix, we</span><span class="s3">\n  </span><span class="s1">// don't need to prefix the path.</span><span class="s3">\n  </span><span class="s1">if (!ignorePrefix) {</span><span class="s3">\n    </span><span class="s1">if (pathHasPrefix(lower, '/api')) return path</span><span class="s3">\n    </span><span class="s1">if (pathHasPrefix(lower, `/${locale.toLowerCase()}`)) return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Add the locale prefix to the path.</span><span class="s3">\n  </span><span class="s1">return addPathPrefix(path, `/${locale}`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class PageSignatureError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor({ page }: { page: string }) {</span><span class="s3">\n    </span><span class="s1">super(`The middleware </span><span class="s3">\&quot;</span><span class="s1">${page}</span><span class="s3">\&quot; </span><span class="s1">accepts an async API directly with the form:</span><span class="s3">\n  \n  </span><span class="s1">export function middleware(request, event) {</span><span class="s3">\n    </span><span class="s1">return NextResponse.redirect('/new-location')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  \n  </span><span class="s1">Read more: https://nextjs.org/docs/messages/middleware-new-signature</span><span class="s3">\n  </span><span class="s1">`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class RemovedPageError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(`The request.page has been deprecated in favour of </span><span class="s3">\\</span><span class="s1">`URLPattern</span><span class="s3">\\</span><span class="s1">`.</span><span class="s3">\n  </span><span class="s1">Read more: https://nextjs.org/docs/messages/middleware-request-page</span><span class="s3">\n  </span><span class="s1">`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class RemovedUAError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(`The request.ua has been removed in favour of </span><span class="s3">\\</span><span class="s1">`userAgent</span><span class="s3">\\</span><span class="s1">` function.</span><span class="s3">\n  </span><span class="s1">Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent</span><span class="s3">\n  </span><span class="s1">`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { I18NConfig } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import { NextURL } from '../next-url'</span><span class="s3">\n</span><span class="s1">import { toNodeOutgoingHttpHeaders, validateURL } from '../utils'</span><span class="s3">\n</span><span class="s1">import { RemovedUAError, RemovedPageError } from '../error'</span><span class="s3">\n</span><span class="s1">import { RequestCookies } from './cookies'</span><span class="s3">\n\n</span><span class="s1">export const INTERNALS = Symbol('internal request')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This class extends the [Web `Request` API](https://developer.mozilla.org/docs/Web/API/Request) with additional convenience methods.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `NextRequest`](https://nextjs.org/docs/app/api-reference/functions/next-request)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class NextRequest extends Request {</span><span class="s3">\n  </span><span class="s1">/** @internal */</span><span class="s3">\n  </span><span class="s1">[INTERNALS]: {</span><span class="s3">\n    </span><span class="s1">cookies: RequestCookies</span><span class="s3">\n    </span><span class="s1">url: string</span><span class="s3">\n    </span><span class="s1">nextUrl: NextURL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(input: URL | RequestInfo, init: RequestInit = {}) {</span><span class="s3">\n    </span><span class="s1">const url =</span><span class="s3">\n      </span><span class="s1">typeof input !== 'string' &amp;&amp; 'url' in input ? input.url : String(input)</span><span class="s3">\n\n    </span><span class="s1">validateURL(url)</span><span class="s3">\n\n    </span><span class="s1">// node Request instance requires duplex option when a body</span><span class="s3">\n    </span><span class="s1">// is present or it errors, we don't handle this for</span><span class="s3">\n    </span><span class="s1">// Request being passed in since it would have already</span><span class="s3">\n    </span><span class="s1">// errored if this wasn't configured</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">if (init.body &amp;&amp; init.duplex !== 'half') {</span><span class="s3">\n        </span><span class="s1">init.duplex = 'half'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (input instanceof Request) super(input, init)</span><span class="s3">\n    </span><span class="s1">else super(url, init)</span><span class="s3">\n\n    </span><span class="s1">const nextUrl = new NextURL(url, {</span><span class="s3">\n      </span><span class="s1">headers: toNodeOutgoingHttpHeaders(this.headers),</span><span class="s3">\n      </span><span class="s1">nextConfig: init.nextConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">this[INTERNALS] = {</span><span class="s3">\n      </span><span class="s1">cookies: new RequestCookies(this.headers),</span><span class="s3">\n      </span><span class="s1">nextUrl,</span><span class="s3">\n      </span><span class="s1">url: process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE</span><span class="s3">\n        </span><span class="s1">? url</span><span class="s3">\n        </span><span class="s1">: nextUrl.toString(),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.for('edge-runtime.inspect.custom')]() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">cookies: this.cookies,</span><span class="s3">\n      </span><span class="s1">nextUrl: this.nextUrl,</span><span class="s3">\n      </span><span class="s1">url: this.url,</span><span class="s3">\n      </span><span class="s1">// rest of props come from Request</span><span class="s3">\n      </span><span class="s1">bodyUsed: this.bodyUsed,</span><span class="s3">\n      </span><span class="s1">cache: this.cache,</span><span class="s3">\n      </span><span class="s1">credentials: this.credentials,</span><span class="s3">\n      </span><span class="s1">destination: this.destination,</span><span class="s3">\n      </span><span class="s1">headers: Object.fromEntries(this.headers),</span><span class="s3">\n      </span><span class="s1">integrity: this.integrity,</span><span class="s3">\n      </span><span class="s1">keepalive: this.keepalive,</span><span class="s3">\n      </span><span class="s1">method: this.method,</span><span class="s3">\n      </span><span class="s1">mode: this.mode,</span><span class="s3">\n      </span><span class="s1">redirect: this.redirect,</span><span class="s3">\n      </span><span class="s1">referrer: this.referrer,</span><span class="s3">\n      </span><span class="s1">referrerPolicy: this.referrerPolicy,</span><span class="s3">\n      </span><span class="s1">signal: this.signal,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get cookies() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].cookies</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get nextUrl() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">* `page` has been deprecated in favour of `URLPattern`.</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-request-page</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get page() {</span><span class="s3">\n    </span><span class="s1">throw new RemovedPageError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">* `ua` has been removed in favour of </span><span class="s3">\\</span><span class="s1">`userAgent</span><span class="s3">\\</span><span class="s1">` function.</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get ua() {</span><span class="s3">\n    </span><span class="s1">throw new RemovedUAError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get url() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RequestInit extends globalThis.RequestInit {</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: I18NConfig | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n  </span><span class="s1">// see https://github.com/whatwg/fetch/pull/1457</span><span class="s3">\n  </span><span class="s1">duplex?: 'half'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { BaseNextRequest } from '../../../base-http'</span><span class="s3">\n</span><span class="s1">import type { NodeNextRequest } from '../../../base-http/node'</span><span class="s3">\n</span><span class="s1">import type { WebNextRequest } from '../../../base-http/web'</span><span class="s3">\n</span><span class="s1">import type { Writable } from 'node:stream'</span><span class="s3">\n\n</span><span class="s1">import { getRequestMeta } from '../../../request-meta'</span><span class="s3">\n</span><span class="s1">import { fromNodeOutgoingHttpHeaders } from '../../utils'</span><span class="s3">\n</span><span class="s1">import { NextRequest } from '../request'</span><span class="s3">\n</span><span class="s1">import { isNodeNextRequest, isWebNextRequest } from '../../../base-http/helpers'</span><span class="s3">\n\n</span><span class="s1">export const ResponseAbortedName = 'ResponseAborted'</span><span class="s3">\n</span><span class="s1">export class ResponseAborted extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly name = ResponseAbortedName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an AbortController tied to the closing of a ServerResponse (or other</span><span class="s3">\n </span><span class="s1">* appropriate Writable).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the `close` event is fired before the `finish` event, then we'll send the</span><span class="s3">\n </span><span class="s1">* `abort` signal.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createAbortController(response: Writable): AbortController {</span><span class="s3">\n  </span><span class="s1">const controller = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">// If `finish` fires first, then `res.end()` has been called and the close is</span><span class="s3">\n  </span><span class="s1">// just us finishing the stream on our side. If `close` fires first, then we</span><span class="s3">\n  </span><span class="s1">// know the client disconnected before we finished.</span><span class="s3">\n  </span><span class="s1">response.once('close', () =&gt; {</span><span class="s3">\n    </span><span class="s1">if (response.writableFinished) return</span><span class="s3">\n\n    </span><span class="s1">controller.abort(new ResponseAborted())</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return controller</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an AbortSignal tied to the closing of a ServerResponse (or other</span><span class="s3">\n </span><span class="s1">* appropriate Writable).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This cannot be done with the request (IncomingMessage or Readable) because</span><span class="s3">\n </span><span class="s1">* the `abort` event will not fire if to data has been fully read (because that</span><span class="s3">\n </span><span class="s1">* will </span><span class="s3">\&quot;</span><span class="s1">close</span><span class="s3">\&quot; </span><span class="s1">the readable stream and nothing fires after that).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function signalFromNodeResponse(response: Writable): AbortSignal {</span><span class="s3">\n  </span><span class="s1">const { errored, destroyed } = response</span><span class="s3">\n  </span><span class="s1">if (errored || destroyed) {</span><span class="s3">\n    </span><span class="s1">return AbortSignal.abort(errored ?? new ResponseAborted())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { signal } = createAbortController(response)</span><span class="s3">\n  </span><span class="s1">return signal</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class NextRequestAdapter {</span><span class="s3">\n  </span><span class="s1">public static fromBaseNextRequest(</span><span class="s3">\n    </span><span class="s1">request: BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal</span><span class="s3">\n  </span><span class="s1">): NextRequest {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME === 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isWebNextRequest(request)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return NextRequestAdapter.fromWebNextRequest(request)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isNodeNextRequest(request)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return NextRequestAdapter.fromNodeNextRequest(request, signal)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: Unsupported NextRequest type')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static fromNodeNextRequest(</span><span class="s3">\n    </span><span class="s1">request: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal</span><span class="s3">\n  </span><span class="s1">): NextRequest {</span><span class="s3">\n    </span><span class="s1">// HEAD and GET requests can not have a body.</span><span class="s3">\n    </span><span class="s1">let body: BodyInit | null = null</span><span class="s3">\n    </span><span class="s1">if (request.method !== 'GET' &amp;&amp; request.method !== 'HEAD' &amp;&amp; request.body) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error - this is handled by undici, when streams/web land use it instead</span><span class="s3">\n      </span><span class="s1">body = request.body</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let url: URL</span><span class="s3">\n    </span><span class="s1">if (request.url.startsWith('http')) {</span><span class="s3">\n      </span><span class="s1">url = new URL(request.url)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Grab the full URL from the request metadata.</span><span class="s3">\n      </span><span class="s1">const base = getRequestMeta(request, 'initURL')</span><span class="s3">\n      </span><span class="s1">if (!base || !base.startsWith('http')) {</span><span class="s3">\n        </span><span class="s1">// Because the URL construction relies on the fact that the URL provided</span><span class="s3">\n        </span><span class="s1">// is absolute, we need to provide a base URL. We can't use the request</span><span class="s3">\n        </span><span class="s1">// URL because it's relative, so we use a dummy URL instead.</span><span class="s3">\n        </span><span class="s1">url = new URL(request.url, 'http://n')</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">url = new URL(request.url, base)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new NextRequest(url, {</span><span class="s3">\n      </span><span class="s1">method: request.method,</span><span class="s3">\n      </span><span class="s1">headers: fromNodeOutgoingHttpHeaders(request.headers),</span><span class="s3">\n      </span><span class="s1">duplex: 'half',</span><span class="s3">\n      </span><span class="s1">signal,</span><span class="s3">\n      </span><span class="s1">// geo</span><span class="s3">\n      </span><span class="s1">// ip</span><span class="s3">\n      </span><span class="s1">// nextConfig</span><span class="s3">\n\n      </span><span class="s1">// body can not be passed if request was aborted</span><span class="s3">\n      </span><span class="s1">// or we get a Request body was disturbed error</span><span class="s3">\n      </span><span class="s1">...(signal.aborted</span><span class="s3">\n        </span><span class="s1">? {}</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">body,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static fromWebNextRequest(request: WebNextRequest): NextRequest {</span><span class="s3">\n    </span><span class="s1">// HEAD and GET requests can not have a body.</span><span class="s3">\n    </span><span class="s1">let body: ReadableStream | null = null</span><span class="s3">\n    </span><span class="s1">if (request.method !== 'GET' &amp;&amp; request.method !== 'HEAD') {</span><span class="s3">\n      </span><span class="s1">body = request.body</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new NextRequest(request.url, {</span><span class="s3">\n      </span><span class="s1">method: request.method,</span><span class="s3">\n      </span><span class="s1">headers: fromNodeOutgoingHttpHeaders(request.headers),</span><span class="s3">\n      </span><span class="s1">duplex: 'half',</span><span class="s3">\n      </span><span class="s1">signal: request.request.signal,</span><span class="s3">\n      </span><span class="s1">// geo</span><span class="s3">\n      </span><span class="s1">// ip</span><span class="s3">\n      </span><span class="s1">// nextConfig</span><span class="s3">\n\n      </span><span class="s1">// body can not be passed if request was aborted</span><span class="s3">\n      </span><span class="s1">// or we get a Request body was disturbed error</span><span class="s3">\n      </span><span class="s1">...(request.request.signal.aborted</span><span class="s3">\n        </span><span class="s1">? {}</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">body,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A `Promise.withResolvers` implementation that exposes the `resolve` and</span><span class="s3">\n </span><span class="s1">* `reject` functions on a `Promise`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @see https://tc39.es/proposal-promise-with-resolvers/</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class DetachedPromise&lt;T = any&gt; {</span><span class="s3">\n  </span><span class="s1">public readonly resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n  </span><span class="s1">public readonly reject: (reason: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">public readonly promise: Promise&lt;T&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">let resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">let reject: (reason: any) =&gt; void</span><span class="s3">\n\n    </span><span class="s1">// Create the promise and assign the resolvers to the object.</span><span class="s3">\n    </span><span class="s1">this.promise = new Promise&lt;T&gt;((res, rej) =&gt; {</span><span class="s3">\n      </span><span class="s1">resolve = res</span><span class="s3">\n      </span><span class="s1">reject = rej</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// We know that resolvers is defined because the Promise constructor runs</span><span class="s3">\n    </span><span class="s1">// synchronously.</span><span class="s3">\n    </span><span class="s1">this.resolve = resolve!</span><span class="s3">\n    </span><span class="s1">this.reject = reject!</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Contains predefined constants for the trace span name in next/server.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Currently, next/server/tracer is internal implementation only for tracking</span><span class="s3">\n </span><span class="s1">* next.js's implementation only with known span names defined here.</span><span class="s3">\n </span><span class="s1">**/</span><span class="s3">\n\n</span><span class="s1">// eslint typescript has a bug with TS enums</span><span class="s3">\n</span><span class="s1">/* eslint-disable no-shadow */</span><span class="s3">\n\n</span><span class="s1">enum BaseServerSpan {</span><span class="s3">\n  </span><span class="s1">handleRequest = 'BaseServer.handleRequest',</span><span class="s3">\n  </span><span class="s1">run = 'BaseServer.run',</span><span class="s3">\n  </span><span class="s1">pipe = 'BaseServer.pipe',</span><span class="s3">\n  </span><span class="s1">getStaticHTML = 'BaseServer.getStaticHTML',</span><span class="s3">\n  </span><span class="s1">render = 'BaseServer.render',</span><span class="s3">\n  </span><span class="s1">renderToResponseWithComponents = 'BaseServer.renderToResponseWithComponents',</span><span class="s3">\n  </span><span class="s1">renderToResponse = 'BaseServer.renderToResponse',</span><span class="s3">\n  </span><span class="s1">renderToHTML = 'BaseServer.renderToHTML',</span><span class="s3">\n  </span><span class="s1">renderError = 'BaseServer.renderError',</span><span class="s3">\n  </span><span class="s1">renderErrorToResponse = 'BaseServer.renderErrorToResponse',</span><span class="s3">\n  </span><span class="s1">renderErrorToHTML = 'BaseServer.renderErrorToHTML',</span><span class="s3">\n  </span><span class="s1">render404 = 'BaseServer.render404',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum LoadComponentsSpan {</span><span class="s3">\n  </span><span class="s1">loadDefaultErrorComponents = 'LoadComponents.loadDefaultErrorComponents',</span><span class="s3">\n  </span><span class="s1">loadComponents = 'LoadComponents.loadComponents',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NextServerSpan {</span><span class="s3">\n  </span><span class="s1">getRequestHandler = 'NextServer.getRequestHandler',</span><span class="s3">\n  </span><span class="s1">getServer = 'NextServer.getServer',</span><span class="s3">\n  </span><span class="s1">getServerRequestHandler = 'NextServer.getServerRequestHandler',</span><span class="s3">\n  </span><span class="s1">createServer = 'createServer.createServer',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NextNodeServerSpan {</span><span class="s3">\n  </span><span class="s1">compression = 'NextNodeServer.compression',</span><span class="s3">\n  </span><span class="s1">getBuildId = 'NextNodeServer.getBuildId',</span><span class="s3">\n  </span><span class="s1">createComponentTree = 'NextNodeServer.createComponentTree',</span><span class="s3">\n  </span><span class="s1">clientComponentLoading = 'NextNodeServer.clientComponentLoading',</span><span class="s3">\n  </span><span class="s1">getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule',</span><span class="s3">\n  </span><span class="s1">generateStaticRoutes = 'NextNodeServer.generateStaticRoutes',</span><span class="s3">\n  </span><span class="s1">generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes',</span><span class="s3">\n  </span><span class="s1">generatePublicRoutes = 'NextNodeServer.generatePublicRoutes',</span><span class="s3">\n  </span><span class="s1">generateImageRoutes = 'NextNodeServer.generateImageRoutes.route',</span><span class="s3">\n  </span><span class="s1">sendRenderResult = 'NextNodeServer.sendRenderResult',</span><span class="s3">\n  </span><span class="s1">proxyRequest = 'NextNodeServer.proxyRequest',</span><span class="s3">\n  </span><span class="s1">runApi = 'NextNodeServer.runApi',</span><span class="s3">\n  </span><span class="s1">render = 'NextNodeServer.render',</span><span class="s3">\n  </span><span class="s1">renderHTML = 'NextNodeServer.renderHTML',</span><span class="s3">\n  </span><span class="s1">imageOptimizer = 'NextNodeServer.imageOptimizer',</span><span class="s3">\n  </span><span class="s1">getPagePath = 'NextNodeServer.getPagePath',</span><span class="s3">\n  </span><span class="s1">getRoutesManifest = 'NextNodeServer.getRoutesManifest',</span><span class="s3">\n  </span><span class="s1">findPageComponents = 'NextNodeServer.findPageComponents',</span><span class="s3">\n  </span><span class="s1">getFontManifest = 'NextNodeServer.getFontManifest',</span><span class="s3">\n  </span><span class="s1">getServerComponentManifest = 'NextNodeServer.getServerComponentManifest',</span><span class="s3">\n  </span><span class="s1">getRequestHandler = 'NextNodeServer.getRequestHandler',</span><span class="s3">\n  </span><span class="s1">renderToHTML = 'NextNodeServer.renderToHTML',</span><span class="s3">\n  </span><span class="s1">renderError = 'NextNodeServer.renderError',</span><span class="s3">\n  </span><span class="s1">renderErrorToHTML = 'NextNodeServer.renderErrorToHTML',</span><span class="s3">\n  </span><span class="s1">render404 = 'NextNodeServer.render404',</span><span class="s3">\n  </span><span class="s1">startResponse = 'NextNodeServer.startResponse',</span><span class="s3">\n\n  </span><span class="s1">// nested inner span, does not require parent scope name</span><span class="s3">\n  </span><span class="s1">route = 'route',</span><span class="s3">\n  </span><span class="s1">onProxyReq = 'onProxyReq',</span><span class="s3">\n  </span><span class="s1">apiResolver = 'apiResolver',</span><span class="s3">\n  </span><span class="s1">internalFetch = 'internalFetch',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum StartServerSpan {</span><span class="s3">\n  </span><span class="s1">startServer = 'startServer.startServer',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum RenderSpan {</span><span class="s3">\n  </span><span class="s1">getServerSideProps = 'Render.getServerSideProps',</span><span class="s3">\n  </span><span class="s1">getStaticProps = 'Render.getStaticProps',</span><span class="s3">\n  </span><span class="s1">renderToString = 'Render.renderToString',</span><span class="s3">\n  </span><span class="s1">renderDocument = 'Render.renderDocument',</span><span class="s3">\n  </span><span class="s1">createBodyResult = 'Render.createBodyResult',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum AppRenderSpan {</span><span class="s3">\n  </span><span class="s1">renderToString = 'AppRender.renderToString',</span><span class="s3">\n  </span><span class="s1">renderToReadableStream = 'AppRender.renderToReadableStream',</span><span class="s3">\n  </span><span class="s1">getBodyResult = 'AppRender.getBodyResult',</span><span class="s3">\n  </span><span class="s1">fetch = 'AppRender.fetch',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum RouterSpan {</span><span class="s3">\n  </span><span class="s1">executeRoute = 'Router.executeRoute',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NodeSpan {</span><span class="s3">\n  </span><span class="s1">runHandler = 'Node.runHandler',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum AppRouteRouteHandlersSpan {</span><span class="s3">\n  </span><span class="s1">runHandler = 'AppRouteRouteHandlers.runHandler',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum ResolveMetadataSpan {</span><span class="s3">\n  </span><span class="s1">generateMetadata = 'ResolveMetadata.generateMetadata',</span><span class="s3">\n  </span><span class="s1">generateViewport = 'ResolveMetadata.generateViewport',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum MiddlewareSpan {</span><span class="s3">\n  </span><span class="s1">execute = 'Middleware.execute',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SpanTypes =</span><span class="s3">\n  </span><span class="s1">| `${BaseServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${LoadComponentsSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NextServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${StartServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NextNodeServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${RenderSpan}`</span><span class="s3">\n  </span><span class="s1">| `${RouterSpan}`</span><span class="s3">\n  </span><span class="s1">| `${AppRenderSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NodeSpan}`</span><span class="s3">\n  </span><span class="s1">| `${AppRouteRouteHandlersSpan}`</span><span class="s3">\n  </span><span class="s1">| `${ResolveMetadataSpan}`</span><span class="s3">\n  </span><span class="s1">| `${MiddlewareSpan}`</span><span class="s3">\n\n</span><span class="s1">// This list is used to filter out spans that are not relevant to the user</span><span class="s3">\n</span><span class="s1">export const NextVanillaSpanAllowlist = [</span><span class="s3">\n  </span><span class="s1">MiddlewareSpan.execute,</span><span class="s3">\n  </span><span class="s1">BaseServerSpan.handleRequest,</span><span class="s3">\n  </span><span class="s1">RenderSpan.getServerSideProps,</span><span class="s3">\n  </span><span class="s1">RenderSpan.getStaticProps,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan.fetch,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan.getBodyResult,</span><span class="s3">\n  </span><span class="s1">RenderSpan.renderDocument,</span><span class="s3">\n  </span><span class="s1">NodeSpan.runHandler,</span><span class="s3">\n  </span><span class="s1">AppRouteRouteHandlersSpan.runHandler,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan.generateMetadata,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan.generateViewport,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.createComponentTree,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.findPageComponents,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.getLayoutOrPageModule,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.startResponse,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.clientComponentLoading,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">// These Spans are allowed to be always logged</span><span class="s3">\n</span><span class="s1">// when the otel log prefix env is set</span><span class="s3">\n</span><span class="s1">export const LogSpanAllowList = [</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.findPageComponents,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.createComponentTree,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.clientComponentLoading,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">BaseServerSpan,</span><span class="s3">\n  </span><span class="s1">LoadComponentsSpan,</span><span class="s3">\n  </span><span class="s1">NextServerSpan,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan,</span><span class="s3">\n  </span><span class="s1">StartServerSpan,</span><span class="s3">\n  </span><span class="s1">RenderSpan,</span><span class="s3">\n  </span><span class="s1">RouterSpan,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan,</span><span class="s3">\n  </span><span class="s1">NodeSpan,</span><span class="s3">\n  </span><span class="s1">AppRouteRouteHandlersSpan,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan,</span><span class="s3">\n  </span><span class="s1">MiddlewareSpan,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type { SpanTypes }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AppPageModule } from './route-modules/app-page/module'</span><span class="s3">\n\n</span><span class="s1">// Combined load times for loading client components</span><span class="s3">\n</span><span class="s1">let clientComponentLoadStart = 0</span><span class="s3">\n</span><span class="s1">let clientComponentLoadTimes = 0</span><span class="s3">\n</span><span class="s1">let clientComponentLoadCount = 0</span><span class="s3">\n\n</span><span class="s1">export function wrapClientComponentLoader(</span><span class="s3">\n  </span><span class="s1">ComponentMod: AppPageModule</span><span class="s3">\n</span><span class="s1">): AppPageModule['__next_app__'] {</span><span class="s3">\n  </span><span class="s1">if (!('performance' in globalThis)) {</span><span class="s3">\n    </span><span class="s1">return ComponentMod.__next_app__</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">require: (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const startTime = performance.now()</span><span class="s3">\n\n      </span><span class="s1">if (clientComponentLoadStart === 0) {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadStart = startTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadCount += 1</span><span class="s3">\n        </span><span class="s1">return ComponentMod.__next_app__.require(...args)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadTimes += performance.now() - startTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">loadChunk: (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const startTime = performance.now()</span><span class="s3">\n      </span><span class="s1">const result = ComponentMod.__next_app__.loadChunk(...args)</span><span class="s3">\n      </span><span class="s1">// Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.</span><span class="s3">\n      </span><span class="s1">// We only need to know when it's settled.</span><span class="s3">\n      </span><span class="s1">result.finally(() =&gt; {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadTimes += performance.now() - startTime</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">return result</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getClientComponentLoaderMetrics(</span><span class="s3">\n  </span><span class="s1">options: { reset?: boolean } = {}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const metrics =</span><span class="s3">\n    </span><span class="s1">clientComponentLoadStart === 0</span><span class="s3">\n      </span><span class="s1">? undefined</span><span class="s3">\n      </span><span class="s1">: {</span><span class="s3">\n          </span><span class="s1">clientComponentLoadStart,</span><span class="s3">\n          </span><span class="s1">clientComponentLoadTimes,</span><span class="s3">\n          </span><span class="s1">clientComponentLoadCount,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (options.reset) {</span><span class="s3">\n    </span><span class="s1">clientComponentLoadStart = 0</span><span class="s3">\n    </span><span class="s1">clientComponentLoadTimes = 0</span><span class="s3">\n    </span><span class="s1">clientComponentLoadCount = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return metrics</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ServerResponse } from 'node:http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ResponseAbortedName,</span><span class="s3">\n  </span><span class="s1">createAbortController,</span><span class="s3">\n</span><span class="s1">} from './web/spec-extension/adapters/next-request'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../lib/detached-promise'</span><span class="s3">\n</span><span class="s1">import { getTracer } from './lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NextNodeServerSpan } from './lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { getClientComponentLoaderMetrics } from './client-component-renderer-logger'</span><span class="s3">\n\n</span><span class="s1">export function isAbortError(e: any): e is Error &amp; { name: 'AbortError' } {</span><span class="s3">\n  </span><span class="s1">return e?.name === 'AbortError' || e?.name === ResponseAbortedName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createWriterFromResponse(</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">waitUntilForEnd?: Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">): WritableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let started = false</span><span class="s3">\n\n  </span><span class="s1">// Create a promise that will resolve once the response has drained. See</span><span class="s3">\n  </span><span class="s1">// https://nodejs.org/api/stream.html#stream_event_drain</span><span class="s3">\n  </span><span class="s1">let drained = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n  </span><span class="s1">function onDrain() {</span><span class="s3">\n    </span><span class="s1">drained.resolve()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">res.on('drain', onDrain)</span><span class="s3">\n\n  </span><span class="s1">// If the finish event fires, it means we shouldn't block and wait for the</span><span class="s3">\n  </span><span class="s1">// drain event.</span><span class="s3">\n  </span><span class="s1">res.once('close', () =&gt; {</span><span class="s3">\n    </span><span class="s1">res.off('drain', onDrain)</span><span class="s3">\n    </span><span class="s1">drained.resolve()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Create a promise that will resolve once the response has finished. See</span><span class="s3">\n  </span><span class="s1">// https://nodejs.org/api/http.html#event-finish_1</span><span class="s3">\n  </span><span class="s1">const finished = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n  </span><span class="s1">res.once('finish', () =&gt; {</span><span class="s3">\n    </span><span class="s1">finished.resolve()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Create a writable stream that will write to the response.</span><span class="s3">\n  </span><span class="s1">return new WritableStream&lt;Uint8Array&gt;({</span><span class="s3">\n    </span><span class="s1">write: async (chunk) =&gt; {</span><span class="s3">\n      </span><span class="s1">// You'd think we'd want to use `start` instead of placing this in `write`</span><span class="s3">\n      </span><span class="s1">// but this ensures that we don't actually flush the headers until we've</span><span class="s3">\n      </span><span class="s1">// started writing chunks.</span><span class="s3">\n      </span><span class="s1">if (!started) {</span><span class="s3">\n        </span><span class="s1">started = true</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">'performance' in globalThis &amp;&amp;</span><span class="s3">\n          </span><span class="s1">process.env.NEXT_OTEL_PERFORMANCE_PREFIX</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const metrics = getClientComponentLoaderMetrics()</span><span class="s3">\n          </span><span class="s1">if (metrics) {</span><span class="s3">\n            </span><span class="s1">performance.measure(</span><span class="s3">\n              </span><span class="s1">`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,</span><span class="s3">\n              </span><span class="s1">{</span><span class="s3">\n                </span><span class="s1">start: metrics.clientComponentLoadStart,</span><span class="s3">\n                </span><span class="s1">end:</span><span class="s3">\n                  </span><span class="s1">metrics.clientComponentLoadStart +</span><span class="s3">\n                  </span><span class="s1">metrics.clientComponentLoadTimes,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">res.flushHeaders()</span><span class="s3">\n        </span><span class="s1">getTracer().trace(</span><span class="s3">\n          </span><span class="s1">NextNodeServerSpan.startResponse,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">spanName: 'start response',</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">() =&gt; undefined</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const ok = res.write(chunk)</span><span class="s3">\n\n        </span><span class="s1">// Added by the `compression` middleware, this is a function that will</span><span class="s3">\n        </span><span class="s1">// flush the partially-compressed response to the client.</span><span class="s3">\n        </span><span class="s1">if ('flush' in res &amp;&amp; typeof res.flush === 'function') {</span><span class="s3">\n          </span><span class="s1">res.flush()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If the write returns false, it means there's some backpressure, so</span><span class="s3">\n        </span><span class="s1">// wait until it's streamed before continuing.</span><span class="s3">\n        </span><span class="s1">if (!ok) {</span><span class="s3">\n          </span><span class="s1">await drained.promise</span><span class="s3">\n\n          </span><span class="s1">// Reset the drained promise so that we can wait for the next drain event.</span><span class="s3">\n          </span><span class="s1">drained = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">res.end()</span><span class="s3">\n        </span><span class="s1">throw new Error('failed to write chunk to response', { cause: err })</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">abort: (err) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (res.writableFinished) return</span><span class="s3">\n\n      </span><span class="s1">res.destroy(err)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">close: async () =&gt; {</span><span class="s3">\n      </span><span class="s1">// if a waitUntil promise was passed, wait for it to resolve before</span><span class="s3">\n      </span><span class="s1">// ending the response.</span><span class="s3">\n      </span><span class="s1">if (waitUntilForEnd) {</span><span class="s3">\n        </span><span class="s1">await waitUntilForEnd</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (res.writableFinished) return</span><span class="s3">\n\n      </span><span class="s1">res.end()</span><span class="s3">\n      </span><span class="s1">return finished.promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function pipeToNodeResponse(</span><span class="s3">\n  </span><span class="s1">readable: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">waitUntilForEnd?: Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// If the response has already errored, then just return now.</span><span class="s3">\n    </span><span class="s1">const { errored, destroyed } = res</span><span class="s3">\n    </span><span class="s1">if (errored || destroyed) return</span><span class="s3">\n\n    </span><span class="s1">// Create a new AbortController so that we can abort the readable if the</span><span class="s3">\n    </span><span class="s1">// client disconnects.</span><span class="s3">\n    </span><span class="s1">const controller = createAbortController(res)</span><span class="s3">\n\n    </span><span class="s1">const writer = createWriterFromResponse(res, waitUntilForEnd)</span><span class="s3">\n\n    </span><span class="s1">await readable.pipeTo(writer, { signal: controller.signal })</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">// If this isn't related to an abort error, re-throw it.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(err)) return</span><span class="s3">\n\n    </span><span class="s1">throw new Error('failed to pipe response', { cause: err })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { FetchMetrics } from './base-http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">chainStreams,</span><span class="s3">\n  </span><span class="s1">streamFromBuffer,</span><span class="s3">\n  </span><span class="s1">streamFromString,</span><span class="s3">\n  </span><span class="s1">streamToString,</span><span class="s3">\n</span><span class="s1">} from './stream-utils/node-web-streams-helper'</span><span class="s3">\n</span><span class="s1">import { isAbortError, pipeToNodeResponse } from './pipe-readable'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">TEXT_PLAIN_CONTENT_TYPE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import type { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">type ContentTypeOption =</span><span class="s3">\n  </span><span class="s1">| typeof RSC_CONTENT_TYPE_HEADER // For App Page RSC responses</span><span class="s3">\n  </span><span class="s1">| typeof HTML_CONTENT_TYPE_HEADER // For App Page, Pages HTML responses</span><span class="s3">\n  </span><span class="s1">| typeof JSON_CONTENT_TYPE_HEADER // For API routes, Next.js data requests</span><span class="s3">\n  </span><span class="s1">| typeof TEXT_PLAIN_CONTENT_TYPE_HEADER // For simplified errors</span><span class="s3">\n\n</span><span class="s1">export type AppPageRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">flightData?: Buffer</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">staticBailoutInfo?: {</span><span class="s3">\n    </span><span class="s1">stack?: string</span><span class="s3">\n    </span><span class="s1">description?: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The postponed state if the render had postponed and needs to be resumed.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The headers to set on the response that were added by the render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">statusCode?: number</span><span class="s3">\n  </span><span class="s1">fetchTags?: string</span><span class="s3">\n  </span><span class="s1">fetchMetrics?: FetchMetrics</span><span class="s3">\n\n  </span><span class="s1">segmentData?: Map&lt;string, Buffer&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the resume data cache is warmed up before the render. This</span><span class="s3">\n   </span><span class="s1">* is attached to the metadata so that it can be used during the render. When</span><span class="s3">\n   </span><span class="s1">* prerendering, the filled resume data cache is also attached to the metadata</span><span class="s3">\n   </span><span class="s1">* so that it can be used when prerendering matching fallback shells.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PagesRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">pageData?: any</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">assetQueryString?: string</span><span class="s3">\n  </span><span class="s1">isNotFound?: boolean</span><span class="s3">\n  </span><span class="s1">isRedirect?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type StaticRenderResultMetadata = {}</span><span class="s3">\n\n</span><span class="s1">export type RenderResultMetadata = AppPageRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">PagesRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">StaticRenderResultMetadata</span><span class="s3">\n\n</span><span class="s1">export type RenderResultResponse =</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;[]</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">| string</span><span class="s3">\n  </span><span class="s1">| Buffer</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n\n</span><span class="s1">export type RenderResultOptions&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; = {</span><span class="s3">\n  </span><span class="s1">contentType: ContentTypeOption | null</span><span class="s3">\n  </span><span class="s1">waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n  </span><span class="s1">metadata: Metadata</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class RenderResult&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The detected content type for the response. This is used to set the</span><span class="s3">\n   </span><span class="s1">* `Content-Type` header.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly contentType: ContentTypeOption | null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The metadata for the response. This is used to set the revalidation times</span><span class="s3">\n   </span><span class="s1">* and other metadata.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly metadata: Readonly&lt;Metadata&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The response itself. This can be a string, a stream, or null. If it's a</span><span class="s3">\n   </span><span class="s1">* string, then it's a static response. If it's a stream, then it's a</span><span class="s3">\n   </span><span class="s1">* dynamic response. If it's null, then the response was not found or was</span><span class="s3">\n   </span><span class="s1">* already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private response: RenderResultResponse</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A render result that represents an empty response. This is used to</span><span class="s3">\n   </span><span class="s1">* represent a response that was not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static readonly EMPTY = new RenderResult&lt;StaticRenderResultMetadata&gt;(</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">{ metadata: {}, contentType: null }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a new RenderResult instance from a static response.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param value the static response value</span><span class="s3">\n   </span><span class="s1">* @param contentType the content type of the response</span><span class="s3">\n   </span><span class="s1">* @returns a new RenderResult instance</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static fromStatic(</span><span class="s3">\n    </span><span class="s1">value: string | Buffer,</span><span class="s3">\n    </span><span class="s1">contentType: ContentTypeOption</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return new RenderResult&lt;StaticRenderResultMetadata&gt;(value, {</span><span class="s3">\n      </span><span class="s1">metadata: {},</span><span class="s3">\n      </span><span class="s1">contentType,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private readonly waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">response: RenderResultResponse,</span><span class="s3">\n    </span><span class="s1">{ contentType, waitUntil, metadata }: RenderResultOptions&lt;Metadata&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.response = response</span><span class="s3">\n    </span><span class="s1">this.contentType = contentType</span><span class="s3">\n    </span><span class="s1">this.metadata = metadata</span><span class="s3">\n    </span><span class="s1">this.waitUntil = waitUntil</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public assignMetadata(metadata: Metadata) {</span><span class="s3">\n    </span><span class="s1">Object.assign(this.metadata, metadata)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns true if the response is null. It can be null if the response was</span><span class="s3">\n   </span><span class="s1">* not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isNull(): boolean {</span><span class="s3">\n    </span><span class="s1">return this.response === null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns false if the response is a string. It can be a string if the page</span><span class="s3">\n   </span><span class="s1">* was prerendered. If it's not, then it was generated dynamically.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isDynamic(): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.response !== 'string'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the response if it is a string. If the page was dynamic, this will</span><span class="s3">\n   </span><span class="s1">* return a promise if the `stream` option is true, or it will throw an error.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param stream Whether or not to return a promise if the response is dynamic</span><span class="s3">\n   </span><span class="s1">* @returns The response as a string</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream?: false): string</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream: true): Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream = false): Promise&lt;string&gt; | string {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty string. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response !== 'string') {</span><span class="s3">\n      </span><span class="s1">if (!stream) {</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'dynamic responses cannot be unchunked. This is a bug in Next.js'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return streamToString(this.readable)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a readable stream of the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private get readable(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return new ReadableStream&lt;Uint8Array&gt;({</span><span class="s3">\n        </span><span class="s1">start(controller) {</span><span class="s3">\n          </span><span class="s1">controller.close()</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return streamFromString(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return streamFromBuffer(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the response is an array of streams, then chain them together.</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return chainStreams(...this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Coerces the response to an array of streams. This will convert the response</span><span class="s3">\n   </span><span class="s1">* to an array of streams if it is not already one.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @returns An array of streams</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private coerce(): ReadableStream&lt;Uint8Array&gt;[] {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return []</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return [streamFromString(this.response)]</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return this.response</span><span class="s3">\n    </span><span class="s1">} else if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return [streamFromBuffer(this.response)]</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return [this.response]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Unshifts a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the start of the array. When this response is piped, all of the streams</span><span class="s3">\n   </span><span class="s1">* will be piped one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to unshift</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public unshift(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the start of the array.</span><span class="s3">\n    </span><span class="s1">this.response.unshift(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Chains a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the end. When this response is piped, all of the streams will be piped</span><span class="s3">\n   </span><span class="s1">* one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to chain</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public push(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the end of the array.</span><span class="s3">\n    </span><span class="s1">this.response.push(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a writable stream. This will close/cancel the</span><span class="s3">\n   </span><span class="s1">* writable stream if an error is encountered. If this doesn't throw, then</span><span class="s3">\n   </span><span class="s1">* the writable stream will be closed or aborted.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param writable Writable stream to pipe the response to</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeTo(writable: WritableStream&lt;Uint8Array&gt;): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">await this.readable.pipeTo(writable, {</span><span class="s3">\n        </span><span class="s1">// We want to close the writable stream ourselves so that we can wait</span><span class="s3">\n        </span><span class="s1">// for the waitUntil promise to resolve before closing it. If an error</span><span class="s3">\n        </span><span class="s1">// is encountered, we'll abort the writable stream if we swallowed the</span><span class="s3">\n        </span><span class="s1">// error.</span><span class="s3">\n        </span><span class="s1">preventClose: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// If there is a waitUntil promise, wait for it to resolve before</span><span class="s3">\n      </span><span class="s1">// closing the writable stream.</span><span class="s3">\n      </span><span class="s1">if (this.waitUntil) await this.waitUntil</span><span class="s3">\n\n      </span><span class="s1">// Close the writable stream.</span><span class="s3">\n      </span><span class="s1">await writable.close()</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">// If this is an abort error, we should abort the writable stream (as we</span><span class="s3">\n      </span><span class="s1">// took ownership of it when we started piping). We don't need to re-throw</span><span class="s3">\n      </span><span class="s1">// because we handled the error.</span><span class="s3">\n      </span><span class="s1">if (isAbortError(err)) {</span><span class="s3">\n        </span><span class="s1">// Abort the writable stream if an error is encountered.</span><span class="s3">\n        </span><span class="s1">await writable.abort(err)</span><span class="s3">\n\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We're not aborting the writer here as when this method throws it's not</span><span class="s3">\n      </span><span class="s1">// clear as to how so the caller should assume it's their responsibility</span><span class="s3">\n      </span><span class="s1">// to clean up the writer.</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a node response. This will close/cancel the node</span><span class="s3">\n   </span><span class="s1">* response if an error is encountered.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param res</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeToNodeResponse(res: ServerResponse) {</span><span class="s3">\n    </span><span class="s1">await pipeToNodeResponse(this.readable, res, this.waitUntil)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* For a given page path, this function ensures that there is no backslash</span><span class="s3">\n </span><span class="s1">* escaping slashes in the path. Example:</span><span class="s3">\n </span><span class="s1">*  - `foo</span><span class="s3">\\</span><span class="s1">/bar</span><span class="s3">\\</span><span class="s1">/baz` -&gt; `foo/bar/baz`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizePathSep(path: string): string {</span><span class="s3">\n  </span><span class="s1">return path.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isDynamicRoute } from '../router/utils'</span><span class="s3">\n</span><span class="s1">import { normalizePathSep } from './normalize-path-sep'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Performs the opposite transformation of `normalizePagePath`. Note that</span><span class="s3">\n </span><span class="s1">* this function is not idempotent either in cases where there are multiple</span><span class="s3">\n </span><span class="s1">* leading `/index` for the page. Examples:</span><span class="s3">\n </span><span class="s1">*  - `/index` -&gt; `/`</span><span class="s3">\n </span><span class="s1">*  - `/index/foo` -&gt; `/foo`</span><span class="s3">\n </span><span class="s1">*  - `/index/index` -&gt; `/index`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function denormalizePagePath(page: string) {</span><span class="s3">\n  </span><span class="s1">let _page = normalizePathSep(page)</span><span class="s3">\n  </span><span class="s1">return _page.startsWith('/index/') &amp;&amp; !isDynamicRoute(_page)</span><span class="s3">\n    </span><span class="s1">? _page.slice(6)</span><span class="s3">\n    </span><span class="s1">: _page !== '/index'</span><span class="s3">\n      </span><span class="s1">? _page</span><span class="s3">\n      </span><span class="s1">: '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Key } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import { regexpToFunction } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A transformer function that will be applied to the regexp generated</span><span class="s3">\n   </span><span class="s1">* from the provided path and path-to-regexp.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">regexModifier?: (regex: string) =&gt; string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the function will remove all unnamed parameters</span><span class="s3">\n   </span><span class="s1">* from the matched parameters.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">removeUnnamedParams?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the regexp won't allow an optional trailing delimiter</span><span class="s3">\n   </span><span class="s1">* to match.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">strict?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the matcher will be case-sensitive, defaults to false</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">sensitive?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PatchMatcher = (</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">params?: Record&lt;string, any&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; Record&lt;string, any&gt; | false</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a path matcher function for a given path and options based on</span><span class="s3">\n </span><span class="s1">* path-to-regexp. By default the match will be case insensitive, non strict</span><span class="s3">\n </span><span class="s1">* and delimited by `/`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getPathMatch(path: string, options?: Options): PatchMatcher {</span><span class="s3">\n  </span><span class="s1">const keys: Key[] = []</span><span class="s3">\n  </span><span class="s1">const regexp = pathToRegexp(path, keys, {</span><span class="s3">\n    </span><span class="s1">delimiter: '/',</span><span class="s3">\n    </span><span class="s1">sensitive:</span><span class="s3">\n      </span><span class="s1">typeof options?.sensitive === 'boolean' ? options.sensitive : false,</span><span class="s3">\n    </span><span class="s1">strict: options?.strict,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const matcher = regexpToFunction&lt;Record&lt;string, any&gt;&gt;(</span><span class="s3">\n    </span><span class="s1">options?.regexModifier</span><span class="s3">\n      </span><span class="s1">? new RegExp(options.regexModifier(regexp.source), regexp.flags)</span><span class="s3">\n      </span><span class="s1">: regexp,</span><span class="s3">\n    </span><span class="s1">keys</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A matcher function that will check if a given pathname matches the path</span><span class="s3">\n   </span><span class="s1">* given in the builder function. When the path does not match it will return</span><span class="s3">\n   </span><span class="s1">* `false` but if it does it will return an object with the matched params</span><span class="s3">\n   </span><span class="s1">* merged with the params provided in the second argument.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">return (pathname, params) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If no pathname is provided it's not a match.</span><span class="s3">\n    </span><span class="s1">if (typeof pathname !== 'string') return false</span><span class="s3">\n\n    </span><span class="s1">const match = matcher(pathname)</span><span class="s3">\n\n    </span><span class="s1">// If the path did not match `false` will be returned.</span><span class="s3">\n    </span><span class="s1">if (!match) return false</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If unnamed params are not allowed they must be removed from</span><span class="s3">\n     </span><span class="s1">* the matched parameters. path-to-regexp uses </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">for named and</span><span class="s3">\n     </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">for unnamed parameters.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (options?.removeUnnamedParams) {</span><span class="s3">\n      </span><span class="s1">for (const key of keys) {</span><span class="s3">\n        </span><span class="s1">if (typeof key.name === 'number') {</span><span class="s3">\n          </span><span class="s1">delete match.params[key.name]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return { ...params, ...match.params }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// regexp is based on https://github.com/sindresorhus/escape-string-regexp</span><span class="s3">\n</span><span class="s1">const reHasRegExp = /[|</span><span class="s3">\\\\</span><span class="s1">{}()[</span><span class="s3">\\</span><span class="s1">]^$+*?.-]/</span><span class="s3">\n</span><span class="s1">const reReplaceRegExp = /[|</span><span class="s3">\\\\</span><span class="s1">{}()[</span><span class="s3">\\</span><span class="s1">]^$+*?.-]/g</span><span class="s3">\n\n</span><span class="s1">export function escapeStringRegexp(str: string) {</span><span class="s3">\n  </span><span class="s1">// see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23</span><span class="s3">\n  </span><span class="s1">if (reHasRegExp.test(str)) {</span><span class="s3">\n    </span><span class="s1">return str.replace(reReplaceRegExp, '</span><span class="s3">\\\\</span><span class="s1">$&amp;')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return str</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { DynamicParam } from '../../../../server/app-render/app-render'</span><span class="s3">\n</span><span class="s1">import type { DynamicParamTypesShort } from '../../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { FallbackRouteParams } from '../../../../server/request/fallback-params'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Shared logic on client and server for creating a dynamic param value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This code needs to be shared with the client so it can extract dynamic route</span><span class="s3">\n </span><span class="s1">* params from the URL without a server request.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Because everything in this module is sent to the client, we should aim to</span><span class="s3">\n </span><span class="s1">* keep this code as simple as possible. The special case handling for catchall</span><span class="s3">\n </span><span class="s1">* and optional is, alas, unfortunate.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getDynamicParam(</span><span class="s3">\n  </span><span class="s1">params: { [key: string]: any },</span><span class="s3">\n  </span><span class="s1">segmentKey: string,</span><span class="s3">\n  </span><span class="s1">dynamicParamType: DynamicParamTypesShort,</span><span class="s3">\n  </span><span class="s1">pagePath: string,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">): DynamicParam {</span><span class="s3">\n  </span><span class="s1">let value = params[segmentKey]</span><span class="s3">\n\n  </span><span class="s1">if (fallbackRouteParams &amp;&amp; fallbackRouteParams.has(segmentKey)) {</span><span class="s3">\n    </span><span class="s1">value = fallbackRouteParams.get(segmentKey)</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">value = value.map((i) =&gt; encodeURIComponent(i))</span><span class="s3">\n  </span><span class="s1">} else if (typeof value === 'string') {</span><span class="s3">\n    </span><span class="s1">value = encodeURIComponent(value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!value) {</span><span class="s3">\n    </span><span class="s1">const isCatchall = dynamicParamType === 'c'</span><span class="s3">\n    </span><span class="s1">const isOptionalCatchall = dynamicParamType === 'oc'</span><span class="s3">\n\n    </span><span class="s1">if (isCatchall || isOptionalCatchall) {</span><span class="s3">\n      </span><span class="s1">// handle the case where an optional catchall does not have a value,</span><span class="s3">\n      </span><span class="s1">// e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`</span><span class="s3">\n      </span><span class="s1">if (isOptionalCatchall) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">param: segmentKey,</span><span class="s3">\n          </span><span class="s1">value: null,</span><span class="s3">\n          </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n          </span><span class="s1">treeSegment: [segmentKey, '', dynamicParamType],</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// handle the case where a catchall or optional catchall does not have a value,</span><span class="s3">\n      </span><span class="s1">// e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched</span><span class="s3">\n      </span><span class="s1">value = pagePath</span><span class="s3">\n        </span><span class="s1">.split('/')</span><span class="s3">\n        </span><span class="s1">// remove the first empty string</span><span class="s3">\n        </span><span class="s1">.slice(1)</span><span class="s3">\n        </span><span class="s1">// replace any dynamic params with the actual values</span><span class="s3">\n        </span><span class="s1">.flatMap((pathSegment) =&gt; {</span><span class="s3">\n          </span><span class="s1">const param = parseParameter(pathSegment)</span><span class="s3">\n          </span><span class="s1">// if the segment matches a param, return the param value</span><span class="s3">\n          </span><span class="s1">// otherwise, it's a static segment, so just return that</span><span class="s3">\n          </span><span class="s1">return params[param.key] ?? param.key</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">param: segmentKey,</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n        </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n        </span><span class="s1">// This value always has to be a string.</span><span class="s3">\n        </span><span class="s1">treeSegment: [segmentKey, value.join('/'), dynamicParamType],</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">param: segmentKey,</span><span class="s3">\n    </span><span class="s1">// The value that is passed to user code.</span><span class="s3">\n    </span><span class="s1">value: value,</span><span class="s3">\n    </span><span class="s1">// The value that is rendered in the router tree.</span><span class="s3">\n    </span><span class="s1">treeSegment: [</span><span class="s3">\n      </span><span class="s1">segmentKey,</span><span class="s3">\n      </span><span class="s1">Array.isArray(value) ? value.join('/') : value,</span><span class="s3">\n      </span><span class="s1">dynamicParamType,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Regular expression pattern used to match route parameters.</span><span class="s3">\n </span><span class="s1">* Matches both single parameters and parameter groups.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false</span><span class="s3">\n </span><span class="s1">*   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true</span><span class="s3">\n </span><span class="s1">*   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const PARAMETER_PATTERN = /^([^[]*)</span><span class="s3">\\</span><span class="s1">[((?:</span><span class="s3">\\</span><span class="s1">[[^</span><span class="s3">\\</span><span class="s1">]]*</span><span class="s3">\\</span><span class="s1">])|[^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">](.*)$/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses a given parameter from a route to a data structure that can be used</span><span class="s3">\n </span><span class="s1">* to generate the parametrized route.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[[...slug]]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `[[foo]]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `[bar]` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `fizz` -&gt; `{ key: 'fizz', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">* @param param - The parameter to parse.</span><span class="s3">\n </span><span class="s1">* @returns The parsed parameter as a data structure.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseParameter(param: string) {</span><span class="s3">\n  </span><span class="s1">const match = param.match(PARAMETER_PATTERN)</span><span class="s3">\n\n  </span><span class="s1">if (!match) {</span><span class="s3">\n    </span><span class="s1">return parseMatchedParameter(param)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return parseMatchedParameter(match[2])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used</span><span class="s3">\n </span><span class="s1">* to generate the parametrized route.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `...slug` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `[foo]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `bar` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">* @param param - The matched parameter to parse.</span><span class="s3">\n </span><span class="s1">* @returns The parsed parameter as a data structure.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseMatchedParameter(param: string) {</span><span class="s3">\n  </span><span class="s1">const optional = param.startsWith('[') &amp;&amp; param.endsWith(']')</span><span class="s3">\n  </span><span class="s1">if (optional) {</span><span class="s3">\n    </span><span class="s1">param = param.slice(1, -1)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const repeat = param.startsWith('...')</span><span class="s3">\n  </span><span class="s1">if (repeat) {</span><span class="s3">\n    </span><span class="s1">param = param.slice(3)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return { key: param, repeat, optional }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from './remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { PARAMETER_PATTERN, parseMatchedParameter } from './get-dynamic-param'</span><span class="s3">\n\n</span><span class="s1">export interface Group {</span><span class="s3">\n  </span><span class="s1">pos: number</span><span class="s3">\n  </span><span class="s1">repeat: boolean</span><span class="s3">\n  </span><span class="s1">optional: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RouteRegex {</span><span class="s3">\n  </span><span class="s1">groups: { [groupName: string]: Group }</span><span class="s3">\n  </span><span class="s1">re: RegExp</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetNamedRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n   </span><span class="s1">* or NEXT_QUERY_PARAM_PREFIX. This is only relevant when creating the</span><span class="s3">\n   </span><span class="s1">* routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the suffix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to backtrack duplicate keys. This is only relevant when creating</span><span class="s3">\n   </span><span class="s1">* the routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include extra parts in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">* of adding this option.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const groups: { [groupName: string]: Group } = {}</span><span class="s3">\n  </span><span class="s1">let groupIndex = 1</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const markerMatch = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (markerMatch &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(markerMatch)}([^/]+?)`)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, repeat, optional } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">parameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* From a normalized route this function generates a regular expression and</span><span class="s3">\n </span><span class="s1">* a corresponding groups object intended to be used to store matching groups</span><span class="s3">\n </span><span class="s1">* from the regular expression.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">includeSuffix = false,</span><span class="s3">\n    </span><span class="s1">includePrefix = false,</span><span class="s3">\n    </span><span class="s1">excludeOptionalTrailingSlash = false,</span><span class="s3">\n  </span><span class="s1">}: GetRouteRegexOptions = {}</span><span class="s3">\n</span><span class="s1">): RouteRegex {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute, groups } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">includeSuffix,</span><span class="s3">\n    </span><span class="s1">includePrefix</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let re = parameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">re += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">re: new RegExp(`^${re}$`),</span><span class="s3">\n    </span><span class="s1">groups: groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Builds a function to generate a minimal routeKey using only a-z and minimal</span><span class="s3">\n </span><span class="s1">* number of characters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildGetSafeRouteKey() {</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n\n  </span><span class="s1">return () =&gt; {</span><span class="s3">\n    </span><span class="s1">let routeKey = ''</span><span class="s3">\n    </span><span class="s1">let j = ++i</span><span class="s3">\n    </span><span class="s1">while (j &gt; 0) {</span><span class="s3">\n      </span><span class="s1">routeKey += String.fromCharCode(97 + ((j - 1) % 26))</span><span class="s3">\n      </span><span class="s1">j = Math.floor((j - 1) / 26)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return routeKey</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getSafeKeyFromSegment({</span><span class="s3">\n  </span><span class="s1">interceptionMarker,</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n  </span><span class="s1">segment,</span><span class="s3">\n  </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">keyPrefix,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">interceptionMarker?: string</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey: () =&gt; string</span><span class="s3">\n  </span><span class="s1">segment: string</span><span class="s3">\n  </span><span class="s1">routeKeys: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">keyPrefix?: string</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(segment)</span><span class="s3">\n\n  </span><span class="s1">// replace any non-word characters since they can break</span><span class="s3">\n  </span><span class="s1">// the named regex</span><span class="s3">\n  </span><span class="s1">let cleanedKey = key.replace(/</span><span class="s3">\\</span><span class="s1">W/g, '')</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = `${keyPrefix}${cleanedKey}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let invalidKey = false</span><span class="s3">\n\n  </span><span class="s1">// check if the key is still invalid and fallback to using a known</span><span class="s3">\n  </span><span class="s1">// safe key</span><span class="s3">\n  </span><span class="s1">if (cleanedKey.length === 0 || cleanedKey.length &gt; 30) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (invalidKey) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = getSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const duplicateKey = cleanedKey in routeKeys</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = `${keyPrefix}${key}`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = key</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if the segment has an interception marker, make sure that's part of the regex pattern</span><span class="s3">\n  </span><span class="s1">// this is to ensure that the route with the interception marker doesn't incorrectly match</span><span class="s3">\n  </span><span class="s1">// the non-intercepted route (ie /app/(.)[username] should not match /app/[username])</span><span class="s3">\n  </span><span class="s1">const interceptionPrefix = interceptionMarker</span><span class="s3">\n    </span><span class="s1">? escapeStringRegexp(interceptionMarker)</span><span class="s3">\n    </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">let pattern: string</span><span class="s3">\n  </span><span class="s1">if (duplicateKey &amp;&amp; backreferenceDuplicateKeys) {</span><span class="s3">\n    </span><span class="s1">// Use a backreference to the key to ensure that the key is the same value</span><span class="s3">\n    </span><span class="s1">// in each of the placeholders.</span><span class="s3">\n    </span><span class="s1">pattern = `</span><span class="s3">\\\\</span><span class="s1">k&lt;${cleanedKey}&gt;`</span><span class="s3">\n  </span><span class="s1">} else if (repeat) {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;.+?)`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;[^/]+?)`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return optional</span><span class="s3">\n    </span><span class="s1">? `(?:/${interceptionPrefix}${pattern})?`</span><span class="s3">\n    </span><span class="s1">: `/${interceptionPrefix}${pattern}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getNamedParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const getSafeRouteKey = buildGetSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">const routeKeys: { [named: string]: string } = {}</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const hasInterceptionMarker = INTERCEPTION_ROUTE_MARKERS.some((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (hasInterceptionMarker &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's an interception marker, add it to the segments.</span><span class="s3">\n      </span><span class="s1">segments.push(</span><span class="s3">\n        </span><span class="s1">getSafeKeyFromSegment({</span><span class="s3">\n          </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n          </span><span class="s1">interceptionMarker: paramMatches[1],</span><span class="s3">\n          </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n          </span><span class="s1">routeKeys,</span><span class="s3">\n          </span><span class="s1">keyPrefix: prefixRouteKeys</span><span class="s3">\n            </span><span class="s1">? NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n            </span><span class="s1">: undefined,</span><span class="s3">\n          </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's a prefix, add it to the segments if it's enabled.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = getSafeKeyFromSegment({</span><span class="s3">\n        </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n        </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n        </span><span class="s1">routeKeys,</span><span class="s3">\n        </span><span class="s1">keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,</span><span class="s3">\n        </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedParameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function extends `getRouteRegex` generating also a named regexp where</span><span class="s3">\n </span><span class="s1">* each group is named along with a routeKeys object that indexes the assigned</span><span class="s3">\n </span><span class="s1">* named group with its corresponding key. When the routeKeys need to be</span><span class="s3">\n </span><span class="s1">* prefixed to uniquely identify internally the </span><span class="s3">\&quot;</span><span class="s1">prefixRouteKey</span><span class="s3">\&quot; </span><span class="s1">arg should</span><span class="s3">\n </span><span class="s1">* be </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot; </span><span class="s1">currently this is only the case when creating the routes-manifest</span><span class="s3">\n </span><span class="s1">* during the build</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: GetNamedRouteRegexOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const result = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">options.prefixRouteKeys,</span><span class="s3">\n    </span><span class="s1">options.includeSuffix ?? false,</span><span class="s3">\n    </span><span class="s1">options.includePrefix ?? false,</span><span class="s3">\n    </span><span class="s1">options.backreferenceDuplicateKeys ?? false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let namedRegex = result.namedParameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!options.excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">namedRegex += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...getRouteRegex(normalizedRoute, options),</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedRegex}$`,</span><span class="s3">\n    </span><span class="s1">routeKeys: result.routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a named regexp.</span><span class="s3">\n </span><span class="s1">* This is intended to be using for build time only.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedMiddlewareRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">catchAll?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const { catchAll = true } = options</span><span class="s3">\n  </span><span class="s1">if (parameterizedRoute === '/') {</span><span class="s3">\n    </span><span class="s1">let catchAllRegex = catchAll ? '.*' : ''</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">namedRegex: `^/${catchAllRegex}$`,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { namedParameterizedRoute } = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : ''</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { Key } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import type { NextParsedUrlQuery } from '../../../../server/request-meta'</span><span class="s3">\n</span><span class="s1">import type { RouteHas } from '../../../../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../../../../server/base-http'</span><span class="s3">\n\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { parseUrl } from './parse-url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">INTERCEPTION_ROUTE_MARKERS,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { getCookieParser } from '../../../../server/api-utils/get-cookie-parser'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp, safeCompile } from './route-match-utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensure only a-zA-Z are used for param names for proper interpolating</span><span class="s3">\n </span><span class="s1">* with path-to-regexp</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getSafeParamName(paramName: string) {</span><span class="s3">\n  </span><span class="s1">let newParamName = ''</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; paramName.length; i++) {</span><span class="s3">\n    </span><span class="s1">const charCode = paramName.charCodeAt(i)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 64 &amp;&amp; charCode &lt; 91) || // A-Z</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 96 &amp;&amp; charCode &lt; 123) // a-z</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">newParamName += paramName[i]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newParamName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function escapeSegment(str: string, segmentName: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(</span><span class="s3">\n    </span><span class="s1">new RegExp(`:${escapeStringRegexp(segmentName)}`, 'g'),</span><span class="s3">\n    </span><span class="s1">`__ESC_COLON_${segmentName}`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function unescapeSegments(str: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(/__ESC_COLON_/gi, ':')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function matchHas(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">query: Params,</span><span class="s3">\n  </span><span class="s1">has: RouteHas[] = [],</span><span class="s3">\n  </span><span class="s1">missing: RouteHas[] = []</span><span class="s3">\n</span><span class="s1">): false | Params {</span><span class="s3">\n  </span><span class="s1">const params: Params = {}</span><span class="s3">\n\n  </span><span class="s1">const hasMatch = (hasItem: RouteHas) =&gt; {</span><span class="s3">\n    </span><span class="s1">let value</span><span class="s3">\n    </span><span class="s1">let key = hasItem.key</span><span class="s3">\n\n    </span><span class="s1">switch (hasItem.type) {</span><span class="s3">\n      </span><span class="s1">case 'header': {</span><span class="s3">\n        </span><span class="s1">key = key!.toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = req.headers[key] as string</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'cookie': {</span><span class="s3">\n        </span><span class="s1">if ('cookies' in req) {</span><span class="s3">\n          </span><span class="s1">value = req.cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const cookies = getCookieParser(req.headers)()</span><span class="s3">\n          </span><span class="s1">value = cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'query': {</span><span class="s3">\n        </span><span class="s1">value = query[key!]</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'host': {</span><span class="s3">\n        </span><span class="s1">const { host } = req?.headers || {}</span><span class="s3">\n        </span><span class="s1">// remove port from host if present</span><span class="s3">\n        </span><span class="s1">const hostname = host?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = hostname</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!hasItem.value &amp;&amp; value) {</span><span class="s3">\n      </span><span class="s1">params[getSafeParamName(key!)] = value</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">const matcher = new RegExp(`^${hasItem.value}$`)</span><span class="s3">\n      </span><span class="s1">const matches = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.slice(-1)[0].match(matcher)</span><span class="s3">\n        </span><span class="s1">: value.match(matcher)</span><span class="s3">\n\n      </span><span class="s1">if (matches) {</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(matches)) {</span><span class="s3">\n          </span><span class="s1">if (matches.groups) {</span><span class="s3">\n            </span><span class="s1">Object.keys(matches.groups).forEach((groupKey) =&gt; {</span><span class="s3">\n              </span><span class="s1">params[groupKey] = matches.groups![groupKey]</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">} else if (hasItem.type === 'host' &amp;&amp; matches[0]) {</span><span class="s3">\n            </span><span class="s1">params.host = matches[0]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const allMatch =</span><span class="s3">\n    </span><span class="s1">has.every((item) =&gt; hasMatch(item)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!missing.some((item) =&gt; hasMatch(item))</span><span class="s3">\n\n  </span><span class="s1">if (allMatch) {</span><span class="s3">\n    </span><span class="s1">return params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function compileNonPath(value: string, params: Params): string {</span><span class="s3">\n  </span><span class="s1">if (!value.includes(':')) {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(params)) {</span><span class="s3">\n    </span><span class="s1">if (value.includes(`:${key}`)) {</span><span class="s3">\n      </span><span class="s1">value = value</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">*`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_ASTERISKS`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">?`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_QUESTION`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}(?!</span><span class="s3">\\\\</span><span class="s1">w)`, 'g'),</span><span class="s3">\n          </span><span class="s1">`--ESCAPED_PARAM_COLON${key}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = value</span><span class="s3">\n    </span><span class="s1">.replace(/(:|</span><span class="s3">\\</span><span class="s1">*|</span><span class="s3">\\</span><span class="s1">?|</span><span class="s3">\\</span><span class="s1">+|</span><span class="s3">\\</span><span class="s1">(|</span><span class="s3">\\</span><span class="s1">)|</span><span class="s3">\\</span><span class="s1">{|</span><span class="s3">\\</span><span class="s1">})/g, '</span><span class="s3">\\\\</span><span class="s1">$1')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_PLUS/g, '+')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_COLON/g, ':')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_QUESTION/g, '?')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')</span><span class="s3">\n\n  </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n  </span><span class="s1">// correctly</span><span class="s3">\n  </span><span class="s1">return safeCompile(`/${value}`, { validate: false })(params).slice(1)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseDestination(args: {</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Readonly&lt;Params&gt;</span><span class="s3">\n  </span><span class="s1">query: Readonly&lt;NextParsedUrlQuery&gt;</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let escaped = args.destination</span><span class="s3">\n  </span><span class="s1">for (const param of Object.keys({ ...args.params, ...args.query })) {</span><span class="s3">\n    </span><span class="s1">if (!param) continue</span><span class="s3">\n\n    </span><span class="s1">escaped = escapeSegment(escaped, param)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsed = parseUrl(escaped)</span><span class="s3">\n\n  </span><span class="s1">let pathname = parsed.pathname</span><span class="s3">\n  </span><span class="s1">if (pathname) {</span><span class="s3">\n    </span><span class="s1">pathname = unescapeSegments(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let href = parsed.href</span><span class="s3">\n  </span><span class="s1">if (href) {</span><span class="s3">\n    </span><span class="s1">href = unescapeSegments(href)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hostname = parsed.hostname</span><span class="s3">\n  </span><span class="s1">if (hostname) {</span><span class="s3">\n    </span><span class="s1">hostname = unescapeSegments(hostname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hash = parsed.hash</span><span class="s3">\n  </span><span class="s1">if (hash) {</span><span class="s3">\n    </span><span class="s1">hash = unescapeSegments(hash)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let search = parsed.search</span><span class="s3">\n  </span><span class="s1">if (search) {</span><span class="s3">\n    </span><span class="s1">search = unescapeSegments(search)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...parsed,</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">hostname,</span><span class="s3">\n    </span><span class="s1">href,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">search,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function prepareDestination(args: {</span><span class="s3">\n  </span><span class="s1">appendParamsToQuery: boolean</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Params</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const parsedDestination = parseDestination(args)</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">hostname: destHostname,</span><span class="s3">\n    </span><span class="s1">query: destQuery,</span><span class="s3">\n    </span><span class="s1">search: destSearch,</span><span class="s3">\n  </span><span class="s1">} = parsedDestination</span><span class="s3">\n\n  </span><span class="s1">// The following code assumes that the pathname here includes the hash if it's</span><span class="s3">\n  </span><span class="s1">// present.</span><span class="s3">\n  </span><span class="s1">let destPath = parsedDestination.pathname</span><span class="s3">\n  </span><span class="s1">if (parsedDestination.hash) {</span><span class="s3">\n    </span><span class="s1">destPath = `${destPath}${parsedDestination.hash}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destParams: (string | number)[] = []</span><span class="s3">\n\n  </span><span class="s1">const destPathParamKeys: Key[] = []</span><span class="s3">\n  </span><span class="s1">safePathToRegexp(destPath, destPathParamKeys)</span><span class="s3">\n  </span><span class="s1">for (const key of destPathParamKeys) {</span><span class="s3">\n    </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">const destHostnameParamKeys: Key[] = []</span><span class="s3">\n    </span><span class="s1">safePathToRegexp(destHostname, destHostnameParamKeys)</span><span class="s3">\n    </span><span class="s1">for (const key of destHostnameParamKeys) {</span><span class="s3">\n      </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destPathCompiler = safeCompile(</span><span class="s3">\n    </span><span class="s1">destPath,</span><span class="s3">\n    </span><span class="s1">// we don't validate while compiling the destination since we should</span><span class="s3">\n    </span><span class="s1">// have already validated before we got to this point and validating</span><span class="s3">\n    </span><span class="s1">// breaks compiling destinations with named pattern params from the source</span><span class="s3">\n    </span><span class="s1">// e.g. /something:hello(.*) -&gt; /another/:hello is broken with validation</span><span class="s3">\n    </span><span class="s1">// since compile validation is meant for reversing and not for inserting</span><span class="s3">\n    </span><span class="s1">// params from a separate path-regex into another</span><span class="s3">\n    </span><span class="s1">{ validate: false }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let destHostnameCompiler</span><span class="s3">\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">destHostnameCompiler = safeCompile(destHostname, { validate: false })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// update any params in query values</span><span class="s3">\n  </span><span class="s1">for (const [key, strOrArray] of Object.entries(destQuery)) {</span><span class="s3">\n    </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n    </span><span class="s1">// correctly</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(strOrArray)) {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = strOrArray.map((value) =&gt;</span><span class="s3">\n        </span><span class="s1">compileNonPath(unescapeSegments(value), args.params)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (typeof strOrArray === 'string') {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add path params to query if it's not a redirect and not</span><span class="s3">\n  </span><span class="s1">// already defined in destination query or path</span><span class="s3">\n  </span><span class="s1">let paramKeys = Object.keys(args.params).filter(</span><span class="s3">\n    </span><span class="s1">(name) =&gt; name !== 'nextInternalLocale'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">args.appendParamsToQuery &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!paramKeys.some((key) =&gt; destParams.includes(key))</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const key of paramKeys) {</span><span class="s3">\n      </span><span class="s1">if (!(key in destQuery)) {</span><span class="s3">\n        </span><span class="s1">destQuery[key] = args.params[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let newUrl</span><span class="s3">\n\n  </span><span class="s1">// The compiler also that the interception route marker is an unnamed param, hence '0',</span><span class="s3">\n  </span><span class="s1">// so we need to add it to the params object.</span><span class="s3">\n  </span><span class="s1">if (isInterceptionRouteAppPath(destPath)) {</span><span class="s3">\n    </span><span class="s1">for (const segment of destPath.split('/')) {</span><span class="s3">\n      </span><span class="s1">const marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n        </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (marker) {</span><span class="s3">\n        </span><span class="s1">if (marker === '(..)(..)') {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = '(..)'</span><span class="s3">\n          </span><span class="s1">args.params['1'] = '(..)'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = marker</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">newUrl = destPathCompiler(args.params)</span><span class="s3">\n\n    </span><span class="s1">const [pathname, hash] = newUrl.split('#', 2)</span><span class="s3">\n    </span><span class="s1">if (destHostnameCompiler) {</span><span class="s3">\n      </span><span class="s1">parsedDestination.hostname = destHostnameCompiler(args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parsedDestination.pathname = pathname</span><span class="s3">\n    </span><span class="s1">parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`</span><span class="s3">\n    </span><span class="s1">parsedDestination.search = destSearch</span><span class="s3">\n      </span><span class="s1">? compileNonPath(destSearch, args.params)</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">if (err.message.match(/Expected .*? to not repeat, but got an array/)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`To use a multi-match in the destination you must add </span><span class="s3">\\</span><span class="s1">`*</span><span class="s3">\\</span><span class="s1">` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Query merge order lowest priority to highest</span><span class="s3">\n  </span><span class="s1">// 1. initial URL query values</span><span class="s3">\n  </span><span class="s1">// 2. path segment values</span><span class="s3">\n  </span><span class="s1">// 3. destination specified query values</span><span class="s3">\n  </span><span class="s1">parsedDestination.query = {</span><span class="s3">\n    </span><span class="s1">...args.query,</span><span class="s3">\n    </span><span class="s1">...parsedDestination.query,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">newUrl,</span><span class="s3">\n    </span><span class="s1">destQuery,</span><span class="s3">\n    </span><span class="s1">parsedDestination,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Decodes a query path parameter.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param value - The value to decode.</span><span class="s3">\n </span><span class="s1">* @returns The decoded value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function decodeQueryPathParameter(value: string) {</span><span class="s3">\n  </span><span class="s1">// When deployed to Vercel, the value may be encoded, so this attempts to</span><span class="s3">\n  </span><span class="s1">// decode it and returns the original value if it fails.</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return decodeURIComponent(value)</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Format function modified from nodejs</span><span class="s3">\n</span><span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span><span class="s3">\n</span><span class="s1">// copy of this software and associated documentation files (the</span><span class="s3">\n</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Software</span><span class="s3">\&quot;</span><span class="s1">), to deal in the Software without restriction, including</span><span class="s3">\n</span><span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span><span class="s3">\n</span><span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span><span class="s3">\n</span><span class="s1">// persons to whom the Software is furnished to do so, subject to the</span><span class="s3">\n</span><span class="s1">// following conditions:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The above copyright notice and this permission notice shall be included</span><span class="s3">\n</span><span class="s1">// in all copies or substantial portions of the Software.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot;</span><span class="s1">, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span><span class="s3">\n</span><span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span><span class="s3">\n</span><span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span><span class="s3">\n</span><span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span><span class="s3">\n</span><span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span><span class="s3">\n</span><span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span><span class="s3">\n</span><span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span><span class="s3">\n\n</span><span class="s1">import type { UrlObject } from 'url'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import * as querystring from './querystring'</span><span class="s3">\n\n</span><span class="s1">const slashedProtocols = /https?|ftp|gopher|file/</span><span class="s3">\n\n</span><span class="s1">export function formatUrl(urlObj: UrlObject) {</span><span class="s3">\n  </span><span class="s1">let { auth, hostname } = urlObj</span><span class="s3">\n  </span><span class="s1">let protocol = urlObj.protocol || ''</span><span class="s3">\n  </span><span class="s1">let pathname = urlObj.pathname || ''</span><span class="s3">\n  </span><span class="s1">let hash = urlObj.hash || ''</span><span class="s3">\n  </span><span class="s1">let query = urlObj.query || ''</span><span class="s3">\n  </span><span class="s1">let host: string | false = false</span><span class="s3">\n\n  </span><span class="s1">auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : ''</span><span class="s3">\n\n  </span><span class="s1">if (urlObj.host) {</span><span class="s3">\n    </span><span class="s1">host = auth + urlObj.host</span><span class="s3">\n  </span><span class="s1">} else if (hostname) {</span><span class="s3">\n    </span><span class="s1">host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname)</span><span class="s3">\n    </span><span class="s1">if (urlObj.port) {</span><span class="s3">\n      </span><span class="s1">host += ':' + urlObj.port</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (query &amp;&amp; typeof query === 'object') {</span><span class="s3">\n    </span><span class="s1">query = String(querystring.urlQueryToSearchParams(query as ParsedUrlQuery))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let search = urlObj.search || (query &amp;&amp; `?${query}`) || ''</span><span class="s3">\n\n  </span><span class="s1">if (protocol &amp;&amp; !protocol.endsWith(':')) protocol += ':'</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">urlObj.slashes ||</span><span class="s3">\n    </span><span class="s1">((!protocol || slashedProtocols.test(protocol)) &amp;&amp; host !== false)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">host = '//' + (host || '')</span><span class="s3">\n    </span><span class="s1">if (pathname &amp;&amp; pathname[0] !== '/') pathname = '/' + pathname</span><span class="s3">\n  </span><span class="s1">} else if (!host) {</span><span class="s3">\n    </span><span class="s1">host = ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (hash &amp;&amp; hash[0] !== '#') hash = '#' + hash</span><span class="s3">\n  </span><span class="s1">if (search &amp;&amp; search[0] !== '?') search = '?' + search</span><span class="s3">\n\n  </span><span class="s1">pathname = pathname.replace(/[?#]/g, encodeURIComponent)</span><span class="s3">\n  </span><span class="s1">search = search.replace('#', '%23')</span><span class="s3">\n\n  </span><span class="s1">return `${protocol}${host}${pathname}${search}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const urlObjectKeys = [</span><span class="s3">\n  </span><span class="s1">'auth',</span><span class="s3">\n  </span><span class="s1">'hash',</span><span class="s3">\n  </span><span class="s1">'host',</span><span class="s3">\n  </span><span class="s1">'hostname',</span><span class="s3">\n  </span><span class="s1">'href',</span><span class="s3">\n  </span><span class="s1">'path',</span><span class="s3">\n  </span><span class="s1">'pathname',</span><span class="s3">\n  </span><span class="s1">'port',</span><span class="s3">\n  </span><span class="s1">'protocol',</span><span class="s3">\n  </span><span class="s1">'query',</span><span class="s3">\n  </span><span class="s1">'search',</span><span class="s3">\n  </span><span class="s1">'slashes',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export function formatWithValidation(url: UrlObject): string {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">if (url !== null &amp;&amp; typeof url === 'object') {</span><span class="s3">\n      </span><span class="s1">Object.keys(url).forEach((key) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!urlObjectKeys.includes(key)) {</span><span class="s3">\n          </span><span class="s1">console.warn(</span><span class="s3">\n            </span><span class="s1">`Unknown key passed via urlObject into url.format: ${key}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return formatUrl(url)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { LoadComponentsReturnType } from '../load-components'</span><span class="s3">\n</span><span class="s1">import type { ServerRuntime, SizeLimit } from '../../types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ExperimentalConfig,</span><span class="s3">\n  </span><span class="s1">NextConfigComplete,</span><span class="s3">\n</span><span class="s1">} from '../../server/config-shared'</span><span class="s3">\n</span><span class="s1">import type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { AppPageModule } from '../route-modules/app-page/module'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HeadData,</span><span class="s3">\n  </span><span class="s1">LoadingModuleData,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../api-utils'</span><span class="s3">\n\n</span><span class="s1">import s from 'next/dist/compiled/superstruct'</span><span class="s3">\n</span><span class="s1">import type { RequestLifecycleOpts } from '../base-server'</span><span class="s3">\n</span><span class="s1">import type { InstrumentationOnRequestError } from '../instrumentation/types'</span><span class="s3">\n</span><span class="s1">import type { NextRequestHint } from '../web/adapter'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'</span><span class="s3">\n\n</span><span class="s1">export type DynamicParamTypes =</span><span class="s3">\n  </span><span class="s1">| 'catchall'</span><span class="s3">\n  </span><span class="s1">| 'catchall-intercepted'</span><span class="s3">\n  </span><span class="s1">| 'optional-catchall'</span><span class="s3">\n  </span><span class="s1">| 'dynamic'</span><span class="s3">\n  </span><span class="s1">| 'dynamic-intercepted'</span><span class="s3">\n\n</span><span class="s1">const dynamicParamTypesSchema = s.enums(['c', 'ci', 'oc', 'd', 'di'])</span><span class="s3">\n\n</span><span class="s1">export type DynamicParamTypesShort = s.Infer&lt;typeof dynamicParamTypesSchema&gt;</span><span class="s3">\n\n</span><span class="s1">const segmentSchema = s.union([</span><span class="s3">\n  </span><span class="s1">s.string(),</span><span class="s3">\n\n  </span><span class="s1">s.tuple([</span><span class="s3">\n    </span><span class="s1">// Param name</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">// Param cache key (almost the same as the value, but arrays are</span><span class="s3">\n    </span><span class="s1">// concatenated into strings)</span><span class="s3">\n    </span><span class="s1">// TODO: We should change this to just be the value. Currently we convert</span><span class="s3">\n    </span><span class="s1">// it back to a value when passing to useParams. It only needs to be</span><span class="s3">\n    </span><span class="s1">// a string when converted to a a cache key, but that doesn't mean we</span><span class="s3">\n    </span><span class="s1">// need to store it as that representation.</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">// Dynamic param type</span><span class="s3">\n    </span><span class="s1">dynamicParamTypesSchema,</span><span class="s3">\n  </span><span class="s1">]),</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">export type Segment = s.Infer&lt;typeof segmentSchema&gt;</span><span class="s3">\n\n</span><span class="s1">// unfortunately the tuple is not understood well by Describe so we have to</span><span class="s3">\n</span><span class="s1">// use any here. This does not have any impact on the runtime type since the validation</span><span class="s3">\n</span><span class="s1">// does work correctly.</span><span class="s3">\n</span><span class="s1">export const flightRouterStateSchema: s.Describe&lt;any&gt; = s.tuple([</span><span class="s3">\n  </span><span class="s1">segmentSchema,</span><span class="s3">\n  </span><span class="s1">s.record(</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">s.lazy(() =&gt; flightRouterStateSchema)</span><span class="s3">\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">s.optional(s.nullable(s.string())),</span><span class="s3">\n  </span><span class="s1">s.optional(</span><span class="s3">\n    </span><span class="s1">s.nullable(</span><span class="s3">\n      </span><span class="s1">s.union([</span><span class="s3">\n        </span><span class="s1">s.literal('refetch'),</span><span class="s3">\n        </span><span class="s1">s.literal('refresh'),</span><span class="s3">\n        </span><span class="s1">s.literal('inside-shared-layout'),</span><span class="s3">\n        </span><span class="s1">s.literal('metadata-only'),</span><span class="s3">\n      </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">s.optional(s.boolean()),</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Router state</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightRouterState = [</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },</span><span class="s3">\n  </span><span class="s1">url?: string | null,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">refetch</span><span class="s3">\&quot;</span><span class="s1">, despite being similarly named, have different</span><span class="s3">\n   </span><span class="s1">* semantics:</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">refetch</span><span class="s3">\&quot; </span><span class="s1">is used during a request to inform the server where rendering</span><span class="s3">\n   </span><span class="s1">*   should start from.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot; </span><span class="s1">is used by the client to mark that a segment should re-fetch the</span><span class="s3">\n   </span><span class="s1">*   data from the server for the current segment. It uses the </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">property</span><span class="s3">\n   </span><span class="s1">*   above to determine where to fetch from.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">inside-shared-layout</span><span class="s3">\&quot; </span><span class="s1">is used during a prefetch request to inform the</span><span class="s3">\n   </span><span class="s1">*   server that even if the segment matches, it should be treated as if it's</span><span class="s3">\n   </span><span class="s1">*   within the </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">part of a navigation  inside the shared layout. If</span><span class="s3">\n   </span><span class="s1">*   the segment doesn't match, then it has no effect, since it would be</span><span class="s3">\n   </span><span class="s1">*   treated as new regardless. If it does match, though, the server does not</span><span class="s3">\n   </span><span class="s1">*   need to render it, because the client already has it.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">metadata-only</span><span class="s3">\&quot; </span><span class="s1">instructs the server to skip rendering the segments and</span><span class="s3">\n   </span><span class="s1">*   only send the head data.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   A bit confusing, but that's because it has only one extremely narrow use</span><span class="s3">\n   </span><span class="s1">*   case  during a non-PPR prefetch, the server uses it to find the first</span><span class="s3">\n   </span><span class="s1">*   loading boundary beneath a shared layout.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   TODO: We should rethink the protocol for dynamic requests. It might not</span><span class="s3">\n   </span><span class="s1">*   make sense for the client to send a FlightRouterState, since this type is</span><span class="s3">\n   </span><span class="s1">*   overloaded with concerns.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">refresh?:</span><span class="s3">\n    </span><span class="s1">| 'refetch'</span><span class="s3">\n    </span><span class="s1">| 'refresh'</span><span class="s3">\n    </span><span class="s1">| 'inside-shared-layout'</span><span class="s3">\n    </span><span class="s1">| 'metadata-only'</span><span class="s3">\n    </span><span class="s1">| null,</span><span class="s3">\n  </span><span class="s1">isRootLayout?: boolean,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Only present when responding to a tree prefetch request. Indicates whether</span><span class="s3">\n   </span><span class="s1">* there is a loading boundary somewhere in the tree. The client cache uses</span><span class="s3">\n   </span><span class="s1">* this to determine if it can skip the data prefetch request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasLoadingBoundary?: HasLoadingBoundary,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export const enum HasLoadingBoundary {</span><span class="s3">\n  </span><span class="s1">// There is a loading boundary in this particular segment</span><span class="s3">\n  </span><span class="s1">SegmentHasLoadingBoundary = 1,</span><span class="s3">\n  </span><span class="s1">// There is a loading boundary somewhere in the subtree (but not in</span><span class="s3">\n  </span><span class="s1">// this segment)</span><span class="s3">\n  </span><span class="s1">SubtreeHasLoadingBoundary = 2,</span><span class="s3">\n  </span><span class="s1">// There is no loading boundary in this segment or any of its descendants</span><span class="s3">\n  </span><span class="s1">SubtreeHasNoLoadingBoundary = 3,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Individual Flight response path</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightSegmentPath =</span><span class="s3">\n  </span><span class="s1">// Uses `any` as repeating pattern can't be typed.</span><span class="s3">\n  </span><span class="s1">| any[]</span><span class="s3">\n  </span><span class="s1">// Looks somewhat like this</span><span class="s3">\n  </span><span class="s1">| [</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Represents a tree of segments and the Flight data (i.e. React nodes) that</span><span class="s3">\n </span><span class="s1">* correspond to each one. The tree is isomorphic to the FlightRouterState;</span><span class="s3">\n </span><span class="s1">* however in the future we want to be able to fetch arbitrary partial segments</span><span class="s3">\n </span><span class="s1">* without having to fetch all its children. So this response format will</span><span class="s3">\n </span><span class="s1">* likely change.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type CacheNodeSeedData = [</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">node: React.ReactNode | null,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: {</span><span class="s3">\n    </span><span class="s1">[parallelRouterKey: string]: CacheNodeSeedData | null</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;,</span><span class="s3">\n  </span><span class="s1">isPartial: boolean,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type FlightDataSegment = [</span><span class="s3">\n  </span><span class="s1">/* segment of the rendered slice: */ Segment,</span><span class="s3">\n  </span><span class="s1">/* treePatch */ FlightRouterState,</span><span class="s3">\n  </span><span class="s1">/* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component</span><span class="s3">\n  </span><span class="s1">/* head: viewport */ HeadData,</span><span class="s3">\n  </span><span class="s1">/* isHeadPartial */ boolean,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type FlightDataPath =</span><span class="s3">\n  </span><span class="s1">// Uses `any` as repeating pattern can't be typed.</span><span class="s3">\n  </span><span class="s1">| any[]</span><span class="s3">\n  </span><span class="s1">// Looks somewhat like this</span><span class="s3">\n  </span><span class="s1">| [</span><span class="s3">\n      </span><span class="s1">// Holds full path to the segment.</span><span class="s3">\n      </span><span class="s1">...FlightSegmentPath[],</span><span class="s3">\n      </span><span class="s1">...FlightDataSegment,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Flight response data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightData = Array&lt;FlightDataPath&gt; | string</span><span class="s3">\n\n</span><span class="s1">export type ActionResult = Promise&lt;any&gt;</span><span class="s3">\n\n</span><span class="s1">export type ServerOnInstrumentationRequestError = (</span><span class="s3">\n  </span><span class="s1">error: unknown,</span><span class="s3">\n  </span><span class="s1">// The request could be middleware, node server or web server request,</span><span class="s3">\n  </span><span class="s1">// we normalized them into an aligned format to `onRequestError` API later.</span><span class="s3">\n  </span><span class="s1">request: NextRequestHint | BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">errorContext: Parameters&lt;InstrumentationOnRequestError&gt;[2]</span><span class="s3">\n</span><span class="s1">) =&gt; void | Promise&lt;void&gt;</span><span class="s3">\n\n</span><span class="s1">export interface RenderOptsPartial {</span><span class="s3">\n  </span><span class="s1">dir?: string</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps | undefined</span><span class="s3">\n  </span><span class="s1">err?: Error | null</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">trailingSlash: boolean</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest?: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">supportsDynamicResponse: boolean</span><span class="s3">\n  </span><span class="s1">runtime?: ServerRuntime</span><span class="s3">\n  </span><span class="s1">serverComponents?: boolean</span><span class="s3">\n  </span><span class="s1">enableTainting?: boolean</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined</span><span class="s3">\n  </span><span class="s1">nextFontManifest?: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n  </span><span class="s1">botType?: 'dom' | 'html' | undefined</span><span class="s3">\n  </span><span class="s1">serveStreamingMetadata?: boolean</span><span class="s3">\n  </span><span class="s1">incrementalCache?: import('../lib/incremental-cache').IncrementalCache</span><span class="s3">\n  </span><span class="s1">cacheLifeProfiles?: {</span><span class="s3">\n    </span><span class="s1">[profile: string]: import('../use-cache/cache-life').CacheLife</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction?: boolean</span><span class="s3">\n  </span><span class="s1">setIsrStatus?: (key: string, value: boolean | null) =&gt; void</span><span class="s3">\n  </span><span class="s1">isRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">nextExport?: boolean</span><span class="s3">\n  </span><span class="s1">nextConfigOutput?: 'standalone' | 'export'</span><span class="s3">\n  </span><span class="s1">onInstrumentationRequestError?: ServerOnInstrumentationRequestError</span><span class="s3">\n  </span><span class="s1">isDraftMode?: boolean</span><span class="s3">\n  </span><span class="s1">deploymentId?: string</span><span class="s3">\n  </span><span class="s1">onUpdateCookies?: (cookies: string[]) =&gt; void</span><span class="s3">\n  </span><span class="s1">loadConfig?: (</span><span class="s3">\n    </span><span class="s1">phase: string,</span><span class="s3">\n    </span><span class="s1">dir: string,</span><span class="s3">\n    </span><span class="s1">customConfig?: object | null,</span><span class="s3">\n    </span><span class="s1">rawConfig?: boolean,</span><span class="s3">\n    </span><span class="s1">silent?: boolean</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;NextConfigComplete&gt;</span><span class="s3">\n  </span><span class="s1">serverActions?: {</span><span class="s3">\n    </span><span class="s1">bodySizeLimit?: SizeLimit</span><span class="s3">\n    </span><span class="s1">allowedOrigins?: string[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n  </span><span class="s1">htmlLimitedBots: string | undefined</span><span class="s3">\n  </span><span class="s1">experimental: {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When true, it indicates that the current page supports partial</span><span class="s3">\n     </span><span class="s1">* prerendering.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">expireTime: number | undefined</span><span class="s3">\n    </span><span class="s1">staleTimes: ExperimentalConfig['staleTimes'] | undefined</span><span class="s3">\n    </span><span class="s1">clientTraceMetadata: string[] | undefined</span><span class="s3">\n    </span><span class="s1">cacheComponents: boolean</span><span class="s3">\n    </span><span class="s1">clientSegmentCache: boolean | 'client-only'</span><span class="s3">\n    </span><span class="s1">clientParamParsing: boolean</span><span class="s3">\n    </span><span class="s1">dynamicOnHover: boolean</span><span class="s3">\n    </span><span class="s1">inlineCss: boolean</span><span class="s3">\n    </span><span class="s1">authInterrupts: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Should wait for react stream allReady to resolve all suspense boundaries,</span><span class="s3">\n   </span><span class="s1">* in order to perform a full page render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">shouldWaitOnAllReady?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A prefilled resume data cache. This was either generated for this page</span><span class="s3">\n   </span><span class="s1">* during dev warmup, or when a page with defined params was previously</span><span class="s3">\n   </span><span class="s1">* prerendered, and now its matching optional fallback shell is prerendered.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, the page will be rendered using the static rendering to detect</span><span class="s3">\n   </span><span class="s1">* any dynamic API's that would have stopped the page from being fully</span><span class="s3">\n   </span><span class="s1">* statically generated.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isDebugDynamicAccesses?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is true when:</span><span class="s3">\n   </span><span class="s1">* - source maps are generated</span><span class="s3">\n   </span><span class="s1">* - source maps are applied</span><span class="s3">\n   </span><span class="s1">* - minification is disabled</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasReadableErrorStacks?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The maximum length of the headers that are emitted by React and added to</span><span class="s3">\n   </span><span class="s1">* the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">reactMaxHeadersLength: number | undefined</span><span class="s3">\n\n  </span><span class="s1">isStaticGeneration?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, the page is prerendered as a fallback shell, while allowing any</span><span class="s3">\n   </span><span class="s1">* dynamic accesses to result in an empty shell. This is the case when there</span><span class="s3">\n   </span><span class="s1">* are also routes prerendered with a more complete set of params.</span><span class="s3">\n   </span><span class="s1">* Prerendering those routes would catch any invalid dynamic accesses.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">allowEmptyStaticShell?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* next config experimental.devtoolSegmentExplorer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">devtoolSegmentExplorer?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderOpts = LoadComponentsReturnType&lt;AppPageModule&gt; &amp;</span><span class="s3">\n  </span><span class="s1">RenderOptsPartial &amp;</span><span class="s3">\n  </span><span class="s1">RequestLifecycleOpts</span><span class="s3">\n\n</span><span class="s1">export type PreloadCallbacks = (() =&gt; void)[]</span><span class="s3">\n\n</span><span class="s1">export type InitialRSCPayload = {</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** assetPrefix */</span><span class="s3">\n  </span><span class="s1">p: string</span><span class="s3">\n  </span><span class="s1">/** initialCanonicalUrlParts */</span><span class="s3">\n  </span><span class="s1">c: string[]</span><span class="s3">\n  </span><span class="s1">/** couldBeIntercepted */</span><span class="s3">\n  </span><span class="s1">i: boolean</span><span class="s3">\n  </span><span class="s1">/** initialFlightData */</span><span class="s3">\n  </span><span class="s1">f: FlightDataPath[]</span><span class="s3">\n  </span><span class="s1">/** missingSlots */</span><span class="s3">\n  </span><span class="s1">m: Set&lt;string&gt; | undefined</span><span class="s3">\n  </span><span class="s1">/** GlobalError */</span><span class="s3">\n  </span><span class="s1">G: [React.ComponentType&lt;any&gt;, React.ReactNode | undefined]</span><span class="s3">\n  </span><span class="s1">/** postponed */</span><span class="s3">\n  </span><span class="s1">s: boolean</span><span class="s3">\n  </span><span class="s1">/** prerendered */</span><span class="s3">\n  </span><span class="s1">S: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Response from `createFromFetch` for normal rendering</span><span class="s3">\n</span><span class="s1">export type NavigationFlightResponse = {</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** flightData */</span><span class="s3">\n  </span><span class="s1">f: FlightData</span><span class="s3">\n  </span><span class="s1">/** prerendered */</span><span class="s3">\n  </span><span class="s1">S: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Response from `createFromFetch` for server actions. Action's flight data can be null</span><span class="s3">\n</span><span class="s1">export type ActionFlightResponse = {</span><span class="s3">\n  </span><span class="s1">/** actionResult */</span><span class="s3">\n  </span><span class="s1">a: ActionResult</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** flightData */</span><span class="s3">\n  </span><span class="s1">f: FlightData</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RSCPayload =</span><span class="s3">\n  </span><span class="s1">| InitialRSCPayload</span><span class="s3">\n  </span><span class="s1">| NavigationFlightResponse</span><span class="s3">\n  </span><span class="s1">| ActionFlightResponse</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const RSC_HEADER = 'rsc' as const</span><span class="s3">\n</span><span class="s1">export const ACTION_HEADER = 'next-action' as const</span><span class="s3">\n</span><span class="s1">// TODO: Instead of sending the full router state, we only need to send the</span><span class="s3">\n</span><span class="s1">// segment path. Saves bytes. Then we could also use this field for segment</span><span class="s3">\n</span><span class="s1">// prefetches, which also need to specify a particular segment.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const</span><span class="s3">\n</span><span class="s1">// This contains the path to the segment being prefetched.</span><span class="s3">\n</span><span class="s1">// TODO: If we change next-router-state-tree to be a segment path, we can use</span><span class="s3">\n</span><span class="s1">// that instead. Then next-router-prefetch and next-router-segment-prefetch can</span><span class="s3">\n</span><span class="s1">// be merged into a single enum.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =</span><span class="s3">\n  </span><span class="s1">'next-router-segment-prefetch' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_URL = 'next-url' as const</span><span class="s3">\n</span><span class="s1">export const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const</span><span class="s3">\n\n</span><span class="s1">export const FLIGHT_HEADERS = [</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_HMR_REFRESH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_RSC_UNION_QUERY = '_rsc' as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { NEXT_URL } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Rewrite } from './load-custom-routes'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp } from '../shared/lib/router/utils/route-match-utils'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)</span><span class="s3">\n</span><span class="s1">function toPathToRegexpPath(path: string): string {</span><span class="s3">\n  </span><span class="s1">return path.replace(/</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">[?([^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">]?/g, (_, capture) =&gt; {</span><span class="s3">\n    </span><span class="s1">// path-to-regexp only supports word characters, so we replace any non-word characters with underscores</span><span class="s3">\n    </span><span class="s1">const paramName = capture.replace(/</span><span class="s3">\\</span><span class="s1">W+/g, '_')</span><span class="s3">\n\n    </span><span class="s1">// handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])</span><span class="s3">\n    </span><span class="s1">if (capture.startsWith('...')) {</span><span class="s3">\n      </span><span class="s1">return `:${capture.slice(3)}*`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ':' + paramName</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateInterceptionRoutesRewrites(</span><span class="s3">\n  </span><span class="s1">appPaths: string[],</span><span class="s3">\n  </span><span class="s1">basePath = ''</span><span class="s3">\n</span><span class="s1">): Rewrite[] {</span><span class="s3">\n  </span><span class="s1">const rewrites: Rewrite[] = []</span><span class="s3">\n\n  </span><span class="s1">for (const appPath of appPaths) {</span><span class="s3">\n    </span><span class="s1">if (isInterceptionRouteAppPath(appPath)) {</span><span class="s3">\n      </span><span class="s1">const { interceptingRoute, interceptedRoute } =</span><span class="s3">\n        </span><span class="s1">extractInterceptionRouteInformation(appPath)</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptingRoute = `${</span><span class="s3">\n        </span><span class="s1">interceptingRoute !== '/' ? toPathToRegexpPath(interceptingRoute) : ''</span><span class="s3">\n      </span><span class="s1">}/(.*)?`</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute)</span><span class="s3">\n      </span><span class="s1">const normalizedAppPath = toPathToRegexpPath(appPath)</span><span class="s3">\n\n      </span><span class="s1">// pathToRegexp returns a regex that matches the path, but we need to</span><span class="s3">\n      </span><span class="s1">// convert it to a string that can be used in a header value</span><span class="s3">\n      </span><span class="s1">// to the format that Next/the proxy expects</span><span class="s3">\n      </span><span class="s1">let interceptingRouteRegex = safePathToRegexp(normalizedInterceptingRoute)</span><span class="s3">\n        </span><span class="s1">.toString()</span><span class="s3">\n        </span><span class="s1">.slice(2, -3)</span><span class="s3">\n\n      </span><span class="s1">rewrites.push({</span><span class="s3">\n        </span><span class="s1">source: `${basePath}${normalizedInterceptedRoute}`,</span><span class="s3">\n        </span><span class="s1">destination: `${basePath}${normalizedAppPath}`,</span><span class="s3">\n        </span><span class="s1">has: [</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">type: 'header',</span><span class="s3">\n            </span><span class="s1">key: NEXT_URL,</span><span class="s3">\n            </span><span class="s1">value: interceptingRouteRegex,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">],</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return rewrites</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteRewrite(route: DeepReadonly&lt;Rewrite&gt;) {</span><span class="s3">\n  </span><span class="s1">// When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.</span><span class="s3">\n  </span><span class="s1">return route.has?.[0]?.key === NEXT_URL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Rewrite } from '../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { RouteMatchFn } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import type { NextConfig } from './config'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n\n</span><span class="s1">import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { getPathMatch } from '../shared/lib/router/utils/path-match'</span><span class="s3">\n</span><span class="s1">import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'</span><span class="s3">\n</span><span class="s1">import { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">matchHas,</span><span class="s3">\n  </span><span class="s1">prepareDestination,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/prepare-destination'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { normalizeRscURL } from '../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATED_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import { normalizeNextQueryParam } from './web/utils'</span><span class="s3">\n</span><span class="s1">import type { IncomingHttpHeaders, IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import { parseReqUrl } from '../lib/url'</span><span class="s3">\n</span><span class="s1">import { formatUrl } from '../shared/lib/router/utils/format-url'</span><span class="s3">\n</span><span class="s1">import { parseAndValidateFlightRouterState } from './app-render/parse-and-validate-flight-router-state'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites'</span><span class="s3">\n</span><span class="s1">import { NEXT_ROUTER_STATE_TREE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { getSelectedParams } from '../client/components/router-reducer/compute-changed-path'</span><span class="s3">\n\n</span><span class="s1">function filterInternalQuery(</span><span class="s3">\n  </span><span class="s1">query: Record&lt;string, undefined | string | string[]&gt;,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n  </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n  </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n  </span><span class="s1">for (const key in query) {</span><span class="s3">\n    </span><span class="s1">const isNextQueryPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_QUERY_PARAM_PREFIX &amp;&amp; key.startsWith(NEXT_QUERY_PARAM_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">const isNextInterceptionMarkerPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_INTERCEPTION_MARKER_PREFIX &amp;&amp;</span><span class="s3">\n      </span><span class="s1">key.startsWith(NEXT_INTERCEPTION_MARKER_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isNextQueryPrefix ||</span><span class="s3">\n      </span><span class="s1">isNextInterceptionMarkerPrefix ||</span><span class="s3">\n      </span><span class="s1">paramKeys.includes(key)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeCdnUrl(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// make sure to normalize req.url from CDNs to strip dynamic and rewrite</span><span class="s3">\n  </span><span class="s1">// params from the query which are added during routing</span><span class="s3">\n  </span><span class="s1">const _parsedUrl = parseReqUrl(req.url!)</span><span class="s3">\n\n  </span><span class="s1">// we can't normalize if we can't parse</span><span class="s3">\n  </span><span class="s1">if (!_parsedUrl) {</span><span class="s3">\n    </span><span class="s1">return req.url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">delete (_parsedUrl as any).search</span><span class="s3">\n  </span><span class="s1">filterInternalQuery(_parsedUrl.query, paramKeys)</span><span class="s3">\n\n  </span><span class="s1">req.url = formatUrl(_parsedUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function interpolateDynamicPath(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">params: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex?: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!defaultRouteRegex) return pathname</span><span class="s3">\n\n  </span><span class="s1">for (const param of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">const { optional, repeat } = defaultRouteRegex.groups[param]</span><span class="s3">\n    </span><span class="s1">let builtParam = `[${repeat ? '...' : ''}${param}]`</span><span class="s3">\n\n    </span><span class="s1">if (optional) {</span><span class="s3">\n      </span><span class="s1">builtParam = `[${builtParam}]`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let paramValue: string</span><span class="s3">\n    </span><span class="s1">const value = params[param]</span><span class="s3">\n\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">paramValue = value.map((v) =&gt; v &amp;&amp; encodeURIComponent(v)).join('/')</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">paramValue = encodeURIComponent(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">paramValue = ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (paramValue || optional) {</span><span class="s3">\n      </span><span class="s1">pathname = pathname.replaceAll(builtParam, paramValue)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeDynamicRouteParams(</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt;,</span><span class="s3">\n  </span><span class="s1">defaultRouteMatches: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let hasValidParams = true</span><span class="s3">\n  </span><span class="s1">let params: ParsedUrlQuery = {}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">let value: string | string[] | undefined = query[key]</span><span class="s3">\n\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">value = normalizeRscURL(value)</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">value = value.map(normalizeRscURL)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the value matches the default value we can't rely</span><span class="s3">\n    </span><span class="s1">// on the parsed params, this is used to signal if we need</span><span class="s3">\n    </span><span class="s1">// to parse x-now-route-matches or not</span><span class="s3">\n    </span><span class="s1">const defaultValue = defaultRouteMatches![key]</span><span class="s3">\n    </span><span class="s1">const isOptional = defaultRouteRegex!.groups[key].optional</span><span class="s3">\n\n    </span><span class="s1">const isDefaultValue = Array.isArray(defaultValue)</span><span class="s3">\n      </span><span class="s1">? defaultValue.some((defaultVal) =&gt; {</span><span class="s3">\n          </span><span class="s1">return Array.isArray(value)</span><span class="s3">\n            </span><span class="s1">? value.some((val) =&gt; val.includes(defaultVal))</span><span class="s3">\n            </span><span class="s1">: value?.includes(defaultVal)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">: value?.includes(defaultValue as string)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isDefaultValue ||</span><span class="s3">\n      </span><span class="s1">(typeof value === 'undefined' &amp;&amp; !(isOptional &amp;&amp; ignoreMissingOptional))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// non-provided optional values should be undefined so normalize</span><span class="s3">\n    </span><span class="s1">// them to undefined</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isOptional &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!value ||</span><span class="s3">\n        </span><span class="s1">(Array.isArray(value) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">value.length === 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// fallback optional catch-all SSG pages have</span><span class="s3">\n          </span><span class="s1">// [[...paramName]] for the root path on Vercel</span><span class="s3">\n          </span><span class="s1">(value[0] === 'index' || value[0] === `[[...${key}]]`)))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = undefined</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// query values from the proxy aren't already split into arrays</span><span class="s3">\n    </span><span class="s1">// so make sure to normalize catch-all values</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">value &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof value === 'string' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">defaultRouteRegex!.groups[key].repeat</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = value.split('/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (value) {</span><span class="s3">\n      </span><span class="s1">params[key] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">hasValidParams,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getServerUtils({</span><span class="s3">\n  </span><span class="s1">page,</span><span class="s3">\n  </span><span class="s1">i18n,</span><span class="s3">\n  </span><span class="s1">basePath,</span><span class="s3">\n  </span><span class="s1">rewrites,</span><span class="s3">\n  </span><span class="s1">pageIsDynamic,</span><span class="s3">\n  </span><span class="s1">trailingSlash,</span><span class="s3">\n  </span><span class="s1">caseSensitive,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">i18n?: NextConfig['i18n']</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">rewrites: DeepReadonly&lt;{</span><span class="s3">\n    </span><span class="s1">fallback?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">afterFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">beforeFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n  </span><span class="s1">pageIsDynamic: boolean</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">caseSensitive: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n  </span><span class="s1">let dynamicRouteMatcher: RouteMatchFn | undefined</span><span class="s3">\n  </span><span class="s1">let defaultRouteMatches: ParsedUrlQuery | undefined</span><span class="s3">\n\n  </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex = getNamedRouteRegex(page, {</span><span class="s3">\n      </span><span class="s1">prefixRouteKeys: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleRewrites(</span><span class="s3">\n    </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const rewriteParams: Record&lt;string, string&gt; = {}</span><span class="s3">\n    </span><span class="s1">let fsPathname = parsedUrl.pathname</span><span class="s3">\n\n    </span><span class="s1">const matchesPage = () =&gt; {</span><span class="s3">\n      </span><span class="s1">const fsPathnameNoSlash = removeTrailingSlash(fsPathname || '')</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">fsPathnameNoSlash === removeTrailingSlash(page) ||</span><span class="s3">\n        </span><span class="s1">dynamicRouteMatcher?.(fsPathnameNoSlash)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const checkRewrite = (rewrite: DeepReadonly&lt;Rewrite&gt;): boolean =&gt; {</span><span class="s3">\n      </span><span class="s1">const matcher = getPathMatch(</span><span class="s3">\n        </span><span class="s1">rewrite.source + (trailingSlash ? '(/)?' : ''),</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">removeUnnamedParams: true,</span><span class="s3">\n          </span><span class="s1">strict: true,</span><span class="s3">\n          </span><span class="s1">sensitive: !!caseSensitive,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (!parsedUrl.pathname) return false</span><span class="s3">\n\n      </span><span class="s1">let params = matcher(parsedUrl.pathname)</span><span class="s3">\n\n      </span><span class="s1">if ((rewrite.has || rewrite.missing) &amp;&amp; params) {</span><span class="s3">\n        </span><span class="s1">const hasParams = matchHas(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">parsedUrl.query,</span><span class="s3">\n          </span><span class="s1">rewrite.has as Rewrite['has'],</span><span class="s3">\n          </span><span class="s1">rewrite.missing as Rewrite['missing']</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (hasParams) {</span><span class="s3">\n          </span><span class="s1">Object.assign(params, hasParams)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (params) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">// An interception rewrite might reference a dynamic param for a route the user</span><span class="s3">\n          </span><span class="s1">// is currently on, which wouldn't be extractable from the matched route params.</span><span class="s3">\n          </span><span class="s1">// This attempts to extract the dynamic params from the provided router state.</span><span class="s3">\n          </span><span class="s1">if (isInterceptionRouteRewrite(rewrite as Rewrite)) {</span><span class="s3">\n            </span><span class="s1">const stateHeader = req.headers[NEXT_ROUTER_STATE_TREE_HEADER]</span><span class="s3">\n\n            </span><span class="s1">if (stateHeader) {</span><span class="s3">\n              </span><span class="s1">params = {</span><span class="s3">\n                </span><span class="s1">...getSelectedParams(</span><span class="s3">\n                  </span><span class="s1">parseAndValidateFlightRouterState(stateHeader)</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">...params,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">// this is a no-op -- we couldn't extract dynamic params from the provided router state,</span><span class="s3">\n          </span><span class="s1">// so we'll just use the params from the route matcher</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const { parsedDestination, destQuery } = prepareDestination({</span><span class="s3">\n          </span><span class="s1">appendParamsToQuery: true,</span><span class="s3">\n          </span><span class="s1">destination: rewrite.destination,</span><span class="s3">\n          </span><span class="s1">params: params,</span><span class="s3">\n          </span><span class="s1">query: parsedUrl.query,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">// if the rewrite destination is external break rewrite chain</span><span class="s3">\n        </span><span class="s1">if (parsedDestination.protocol) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">Object.assign(rewriteParams, destQuery, params)</span><span class="s3">\n        </span><span class="s1">Object.assign(parsedUrl.query, parsedDestination.query)</span><span class="s3">\n        </span><span class="s1">delete (parsedDestination as any).query</span><span class="s3">\n\n        </span><span class="s1">// for each property in parsedUrl.query, if the value is parametrized (eg :foo), look up the value</span><span class="s3">\n        </span><span class="s1">// in rewriteParams and replace the parametrized value with the actual value</span><span class="s3">\n        </span><span class="s1">// this is used when the rewrite destination does not contain the original source param</span><span class="s3">\n        </span><span class="s1">// and so the value is still parametrized and needs to be replaced with the actual rewrite param</span><span class="s3">\n        </span><span class="s1">Object.entries(parsedUrl.query).forEach(([key, value]) =&gt; {</span><span class="s3">\n          </span><span class="s1">if (value &amp;&amp; typeof value === 'string' &amp;&amp; value.startsWith(':')) {</span><span class="s3">\n            </span><span class="s1">const paramName = value.slice(1)</span><span class="s3">\n            </span><span class="s1">const actualValue = rewriteParams[paramName]</span><span class="s3">\n            </span><span class="s1">if (actualValue) {</span><span class="s3">\n              </span><span class="s1">parsedUrl.query[key] = actualValue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">Object.assign(parsedUrl, parsedDestination)</span><span class="s3">\n\n        </span><span class="s1">fsPathname = parsedUrl.pathname</span><span class="s3">\n        </span><span class="s1">if (!fsPathname) return false</span><span class="s3">\n\n        </span><span class="s1">if (basePath) {</span><span class="s3">\n          </span><span class="s1">fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (i18n) {</span><span class="s3">\n          </span><span class="s1">const result = normalizeLocalePath(fsPathname, i18n.locales)</span><span class="s3">\n          </span><span class="s1">fsPathname = result.pathname</span><span class="s3">\n          </span><span class="s1">parsedUrl.query.nextInternalLocale =</span><span class="s3">\n            </span><span class="s1">result.detectedLocale || params.nextInternalLocale</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (fsPathname === page) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (pageIsDynamic &amp;&amp; dynamicRouteMatcher) {</span><span class="s3">\n          </span><span class="s1">const dynamicParams = dynamicRouteMatcher(fsPathname)</span><span class="s3">\n          </span><span class="s1">if (dynamicParams) {</span><span class="s3">\n            </span><span class="s1">parsedUrl.query = {</span><span class="s3">\n              </span><span class="s1">...parsedUrl.query,</span><span class="s3">\n              </span><span class="s1">...dynamicParams,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const rewrite of rewrites.beforeFiles || []) {</span><span class="s3">\n      </span><span class="s1">checkRewrite(rewrite)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (fsPathname !== page) {</span><span class="s3">\n      </span><span class="s1">let finished = false</span><span class="s3">\n\n      </span><span class="s1">for (const rewrite of rewrites.afterFiles || []) {</span><span class="s3">\n        </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n        </span><span class="s1">if (finished) break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!finished &amp;&amp; !matchesPage()) {</span><span class="s3">\n        </span><span class="s1">for (const rewrite of rewrites.fallback || []) {</span><span class="s3">\n          </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n          </span><span class="s1">if (finished) break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return rewriteParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function getParamsFromRouteMatches(routeMatchesHeader: string) {</span><span class="s3">\n    </span><span class="s1">// If we don't have a default route regex, we can't get params from route</span><span class="s3">\n    </span><span class="s1">// matches</span><span class="s3">\n    </span><span class="s1">if (!defaultRouteRegex) return null</span><span class="s3">\n\n    </span><span class="s1">const { groups, routeKeys } = defaultRouteRegex</span><span class="s3">\n\n    </span><span class="s1">const matcher = getRouteMatcher({</span><span class="s3">\n      </span><span class="s1">re: {</span><span class="s3">\n        </span><span class="s1">// Simulate a RegExp match from the </span><span class="s3">\\</span><span class="s1">`req.url</span><span class="s3">\\</span><span class="s1">` input</span><span class="s3">\n        </span><span class="s1">exec: (str: string) =&gt; {</span><span class="s3">\n          </span><span class="s1">// Normalize all the prefixed query params.</span><span class="s3">\n          </span><span class="s1">const obj: Record&lt;string, string&gt; = Object.fromEntries(</span><span class="s3">\n            </span><span class="s1">new URLSearchParams(str)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">for (const [key, value] of Object.entries(obj)) {</span><span class="s3">\n            </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n            </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n            </span><span class="s1">obj[normalizedKey] = value</span><span class="s3">\n            </span><span class="s1">delete obj[key]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Use all the named route keys.</span><span class="s3">\n          </span><span class="s1">const result = {} as RegExpExecArray</span><span class="s3">\n          </span><span class="s1">for (const keyName of Object.keys(routeKeys)) {</span><span class="s3">\n            </span><span class="s1">const paramName = routeKeys[keyName]</span><span class="s3">\n\n            </span><span class="s1">// If this param name is not a valid parameter name, then skip it.</span><span class="s3">\n            </span><span class="s1">if (!paramName) continue</span><span class="s3">\n\n            </span><span class="s1">const group = groups[paramName]</span><span class="s3">\n            </span><span class="s1">const value = obj[keyName]</span><span class="s3">\n\n            </span><span class="s1">// When we're missing a required param, we can't match the route.</span><span class="s3">\n            </span><span class="s1">if (!group.optional &amp;&amp; !value) return null</span><span class="s3">\n\n            </span><span class="s1">result[group.pos] = value</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return result</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">groups,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const routeMatches = matcher(routeMatchesHeader)</span><span class="s3">\n    </span><span class="s1">if (!routeMatches) return null</span><span class="s3">\n\n    </span><span class="s1">return routeMatches</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function normalizeQueryParams(</span><span class="s3">\n    </span><span class="s1">query: Record&lt;string, string | string[] | undefined&gt;,</span><span class="s3">\n    </span><span class="s1">routeParamKeys: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n    </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n    </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n    </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n      </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n      </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n      </span><span class="s1">// Remove the prefixed key from the query params because we want</span><span class="s3">\n      </span><span class="s1">// to consume it for the dynamic route matcher.</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n      </span><span class="s1">routeParamKeys.add(normalizedKey)</span><span class="s3">\n\n      </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n\n      </span><span class="s1">query[normalizedKey] = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.map((v) =&gt; decodeQueryPathParameter(v))</span><span class="s3">\n        </span><span class="s1">: decodeQueryPathParameter(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">handleRewrites,</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher,</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n    </span><span class="s1">normalizeQueryParams,</span><span class="s3">\n    </span><span class="s1">getParamsFromRouteMatches,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Normalize dynamic route params.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param query - The query params to normalize.</span><span class="s3">\n     </span><span class="s1">* @param ignoreMissingOptional - Whether to ignore missing optional params.</span><span class="s3">\n     </span><span class="s1">* @returns The normalized params and whether they are valid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">normalizeDynamicRouteParams: (</span><span class="s3">\n      </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n      </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n    </span><span class="s1">) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!defaultRouteRegex || !defaultRouteMatches) {</span><span class="s3">\n        </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">query,</span><span class="s3">\n        </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n        </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n        </span><span class="s1">ignoreMissingOptional</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">normalizeCdnUrl: (</span><span class="s3">\n      </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n      </span><span class="s1">paramKeys: string[]</span><span class="s3">\n    </span><span class="s1">) =&gt; normalizeCdnUrl(req, paramKeys),</span><span class="s3">\n\n    </span><span class="s1">interpolateDynamicPath: (</span><span class="s3">\n      </span><span class="s1">pathname: string,</span><span class="s3">\n      </span><span class="s1">params: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; interpolateDynamicPath(pathname, params, defaultRouteRegex),</span><span class="s3">\n\n    </span><span class="s1">filterInternalQuery: (query: ParsedUrlQuery, paramKeys: string[]) =&gt;</span><span class="s3">\n      </span><span class="s1">filterInternalQuery(query, paramKeys),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getPreviouslyRevalidatedTags(</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">previewModeId: string | undefined</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">return typeof headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">headers[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === previewModeId</span><span class="s3">\n    </span><span class="s1">? headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')</span><span class="s3">\n    </span><span class="s1">: []</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isPlainObject } from '../shared/lib/is-plain-object'</span><span class="s3">\n\n</span><span class="s1">// We allow some additional attached properties for Next.js errors</span><span class="s3">\n</span><span class="s1">export interface NextError extends Error {</span><span class="s3">\n  </span><span class="s1">type?: string</span><span class="s3">\n  </span><span class="s1">page?: string</span><span class="s3">\n  </span><span class="s1">code?: string | number</span><span class="s3">\n  </span><span class="s1">cancelled?: boolean</span><span class="s3">\n  </span><span class="s1">digest?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks whether the given value is a NextError.</span><span class="s3">\n </span><span class="s1">* This can be used to print a more detailed error message with properties like `code` &amp; `digest`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isError(err: unknown): err is NextError {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof err === 'object' &amp;&amp; err !== null &amp;&amp; 'name' in err &amp;&amp; 'message' in err</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function safeStringify(obj: any) {</span><span class="s3">\n  </span><span class="s1">const seen = new WeakSet()</span><span class="s3">\n\n  </span><span class="s1">return JSON.stringify(obj, (_key, value) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If value is an object and already seen, replace with </span><span class="s3">\&quot;</span><span class="s1">[Circular]</span><span class="s3">\&quot;\n    </span><span class="s1">if (typeof value === 'object' &amp;&amp; value !== null) {</span><span class="s3">\n      </span><span class="s1">if (seen.has(value)) {</span><span class="s3">\n        </span><span class="s1">return '[Circular]'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">seen.add(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getProperError(err: unknown): Error {</span><span class="s3">\n  </span><span class="s1">if (isError(err)) {</span><span class="s3">\n    </span><span class="s1">return err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">// provide better error for case where `throw undefined`</span><span class="s3">\n    </span><span class="s1">// is called in development</span><span class="s3">\n    </span><span class="s1">if (typeof err === 'undefined') {</span><span class="s3">\n      </span><span class="s1">return new Error(</span><span class="s3">\n        </span><span class="s1">'An undefined error was thrown, ' +</span><span class="s3">\n          </span><span class="s1">'see here for more info: https://nextjs.org/docs/messages/threw-undefined'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (err === null) {</span><span class="s3">\n      </span><span class="s1">return new Error(</span><span class="s3">\n        </span><span class="s1">'A null error was thrown, ' +</span><span class="s3">\n          </span><span class="s1">'see here for more info: https://nextjs.org/docs/messages/threw-undefined'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new Error(isPlainObject(err) ? safeStringify(err) : err + '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function getObjectClassLabel(value: any): string {</span><span class="s3">\n  </span><span class="s1">return Object.prototype.toString.call(value)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isPlainObject(value: any): boolean {</span><span class="s3">\n  </span><span class="s1">if (getObjectClassLabel(value) !== '[object Object]') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const prototype = Object.getPrototypeOf(value)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* this used to be previously:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* `return prototype === null || prototype === Object.prototype`</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* It was changed to the current implementation since it's resilient to serialization.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">return prototype === null || prototype.hasOwnProperty('isPrototypeOf')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { I18NProvider } from '../lib/i18n-provider'</span><span class="s3">\n</span><span class="s1">import type { Normalizer } from './normalizer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes the pathname by removing the locale prefix if any.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class LocaleRouteNormalizer implements Normalizer {</span><span class="s3">\n  </span><span class="s1">constructor(private readonly provider: I18NProvider) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Normalizes the pathname by removing the locale prefix if any.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname The pathname to normalize.</span><span class="s3">\n   </span><span class="s1">* @returns The pathname without the locale prefix (if any).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public normalize(pathname: string): string {</span><span class="s3">\n    </span><span class="s1">const match = this.provider.analyze(pathname)</span><span class="s3">\n    </span><span class="s1">return match.pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;class UrlNode {</span><span class="s3">\n  </span><span class="s1">placeholder: boolean = true</span><span class="s3">\n  </span><span class="s1">children: Map&lt;string, UrlNode&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">slugName: string | null = null</span><span class="s3">\n  </span><span class="s1">restSlugName: string | null = null</span><span class="s3">\n  </span><span class="s1">optionalRestSlugName: string | null = null</span><span class="s3">\n\n  </span><span class="s1">insert(urlPath: string): void {</span><span class="s3">\n    </span><span class="s1">this._insert(urlPath.split('/').filter(Boolean), [], false)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">smoosh(): string[] {</span><span class="s3">\n    </span><span class="s1">return this._smoosh()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private _smoosh(prefix: string = '/'): string[] {</span><span class="s3">\n    </span><span class="s1">const childrenPaths = [...this.children.keys()].sort()</span><span class="s3">\n    </span><span class="s1">if (this.slugName !== null) {</span><span class="s3">\n      </span><span class="s1">childrenPaths.splice(childrenPaths.indexOf('[]'), 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.restSlugName !== null) {</span><span class="s3">\n      </span><span class="s1">childrenPaths.splice(childrenPaths.indexOf('[...]'), 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.optionalRestSlugName !== null) {</span><span class="s3">\n      </span><span class="s1">childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const routes = childrenPaths</span><span class="s3">\n      </span><span class="s1">.map((c) =&gt; this.children.get(c)!._smoosh(`${prefix}${c}/`))</span><span class="s3">\n      </span><span class="s1">.reduce((prev, curr) =&gt; [...prev, ...curr], [])</span><span class="s3">\n\n    </span><span class="s1">if (this.slugName !== null) {</span><span class="s3">\n      </span><span class="s1">routes.push(</span><span class="s3">\n        </span><span class="s1">...this.children.get('[]')!._smoosh(`${prefix}[${this.slugName}]/`)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.placeholder) {</span><span class="s3">\n      </span><span class="s1">const r = prefix === '/' ? '/' : prefix.slice(0, -1)</span><span class="s3">\n      </span><span class="s1">if (this.optionalRestSlugName != null) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`You cannot define a route with the same specificity as a optional catch-all route (</span><span class="s3">\&quot;</span><span class="s1">${r}</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">${r}[[...${this.optionalRestSlugName}]]</span><span class="s3">\&quot;</span><span class="s1">).`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">routes.unshift(r)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.restSlugName !== null) {</span><span class="s3">\n      </span><span class="s1">routes.push(</span><span class="s3">\n        </span><span class="s1">...this.children</span><span class="s3">\n          </span><span class="s1">.get('[...]')!</span><span class="s3">\n          </span><span class="s1">._smoosh(`${prefix}[...${this.restSlugName}]/`)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.optionalRestSlugName !== null) {</span><span class="s3">\n      </span><span class="s1">routes.push(</span><span class="s3">\n        </span><span class="s1">...this.children</span><span class="s3">\n          </span><span class="s1">.get('[[...]]')!</span><span class="s3">\n          </span><span class="s1">._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return routes</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private _insert(</span><span class="s3">\n    </span><span class="s1">urlPaths: string[],</span><span class="s3">\n    </span><span class="s1">slugNames: string[],</span><span class="s3">\n    </span><span class="s1">isCatchAll: boolean</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">if (urlPaths.length === 0) {</span><span class="s3">\n      </span><span class="s1">this.placeholder = false</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`Catch-all must be the last part of the URL.`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// The next segment in the urlPaths list</span><span class="s3">\n    </span><span class="s1">let nextSegment = urlPaths[0]</span><span class="s3">\n\n    </span><span class="s1">// Check if the segment matches `[something]`</span><span class="s3">\n    </span><span class="s1">if (nextSegment.startsWith('[') &amp;&amp; nextSegment.endsWith(']')) {</span><span class="s3">\n      </span><span class="s1">// Strip `[` and `]`, leaving only `something`</span><span class="s3">\n      </span><span class="s1">let segmentName = nextSegment.slice(1, -1)</span><span class="s3">\n\n      </span><span class="s1">let isOptional = false</span><span class="s3">\n      </span><span class="s1">if (segmentName.startsWith('[') &amp;&amp; segmentName.endsWith(']')) {</span><span class="s3">\n        </span><span class="s1">// Strip optional `[` and `]`, leaving only `something`</span><span class="s3">\n        </span><span class="s1">segmentName = segmentName.slice(1, -1)</span><span class="s3">\n        </span><span class="s1">isOptional = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (segmentName.startsWith('')) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Detected a three-dot character ('') at ('${segmentName}'). Did you mean ('...')?`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (segmentName.startsWith('...')) {</span><span class="s3">\n        </span><span class="s1">// Strip `...`, leaving only `something`</span><span class="s3">\n        </span><span class="s1">segmentName = segmentName.substring(3)</span><span class="s3">\n        </span><span class="s1">isCatchAll = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (segmentName.startsWith('[') || segmentName.endsWith(']')) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Segment names may not start or end with extra brackets ('${segmentName}').`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (segmentName.startsWith('.')) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Segment names may not start with erroneous periods ('${segmentName}').`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">function handleSlug(previousSlug: string | null, nextSlug: string) {</span><span class="s3">\n        </span><span class="s1">if (previousSlug !== null) {</span><span class="s3">\n          </span><span class="s1">// If the specific segment already has a slug but the slug is not `something`</span><span class="s3">\n          </span><span class="s1">// This prevents collisions like:</span><span class="s3">\n          </span><span class="s1">// pages/[post]/index.js</span><span class="s3">\n          </span><span class="s1">// pages/[id]/index.js</span><span class="s3">\n          </span><span class="s1">// Because currently multiple dynamic params on the same segment level are not supported</span><span class="s3">\n          </span><span class="s1">if (previousSlug !== nextSlug) {</span><span class="s3">\n            </span><span class="s1">// TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">slugNames.forEach((slug) =&gt; {</span><span class="s3">\n          </span><span class="s1">if (slug === nextSlug) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot have the same slug name </span><span class="s3">\&quot;</span><span class="s1">${nextSlug}</span><span class="s3">\&quot; </span><span class="s1">repeat within a single dynamic path`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (slug.replace(/</span><span class="s3">\\</span><span class="s1">W/g, '') === nextSegment.replace(/</span><span class="s3">\\</span><span class="s1">W/g, '')) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot have the slug names </span><span class="s3">\&quot;</span><span class="s1">${slug}</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">${nextSlug}</span><span class="s3">\&quot; </span><span class="s1">differ only by non-word symbols within a single dynamic path`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">slugNames.push(nextSlug)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n        </span><span class="s1">if (isOptional) {</span><span class="s3">\n          </span><span class="s1">if (this.restSlugName != null) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot use both an required and optional catch-all route at the same level (</span><span class="s3">\&quot;</span><span class="s1">[...${this.restSlugName}]</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">${urlPaths[0]}</span><span class="s3">\&quot; </span><span class="s1">).`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">handleSlug(this.optionalRestSlugName, segmentName)</span><span class="s3">\n          </span><span class="s1">// slugName is kept as it can only be one particular slugName</span><span class="s3">\n          </span><span class="s1">this.optionalRestSlugName = segmentName</span><span class="s3">\n          </span><span class="s1">// nextSegment is overwritten to [[...]] so that it can later be sorted specifically</span><span class="s3">\n          </span><span class="s1">nextSegment = '[[...]]'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (this.optionalRestSlugName != null) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`You cannot use both an optional and required catch-all route at the same level (</span><span class="s3">\&quot;</span><span class="s1">[[...${this.optionalRestSlugName}]]</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">${urlPaths[0]}</span><span class="s3">\&quot;</span><span class="s1">).`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">handleSlug(this.restSlugName, segmentName)</span><span class="s3">\n          </span><span class="s1">// slugName is kept as it can only be one particular slugName</span><span class="s3">\n          </span><span class="s1">this.restSlugName = segmentName</span><span class="s3">\n          </span><span class="s1">// nextSegment is overwritten to [...] so that it can later be sorted specifically</span><span class="s3">\n          </span><span class="s1">nextSegment = '[...]'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (isOptional) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">`Optional route parameters are not yet supported (</span><span class="s3">\&quot;</span><span class="s1">${urlPaths[0]}</span><span class="s3">\&quot;</span><span class="s1">).`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">handleSlug(this.slugName, segmentName)</span><span class="s3">\n        </span><span class="s1">// slugName is kept as it can only be one particular slugName</span><span class="s3">\n        </span><span class="s1">this.slugName = segmentName</span><span class="s3">\n        </span><span class="s1">// nextSegment is overwritten to [] so that it can later be sorted specifically</span><span class="s3">\n        </span><span class="s1">nextSegment = '[]'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode</span><span class="s3">\n    </span><span class="s1">if (!this.children.has(nextSegment)) {</span><span class="s3">\n      </span><span class="s1">this.children.set(nextSegment, new UrlNode())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.children</span><span class="s3">\n      </span><span class="s1">.get(nextSegment)!</span><span class="s3">\n      </span><span class="s1">._insert(urlPaths.slice(1), slugNames, isCatchAll)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @deprecated Use `sortSortableRoutes` or `sortPages` instead.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSortedRoutes(</span><span class="s3">\n  </span><span class="s1">normalizedPages: ReadonlyArray&lt;string&gt;</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">// First the UrlNode is created, and every UrlNode can have only 1 dynamic segment</span><span class="s3">\n  </span><span class="s1">// Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js</span><span class="s3">\n  </span><span class="s1">// Only 1 dynamic segment per nesting level</span><span class="s3">\n\n  </span><span class="s1">// So in the case that is test/integration/dynamic-routing it'll be this:</span><span class="s3">\n  </span><span class="s1">// pages/[post]/comments.js</span><span class="s3">\n  </span><span class="s1">// pages/blog/[post]/comment/[id].js</span><span class="s3">\n  </span><span class="s1">// Both are fine because `pages/[post]` and `pages/blog` are on the same level</span><span class="s3">\n  </span><span class="s1">// So in this case `UrlNode` created here has `this.slugName === 'post'`</span><span class="s3">\n  </span><span class="s1">// And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities</span><span class="s3">\n  </span><span class="s1">// Instead what has to be passed through is the upwards path's dynamic names</span><span class="s3">\n  </span><span class="s1">const root = new UrlNode()</span><span class="s3">\n\n  </span><span class="s1">// Here the `root` gets injected multiple paths, and insert will break them up into sublevels</span><span class="s3">\n  </span><span class="s1">normalizedPages.forEach((pagePath) =&gt; root.insert(pagePath))</span><span class="s3">\n  </span><span class="s1">// Smoosh will then sort those sublevels up to the point where you get the correct route definition priority</span><span class="s3">\n  </span><span class="s1">return root.smoosh()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @deprecated Use `sortSortableRouteObjects` or `sortPageObjects` instead.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSortedRouteObjects&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">objects: T[],</span><span class="s3">\n  </span><span class="s1">getter: (obj: T) =&gt; string</span><span class="s3">\n</span><span class="s1">): T[] {</span><span class="s3">\n  </span><span class="s1">// We're assuming here that all the pathnames are unique, that way we can</span><span class="s3">\n  </span><span class="s1">// sort the list and use the index as the key.</span><span class="s3">\n  </span><span class="s1">const indexes: Record&lt;string, number&gt; = {}</span><span class="s3">\n  </span><span class="s1">const pathnames: string[] = []</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; objects.length; i++) {</span><span class="s3">\n    </span><span class="s1">const pathname = getter(objects[i])</span><span class="s3">\n    </span><span class="s1">indexes[pathname] = i</span><span class="s3">\n    </span><span class="s1">pathnames[i] = pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Sort the pathnames.</span><span class="s3">\n  </span><span class="s1">const sorted = getSortedRoutes(pathnames)</span><span class="s3">\n\n  </span><span class="s1">// Map the sorted pathnames back to the original objects using the new sorted</span><span class="s3">\n  </span><span class="s1">// index.</span><span class="s3">\n  </span><span class="s1">return sorted.map((pathname) =&gt; objects[indexes[pathname]])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RouteMatch } from '../route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { RouteDefinition } from '../route-definitions/route-definition'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../request/params'</span><span class="s3">\n\n</span><span class="s1">import { isDynamicRoute } from '../../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getRouteMatcher,</span><span class="s3">\n  </span><span class="s1">type RouteMatchFn,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import { getRouteRegex } from '../../shared/lib/router/utils/route-regex'</span><span class="s3">\n\n</span><span class="s1">type RouteMatchResult = {</span><span class="s3">\n  </span><span class="s1">params?: Params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class RouteMatcher&lt;D extends RouteDefinition = RouteDefinition&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly dynamic?: RouteMatchFn</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When set, this is an array of all the other matchers that are duplicates of</span><span class="s3">\n   </span><span class="s1">* this one. This is used by the managers to warn the users about possible</span><span class="s3">\n   </span><span class="s1">* duplicate matches on routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public duplicated?: Array&lt;RouteMatcher&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(public readonly definition: D) {</span><span class="s3">\n    </span><span class="s1">if (isDynamicRoute(definition.pathname)) {</span><span class="s3">\n      </span><span class="s1">this.dynamic = getRouteMatcher(getRouteRegex(definition.pathname))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Identity returns the identity part of the matcher. This is used to compare</span><span class="s3">\n   </span><span class="s1">* a unique matcher to another. This is also used when sorting dynamic routes,</span><span class="s3">\n   </span><span class="s1">* so it must contain the pathname part.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get identity(): string {</span><span class="s3">\n    </span><span class="s1">return this.definition.pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get isDynamic() {</span><span class="s3">\n    </span><span class="s1">return this.dynamic !== undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public match(pathname: string): RouteMatch&lt;D&gt; | null {</span><span class="s3">\n    </span><span class="s1">const result = this.test(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return null</span><span class="s3">\n\n    </span><span class="s1">return { definition: this.definition, params: result.params }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public test(pathname: string): RouteMatchResult | null {</span><span class="s3">\n    </span><span class="s1">if (this.dynamic) {</span><span class="s3">\n      </span><span class="s1">const params = this.dynamic(pathname)</span><span class="s3">\n      </span><span class="s1">if (!params) return null</span><span class="s3">\n\n      </span><span class="s1">return { params }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (pathname === this.definition.pathname) {</span><span class="s3">\n      </span><span class="s1">return {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { LocaleAnalysisResult } from '../lib/i18n-provider'</span><span class="s3">\n</span><span class="s1">import type { LocaleRouteDefinition } from '../route-definitions/locale-route-definition'</span><span class="s3">\n</span><span class="s1">import type { LocaleRouteMatch } from '../route-matches/locale-route-match'</span><span class="s3">\n</span><span class="s1">import { RouteMatcher } from './route-matcher'</span><span class="s3">\n\n</span><span class="s1">export type LocaleMatcherMatchOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If defined, this indicates to the matcher that the request should be</span><span class="s3">\n   </span><span class="s1">* treated as locale-aware. If this is undefined, it means that this</span><span class="s3">\n   </span><span class="s1">* application was not configured for additional locales.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">i18n?: LocaleAnalysisResult</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class LocaleRouteMatcher&lt;</span><span class="s3">\n  </span><span class="s1">D extends LocaleRouteDefinition = LocaleRouteDefinition,</span><span class="s3">\n</span><span class="s1">&gt; extends RouteMatcher&lt;D&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Identity returns the identity part of the matcher. This is used to compare</span><span class="s3">\n   </span><span class="s1">* a unique matcher to another. This is also used when sorting dynamic routes,</span><span class="s3">\n   </span><span class="s1">* so it must contain the pathname part as well.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get identity(): string {</span><span class="s3">\n    </span><span class="s1">return `${this.definition.pathname}?__nextLocale=${this.definition.i18n?.locale}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Match will attempt to match the given pathname against this route while</span><span class="s3">\n   </span><span class="s1">* also taking into account the locale information.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname The pathname to match against.</span><span class="s3">\n   </span><span class="s1">* @param options The options to use when matching.</span><span class="s3">\n   </span><span class="s1">* @returns The match result, or `null` if there was no match.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public match(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">options?: LocaleMatcherMatchOptions</span><span class="s3">\n  </span><span class="s1">): LocaleRouteMatch&lt;D&gt; | null {</span><span class="s3">\n    </span><span class="s1">// This is like the parent `match` method but instead this injects the</span><span class="s3">\n    </span><span class="s1">// additional `options` into the</span><span class="s3">\n    </span><span class="s1">const result = this.test(pathname, options)</span><span class="s3">\n    </span><span class="s1">if (!result) return null</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">definition: this.definition,</span><span class="s3">\n      </span><span class="s1">params: result.params,</span><span class="s3">\n      </span><span class="s1">detectedLocale:</span><span class="s3">\n        </span><span class="s1">// If the options have a detected locale, then use that, otherwise use</span><span class="s3">\n        </span><span class="s1">// the route's locale.</span><span class="s3">\n        </span><span class="s1">options?.i18n?.detectedLocale ?? this.definition.i18n?.locale,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Test will attempt to match the given pathname against this route while</span><span class="s3">\n   </span><span class="s1">* also taking into account the locale information.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname The pathname to match against.</span><span class="s3">\n   </span><span class="s1">* @param options The options to use when matching.</span><span class="s3">\n   </span><span class="s1">* @returns The match result, or `null` if there was no match.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public test(pathname: string, options?: LocaleMatcherMatchOptions) {</span><span class="s3">\n    </span><span class="s1">// If this route has locale information and we have detected a locale, then</span><span class="s3">\n    </span><span class="s1">// we need to compare the detected locale to the route's locale.</span><span class="s3">\n    </span><span class="s1">if (this.definition.i18n &amp;&amp; options?.i18n) {</span><span class="s3">\n      </span><span class="s1">// If we have detected a locale and it does not match this route's locale,</span><span class="s3">\n      </span><span class="s1">// then this isn't a match!</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">this.definition.i18n.locale &amp;&amp;</span><span class="s3">\n        </span><span class="s1">options.i18n.detectedLocale &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.definition.i18n.locale !== options.i18n.detectedLocale</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Perform regular matching against the locale stripped pathname now, the</span><span class="s3">\n      </span><span class="s1">// locale information matches!</span><span class="s3">\n      </span><span class="s1">return super.test(options.i18n.pathname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we don't have locale information, then we can just perform regular</span><span class="s3">\n    </span><span class="s1">// matching.</span><span class="s3">\n    </span><span class="s1">return super.test(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isDynamicRoute } from '../../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import type { RouteMatch } from '../route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { RouteDefinition } from '../route-definitions/route-definition'</span><span class="s3">\n</span><span class="s1">import type { RouteMatcherProvider } from '../route-matcher-providers/route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import type { RouteMatcher } from '../route-matchers/route-matcher'</span><span class="s3">\n</span><span class="s1">import type { MatchOptions, RouteMatcherManager } from './route-matcher-manager'</span><span class="s3">\n</span><span class="s1">import { getSortedRoutes } from '../../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import { LocaleRouteMatcher } from '../route-matchers/locale-route-matcher'</span><span class="s3">\n</span><span class="s1">import { ensureLeadingSlash } from '../../shared/lib/page-path/ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../lib/detached-promise'</span><span class="s3">\n\n</span><span class="s1">interface RouteMatchers {</span><span class="s3">\n  </span><span class="s1">static: ReadonlyArray&lt;RouteMatcher&gt;</span><span class="s3">\n  </span><span class="s1">dynamic: ReadonlyArray&lt;RouteMatcher&gt;</span><span class="s3">\n  </span><span class="s1">duplicates: Record&lt;string, ReadonlyArray&lt;RouteMatcher&gt;&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class DefaultRouteMatcherManager implements RouteMatcherManager {</span><span class="s3">\n  </span><span class="s1">private readonly providers: Array&lt;RouteMatcherProvider&gt; = []</span><span class="s3">\n  </span><span class="s1">protected readonly matchers: RouteMatchers = {</span><span class="s3">\n    </span><span class="s1">static: [],</span><span class="s3">\n    </span><span class="s1">dynamic: [],</span><span class="s3">\n    </span><span class="s1">duplicates: {},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">private lastCompilationID = this.compilationID</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When this value changes, it indicates that a change has been introduced</span><span class="s3">\n   </span><span class="s1">* that requires recompilation.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private get compilationID() {</span><span class="s3">\n    </span><span class="s1">return this.providers.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private waitTillReadyPromise?: Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">public async waitTillReady(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.waitTillReadyPromise) {</span><span class="s3">\n      </span><span class="s1">await this.waitTillReadyPromise</span><span class="s3">\n      </span><span class="s1">delete this.waitTillReadyPromise</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private previousMatchers: ReadonlyArray&lt;RouteMatcher&gt; = []</span><span class="s3">\n  </span><span class="s1">public async reload() {</span><span class="s3">\n    </span><span class="s1">const { promise, resolve, reject } = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">this.waitTillReadyPromise = promise</span><span class="s3">\n\n    </span><span class="s1">// Grab the compilation ID for this run, we'll verify it at the end to</span><span class="s3">\n    </span><span class="s1">// ensure that if any routes were added before reloading is finished that</span><span class="s3">\n    </span><span class="s1">// we error out.</span><span class="s3">\n    </span><span class="s1">const compilationID = this.compilationID</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">// Collect all the matchers from each provider.</span><span class="s3">\n      </span><span class="s1">const matchers: Array&lt;RouteMatcher&gt; = []</span><span class="s3">\n\n      </span><span class="s1">// Get all the providers matchers.</span><span class="s3">\n      </span><span class="s1">const providersMatchers: ReadonlyArray&lt;ReadonlyArray&lt;RouteMatcher&gt;&gt; =</span><span class="s3">\n        </span><span class="s1">await Promise.all(this.providers.map((provider) =&gt; provider.matchers()))</span><span class="s3">\n\n      </span><span class="s1">// Use this to detect duplicate pathnames.</span><span class="s3">\n      </span><span class="s1">const all = new Map&lt;string, RouteMatcher&gt;()</span><span class="s3">\n      </span><span class="s1">const duplicates: Record&lt;string, RouteMatcher[]&gt; = {}</span><span class="s3">\n      </span><span class="s1">for (const providerMatchers of providersMatchers) {</span><span class="s3">\n        </span><span class="s1">for (const matcher of providerMatchers) {</span><span class="s3">\n          </span><span class="s1">// Reset duplicated matches when reloading from pages conflicting state.</span><span class="s3">\n          </span><span class="s1">if (matcher.duplicated) delete matcher.duplicated</span><span class="s3">\n          </span><span class="s1">// Test to see if the matcher being added is a duplicate.</span><span class="s3">\n          </span><span class="s1">const duplicate = all.get(matcher.definition.pathname)</span><span class="s3">\n          </span><span class="s1">if (duplicate) {</span><span class="s3">\n            </span><span class="s1">// This looks a little weird, but essentially if the pathname</span><span class="s3">\n            </span><span class="s1">// already exists in the duplicates map, then we got that array</span><span class="s3">\n            </span><span class="s1">// reference. Otherwise, we create a new array with the original</span><span class="s3">\n            </span><span class="s1">// duplicate first. Then we push the new matcher into the duplicate</span><span class="s3">\n            </span><span class="s1">// array, and reset it to the duplicates object (which may be a</span><span class="s3">\n            </span><span class="s1">// no-op if the pathname already existed in the duplicates object).</span><span class="s3">\n            </span><span class="s1">// Then we set the array of duplicates on both the original</span><span class="s3">\n            </span><span class="s1">// duplicate object and the new one, so we can keep them in sync.</span><span class="s3">\n            </span><span class="s1">// If a new duplicate is found, and it matches an existing pathname,</span><span class="s3">\n            </span><span class="s1">// the retrieval of the `other` will actually return the array</span><span class="s3">\n            </span><span class="s1">// reference used by all other duplicates. This is why ReadonlyArray</span><span class="s3">\n            </span><span class="s1">// is so important! Array's are always references!</span><span class="s3">\n            </span><span class="s1">const others = duplicates[matcher.definition.pathname] ?? [</span><span class="s3">\n              </span><span class="s1">duplicate,</span><span class="s3">\n            </span><span class="s1">]</span><span class="s3">\n            </span><span class="s1">others.push(matcher)</span><span class="s3">\n            </span><span class="s1">duplicates[matcher.definition.pathname] = others</span><span class="s3">\n\n            </span><span class="s1">// Add duplicated details to each route.</span><span class="s3">\n            </span><span class="s1">duplicate.duplicated = others</span><span class="s3">\n            </span><span class="s1">matcher.duplicated = others</span><span class="s3">\n\n            </span><span class="s1">// TODO: see if we should error for duplicates in production?</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">matchers.push(matcher)</span><span class="s3">\n\n          </span><span class="s1">// Add the matcher's pathname to the set.</span><span class="s3">\n          </span><span class="s1">all.set(matcher.definition.pathname, matcher)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Update the duplicate matchers. This is used in the development manager</span><span class="s3">\n      </span><span class="s1">// to warn about duplicates.</span><span class="s3">\n      </span><span class="s1">this.matchers.duplicates = duplicates</span><span class="s3">\n\n      </span><span class="s1">// If the cache is the same as what we just parsed, we can exit now. We</span><span class="s3">\n      </span><span class="s1">// can tell by using the `===` which compares object identity, which for</span><span class="s3">\n      </span><span class="s1">// the manifest matchers, will return the same matcher each time.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">this.previousMatchers.length === matchers.length &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.previousMatchers.every(</span><span class="s3">\n          </span><span class="s1">(cachedMatcher, index) =&gt; cachedMatcher === matchers[index]</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.previousMatchers = matchers</span><span class="s3">\n\n      </span><span class="s1">// For matchers that are for static routes, filter them now.</span><span class="s3">\n      </span><span class="s1">this.matchers.static = matchers.filter((matcher) =&gt; !matcher.isDynamic)</span><span class="s3">\n\n      </span><span class="s1">// For matchers that are for dynamic routes, filter them and sort them now.</span><span class="s3">\n      </span><span class="s1">const dynamic = matchers.filter((matcher) =&gt; matcher.isDynamic)</span><span class="s3">\n\n      </span><span class="s1">// As `getSortedRoutes` only takes an array of strings, we need to create</span><span class="s3">\n      </span><span class="s1">// a map of the pathnames (used for sorting) and the matchers. When we</span><span class="s3">\n      </span><span class="s1">// have locales, there may be multiple matches for the same pathname. To</span><span class="s3">\n      </span><span class="s1">// handle this, we keep a map of all the indexes (in `reference`) and</span><span class="s3">\n      </span><span class="s1">// merge them in later.</span><span class="s3">\n\n      </span><span class="s1">const reference = new Map&lt;string, number[]&gt;()</span><span class="s3">\n      </span><span class="s1">const pathnames = new Array&lt;string&gt;()</span><span class="s3">\n      </span><span class="s1">for (let index = 0; index &lt; dynamic.length; index++) {</span><span class="s3">\n        </span><span class="s1">// Grab the pathname from the definition.</span><span class="s3">\n        </span><span class="s1">const pathname = dynamic[index].definition.pathname</span><span class="s3">\n\n        </span><span class="s1">// Grab the index in the dynamic array, push it into the reference.</span><span class="s3">\n        </span><span class="s1">const indexes = reference.get(pathname) ?? []</span><span class="s3">\n        </span><span class="s1">indexes.push(index)</span><span class="s3">\n\n        </span><span class="s1">// If this is the first one set it. If it isn't, we don't need to</span><span class="s3">\n        </span><span class="s1">// because pushing above on the array will mutate the array already</span><span class="s3">\n        </span><span class="s1">// stored there because array's are always a reference!</span><span class="s3">\n        </span><span class="s1">if (indexes.length === 1) reference.set(pathname, indexes)</span><span class="s3">\n        </span><span class="s1">// Otherwise, continue, we've already added this pathname before.</span><span class="s3">\n        </span><span class="s1">else continue</span><span class="s3">\n\n        </span><span class="s1">pathnames.push(pathname)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Sort the array of pathnames.</span><span class="s3">\n      </span><span class="s1">const sorted = getSortedRoutes(pathnames)</span><span class="s3">\n\n      </span><span class="s1">// For each of the sorted pathnames, iterate over them, grabbing the list</span><span class="s3">\n      </span><span class="s1">// of indexes and merging them back into the new `sortedDynamicMatchers`</span><span class="s3">\n      </span><span class="s1">// array. The order of the same matching pathname doesn't matter because</span><span class="s3">\n      </span><span class="s1">// they will have other matching characteristics (like the locale) that</span><span class="s3">\n      </span><span class="s1">// is considered.</span><span class="s3">\n      </span><span class="s1">const sortedDynamicMatchers: Array&lt;RouteMatcher&gt; = []</span><span class="s3">\n      </span><span class="s1">for (const pathname of sorted) {</span><span class="s3">\n        </span><span class="s1">const indexes = reference.get(pathname)</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(indexes)) {</span><span class="s3">\n          </span><span class="s1">throw new Error('Invariant: expected to find identity in indexes map')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const dynamicMatches = indexes.map((index) =&gt; dynamic[index])</span><span class="s3">\n\n        </span><span class="s1">sortedDynamicMatchers.push(...dynamicMatches)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.matchers.dynamic = sortedDynamicMatchers</span><span class="s3">\n\n      </span><span class="s1">// This means that there was a new matcher pushed while we were waiting</span><span class="s3">\n      </span><span class="s1">if (this.compilationID !== compilationID) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">'Invariant: expected compilation to finish before new matchers were added, possible missing await'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">reject(err)</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">// The compilation ID matched, so mark the complication as finished.</span><span class="s3">\n      </span><span class="s1">this.lastCompilationID = compilationID</span><span class="s3">\n      </span><span class="s1">resolve()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public push(provider: RouteMatcherProvider): void {</span><span class="s3">\n    </span><span class="s1">this.providers.push(provider)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async test(pathname: string, options: MatchOptions): Promise&lt;boolean&gt; {</span><span class="s3">\n    </span><span class="s1">// See if there's a match for the pathname...</span><span class="s3">\n    </span><span class="s1">const match = await this.match(pathname, options)</span><span class="s3">\n\n    </span><span class="s1">// This default implementation only needs to check to see if there _was_ a</span><span class="s3">\n    </span><span class="s1">// match. The development matcher actually changes it's behavior by not</span><span class="s3">\n    </span><span class="s1">// recompiling the routes.</span><span class="s3">\n    </span><span class="s1">return match !== null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async match(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">options: MatchOptions</span><span class="s3">\n  </span><span class="s1">): Promise&lt;RouteMatch&lt;RouteDefinition&lt;RouteKind&gt;&gt; | null&gt; {</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Iterate</span><span class="s3">\&quot; </span><span class="s1">over the match options. Once we found a single match, exit with</span><span class="s3">\n    </span><span class="s1">// it, otherwise return null below. If no match is found, the inner block</span><span class="s3">\n    </span><span class="s1">// won't be called.</span><span class="s3">\n    </span><span class="s1">for await (const match of this.matchAll(pathname, options)) {</span><span class="s3">\n      </span><span class="s1">return match</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is a point for other managers to override to inject other checking</span><span class="s3">\n   </span><span class="s1">* behavior like duplicate route checking on a per-request basis.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname the pathname to validate against</span><span class="s3">\n   </span><span class="s1">* @param matcher the matcher to validate/test with</span><span class="s3">\n   </span><span class="s1">* @returns the match if found</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">protected validate(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">matcher: RouteMatcher,</span><span class="s3">\n    </span><span class="s1">options: MatchOptions</span><span class="s3">\n  </span><span class="s1">): RouteMatch | null {</span><span class="s3">\n    </span><span class="s1">if (matcher instanceof LocaleRouteMatcher) {</span><span class="s3">\n      </span><span class="s1">return matcher.match(pathname, options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the locale was inferred from the default locale, then it will have</span><span class="s3">\n    </span><span class="s1">// already added a locale to the pathname. We need to remove it before</span><span class="s3">\n    </span><span class="s1">// matching because this matcher is not locale aware.</span><span class="s3">\n    </span><span class="s1">if (options.i18n?.inferredFromDefault) {</span><span class="s3">\n      </span><span class="s1">return matcher.match(options.i18n.pathname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return matcher.match(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async *matchAll(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">options: MatchOptions</span><span class="s3">\n  </span><span class="s1">): AsyncGenerator&lt;RouteMatch&lt;RouteDefinition&lt;RouteKind&gt;&gt;, null, undefined&gt; {</span><span class="s3">\n    </span><span class="s1">// Guard against the matcher manager from being run before it needs to be</span><span class="s3">\n    </span><span class="s1">// recompiled. This was preferred to re-running the compilation here because</span><span class="s3">\n    </span><span class="s1">// it should be re-ran only when it changes. If a match is attempted before</span><span class="s3">\n    </span><span class="s1">// this is done, it indicates that there is a case where a provider is added</span><span class="s3">\n    </span><span class="s1">// before it was recompiled (an error). We also don't want to affect request</span><span class="s3">\n    </span><span class="s1">// times.</span><span class="s3">\n    </span><span class="s1">if (this.lastCompilationID !== this.compilationID) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Invariant: expected routes to have been loaded before match'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Ensure that path matching is done with a leading slash.</span><span class="s3">\n    </span><span class="s1">pathname = ensureLeadingSlash(pathname)</span><span class="s3">\n\n    </span><span class="s1">// If this pathname doesn't look like a dynamic route, and this pathname is</span><span class="s3">\n    </span><span class="s1">// listed in the normalized list of routes, then return it. This ensures</span><span class="s3">\n    </span><span class="s1">// that when a route like `/user/[id]` is encountered, it doesn't just match</span><span class="s3">\n    </span><span class="s1">// with the list of normalized routes.</span><span class="s3">\n    </span><span class="s1">if (!isDynamicRoute(pathname)) {</span><span class="s3">\n      </span><span class="s1">for (const matcher of this.matchers.static) {</span><span class="s3">\n        </span><span class="s1">const match = this.validate(pathname, matcher, options)</span><span class="s3">\n        </span><span class="s1">if (!match) continue</span><span class="s3">\n\n        </span><span class="s1">yield match</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we should skip handling dynamic routes, exit now.</span><span class="s3">\n    </span><span class="s1">if (options?.skipDynamic) return null</span><span class="s3">\n\n    </span><span class="s1">// Loop over the dynamic matchers, yielding each match.</span><span class="s3">\n    </span><span class="s1">for (const matcher of this.matchers.dynamic) {</span><span class="s3">\n      </span><span class="s1">const match = this.validate(pathname, matcher, options)</span><span class="s3">\n      </span><span class="s1">if (!match) continue</span><span class="s3">\n\n      </span><span class="s1">yield match</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We tried direct matching against the pathname and against all the dynamic</span><span class="s3">\n    </span><span class="s1">// paths, so there was no match.</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Normalizer } from './normalizer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizers combines many normalizers into a single normalizer interface that</span><span class="s3">\n </span><span class="s1">* will normalize the inputted pathname with each normalizer in order.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Normalizers implements Normalizer {</span><span class="s3">\n  </span><span class="s1">constructor(private readonly normalizers: Array&lt;Normalizer&gt; = []) {}</span><span class="s3">\n\n  </span><span class="s1">public push(normalizer: Normalizer) {</span><span class="s3">\n    </span><span class="s1">this.normalizers.push(normalizer)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(pathname: string): string {</span><span class="s3">\n    </span><span class="s1">return this.normalizers.reduce&lt;string&gt;(</span><span class="s3">\n      </span><span class="s1">(normalized, normalizer) =&gt; normalizer.normalize(normalized),</span><span class="s3">\n      </span><span class="s1">pathname</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from '../../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import type { Normalizer } from './normalizer'</span><span class="s3">\n\n</span><span class="s1">export class PrefixingNormalizer implements Normalizer {</span><span class="s3">\n  </span><span class="s1">private readonly prefix: string</span><span class="s3">\n\n  </span><span class="s1">constructor(...prefixes: ReadonlyArray&lt;string&gt;) {</span><span class="s3">\n    </span><span class="s1">this.prefix = path.posix.join(...prefixes)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(pathname: string): string {</span><span class="s3">\n    </span><span class="s1">return path.posix.join(this.prefix, pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ensureLeadingSlash } from './ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../router/utils'</span><span class="s3">\n</span><span class="s1">import { NormalizeError } from '../utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes a page and transforms it into its file counterpart ensuring that the</span><span class="s3">\n </span><span class="s1">* output is normalized. Note this function is not idempotent because a page</span><span class="s3">\n </span><span class="s1">* `/index` can be referencing `/index/index.js` and `/index/index` could be</span><span class="s3">\n </span><span class="s1">* referencing `/index/index/index.js`. Examples:</span><span class="s3">\n </span><span class="s1">*  - `/` -&gt; `/index`</span><span class="s3">\n </span><span class="s1">*  - `/index/foo` -&gt; `/index/index/foo`</span><span class="s3">\n </span><span class="s1">*  - `/index` -&gt; `/index/index`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizePagePath(page: string): string {</span><span class="s3">\n  </span><span class="s1">const normalized =</span><span class="s3">\n    </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">/index(</span><span class="s3">\\</span><span class="s1">/|$)/.test(page) &amp;&amp; !isDynamicRoute(page)</span><span class="s3">\n      </span><span class="s1">? `/index${page}`</span><span class="s3">\n      </span><span class="s1">: page === '/'</span><span class="s3">\n        </span><span class="s1">? '/index'</span><span class="s3">\n        </span><span class="s1">: ensureLeadingSlash(page)</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n    </span><span class="s1">const { posix } = require('path') as typeof import('path')</span><span class="s3">\n    </span><span class="s1">const resolvedPage = posix.normalize(normalized)</span><span class="s3">\n    </span><span class="s1">if (resolvedPage !== normalized) {</span><span class="s3">\n      </span><span class="s1">throw new NormalizeError(</span><span class="s3">\n        </span><span class="s1">`Requested and resolved page mismatch: ${normalized} ${resolvedPage}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalized</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Normalizer } from './normalizer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* UnderscoreNormalizer replaces all instances of %5F with _.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class UnderscoreNormalizer implements Normalizer {</span><span class="s3">\n  </span><span class="s1">public normalize(pathname: string): string {</span><span class="s3">\n    </span><span class="s1">return pathname.replace(/%5F/g, '_')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { Normalizers } from '../../normalizers'</span><span class="s3">\n</span><span class="s1">import type { Normalizer } from '../../normalizer'</span><span class="s3">\n</span><span class="s1">import { PrefixingNormalizer } from '../../prefixing-normalizer'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../../../../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n</span><span class="s1">import { UnderscoreNormalizer } from '../../underscore-normalizer'</span><span class="s3">\n\n</span><span class="s1">export class AppBundlePathNormalizer extends PrefixingNormalizer {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super('app')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(page: string): string {</span><span class="s3">\n    </span><span class="s1">return super.normalize(normalizePagePath(page))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class DevAppBundlePathNormalizer extends Normalizers {</span><span class="s3">\n  </span><span class="s1">constructor(pageNormalizer: Normalizer, isTurbopack: boolean) {</span><span class="s3">\n    </span><span class="s1">const normalizers = [</span><span class="s3">\n      </span><span class="s1">// This should normalize the filename to a page.</span><span class="s3">\n      </span><span class="s1">pageNormalizer,</span><span class="s3">\n      </span><span class="s1">// Normalize the app page to a pathname.</span><span class="s3">\n      </span><span class="s1">new AppBundlePathNormalizer(),</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n    </span><span class="s1">// %5F to _ replacement should only happen with Turbopack.</span><span class="s3">\n    </span><span class="s1">if (isTurbopack) {</span><span class="s3">\n      </span><span class="s1">normalizers.unshift(new UnderscoreNormalizer())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">super(normalizers)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(filename: string): string {</span><span class="s3">\n    </span><span class="s1">return super.normalize(filename)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { SERVER_DIRECTORY } from '../../../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { PrefixingNormalizer } from '../../prefixing-normalizer'</span><span class="s3">\n\n</span><span class="s1">export class AppFilenameNormalizer extends PrefixingNormalizer {</span><span class="s3">\n  </span><span class="s1">constructor(distDir: string) {</span><span class="s3">\n    </span><span class="s1">super(distDir, SERVER_DIRECTORY)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(manifestFilename: string): string {</span><span class="s3">\n    </span><span class="s1">return super.normalize(manifestFilename)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function isAppRouteRoute(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">return route.endsWith('/route')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PageExtensions } from '../../build/page-extensions-type'</span><span class="s3">\n</span><span class="s1">import { normalizePathSep } from '../../shared/lib/page-path/normalize-path-sep'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { isAppRouteRoute } from '../is-app-route-route'</span><span class="s3">\n\n</span><span class="s1">export const STATIC_METADATA_IMAGES = {</span><span class="s3">\n  </span><span class="s1">icon: {</span><span class="s3">\n    </span><span class="s1">filename: 'icon',</span><span class="s3">\n    </span><span class="s1">extensions: ['ico', 'jpg', 'jpeg', 'png', 'svg'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">apple: {</span><span class="s3">\n    </span><span class="s1">filename: 'apple-icon',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">favicon: {</span><span class="s3">\n    </span><span class="s1">filename: 'favicon',</span><span class="s3">\n    </span><span class="s1">extensions: ['ico'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">openGraph: {</span><span class="s3">\n    </span><span class="s1">filename: 'opengraph-image',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png', 'gif'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">twitter: {</span><span class="s3">\n    </span><span class="s1">filename: 'twitter-image',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png', 'gif'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">// Match routes that are metadata routes, e.g. /sitemap.xml, /favicon.&lt;ext&gt;, /&lt;icon&gt;.&lt;ext&gt;, etc.</span><span class="s3">\n</span><span class="s1">// TODO-METADATA: support more metadata routes with more extensions</span><span class="s3">\n</span><span class="s1">export const DEFAULT_METADATA_ROUTE_EXTENSIONS = ['js', 'jsx', 'ts', 'tsx']</span><span class="s3">\n\n</span><span class="s1">// Match the file extension with the dynamic multi-routes extensions</span><span class="s3">\n</span><span class="s1">// e.g. ([xml, js], null) -&gt; can match `/sitemap.xml/route`, `sitemap.js/route`</span><span class="s3">\n</span><span class="s1">// e.g. ([png], [ts]) -&gt; can match `/opengrapg-image.png`, `/opengraph-image.ts`</span><span class="s3">\n</span><span class="s1">export const getExtensionRegexString = (</span><span class="s3">\n  </span><span class="s1">staticExtensions: readonly string[],</span><span class="s3">\n  </span><span class="s1">dynamicExtensions: readonly string[] | null</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">// If there's no possible multi dynamic routes, will not match any &lt;name&gt;[].&lt;ext&gt; files</span><span class="s3">\n  </span><span class="s1">if (!dynamicExtensions || dynamicExtensions.length === 0) {</span><span class="s3">\n    </span><span class="s1">return `(</span><span class="s3">\\\\</span><span class="s1">.(?:${staticExtensions.join('|')}))`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return `(?:</span><span class="s3">\\\\</span><span class="s1">.(${staticExtensions.join('|')})|(</span><span class="s3">\\\\</span><span class="s1">.(${dynamicExtensions.join('|')})))`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine if the file is a metadata route file entry</span><span class="s3">\n </span><span class="s1">* @param appDirRelativePath the relative file path to app/</span><span class="s3">\n </span><span class="s1">* @param pageExtensions the js extensions, such as ['js', 'jsx', 'ts', 'tsx']</span><span class="s3">\n </span><span class="s1">* @param strictlyMatchExtensions if it's true, match the file with page extension, otherwise match the file with default corresponding extension</span><span class="s3">\n </span><span class="s1">* @returns if the file is a metadata route file</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataRouteFile(</span><span class="s3">\n  </span><span class="s1">appDirRelativePath: string,</span><span class="s3">\n  </span><span class="s1">pageExtensions: PageExtensions,</span><span class="s3">\n  </span><span class="s1">strictlyMatchExtensions: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// End with the extension or optional to have the extension</span><span class="s3">\n  </span><span class="s1">// When strictlyMatchExtensions is true, it's used for match file path;</span><span class="s3">\n  </span><span class="s1">// When strictlyMatchExtensions, the dynamic extension is skipped but</span><span class="s3">\n  </span><span class="s1">// static extension is kept, which is usually used for matching route path.</span><span class="s3">\n  </span><span class="s1">const trailingMatcher = (strictlyMatchExtensions ? '' : '?') + '$'</span><span class="s3">\n  </span><span class="s1">// Match the optional variants like /opengraph-image2, /icon-a102f4.png, etc.</span><span class="s3">\n  </span><span class="s1">const variantsMatcher = '</span><span class="s3">\\\\</span><span class="s1">d?'</span><span class="s3">\n  </span><span class="s1">// The -</span><span class="s3">\\</span><span class="s1">w{6} is the suffix that normalized from group routes;</span><span class="s3">\n  </span><span class="s1">const groupSuffix = strictlyMatchExtensions ? '' : '(-</span><span class="s3">\\\\</span><span class="s1">w{6})?'</span><span class="s3">\n\n  </span><span class="s1">const suffixMatcher = `${variantsMatcher}${groupSuffix}`</span><span class="s3">\n\n  </span><span class="s1">const metadataRouteFilesRegex = [</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]robots${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">pageExtensions.concat('txt'),</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]manifest${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">pageExtensions.concat('webmanifest', 'json'),</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]favicon</span><span class="s3">\\\\</span><span class="s1">.ico$`),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]sitemap${getExtensionRegexString(['xml'], pageExtensions)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.icon.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.icon.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.apple.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.apple.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.openGraph.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.openGraph.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.twitter.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.twitter.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">const normalizedAppDirRelativePath = normalizePathSep(appDirRelativePath)</span><span class="s3">\n  </span><span class="s1">const matched = metadataRouteFilesRegex.some((r) =&gt;</span><span class="s3">\n    </span><span class="s1">r.test(normalizedAppDirRelativePath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Check if the route is a static metadata route, with /route suffix</span><span class="s3">\n</span><span class="s1">// e.g. /favicon.ico/route, /icon.png/route, etc.</span><span class="s3">\n</span><span class="s1">// But skip the text routes like robots.txt since they might also be dynamic.</span><span class="s3">\n</span><span class="s1">// Checking route path is not enough to determine if text routes is dynamic.</span><span class="s3">\n</span><span class="s1">export function isStaticMetadataRoute(route: string) {</span><span class="s3">\n  </span><span class="s1">// extract ext with regex</span><span class="s3">\n  </span><span class="s1">const pathname = route.replace(/</span><span class="s3">\\</span><span class="s1">/route$/, '')</span><span class="s3">\n\n  </span><span class="s1">const matched =</span><span class="s3">\n    </span><span class="s1">isAppRouteRoute(route) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isMetadataRouteFile(pathname, [], true) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// These routes can either be built by static or dynamic entrypoints,</span><span class="s3">\n    </span><span class="s1">// so we assume they're dynamic</span><span class="s3">\n    </span><span class="s1">pathname !== '/robots.txt' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">pathname !== '/manifest.webmanifest' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!pathname.endsWith('/sitemap.xml')</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine if a page or pathname is a metadata page.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The input is a page or pathname, which can be with or without page suffix /foo/page or /foo.</span><span class="s3">\n </span><span class="s1">* But it will not contain the /route suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* .e.g</span><span class="s3">\n </span><span class="s1">* /robots -&gt; true</span><span class="s3">\n </span><span class="s1">* /sitemap -&gt; true</span><span class="s3">\n </span><span class="s1">* /foo -&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataPage(page: string) {</span><span class="s3">\n  </span><span class="s1">const matched = !isAppRouteRoute(page) &amp;&amp; isMetadataRouteFile(page, [], false)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Determine if a Next.js route is a metadata route.</span><span class="s3">\n </span><span class="s1">* `route` will has a route suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* e.g.</span><span class="s3">\n </span><span class="s1">* /app/robots/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /robots/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /sitemap/[__metadata_id__]/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /app/sitemap/page -&gt; false</span><span class="s3">\n </span><span class="s1">* /icon-a102f4/route -&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataRoute(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">let page = normalizeAppPath(route)</span><span class="s3">\n    </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">/?app</span><span class="s3">\\</span><span class="s1">//, '')</span><span class="s3">\n    </span><span class="s1">// Remove the dynamic route id</span><span class="s3">\n    </span><span class="s1">.replace('/[__metadata_id__]', '')</span><span class="s3">\n    </span><span class="s1">// Remove the /route suffix</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/route$/, '')</span><span class="s3">\n\n  </span><span class="s1">if (page[0] !== '/') page = '/' + page</span><span class="s3">\n\n  </span><span class="s1">const matched = isAppRouteRoute(route) &amp;&amp; isMetadataRouteFile(page, [], false)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Normalizer } from './normalizer'</span><span class="s3">\n\n</span><span class="s1">export function wrapNormalizerFn(fn: (pathname: string) =&gt; string): Normalizer {</span><span class="s3">\n  </span><span class="s1">return { normalize: fn }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizeAppPath } from '../../../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { Normalizers } from '../../normalizers'</span><span class="s3">\n</span><span class="s1">import { wrapNormalizerFn } from '../../wrap-normalizer-fn'</span><span class="s3">\n</span><span class="s1">import { UnderscoreNormalizer } from '../../underscore-normalizer'</span><span class="s3">\n</span><span class="s1">import type { Normalizer } from '../../normalizer'</span><span class="s3">\n\n</span><span class="s1">export class AppPathnameNormalizer extends Normalizers {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\n      </span><span class="s1">// The pathname to match should have the trailing `/page` and other route</span><span class="s3">\n      </span><span class="s1">// group information stripped from it.</span><span class="s3">\n      </span><span class="s1">wrapNormalizerFn(normalizeAppPath),</span><span class="s3">\n      </span><span class="s1">// The page should have the `%5F` characters replaced with `_` characters.</span><span class="s3">\n      </span><span class="s1">new UnderscoreNormalizer(),</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(page: string): string {</span><span class="s3">\n    </span><span class="s1">return super.normalize(page)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class DevAppPathnameNormalizer extends Normalizers {</span><span class="s3">\n  </span><span class="s1">constructor(pageNormalizer: Normalizer) {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\n      </span><span class="s1">// This should normalize the filename to a page.</span><span class="s3">\n      </span><span class="s1">pageNormalizer,</span><span class="s3">\n      </span><span class="s1">// Normalize the app page to a pathname.</span><span class="s3">\n      </span><span class="s1">new AppPathnameNormalizer(),</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(filename: string): string {</span><span class="s3">\n    </span><span class="s1">return super.normalize(filename)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">AppBundlePathNormalizer,</span><span class="s3">\n  </span><span class="s1">DevAppBundlePathNormalizer,</span><span class="s3">\n</span><span class="s1">} from './app-bundle-path-normalizer'</span><span class="s3">\n</span><span class="s1">import { AppFilenameNormalizer } from './app-filename-normalizer'</span><span class="s3">\n</span><span class="s1">import { DevAppPageNormalizer } from './app-page-normalizer'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">AppPathnameNormalizer,</span><span class="s3">\n  </span><span class="s1">DevAppPathnameNormalizer,</span><span class="s3">\n</span><span class="s1">} from './app-pathname-normalizer'</span><span class="s3">\n\n</span><span class="s1">export class AppNormalizers {</span><span class="s3">\n  </span><span class="s1">public readonly filename: AppFilenameNormalizer</span><span class="s3">\n  </span><span class="s1">public readonly pathname: AppPathnameNormalizer</span><span class="s3">\n  </span><span class="s1">public readonly bundlePath: AppBundlePathNormalizer</span><span class="s3">\n\n  </span><span class="s1">constructor(distDir: string) {</span><span class="s3">\n    </span><span class="s1">this.filename = new AppFilenameNormalizer(distDir)</span><span class="s3">\n    </span><span class="s1">this.pathname = new AppPathnameNormalizer()</span><span class="s3">\n    </span><span class="s1">this.bundlePath = new AppBundlePathNormalizer()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class DevAppNormalizers {</span><span class="s3">\n  </span><span class="s1">public readonly page: DevAppPageNormalizer</span><span class="s3">\n  </span><span class="s1">public readonly pathname: DevAppPathnameNormalizer</span><span class="s3">\n  </span><span class="s1">public readonly bundlePath: DevAppBundlePathNormalizer</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">appDir: string,</span><span class="s3">\n    </span><span class="s1">extensions: ReadonlyArray&lt;string&gt;,</span><span class="s3">\n    </span><span class="s1">isTurbopack: boolean</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.page = new DevAppPageNormalizer(appDir, extensions, isTurbopack)</span><span class="s3">\n    </span><span class="s1">this.pathname = new DevAppPathnameNormalizer(this.page)</span><span class="s3">\n    </span><span class="s1">this.bundlePath = new DevAppBundlePathNormalizer(this.page, isTurbopack)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const enum RouteKind {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES` represents all the React pages that are under `pages/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES_API` represents all the API routes under `pages/api/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES_API = 'PAGES_API',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_PAGE` represents all the React pages that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `page.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `route.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `IMAGE` represents all the images that are generated by `next/image`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { RouteMatcher } from './route-matcher'</span><span class="s3">\n</span><span class="s1">import type { AppPageRouteDefinition } from '../route-definitions/app-page-route-definition'</span><span class="s3">\n\n</span><span class="s1">export class AppPageRouteMatcher extends RouteMatcher&lt;AppPageRouteDefinition&gt; {</span><span class="s3">\n  </span><span class="s1">public get identity(): string {</span><span class="s3">\n    </span><span class="s1">return `${this.definition.pathname}?__nextPage=${this.definition.page}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RouteMatcherProvider } from '../route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import type { RouteMatcher } from '../../route-matchers/route-matcher'</span><span class="s3">\n\n</span><span class="s1">interface LoaderComparable&lt;D&gt; {</span><span class="s3">\n  </span><span class="s1">load(): Promise&lt;D&gt;</span><span class="s3">\n  </span><span class="s1">compare(left: D, right: D): boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This will memoize the matchers if the loaded data is comparable.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export abstract class CachedRouteMatcherProvider&lt;</span><span class="s3">\n  </span><span class="s1">M extends RouteMatcher = RouteMatcher,</span><span class="s3">\n  </span><span class="s1">D = any,</span><span class="s3">\n</span><span class="s1">&gt; implements RouteMatcherProvider&lt;M&gt;</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">private data?: D</span><span class="s3">\n  </span><span class="s1">private cached: ReadonlyArray&lt;M&gt; = []</span><span class="s3">\n\n  </span><span class="s1">constructor(private readonly loader: LoaderComparable&lt;D&gt;) {}</span><span class="s3">\n\n  </span><span class="s1">protected abstract transform(data: D): Promise&lt;ReadonlyArray&lt;M&gt;&gt;</span><span class="s3">\n\n  </span><span class="s1">public async matchers(): Promise&lt;readonly M[]&gt; {</span><span class="s3">\n    </span><span class="s1">const data = await this.loader.load()</span><span class="s3">\n    </span><span class="s1">if (!data) return []</span><span class="s3">\n\n    </span><span class="s1">// Return the cached matchers if the data has not changed.</span><span class="s3">\n    </span><span class="s1">if (this.data &amp;&amp; this.loader.compare(this.data, data)) return this.cached</span><span class="s3">\n    </span><span class="s1">this.data = data</span><span class="s3">\n\n    </span><span class="s1">// Transform the manifest into matchers.</span><span class="s3">\n    </span><span class="s1">const matchers = await this.transform(data)</span><span class="s3">\n\n    </span><span class="s1">// Cache the matchers.</span><span class="s3">\n    </span><span class="s1">this.cached = matchers</span><span class="s3">\n\n    </span><span class="s1">return matchers</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RouteMatcher } from '../route-matchers/route-matcher'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Manifest,</span><span class="s3">\n  </span><span class="s1">ManifestLoader,</span><span class="s3">\n</span><span class="s1">} from './helpers/manifest-loaders/manifest-loader'</span><span class="s3">\n</span><span class="s1">import { CachedRouteMatcherProvider } from './helpers/cached-route-matcher-provider'</span><span class="s3">\n\n</span><span class="s1">export abstract class ManifestRouteMatcherProvider&lt;</span><span class="s3">\n  </span><span class="s1">M extends RouteMatcher = RouteMatcher,</span><span class="s3">\n</span><span class="s1">&gt; extends CachedRouteMatcherProvider&lt;M, Manifest | null&gt; {</span><span class="s3">\n  </span><span class="s1">constructor(manifestName: string, manifestLoader: ManifestLoader) {</span><span class="s3">\n    </span><span class="s1">super({</span><span class="s3">\n      </span><span class="s1">load: async () =&gt; manifestLoader.load(manifestName),</span><span class="s3">\n      </span><span class="s1">compare: (left, right) =&gt; left === right,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isAppPageRoute } from '../../lib/is-app-page-route'</span><span class="s3">\n\n</span><span class="s1">import { APP_PATHS_MANIFEST } from '../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { AppNormalizers } from '../normalizers/built/app'</span><span class="s3">\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import { AppPageRouteMatcher } from '../route-matchers/app-page-route-matcher'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Manifest,</span><span class="s3">\n  </span><span class="s1">ManifestLoader,</span><span class="s3">\n</span><span class="s1">} from './helpers/manifest-loaders/manifest-loader'</span><span class="s3">\n</span><span class="s1">import { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'</span><span class="s3">\n\n</span><span class="s1">export class AppPageRouteMatcherProvider extends ManifestRouteMatcherProvider&lt;AppPageRouteMatcher&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly normalizers: AppNormalizers</span><span class="s3">\n\n  </span><span class="s1">constructor(distDir: string, manifestLoader: ManifestLoader) {</span><span class="s3">\n    </span><span class="s1">super(APP_PATHS_MANIFEST, manifestLoader)</span><span class="s3">\n\n    </span><span class="s1">this.normalizers = new AppNormalizers(distDir)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async transform(</span><span class="s3">\n    </span><span class="s1">manifest: Manifest</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ReadonlyArray&lt;AppPageRouteMatcher&gt;&gt; {</span><span class="s3">\n    </span><span class="s1">// This matcher only matches app pages.</span><span class="s3">\n    </span><span class="s1">const pages = Object.keys(manifest).filter((page) =&gt; isAppPageRoute(page))</span><span class="s3">\n\n    </span><span class="s1">// Collect all the app paths for each page. This could include any parallel</span><span class="s3">\n    </span><span class="s1">// routes.</span><span class="s3">\n    </span><span class="s1">const allAppPaths: Record&lt;string, string[]&gt; = {}</span><span class="s3">\n    </span><span class="s1">for (const page of pages) {</span><span class="s3">\n      </span><span class="s1">const pathname = this.normalizers.pathname.normalize(page)</span><span class="s3">\n      </span><span class="s1">if (pathname in allAppPaths) allAppPaths[pathname].push(page)</span><span class="s3">\n      </span><span class="s1">else allAppPaths[pathname] = [page]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Format the routes.</span><span class="s3">\n    </span><span class="s1">const matchers: Array&lt;AppPageRouteMatcher&gt; = []</span><span class="s3">\n    </span><span class="s1">for (const [pathname, appPaths] of Object.entries(allAppPaths)) {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: (wyattjoh) this is a hack right now, should be more deterministic</span><span class="s3">\n      </span><span class="s1">const page = appPaths[0]</span><span class="s3">\n\n      </span><span class="s1">const filename = this.normalizers.filename.normalize(manifest[page])</span><span class="s3">\n      </span><span class="s1">const bundlePath = this.normalizers.bundlePath.normalize(page)</span><span class="s3">\n\n      </span><span class="s1">matchers.push(</span><span class="s3">\n        </span><span class="s1">new AppPageRouteMatcher({</span><span class="s3">\n          </span><span class="s1">kind: RouteKind.APP_PAGE,</span><span class="s3">\n          </span><span class="s1">pathname,</span><span class="s3">\n          </span><span class="s1">page,</span><span class="s3">\n          </span><span class="s1">bundlePath,</span><span class="s3">\n          </span><span class="s1">filename,</span><span class="s3">\n          </span><span class="s1">appPaths,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return matchers</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function isAppPageRoute(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">return route.endsWith('/page')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { RouteMatcher } from './route-matcher'</span><span class="s3">\n</span><span class="s1">import type { AppRouteRouteDefinition } from '../route-definitions/app-route-route-definition'</span><span class="s3">\n\n</span><span class="s1">export class AppRouteRouteMatcher extends RouteMatcher&lt;AppRouteRouteDefinition&gt; {}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isAppRouteRoute } from '../../lib/is-app-route-route'</span><span class="s3">\n</span><span class="s1">import { APP_PATHS_MANIFEST } from '../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import { AppRouteRouteMatcher } from '../route-matchers/app-route-route-matcher'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Manifest,</span><span class="s3">\n  </span><span class="s1">ManifestLoader,</span><span class="s3">\n</span><span class="s1">} from './helpers/manifest-loaders/manifest-loader'</span><span class="s3">\n</span><span class="s1">import { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import { AppNormalizers } from '../normalizers/built/app'</span><span class="s3">\n\n</span><span class="s1">export class AppRouteRouteMatcherProvider extends ManifestRouteMatcherProvider&lt;AppRouteRouteMatcher&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly normalizers: AppNormalizers</span><span class="s3">\n\n  </span><span class="s1">constructor(distDir: string, manifestLoader: ManifestLoader) {</span><span class="s3">\n    </span><span class="s1">super(APP_PATHS_MANIFEST, manifestLoader)</span><span class="s3">\n\n    </span><span class="s1">this.normalizers = new AppNormalizers(distDir)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async transform(</span><span class="s3">\n    </span><span class="s1">manifest: Manifest</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ReadonlyArray&lt;AppRouteRouteMatcher&gt;&gt; {</span><span class="s3">\n    </span><span class="s1">// This matcher only matches app routes.</span><span class="s3">\n    </span><span class="s1">const pages = Object.keys(manifest).filter((page) =&gt; isAppRouteRoute(page))</span><span class="s3">\n\n    </span><span class="s1">// Format the routes.</span><span class="s3">\n    </span><span class="s1">const matchers: Array&lt;AppRouteRouteMatcher&gt; = []</span><span class="s3">\n    </span><span class="s1">for (const page of pages) {</span><span class="s3">\n      </span><span class="s1">const filename = this.normalizers.filename.normalize(manifest[page])</span><span class="s3">\n      </span><span class="s1">const pathname = this.normalizers.pathname.normalize(page)</span><span class="s3">\n      </span><span class="s1">const bundlePath = this.normalizers.bundlePath.normalize(page)</span><span class="s3">\n\n      </span><span class="s1">matchers.push(</span><span class="s3">\n        </span><span class="s1">new AppRouteRouteMatcher({</span><span class="s3">\n          </span><span class="s1">kind: RouteKind.APP_ROUTE,</span><span class="s3">\n          </span><span class="s1">pathname,</span><span class="s3">\n          </span><span class="s1">page,</span><span class="s3">\n          </span><span class="s1">bundlePath,</span><span class="s3">\n          </span><span class="s1">filename,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return matchers</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function isAPIRoute(value?: string) {</span><span class="s3">\n  </span><span class="s1">return value === '/api' || Boolean(value?.startsWith('/api/'))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PagesAPIRouteDefinition } from '../route-definitions/pages-api-route-definition'</span><span class="s3">\n</span><span class="s1">import { LocaleRouteMatcher } from './locale-route-matcher'</span><span class="s3">\n</span><span class="s1">import { RouteMatcher } from './route-matcher'</span><span class="s3">\n\n</span><span class="s1">export class PagesAPIRouteMatcher extends RouteMatcher&lt;PagesAPIRouteDefinition&gt; {}</span><span class="s3">\n\n</span><span class="s1">export class PagesAPILocaleRouteMatcher extends LocaleRouteMatcher&lt;PagesAPIRouteDefinition&gt; {}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizePagePath } from '../../../../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n</span><span class="s1">import type { Normalizer } from '../../normalizer'</span><span class="s3">\n</span><span class="s1">import { Normalizers } from '../../normalizers'</span><span class="s3">\n</span><span class="s1">import { PrefixingNormalizer } from '../../prefixing-normalizer'</span><span class="s3">\n</span><span class="s1">import { wrapNormalizerFn } from '../../wrap-normalizer-fn'</span><span class="s3">\n\n</span><span class="s1">export class PagesBundlePathNormalizer extends Normalizers {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\n      </span><span class="s1">// The bundle path should have the trailing `/index` stripped from</span><span class="s3">\n      </span><span class="s1">// it.</span><span class="s3">\n      </span><span class="s1">wrapNormalizerFn(normalizePagePath),</span><span class="s3">\n      </span><span class="s1">// The page should prefixed with `pages/`.</span><span class="s3">\n      </span><span class="s1">new PrefixingNormalizer('pages'),</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(page: string): string {</span><span class="s3">\n    </span><span class="s1">return super.normalize(page)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class DevPagesBundlePathNormalizer extends Normalizers {</span><span class="s3">\n  </span><span class="s1">constructor(pagesNormalizer: Normalizer) {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\n      </span><span class="s1">// This should normalize the filename to a page.</span><span class="s3">\n      </span><span class="s1">pagesNormalizer,</span><span class="s3">\n      </span><span class="s1">// Normalize the app page to a pathname.</span><span class="s3">\n      </span><span class="s1">new PagesBundlePathNormalizer(),</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(filename: string): string {</span><span class="s3">\n    </span><span class="s1">return super.normalize(filename)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { SERVER_DIRECTORY } from '../../../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { PrefixingNormalizer } from '../../prefixing-normalizer'</span><span class="s3">\n\n</span><span class="s1">export class PagesFilenameNormalizer extends PrefixingNormalizer {</span><span class="s3">\n  </span><span class="s1">constructor(distDir: string) {</span><span class="s3">\n    </span><span class="s1">super(distDir, SERVER_DIRECTORY)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(manifestFilename: string): string {</span><span class="s3">\n    </span><span class="s1">return super.normalize(manifestFilename)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">DevPagesBundlePathNormalizer,</span><span class="s3">\n  </span><span class="s1">PagesBundlePathNormalizer,</span><span class="s3">\n</span><span class="s1">} from './pages-bundle-path-normalizer'</span><span class="s3">\n</span><span class="s1">import { PagesFilenameNormalizer } from './pages-filename-normalizer'</span><span class="s3">\n</span><span class="s1">import { DevPagesPageNormalizer } from './pages-page-normalizer'</span><span class="s3">\n</span><span class="s1">import { DevPagesPathnameNormalizer } from './pages-pathname-normalizer'</span><span class="s3">\n\n</span><span class="s1">export class PagesNormalizers {</span><span class="s3">\n  </span><span class="s1">public readonly filename: PagesFilenameNormalizer</span><span class="s3">\n  </span><span class="s1">public readonly bundlePath: PagesBundlePathNormalizer</span><span class="s3">\n\n  </span><span class="s1">constructor(distDir: string) {</span><span class="s3">\n    </span><span class="s1">this.filename = new PagesFilenameNormalizer(distDir)</span><span class="s3">\n    </span><span class="s1">this.bundlePath = new PagesBundlePathNormalizer()</span><span class="s3">\n\n    </span><span class="s1">// You'd think that we'd require a `pathname` normalizer here, but for</span><span class="s3">\n    </span><span class="s1">// `/pages` we have to handle i18n routes, which means that we need to</span><span class="s3">\n    </span><span class="s1">// analyze the page path to determine the locale prefix and it's locale.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class DevPagesNormalizers {</span><span class="s3">\n  </span><span class="s1">public readonly page: DevPagesPageNormalizer</span><span class="s3">\n  </span><span class="s1">public readonly pathname: DevPagesPathnameNormalizer</span><span class="s3">\n  </span><span class="s1">public readonly bundlePath: DevPagesBundlePathNormalizer</span><span class="s3">\n\n  </span><span class="s1">constructor(pagesDir: string, extensions: ReadonlyArray&lt;string&gt;) {</span><span class="s3">\n    </span><span class="s1">this.page = new DevPagesPageNormalizer(pagesDir, extensions)</span><span class="s3">\n    </span><span class="s1">this.pathname = new DevPagesPathnameNormalizer(pagesDir, extensions)</span><span class="s3">\n    </span><span class="s1">this.bundlePath = new DevPagesBundlePathNormalizer(this.page)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isAPIRoute } from '../../lib/is-api-route'</span><span class="s3">\n</span><span class="s1">import { PAGES_MANIFEST } from '../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PagesAPILocaleRouteMatcher,</span><span class="s3">\n  </span><span class="s1">PagesAPIRouteMatcher,</span><span class="s3">\n</span><span class="s1">} from '../route-matchers/pages-api-route-matcher'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Manifest,</span><span class="s3">\n  </span><span class="s1">ManifestLoader,</span><span class="s3">\n</span><span class="s1">} from './helpers/manifest-loaders/manifest-loader'</span><span class="s3">\n</span><span class="s1">import { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../lib/i18n-provider'</span><span class="s3">\n</span><span class="s1">import { PagesNormalizers } from '../normalizers/built/pages'</span><span class="s3">\n\n</span><span class="s1">export class PagesAPIRouteMatcherProvider extends ManifestRouteMatcherProvider&lt;PagesAPIRouteMatcher&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly normalizers: PagesNormalizers</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">distDir: string,</span><span class="s3">\n    </span><span class="s1">manifestLoader: ManifestLoader,</span><span class="s3">\n    </span><span class="s1">private readonly i18nProvider?: I18NProvider</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">super(PAGES_MANIFEST, manifestLoader)</span><span class="s3">\n\n    </span><span class="s1">this.normalizers = new PagesNormalizers(distDir)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async transform(</span><span class="s3">\n    </span><span class="s1">manifest: Manifest</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ReadonlyArray&lt;PagesAPIRouteMatcher&gt;&gt; {</span><span class="s3">\n    </span><span class="s1">// This matcher is only for Pages API routes.</span><span class="s3">\n    </span><span class="s1">const pathnames = Object.keys(manifest).filter((pathname) =&gt;</span><span class="s3">\n      </span><span class="s1">isAPIRoute(pathname)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const matchers: Array&lt;PagesAPIRouteMatcher&gt; = []</span><span class="s3">\n\n    </span><span class="s1">for (const page of pathnames) {</span><span class="s3">\n      </span><span class="s1">if (this.i18nProvider) {</span><span class="s3">\n        </span><span class="s1">// Match the locale on the page name, or default to the default locale.</span><span class="s3">\n        </span><span class="s1">const { detectedLocale, pathname } = this.i18nProvider.analyze(page)</span><span class="s3">\n\n        </span><span class="s1">matchers.push(</span><span class="s3">\n          </span><span class="s1">new PagesAPILocaleRouteMatcher({</span><span class="s3">\n            </span><span class="s1">kind: RouteKind.PAGES_API,</span><span class="s3">\n            </span><span class="s1">pathname,</span><span class="s3">\n            </span><span class="s1">page,</span><span class="s3">\n            </span><span class="s1">bundlePath: this.normalizers.bundlePath.normalize(page),</span><span class="s3">\n            </span><span class="s1">filename: this.normalizers.filename.normalize(manifest[page]),</span><span class="s3">\n            </span><span class="s1">i18n: {</span><span class="s3">\n              </span><span class="s1">locale: detectedLocale,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">matchers.push(</span><span class="s3">\n          </span><span class="s1">new PagesAPIRouteMatcher({</span><span class="s3">\n            </span><span class="s1">kind: RouteKind.PAGES_API,</span><span class="s3">\n            </span><span class="s1">// In `pages/`, the page is the same as the pathname.</span><span class="s3">\n            </span><span class="s1">pathname: page,</span><span class="s3">\n            </span><span class="s1">page,</span><span class="s3">\n            </span><span class="s1">bundlePath: this.normalizers.bundlePath.normalize(page),</span><span class="s3">\n            </span><span class="s1">filename: this.normalizers.filename.normalize(manifest[page]),</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return matchers</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PagesRouteDefinition } from '../route-definitions/pages-route-definition'</span><span class="s3">\n</span><span class="s1">import { LocaleRouteMatcher } from './locale-route-matcher'</span><span class="s3">\n</span><span class="s1">import { RouteMatcher } from './route-matcher'</span><span class="s3">\n\n</span><span class="s1">export class PagesRouteMatcher extends RouteMatcher&lt;PagesRouteDefinition&gt; {}</span><span class="s3">\n\n</span><span class="s1">export class PagesLocaleRouteMatcher extends LocaleRouteMatcher&lt;PagesRouteDefinition&gt; {}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isAPIRoute } from '../../lib/is-api-route'</span><span class="s3">\n</span><span class="s1">import { BLOCKED_PAGES, PAGES_MANIFEST } from '../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PagesLocaleRouteMatcher,</span><span class="s3">\n  </span><span class="s1">PagesRouteMatcher,</span><span class="s3">\n</span><span class="s1">} from '../route-matchers/pages-route-matcher'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Manifest,</span><span class="s3">\n  </span><span class="s1">ManifestLoader,</span><span class="s3">\n</span><span class="s1">} from './helpers/manifest-loaders/manifest-loader'</span><span class="s3">\n</span><span class="s1">import { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../lib/i18n-provider'</span><span class="s3">\n</span><span class="s1">import { PagesNormalizers } from '../normalizers/built/pages'</span><span class="s3">\n\n</span><span class="s1">export class PagesRouteMatcherProvider extends ManifestRouteMatcherProvider&lt;PagesRouteMatcher&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly normalizers: PagesNormalizers</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">distDir: string,</span><span class="s3">\n    </span><span class="s1">manifestLoader: ManifestLoader,</span><span class="s3">\n    </span><span class="s1">private readonly i18nProvider?: I18NProvider</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">super(PAGES_MANIFEST, manifestLoader)</span><span class="s3">\n\n    </span><span class="s1">this.normalizers = new PagesNormalizers(distDir)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async transform(</span><span class="s3">\n    </span><span class="s1">manifest: Manifest</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ReadonlyArray&lt;PagesRouteMatcher&gt;&gt; {</span><span class="s3">\n    </span><span class="s1">// This matcher is only for Pages routes, not Pages API routes which are</span><span class="s3">\n    </span><span class="s1">// included in this manifest.</span><span class="s3">\n    </span><span class="s1">const pathnames = Object.keys(manifest)</span><span class="s3">\n      </span><span class="s1">.filter((pathname) =&gt; !isAPIRoute(pathname))</span><span class="s3">\n      </span><span class="s1">// Remove any blocked pages (page that can't be routed to, like error or</span><span class="s3">\n      </span><span class="s1">// internal pages).</span><span class="s3">\n      </span><span class="s1">.filter((pathname) =&gt; {</span><span class="s3">\n        </span><span class="s1">const normalized =</span><span class="s3">\n          </span><span class="s1">this.i18nProvider?.analyze(pathname).pathname ?? pathname</span><span class="s3">\n\n        </span><span class="s1">// Skip any blocked pages.</span><span class="s3">\n        </span><span class="s1">if (BLOCKED_PAGES.includes(normalized)) return false</span><span class="s3">\n\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const matchers: Array&lt;PagesRouteMatcher&gt; = []</span><span class="s3">\n    </span><span class="s1">for (const page of pathnames) {</span><span class="s3">\n      </span><span class="s1">if (this.i18nProvider) {</span><span class="s3">\n        </span><span class="s1">// Match the locale on the page name, or default to the default locale.</span><span class="s3">\n        </span><span class="s1">const { detectedLocale, pathname } = this.i18nProvider.analyze(page)</span><span class="s3">\n\n        </span><span class="s1">matchers.push(</span><span class="s3">\n          </span><span class="s1">new PagesLocaleRouteMatcher({</span><span class="s3">\n            </span><span class="s1">kind: RouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">pathname,</span><span class="s3">\n            </span><span class="s1">page,</span><span class="s3">\n            </span><span class="s1">bundlePath: this.normalizers.bundlePath.normalize(page),</span><span class="s3">\n            </span><span class="s1">filename: this.normalizers.filename.normalize(manifest[page]),</span><span class="s3">\n            </span><span class="s1">i18n: {</span><span class="s3">\n              </span><span class="s1">locale: detectedLocale,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">matchers.push(</span><span class="s3">\n          </span><span class="s1">new PagesRouteMatcher({</span><span class="s3">\n            </span><span class="s1">kind: RouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">// In `pages/`, the page is the same as the pathname.</span><span class="s3">\n            </span><span class="s1">pathname: page,</span><span class="s3">\n            </span><span class="s1">page,</span><span class="s3">\n            </span><span class="s1">bundlePath: this.normalizers.bundlePath.normalize(page),</span><span class="s3">\n            </span><span class="s1">filename: this.normalizers.filename.normalize(manifest[page]),</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return matchers</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Manifest, ManifestLoader } from './manifest-loader'</span><span class="s3">\n\n</span><span class="s1">export class ServerManifestLoader implements ManifestLoader {</span><span class="s3">\n  </span><span class="s1">constructor(private readonly getter: (name: string) =&gt; Manifest | null) {}</span><span class="s3">\n\n  </span><span class="s1">public load(name: string): Manifest | null {</span><span class="s3">\n    </span><span class="s1">return this.getter(name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { DomainLocale, I18NConfig } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import { getRequestMeta, type NextIncomingMessage } from '../request-meta'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The result of matching a locale aware route.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface LocaleAnalysisResult {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The pathname without the locale prefix (if any).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The detected locale. If no locale was detected, this will be `undefined`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the locale was inferred from the default locale.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">inferredFromDefault: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type LocaleAnalysisOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When provided, it will be used as the default locale if the locale</span><span class="s3">\n   </span><span class="s1">* cannot be inferred from the pathname.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The I18NProvider is used to match locale aware routes, detect the locale from</span><span class="s3">\n </span><span class="s1">* the pathname and hostname and normalize the pathname by removing the locale</span><span class="s3">\n </span><span class="s1">* prefix.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class I18NProvider {</span><span class="s3">\n  </span><span class="s1">private readonly lowerCaseLocales: ReadonlyArray&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">private readonly lowerCaseDomains?: ReadonlyArray&lt;</span><span class="s3">\n    </span><span class="s1">DomainLocale &amp; {</span><span class="s3">\n      </span><span class="s1">// The configuration references a domain with an optional port, but the</span><span class="s3">\n      </span><span class="s1">// hostname is always the domain without the port and is used for</span><span class="s3">\n      </span><span class="s1">// matching.</span><span class="s3">\n      </span><span class="s1">hostname: string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(public readonly config: Readonly&lt;I18NConfig&gt;) {</span><span class="s3">\n    </span><span class="s1">if (!config.locales.length) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: No locales provided')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.lowerCaseLocales = config.locales.map((locale) =&gt; locale.toLowerCase())</span><span class="s3">\n    </span><span class="s1">this.lowerCaseDomains = config.domains?.map((domainLocale) =&gt; {</span><span class="s3">\n      </span><span class="s1">const domain = domainLocale.domain.toLowerCase()</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">defaultLocale: domainLocale.defaultLocale.toLowerCase(),</span><span class="s3">\n        </span><span class="s1">hostname: domain.split(':', 1)[0],</span><span class="s3">\n        </span><span class="s1">domain,</span><span class="s3">\n        </span><span class="s1">locales: domainLocale.locales?.map((locale) =&gt; locale.toLowerCase()),</span><span class="s3">\n        </span><span class="s1">http: domainLocale.http,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Detects the domain locale from the hostname and the detected locale if</span><span class="s3">\n   </span><span class="s1">* provided.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param hostname The hostname to detect the domain locale from, this must be lowercased.</span><span class="s3">\n   </span><span class="s1">* @param detectedLocale The detected locale to use if the hostname does not match.</span><span class="s3">\n   </span><span class="s1">* @returns The domain locale if found, `undefined` otherwise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public detectDomainLocale(</span><span class="s3">\n    </span><span class="s1">hostname?: string,</span><span class="s3">\n    </span><span class="s1">detectedLocale?: string</span><span class="s3">\n  </span><span class="s1">): DomainLocale | undefined {</span><span class="s3">\n    </span><span class="s1">if (!hostname || !this.lowerCaseDomains || !this.config.domains) return</span><span class="s3">\n\n    </span><span class="s1">if (detectedLocale) detectedLocale = detectedLocale.toLowerCase()</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; this.lowerCaseDomains.length; i++) {</span><span class="s3">\n      </span><span class="s1">const domainLocale = this.lowerCaseDomains[i]</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">// We assume that the hostname is already lowercased.</span><span class="s3">\n        </span><span class="s1">domainLocale.hostname === hostname ||</span><span class="s3">\n        </span><span class="s1">// Configuration validation ensures that the locale is not repeated in</span><span class="s3">\n        </span><span class="s1">// other domains locales.</span><span class="s3">\n        </span><span class="s1">domainLocale.locales?.some((locale) =&gt; locale === detectedLocale)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return this.config.domains[i]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pulls the pre-computed locale and inference results from the query</span><span class="s3">\n   </span><span class="s1">* object.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param req the request object</span><span class="s3">\n   </span><span class="s1">* @param pathname the pathname that could contain a locale prefix</span><span class="s3">\n   </span><span class="s1">* @returns the locale analysis result</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public fromRequest(</span><span class="s3">\n    </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n    </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">): LocaleAnalysisResult {</span><span class="s3">\n    </span><span class="s1">const detectedLocale = getRequestMeta(req, 'locale')</span><span class="s3">\n\n    </span><span class="s1">// If a locale was detected on the query, analyze the pathname to ensure</span><span class="s3">\n    </span><span class="s1">// that the locale matches.</span><span class="s3">\n    </span><span class="s1">if (detectedLocale) {</span><span class="s3">\n      </span><span class="s1">const analysis = this.analyze(pathname)</span><span class="s3">\n\n      </span><span class="s1">// If the analysis contained a locale we should validate it against the</span><span class="s3">\n      </span><span class="s1">// query and strip it from the pathname.</span><span class="s3">\n      </span><span class="s1">if (analysis.detectedLocale) {</span><span class="s3">\n        </span><span class="s1">if (analysis.detectedLocale !== detectedLocale) {</span><span class="s3">\n          </span><span class="s1">console.warn(</span><span class="s3">\n            </span><span class="s1">`The detected locale does not match the locale in the query. Expected to find '${detectedLocale}' in '${pathname}' but found '${analysis.detectedLocale}'}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">pathname = analysis.pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">detectedLocale,</span><span class="s3">\n      </span><span class="s1">inferredFromDefault:</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'localeInferredFromDefault') ?? false,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Analyzes the pathname for a locale and returns the pathname without it.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname The pathname that could contain a locale prefix.</span><span class="s3">\n   </span><span class="s1">* @param options The options to use when matching the locale.</span><span class="s3">\n   </span><span class="s1">* @returns The matched locale and the pathname without the locale prefix</span><span class="s3">\n   </span><span class="s1">*          (if any).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public analyze(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">options: LocaleAnalysisOptions = {}</span><span class="s3">\n  </span><span class="s1">): LocaleAnalysisResult {</span><span class="s3">\n    </span><span class="s1">let detectedLocale: string | undefined = options.defaultLocale</span><span class="s3">\n\n    </span><span class="s1">// By default, we assume that the default locale was inferred if there was</span><span class="s3">\n    </span><span class="s1">// no detected locale.</span><span class="s3">\n    </span><span class="s1">let inferredFromDefault = typeof detectedLocale === 'string'</span><span class="s3">\n\n    </span><span class="s1">// The first segment will be empty, because it has a leading `/`. If</span><span class="s3">\n    </span><span class="s1">// there is no further segment, there is no locale (or it's the default).</span><span class="s3">\n    </span><span class="s1">const segments = pathname.split('/', 2)</span><span class="s3">\n    </span><span class="s1">if (!segments[1])</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">detectedLocale,</span><span class="s3">\n        </span><span class="s1">pathname,</span><span class="s3">\n        </span><span class="s1">inferredFromDefault,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// The second segment will contain the locale part if any.</span><span class="s3">\n    </span><span class="s1">const segment = segments[1].toLowerCase()</span><span class="s3">\n\n    </span><span class="s1">// See if the segment matches one of the locales. If it doesn't, there is</span><span class="s3">\n    </span><span class="s1">// no locale (or it's the default).</span><span class="s3">\n    </span><span class="s1">const index = this.lowerCaseLocales.indexOf(segment)</span><span class="s3">\n    </span><span class="s1">if (index &lt; 0)</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">detectedLocale,</span><span class="s3">\n        </span><span class="s1">pathname,</span><span class="s3">\n        </span><span class="s1">inferredFromDefault,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Return the case-sensitive locale.</span><span class="s3">\n    </span><span class="s1">detectedLocale = this.config.locales[index]</span><span class="s3">\n    </span><span class="s1">inferredFromDefault = false</span><span class="s3">\n\n    </span><span class="s1">// Remove the `/${locale}` part of the pathname.</span><span class="s3">\n    </span><span class="s1">pathname = pathname.slice(detectedLocale.length + 1) || '/'</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">detectedLocale,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">inferredFromDefault,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { BaseNextRequest, BaseNextResponse } from './base-http'</span><span class="s3">\n</span><span class="s1">import { isNodeNextResponse } from './base-http/helpers'</span><span class="s3">\n\n</span><span class="s1">import { pipeToNodeResponse } from './pipe-readable'</span><span class="s3">\n</span><span class="s1">import { splitCookiesString } from './web/utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sends the response on the underlying next response object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the underlying request object</span><span class="s3">\n </span><span class="s1">* @param res the underlying response object</span><span class="s3">\n </span><span class="s1">* @param response the response to send</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function sendResponse(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">response: Response,</span><span class="s3">\n  </span><span class="s1">waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n    </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n    </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isNodeNextResponse(res)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// Copy over the response status.</span><span class="s3">\n    </span><span class="s1">res.statusCode = response.status</span><span class="s3">\n    </span><span class="s1">res.statusMessage = response.statusText</span><span class="s3">\n\n    </span><span class="s1">// TODO: this is not spec-compliant behavior and we should not restrict</span><span class="s3">\n    </span><span class="s1">// headers that are allowed to appear many times.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// See:</span><span class="s3">\n    </span><span class="s1">// https://github.com/vercel/next.js/pull/70127</span><span class="s3">\n    </span><span class="s1">const headersWithMultipleValuesAllowed = [</span><span class="s3">\n      </span><span class="s1">// can add more headers to this list if needed</span><span class="s3">\n      </span><span class="s1">'set-cookie',</span><span class="s3">\n      </span><span class="s1">'www-authenticate',</span><span class="s3">\n      </span><span class="s1">'proxy-authenticate',</span><span class="s3">\n      </span><span class="s1">'vary',</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n    </span><span class="s1">// Copy over the response headers.</span><span class="s3">\n    </span><span class="s1">response.headers?.forEach((value, name) =&gt; {</span><span class="s3">\n      </span><span class="s1">// `x-middleware-set-cookie` is an internal header not needed for the response</span><span class="s3">\n      </span><span class="s1">if (name.toLowerCase() === 'x-middleware-set-cookie') {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// The append handling is special cased for `set-cookie`.</span><span class="s3">\n      </span><span class="s1">if (name.toLowerCase() === 'set-cookie') {</span><span class="s3">\n        </span><span class="s1">// TODO: (wyattjoh) replace with native response iteration when we can upgrade undici</span><span class="s3">\n        </span><span class="s1">for (const cookie of splitCookiesString(value)) {</span><span class="s3">\n          </span><span class="s1">res.appendHeader(name, cookie)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// only append the header if it is either not present in the outbound response</span><span class="s3">\n        </span><span class="s1">// or if the header supports multiple values</span><span class="s3">\n        </span><span class="s1">const isHeaderPresent = typeof res.getHeader(name) !== 'undefined'</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">headersWithMultipleValuesAllowed.includes(name.toLowerCase()) ||</span><span class="s3">\n          </span><span class="s1">!isHeaderPresent</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">res.appendHeader(name, value)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The response can't be directly piped to the underlying response. The</span><span class="s3">\n     </span><span class="s1">* following is duplicated from the edge runtime handler.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* See packages/next/server/next-server.ts</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n\n    </span><span class="s1">const { originalResponse } = res</span><span class="s3">\n\n    </span><span class="s1">// A response body must not be sent for HEAD requests. See https://httpwg.org/specs/rfc9110.html#HEAD</span><span class="s3">\n    </span><span class="s1">if (response.body &amp;&amp; req.method !== 'HEAD') {</span><span class="s3">\n      </span><span class="s1">await pipeToNodeResponse(response.body, originalResponse, waitUntil)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">originalResponse.end()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { getPathMatch } from '../../shared/lib/router/utils/path-match'</span><span class="s3">\n\n</span><span class="s1">const matcher = getPathMatch('/_next/data/:path*')</span><span class="s3">\n\n</span><span class="s1">export function matchNextDataPathname(pathname: string | null | undefined) {</span><span class="s3">\n  </span><span class="s1">if (typeof pathname !== 'string') return false</span><span class="s3">\n\n  </span><span class="s1">return matcher(pathname)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Normalizer } from '../normalizer'</span><span class="s3">\n\n</span><span class="s1">export class SuffixPathnameNormalizer implements Normalizer {</span><span class="s3">\n  </span><span class="s1">constructor(private readonly suffix: string) {}</span><span class="s3">\n\n  </span><span class="s1">public match(pathname: string) {</span><span class="s3">\n    </span><span class="s1">// If the pathname doesn't end in the suffix, we don't match.</span><span class="s3">\n    </span><span class="s1">if (!pathname.endsWith(this.suffix)) return false</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(pathname: string, matched?: boolean): string {</span><span class="s3">\n    </span><span class="s1">// If we're not matched and we don't match, we don't need to normalize.</span><span class="s3">\n    </span><span class="s1">if (!matched &amp;&amp; !this.match(pathname)) return pathname</span><span class="s3">\n\n    </span><span class="s1">return pathname.substring(0, pathname.length - this.suffix.length)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PathnameNormalizer } from './pathname-normalizer'</span><span class="s3">\n\n</span><span class="s1">import { RSC_SUFFIX } from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { SuffixPathnameNormalizer } from './suffix'</span><span class="s3">\n\n</span><span class="s1">export class RSCPathnameNormalizer</span><span class="s3">\n  </span><span class="s1">extends SuffixPathnameNormalizer</span><span class="s3">\n  </span><span class="s1">implements PathnameNormalizer</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(RSC_SUFFIX)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PathnameNormalizer } from './pathname-normalizer'</span><span class="s3">\n\n</span><span class="s1">import { RSC_PREFETCH_SUFFIX } from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { SuffixPathnameNormalizer } from './suffix'</span><span class="s3">\n\n</span><span class="s1">export class PrefetchRSCPathnameNormalizer</span><span class="s3">\n  </span><span class="s1">extends SuffixPathnameNormalizer</span><span class="s3">\n  </span><span class="s1">implements PathnameNormalizer</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(RSC_PREFETCH_SUFFIX)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public match(pathname: string): boolean {</span><span class="s3">\n    </span><span class="s1">if (pathname === '/__index' + RSC_PREFETCH_SUFFIX) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return super.match(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(pathname: string, matched?: boolean): string {</span><span class="s3">\n    </span><span class="s1">if (pathname === '/__index' + RSC_PREFETCH_SUFFIX) {</span><span class="s3">\n      </span><span class="s1">return '/'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return super.normalize(pathname, matched)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Normalizer } from '../normalizer'</span><span class="s3">\n\n</span><span class="s1">export class PrefixPathnameNormalizer implements Normalizer {</span><span class="s3">\n  </span><span class="s1">constructor(private readonly prefix: string) {</span><span class="s3">\n    </span><span class="s1">if (prefix.endsWith('/')) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`PrefixPathnameNormalizer: prefix </span><span class="s3">\&quot;</span><span class="s1">${prefix}</span><span class="s3">\&quot; </span><span class="s1">should not end with a slash`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public match(pathname: string) {</span><span class="s3">\n    </span><span class="s1">// If the pathname doesn't start with the prefix, we don't match.</span><span class="s3">\n    </span><span class="s1">if (pathname !== this.prefix &amp;&amp; !pathname.startsWith(this.prefix + '/')) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(pathname: string, matched?: boolean): string {</span><span class="s3">\n    </span><span class="s1">// If we're not matched and we don't match, we don't need to normalize.</span><span class="s3">\n    </span><span class="s1">if (!matched &amp;&amp; !this.match(pathname)) return pathname</span><span class="s3">\n\n    </span><span class="s1">if (pathname.length === this.prefix.length) {</span><span class="s3">\n      </span><span class="s1">return '/'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return pathname.substring(this.prefix.length)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PathnameNormalizer } from './pathname-normalizer'</span><span class="s3">\n\n</span><span class="s1">import { denormalizePagePath } from '../../../shared/lib/page-path/denormalize-page-path'</span><span class="s3">\n</span><span class="s1">import { PrefixPathnameNormalizer } from './prefix'</span><span class="s3">\n</span><span class="s1">import { SuffixPathnameNormalizer } from './suffix'</span><span class="s3">\n\n</span><span class="s1">export class NextDataPathnameNormalizer implements PathnameNormalizer {</span><span class="s3">\n  </span><span class="s1">private readonly prefix: PrefixPathnameNormalizer</span><span class="s3">\n  </span><span class="s1">private readonly suffix = new SuffixPathnameNormalizer('.json')</span><span class="s3">\n  </span><span class="s1">constructor(buildID: string) {</span><span class="s3">\n    </span><span class="s1">if (!buildID) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: buildID is required')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.prefix = new PrefixPathnameNormalizer(`/_next/data/${buildID}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public match(pathname: string) {</span><span class="s3">\n    </span><span class="s1">return this.prefix.match(pathname) &amp;&amp; this.suffix.match(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(pathname: string, matched?: boolean): string {</span><span class="s3">\n    </span><span class="s1">// If we're not matched and we don't match, we don't need to normalize.</span><span class="s3">\n    </span><span class="s1">if (!matched &amp;&amp; !this.match(pathname)) return pathname</span><span class="s3">\n\n    </span><span class="s1">pathname = this.prefix.normalize(pathname, true)</span><span class="s3">\n    </span><span class="s1">pathname = this.suffix.normalize(pathname, true)</span><span class="s3">\n\n    </span><span class="s1">return denormalizePagePath(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This transforms a URL pathname into a route. It removes any trailing slashes</span><span class="s3">\n </span><span class="s1">* and the `/index` suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pathname - The URL path that needs to be optimized.</span><span class="s3">\n </span><span class="s1">* @returns - The route</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/example'</span><span class="s3">\n </span><span class="s1">* toRoute('/example/index/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/example'</span><span class="s3">\n </span><span class="s1">* toRoute('/example/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/'</span><span class="s3">\n </span><span class="s1">* toRoute('/index/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/'</span><span class="s3">\n </span><span class="s1">* toRoute('/');</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function toRoute(pathname: string): string {</span><span class="s3">\n  </span><span class="s1">return pathname.replace(/(?:</span><span class="s3">\\</span><span class="s1">/index)?</span><span class="s3">\\</span><span class="s1">/?$/, '') || '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AsyncLocalStorage } from 'async_hooks'</span><span class="s3">\n\n</span><span class="s1">const sharedAsyncLocalStorageNotAvailableError = new Error(</span><span class="s3">\n  </span><span class="s1">'Invariant: AsyncLocalStorage accessed in runtime where it is not available'</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">class FakeAsyncLocalStorage&lt;Store extends {}&gt;</span><span class="s3">\n  </span><span class="s1">implements AsyncLocalStorage&lt;Store&gt;</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">disable(): void {</span><span class="s3">\n    </span><span class="s1">throw sharedAsyncLocalStorageNotAvailableError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getStore(): Store | undefined {</span><span class="s3">\n    </span><span class="s1">// This fake implementation of AsyncLocalStorage always returns `undefined`.</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">run&lt;R&gt;(): R {</span><span class="s3">\n    </span><span class="s1">throw sharedAsyncLocalStorageNotAvailableError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">exit&lt;R&gt;(): R {</span><span class="s3">\n    </span><span class="s1">throw sharedAsyncLocalStorageNotAvailableError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">enterWith(): void {</span><span class="s3">\n    </span><span class="s1">throw sharedAsyncLocalStorageNotAvailableError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static bind&lt;T&gt;(fn: T): T {</span><span class="s3">\n    </span><span class="s1">return fn</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const maybeGlobalAsyncLocalStorage =</span><span class="s3">\n  </span><span class="s1">typeof globalThis !== 'undefined' &amp;&amp; (globalThis as any).AsyncLocalStorage</span><span class="s3">\n\n</span><span class="s1">export function createAsyncLocalStorage&lt;</span><span class="s3">\n  </span><span class="s1">Store extends {},</span><span class="s3">\n</span><span class="s1">&gt;(): AsyncLocalStorage&lt;Store&gt; {</span><span class="s3">\n  </span><span class="s1">if (maybeGlobalAsyncLocalStorage) {</span><span class="s3">\n    </span><span class="s1">return new maybeGlobalAsyncLocalStorage()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return new FakeAsyncLocalStorage()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function bindSnapshot&lt;T&gt;(fn: T): T {</span><span class="s3">\n  </span><span class="s1">if (maybeGlobalAsyncLocalStorage) {</span><span class="s3">\n    </span><span class="s1">return maybeGlobalAsyncLocalStorage.bind(fn)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return FakeAsyncLocalStorage.bind(fn)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createSnapshot(): &lt;R, TArgs extends any[]&gt;(</span><span class="s3">\n  </span><span class="s1">fn: (...args: TArgs) =&gt; R,</span><span class="s3">\n  </span><span class="s1">...args: TArgs</span><span class="s3">\n</span><span class="s1">) =&gt; R {</span><span class="s3">\n  </span><span class="s1">if (maybeGlobalAsyncLocalStorage) {</span><span class="s3">\n    </span><span class="s1">return maybeGlobalAsyncLocalStorage.snapshot()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function (fn: any, ...args: any[]) {</span><span class="s3">\n    </span><span class="s1">return fn(...args)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { createAsyncLocalStorage } from '../app-render/async-local-storage'</span><span class="s3">\n\n</span><span class="s1">export function getBuiltinRequestContext():</span><span class="s3">\n  </span><span class="s1">| BuiltinRequestContextValue</span><span class="s3">\n  </span><span class="s1">| undefined {</span><span class="s3">\n  </span><span class="s1">const _globalThis = globalThis as GlobalThisWithRequestContext</span><span class="s3">\n  </span><span class="s1">const ctx = _globalThis[NEXT_REQUEST_CONTEXT_SYMBOL]</span><span class="s3">\n  </span><span class="s1">return ctx?.get()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const NEXT_REQUEST_CONTEXT_SYMBOL = Symbol.for('@next/request-context')</span><span class="s3">\n\n</span><span class="s1">type GlobalThisWithRequestContext = typeof globalThis &amp; {</span><span class="s3">\n  </span><span class="s1">[NEXT_REQUEST_CONTEXT_SYMBOL]?: BuiltinRequestContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** A request context provided by the platform. */</span><span class="s3">\n</span><span class="s1">export type BuiltinRequestContext = {</span><span class="s3">\n  </span><span class="s1">get(): BuiltinRequestContextValue | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RunnableBuiltinRequestContext = BuiltinRequestContext &amp; {</span><span class="s3">\n  </span><span class="s1">run&lt;T&gt;(value: BuiltinRequestContextValue, callback: () =&gt; T): T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type BuiltinRequestContextValue = {</span><span class="s3">\n  </span><span class="s1">waitUntil?: WaitUntil</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export type WaitUntil = (promise: Promise&lt;any&gt;) =&gt; void</span><span class="s3">\n\n</span><span class="s1">/** </span><span class="s3">\&quot;</span><span class="s1">@next/request-context</span><span class="s3">\&quot; </span><span class="s1">has a different signature from AsyncLocalStorage,</span><span class="s3">\n </span><span class="s1">* matching [AsyncContext.Variable](https://github.com/tc39/proposal-async-context).</span><span class="s3">\n </span><span class="s1">* We don't need a full AsyncContext adapter here, just having `.get()` is enough</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createLocalRequestContext(): RunnableBuiltinRequestContext {</span><span class="s3">\n  </span><span class="s1">const storage = createAsyncLocalStorage&lt;BuiltinRequestContextValue&gt;()</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">get: () =&gt; storage.getStore(),</span><span class="s3">\n    </span><span class="s1">run: (value, callback) =&gt; storage.run(value, callback),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { WaitUntil } from '../../after/builtin-request-context'</span><span class="s3">\n</span><span class="s1">import { PageSignatureError } from '../error'</span><span class="s3">\n</span><span class="s1">import type { NextRequest } from './request'</span><span class="s3">\n\n</span><span class="s1">const responseSymbol = Symbol('response')</span><span class="s3">\n</span><span class="s1">const passThroughSymbol = Symbol('passThrough')</span><span class="s3">\n</span><span class="s1">const waitUntilSymbol = Symbol('waitUntil')</span><span class="s3">\n\n</span><span class="s1">class FetchEvent {</span><span class="s3">\n  </span><span class="s1">// TODO(after): get rid of the 'internal' variant and always use an external waitUntil</span><span class="s3">\n  </span><span class="s1">// (this means removing `FetchEventResult.waitUntil` which also requires a builder change)</span><span class="s3">\n  </span><span class="s1">readonly [waitUntilSymbol]:</span><span class="s3">\n    </span><span class="s1">| { kind: 'internal'; promises: Promise&lt;any&gt;[] }</span><span class="s3">\n    </span><span class="s1">| { kind: 'external'; function: WaitUntil };</span><span class="s3">\n\n  </span><span class="s1">[responseSymbol]?: Promise&lt;Response&gt;;</span><span class="s3">\n  </span><span class="s1">[passThroughSymbol] = false</span><span class="s3">\n\n  </span><span class="s1">constructor(_request: Request, waitUntil?: WaitUntil) {</span><span class="s3">\n    </span><span class="s1">this[waitUntilSymbol] = waitUntil</span><span class="s3">\n      </span><span class="s1">? { kind: 'external', function: waitUntil }</span><span class="s3">\n      </span><span class="s1">: { kind: 'internal', promises: [] }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO: is this dead code? NextFetchEvent never lets this get called</span><span class="s3">\n  </span><span class="s1">respondWith(response: Response | Promise&lt;Response&gt;): void {</span><span class="s3">\n    </span><span class="s1">if (!this[responseSymbol]) {</span><span class="s3">\n      </span><span class="s1">this[responseSymbol] = Promise.resolve(response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO: is this dead code? passThroughSymbol is unused</span><span class="s3">\n  </span><span class="s1">passThroughOnException(): void {</span><span class="s3">\n    </span><span class="s1">this[passThroughSymbol] = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">waitUntil(promise: Promise&lt;any&gt;): void {</span><span class="s3">\n    </span><span class="s1">if (this[waitUntilSymbol].kind === 'external') {</span><span class="s3">\n      </span><span class="s1">// if we received an external waitUntil, we delegate to it</span><span class="s3">\n      </span><span class="s1">// TODO(after): this will make us not go through `getServerError(error, 'edge-server')` in `sandbox`</span><span class="s3">\n      </span><span class="s1">const waitUntil = this[waitUntilSymbol].function</span><span class="s3">\n      </span><span class="s1">return waitUntil(promise)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// if we didn't receive an external waitUntil, we make it work on our own</span><span class="s3">\n      </span><span class="s1">// (and expect the caller to do something with the promises)</span><span class="s3">\n      </span><span class="s1">this[waitUntilSymbol].promises.push(promise)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getWaitUntilPromiseFromEvent(</span><span class="s3">\n  </span><span class="s1">event: FetchEvent</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; | undefined {</span><span class="s3">\n  </span><span class="s1">return event[waitUntilSymbol].kind === 'internal'</span><span class="s3">\n    </span><span class="s1">? Promise.all(event[waitUntilSymbol].promises).then(() =&gt; {})</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class NextFetchEvent extends FetchEvent {</span><span class="s3">\n  </span><span class="s1">sourcePage: string</span><span class="s3">\n\n  </span><span class="s1">constructor(params: {</span><span class="s3">\n    </span><span class="s1">request: NextRequest</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">context: { waitUntil: WaitUntil } | undefined</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">super(params.request, params.context?.waitUntil)</span><span class="s3">\n    </span><span class="s1">this.sourcePage = params.page</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated The `request` is now the first parameter and the API is now async.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-new-signature</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get request() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({</span><span class="s3">\n      </span><span class="s1">page: this.sourcePage,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated Using `respondWith` is no longer needed.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-new-signature</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">respondWith() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({</span><span class="s3">\n      </span><span class="s1">page: this.sourcePage,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { stringifyCookie } from '../../web/spec-extension/cookies'</span><span class="s3">\n</span><span class="s1">import type { I18NConfig } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import { NextURL } from '../next-url'</span><span class="s3">\n</span><span class="s1">import { toNodeOutgoingHttpHeaders, validateURL } from '../utils'</span><span class="s3">\n</span><span class="s1">import { ReflectAdapter } from './adapters/reflect'</span><span class="s3">\n\n</span><span class="s1">import { ResponseCookies } from './cookies'</span><span class="s3">\n\n</span><span class="s1">const INTERNALS = Symbol('internal response')</span><span class="s3">\n</span><span class="s1">const REDIRECTS = new Set([301, 302, 303, 307, 308])</span><span class="s3">\n\n</span><span class="s1">function handleMiddlewareField(</span><span class="s3">\n  </span><span class="s1">init: MiddlewareResponseInit | undefined,</span><span class="s3">\n  </span><span class="s1">headers: Headers</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (init?.request?.headers) {</span><span class="s3">\n    </span><span class="s1">if (!(init.request.headers instanceof Headers)) {</span><span class="s3">\n      </span><span class="s1">throw new Error('request.headers must be an instance of Headers')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const keys = []</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of init.request.headers) {</span><span class="s3">\n      </span><span class="s1">headers.set('x-middleware-request-' + key, value)</span><span class="s3">\n      </span><span class="s1">keys.push(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">headers.set('x-middleware-override-headers', keys.join(','))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This class extends the [Web `Response` API](https://developer.mozilla.org/docs/Web/API/Response) with additional convenience methods.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `NextResponse`](https://nextjs.org/docs/app/api-reference/functions/next-response)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class NextResponse&lt;Body = unknown&gt; extends Response {</span><span class="s3">\n  </span><span class="s1">[INTERNALS]: {</span><span class="s3">\n    </span><span class="s1">cookies: ResponseCookies</span><span class="s3">\n    </span><span class="s1">url?: NextURL</span><span class="s3">\n    </span><span class="s1">body?: Body</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(body?: BodyInit | null, init: ResponseInit = {}) {</span><span class="s3">\n    </span><span class="s1">super(body, init)</span><span class="s3">\n\n    </span><span class="s1">const headers = this.headers</span><span class="s3">\n    </span><span class="s1">const cookies = new ResponseCookies(headers)</span><span class="s3">\n\n    </span><span class="s1">const cookiesProxy = new Proxy(cookies, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">switch (prop) {</span><span class="s3">\n          </span><span class="s1">case 'delete':</span><span class="s3">\n          </span><span class="s1">case 'set': {</span><span class="s3">\n            </span><span class="s1">return (...args: [string, string]) =&gt; {</span><span class="s3">\n              </span><span class="s1">const result = Reflect.apply(target[prop], target, args)</span><span class="s3">\n              </span><span class="s1">const newHeaders = new Headers(headers)</span><span class="s3">\n\n              </span><span class="s1">if (result instanceof ResponseCookies) {</span><span class="s3">\n                </span><span class="s1">headers.set(</span><span class="s3">\n                  </span><span class="s1">'x-middleware-set-cookie',</span><span class="s3">\n                  </span><span class="s1">result</span><span class="s3">\n                    </span><span class="s1">.getAll()</span><span class="s3">\n                    </span><span class="s1">.map((cookie) =&gt; stringifyCookie(cookie))</span><span class="s3">\n                    </span><span class="s1">.join(',')</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">handleMiddlewareField(init, newHeaders)</span><span class="s3">\n              </span><span class="s1">return result</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">this[INTERNALS] = {</span><span class="s3">\n      </span><span class="s1">cookies: cookiesProxy,</span><span class="s3">\n      </span><span class="s1">url: init.url</span><span class="s3">\n        </span><span class="s1">? new NextURL(init.url, {</span><span class="s3">\n            </span><span class="s1">headers: toNodeOutgoingHttpHeaders(headers),</span><span class="s3">\n            </span><span class="s1">nextConfig: init.nextConfig,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.for('edge-runtime.inspect.custom')]() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">cookies: this.cookies,</span><span class="s3">\n      </span><span class="s1">url: this.url,</span><span class="s3">\n      </span><span class="s1">// rest of props come from Response</span><span class="s3">\n      </span><span class="s1">body: this.body,</span><span class="s3">\n      </span><span class="s1">bodyUsed: this.bodyUsed,</span><span class="s3">\n      </span><span class="s1">headers: Object.fromEntries(this.headers),</span><span class="s3">\n      </span><span class="s1">ok: this.ok,</span><span class="s3">\n      </span><span class="s1">redirected: this.redirected,</span><span class="s3">\n      </span><span class="s1">status: this.status,</span><span class="s3">\n      </span><span class="s1">statusText: this.statusText,</span><span class="s3">\n      </span><span class="s1">type: this.type,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get cookies() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].cookies</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static json&lt;JsonBody&gt;(</span><span class="s3">\n    </span><span class="s1">body: JsonBody,</span><span class="s3">\n    </span><span class="s1">init?: ResponseInit</span><span class="s3">\n  </span><span class="s1">): NextResponse&lt;JsonBody&gt; {</span><span class="s3">\n    </span><span class="s1">const response: Response = Response.json(body, init)</span><span class="s3">\n    </span><span class="s1">return new NextResponse(response.body, response)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static redirect(url: string | NextURL | URL, init?: number | ResponseInit) {</span><span class="s3">\n    </span><span class="s1">const status = typeof init === 'number' ? init : init?.status ?? 307</span><span class="s3">\n    </span><span class="s1">if (!REDIRECTS.has(status)) {</span><span class="s3">\n      </span><span class="s1">throw new RangeError(</span><span class="s3">\n        </span><span class="s1">'Failed to execute </span><span class="s3">\&quot;</span><span class="s1">redirect</span><span class="s3">\&quot; </span><span class="s1">on </span><span class="s3">\&quot;</span><span class="s1">response</span><span class="s3">\&quot;</span><span class="s1">: Invalid status code'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const initObj = typeof init === 'object' ? init : {}</span><span class="s3">\n    </span><span class="s1">const headers = new Headers(initObj?.headers)</span><span class="s3">\n    </span><span class="s1">headers.set('Location', validateURL(url))</span><span class="s3">\n\n    </span><span class="s1">return new NextResponse(null, {</span><span class="s3">\n      </span><span class="s1">...initObj,</span><span class="s3">\n      </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">status,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static rewrite(</span><span class="s3">\n    </span><span class="s1">destination: string | NextURL | URL,</span><span class="s3">\n    </span><span class="s1">init?: MiddlewareResponseInit</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const headers = new Headers(init?.headers)</span><span class="s3">\n    </span><span class="s1">headers.set('x-middleware-rewrite', validateURL(destination))</span><span class="s3">\n\n    </span><span class="s1">handleMiddlewareField(init, headers)</span><span class="s3">\n    </span><span class="s1">return new NextResponse(null, { ...init, headers })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static next(init?: MiddlewareResponseInit) {</span><span class="s3">\n    </span><span class="s1">const headers = new Headers(init?.headers)</span><span class="s3">\n    </span><span class="s1">headers.set('x-middleware-next', '1')</span><span class="s3">\n\n    </span><span class="s1">handleMiddlewareField(init, headers)</span><span class="s3">\n    </span><span class="s1">return new NextResponse(null, { ...init, headers })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface ResponseInit extends globalThis.ResponseInit {</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: I18NConfig</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">url?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface ModifiedRequest {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If this is set, the request headers will be overridden with this value.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">headers?: Headers</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface MiddlewareResponseInit extends globalThis.ResponseInit {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* These fields will override the request from clients.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">request?: ModifiedRequest</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { RequestCookies } from '../cookies'</span><span class="s3">\n\n</span><span class="s1">import { ResponseCookies } from '../cookies'</span><span class="s3">\n</span><span class="s1">import { ReflectAdapter } from './reflect'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../../../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type { RequestStore } from '../../../app-render/work-unit-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ReadonlyRequestCookiesError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static callable() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyRequestCookiesError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We use this to type some APIs but we don't construct instances directly</span><span class="s3">\n</span><span class="s1">export type { ResponseCookies }</span><span class="s3">\n\n</span><span class="s1">// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,</span><span class="s3">\n</span><span class="s1">// we want to return the request cookie if it exists. For mutative methods like `.set()`,</span><span class="s3">\n</span><span class="s1">// we want to return the response cookie.</span><span class="s3">\n</span><span class="s1">export type ReadonlyRequestCookies = Omit&lt;</span><span class="s3">\n  </span><span class="s1">RequestCookies,</span><span class="s3">\n  </span><span class="s1">'set' | 'clear' | 'delete'</span><span class="s3">\n</span><span class="s1">&gt; &amp;</span><span class="s3">\n  </span><span class="s1">Pick&lt;ResponseCookies, 'set' | 'delete'&gt;</span><span class="s3">\n\n</span><span class="s1">export class RequestCookiesAdapter {</span><span class="s3">\n  </span><span class="s1">public static seal(cookies: RequestCookies): ReadonlyRequestCookies {</span><span class="s3">\n    </span><span class="s1">return new Proxy(cookies as any, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">switch (prop) {</span><span class="s3">\n          </span><span class="s1">case 'clear':</span><span class="s3">\n          </span><span class="s1">case 'delete':</span><span class="s3">\n          </span><span class="s1">case 'set':</span><span class="s3">\n            </span><span class="s1">return ReadonlyRequestCookiesError.callable</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')</span><span class="s3">\n\n</span><span class="s1">export function getModifiedCookieValues(</span><span class="s3">\n  </span><span class="s1">cookies: ResponseCookies</span><span class="s3">\n</span><span class="s1">): ResponseCookie[] {</span><span class="s3">\n  </span><span class="s1">const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[</span><span class="s3">\n    </span><span class="s1">SYMBOL_MODIFY_COOKIE_VALUES</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">if (!modified || !Array.isArray(modified) || modified.length === 0) {</span><span class="s3">\n    </span><span class="s1">return []</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return modified</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SetCookieArgs =</span><span class="s3">\n  </span><span class="s1">| [key: string, value: string, cookie?: Partial&lt;ResponseCookie&gt;]</span><span class="s3">\n  </span><span class="s1">| [options: ResponseCookie]</span><span class="s3">\n\n</span><span class="s1">export function appendMutableCookies(</span><span class="s3">\n  </span><span class="s1">headers: Headers,</span><span class="s3">\n  </span><span class="s1">mutableCookies: ResponseCookies</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const modifiedCookieValues = getModifiedCookieValues(mutableCookies)</span><span class="s3">\n  </span><span class="s1">if (modifiedCookieValues.length === 0) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Return a new response that extends the response with</span><span class="s3">\n  </span><span class="s1">// the modified cookies as fallbacks. `res` cookies</span><span class="s3">\n  </span><span class="s1">// will still take precedence.</span><span class="s3">\n  </span><span class="s1">const resCookies = new ResponseCookies(headers)</span><span class="s3">\n  </span><span class="s1">const returnedCookies = resCookies.getAll()</span><span class="s3">\n\n  </span><span class="s1">// Set the modified cookies as fallbacks.</span><span class="s3">\n  </span><span class="s1">for (const cookie of modifiedCookieValues) {</span><span class="s3">\n    </span><span class="s1">resCookies.set(cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Set the original cookies as the final values.</span><span class="s3">\n  </span><span class="s1">for (const cookie of returnedCookies) {</span><span class="s3">\n    </span><span class="s1">resCookies.set(cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ResponseCookie = NonNullable&lt;</span><span class="s3">\n  </span><span class="s1">ReturnType&lt;InstanceType&lt;typeof ResponseCookies&gt;['get']&gt;</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export class MutableRequestCookiesAdapter {</span><span class="s3">\n  </span><span class="s1">public static wrap(</span><span class="s3">\n    </span><span class="s1">cookies: RequestCookies,</span><span class="s3">\n    </span><span class="s1">onUpdateCookies?: (cookies: string[]) =&gt; void</span><span class="s3">\n  </span><span class="s1">): ResponseCookies {</span><span class="s3">\n    </span><span class="s1">const responseCookies = new ResponseCookies(new Headers())</span><span class="s3">\n    </span><span class="s1">for (const cookie of cookies.getAll()) {</span><span class="s3">\n      </span><span class="s1">responseCookies.set(cookie)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let modifiedValues: ResponseCookie[] = []</span><span class="s3">\n    </span><span class="s1">const modifiedCookies = new Set&lt;string&gt;()</span><span class="s3">\n    </span><span class="s1">const updateResponseCookies = () =&gt; {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: change method of getting workStore</span><span class="s3">\n      </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">if (workStore) {</span><span class="s3">\n        </span><span class="s1">workStore.pathWasRevalidated = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const allCookies = responseCookies.getAll()</span><span class="s3">\n      </span><span class="s1">modifiedValues = allCookies.filter((c) =&gt; modifiedCookies.has(c.name))</span><span class="s3">\n      </span><span class="s1">if (onUpdateCookies) {</span><span class="s3">\n        </span><span class="s1">const serializedCookies: string[] = []</span><span class="s3">\n        </span><span class="s1">for (const cookie of modifiedValues) {</span><span class="s3">\n          </span><span class="s1">const tempCookies = new ResponseCookies(new Headers())</span><span class="s3">\n          </span><span class="s1">tempCookies.set(cookie)</span><span class="s3">\n          </span><span class="s1">serializedCookies.push(tempCookies.toString())</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">onUpdateCookies(serializedCookies)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const wrappedCookies = new Proxy(responseCookies, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">switch (prop) {</span><span class="s3">\n          </span><span class="s1">// A special symbol to get the modified cookie values</span><span class="s3">\n          </span><span class="s1">case SYMBOL_MODIFY_COOKIE_VALUES:</span><span class="s3">\n            </span><span class="s1">return modifiedValues</span><span class="s3">\n\n          </span><span class="s1">// TODO: Throw error if trying to set a cookie after the response</span><span class="s3">\n          </span><span class="s1">// headers have been set.</span><span class="s3">\n          </span><span class="s1">case 'delete':</span><span class="s3">\n            </span><span class="s1">return function (...args: [string] | [ResponseCookie]) {</span><span class="s3">\n              </span><span class="s1">modifiedCookies.add(</span><span class="s3">\n                </span><span class="s1">typeof args[0] === 'string' ? args[0] : args[0].name</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">target.delete(...args)</span><span class="s3">\n                </span><span class="s1">return wrappedCookies</span><span class="s3">\n              </span><span class="s1">} finally {</span><span class="s3">\n                </span><span class="s1">updateResponseCookies()</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case 'set':</span><span class="s3">\n            </span><span class="s1">return function (...args: SetCookieArgs) {</span><span class="s3">\n              </span><span class="s1">modifiedCookies.add(</span><span class="s3">\n                </span><span class="s1">typeof args[0] === 'string' ? args[0] : args[0].name</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">target.set(...args)</span><span class="s3">\n                </span><span class="s1">return wrappedCookies</span><span class="s3">\n              </span><span class="s1">} finally {</span><span class="s3">\n                </span><span class="s1">updateResponseCookies()</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">return wrappedCookies</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createCookiesWithMutableAccessCheck(</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore</span><span class="s3">\n</span><span class="s1">): ResponseCookies {</span><span class="s3">\n  </span><span class="s1">const wrappedCookies = new Proxy(requestStore.mutableCookies, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">switch (prop) {</span><span class="s3">\n        </span><span class="s1">case 'delete':</span><span class="s3">\n          </span><span class="s1">return function (...args: [string] | [ResponseCookie]) {</span><span class="s3">\n            </span><span class="s1">ensureCookiesAreStillMutable(requestStore, 'cookies().delete')</span><span class="s3">\n            </span><span class="s1">target.delete(...args)</span><span class="s3">\n            </span><span class="s1">return wrappedCookies</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'set':</span><span class="s3">\n          </span><span class="s1">return function (...args: SetCookieArgs) {</span><span class="s3">\n            </span><span class="s1">ensureCookiesAreStillMutable(requestStore, 'cookies().set')</span><span class="s3">\n            </span><span class="s1">target.set(...args)</span><span class="s3">\n            </span><span class="s1">return wrappedCookies</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return wrappedCookies</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {</span><span class="s3">\n  </span><span class="s1">return requestStore.phase === 'action'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Ensure that cookies() starts throwing on mutation</span><span class="s3">\n </span><span class="s1">* if we changed phases and can no longer mutate.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This can happen when going:</span><span class="s3">\n </span><span class="s1">*   'render' -&gt; 'after'</span><span class="s3">\n </span><span class="s1">*   'action' -&gt; 'render'</span><span class="s3">\n </span><span class="s1">* */</span><span class="s3">\n</span><span class="s1">function ensureCookiesAreStillMutable(</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore,</span><span class="s3">\n  </span><span class="s1">_callingExpression: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!areCookiesMutableInCurrentPhase(requestStore)) {</span><span class="s3">\n    </span><span class="s1">// TODO: maybe we can give a more precise error message based on callingExpression?</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyRequestCookiesError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function responseCookiesToRequestCookies(</span><span class="s3">\n  </span><span class="s1">responseCookies: ResponseCookies</span><span class="s3">\n</span><span class="s1">): RequestCookies {</span><span class="s3">\n  </span><span class="s1">const requestCookies = new RequestCookies(new Headers())</span><span class="s3">\n  </span><span class="s1">for (const cookie of responseCookies.getAll()) {</span><span class="s3">\n    </span><span class="s1">requestCookies.set(cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return requestCookies</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import DefaultCacheHandler from '../lib/cache-handlers/default.external'</span><span class="s3">\n</span><span class="s1">import type { CacheHandlerCompat } from '../lib/cache-handlers/types'</span><span class="s3">\n\n</span><span class="s1">const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">? (message: string, ...args: any[]) =&gt; {</span><span class="s3">\n      </span><span class="s1">console.log(`use-cache: ${message}`, ...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">const handlersSymbol = Symbol.for('@next/cache-handlers')</span><span class="s3">\n</span><span class="s1">const handlersMapSymbol = Symbol.for('@next/cache-handlers-map')</span><span class="s3">\n</span><span class="s1">const handlersSetSymbol = Symbol.for('@next/cache-handlers-set')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The reference to the cache handlers. We store the cache handlers on the</span><span class="s3">\n </span><span class="s1">* global object so that we can access the same instance across different</span><span class="s3">\n </span><span class="s1">* boundaries (such as different copies of the same module).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const reference: typeof globalThis &amp; {</span><span class="s3">\n  </span><span class="s1">[handlersSymbol]?: {</span><span class="s3">\n    </span><span class="s1">RemoteCache?: CacheHandlerCompat</span><span class="s3">\n    </span><span class="s1">DefaultCache?: CacheHandlerCompat</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[handlersMapSymbol]?: Map&lt;string, CacheHandlerCompat&gt;</span><span class="s3">\n  </span><span class="s1">[handlersSetSymbol]?: Set&lt;CacheHandlerCompat&gt;</span><span class="s3">\n</span><span class="s1">} = globalThis</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Initialize the cache handlers.</span><span class="s3">\n </span><span class="s1">* @returns `true` if the cache handlers were initialized, `false` if they were already initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function initializeCacheHandlers(): boolean {</span><span class="s3">\n  </span><span class="s1">// If the cache handlers have already been initialized, don't do it again.</span><span class="s3">\n  </span><span class="s1">if (reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">debug?.('cache handlers already initialized')</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">debug?.('initializing cache handlers')</span><span class="s3">\n  </span><span class="s1">reference[handlersMapSymbol] = new Map&lt;string, CacheHandlerCompat&gt;()</span><span class="s3">\n\n  </span><span class="s1">// Initialize the cache from the symbol contents first.</span><span class="s3">\n  </span><span class="s1">if (reference[handlersSymbol]) {</span><span class="s3">\n    </span><span class="s1">let fallback: CacheHandlerCompat</span><span class="s3">\n    </span><span class="s1">if (reference[handlersSymbol].DefaultCache) {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from symbol')</span><span class="s3">\n      </span><span class="s1">fallback = reference[handlersSymbol].DefaultCache</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n      </span><span class="s1">fallback = DefaultCacheHandler</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">reference[handlersMapSymbol].set('default', fallback)</span><span class="s3">\n\n    </span><span class="s1">if (reference[handlersSymbol].RemoteCache) {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from symbol')</span><span class="s3">\n      </span><span class="s1">reference[handlersMapSymbol].set(</span><span class="s3">\n        </span><span class="s1">'remote',</span><span class="s3">\n        </span><span class="s1">reference[handlersSymbol].RemoteCache</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n      </span><span class="s1">reference[handlersMapSymbol].set('remote', fallback)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n    </span><span class="s1">reference[handlersMapSymbol].set('default', DefaultCacheHandler)</span><span class="s3">\n    </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n    </span><span class="s1">reference[handlersMapSymbol].set('remote', DefaultCacheHandler)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Create a set of the cache handlers.</span><span class="s3">\n  </span><span class="s1">reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a cache handler by kind.</span><span class="s3">\n </span><span class="s1">* @param kind - The kind of cache handler to get.</span><span class="s3">\n </span><span class="s1">* @returns The cache handler, or `undefined` if it does not exist.</span><span class="s3">\n </span><span class="s1">* @throws If the cache handlers are not initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandler(kind: string): CacheHandlerCompat | undefined {</span><span class="s3">\n  </span><span class="s1">// This should never be called before initializeCacheHandlers.</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Cache handlers not initialized')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersMapSymbol].get(kind)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a set iterator over the cache handlers.</span><span class="s3">\n </span><span class="s1">* @returns An iterator over the cache handlers, or `undefined` if they are not</span><span class="s3">\n </span><span class="s1">* initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandlers():</span><span class="s3">\n  </span><span class="s1">| SetIterator&lt;CacheHandlerCompat&gt;</span><span class="s3">\n  </span><span class="s1">| undefined {</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersSetSymbol]) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersSetSymbol].values()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a map iterator over the cache handlers (keyed by kind).</span><span class="s3">\n </span><span class="s1">* @returns An iterator over the cache handler entries, or `undefined` if they</span><span class="s3">\n </span><span class="s1">* are not initialized.</span><span class="s3">\n </span><span class="s1">* @throws If the cache handlers are not initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandlerEntries():</span><span class="s3">\n  </span><span class="s1">| MapIterator&lt;[string, CacheHandlerCompat]&gt;</span><span class="s3">\n  </span><span class="s1">| undefined {</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersMapSymbol].entries()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set a cache handler by kind.</span><span class="s3">\n </span><span class="s1">* @param kind - The kind of cache handler to set.</span><span class="s3">\n </span><span class="s1">* @param cacheHandler - The cache handler to set.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setCacheHandler(</span><span class="s3">\n  </span><span class="s1">kind: string,</span><span class="s3">\n  </span><span class="s1">cacheHandler: CacheHandlerCompat</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// This should never be called before initializeCacheHandlers.</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Cache handlers not initialized')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">debug?.('setting cache handler for </span><span class="s3">\&quot;</span><span class="s1">%s</span><span class="s3">\&quot;</span><span class="s1">', kind)</span><span class="s3">\n  </span><span class="s1">reference[handlersMapSymbol].set(kind, cacheHandler)</span><span class="s3">\n  </span><span class="s1">reference[handlersSetSymbol].add(cacheHandler)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RequestData, FetchEventResult } from './types'</span><span class="s3">\n</span><span class="s1">import type { RequestInit } from './spec-extension/request'</span><span class="s3">\n</span><span class="s1">import { PageSignatureError } from './error'</span><span class="s3">\n</span><span class="s1">import { fromNodeOutgoingHttpHeaders, normalizeNextQueryParam } from './utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NextFetchEvent,</span><span class="s3">\n  </span><span class="s1">getWaitUntilPromiseFromEvent,</span><span class="s3">\n</span><span class="s1">} from './spec-extension/fetch-event'</span><span class="s3">\n</span><span class="s1">import { NextRequest } from './spec-extension/request'</span><span class="s3">\n</span><span class="s1">import { NextResponse } from './spec-extension/response'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">parseRelativeURL,</span><span class="s3">\n  </span><span class="s1">getRelativeURL,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/router/utils/relativize-url'</span><span class="s3">\n</span><span class="s1">import { NextURL } from './next-url'</span><span class="s3">\n</span><span class="s1">import { stripInternalSearchParams } from '../internal-utils'</span><span class="s3">\n</span><span class="s1">import { normalizeRscURL } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">FLIGHT_HEADERS,</span><span class="s3">\n  </span><span class="s1">NEXT_REWRITTEN_PATH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_REWRITTEN_QUERY_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_RSC_UNION_QUERY,</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { ensureInstrumentationRegistered } from './globals'</span><span class="s3">\n</span><span class="s1">import { createRequestStoreForAPI } from '../async-storage/request-store'</span><span class="s3">\n</span><span class="s1">import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { createWorkStore } from '../async-storage/work-store'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { NEXT_ROUTER_PREFETCH_HEADER } from '../../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import type { TextMapGetter } from 'next/dist/compiled/@opentelemetry/api'</span><span class="s3">\n</span><span class="s1">import { MiddlewareSpan } from '../lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { CloseController } from './web-on-close'</span><span class="s3">\n</span><span class="s1">import { getEdgePreviewProps } from './get-edge-preview-props'</span><span class="s3">\n</span><span class="s1">import { getBuiltinRequestContext } from '../after/builtin-request-context'</span><span class="s3">\n</span><span class="s1">import { getImplicitTags } from '../lib/implicit-tags'</span><span class="s3">\n\n</span><span class="s1">export class NextRequestHint extends NextRequest {</span><span class="s3">\n  </span><span class="s1">sourcePage: string</span><span class="s3">\n  </span><span class="s1">fetchMetrics: FetchEventResult['fetchMetrics'] | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(params: {</span><span class="s3">\n    </span><span class="s1">init: RequestInit</span><span class="s3">\n    </span><span class="s1">input: Request | string</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">super(params.input, params.init)</span><span class="s3">\n    </span><span class="s1">this.sourcePage = params.page</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get request() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({ page: this.sourcePage })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">respondWith() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({ page: this.sourcePage })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">waitUntil() {</span><span class="s3">\n    </span><span class="s1">throw new PageSignatureError({ page: this.sourcePage })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const headersGetter: TextMapGetter&lt;Headers&gt; = {</span><span class="s3">\n  </span><span class="s1">keys: (headers) =&gt; Array.from(headers.keys()),</span><span class="s3">\n  </span><span class="s1">get: (headers, key) =&gt; headers.get(key) ?? undefined,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AdapterOptions = {</span><span class="s3">\n  </span><span class="s1">handler: (req: NextRequestHint, event: NextFetchEvent) =&gt; Promise&lt;Response&gt;</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">request: RequestData</span><span class="s3">\n  </span><span class="s1">IncrementalCache?: typeof import('../lib/incremental-cache').IncrementalCache</span><span class="s3">\n  </span><span class="s1">incrementalCacheHandler?: typeof import('../lib/incremental-cache').CacheHandler</span><span class="s3">\n  </span><span class="s1">bypassNextUrl?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let propagator: &lt;T&gt;(request: NextRequestHint, fn: () =&gt; T) =&gt; T = (</span><span class="s3">\n  </span><span class="s1">request,</span><span class="s3">\n  </span><span class="s1">fn</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">const tracer = getTracer()</span><span class="s3">\n  </span><span class="s1">return tracer.withPropagatedContext(request.headers, fn, headersGetter)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let testApisIntercepted = false</span><span class="s3">\n\n</span><span class="s1">function ensureTestApisIntercepted() {</span><span class="s3">\n  </span><span class="s1">if (!testApisIntercepted) {</span><span class="s3">\n    </span><span class="s1">testApisIntercepted = true</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_PRIVATE_TEST_PROXY === 'true') {</span><span class="s3">\n      </span><span class="s1">const { interceptTestApis, wrapRequestHandler } =</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @next/internal/typechecked-require -- experimental/testmode is not built ins next/dist/esm</span><span class="s3">\n        </span><span class="s1">require('next/dist/experimental/testmode/server-edge') as typeof import('../../experimental/testmode/server-edge')</span><span class="s3">\n      </span><span class="s1">interceptTestApis()</span><span class="s3">\n      </span><span class="s1">propagator = wrapRequestHandler(propagator)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function adapter(</span><span class="s3">\n  </span><span class="s1">params: AdapterOptions</span><span class="s3">\n</span><span class="s1">): Promise&lt;FetchEventResult&gt; {</span><span class="s3">\n  </span><span class="s1">ensureTestApisIntercepted()</span><span class="s3">\n  </span><span class="s1">await ensureInstrumentationRegistered()</span><span class="s3">\n\n  </span><span class="s1">// TODO-APP: use explicit marker for this</span><span class="s3">\n  </span><span class="s1">const isEdgeRendering =</span><span class="s3">\n    </span><span class="s1">typeof (globalThis as any).__BUILD_MANIFEST !== 'undefined'</span><span class="s3">\n\n  </span><span class="s1">params.request.url = normalizeRscURL(params.request.url)</span><span class="s3">\n\n  </span><span class="s1">const requestURL = params.bypassNextUrl</span><span class="s3">\n    </span><span class="s1">? new URL(params.request.url)</span><span class="s3">\n    </span><span class="s1">: new NextURL(params.request.url, {</span><span class="s3">\n        </span><span class="s1">headers: params.request.headers,</span><span class="s3">\n        </span><span class="s1">nextConfig: params.request.nextConfig,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Iterator uses an index to keep track of the current iteration. Because of deleting and appending below we can't just use the iterator.</span><span class="s3">\n  </span><span class="s1">// Instead we use the keys before iteration.</span><span class="s3">\n  </span><span class="s1">const keys = [...requestURL.searchParams.keys()]</span><span class="s3">\n  </span><span class="s1">for (const key of keys) {</span><span class="s3">\n    </span><span class="s1">const value = requestURL.searchParams.getAll(key)</span><span class="s3">\n\n    </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n    </span><span class="s1">if (normalizedKey) {</span><span class="s3">\n      </span><span class="s1">requestURL.searchParams.delete(normalizedKey)</span><span class="s3">\n      </span><span class="s1">for (const val of value) {</span><span class="s3">\n        </span><span class="s1">requestURL.searchParams.append(normalizedKey, val)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">requestURL.searchParams.delete(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Ensure users only see page requests, never data requests.</span><span class="s3">\n  </span><span class="s1">let buildId = process.env.__NEXT_BUILD_ID || ''</span><span class="s3">\n  </span><span class="s1">if ('buildId' in requestURL) {</span><span class="s3">\n    </span><span class="s1">buildId = (requestURL as NextURL).buildId || ''</span><span class="s3">\n    </span><span class="s1">requestURL.buildId = ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const requestHeaders = fromNodeOutgoingHttpHeaders(params.request.headers)</span><span class="s3">\n  </span><span class="s1">const isNextDataRequest = requestHeaders.has('x-nextjs-data')</span><span class="s3">\n  </span><span class="s1">const isRSCRequest = requestHeaders.get(RSC_HEADER) === '1'</span><span class="s3">\n\n  </span><span class="s1">if (isNextDataRequest &amp;&amp; requestURL.pathname === '/index') {</span><span class="s3">\n    </span><span class="s1">requestURL.pathname = '/'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const flightHeaders = new Map()</span><span class="s3">\n\n  </span><span class="s1">// Headers should only be stripped for middleware</span><span class="s3">\n  </span><span class="s1">if (!isEdgeRendering) {</span><span class="s3">\n    </span><span class="s1">for (const header of FLIGHT_HEADERS) {</span><span class="s3">\n      </span><span class="s1">const value = requestHeaders.get(header)</span><span class="s3">\n      </span><span class="s1">if (value !== null) {</span><span class="s3">\n        </span><span class="s1">flightHeaders.set(header, value)</span><span class="s3">\n        </span><span class="s1">requestHeaders.delete(header)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const normalizeURL = process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE</span><span class="s3">\n    </span><span class="s1">? new URL(params.request.url)</span><span class="s3">\n    </span><span class="s1">: requestURL</span><span class="s3">\n\n  </span><span class="s1">const rscHash = normalizeURL.searchParams.get(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n\n  </span><span class="s1">const request = new NextRequestHint({</span><span class="s3">\n    </span><span class="s1">page: params.page,</span><span class="s3">\n    </span><span class="s1">// Strip internal query parameters off the request.</span><span class="s3">\n    </span><span class="s1">input: stripInternalSearchParams(normalizeURL).toString(),</span><span class="s3">\n    </span><span class="s1">init: {</span><span class="s3">\n      </span><span class="s1">body: params.request.body,</span><span class="s3">\n      </span><span class="s1">headers: requestHeaders,</span><span class="s3">\n      </span><span class="s1">method: params.request.method,</span><span class="s3">\n      </span><span class="s1">nextConfig: params.request.nextConfig,</span><span class="s3">\n      </span><span class="s1">signal: params.request.signal,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This allows to identify the request as a data request. The user doesn't</span><span class="s3">\n   </span><span class="s1">* need to know about this property neither use it. We add it for testing</span><span class="s3">\n   </span><span class="s1">* purposes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">if (isNextDataRequest) {</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(request, '__isData', {</span><span class="s3">\n      </span><span class="s1">enumerable: false,</span><span class="s3">\n      </span><span class="s1">value: true,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// If we are inside of the next start sandbox</span><span class="s3">\n    </span><span class="s1">// leverage the shared instance if not we need</span><span class="s3">\n    </span><span class="s1">// to create a fresh cache instance each time</span><span class="s3">\n    </span><span class="s1">!(globalThis as any).__incrementalCacheShared &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(params as any).IncrementalCache</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">;(globalThis as any).__incrementalCache = new (</span><span class="s3">\n      </span><span class="s1">params as {</span><span class="s3">\n        </span><span class="s1">IncrementalCache: typeof import('../lib/incremental-cache').IncrementalCache</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">).IncrementalCache({</span><span class="s3">\n      </span><span class="s1">CurCacheHandler: params.incrementalCacheHandler,</span><span class="s3">\n      </span><span class="s1">minimalMode: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">fetchCacheKeyPrefix: process.env.__NEXT_FETCH_CACHE_KEY_PREFIX,</span><span class="s3">\n      </span><span class="s1">dev: process.env.NODE_ENV === 'development',</span><span class="s3">\n      </span><span class="s1">requestHeaders: params.request.headers as any,</span><span class="s3">\n\n      </span><span class="s1">getPrerenderManifest: () =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">version: -1 as any, // letting us know this doesn't conform to spec</span><span class="s3">\n          </span><span class="s1">routes: {},</span><span class="s3">\n          </span><span class="s1">dynamicRoutes: {},</span><span class="s3">\n          </span><span class="s1">notFoundRoutes: [],</span><span class="s3">\n          </span><span class="s1">preview: getEdgePreviewProps(),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if we're in an edge runtime sandbox, we should use the waitUntil</span><span class="s3">\n  </span><span class="s1">// that we receive from the enclosing NextServer</span><span class="s3">\n  </span><span class="s1">const outerWaitUntil =</span><span class="s3">\n    </span><span class="s1">params.request.waitUntil ?? getBuiltinRequestContext()?.waitUntil</span><span class="s3">\n\n  </span><span class="s1">const event = new NextFetchEvent({</span><span class="s3">\n    </span><span class="s1">request,</span><span class="s3">\n    </span><span class="s1">page: params.page,</span><span class="s3">\n    </span><span class="s1">context: outerWaitUntil ? { waitUntil: outerWaitUntil } : undefined,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">let response</span><span class="s3">\n  </span><span class="s1">let cookiesFromResponse</span><span class="s3">\n\n  </span><span class="s1">response = await propagator(request, () =&gt; {</span><span class="s3">\n    </span><span class="s1">// we only care to make async storage available for middleware</span><span class="s3">\n    </span><span class="s1">const isMiddleware =</span><span class="s3">\n      </span><span class="s1">params.page === '/middleware' || params.page === '/src/middleware'</span><span class="s3">\n\n    </span><span class="s1">if (isMiddleware) {</span><span class="s3">\n      </span><span class="s1">// if we're in an edge function, we only get a subset of `nextConfig` (no `experimental`),</span><span class="s3">\n      </span><span class="s1">// so we have to inject it via DefinePlugin.</span><span class="s3">\n      </span><span class="s1">// in `next start` this will be passed normally (see `NextNodeServer.runMiddleware`).</span><span class="s3">\n\n      </span><span class="s1">const waitUntil = event.waitUntil.bind(event)</span><span class="s3">\n      </span><span class="s1">const closeController = new CloseController()</span><span class="s3">\n\n      </span><span class="s1">return getTracer().trace(</span><span class="s3">\n        </span><span class="s1">MiddlewareSpan.execute,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">spanName: `middleware ${request.method} ${request.nextUrl.pathname}`,</span><span class="s3">\n          </span><span class="s1">attributes: {</span><span class="s3">\n            </span><span class="s1">'http.target': request.nextUrl.pathname,</span><span class="s3">\n            </span><span class="s1">'http.method': request.method,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">async () =&gt; {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const onUpdateCookies = (cookies: Array&lt;string&gt;) =&gt; {</span><span class="s3">\n              </span><span class="s1">cookiesFromResponse = cookies</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const previewProps = getEdgePreviewProps()</span><span class="s3">\n            </span><span class="s1">const page = '/' // Fake Work</span><span class="s3">\n            </span><span class="s1">const fallbackRouteParams = null</span><span class="s3">\n\n            </span><span class="s1">const implicitTags = await getImplicitTags(</span><span class="s3">\n              </span><span class="s1">page,</span><span class="s3">\n              </span><span class="s1">request.nextUrl,</span><span class="s3">\n              </span><span class="s1">fallbackRouteParams</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">const requestStore = createRequestStoreForAPI(</span><span class="s3">\n              </span><span class="s1">request,</span><span class="s3">\n              </span><span class="s1">request.nextUrl,</span><span class="s3">\n              </span><span class="s1">implicitTags,</span><span class="s3">\n              </span><span class="s1">onUpdateCookies,</span><span class="s3">\n              </span><span class="s1">previewProps</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">const workStore = createWorkStore({</span><span class="s3">\n              </span><span class="s1">page,</span><span class="s3">\n              </span><span class="s1">renderOpts: {</span><span class="s3">\n                </span><span class="s1">cacheLifeProfiles:</span><span class="s3">\n                  </span><span class="s1">params.request.nextConfig?.experimental?.cacheLife,</span><span class="s3">\n                </span><span class="s1">experimental: {</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled: false,</span><span class="s3">\n                  </span><span class="s1">cacheComponents: false,</span><span class="s3">\n                  </span><span class="s1">authInterrupts:</span><span class="s3">\n                    </span><span class="s1">!!params.request.nextConfig?.experimental?.authInterrupts,</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">supportsDynamicResponse: true,</span><span class="s3">\n                </span><span class="s1">waitUntil,</span><span class="s3">\n                </span><span class="s1">onClose: closeController.onClose.bind(closeController),</span><span class="s3">\n                </span><span class="s1">onAfterTaskError: undefined,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">isPrefetchRequest:</span><span class="s3">\n                </span><span class="s1">request.headers.get(NEXT_ROUTER_PREFETCH_HEADER) === '1',</span><span class="s3">\n              </span><span class="s1">buildId: buildId ?? '',</span><span class="s3">\n              </span><span class="s1">previouslyRevalidatedTags: [],</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">return await workAsyncStorage.run(workStore, () =&gt;</span><span class="s3">\n              </span><span class="s1">workUnitAsyncStorage.run(</span><span class="s3">\n                </span><span class="s1">requestStore,</span><span class="s3">\n                </span><span class="s1">params.handler,</span><span class="s3">\n                </span><span class="s1">request,</span><span class="s3">\n                </span><span class="s1">event</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">// middleware cannot stream, so we can consider the response closed</span><span class="s3">\n            </span><span class="s1">// as soon as the handler returns.</span><span class="s3">\n            </span><span class="s1">// we can delay running it until a bit later --</span><span class="s3">\n            </span><span class="s1">// if it's needed, we'll have a `waitUntil` lock anyway.</span><span class="s3">\n            </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n              </span><span class="s1">closeController.dispatchClose()</span><span class="s3">\n            </span><span class="s1">}, 0)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return params.handler(request, event)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// check if response is a Response object</span><span class="s3">\n  </span><span class="s1">if (response &amp;&amp; !(response instanceof Response)) {</span><span class="s3">\n    </span><span class="s1">throw new TypeError('Expected an instance of Response to be returned')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (response &amp;&amp; cookiesFromResponse) {</span><span class="s3">\n    </span><span class="s1">response.headers.set('set-cookie', cookiesFromResponse)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* For rewrites we must always include the locale in the final pathname</span><span class="s3">\n   </span><span class="s1">* so we re-create the NextURL forcing it to include it when the it is</span><span class="s3">\n   </span><span class="s1">* an internal rewrite. Also we make sure the outgoing rewrite URL is</span><span class="s3">\n   </span><span class="s1">* a data URL if the request was a data request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const rewrite = response?.headers.get('x-middleware-rewrite')</span><span class="s3">\n  </span><span class="s1">if (response &amp;&amp; rewrite &amp;&amp; (isRSCRequest || !isEdgeRendering)) {</span><span class="s3">\n    </span><span class="s1">const destination = new NextURL(rewrite, {</span><span class="s3">\n      </span><span class="s1">forceLocale: true,</span><span class="s3">\n      </span><span class="s1">headers: params.request.headers,</span><span class="s3">\n      </span><span class="s1">nextConfig: params.request.nextConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (!process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE &amp;&amp; !isEdgeRendering) {</span><span class="s3">\n      </span><span class="s1">if (destination.host === request.nextUrl.host) {</span><span class="s3">\n        </span><span class="s1">destination.buildId = buildId || destination.buildId</span><span class="s3">\n        </span><span class="s1">response.headers.set('x-middleware-rewrite', String(destination))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When the request is a data request we must show if there was a rewrite</span><span class="s3">\n     </span><span class="s1">* with an internal header so the client knows which component to load</span><span class="s3">\n     </span><span class="s1">* from the data request.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const { url: relativeDestination, isRelative } = parseRelativeURL(</span><span class="s3">\n      </span><span class="s1">destination.toString(),</span><span class="s3">\n      </span><span class="s1">requestURL.toString()</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!isEdgeRendering &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isNextDataRequest &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// if the rewrite is external and external rewrite</span><span class="s3">\n      </span><span class="s1">// resolving config is enabled don't add this header</span><span class="s3">\n      </span><span class="s1">// so the upstream app can set it instead</span><span class="s3">\n      </span><span class="s1">!(</span><span class="s3">\n        </span><span class="s1">process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE &amp;&amp;</span><span class="s3">\n        </span><span class="s1">relativeDestination.match(/http(s)?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">response.headers.set('x-nextjs-rewrite', relativeDestination)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If this is an RSC request, and the pathname or search has changed, and</span><span class="s3">\n    </span><span class="s1">// this isn't an external rewrite, we need to set the rewritten pathname and</span><span class="s3">\n    </span><span class="s1">// query headers.</span><span class="s3">\n    </span><span class="s1">if (isRSCRequest &amp;&amp; isRelative) {</span><span class="s3">\n      </span><span class="s1">if (requestURL.pathname !== destination.pathname) {</span><span class="s3">\n        </span><span class="s1">response.headers.set(NEXT_REWRITTEN_PATH_HEADER, destination.pathname)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (requestURL.search !== destination.search) {</span><span class="s3">\n        </span><span class="s1">response.headers.set(</span><span class="s3">\n          </span><span class="s1">NEXT_REWRITTEN_QUERY_HEADER,</span><span class="s3">\n          </span><span class="s1">// remove the leading ? from the search string</span><span class="s3">\n          </span><span class="s1">destination.search.slice(1)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Always forward the `_rsc` search parameter to the rewritten URL for RSC requests,</span><span class="s3">\n   </span><span class="s1">* unless it's already present. This is necessary to ensure that RSC hash validation</span><span class="s3">\n   </span><span class="s1">* works correctly after a rewrite. For internal rewrites, the server can validate the</span><span class="s3">\n   </span><span class="s1">* RSC hash using the original URL, so forwarding the `_rsc` parameter is less critical.</span><span class="s3">\n   </span><span class="s1">* However, for external rewrites (where the request is proxied to another Next.js server),</span><span class="s3">\n   </span><span class="s1">* the external server does not have access to the original URL or its search parameters.</span><span class="s3">\n   </span><span class="s1">* In these cases, forwarding the `_rsc` parameter is essential so that the external server</span><span class="s3">\n   </span><span class="s1">* can perform the correct RSC hash validation.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">if (response &amp;&amp; rewrite &amp;&amp; isRSCRequest &amp;&amp; rscHash) {</span><span class="s3">\n    </span><span class="s1">const rewriteURL = new URL(rewrite)</span><span class="s3">\n    </span><span class="s1">if (!rewriteURL.searchParams.has(NEXT_RSC_UNION_QUERY)) {</span><span class="s3">\n      </span><span class="s1">rewriteURL.searchParams.set(NEXT_RSC_UNION_QUERY, rscHash)</span><span class="s3">\n      </span><span class="s1">response.headers.set('x-middleware-rewrite', rewriteURL.toString())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* For redirects we will not include the locale in case when it is the</span><span class="s3">\n   </span><span class="s1">* default and we must also make sure the outgoing URL is a data one if</span><span class="s3">\n   </span><span class="s1">* the incoming request was a data request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const redirect = response?.headers.get('Location')</span><span class="s3">\n  </span><span class="s1">if (response &amp;&amp; redirect &amp;&amp; !isEdgeRendering) {</span><span class="s3">\n    </span><span class="s1">const redirectURL = new NextURL(redirect, {</span><span class="s3">\n      </span><span class="s1">forceLocale: false,</span><span class="s3">\n      </span><span class="s1">headers: params.request.headers,</span><span class="s3">\n      </span><span class="s1">nextConfig: params.request.nextConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Responses created from redirects have immutable headers so we have</span><span class="s3">\n     </span><span class="s1">* to clone the response to be able to modify it.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">response = new Response(response.body, response)</span><span class="s3">\n\n    </span><span class="s1">if (!process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE) {</span><span class="s3">\n      </span><span class="s1">if (redirectURL.host === requestURL.host) {</span><span class="s3">\n        </span><span class="s1">redirectURL.buildId = buildId || redirectURL.buildId</span><span class="s3">\n        </span><span class="s1">response.headers.set('Location', redirectURL.toString())</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When the request is a data request we can't use the location header as</span><span class="s3">\n     </span><span class="s1">* it may end up with CORS error. Instead we map to an internal header so</span><span class="s3">\n     </span><span class="s1">* the client knows the destination.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (isNextDataRequest) {</span><span class="s3">\n      </span><span class="s1">response.headers.delete('Location')</span><span class="s3">\n      </span><span class="s1">response.headers.set(</span><span class="s3">\n        </span><span class="s1">'x-nextjs-redirect',</span><span class="s3">\n        </span><span class="s1">getRelativeURL(redirectURL.toString(), requestURL.toString())</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const finalResponse = response ? response : NextResponse.next()</span><span class="s3">\n\n  </span><span class="s1">// Flight headers are not overridable / removable so they are applied at the end.</span><span class="s3">\n  </span><span class="s1">const middlewareOverrideHeaders = finalResponse.headers.get(</span><span class="s3">\n    </span><span class="s1">'x-middleware-override-headers'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const overwrittenHeaders: string[] = []</span><span class="s3">\n  </span><span class="s1">if (middlewareOverrideHeaders) {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of flightHeaders) {</span><span class="s3">\n      </span><span class="s1">finalResponse.headers.set(`x-middleware-request-${key}`, value)</span><span class="s3">\n      </span><span class="s1">overwrittenHeaders.push(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (overwrittenHeaders.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">finalResponse.headers.set(</span><span class="s3">\n        </span><span class="s1">'x-middleware-override-headers',</span><span class="s3">\n        </span><span class="s1">middlewareOverrideHeaders + ',' + overwrittenHeaders.join(',')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">response: finalResponse,</span><span class="s3">\n    </span><span class="s1">waitUntil: getWaitUntilPromiseFromEvent(event) ?? Promise.resolve(),</span><span class="s3">\n    </span><span class="s1">fetchMetrics: request.fetchMetrics,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PathnameNormalizer } from './pathname-normalizer'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENT_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">const PATTERN = new RegExp(</span><span class="s3">\n  </span><span class="s1">`^(/.*)${RSC_SEGMENTS_DIR_SUFFIX}(/.*)${RSC_SEGMENT_SUFFIX}$`</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export class SegmentPrefixRSCPathnameNormalizer implements PathnameNormalizer {</span><span class="s3">\n  </span><span class="s1">public match(pathname: string): boolean {</span><span class="s3">\n    </span><span class="s1">return PATTERN.test(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public extract(pathname: string) {</span><span class="s3">\n    </span><span class="s1">const match = pathname.match(PATTERN)</span><span class="s3">\n    </span><span class="s1">if (!match) return null</span><span class="s3">\n\n    </span><span class="s1">return { originalPathname: match[1], segmentPath: match[2] }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public normalize(pathname: string): string {</span><span class="s3">\n    </span><span class="s1">const match = this.extract(pathname)</span><span class="s3">\n    </span><span class="s1">if (!match) return pathname</span><span class="s3">\n\n    </span><span class="s1">return match.originalPathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { __ApiPreviewProps } from './api-utils'</span><span class="s3">\n</span><span class="s1">import type { LoadComponentsReturnType } from './load-components'</span><span class="s3">\n</span><span class="s1">import type { MiddlewareRouteMatch } from '../shared/lib/router/utils/middleware-route-matcher'</span><span class="s3">\n</span><span class="s1">import type { Params } from './request/params'</span><span class="s3">\n</span><span class="s1">import type { NextConfig, NextConfigComplete } from './config-shared'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">NextParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">NextUrlWithParsedQuery,</span><span class="s3">\n  </span><span class="s1">RequestMeta,</span><span class="s3">\n</span><span class="s1">} from './request-meta'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { RenderOptsPartial as PagesRenderOptsPartial } from './render'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">RenderOptsPartial as AppRenderOptsPartial,</span><span class="s3">\n  </span><span class="s1">ServerOnInstrumentationRequestError,</span><span class="s3">\n</span><span class="s1">} from './app-render/types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ServerComponentsHmrCache,</span><span class="s3">\n  </span><span class="s1">ResponseCacheBase,</span><span class="s3">\n</span><span class="s1">} from './response-cache'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NormalizeError,</span><span class="s3">\n  </span><span class="s1">DecodeError,</span><span class="s3">\n  </span><span class="s1">normalizeRepeatedSlashes,</span><span class="s3">\n  </span><span class="s1">MissingStaticPage,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest, BaseNextResponse } from './base-http'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ManifestRewriteRoute,</span><span class="s3">\n  </span><span class="s1">ManifestRoute,</span><span class="s3">\n  </span><span class="s1">PrerenderManifest,</span><span class="s3">\n</span><span class="s1">} from '../build'</span><span class="s3">\n</span><span class="s1">import type { ClientReferenceManifest } from '../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Server as HTTPServer,</span><span class="s3">\n  </span><span class="s1">IncomingMessage,</span><span class="s3">\n  </span><span class="s1">ServerResponse as HTTPServerResponse,</span><span class="s3">\n</span><span class="s1">} from 'http'</span><span class="s3">\n</span><span class="s1">import type { MiddlewareMatcher } from '../build/analysis/get-page-static-info'</span><span class="s3">\n</span><span class="s1">import type { TLSSocket } from 'tls'</span><span class="s3">\n</span><span class="s1">import type { PathnameNormalizer } from './normalizers/request/pathname-normalizer'</span><span class="s3">\n</span><span class="s1">import type { InstrumentationModule } from './instrumentation/types'</span><span class="s3">\n\n</span><span class="s1">import { format as formatUrl, parse as parseUrl } from 'url'</span><span class="s3">\n</span><span class="s1">import { formatHostname } from './lib/format-hostname'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">APP_PATHS_MANIFEST,</span><span class="s3">\n  </span><span class="s1">NEXT_BUILTIN_DOCUMENT,</span><span class="s3">\n  </span><span class="s1">PAGES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">STATIC_STATUS_PAGES,</span><span class="s3">\n  </span><span class="s1">UNDERSCORE_NOT_FOUND_ROUTE,</span><span class="s3">\n  </span><span class="s1">UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import { setConfig } from '../shared/lib/runtime-config.external'</span><span class="s3">\n</span><span class="s1">import { execOnce } from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { isBlockedPage } from './utils'</span><span class="s3">\n</span><span class="s1">import { getBotType, isBot } from '../shared/lib/router/utils/is-bot'</span><span class="s3">\n</span><span class="s1">import RenderResult from './render-result'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'</span><span class="s3">\n</span><span class="s1">import * as Log from '../build/output/log'</span><span class="s3">\n</span><span class="s1">import { getPreviouslyRevalidatedTags, getServerUtils } from './server-utils'</span><span class="s3">\n</span><span class="s1">import isError, { getProperError } from '../lib/is-error'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">addRequestMeta,</span><span class="s3">\n  </span><span class="s1">getRequestMeta,</span><span class="s3">\n  </span><span class="s1">removeRequestMeta,</span><span class="s3">\n  </span><span class="s1">setRequestMeta,</span><span class="s3">\n</span><span class="s1">} from './request-meta'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from '../shared/lib/router/utils/remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import { parseUrl as parseUrlUtil } from '../shared/lib/router/utils/parse-url'</span><span class="s3">\n</span><span class="s1">import { getNextPathnameInfo } from '../shared/lib/router/utils/get-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_RSC_UNION_QUERY,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_URL,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">MatchOptions,</span><span class="s3">\n  </span><span class="s1">RouteMatcherManager,</span><span class="s3">\n</span><span class="s1">} from './route-matcher-managers/route-matcher-manager'</span><span class="s3">\n</span><span class="s1">import { LocaleRouteNormalizer } from './normalizers/locale-route-normalizer'</span><span class="s3">\n</span><span class="s1">import { DefaultRouteMatcherManager } from './route-matcher-managers/default-route-matcher-manager'</span><span class="s3">\n</span><span class="s1">import { AppPageRouteMatcherProvider } from './route-matcher-providers/app-page-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import { AppRouteRouteMatcherProvider } from './route-matcher-providers/app-route-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import { PagesAPIRouteMatcherProvider } from './route-matcher-providers/pages-api-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import { PagesRouteMatcherProvider } from './route-matcher-providers/pages-route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import { ServerManifestLoader } from './route-matcher-providers/helpers/manifest-loaders/server-manifest-loader'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getTracer,</span><span class="s3">\n  </span><span class="s1">isBubbledError,</span><span class="s3">\n  </span><span class="s1">SpanKind,</span><span class="s3">\n  </span><span class="s1">SpanStatusCode,</span><span class="s3">\n</span><span class="s1">} from './lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { BaseServerSpan } from './lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { I18NProvider } from './lib/i18n-provider'</span><span class="s3">\n</span><span class="s1">import { sendResponse } from './send-response'</span><span class="s3">\n</span><span class="s1">import { normalizeNextQueryParam } from './web/utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">MATCHED_PATH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_RESUME_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { matchNextDataPathname } from './lib/match-next-data-pathname'</span><span class="s3">\n</span><span class="s1">import getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'</span><span class="s3">\n</span><span class="s1">import { RSCPathnameNormalizer } from './normalizers/request/rsc'</span><span class="s3">\n</span><span class="s1">import { stripFlightHeaders } from './app-render/strip-flight-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isAppPageRouteModule,</span><span class="s3">\n  </span><span class="s1">isAppRouteRouteModule,</span><span class="s3">\n</span><span class="s1">} from './route-modules/checks'</span><span class="s3">\n</span><span class="s1">import { PrefetchRSCPathnameNormalizer } from './normalizers/request/prefetch-rsc'</span><span class="s3">\n</span><span class="s1">import { NextDataPathnameNormalizer } from './normalizers/request/next-data'</span><span class="s3">\n</span><span class="s1">import { getIsPossibleServerAction } from './lib/server-action-request-meta'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteAppPath } from '../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import { toRoute } from './lib/to-route'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import { isNodeNextRequest, isNodeNextResponse } from './base-http/helpers'</span><span class="s3">\n</span><span class="s1">import { patchSetHeaderWithCookieSupport } from './lib/patch-set-header'</span><span class="s3">\n</span><span class="s1">import { checkIsAppPPREnabled } from './lib/experimental/ppr'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getBuiltinRequestContext,</span><span class="s3">\n  </span><span class="s1">type WaitUntil,</span><span class="s3">\n</span><span class="s1">} from './after/builtin-request-context'</span><span class="s3">\n</span><span class="s1">import { NextRequestHint } from './web/adapter'</span><span class="s3">\n</span><span class="s1">import type { RouteModule } from './route-modules/route-module'</span><span class="s3">\n</span><span class="s1">import { type FallbackMode, parseFallbackField } from '../lib/fallback'</span><span class="s3">\n</span><span class="s1">import { SegmentPrefixRSCPathnameNormalizer } from './normalizers/request/segment-prefix-rsc'</span><span class="s3">\n</span><span class="s1">import { shouldServeStreamingMetadata } from './lib/streaming-metadata'</span><span class="s3">\n</span><span class="s1">import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'</span><span class="s3">\n</span><span class="s1">import { NoFallbackError } from '../shared/lib/no-fallback-error.external'</span><span class="s3">\n</span><span class="s1">import { getCacheHandlers } from './use-cache/handlers'</span><span class="s3">\n</span><span class="s1">import { fixMojibake } from './lib/fix-mojibake'</span><span class="s3">\n</span><span class="s1">import { computeCacheBustingSearchParam } from '../shared/lib/router/utils/cache-busting-search-param'</span><span class="s3">\n</span><span class="s1">import { setCacheBustingSearchParamWithHash } from '../client/components/router-reducer/set-cache-busting-search-param'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { PrerenderedRoute } from '../build/static-paths/types'</span><span class="s3">\n\n</span><span class="s1">export type FindComponentsResult = {</span><span class="s3">\n  </span><span class="s1">components: LoadComponentsReturnType</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface MiddlewareRoutingItem {</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">match: MiddlewareRouteMatch</span><span class="s3">\n  </span><span class="s1">matchers?: MiddlewareMatcher[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RouteHandler&lt;</span><span class="s3">\n  </span><span class="s1">ServerRequest extends BaseNextRequest = BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ServerResponse extends BaseNextResponse = BaseNextResponse,</span><span class="s3">\n</span><span class="s1">&gt; = (</span><span class="s3">\n  </span><span class="s1">req: ServerRequest,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">parsedUrl: NextUrlWithParsedQuery</span><span class="s3">\n</span><span class="s1">) =&gt; PromiseLike&lt;boolean&gt; | boolean</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The normalized route manifest is the same as the route manifest, but with</span><span class="s3">\n </span><span class="s1">* the rewrites normalized to the object shape that the router expects.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NormalizedRouteManifest = {</span><span class="s3">\n  </span><span class="s1">readonly dynamicRoutes: ReadonlyArray&lt;ManifestRoute&gt;</span><span class="s3">\n  </span><span class="s1">readonly rewrites: {</span><span class="s3">\n    </span><span class="s1">readonly beforeFiles: ReadonlyArray&lt;ManifestRewriteRoute&gt;</span><span class="s3">\n    </span><span class="s1">readonly afterFiles: ReadonlyArray&lt;ManifestRewriteRoute&gt;</span><span class="s3">\n    </span><span class="s1">readonly fallback: ReadonlyArray&lt;ManifestRewriteRoute&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object containing the configuration next.config.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">conf: NextConfig</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set to false when the server was created by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">customServer?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Tells if Next.js is running in dev mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Enables the experimental testing mode.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">experimentalTestProxy?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether or not the dev server is running in experimental HTTPS mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">experimentalHttpsServer?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Where the Next project is located</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">dir?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Tells if Next.js is at the platform-level</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Hide error messages containing server information</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">quiet?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The hostname the server is running behind</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hostname?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The port the server is running behind</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">port?: number</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The HTTP Server that Next.js is running behind</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">httpServer?: HTTPServer</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderOpts = PagesRenderOptsPartial &amp; AppRenderOptsPartial</span><span class="s3">\n\n</span><span class="s1">export type LoadedRenderOpts = RenderOpts &amp;</span><span class="s3">\n  </span><span class="s1">LoadComponentsReturnType &amp;</span><span class="s3">\n  </span><span class="s1">RequestLifecycleOpts</span><span class="s3">\n\n</span><span class="s1">export type RequestLifecycleOpts = {</span><span class="s3">\n  </span><span class="s1">waitUntil: ((promise: Promise&lt;any&gt;) =&gt; void) | undefined</span><span class="s3">\n  </span><span class="s1">onClose: (callback: () =&gt; void) =&gt; void</span><span class="s3">\n  </span><span class="s1">onAfterTaskError: ((error: unknown) =&gt; void) | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type BaseRenderOpts = RenderOpts &amp; {</span><span class="s3">\n  </span><span class="s1">poweredByHeader: boolean</span><span class="s3">\n  </span><span class="s1">generateEtags: boolean</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The public interface for rendering with the server programmatically. This</span><span class="s3">\n </span><span class="s1">* would typically only allow the base request or response to extend it, but</span><span class="s3">\n </span><span class="s1">* because this can be programmatically accessed, we assume that it could also</span><span class="s3">\n </span><span class="s1">* be the base Node.js request and response types.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface BaseRequestHandler&lt;</span><span class="s3">\n  </span><span class="s1">ServerRequest extends BaseNextRequest | IncomingMessage = BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ServerResponse extends</span><span class="s3">\n    </span><span class="s1">| BaseNextResponse</span><span class="s3">\n    </span><span class="s1">| HTTPServerResponse = BaseNextResponse,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery | undefined</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; | void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RequestContext&lt;</span><span class="s3">\n  </span><span class="s1">ServerRequest extends BaseNextRequest = BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ServerResponse extends BaseNextResponse = BaseNextResponse,</span><span class="s3">\n</span><span class="s1">&gt; = {</span><span class="s3">\n  </span><span class="s1">req: ServerRequest</span><span class="s3">\n  </span><span class="s1">res: ServerResponse</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">renderOpts: RenderOpts</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Internal wrapper around build errors at development</span><span class="s3">\n</span><span class="s1">// time, to prevent us from propagating or logging them</span><span class="s3">\n</span><span class="s1">export class WrappedBuildError extends Error {</span><span class="s3">\n  </span><span class="s1">innerError: Error</span><span class="s3">\n\n  </span><span class="s1">constructor(innerError: Error) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.innerError = innerError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ResponsePayload = {</span><span class="s3">\n  </span><span class="s1">body: RenderResult</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NextEnabledDirectories = {</span><span class="s3">\n  </span><span class="s1">readonly pages: boolean</span><span class="s3">\n  </span><span class="s1">readonly app: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default abstract class Server&lt;</span><span class="s3">\n  </span><span class="s1">ServerOptions extends Options = Options,</span><span class="s3">\n  </span><span class="s1">ServerRequest extends BaseNextRequest = BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ServerResponse extends BaseNextResponse = BaseNextResponse,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">public readonly hostname?: string</span><span class="s3">\n  </span><span class="s1">public readonly fetchHostname?: string</span><span class="s3">\n  </span><span class="s1">public readonly port?: number</span><span class="s3">\n  </span><span class="s1">protected readonly dir: string</span><span class="s3">\n  </span><span class="s1">protected readonly quiet: boolean</span><span class="s3">\n  </span><span class="s1">protected readonly nextConfig: NextConfigComplete</span><span class="s3">\n  </span><span class="s1">protected readonly distDir: string</span><span class="s3">\n  </span><span class="s1">protected readonly publicDir: string</span><span class="s3">\n  </span><span class="s1">protected readonly hasStaticDir: boolean</span><span class="s3">\n  </span><span class="s1">protected readonly pagesManifest?: PagesManifest</span><span class="s3">\n  </span><span class="s1">protected readonly appPathsManifest?: PagesManifest</span><span class="s3">\n  </span><span class="s1">protected readonly buildId: string</span><span class="s3">\n  </span><span class="s1">protected readonly minimalMode: boolean</span><span class="s3">\n  </span><span class="s1">protected readonly renderOpts: BaseRenderOpts</span><span class="s3">\n  </span><span class="s1">protected readonly serverOptions: Readonly&lt;ServerOptions&gt;</span><span class="s3">\n  </span><span class="s1">protected readonly appPathRoutes?: Record&lt;string, string[]&gt;</span><span class="s3">\n  </span><span class="s1">protected readonly clientReferenceManifest?: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">protected interceptionRoutePatterns: RegExp[]</span><span class="s3">\n  </span><span class="s1">protected nextFontManifest?: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n  </span><span class="s1">protected instrumentation: InstrumentationModule | undefined</span><span class="s3">\n  </span><span class="s1">private readonly responseCache: ResponseCacheBase</span><span class="s3">\n\n  </span><span class="s1">protected abstract getPublicDir(): string</span><span class="s3">\n  </span><span class="s1">protected abstract getHasStaticDir(): boolean</span><span class="s3">\n  </span><span class="s1">protected abstract getPagesManifest(): PagesManifest | undefined</span><span class="s3">\n  </span><span class="s1">protected abstract getAppPathsManifest(): PagesManifest | undefined</span><span class="s3">\n  </span><span class="s1">protected abstract getBuildId(): string</span><span class="s3">\n  </span><span class="s1">protected abstract getinterceptionRoutePatterns(): RegExp[]</span><span class="s3">\n\n  </span><span class="s1">protected readonly enabledDirectories: NextEnabledDirectories</span><span class="s3">\n  </span><span class="s1">protected abstract getEnabledDirectories(dev: boolean): NextEnabledDirectories</span><span class="s3">\n\n  </span><span class="s1">protected readonly experimentalTestProxy?: boolean</span><span class="s3">\n\n  </span><span class="s1">protected abstract findPageComponents(params: {</span><span class="s3">\n    </span><span class="s1">locale: string | undefined</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n    </span><span class="s1">params: Params</span><span class="s3">\n    </span><span class="s1">isAppPath: boolean</span><span class="s3">\n    </span><span class="s1">// The following parameters are used in the development server's</span><span class="s3">\n    </span><span class="s1">// implementation.</span><span class="s3">\n    </span><span class="s1">sriEnabled?: boolean</span><span class="s3">\n    </span><span class="s1">appPaths?: ReadonlyArray&lt;string&gt; | null</span><span class="s3">\n    </span><span class="s1">shouldEnsure?: boolean</span><span class="s3">\n    </span><span class="s1">url?: string</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;FindComponentsResult | null&gt;</span><span class="s3">\n  </span><span class="s1">protected abstract getPrerenderManifest(): DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">protected abstract getNextFontManifest():</span><span class="s3">\n    </span><span class="s1">| DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n    </span><span class="s1">| undefined</span><span class="s3">\n  </span><span class="s1">protected abstract attachRequestMeta(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">parsedUrl: NextUrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): void</span><span class="s3">\n  </span><span class="s1">protected abstract hasPage(pathname: string): Promise&lt;boolean&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract sendRenderResult(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">options: {</span><span class="s3">\n      </span><span class="s1">result: RenderResult</span><span class="s3">\n      </span><span class="s1">generateEtags: boolean</span><span class="s3">\n      </span><span class="s1">poweredByHeader: boolean</span><span class="s3">\n      </span><span class="s1">cacheControl: CacheControl | undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract runApi(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">match: PagesAPIRouteMatch</span><span class="s3">\n  </span><span class="s1">): Promise&lt;boolean&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract renderHTML(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">renderOpts: LoadedRenderOpts</span><span class="s3">\n  </span><span class="s1">): Promise&lt;RenderResult&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract getIncrementalCache(options: {</span><span class="s3">\n    </span><span class="s1">requestHeaders: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;import('./lib/incremental-cache').IncrementalCache&gt;</span><span class="s3">\n\n  </span><span class="s1">protected abstract getResponseCache(options: {</span><span class="s3">\n    </span><span class="s1">dev: boolean</span><span class="s3">\n  </span><span class="s1">}): ResponseCacheBase</span><span class="s3">\n\n  </span><span class="s1">protected getServerComponentsHmrCache():</span><span class="s3">\n    </span><span class="s1">| ServerComponentsHmrCache</span><span class="s3">\n    </span><span class="s1">| undefined {</span><span class="s3">\n    </span><span class="s1">return this.nextConfig.experimental.serverComponentsHmrCache</span><span class="s3">\n      </span><span class="s1">? (globalThis as any).__serverComponentsHmrCache</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected abstract loadEnvConfig(params: {</span><span class="s3">\n    </span><span class="s1">dev: boolean</span><span class="s3">\n    </span><span class="s1">forceReload?: boolean</span><span class="s3">\n  </span><span class="s1">}): void</span><span class="s3">\n\n  </span><span class="s1">// TODO-APP: (wyattjoh): Make protected again. Used for turbopack in route-resolver.ts right now.</span><span class="s3">\n  </span><span class="s1">public readonly matchers: RouteMatcherManager</span><span class="s3">\n  </span><span class="s1">protected readonly i18nProvider?: I18NProvider</span><span class="s3">\n  </span><span class="s1">protected readonly localeNormalizer?: LocaleRouteNormalizer</span><span class="s3">\n\n  </span><span class="s1">protected readonly normalizers: {</span><span class="s3">\n    </span><span class="s1">readonly rsc: RSCPathnameNormalizer | undefined</span><span class="s3">\n    </span><span class="s1">readonly prefetchRSC: PrefetchRSCPathnameNormalizer | undefined</span><span class="s3">\n    </span><span class="s1">readonly segmentPrefetchRSC: SegmentPrefixRSCPathnameNormalizer | undefined</span><span class="s3">\n    </span><span class="s1">readonly data: NextDataPathnameNormalizer | undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private readonly isAppPPREnabled: boolean</span><span class="s3">\n  </span><span class="s1">private readonly isAppSegmentPrefetchEnabled: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is used to persist cache scopes across</span><span class="s3">\n   </span><span class="s1">* prefetch -&gt; full route requests for cache components</span><span class="s3">\n   </span><span class="s1">* it's only fully used in dev</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">public constructor(options: ServerOptions) {</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">dir = '.',</span><span class="s3">\n      </span><span class="s1">quiet = false,</span><span class="s3">\n      </span><span class="s1">conf,</span><span class="s3">\n      </span><span class="s1">dev = false,</span><span class="s3">\n      </span><span class="s1">minimalMode = false,</span><span class="s3">\n      </span><span class="s1">hostname,</span><span class="s3">\n      </span><span class="s1">port,</span><span class="s3">\n      </span><span class="s1">experimentalTestProxy,</span><span class="s3">\n    </span><span class="s1">} = options</span><span class="s3">\n\n    </span><span class="s1">this.experimentalTestProxy = experimentalTestProxy</span><span class="s3">\n    </span><span class="s1">this.serverOptions = options</span><span class="s3">\n\n    </span><span class="s1">this.dir = (require('path') as typeof import('path')).resolve(dir)</span><span class="s3">\n\n    </span><span class="s1">this.quiet = quiet</span><span class="s3">\n    </span><span class="s1">this.loadEnvConfig({ dev })</span><span class="s3">\n\n    </span><span class="s1">// TODO: should conf be normalized to prevent missing</span><span class="s3">\n    </span><span class="s1">// values from causing issues as this can be user provided</span><span class="s3">\n    </span><span class="s1">this.nextConfig = conf as NextConfigComplete</span><span class="s3">\n    </span><span class="s1">this.hostname = hostname</span><span class="s3">\n    </span><span class="s1">if (this.hostname) {</span><span class="s3">\n      </span><span class="s1">// we format the hostname so that it can be fetched</span><span class="s3">\n      </span><span class="s1">this.fetchHostname = formatHostname(this.hostname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.port = port</span><span class="s3">\n    </span><span class="s1">this.distDir = (require('path') as typeof import('path')).join(</span><span class="s3">\n      </span><span class="s1">this.dir,</span><span class="s3">\n      </span><span class="s1">this.nextConfig.distDir</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.publicDir = this.getPublicDir()</span><span class="s3">\n    </span><span class="s1">this.hasStaticDir = !minimalMode &amp;&amp; this.getHasStaticDir()</span><span class="s3">\n\n    </span><span class="s1">this.i18nProvider = this.nextConfig.i18n?.locales</span><span class="s3">\n      </span><span class="s1">? new I18NProvider(this.nextConfig.i18n)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">// Configure the locale normalizer, it's used for routes inside `pages/`.</span><span class="s3">\n    </span><span class="s1">this.localeNormalizer = this.i18nProvider</span><span class="s3">\n      </span><span class="s1">? new LocaleRouteNormalizer(this.i18nProvider)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">// Only serverRuntimeConfig needs the default</span><span class="s3">\n    </span><span class="s1">// publicRuntimeConfig gets it's default in client/index.js</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">serverRuntimeConfig = {},</span><span class="s3">\n      </span><span class="s1">publicRuntimeConfig,</span><span class="s3">\n      </span><span class="s1">assetPrefix,</span><span class="s3">\n      </span><span class="s1">generateEtags,</span><span class="s3">\n    </span><span class="s1">} = this.nextConfig</span><span class="s3">\n\n    </span><span class="s1">this.buildId = this.getBuildId()</span><span class="s3">\n    </span><span class="s1">// this is a hack to avoid Webpack knowing this is equal to this.minimalMode</span><span class="s3">\n    </span><span class="s1">// because we replace this.minimalMode to true in production bundles.</span><span class="s3">\n    </span><span class="s1">const minimalModeKey = 'minimalMode'</span><span class="s3">\n    </span><span class="s1">this[minimalModeKey] =</span><span class="s3">\n      </span><span class="s1">minimalMode || !!process.env.NEXT_PRIVATE_MINIMAL_MODE</span><span class="s3">\n\n    </span><span class="s1">this.enabledDirectories = this.getEnabledDirectories(dev)</span><span class="s3">\n\n    </span><span class="s1">this.isAppPPREnabled =</span><span class="s3">\n      </span><span class="s1">this.enabledDirectories.app &amp;&amp;</span><span class="s3">\n      </span><span class="s1">checkIsAppPPREnabled(this.nextConfig.experimental.ppr)</span><span class="s3">\n\n    </span><span class="s1">this.isAppSegmentPrefetchEnabled =</span><span class="s3">\n      </span><span class="s1">this.enabledDirectories.app &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.nextConfig.experimental.clientSegmentCache === true</span><span class="s3">\n\n    </span><span class="s1">this.normalizers = {</span><span class="s3">\n      </span><span class="s1">// We should normalize the pathname from the RSC prefix only in minimal</span><span class="s3">\n      </span><span class="s1">// mode as otherwise that route is not exposed external to the server as</span><span class="s3">\n      </span><span class="s1">// we instead only rely on the headers.</span><span class="s3">\n      </span><span class="s1">rsc:</span><span class="s3">\n        </span><span class="s1">this.enabledDirectories.app &amp;&amp; this.minimalMode</span><span class="s3">\n          </span><span class="s1">? new RSCPathnameNormalizer()</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">prefetchRSC:</span><span class="s3">\n        </span><span class="s1">this.isAppPPREnabled &amp;&amp; this.minimalMode</span><span class="s3">\n          </span><span class="s1">? new PrefetchRSCPathnameNormalizer()</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">segmentPrefetchRSC:</span><span class="s3">\n        </span><span class="s1">this.isAppSegmentPrefetchEnabled &amp;&amp; this.minimalMode</span><span class="s3">\n          </span><span class="s1">? new SegmentPrefixRSCPathnameNormalizer()</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">data: this.enabledDirectories.pages</span><span class="s3">\n        </span><span class="s1">? new NextDataPathnameNormalizer(this.buildId)</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.nextFontManifest = this.getNextFontManifest()</span><span class="s3">\n    </span><span class="s1">process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || ''</span><span class="s3">\n\n    </span><span class="s1">this.renderOpts = {</span><span class="s3">\n      </span><span class="s1">dir: this.dir,</span><span class="s3">\n      </span><span class="s1">supportsDynamicResponse: true,</span><span class="s3">\n      </span><span class="s1">trailingSlash: this.nextConfig.trailingSlash,</span><span class="s3">\n      </span><span class="s1">deploymentId: this.nextConfig.deploymentId,</span><span class="s3">\n      </span><span class="s1">poweredByHeader: this.nextConfig.poweredByHeader,</span><span class="s3">\n      </span><span class="s1">canonicalBase: this.nextConfig.amp.canonicalBase || '',</span><span class="s3">\n      </span><span class="s1">generateEtags,</span><span class="s3">\n      </span><span class="s1">previewProps: this.getPrerenderManifest().preview,</span><span class="s3">\n      </span><span class="s1">ampOptimizerConfig: this.nextConfig.experimental.amp?.optimizer,</span><span class="s3">\n      </span><span class="s1">basePath: this.nextConfig.basePath,</span><span class="s3">\n      </span><span class="s1">images: this.nextConfig.images,</span><span class="s3">\n      </span><span class="s1">optimizeCss: this.nextConfig.experimental.optimizeCss,</span><span class="s3">\n      </span><span class="s1">nextConfigOutput: this.nextConfig.output,</span><span class="s3">\n      </span><span class="s1">nextScriptWorkers: this.nextConfig.experimental.nextScriptWorkers,</span><span class="s3">\n      </span><span class="s1">disableOptimizedLoading:</span><span class="s3">\n        </span><span class="s1">this.nextConfig.experimental.disableOptimizedLoading,</span><span class="s3">\n      </span><span class="s1">domainLocales: this.nextConfig.i18n?.domains,</span><span class="s3">\n      </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n      </span><span class="s1">serverComponents: this.enabledDirectories.app,</span><span class="s3">\n      </span><span class="s1">cacheLifeProfiles: this.nextConfig.experimental.cacheLife,</span><span class="s3">\n      </span><span class="s1">enableTainting: this.nextConfig.experimental.taint,</span><span class="s3">\n      </span><span class="s1">crossOrigin: this.nextConfig.crossOrigin</span><span class="s3">\n        </span><span class="s1">? this.nextConfig.crossOrigin</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">largePageDataBytes: this.nextConfig.experimental.largePageDataBytes,</span><span class="s3">\n      </span><span class="s1">// Only the `publicRuntimeConfig` key is exposed to the client side</span><span class="s3">\n      </span><span class="s1">// It'll be rendered as part of __NEXT_DATA__ on the client side</span><span class="s3">\n      </span><span class="s1">runtimeConfig:</span><span class="s3">\n        </span><span class="s1">Object.keys(publicRuntimeConfig).length &gt; 0</span><span class="s3">\n          </span><span class="s1">? publicRuntimeConfig</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n\n      </span><span class="s1">isExperimentalCompile: this.nextConfig.experimental.isExperimentalCompile,</span><span class="s3">\n      </span><span class="s1">// `htmlLimitedBots` is passed to server as serialized config in string format</span><span class="s3">\n      </span><span class="s1">htmlLimitedBots: this.nextConfig.htmlLimitedBots,</span><span class="s3">\n      </span><span class="s1">experimental: {</span><span class="s3">\n        </span><span class="s1">expireTime: this.nextConfig.expireTime,</span><span class="s3">\n        </span><span class="s1">staleTimes: this.nextConfig.experimental.staleTimes,</span><span class="s3">\n        </span><span class="s1">clientTraceMetadata: this.nextConfig.experimental.clientTraceMetadata,</span><span class="s3">\n        </span><span class="s1">cacheComponents: this.nextConfig.experimental.cacheComponents ?? false,</span><span class="s3">\n        </span><span class="s1">clientSegmentCache:</span><span class="s3">\n          </span><span class="s1">this.nextConfig.experimental.clientSegmentCache === 'client-only'</span><span class="s3">\n            </span><span class="s1">? 'client-only'</span><span class="s3">\n            </span><span class="s1">: Boolean(this.nextConfig.experimental.clientSegmentCache),</span><span class="s3">\n        </span><span class="s1">clientParamParsing:</span><span class="s3">\n          </span><span class="s1">this.nextConfig.experimental.clientParamParsing ?? false,</span><span class="s3">\n        </span><span class="s1">dynamicOnHover: this.nextConfig.experimental.dynamicOnHover ?? false,</span><span class="s3">\n        </span><span class="s1">inlineCss: this.nextConfig.experimental.inlineCss ?? false,</span><span class="s3">\n        </span><span class="s1">authInterrupts: !!this.nextConfig.experimental.authInterrupts,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">onInstrumentationRequestError:</span><span class="s3">\n        </span><span class="s1">this.instrumentationOnRequestError.bind(this),</span><span class="s3">\n      </span><span class="s1">reactMaxHeadersLength: this.nextConfig.reactMaxHeadersLength,</span><span class="s3">\n      </span><span class="s1">devtoolSegmentExplorer:</span><span class="s3">\n        </span><span class="s1">this.nextConfig.experimental.devtoolSegmentExplorer,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Initialize next/config with the environment configuration</span><span class="s3">\n    </span><span class="s1">setConfig({</span><span class="s3">\n      </span><span class="s1">serverRuntimeConfig,</span><span class="s3">\n      </span><span class="s1">publicRuntimeConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">this.pagesManifest = this.getPagesManifest()</span><span class="s3">\n    </span><span class="s1">this.appPathsManifest = this.getAppPathsManifest()</span><span class="s3">\n    </span><span class="s1">this.appPathRoutes = this.getAppPathRoutes()</span><span class="s3">\n    </span><span class="s1">this.interceptionRoutePatterns = this.getinterceptionRoutePatterns()</span><span class="s3">\n\n    </span><span class="s1">// Configure the routes.</span><span class="s3">\n    </span><span class="s1">this.matchers = this.getRouteMatchers()</span><span class="s3">\n\n    </span><span class="s1">// Start route compilation. We don't wait for the routes to finish loading</span><span class="s3">\n    </span><span class="s1">// because we use the `waitTillReady` promise below in `handleRequest` to</span><span class="s3">\n    </span><span class="s1">// wait. Also we can't `await` in the constructor.</span><span class="s3">\n    </span><span class="s1">void this.matchers.reload()</span><span class="s3">\n\n    </span><span class="s1">this.setAssetPrefix(assetPrefix)</span><span class="s3">\n    </span><span class="s1">this.responseCache = this.getResponseCache({ dev })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private handleRSCRequest: RouteHandler&lt;ServerRequest, ServerResponse&gt; = (</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">_res,</span><span class="s3">\n    </span><span class="s1">parsedUrl</span><span class="s3">\n  </span><span class="s1">) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!parsedUrl.pathname) return false</span><span class="s3">\n\n    </span><span class="s1">if (this.normalizers.segmentPrefetchRSC?.match(parsedUrl.pathname)) {</span><span class="s3">\n      </span><span class="s1">const result = this.normalizers.segmentPrefetchRSC.extract(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (!result) return false</span><span class="s3">\n\n      </span><span class="s1">const { originalPathname, segmentPath } = result</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = originalPathname</span><span class="s3">\n\n      </span><span class="s1">// Mark the request as a router prefetch request.</span><span class="s3">\n      </span><span class="s1">req.headers[RSC_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">req.headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] = segmentPath</span><span class="s3">\n\n      </span><span class="s1">addRequestMeta(req, 'isRSCRequest', true)</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isPrefetchRSCRequest', true)</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'segmentPrefetchRSCRequest', segmentPath)</span><span class="s3">\n    </span><span class="s1">} else if (this.normalizers.prefetchRSC?.match(parsedUrl.pathname)) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = this.normalizers.prefetchRSC.normalize(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname,</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// Mark the request as a router prefetch request.</span><span class="s3">\n      </span><span class="s1">req.headers[RSC_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">req.headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isRSCRequest', true)</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isPrefetchRSCRequest', true)</span><span class="s3">\n    </span><span class="s1">} else if (this.normalizers.rsc?.match(parsedUrl.pathname)) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = this.normalizers.rsc.normalize(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname,</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// Mark the request as a RSC request.</span><span class="s3">\n      </span><span class="s1">req.headers[RSC_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isRSCRequest', true)</span><span class="s3">\n    </span><span class="s1">} else if (req.headers['x-now-route-matches']) {</span><span class="s3">\n      </span><span class="s1">// If we didn't match, return with the flight headers stripped. If in</span><span class="s3">\n      </span><span class="s1">// minimal mode we didn't match based on the path, this can't be a RSC</span><span class="s3">\n      </span><span class="s1">// request. This is because Vercel only sends this header during</span><span class="s3">\n      </span><span class="s1">// revalidation requests and we want the cache to instead depend on the</span><span class="s3">\n      </span><span class="s1">// request path for flight information.</span><span class="s3">\n      </span><span class="s1">stripFlightHeaders(req.headers)</span><span class="s3">\n\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">} else if (req.headers[RSC_HEADER] === '1') {</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isRSCRequest', true)</span><span class="s3">\n\n      </span><span class="s1">if (req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1') {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'isPrefetchRSCRequest', true)</span><span class="s3">\n\n        </span><span class="s1">const segmentPrefetchRSCRequest =</span><span class="s3">\n          </span><span class="s1">req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]</span><span class="s3">\n        </span><span class="s1">if (typeof segmentPrefetchRSCRequest === 'string') {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(</span><span class="s3">\n            </span><span class="s1">req,</span><span class="s3">\n            </span><span class="s1">'segmentPrefetchRSCRequest',</span><span class="s3">\n            </span><span class="s1">segmentPrefetchRSCRequest</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Otherwise just return without doing anything.</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (req.url) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseUrl(req.url)</span><span class="s3">\n      </span><span class="s1">parsed.pathname = parsedUrl.pathname</span><span class="s3">\n      </span><span class="s1">req.url = formatUrl(parsed)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private handleNextDataRequest: RouteHandler&lt;ServerRequest, ServerResponse&gt; =</span><span class="s3">\n    </span><span class="s1">async (req, res, parsedUrl) =&gt; {</span><span class="s3">\n      </span><span class="s1">const middleware = await this.getMiddleware()</span><span class="s3">\n      </span><span class="s1">const params = matchNextDataPathname(parsedUrl.pathname)</span><span class="s3">\n\n      </span><span class="s1">// ignore for non-next data URLs</span><span class="s3">\n      </span><span class="s1">if (!params || !params.path) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (params.path[0] !== this.buildId) {</span><span class="s3">\n        </span><span class="s1">// Ignore if its a middleware request when we aren't on edge.</span><span class="s3">\n        </span><span class="s1">if (getRequestMeta(req, 'middlewareInvoke')) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Make sure to 404 if the buildId isn't correct</span><span class="s3">\n        </span><span class="s1">await this.render404(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// remove buildId from URL</span><span class="s3">\n      </span><span class="s1">params.path.shift()</span><span class="s3">\n\n      </span><span class="s1">const lastParam = params.path[params.path.length - 1]</span><span class="s3">\n\n      </span><span class="s1">// show 404 if it doesn't end with .json</span><span class="s3">\n      </span><span class="s1">if (typeof lastParam !== 'string' || !lastParam.endsWith('.json')) {</span><span class="s3">\n        </span><span class="s1">await this.render404(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// re-create page's pathname</span><span class="s3">\n      </span><span class="s1">let pathname = `/${params.path.join('/')}`</span><span class="s3">\n      </span><span class="s1">pathname = getRouteFromAssetPath(pathname, '.json')</span><span class="s3">\n\n      </span><span class="s1">// ensure trailing slash is normalized per config</span><span class="s3">\n      </span><span class="s1">if (middleware) {</span><span class="s3">\n        </span><span class="s1">if (this.nextConfig.trailingSlash &amp;&amp; !pathname.endsWith('/')) {</span><span class="s3">\n          </span><span class="s1">pathname += '/'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!this.nextConfig.trailingSlash &amp;&amp;</span><span class="s3">\n          </span><span class="s1">pathname.length &gt; 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">pathname.endsWith('/')</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">pathname = pathname.substring(0, pathname.length - 1)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (this.i18nProvider) {</span><span class="s3">\n        </span><span class="s1">// Remove the port from the hostname if present.</span><span class="s3">\n        </span><span class="s1">const hostname = req?.headers.host?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">const domainLocale = this.i18nProvider.detectDomainLocale(hostname)</span><span class="s3">\n        </span><span class="s1">const defaultLocale =</span><span class="s3">\n          </span><span class="s1">domainLocale?.defaultLocale ?? this.i18nProvider.config.defaultLocale</span><span class="s3">\n\n        </span><span class="s1">const localePathResult = this.i18nProvider.analyze(pathname)</span><span class="s3">\n\n        </span><span class="s1">// If the locale is detected from the path, we need to remove it</span><span class="s3">\n        </span><span class="s1">// from the pathname.</span><span class="s3">\n        </span><span class="s1">if (localePathResult.detectedLocale) {</span><span class="s3">\n          </span><span class="s1">pathname = localePathResult.pathname</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Update the query with the detected locale and default locale.</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'locale', localePathResult.detectedLocale)</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'defaultLocale', defaultLocale)</span><span class="s3">\n\n        </span><span class="s1">// If the locale is not detected from the path, we need to mark that</span><span class="s3">\n        </span><span class="s1">// it was not inferred from default.</span><span class="s3">\n        </span><span class="s1">if (!localePathResult.detectedLocale) {</span><span class="s3">\n          </span><span class="s1">removeRequestMeta(req, 'localeInferredFromDefault')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If no locale was detected and we don't have middleware, we need</span><span class="s3">\n        </span><span class="s1">// to render a 404 page.</span><span class="s3">\n        </span><span class="s1">if (!localePathResult.detectedLocale &amp;&amp; !middleware) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', defaultLocale)</span><span class="s3">\n          </span><span class="s1">await this.render404(req, res, parsedUrl)</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">parsedUrl.pathname = pathname</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'isNextDataReq', true)</span><span class="s3">\n\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected handleNextImageRequest: RouteHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; = () =&gt; false</span><span class="s3">\n\n  </span><span class="s1">protected handleCatchallRenderRequest: RouteHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; = () =&gt; false</span><span class="s3">\n\n  </span><span class="s1">protected handleCatchallMiddlewareRequest: RouteHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; = () =&gt; false</span><span class="s3">\n\n  </span><span class="s1">protected getRouteMatchers(): RouteMatcherManager {</span><span class="s3">\n    </span><span class="s1">// Create a new manifest loader that get's the manifests from the server.</span><span class="s3">\n    </span><span class="s1">const manifestLoader = new ServerManifestLoader((name) =&gt; {</span><span class="s3">\n      </span><span class="s1">switch (name) {</span><span class="s3">\n        </span><span class="s1">case PAGES_MANIFEST:</span><span class="s3">\n          </span><span class="s1">return this.getPagesManifest() ?? null</span><span class="s3">\n        </span><span class="s1">case APP_PATHS_MANIFEST:</span><span class="s3">\n          </span><span class="s1">return this.getAppPathsManifest() ?? null</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// Configure the matchers and handlers.</span><span class="s3">\n    </span><span class="s1">const matchers: RouteMatcherManager = new DefaultRouteMatcherManager()</span><span class="s3">\n\n    </span><span class="s1">// Match pages under `pages/`.</span><span class="s3">\n    </span><span class="s1">matchers.push(</span><span class="s3">\n      </span><span class="s1">new PagesRouteMatcherProvider(</span><span class="s3">\n        </span><span class="s1">this.distDir,</span><span class="s3">\n        </span><span class="s1">manifestLoader,</span><span class="s3">\n        </span><span class="s1">this.i18nProvider</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// Match api routes under `pages/api/`.</span><span class="s3">\n    </span><span class="s1">matchers.push(</span><span class="s3">\n      </span><span class="s1">new PagesAPIRouteMatcherProvider(</span><span class="s3">\n        </span><span class="s1">this.distDir,</span><span class="s3">\n        </span><span class="s1">manifestLoader,</span><span class="s3">\n        </span><span class="s1">this.i18nProvider</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// If the app directory is enabled, then add the app matchers and handlers.</span><span class="s3">\n    </span><span class="s1">if (this.enabledDirectories.app) {</span><span class="s3">\n      </span><span class="s1">// Match app pages under `app/`.</span><span class="s3">\n      </span><span class="s1">matchers.push(</span><span class="s3">\n        </span><span class="s1">new AppPageRouteMatcherProvider(this.distDir, manifestLoader)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">matchers.push(</span><span class="s3">\n        </span><span class="s1">new AppRouteRouteMatcherProvider(this.distDir, manifestLoader)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return matchers</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async instrumentationOnRequestError(</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;ServerOnInstrumentationRequestError&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const [err, req, ctx] = args</span><span class="s3">\n\n    </span><span class="s1">if (this.instrumentation) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">await this.instrumentation.onRequestError?.(</span><span class="s3">\n          </span><span class="s1">err,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">path: req.url || '',</span><span class="s3">\n            </span><span class="s1">method: req.method || 'GET',</span><span class="s3">\n            </span><span class="s1">// Normalize middleware headers and other server request headers</span><span class="s3">\n            </span><span class="s1">headers:</span><span class="s3">\n              </span><span class="s1">req instanceof NextRequestHint</span><span class="s3">\n                </span><span class="s1">? Object.fromEntries(req.headers.entries())</span><span class="s3">\n                </span><span class="s1">: req.headers,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">ctx</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (handlerErr) {</span><span class="s3">\n        </span><span class="s1">// Log the soft error and continue, since errors can thrown from react stream handler</span><span class="s3">\n        </span><span class="s1">console.error('Error in instrumentation.onRequestError:', handlerErr)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public logError(err: Error): void {</span><span class="s3">\n    </span><span class="s1">if (this.quiet) return</span><span class="s3">\n    </span><span class="s1">Log.error(err)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async handleRequest(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">await this.prepare()</span><span class="s3">\n    </span><span class="s1">const method = req.method.toUpperCase()</span><span class="s3">\n\n    </span><span class="s1">const tracer = getTracer()</span><span class="s3">\n    </span><span class="s1">return tracer.withPropagatedContext(req.headers, () =&gt; {</span><span class="s3">\n      </span><span class="s1">return tracer.trace(</span><span class="s3">\n        </span><span class="s1">BaseServerSpan.handleRequest,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">spanName: `${method} ${req.url}`,</span><span class="s3">\n          </span><span class="s1">kind: SpanKind.SERVER,</span><span class="s3">\n          </span><span class="s1">attributes: {</span><span class="s3">\n            </span><span class="s1">'http.method': method,</span><span class="s3">\n            </span><span class="s1">'http.target': req.url,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">async (span) =&gt;</span><span class="s3">\n          </span><span class="s1">this.handleRequestImpl(req, res, parsedUrl).finally(() =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!span) return</span><span class="s3">\n\n            </span><span class="s1">const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false</span><span class="s3">\n            </span><span class="s1">span.setAttributes({</span><span class="s3">\n              </span><span class="s1">'http.status_code': res.statusCode,</span><span class="s3">\n              </span><span class="s1">'next.rsc': isRSCRequest,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">if (res.statusCode &amp;&amp; res.statusCode &gt;= 500) {</span><span class="s3">\n              </span><span class="s1">// For 5xx status codes: SHOULD be set to 'Error' span status.</span><span class="s3">\n              </span><span class="s1">// x-ref: https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status</span><span class="s3">\n              </span><span class="s1">span.setStatus({</span><span class="s3">\n                </span><span class="s1">code: SpanStatusCode.ERROR,</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">// For span status 'Error', SHOULD set 'error.type' attribute.</span><span class="s3">\n              </span><span class="s1">span.setAttribute('error.type', res.statusCode.toString())</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const rootSpanAttributes = tracer.getRootSpanAttributes()</span><span class="s3">\n            </span><span class="s1">// We were unable to get attributes, probably OTEL is not enabled</span><span class="s3">\n            </span><span class="s1">if (!rootSpanAttributes) return</span><span class="s3">\n\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">rootSpanAttributes.get('next.span_type') !==</span><span class="s3">\n              </span><span class="s1">BaseServerSpan.handleRequest</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">console.warn(</span><span class="s3">\n                </span><span class="s1">`Unexpected root span type '${rootSpanAttributes.get(</span><span class="s3">\n                  </span><span class="s1">'next.span_type'</span><span class="s3">\n                </span><span class="s1">)}'. Please report this Next.js issue https://github.com/vercel/next.js`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">return</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const route = rootSpanAttributes.get('next.route')</span><span class="s3">\n            </span><span class="s1">if (route) {</span><span class="s3">\n              </span><span class="s1">const name = isRSCRequest</span><span class="s3">\n                </span><span class="s1">? `RSC ${method} ${route}`</span><span class="s3">\n                </span><span class="s1">: `${method} ${route}`</span><span class="s3">\n\n              </span><span class="s1">span.setAttributes({</span><span class="s3">\n                </span><span class="s1">'next.route': route,</span><span class="s3">\n                </span><span class="s1">'http.route': route,</span><span class="s3">\n                </span><span class="s1">'next.span_name': name,</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">span.updateName(name)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">span.updateName(</span><span class="s3">\n                </span><span class="s1">isRSCRequest</span><span class="s3">\n                  </span><span class="s1">? `RSC ${method} ${req.url}`</span><span class="s3">\n                  </span><span class="s1">: `${method} ${req.url}`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async handleRequestImpl(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">// Wait for the matchers to be ready.</span><span class="s3">\n      </span><span class="s1">await this.matchers.waitTillReady()</span><span class="s3">\n\n      </span><span class="s1">// ensure cookies set in middleware are merged and</span><span class="s3">\n      </span><span class="s1">// not overridden by API routes/getServerSideProps</span><span class="s3">\n      </span><span class="s1">patchSetHeaderWithCookieSupport(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">isNodeNextResponse(res) ? res.originalResponse : res</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const urlParts = (req.url || '').split('?', 1)</span><span class="s3">\n      </span><span class="s1">const urlNoQuery = urlParts[0]</span><span class="s3">\n\n      </span><span class="s1">// this normalizes repeated slashes in the path e.g. hello//world -&gt;</span><span class="s3">\n      </span><span class="s1">// hello/world or backslashes to forward slashes, this does not</span><span class="s3">\n      </span><span class="s1">// handle trailing slash as that is handled the same as a next.config.js</span><span class="s3">\n      </span><span class="s1">// redirect</span><span class="s3">\n      </span><span class="s1">if (urlNoQuery?.match(/(</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/)/)) {</span><span class="s3">\n        </span><span class="s1">const cleanUrl = normalizeRepeatedSlashes(req.url!)</span><span class="s3">\n        </span><span class="s1">res.redirect(cleanUrl, 308).body(cleanUrl).send()</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Parse url if parsedUrl not provided</span><span class="s3">\n      </span><span class="s1">if (!parsedUrl || typeof parsedUrl !== 'object') {</span><span class="s3">\n        </span><span class="s1">if (!req.url) {</span><span class="s3">\n          </span><span class="s1">throw new Error('Invariant: url can not be undefined')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">parsedUrl = parseUrl(req.url!, true)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!parsedUrl.pathname) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Invariant: pathname can't be empty</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Parse the querystring ourselves if the user doesn't handle querystring parsing</span><span class="s3">\n      </span><span class="s1">if (typeof parsedUrl.query === 'string') {</span><span class="s3">\n        </span><span class="s1">parsedUrl.query = Object.fromEntries(</span><span class="s3">\n          </span><span class="s1">new URLSearchParams(parsedUrl.query)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Update the `x-forwarded-*` headers.</span><span class="s3">\n      </span><span class="s1">const { originalRequest = null } = isNodeNextRequest(req) ? req : {}</span><span class="s3">\n      </span><span class="s1">const xForwardedProto = originalRequest?.headers['x-forwarded-proto']</span><span class="s3">\n      </span><span class="s1">const isHttps = xForwardedProto</span><span class="s3">\n        </span><span class="s1">? xForwardedProto === 'https'</span><span class="s3">\n        </span><span class="s1">: !!(originalRequest?.socket as TLSSocket)?.encrypted</span><span class="s3">\n\n      </span><span class="s1">req.headers['x-forwarded-host'] ??= req.headers['host'] ?? this.hostname</span><span class="s3">\n      </span><span class="s1">req.headers['x-forwarded-port'] ??= this.port</span><span class="s3">\n        </span><span class="s1">? this.port.toString()</span><span class="s3">\n        </span><span class="s1">: isHttps</span><span class="s3">\n          </span><span class="s1">? '443'</span><span class="s3">\n          </span><span class="s1">: '80'</span><span class="s3">\n      </span><span class="s1">req.headers['x-forwarded-proto'] ??= isHttps ? 'https' : 'http'</span><span class="s3">\n      </span><span class="s1">req.headers['x-forwarded-for'] ??= originalRequest?.socket?.remoteAddress</span><span class="s3">\n\n      </span><span class="s1">// This should be done before any normalization of the pathname happens as</span><span class="s3">\n      </span><span class="s1">// it captures the initial URL.</span><span class="s3">\n      </span><span class="s1">this.attachRequestMeta(req, parsedUrl)</span><span class="s3">\n\n      </span><span class="s1">let finished = await this.handleRSCRequest(req, res, parsedUrl)</span><span class="s3">\n      </span><span class="s1">if (finished) return</span><span class="s3">\n\n      </span><span class="s1">const domainLocale = this.i18nProvider?.detectDomainLocale(</span><span class="s3">\n        </span><span class="s1">getHostname(parsedUrl, req.headers)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const defaultLocale =</span><span class="s3">\n        </span><span class="s1">domainLocale?.defaultLocale || this.nextConfig.i18n?.defaultLocale</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'defaultLocale', defaultLocale)</span><span class="s3">\n\n      </span><span class="s1">const url = parseUrlUtil(req.url.replace(/^</span><span class="s3">\\</span><span class="s1">/+/, '/'))</span><span class="s3">\n      </span><span class="s1">const pathnameInfo = getNextPathnameInfo(url.pathname, {</span><span class="s3">\n        </span><span class="s1">nextConfig: this.nextConfig,</span><span class="s3">\n        </span><span class="s1">i18nProvider: this.i18nProvider,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">url.pathname = pathnameInfo.pathname</span><span class="s3">\n\n      </span><span class="s1">if (pathnameInfo.basePath) {</span><span class="s3">\n        </span><span class="s1">req.url = removePathPrefix(req.url!, this.nextConfig.basePath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const useMatchedPathHeader =</span><span class="s3">\n        </span><span class="s1">this.minimalMode &amp;&amp; typeof req.headers[MATCHED_PATH_HEADER] === 'string'</span><span class="s3">\n\n      </span><span class="s1">// TODO: merge handling with invokePath</span><span class="s3">\n      </span><span class="s1">if (useMatchedPathHeader) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">if (this.enabledDirectories.app) {</span><span class="s3">\n            </span><span class="s1">// ensure /index path is normalized for prerender</span><span class="s3">\n            </span><span class="s1">// in minimal mode</span><span class="s3">\n            </span><span class="s1">if (req.url.match(/^</span><span class="s3">\\</span><span class="s1">/index($|</span><span class="s3">\\</span><span class="s1">?)/)) {</span><span class="s3">\n              </span><span class="s1">req.url = req.url.replace(/^</span><span class="s3">\\</span><span class="s1">/index/, '/')</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">parsedUrl.pathname =</span><span class="s3">\n              </span><span class="s1">parsedUrl.pathname === '/index' ? '/' : parsedUrl.pathname</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// x-matched-path is the source of truth, it tells what page</span><span class="s3">\n          </span><span class="s1">// should be rendered because we don't process rewrites in minimalMode</span><span class="s3">\n          </span><span class="s1">let { pathname: matchedPath } = new URL(</span><span class="s3">\n            </span><span class="s1">fixMojibake(req.headers[MATCHED_PATH_HEADER] as string),</span><span class="s3">\n            </span><span class="s1">'http://localhost'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">let { pathname: urlPathname } = new URL(req.url, 'http://localhost')</span><span class="s3">\n\n          </span><span class="s1">// For ISR the URL is normalized to the prerenderPath so if</span><span class="s3">\n          </span><span class="s1">// it's a data request the URL path will be the data URL,</span><span class="s3">\n          </span><span class="s1">// basePath is already stripped by this point</span><span class="s3">\n          </span><span class="s1">if (this.normalizers.data?.match(urlPathname)) {</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'isNextDataReq', true)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// In minimal mode, if PPR is enabled, then we should check to see if</span><span class="s3">\n          </span><span class="s1">// the request should be a resume request.</span><span class="s3">\n          </span><span class="s1">else if (</span><span class="s3">\n            </span><span class="s1">this.isAppPPREnabled &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.minimalMode &amp;&amp;</span><span class="s3">\n            </span><span class="s1">req.headers[NEXT_RESUME_HEADER] === '1' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">req.method === 'POST'</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// Decode the postponed state from the request body, it will come as</span><span class="s3">\n            </span><span class="s1">// an array of buffers, so collect them and then concat them to form</span><span class="s3">\n            </span><span class="s1">// the string.</span><span class="s3">\n            </span><span class="s1">const body: Array&lt;Buffer&gt; = []</span><span class="s3">\n            </span><span class="s1">for await (const chunk of req.body) {</span><span class="s3">\n              </span><span class="s1">body.push(chunk)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const postponed = Buffer.concat(body).toString('utf8')</span><span class="s3">\n\n            </span><span class="s1">addRequestMeta(req, 'postponed', postponed)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">matchedPath = this.normalize(matchedPath)</span><span class="s3">\n          </span><span class="s1">const normalizedUrlPath = this.stripNextDataPath(urlPathname)</span><span class="s3">\n\n          </span><span class="s1">matchedPath = denormalizePagePath(matchedPath)</span><span class="s3">\n\n          </span><span class="s1">// Perform locale detection and normalization.</span><span class="s3">\n          </span><span class="s1">const localeAnalysisResult = this.i18nProvider?.analyze(matchedPath, {</span><span class="s3">\n            </span><span class="s1">defaultLocale,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">// The locale result will be defined even if the locale was not</span><span class="s3">\n          </span><span class="s1">// detected for the request because it will be inferred from the</span><span class="s3">\n          </span><span class="s1">// default locale.</span><span class="s3">\n          </span><span class="s1">if (localeAnalysisResult) {</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'locale', localeAnalysisResult.detectedLocale)</span><span class="s3">\n\n            </span><span class="s1">// If the detected locale was inferred from the default locale, we</span><span class="s3">\n            </span><span class="s1">// need to modify the metadata on the request to indicate that.</span><span class="s3">\n            </span><span class="s1">if (localeAnalysisResult.inferredFromDefault) {</span><span class="s3">\n              </span><span class="s1">addRequestMeta(req, 'localeInferredFromDefault', true)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">removeRequestMeta(req, 'localeInferredFromDefault')</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">let srcPathname = matchedPath</span><span class="s3">\n          </span><span class="s1">let pageIsDynamic = isDynamicRoute(srcPathname)</span><span class="s3">\n          </span><span class="s1">let paramsResult: {</span><span class="s3">\n            </span><span class="s1">params: ParsedUrlQuery | false</span><span class="s3">\n            </span><span class="s1">hasValidParams: boolean</span><span class="s3">\n          </span><span class="s1">} = {</span><span class="s3">\n            </span><span class="s1">params: false,</span><span class="s3">\n            </span><span class="s1">hasValidParams: false,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (!pageIsDynamic) {</span><span class="s3">\n            </span><span class="s1">const match = await this.matchers.match(srcPathname, {</span><span class="s3">\n              </span><span class="s1">i18n: localeAnalysisResult,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">// Update the source pathname to the matched page's pathname.</span><span class="s3">\n            </span><span class="s1">if (match) {</span><span class="s3">\n              </span><span class="s1">srcPathname = match.definition.pathname</span><span class="s3">\n\n              </span><span class="s1">// The page is dynamic if the params are defined. We know at this</span><span class="s3">\n              </span><span class="s1">// stage that the matched path is not a static page if the params</span><span class="s3">\n              </span><span class="s1">// were parsed from the matched path header.</span><span class="s3">\n              </span><span class="s1">if (typeof match.params !== 'undefined') {</span><span class="s3">\n                </span><span class="s1">pageIsDynamic = true</span><span class="s3">\n                </span><span class="s1">paramsResult.params = match.params</span><span class="s3">\n                </span><span class="s1">paramsResult.hasValidParams = true</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// The rest of this function can't handle i18n properly, so ensure we</span><span class="s3">\n          </span><span class="s1">// restore the pathname with the locale information stripped from it</span><span class="s3">\n          </span><span class="s1">// now that we're done matching if we're using i18n.</span><span class="s3">\n          </span><span class="s1">if (localeAnalysisResult) {</span><span class="s3">\n            </span><span class="s1">matchedPath = localeAnalysisResult.pathname</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const utils = getServerUtils({</span><span class="s3">\n            </span><span class="s1">pageIsDynamic,</span><span class="s3">\n            </span><span class="s1">page: srcPathname,</span><span class="s3">\n            </span><span class="s1">i18n: this.nextConfig.i18n,</span><span class="s3">\n            </span><span class="s1">basePath: this.nextConfig.basePath,</span><span class="s3">\n            </span><span class="s1">rewrites: this.getRoutesManifest()?.rewrites || {</span><span class="s3">\n              </span><span class="s1">beforeFiles: [],</span><span class="s3">\n              </span><span class="s1">afterFiles: [],</span><span class="s3">\n              </span><span class="s1">fallback: [],</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">caseSensitive: !!this.nextConfig.experimental.caseSensitiveRoutes,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">// Ensure parsedUrl.pathname includes locale before processing</span><span class="s3">\n          </span><span class="s1">// rewrites or they won't match correctly.</span><span class="s3">\n          </span><span class="s1">if (defaultLocale &amp;&amp; !pathnameInfo.locale) {</span><span class="s3">\n            </span><span class="s1">parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Store a copy of `parsedUrl.query` before calling handleRewrites.</span><span class="s3">\n          </span><span class="s1">// Since `handleRewrites` might add new queries to `parsedUrl.query`.</span><span class="s3">\n          </span><span class="s1">const originQueryParams = { ...parsedUrl.query }</span><span class="s3">\n\n          </span><span class="s1">const pathnameBeforeRewrite = parsedUrl.pathname</span><span class="s3">\n          </span><span class="s1">const rewriteParamKeys = Object.keys(</span><span class="s3">\n            </span><span class="s1">utils.handleRewrites(req, parsedUrl)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// Create a copy of the query params to avoid mutating the original</span><span class="s3">\n          </span><span class="s1">// object. This prevents any overlapping query params that have the</span><span class="s3">\n          </span><span class="s1">// same normalized key from causing issues.</span><span class="s3">\n          </span><span class="s1">const queryParams = { ...parsedUrl.query }</span><span class="s3">\n          </span><span class="s1">const didRewrite = pathnameBeforeRewrite !== parsedUrl.pathname</span><span class="s3">\n\n          </span><span class="s1">if (didRewrite &amp;&amp; parsedUrl.pathname) {</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'rewroteURL', parsedUrl.pathname)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const routeParamKeys = new Set&lt;string&gt;()</span><span class="s3">\n          </span><span class="s1">for (const [key, value] of Object.entries(parsedUrl.query)) {</span><span class="s3">\n            </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n            </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n            </span><span class="s1">// Remove the prefixed key from the query params because we want</span><span class="s3">\n            </span><span class="s1">// to consume it for the dynamic route matcher.</span><span class="s3">\n            </span><span class="s1">delete parsedUrl.query[key]</span><span class="s3">\n            </span><span class="s1">routeParamKeys.add(normalizedKey)</span><span class="s3">\n\n            </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n\n            </span><span class="s1">queryParams[normalizedKey] = Array.isArray(value)</span><span class="s3">\n              </span><span class="s1">? value.map((v) =&gt; decodeQueryPathParameter(v))</span><span class="s3">\n              </span><span class="s1">: decodeQueryPathParameter(value)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// interpolate dynamic params and normalize URL if needed</span><span class="s3">\n          </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n            </span><span class="s1">let params: ParsedUrlQuery | false = {}</span><span class="s3">\n\n            </span><span class="s1">// If we don't already have valid params, try to parse them from</span><span class="s3">\n            </span><span class="s1">// the query params.</span><span class="s3">\n            </span><span class="s1">if (!paramsResult.hasValidParams) {</span><span class="s3">\n              </span><span class="s1">paramsResult = utils.normalizeDynamicRouteParams(</span><span class="s3">\n                </span><span class="s1">queryParams,</span><span class="s3">\n                </span><span class="s1">false</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// for prerendered ISR paths we attempt parsing the route</span><span class="s3">\n            </span><span class="s1">// params from the URL directly as route-matches may not</span><span class="s3">\n            </span><span class="s1">// contain the correct values due to the filesystem path</span><span class="s3">\n            </span><span class="s1">// matching before the dynamic route has been matched</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">!paramsResult.hasValidParams &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!isDynamicRoute(normalizedUrlPath)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">let matcherParams = utils.dynamicRouteMatcher?.(normalizedUrlPath)</span><span class="s3">\n\n              </span><span class="s1">if (matcherParams) {</span><span class="s3">\n                </span><span class="s1">utils.normalizeDynamicRouteParams(matcherParams, false)</span><span class="s3">\n                </span><span class="s1">Object.assign(paramsResult.params, matcherParams)</span><span class="s3">\n                </span><span class="s1">paramsResult.hasValidParams = true</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// if an action request is bypassing a prerender and we</span><span class="s3">\n            </span><span class="s1">// don't have the params in the URL since it was prerendered</span><span class="s3">\n            </span><span class="s1">// and matched during handle: 'filesystem' rather than dynamic route</span><span class="s3">\n            </span><span class="s1">// resolving we need to parse the params from the matched-path.</span><span class="s3">\n            </span><span class="s1">// Note: this is similar to above case but from match-path instead</span><span class="s3">\n            </span><span class="s1">// of from the request URL since a rewrite could cause that to not</span><span class="s3">\n            </span><span class="s1">// match the src pathname</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">// we can have a collision with /index and a top-level /[slug]</span><span class="s3">\n              </span><span class="s1">matchedPath !== '/index' &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!paramsResult.hasValidParams &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!isDynamicRoute(matchedPath)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">let matcherParams = utils.dynamicRouteMatcher?.(matchedPath)</span><span class="s3">\n\n              </span><span class="s1">if (matcherParams) {</span><span class="s3">\n                </span><span class="s1">const curParamsResult = utils.normalizeDynamicRouteParams(</span><span class="s3">\n                  </span><span class="s1">matcherParams,</span><span class="s3">\n                  </span><span class="s1">false</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">if (curParamsResult.hasValidParams) {</span><span class="s3">\n                  </span><span class="s1">Object.assign(params, matcherParams)</span><span class="s3">\n                  </span><span class="s1">paramsResult = curParamsResult</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (paramsResult.hasValidParams) {</span><span class="s3">\n              </span><span class="s1">params = paramsResult.params</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const routeMatchesHeader = req.headers['x-now-route-matches']</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">typeof routeMatchesHeader === 'string' &amp;&amp;</span><span class="s3">\n              </span><span class="s1">routeMatchesHeader &amp;&amp;</span><span class="s3">\n              </span><span class="s1">isDynamicRoute(matchedPath) &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!paramsResult.hasValidParams</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">const routeMatches =</span><span class="s3">\n                </span><span class="s1">utils.getParamsFromRouteMatches(routeMatchesHeader)</span><span class="s3">\n\n              </span><span class="s1">if (routeMatches) {</span><span class="s3">\n                </span><span class="s1">paramsResult = utils.normalizeDynamicRouteParams(</span><span class="s3">\n                  </span><span class="s1">routeMatches,</span><span class="s3">\n                  </span><span class="s1">true</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">if (paramsResult.hasValidParams) {</span><span class="s3">\n                  </span><span class="s1">params = paramsResult.params</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Try to parse the params from the query if we couldn't parse them</span><span class="s3">\n            </span><span class="s1">// from the route matches but ignore missing optional params.</span><span class="s3">\n            </span><span class="s1">if (!paramsResult.hasValidParams) {</span><span class="s3">\n              </span><span class="s1">paramsResult = utils.normalizeDynamicRouteParams(</span><span class="s3">\n                </span><span class="s1">queryParams,</span><span class="s3">\n                </span><span class="s1">true</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">if (paramsResult.hasValidParams) {</span><span class="s3">\n                </span><span class="s1">params = paramsResult.params</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// If the pathname being requested is the same as the source</span><span class="s3">\n            </span><span class="s1">// pathname, and we don't have valid params, we want to use the</span><span class="s3">\n            </span><span class="s1">// default route matches.</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">utils.defaultRouteMatches &amp;&amp;</span><span class="s3">\n              </span><span class="s1">normalizedUrlPath === srcPathname &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!paramsResult.hasValidParams</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">params = utils.defaultRouteMatches</span><span class="s3">\n\n              </span><span class="s1">// If the route matches header is an empty string, we want to</span><span class="s3">\n              </span><span class="s1">// render a fallback shell. This is because we know this came from</span><span class="s3">\n              </span><span class="s1">// a prerender (it has the header) but it's values were filtered</span><span class="s3">\n              </span><span class="s1">// out (because the allowQuery was empty). If it was undefined</span><span class="s3">\n              </span><span class="s1">// then we know that the request is hitting the lambda directly.</span><span class="s3">\n              </span><span class="s1">if (routeMatchesHeader === '') {</span><span class="s3">\n                </span><span class="s1">addRequestMeta(req, 'renderFallbackShell', true)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (params) {</span><span class="s3">\n              </span><span class="s1">matchedPath = utils.interpolateDynamicPath(srcPathname, params)</span><span class="s3">\n              </span><span class="s1">req.url = utils.interpolateDynamicPath(req.url!, params)</span><span class="s3">\n\n              </span><span class="s1">// If the request is for a segment prefetch, we need to update the</span><span class="s3">\n              </span><span class="s1">// segment prefetch request path to include the interpolated</span><span class="s3">\n              </span><span class="s1">// params.</span><span class="s3">\n              </span><span class="s1">let segmentPrefetchRSCRequest = getRequestMeta(</span><span class="s3">\n                </span><span class="s1">req,</span><span class="s3">\n                </span><span class="s1">'segmentPrefetchRSCRequest'</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">segmentPrefetchRSCRequest &amp;&amp;</span><span class="s3">\n                </span><span class="s1">isDynamicRoute(segmentPrefetchRSCRequest, false)</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">segmentPrefetchRSCRequest = utils.interpolateDynamicPath(</span><span class="s3">\n                  </span><span class="s1">segmentPrefetchRSCRequest,</span><span class="s3">\n                  </span><span class="s1">params</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] =</span><span class="s3">\n                  </span><span class="s1">segmentPrefetchRSCRequest</span><span class="s3">\n                </span><span class="s1">addRequestMeta(</span><span class="s3">\n                  </span><span class="s1">req,</span><span class="s3">\n                  </span><span class="s1">'segmentPrefetchRSCRequest',</span><span class="s3">\n                  </span><span class="s1">segmentPrefetchRSCRequest</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (pageIsDynamic || didRewrite) {</span><span class="s3">\n            </span><span class="s1">utils.normalizeCdnUrl(req, [</span><span class="s3">\n              </span><span class="s1">...rewriteParamKeys,</span><span class="s3">\n              </span><span class="s1">...Object.keys(utils.defaultRouteRegex?.groups || {}),</span><span class="s3">\n            </span><span class="s1">])</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Remove the route `params` keys from `parsedUrl.query` if they are</span><span class="s3">\n          </span><span class="s1">// not in the original query params.</span><span class="s3">\n          </span><span class="s1">// If it's used in both route `params` and query `searchParams`, it should be kept.</span><span class="s3">\n          </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n            </span><span class="s1">if (!(key in originQueryParams)) {</span><span class="s3">\n              </span><span class="s1">delete parsedUrl.query[key]</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">parsedUrl.pathname = matchedPath</span><span class="s3">\n          </span><span class="s1">url.pathname = parsedUrl.pathname</span><span class="s3">\n          </span><span class="s1">finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)</span><span class="s3">\n          </span><span class="s1">if (finished) return</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">if (err instanceof DecodeError || err instanceof NormalizeError) {</span><span class="s3">\n            </span><span class="s1">res.statusCode = 400</span><span class="s3">\n            </span><span class="s1">return this.renderError(null, req, res, '/_error', {})</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))</span><span class="s3">\n\n      </span><span class="s1">if (pathnameInfo.locale) {</span><span class="s3">\n        </span><span class="s1">req.url = formatUrl(url)</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'didStripLocale', true)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If we aren't in minimal mode or there is no locale in the query</span><span class="s3">\n      </span><span class="s1">// string, add the locale to the query string.</span><span class="s3">\n      </span><span class="s1">if (!this.minimalMode || !getRequestMeta(req, 'locale')) {</span><span class="s3">\n        </span><span class="s1">// If the locale is in the pathname, add it to the query string.</span><span class="s3">\n        </span><span class="s1">if (pathnameInfo.locale) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', pathnameInfo.locale)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If the default locale is available, add it to the query string and</span><span class="s3">\n        </span><span class="s1">// mark it as inferred rather than implicit.</span><span class="s3">\n        </span><span class="s1">else if (defaultLocale) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', defaultLocale)</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'localeInferredFromDefault', true)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// set incremental cache to request meta so it can</span><span class="s3">\n      </span><span class="s1">// be passed down for edge functions and the fetch disk</span><span class="s3">\n      </span><span class="s1">// cache can be leveraged locally</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!(this.serverOptions as any).webServerConfig &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!getRequestMeta(req, 'incrementalCache')</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const incrementalCache = await this.getIncrementalCache({</span><span class="s3">\n          </span><span class="s1">requestHeaders: Object.assign({}, req.headers),</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">incrementalCache.resetRequestCache()</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'incrementalCache', incrementalCache)</span><span class="s3">\n        </span><span class="s1">// This is needed for pages router to leverage unstable_cache</span><span class="s3">\n        </span><span class="s1">// TODO: re-work this handling to not use global and use a AsyncStore</span><span class="s3">\n        </span><span class="s1">;(globalThis as any).__incrementalCache = incrementalCache</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const cacheHandlers = getCacheHandlers()</span><span class="s3">\n\n      </span><span class="s1">if (cacheHandlers) {</span><span class="s3">\n        </span><span class="s1">await Promise.all(</span><span class="s3">\n          </span><span class="s1">[...cacheHandlers].map(async (cacheHandler) =&gt; {</span><span class="s3">\n            </span><span class="s1">if ('refreshTags' in cacheHandler) {</span><span class="s3">\n              </span><span class="s1">// Note: cacheHandler.refreshTags() is called lazily before the</span><span class="s3">\n              </span><span class="s1">// first cache entry is retrieved. It allows us to skip the</span><span class="s3">\n              </span><span class="s1">// refresh request if no caches are read at all.</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(</span><span class="s3">\n                </span><span class="s1">req.headers,</span><span class="s3">\n                </span><span class="s1">this.getPrerenderManifest().preview.previewModeId</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">await cacheHandler.receiveExpiredTags(</span><span class="s3">\n                </span><span class="s1">...previouslyRevalidatedTags</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// set server components HMR cache to request meta so it can be passed</span><span class="s3">\n      </span><span class="s1">// down for edge functions</span><span class="s3">\n      </span><span class="s1">if (!getRequestMeta(req, 'serverComponentsHmrCache')) {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">'serverComponentsHmrCache',</span><span class="s3">\n          </span><span class="s1">this.getServerComponentsHmrCache()</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// when invokePath is specified we can short short circuit resolving</span><span class="s3">\n      </span><span class="s1">// we only honor this header if we are inside of a render worker to</span><span class="s3">\n      </span><span class="s1">// prevent external users coercing the routing path</span><span class="s3">\n      </span><span class="s1">const invokePath = getRequestMeta(req, 'invokePath')</span><span class="s3">\n      </span><span class="s1">const useInvokePath = !useMatchedPathHeader &amp;&amp; invokePath</span><span class="s3">\n\n      </span><span class="s1">if (useInvokePath) {</span><span class="s3">\n        </span><span class="s1">const invokeStatus = getRequestMeta(req, 'invokeStatus')</span><span class="s3">\n        </span><span class="s1">if (invokeStatus) {</span><span class="s3">\n          </span><span class="s1">const invokeQuery = getRequestMeta(req, 'invokeQuery')</span><span class="s3">\n\n          </span><span class="s1">if (invokeQuery) {</span><span class="s3">\n            </span><span class="s1">Object.assign(parsedUrl.query, invokeQuery)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">res.statusCode = invokeStatus</span><span class="s3">\n          </span><span class="s1">let err: Error | null = getRequestMeta(req, 'invokeError') || null</span><span class="s3">\n\n          </span><span class="s1">return this.renderError(err, req, res, '/_error', parsedUrl.query)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const parsedMatchedPath = new URL(invokePath || '/', 'http://n')</span><span class="s3">\n        </span><span class="s1">const invokePathnameInfo = getNextPathnameInfo(</span><span class="s3">\n          </span><span class="s1">parsedMatchedPath.pathname,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">nextConfig: this.nextConfig,</span><span class="s3">\n            </span><span class="s1">parseData: false,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (invokePathnameInfo.locale) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', invokePathnameInfo.locale)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (parsedUrl.pathname !== parsedMatchedPath.pathname) {</span><span class="s3">\n          </span><span class="s1">parsedUrl.pathname = parsedMatchedPath.pathname</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'rewroteURL', invokePathnameInfo.pathname)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const normalizeResult = normalizeLocalePath(</span><span class="s3">\n          </span><span class="s1">removePathPrefix(parsedUrl.pathname, this.nextConfig.basePath || ''),</span><span class="s3">\n          </span><span class="s1">this.nextConfig.i18n?.locales</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (normalizeResult.detectedLocale) {</span><span class="s3">\n          </span><span class="s1">addRequestMeta(req, 'locale', normalizeResult.detectedLocale)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname = normalizeResult.pathname</span><span class="s3">\n\n        </span><span class="s1">for (const key of Object.keys(parsedUrl.query)) {</span><span class="s3">\n          </span><span class="s1">delete parsedUrl.query[key]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const invokeQuery = getRequestMeta(req, 'invokeQuery')</span><span class="s3">\n\n        </span><span class="s1">if (invokeQuery) {</span><span class="s3">\n          </span><span class="s1">Object.assign(parsedUrl.query, invokeQuery)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">if (finished) return</span><span class="s3">\n\n        </span><span class="s1">await this.handleCatchallRenderRequest(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (getRequestMeta(req, 'middlewareInvoke')) {</span><span class="s3">\n        </span><span class="s1">finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)</span><span class="s3">\n        </span><span class="s1">if (finished) return</span><span class="s3">\n\n        </span><span class="s1">finished = await this.handleCatchallMiddlewareRequest(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">res,</span><span class="s3">\n          </span><span class="s1">parsedUrl</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (finished) return</span><span class="s3">\n\n        </span><span class="s1">const err = new Error()</span><span class="s3">\n        </span><span class="s1">;(err as any).result = {</span><span class="s3">\n          </span><span class="s1">response: new Response(null, {</span><span class="s3">\n            </span><span class="s1">headers: {</span><span class="s3">\n              </span><span class="s1">'x-middleware-next': '1',</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">;(err as any).bubble = true</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// This wasn't a request via the matched path or the invoke path, so</span><span class="s3">\n      </span><span class="s1">// prepare for a legacy run by removing the base path.</span><span class="s3">\n\n      </span><span class="s1">// ensure we strip the basePath when not using an invoke header</span><span class="s3">\n      </span><span class="s1">if (!useMatchedPathHeader &amp;&amp; pathnameInfo.basePath) {</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname = removePathPrefix(</span><span class="s3">\n          </span><span class="s1">parsedUrl.pathname,</span><span class="s3">\n          </span><span class="s1">pathnameInfo.basePath</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">res.statusCode = 200</span><span class="s3">\n      </span><span class="s1">return await this.run(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">} catch (err: any) {</span><span class="s3">\n      </span><span class="s1">if (err instanceof NoFallbackError) {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(err &amp;&amp; typeof err === 'object' &amp;&amp; err.code === 'ERR_INVALID_URL') ||</span><span class="s3">\n        </span><span class="s1">err instanceof DecodeError ||</span><span class="s3">\n        </span><span class="s1">err instanceof NormalizeError</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">res.statusCode = 400</span><span class="s3">\n        </span><span class="s1">return this.renderError(null, req, res, '/_error', {})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">this.minimalMode ||</span><span class="s3">\n        </span><span class="s1">this.renderOpts.dev ||</span><span class="s3">\n        </span><span class="s1">(isBubbledError(err) &amp;&amp; err.bubble)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.logError(getProperError(err))</span><span class="s3">\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n      </span><span class="s1">res.body('Internal Server Error').send()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Normalizes a pathname without attaching any metadata from any matched</span><span class="s3">\n   </span><span class="s1">* normalizer.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname the pathname to normalize</span><span class="s3">\n   </span><span class="s1">* @returns the normalized pathname</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private normalize = (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const normalizers: Array&lt;PathnameNormalizer&gt; = []</span><span class="s3">\n\n    </span><span class="s1">if (this.normalizers.data) {</span><span class="s3">\n      </span><span class="s1">normalizers.push(this.normalizers.data)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We have to put the segment prefetch normalizer before the RSC normalizer</span><span class="s3">\n    </span><span class="s1">// because the RSC normalizer will match the prefetch RSC routes too.</span><span class="s3">\n    </span><span class="s1">if (this.normalizers.segmentPrefetchRSC) {</span><span class="s3">\n      </span><span class="s1">normalizers.push(this.normalizers.segmentPrefetchRSC)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We have to put the prefetch normalizer before the RSC normalizer</span><span class="s3">\n    </span><span class="s1">// because the RSC normalizer will match the prefetch RSC routes too.</span><span class="s3">\n    </span><span class="s1">if (this.normalizers.prefetchRSC) {</span><span class="s3">\n      </span><span class="s1">normalizers.push(this.normalizers.prefetchRSC)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.normalizers.rsc) {</span><span class="s3">\n      </span><span class="s1">normalizers.push(this.normalizers.rsc)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const normalizer of normalizers) {</span><span class="s3">\n      </span><span class="s1">if (!normalizer.match(pathname)) continue</span><span class="s3">\n\n      </span><span class="s1">return normalizer.normalize(pathname, true)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private normalizeAndAttachMetadata: RouteHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; = async (req, res, url) =&gt; {</span><span class="s3">\n    </span><span class="s1">let finished = await this.handleNextImageRequest(req, res, url)</span><span class="s3">\n    </span><span class="s1">if (finished) return true</span><span class="s3">\n\n    </span><span class="s1">if (this.enabledDirectories.pages) {</span><span class="s3">\n      </span><span class="s1">finished = await this.handleNextDataRequest(req, res, url)</span><span class="s3">\n      </span><span class="s1">if (finished) return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @internal - this method is internal to Next.js and should not be used directly by end-users</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public getRequestHandlerWithMetadata(</span><span class="s3">\n    </span><span class="s1">meta: RequestMeta</span><span class="s3">\n  </span><span class="s1">): BaseRequestHandler&lt;ServerRequest, ServerResponse&gt; {</span><span class="s3">\n    </span><span class="s1">const handler = this.getRequestHandler()</span><span class="s3">\n    </span><span class="s1">return (req, res, parsedUrl) =&gt; {</span><span class="s3">\n      </span><span class="s1">setRequestMeta(req, meta)</span><span class="s3">\n      </span><span class="s1">return handler(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getRequestHandler(): BaseRequestHandler&lt;</span><span class="s3">\n    </span><span class="s1">ServerRequest,</span><span class="s3">\n    </span><span class="s1">ServerResponse</span><span class="s3">\n  </span><span class="s1">&gt; {</span><span class="s3">\n    </span><span class="s1">return this.handleRequest.bind(this)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected abstract handleUpgrade(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">socket: any,</span><span class="s3">\n    </span><span class="s1">head?: any</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n\n  </span><span class="s1">public setAssetPrefix(prefix?: string): void {</span><span class="s3">\n    </span><span class="s1">this.nextConfig.assetPrefix = prefix ? prefix.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '') : ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected prepared: boolean = false</span><span class="s3">\n  </span><span class="s1">protected preparedPromise: Promise&lt;void&gt; | null = null</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Runs async initialization of server.</span><span class="s3">\n   </span><span class="s1">* It is idempotent, won't fire underlying initialization more than once.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async prepare(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.prepared) return</span><span class="s3">\n\n    </span><span class="s1">// Get instrumentation module</span><span class="s3">\n    </span><span class="s1">if (!this.instrumentation) {</span><span class="s3">\n      </span><span class="s1">this.instrumentation = await this.loadInstrumentationModule()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.preparedPromise === null) {</span><span class="s3">\n      </span><span class="s1">this.preparedPromise = this.prepareImpl().then(() =&gt; {</span><span class="s3">\n        </span><span class="s1">this.prepared = true</span><span class="s3">\n        </span><span class="s1">this.preparedPromise = null</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.preparedPromise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">protected async prepareImpl(): Promise&lt;void&gt; {}</span><span class="s3">\n  </span><span class="s1">protected async loadInstrumentationModule(): Promise&lt;any&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public async close(): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">protected getAppPathRoutes(): Record&lt;string, string[]&gt; {</span><span class="s3">\n    </span><span class="s1">const appPathRoutes: Record&lt;string, string[]&gt; = {}</span><span class="s3">\n\n    </span><span class="s1">Object.keys(this.appPathsManifest || {}).forEach((entry) =&gt; {</span><span class="s3">\n      </span><span class="s1">const normalizedPath = normalizeAppPath(entry)</span><span class="s3">\n      </span><span class="s1">if (!appPathRoutes[normalizedPath]) {</span><span class="s3">\n        </span><span class="s1">appPathRoutes[normalizedPath] = []</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">appPathRoutes[normalizedPath].push(entry)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return appPathRoutes</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async run(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.run, async () =&gt;</span><span class="s3">\n      </span><span class="s1">this.runImpl(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async runImpl(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">await this.handleCatchallRenderRequest(req, res, parsedUrl)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async pipe(</span><span class="s3">\n    </span><span class="s1">fn: (</span><span class="s3">\n      </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;ResponsePayload | null&gt;,</span><span class="s3">\n    </span><span class="s1">partialContext: Omit&lt;</span><span class="s3">\n      </span><span class="s1">RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n      </span><span class="s1">'renderOpts'</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.pipe, async () =&gt;</span><span class="s3">\n      </span><span class="s1">this.pipeImpl(fn, partialContext)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async pipeImpl(</span><span class="s3">\n    </span><span class="s1">fn: (</span><span class="s3">\n      </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;ResponsePayload | null&gt;,</span><span class="s3">\n    </span><span class="s1">partialContext: Omit&lt;</span><span class="s3">\n      </span><span class="s1">RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n      </span><span class="s1">'renderOpts'</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">const ua = partialContext.req.headers['user-agent'] || ''</span><span class="s3">\n\n    </span><span class="s1">const ctx: RequestContext&lt;ServerRequest, ServerResponse&gt; = {</span><span class="s3">\n      </span><span class="s1">...partialContext,</span><span class="s3">\n      </span><span class="s1">renderOpts: {</span><span class="s3">\n        </span><span class="s1">...this.renderOpts,</span><span class="s3">\n        </span><span class="s1">// `renderOpts.botType` is accumulated in `this.renderImpl()`</span><span class="s3">\n        </span><span class="s1">supportsDynamicResponse: !this.renderOpts.botType,</span><span class="s3">\n        </span><span class="s1">serveStreamingMetadata: shouldServeStreamingMetadata(</span><span class="s3">\n          </span><span class="s1">ua,</span><span class="s3">\n          </span><span class="s1">this.nextConfig.htmlLimitedBots</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const payload = await fn(ctx)</span><span class="s3">\n    </span><span class="s1">if (payload === null) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { req, res } = ctx</span><span class="s3">\n    </span><span class="s1">const originalStatus = res.statusCode</span><span class="s3">\n    </span><span class="s1">const { body } = payload</span><span class="s3">\n    </span><span class="s1">let { cacheControl } = payload</span><span class="s3">\n    </span><span class="s1">if (!res.sent) {</span><span class="s3">\n      </span><span class="s1">const { generateEtags, poweredByHeader, dev } = this.renderOpts</span><span class="s3">\n\n      </span><span class="s1">// In dev, we should not cache pages for any reason.</span><span class="s3">\n      </span><span class="s1">if (dev) {</span><span class="s3">\n        </span><span class="s1">res.setHeader('Cache-Control', 'no-store, must-revalidate')</span><span class="s3">\n        </span><span class="s1">cacheControl = undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheControl &amp;&amp; cacheControl.expire === undefined) {</span><span class="s3">\n        </span><span class="s1">cacheControl.expire = this.nextConfig.expireTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">await this.sendRenderResult(req, res, {</span><span class="s3">\n        </span><span class="s1">result: body,</span><span class="s3">\n        </span><span class="s1">generateEtags,</span><span class="s3">\n        </span><span class="s1">poweredByHeader,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">res.statusCode = originalStatus</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async getStaticHTML(</span><span class="s3">\n    </span><span class="s1">fn: (</span><span class="s3">\n      </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;ResponsePayload | null&gt;,</span><span class="s3">\n    </span><span class="s1">partialContext: Omit&lt;</span><span class="s3">\n      </span><span class="s1">RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n      </span><span class="s1">'renderOpts'</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">const ctx: RequestContext&lt;ServerRequest, ServerResponse&gt; = {</span><span class="s3">\n      </span><span class="s1">...partialContext,</span><span class="s3">\n      </span><span class="s1">renderOpts: {</span><span class="s3">\n        </span><span class="s1">...this.renderOpts,</span><span class="s3">\n        </span><span class="s1">supportsDynamicResponse: false,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const payload = await fn(ctx)</span><span class="s3">\n    </span><span class="s1">if (payload === null) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return payload.body.toUnchunkedString()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async render(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery = {},</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery,</span><span class="s3">\n    </span><span class="s1">internalRender = false</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.render, async () =&gt;</span><span class="s3">\n      </span><span class="s1">this.renderImpl(req, res, pathname, query, parsedUrl, internalRender)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getWaitUntil(): WaitUntil | undefined {</span><span class="s3">\n    </span><span class="s1">const builtinRequestContext = getBuiltinRequestContext()</span><span class="s3">\n    </span><span class="s1">if (builtinRequestContext) {</span><span class="s3">\n      </span><span class="s1">// the platform provided a request context.</span><span class="s3">\n      </span><span class="s1">// use the `waitUntil` from there, whether actually present or not --</span><span class="s3">\n      </span><span class="s1">// if not present, `after` will error.</span><span class="s3">\n\n      </span><span class="s1">// NOTE: if we're in an edge runtime sandbox, this context will be used to forward the outer waitUntil.</span><span class="s3">\n      </span><span class="s1">return builtinRequestContext.waitUntil</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.minimalMode) {</span><span class="s3">\n      </span><span class="s1">// we're built for a serverless environment, and `waitUntil` is not available,</span><span class="s3">\n      </span><span class="s1">// but using a noop would likely lead to incorrect behavior,</span><span class="s3">\n      </span><span class="s1">// because we have no way of keeping the invocation alive.</span><span class="s3">\n      </span><span class="s1">// return nothing, and `after` will error if used.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// NOTE: for edge functions, `NextWebServer` always runs in minimal mode.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// NOTE: if we're in an edge runtime sandbox, waitUntil will be passed in using </span><span class="s3">\&quot;</span><span class="s1">@next/request-context</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">// so we won't get here.</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.getInternalWaitUntil()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getInternalWaitUntil(): WaitUntil | undefined {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderImpl(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery = {},</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery,</span><span class="s3">\n    </span><span class="s1">internalRender = false</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (!pathname.startsWith('/')) {</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">`Cannot render page with path </span><span class="s3">\&quot;</span><span class="s1">${pathname}</span><span class="s3">\&quot;</span><span class="s1">, did you mean </span><span class="s3">\&quot;</span><span class="s1">/${pathname}</span><span class="s3">\&quot;</span><span class="s1">?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this.serverOptions.customServer &amp;&amp;</span><span class="s3">\n      </span><span class="s1">pathname === '/index' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!(await this.hasPage('/index'))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// maintain backwards compatibility for custom server</span><span class="s3">\n      </span><span class="s1">// (see custom-server integration tests)</span><span class="s3">\n      </span><span class="s1">pathname = '/'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const ua = req.headers['user-agent'] || ''</span><span class="s3">\n    </span><span class="s1">this.renderOpts.botType = getBotType(ua)</span><span class="s3">\n\n    </span><span class="s1">// we allow custom servers to call render for all URLs</span><span class="s3">\n    </span><span class="s1">// so check if we need to serve a static _next file or not.</span><span class="s3">\n    </span><span class="s1">// we don't modify the URL for _next/data request but still</span><span class="s3">\n    </span><span class="s1">// call render so we special case this to prevent an infinite loop</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!internalRender &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!getRequestMeta(req, 'isNextDataReq') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(req.url?.match(/^</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">//) ||</span><span class="s3">\n        </span><span class="s1">(this.hasStaticDir &amp;&amp; req.url!.match(/^</span><span class="s3">\\</span><span class="s1">/static</span><span class="s3">\\</span><span class="s1">//)))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return this.handleRequest(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isBlockedPage(pathname)) {</span><span class="s3">\n      </span><span class="s1">return this.render404(req, res, parsedUrl)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.pipe((ctx) =&gt; this.renderToResponse(ctx), {</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async getStaticPaths({</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">pathname: string</span><span class="s3">\n    </span><span class="s1">urlPathname: string</span><span class="s3">\n    </span><span class="s1">requestHeaders: import('./lib/incremental-cache').IncrementalCache['requestHeaders']</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">isAppPath: boolean</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;{</span><span class="s3">\n    </span><span class="s1">staticPaths?: string[]</span><span class="s3">\n    </span><span class="s1">prerenderedRoutes?: PrerenderedRoute[]</span><span class="s3">\n    </span><span class="s1">fallbackMode?: FallbackMode</span><span class="s3">\n  </span><span class="s1">}&gt; {</span><span class="s3">\n    </span><span class="s1">// Read whether or not fallback should exist from the manifest.</span><span class="s3">\n    </span><span class="s1">const fallbackField =</span><span class="s3">\n      </span><span class="s1">this.getPrerenderManifest().dynamicRoutes[pathname]?.fallback</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">// `staticPaths` is intentionally set to `undefined` as it should've</span><span class="s3">\n      </span><span class="s1">// been caught when checking disk data.</span><span class="s3">\n      </span><span class="s1">staticPaths: undefined,</span><span class="s3">\n      </span><span class="s1">fallbackMode: parseFallbackField(fallbackField),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderToResponseWithComponents(</span><span class="s3">\n    </span><span class="s1">requestContext: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">findComponentsResult: FindComponentsResult</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">BaseServerSpan.renderToResponseWithComponents,</span><span class="s3">\n      </span><span class="s1">async () =&gt;</span><span class="s3">\n        </span><span class="s1">this.renderToResponseWithComponentsImpl(</span><span class="s3">\n          </span><span class="s1">requestContext,</span><span class="s3">\n          </span><span class="s1">findComponentsResult</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected pathCouldBeIntercepted(resolvedPathname: string): boolean {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">isInterceptionRouteAppPath(resolvedPathname) ||</span><span class="s3">\n      </span><span class="s1">this.interceptionRoutePatterns.some((regexp) =&gt; {</span><span class="s3">\n        </span><span class="s1">return regexp.test(resolvedPathname)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected setVaryHeader(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">isAppPath: boolean,</span><span class="s3">\n    </span><span class="s1">resolvedPathname: string</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">const baseVaryHeader = `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE_HEADER}, ${NEXT_ROUTER_PREFETCH_HEADER}, ${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`</span><span class="s3">\n    </span><span class="s1">const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false</span><span class="s3">\n\n    </span><span class="s1">let addedNextUrlToVary = false</span><span class="s3">\n\n    </span><span class="s1">if (isAppPath &amp;&amp; this.pathCouldBeIntercepted(resolvedPathname)) {</span><span class="s3">\n      </span><span class="s1">// Interception route responses can vary based on the `Next-URL` header.</span><span class="s3">\n      </span><span class="s1">// We use the Vary header to signal this behavior to the client to properly cache the response.</span><span class="s3">\n      </span><span class="s1">res.appendHeader('vary', `${baseVaryHeader}, ${NEXT_URL}`)</span><span class="s3">\n      </span><span class="s1">addedNextUrlToVary = true</span><span class="s3">\n    </span><span class="s1">} else if (isAppPath || isRSCRequest) {</span><span class="s3">\n      </span><span class="s1">// We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.</span><span class="s3">\n      </span><span class="s1">// We also set this header for pages to avoid caching issues when navigating between pages and app.</span><span class="s3">\n      </span><span class="s1">res.appendHeader('vary', baseVaryHeader)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!addedNextUrlToVary) {</span><span class="s3">\n      </span><span class="s1">// Remove `Next-URL` from the request headers we determined it wasn't necessary to include in the Vary header.</span><span class="s3">\n      </span><span class="s1">// This is to avoid any dependency on the `Next-URL` header being present when preparing the response.</span><span class="s3">\n      </span><span class="s1">delete req.headers[NEXT_URL]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderToResponseWithComponentsImpl(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">renderOpts: opts,</span><span class="s3">\n    </span><span class="s1">}: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">{ components, query }: FindComponentsResult</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {</span><span class="s3">\n      </span><span class="s1">pathname = '/404'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const isErrorPathname = pathname === '/_error'</span><span class="s3">\n    </span><span class="s1">const is404Page =</span><span class="s3">\n      </span><span class="s1">pathname === '/404' || (isErrorPathname &amp;&amp; res.statusCode === 404)</span><span class="s3">\n    </span><span class="s1">const is500Page =</span><span class="s3">\n      </span><span class="s1">pathname === '/500' || (isErrorPathname &amp;&amp; res.statusCode === 500)</span><span class="s3">\n    </span><span class="s1">const isAppPath = components.isAppPath === true</span><span class="s3">\n\n    </span><span class="s1">const hasServerProps = !!components.getServerSideProps</span><span class="s3">\n    </span><span class="s1">const isPossibleServerAction = getIsPossibleServerAction(req)</span><span class="s3">\n    </span><span class="s1">let isSSG = !!components.getStaticProps</span><span class="s3">\n    </span><span class="s1">// NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later</span><span class="s3">\n    </span><span class="s1">const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false</span><span class="s3">\n\n    </span><span class="s1">// Not all CDNs respect the Vary header when caching. We must assume that</span><span class="s3">\n    </span><span class="s1">// only the URL is used to vary the responses. The Next client computes a</span><span class="s3">\n    </span><span class="s1">// hash of the header values and sends it as a search param. Before</span><span class="s3">\n    </span><span class="s1">// responding to a request, we must verify that the hash matches the</span><span class="s3">\n    </span><span class="s1">// expected value. Neglecting to do this properly can lead to cache</span><span class="s3">\n    </span><span class="s1">// poisoning attacks on certain CDNs.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.nextConfig.experimental.validateRSCRequestHeaders &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isRSCRequest</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const headers = req.headers</span><span class="s3">\n\n      </span><span class="s1">const prefetchHeaderValue = headers[NEXT_ROUTER_PREFETCH_HEADER]</span><span class="s3">\n      </span><span class="s1">const routerPrefetch =</span><span class="s3">\n        </span><span class="s1">prefetchHeaderValue !== undefined</span><span class="s3">\n          </span><span class="s1">? // We only recognize '1' and '2'. Strip all other values here.</span><span class="s3">\n            </span><span class="s1">prefetchHeaderValue === '1' || prefetchHeaderValue === '2'</span><span class="s3">\n            </span><span class="s1">? prefetchHeaderValue</span><span class="s3">\n            </span><span class="s1">: undefined</span><span class="s3">\n          </span><span class="s1">: // For runtime prefetches, we always perform a dynamic request,</span><span class="s3">\n            </span><span class="s1">// so we don't expect the header to be stripped by an intermediate layer.</span><span class="s3">\n            </span><span class="s1">// This should only happen for static prefetches, so we only handle those here.</span><span class="s3">\n            </span><span class="s1">getRequestMeta(req, 'isPrefetchRSCRequest')</span><span class="s3">\n            </span><span class="s1">? '1'</span><span class="s3">\n            </span><span class="s1">: undefined</span><span class="s3">\n\n      </span><span class="s1">const segmentPrefetchRSCRequest =</span><span class="s3">\n        </span><span class="s1">headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] ||</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'segmentPrefetchRSCRequest')</span><span class="s3">\n\n      </span><span class="s1">const expectedHash = computeCacheBustingSearchParam(</span><span class="s3">\n        </span><span class="s1">routerPrefetch,</span><span class="s3">\n        </span><span class="s1">segmentPrefetchRSCRequest,</span><span class="s3">\n        </span><span class="s1">headers[NEXT_ROUTER_STATE_TREE_HEADER],</span><span class="s3">\n        </span><span class="s1">headers[NEXT_URL]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const actualHash =</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'cacheBustingSearchParam') ??</span><span class="s3">\n        </span><span class="s1">new URL(req.url || '', 'http://localhost').searchParams.get(</span><span class="s3">\n          </span><span class="s1">NEXT_RSC_UNION_QUERY</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (expectedHash !== actualHash) {</span><span class="s3">\n        </span><span class="s1">// The hash sent by the client does not match the expected value.</span><span class="s3">\n        </span><span class="s1">// Redirect to the URL with the correct cache-busting search param.</span><span class="s3">\n        </span><span class="s1">// This prevents cache poisoning attacks on CDNs that don't respect Vary headers.</span><span class="s3">\n        </span><span class="s1">// Note: When no headers are present, expectedHash is empty string and client</span><span class="s3">\n        </span><span class="s1">// must send `_rsc` param, otherwise actualHash is null and hash check fails.</span><span class="s3">\n        </span><span class="s1">const url = new URL(req.url || '', 'http://localhost')</span><span class="s3">\n        </span><span class="s1">setCacheBustingSearchParamWithHash(url, expectedHash)</span><span class="s3">\n        </span><span class="s1">res.statusCode = 307</span><span class="s3">\n        </span><span class="s1">res.setHeader('location', `${url.pathname}${url.search}`)</span><span class="s3">\n        </span><span class="s1">res.body('').send()</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Compute the iSSG cache key. We use the rewroteUrl since</span><span class="s3">\n    </span><span class="s1">// pages with fallback: false are allowed to be rewritten to</span><span class="s3">\n    </span><span class="s1">// and we need to look up the path by the rewritten path</span><span class="s3">\n    </span><span class="s1">let urlPathname = parseUrl(req.url || '').pathname || '/'</span><span class="s3">\n\n    </span><span class="s1">let resolvedUrlPathname = getRequestMeta(req, 'rewroteURL') || urlPathname</span><span class="s3">\n\n    </span><span class="s1">this.setVaryHeader(req, res, isAppPath, resolvedUrlPathname)</span><span class="s3">\n\n    </span><span class="s1">let staticPaths: string[] | undefined</span><span class="s3">\n    </span><span class="s1">let hasFallback = false</span><span class="s3">\n\n    </span><span class="s1">const prerenderManifest = this.getPrerenderManifest()</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">hasFallback ||</span><span class="s3">\n      </span><span class="s1">staticPaths?.includes(resolvedUrlPathname) ||</span><span class="s3">\n      </span><span class="s1">// this signals revalidation in deploy environments</span><span class="s3">\n      </span><span class="s1">// TODO: make this more generic</span><span class="s3">\n      </span><span class="s1">req.headers['x-now-route-matches']</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">isSSG = true</span><span class="s3">\n    </span><span class="s1">} else if (!this.renderOpts.dev) {</span><span class="s3">\n      </span><span class="s1">isSSG ||= !!prerenderManifest.routes[toRoute(pathname)]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Toggle whether or not this is a Data request</span><span class="s3">\n    </span><span class="s1">const isNextDataRequest =</span><span class="s3">\n      </span><span class="s1">!!(</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'isNextDataReq') ||</span><span class="s3">\n        </span><span class="s1">(req.headers['x-nextjs-data'] &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(this.serverOptions as any).webServerConfig)</span><span class="s3">\n      </span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(isSSG || hasServerProps)</span><span class="s3">\n\n    </span><span class="s1">// when we are handling a middleware prefetch and it doesn't</span><span class="s3">\n    </span><span class="s1">// resolve to a static data route we bail early to avoid</span><span class="s3">\n    </span><span class="s1">// unexpected SSR invocations</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!isSSG &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.headers['x-middleware-prefetch'] &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!(is404Page || pathname === '/_error')</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">res.setHeader(MATCHED_PATH_HEADER, pathname)</span><span class="s3">\n      </span><span class="s1">res.setHeader('x-middleware-skip', '1')</span><span class="s3">\n      </span><span class="s1">res.setHeader(</span><span class="s3">\n        </span><span class="s1">'cache-control',</span><span class="s3">\n        </span><span class="s1">'private, no-cache, no-store, max-age=0, must-revalidate'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">res.body('{}').send()</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// normalize req.url for SSG paths as it is not exposed</span><span class="s3">\n    </span><span class="s1">// to getStaticProps and the asPath should not expose /_next/data</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isSSG &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.headers[MATCHED_PATH_HEADER] &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.url.startsWith('/_next/data')</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">req.url = this.stripNextDataPath(req.url)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const locale = getRequestMeta(req, 'locale')</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!!req.headers['x-nextjs-data'] &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!res.statusCode || res.statusCode === 200)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">res.setHeader(</span><span class="s3">\n        </span><span class="s1">'x-nextjs-matched-path',</span><span class="s3">\n        </span><span class="s1">`${locale ? `/${locale}` : ''}${pathname}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let routeModule: RouteModule | undefined</span><span class="s3">\n    </span><span class="s1">if (components.routeModule) {</span><span class="s3">\n      </span><span class="s1">routeModule = components.routeModule</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If the route being rendered is an app page, and the ppr feature has been</span><span class="s3">\n     </span><span class="s1">* enabled, then the given route _could_ support PPR.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const couldSupportPPR: boolean =</span><span class="s3">\n      </span><span class="s1">this.isAppPPREnabled &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof routeModule !== 'undefined' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isAppPageRouteModule(routeModule)</span><span class="s3">\n\n    </span><span class="s1">// When enabled, this will allow the use of the `?__nextppronly` query to</span><span class="s3">\n    </span><span class="s1">// enable debugging of the static shell.</span><span class="s3">\n    </span><span class="s1">const hasDebugStaticShellQuery =</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof query.__nextppronly !== 'undefined' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">couldSupportPPR</span><span class="s3">\n\n    </span><span class="s1">// This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the</span><span class="s3">\n    </span><span class="s1">// prerender manifest and this is an app page.</span><span class="s3">\n    </span><span class="s1">const isRoutePPREnabled: boolean =</span><span class="s3">\n      </span><span class="s1">couldSupportPPR &amp;&amp;</span><span class="s3">\n      </span><span class="s1">((</span><span class="s3">\n        </span><span class="s1">prerenderManifest.routes[pathname] ??</span><span class="s3">\n        </span><span class="s1">prerenderManifest.dynamicRoutes[pathname]</span><span class="s3">\n      </span><span class="s1">)?.renderingMode === 'PARTIALLY_STATIC' ||</span><span class="s3">\n        </span><span class="s1">// Ideally we'd want to check the appConfig to see if this page has PPR</span><span class="s3">\n        </span><span class="s1">// enabled or not, but that would require plumbing the appConfig through</span><span class="s3">\n        </span><span class="s1">// to the server during development. We assume that the page supports it</span><span class="s3">\n        </span><span class="s1">// but only during development.</span><span class="s3">\n        </span><span class="s1">(hasDebugStaticShellQuery &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(this.renderOpts.dev === true ||</span><span class="s3">\n            </span><span class="s1">this.experimentalTestProxy === true)))</span><span class="s3">\n\n    </span><span class="s1">// If we're in minimal mode, then try to get the postponed information from</span><span class="s3">\n    </span><span class="s1">// the request metadata. If available, use it for resuming the postponed</span><span class="s3">\n    </span><span class="s1">// render.</span><span class="s3">\n    </span><span class="s1">const minimalPostponed = isRoutePPREnabled</span><span class="s3">\n      </span><span class="s1">? getRequestMeta(req, 'postponed')</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">// we need to ensure the status code if /404 is visited directly</span><span class="s3">\n    </span><span class="s1">if (is404Page &amp;&amp; !isNextDataRequest &amp;&amp; !isRSCRequest) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = 404</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// ensure correct status is set when visiting a status page</span><span class="s3">\n    </span><span class="s1">// directly e.g. /500</span><span class="s3">\n    </span><span class="s1">if (STATIC_STATUS_PAGES.includes(pathname)) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = parseInt(pathname.slice(1), 10)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// Server actions can use non-GET/HEAD methods.</span><span class="s3">\n      </span><span class="s1">!isPossibleServerAction &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Resume can use non-GET/HEAD methods.</span><span class="s3">\n      </span><span class="s1">!minimalPostponed &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!is404Page &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!is500Page &amp;&amp;</span><span class="s3">\n      </span><span class="s1">pathname !== '/_error' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.method !== 'HEAD' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.method !== 'GET' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(typeof components.Component === 'string' || isSSG)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = 405</span><span class="s3">\n      </span><span class="s1">res.setHeader('Allow', ['GET', 'HEAD'])</span><span class="s3">\n      </span><span class="s1">res.body('Method Not Allowed').send()</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// handle static page</span><span class="s3">\n    </span><span class="s1">if (typeof components.Component === 'string') {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">body: RenderResult.fromStatic(</span><span class="s3">\n          </span><span class="s1">components.Component,</span><span class="s3">\n          </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Ensure that if the `amp` query parameter is falsy that we remove it from</span><span class="s3">\n    </span><span class="s1">// the query object. This ensures it won't be found by the `in` operator.</span><span class="s3">\n    </span><span class="s1">if ('amp' in query &amp;&amp; !query.amp) delete query.amp</span><span class="s3">\n\n    </span><span class="s1">if (opts.supportsDynamicResponse === true) {</span><span class="s3">\n      </span><span class="s1">const ua = req.headers['user-agent'] || ''</span><span class="s3">\n      </span><span class="s1">const isBotRequest = isBot(ua)</span><span class="s3">\n      </span><span class="s1">const isSupportedDocument =</span><span class="s3">\n        </span><span class="s1">typeof components.Document?.getInitialProps !== 'function' ||</span><span class="s3">\n        </span><span class="s1">// The built-in `Document` component also supports dynamic HTML for concurrent mode.</span><span class="s3">\n        </span><span class="s1">NEXT_BUILTIN_DOCUMENT in components.Document</span><span class="s3">\n\n      </span><span class="s1">// Disable dynamic HTML in cases that we know it won't be generated,</span><span class="s3">\n      </span><span class="s1">// so that we can continue generating a cache key when possible.</span><span class="s3">\n      </span><span class="s1">// TODO-APP: should the first render for a dynamic app path</span><span class="s3">\n      </span><span class="s1">// be static so we can collect revalidate and populate the</span><span class="s3">\n      </span><span class="s1">// cache if there are no dynamic data requirements</span><span class="s3">\n      </span><span class="s1">opts.supportsDynamicResponse =</span><span class="s3">\n        </span><span class="s1">!isSSG &amp;&amp; !isBotRequest &amp;&amp; !query.amp &amp;&amp; isSupportedDocument</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// In development, we always want to generate dynamic HTML.</span><span class="s3">\n    </span><span class="s1">if (!isNextDataRequest &amp;&amp; isAppPath &amp;&amp; opts.dev) {</span><span class="s3">\n      </span><span class="s1">opts.supportsDynamicResponse = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isSSG &amp;&amp; this.minimalMode &amp;&amp; req.headers[MATCHED_PATH_HEADER]) {</span><span class="s3">\n      </span><span class="s1">// the url value is already correct when the matched-path header is set</span><span class="s3">\n      </span><span class="s1">resolvedUrlPathname = urlPathname</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">urlPathname = removeTrailingSlash(urlPathname)</span><span class="s3">\n    </span><span class="s1">resolvedUrlPathname = removeTrailingSlash(resolvedUrlPathname)</span><span class="s3">\n    </span><span class="s1">if (this.localeNormalizer) {</span><span class="s3">\n      </span><span class="s1">resolvedUrlPathname = this.localeNormalizer.normalize(resolvedUrlPathname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// remove /_next/data prefix from urlPathname so it matches</span><span class="s3">\n    </span><span class="s1">// for direct page visit and /_next/data visit</span><span class="s3">\n    </span><span class="s1">if (isNextDataRequest) {</span><span class="s3">\n      </span><span class="s1">resolvedUrlPathname = this.stripNextDataPath(resolvedUrlPathname)</span><span class="s3">\n      </span><span class="s1">urlPathname = this.stripNextDataPath(urlPathname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// use existing incrementalCache instance if available</span><span class="s3">\n    </span><span class="s1">const incrementalCache: import('./lib/incremental-cache').IncrementalCache =</span><span class="s3">\n      </span><span class="s1">await this.getIncrementalCache({</span><span class="s3">\n        </span><span class="s1">requestHeaders: Object.assign({}, req.headers),</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// TODO: investigate, this is not safe across multiple concurrent requests</span><span class="s3">\n    </span><span class="s1">incrementalCache.resetRequestCache()</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">routeModule?.isDev &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isDynamicRoute(pathname) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(components.getStaticPaths || isAppPath)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const pathsResults = await this.getStaticPaths({</span><span class="s3">\n        </span><span class="s1">pathname,</span><span class="s3">\n        </span><span class="s1">urlPathname,</span><span class="s3">\n        </span><span class="s1">requestHeaders: req.headers,</span><span class="s3">\n        </span><span class="s1">page: components.page,</span><span class="s3">\n        </span><span class="s1">isAppPath,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">if (isAppPath &amp;&amp; this.nextConfig.experimental.cacheComponents) {</span><span class="s3">\n        </span><span class="s1">if (pathsResults.prerenderedRoutes?.length) {</span><span class="s3">\n          </span><span class="s1">let smallestFallbackRouteParams = null</span><span class="s3">\n          </span><span class="s1">for (const route of pathsResults.prerenderedRoutes) {</span><span class="s3">\n            </span><span class="s1">const fallbackRouteParams = route.fallbackRouteParams</span><span class="s3">\n            </span><span class="s1">if (!fallbackRouteParams || fallbackRouteParams.length === 0) {</span><span class="s3">\n              </span><span class="s1">// There are no fallback route params so we don't need to continue</span><span class="s3">\n              </span><span class="s1">smallestFallbackRouteParams = null</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">smallestFallbackRouteParams === null ||</span><span class="s3">\n              </span><span class="s1">fallbackRouteParams.length &lt; smallestFallbackRouteParams.length</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">smallestFallbackRouteParams = fallbackRouteParams</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (smallestFallbackRouteParams) {</span><span class="s3">\n            </span><span class="s1">const devValidatingFallbackParams = new Map&lt;string, string&gt;(</span><span class="s3">\n              </span><span class="s1">smallestFallbackRouteParams.map((v) =&gt; [v, ''])</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">addRequestMeta(</span><span class="s3">\n              </span><span class="s1">req,</span><span class="s3">\n              </span><span class="s1">'devValidatingFallbackParams',</span><span class="s3">\n              </span><span class="s1">devValidatingFallbackParams</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// An OPTIONS request to a page handler is invalid.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">req.method === 'OPTIONS' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!is404Page &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!routeModule || !isAppRouteRouteModule(routeModule))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">await sendResponse(req, res, new Response(null, { status: 400 }))</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const request = isNodeNextRequest(req) ? req.originalRequest : req</span><span class="s3">\n    </span><span class="s1">const response = isNodeNextResponse(res) ? res.originalResponse : res</span><span class="s3">\n\n    </span><span class="s1">const parsedInitUrl = parseUrl(getRequestMeta(req, 'initURL') || req.url)</span><span class="s3">\n    </span><span class="s1">let initPathname = parsedInitUrl.pathname || '/'</span><span class="s3">\n\n    </span><span class="s1">for (const normalizer of [</span><span class="s3">\n      </span><span class="s1">this.normalizers.segmentPrefetchRSC,</span><span class="s3">\n      </span><span class="s1">this.normalizers.prefetchRSC,</span><span class="s3">\n      </span><span class="s1">this.normalizers.rsc,</span><span class="s3">\n    </span><span class="s1">]) {</span><span class="s3">\n      </span><span class="s1">if (normalizer?.match(initPathname)) {</span><span class="s3">\n        </span><span class="s1">initPathname = normalizer.normalize(initPathname)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// On minimal mode, the request url of dynamic route can be a</span><span class="s3">\n    </span><span class="s1">// literal dynamic route ('/[slug]') instead of actual URL, so overwriting to initPathname</span><span class="s3">\n    </span><span class="s1">// will transform back the resolved url to the dynamic route pathname.</span><span class="s3">\n    </span><span class="s1">if (!(this.minimalMode &amp;&amp; isErrorPathname)) {</span><span class="s3">\n      </span><span class="s1">request.url = `${initPathname}${parsedInitUrl.search || ''}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// propagate the request context for dev</span><span class="s3">\n    </span><span class="s1">setRequestMeta(request, getRequestMeta(req))</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'distDir', this.distDir)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'query', query)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'params', opts.params)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'ampValidator', this.renderOpts.ampValidator)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(request, 'minimalMode', this.minimalMode)</span><span class="s3">\n\n    </span><span class="s1">if (opts.err) {</span><span class="s3">\n      </span><span class="s1">addRequestMeta(request, 'invokeError', opts.err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const handler: (</span><span class="s3">\n      </span><span class="s1">req: ServerRequest | IncomingMessage,</span><span class="s3">\n      </span><span class="s1">res: ServerResponse | HTTPServerResponse,</span><span class="s3">\n      </span><span class="s1">ctx: {</span><span class="s3">\n        </span><span class="s1">waitUntil: ReturnType&lt;Server['getWaitUntil']&gt;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;void&gt; = components.ComponentMod.handler</span><span class="s3">\n\n    </span><span class="s1">const maybeDevRequest =</span><span class="s3">\n      </span><span class="s1">// we need to capture fetch metrics when they are set</span><span class="s3">\n      </span><span class="s1">// and can't wait for handler to resolve as the fetch</span><span class="s3">\n      </span><span class="s1">// metrics are logged on response close which happens</span><span class="s3">\n      </span><span class="s1">// before handler resolves</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV === 'development'</span><span class="s3">\n        </span><span class="s1">? new Proxy(request, {</span><span class="s3">\n            </span><span class="s1">get(target: any, prop) {</span><span class="s3">\n              </span><span class="s1">if (typeof target[prop] === 'function') {</span><span class="s3">\n                </span><span class="s1">return target[prop].bind(target)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">return target[prop]</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">set(target: any, prop, value) {</span><span class="s3">\n              </span><span class="s1">if (prop === 'fetchMetrics') {</span><span class="s3">\n                </span><span class="s1">;(req as any).fetchMetrics = value</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">target[prop] = value</span><span class="s3">\n              </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">: request</span><span class="s3">\n\n    </span><span class="s1">await handler(maybeDevRequest, response, {</span><span class="s3">\n      </span><span class="s1">waitUntil: this.getWaitUntil(),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// response is handled fully in handler</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private stripNextDataPath(path: string, stripLocale = true) {</span><span class="s3">\n    </span><span class="s1">if (path.includes(this.buildId)) {</span><span class="s3">\n      </span><span class="s1">const splitPath = path.substring(</span><span class="s3">\n        </span><span class="s1">path.indexOf(this.buildId) + this.buildId.length</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">path = denormalizePagePath(splitPath.replace(/</span><span class="s3">\\</span><span class="s1">.json$/, ''))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.localeNormalizer &amp;&amp; stripLocale) {</span><span class="s3">\n      </span><span class="s1">return this.localeNormalizer.normalize(path)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// map the route to the actual bundle name</span><span class="s3">\n  </span><span class="s1">protected getOriginalAppPaths(route: string) {</span><span class="s3">\n    </span><span class="s1">if (this.enabledDirectories.app) {</span><span class="s3">\n      </span><span class="s1">const originalAppPath = this.appPathRoutes?.[route]</span><span class="s3">\n\n      </span><span class="s1">if (!originalAppPath) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return originalAppPath</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async renderPageComponent(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">bubbleNoFallback: boolean</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { query, pathname } = ctx</span><span class="s3">\n\n    </span><span class="s1">const appPaths = this.getOriginalAppPaths(pathname)</span><span class="s3">\n    </span><span class="s1">const isAppPath = Array.isArray(appPaths)</span><span class="s3">\n\n    </span><span class="s1">let page = pathname</span><span class="s3">\n    </span><span class="s1">if (isAppPath) {</span><span class="s3">\n      </span><span class="s1">// the last item in the array is the root page, if there are parallel routes</span><span class="s3">\n      </span><span class="s1">page = appPaths[appPaths.length - 1]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const result = await this.findPageComponents({</span><span class="s3">\n      </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n      </span><span class="s1">page,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n      </span><span class="s1">params: ctx.renderOpts.params || {},</span><span class="s3">\n      </span><span class="s1">isAppPath,</span><span class="s3">\n      </span><span class="s1">sriEnabled: !!this.nextConfig.experimental.sri?.algorithm,</span><span class="s3">\n      </span><span class="s1">appPaths,</span><span class="s3">\n      </span><span class="s1">// Ensuring for loading page component routes is done via the matcher.</span><span class="s3">\n      </span><span class="s1">shouldEnsure: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">if (result) {</span><span class="s3">\n      </span><span class="s1">getTracer().setRootSpanAttribute('next.route', pathname)</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return await this.renderToResponseWithComponents(ctx, result)</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">const isNoFallbackError = err instanceof NoFallbackError</span><span class="s3">\n\n        </span><span class="s1">if (!isNoFallbackError || (isNoFallbackError &amp;&amp; bubbleNoFallback)) {</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderToResponse(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">BaseServerSpan.renderToResponse,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">spanName: `rendering page`,</span><span class="s3">\n        </span><span class="s1">attributes: {</span><span class="s3">\n          </span><span class="s1">'next.route': ctx.pathname,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">async () =&gt; {</span><span class="s3">\n        </span><span class="s1">return this.renderToResponseImpl(ctx)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected abstract getMiddleware(): Promise&lt;MiddlewareRoutingItem | undefined&gt;</span><span class="s3">\n  </span><span class="s1">protected abstract getFallbackErrorComponents(</span><span class="s3">\n    </span><span class="s1">url?: string</span><span class="s3">\n  </span><span class="s1">): Promise&lt;LoadComponentsReturnType | null&gt;</span><span class="s3">\n  </span><span class="s1">protected abstract getRoutesManifest(): NormalizedRouteManifest | undefined</span><span class="s3">\n\n  </span><span class="s1">private async renderToResponseImpl(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">const { req, res, query, pathname } = ctx</span><span class="s3">\n    </span><span class="s1">let page = pathname</span><span class="s3">\n    </span><span class="s1">const bubbleNoFallback =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(ctx.req, 'bubbleNoFallback') ?? false</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.nextConfig.experimental.validateRSCRequestHeaders</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">addRequestMeta(</span><span class="s3">\n        </span><span class="s1">ctx.req,</span><span class="s3">\n        </span><span class="s1">'cacheBustingSearchParam',</span><span class="s3">\n        </span><span class="s1">query[NEXT_RSC_UNION_QUERY]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">delete query[NEXT_RSC_UNION_QUERY]</span><span class="s3">\n\n    </span><span class="s1">const options: MatchOptions = {</span><span class="s3">\n      </span><span class="s1">i18n: this.i18nProvider?.fromRequest(req, pathname),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">for await (const match of this.matchers.matchAll(pathname, options)) {</span><span class="s3">\n        </span><span class="s1">// when a specific invoke-output is meant to be matched</span><span class="s3">\n        </span><span class="s1">// ensure a prior dynamic route/page doesn't take priority</span><span class="s3">\n        </span><span class="s1">const invokeOutput = getRequestMeta(ctx.req, 'invokeOutput')</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!this.minimalMode &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof invokeOutput === 'string' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">isDynamicRoute(invokeOutput || '') &amp;&amp;</span><span class="s3">\n          </span><span class="s1">invokeOutput !== match.definition.pathname</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const result = await this.renderPageComponent(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">...ctx,</span><span class="s3">\n            </span><span class="s1">pathname: match.definition.pathname,</span><span class="s3">\n            </span><span class="s1">renderOpts: {</span><span class="s3">\n              </span><span class="s1">...ctx.renderOpts,</span><span class="s3">\n              </span><span class="s1">params: match.params,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">bubbleNoFallback</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (result !== false) return result</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// currently edge functions aren't receiving the x-matched-path</span><span class="s3">\n      </span><span class="s1">// header so we need to fallback to matching the current page</span><span class="s3">\n      </span><span class="s1">// when we weren't able to match via dynamic route to handle</span><span class="s3">\n      </span><span class="s1">// the rewrite case</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error extended in child class web-server</span><span class="s3">\n      </span><span class="s1">if (this.serverOptions.webServerConfig) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error extended in child class web-server</span><span class="s3">\n        </span><span class="s1">ctx.pathname = this.serverOptions.webServerConfig.page</span><span class="s3">\n        </span><span class="s1">const result = await this.renderPageComponent(ctx, bubbleNoFallback)</span><span class="s3">\n        </span><span class="s1">if (result !== false) return result</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (error) {</span><span class="s3">\n      </span><span class="s1">const err = getProperError(error)</span><span class="s3">\n\n      </span><span class="s1">if (error instanceof MissingStaticPage) {</span><span class="s3">\n        </span><span class="s1">console.error(</span><span class="s3">\n          </span><span class="s1">'Invariant: failed to load static page',</span><span class="s3">\n          </span><span class="s1">JSON.stringify(</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">page,</span><span class="s3">\n              </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n              </span><span class="s1">matchedPath: ctx.req.headers[MATCHED_PATH_HEADER],</span><span class="s3">\n              </span><span class="s1">initUrl: getRequestMeta(ctx.req, 'initURL'),</span><span class="s3">\n              </span><span class="s1">didRewrite: !!getRequestMeta(ctx.req, 'rewroteURL'),</span><span class="s3">\n              </span><span class="s1">rewroteUrl: getRequestMeta(ctx.req, 'rewroteURL'),</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">null,</span><span class="s3">\n            </span><span class="s1">2</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (err instanceof NoFallbackError &amp;&amp; bubbleNoFallback) {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (err instanceof DecodeError || err instanceof NormalizeError) {</span><span class="s3">\n        </span><span class="s1">res.statusCode = 400</span><span class="s3">\n        </span><span class="s1">return await this.renderErrorToResponse(ctx, err)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n\n      </span><span class="s1">// if pages/500 is present we still need to trigger</span><span class="s3">\n      </span><span class="s1">// /_error `getInitialProps` to allow reporting error</span><span class="s3">\n      </span><span class="s1">if (await this.hasPage('/500')) {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(ctx.req, 'customErrorRender', true)</span><span class="s3">\n        </span><span class="s1">await this.renderErrorToResponse(ctx, err)</span><span class="s3">\n        </span><span class="s1">removeRequestMeta(ctx.req, 'customErrorRender')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const isWrappedError = err instanceof WrappedBuildError</span><span class="s3">\n\n      </span><span class="s1">if (!isWrappedError) {</span><span class="s3">\n        </span><span class="s1">if (this.minimalMode || this.renderOpts.dev) {</span><span class="s3">\n          </span><span class="s1">if (isError(err)) err.page = page</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.logError(getProperError(err))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const response = await this.renderErrorToResponse(</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">isWrappedError ? (err as WrappedBuildError).innerError : err</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return response</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const middleware = await this.getMiddleware()</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">middleware &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!!ctx.req.headers['x-nextjs-data'] &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!res.statusCode || res.statusCode === 200 || res.statusCode === 404)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const locale = getRequestMeta(req, 'locale')</span><span class="s3">\n\n      </span><span class="s1">res.setHeader(</span><span class="s3">\n        </span><span class="s1">'x-nextjs-matched-path',</span><span class="s3">\n        </span><span class="s1">`${locale ? `/${locale}` : ''}${pathname}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">res.statusCode = 200</span><span class="s3">\n      </span><span class="s1">res.setHeader('Content-Type', JSON_CONTENT_TYPE_HEADER)</span><span class="s3">\n      </span><span class="s1">res.body('{}')</span><span class="s3">\n      </span><span class="s1">res.send()</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">res.statusCode = 404</span><span class="s3">\n    </span><span class="s1">return this.renderErrorToResponse(ctx, null)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async renderToHTML(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.renderToHTML, async () =&gt; {</span><span class="s3">\n      </span><span class="s1">return this.renderToHTMLImpl(req, res, pathname, query)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderToHTMLImpl(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">return this.getStaticHTML((ctx) =&gt; this.renderToResponse(ctx), {</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async renderError(</span><span class="s3">\n    </span><span class="s1">err: Error | null,</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery = {},</span><span class="s3">\n    </span><span class="s1">setHeaders = true</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.renderError, async () =&gt; {</span><span class="s3">\n      </span><span class="s1">return this.renderErrorImpl(err, req, res, pathname, query, setHeaders)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderErrorImpl(</span><span class="s3">\n    </span><span class="s1">err: Error | null,</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery = {},</span><span class="s3">\n    </span><span class="s1">setHeaders = true</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (setHeaders) {</span><span class="s3">\n      </span><span class="s1">res.setHeader(</span><span class="s3">\n        </span><span class="s1">'Cache-Control',</span><span class="s3">\n        </span><span class="s1">'private, no-cache, no-store, max-age=0, must-revalidate'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.pipe(</span><span class="s3">\n      </span><span class="s1">async (ctx) =&gt; {</span><span class="s3">\n        </span><span class="s1">const response = await this.renderErrorToResponse(ctx, err)</span><span class="s3">\n        </span><span class="s1">if (this.minimalMode &amp;&amp; res.statusCode === 500) {</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return response</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">{ req, res, pathname, query }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private customErrorNo404Warn = execOnce(() =&gt; {</span><span class="s3">\n    </span><span class="s1">Log.warn(</span><span class="s3">\n      </span><span class="s1">`You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.</span><span class="s3">\\</span><span class="s1">nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">private async renderErrorToResponse(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">err: Error | null</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(BaseServerSpan.renderErrorToResponse, async () =&gt; {</span><span class="s3">\n      </span><span class="s1">return this.renderErrorToResponseImpl(ctx, err)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async renderErrorToResponseImpl(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;ServerRequest, ServerResponse&gt;,</span><span class="s3">\n    </span><span class="s1">err: Error | null</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponsePayload | null&gt; {</span><span class="s3">\n    </span><span class="s1">// Short-circuit favicon.ico in development to avoid compiling 404 page when the app has no favicon.ico.</span><span class="s3">\n    </span><span class="s1">// Since favicon.ico is automatically requested by the browser.</span><span class="s3">\n    </span><span class="s1">if (this.renderOpts.dev &amp;&amp; ctx.pathname === '/favicon.ico') {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">body: RenderResult.EMPTY,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { res, query } = ctx</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">let result: null | FindComponentsResult = null</span><span class="s3">\n\n      </span><span class="s1">const is404 = res.statusCode === 404</span><span class="s3">\n      </span><span class="s1">let using404Page = false</span><span class="s3">\n\n      </span><span class="s1">if (is404) {</span><span class="s3">\n        </span><span class="s1">if (this.enabledDirectories.app) {</span><span class="s3">\n          </span><span class="s1">// Use the not-found entry in app directory</span><span class="s3">\n          </span><span class="s1">result = await this.findPageComponents({</span><span class="s3">\n            </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n            </span><span class="s1">page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">params: {},</span><span class="s3">\n            </span><span class="s1">isAppPath: true,</span><span class="s3">\n            </span><span class="s1">shouldEnsure: true,</span><span class="s3">\n            </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">using404Page = result !== null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (!result &amp;&amp; (await this.hasPage('/404'))) {</span><span class="s3">\n          </span><span class="s1">result = await this.findPageComponents({</span><span class="s3">\n            </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n            </span><span class="s1">page: '/404',</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">params: {},</span><span class="s3">\n            </span><span class="s1">isAppPath: false,</span><span class="s3">\n            </span><span class="s1">// Ensuring can't be done here because you never </span><span class="s3">\&quot;</span><span class="s1">match</span><span class="s3">\&quot; </span><span class="s1">a 404 route.</span><span class="s3">\n            </span><span class="s1">shouldEnsure: true,</span><span class="s3">\n            </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">using404Page = result !== null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">let statusPage = `/${res.statusCode}`</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!getRequestMeta(ctx.req, 'customErrorRender') &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!result &amp;&amp;</span><span class="s3">\n        </span><span class="s1">STATIC_STATUS_PAGES.includes(statusPage)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// skip ensuring /500 in dev mode as it isn't used and the</span><span class="s3">\n        </span><span class="s1">// dev overlay is used instead</span><span class="s3">\n        </span><span class="s1">if (statusPage !== '/500' || !this.renderOpts.dev) {</span><span class="s3">\n          </span><span class="s1">result = await this.findPageComponents({</span><span class="s3">\n            </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n            </span><span class="s1">page: statusPage,</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">params: {},</span><span class="s3">\n            </span><span class="s1">isAppPath: false,</span><span class="s3">\n            </span><span class="s1">// Ensuring can't be done here because you never </span><span class="s3">\&quot;</span><span class="s1">match</span><span class="s3">\&quot; </span><span class="s1">a 500</span><span class="s3">\n            </span><span class="s1">// route.</span><span class="s3">\n            </span><span class="s1">shouldEnsure: true,</span><span class="s3">\n            </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!result) {</span><span class="s3">\n        </span><span class="s1">result = await this.findPageComponents({</span><span class="s3">\n          </span><span class="s1">locale: getRequestMeta(ctx.req, 'locale'),</span><span class="s3">\n          </span><span class="s1">page: '/_error',</span><span class="s3">\n          </span><span class="s1">query,</span><span class="s3">\n          </span><span class="s1">params: {},</span><span class="s3">\n          </span><span class="s1">isAppPath: false,</span><span class="s3">\n          </span><span class="s1">// Ensuring can't be done here because you never </span><span class="s3">\&quot;</span><span class="s1">match</span><span class="s3">\&quot; </span><span class="s1">an error</span><span class="s3">\n          </span><span class="s1">// route.</span><span class="s3">\n          </span><span class="s1">shouldEnsure: true,</span><span class="s3">\n          </span><span class="s1">url: ctx.req.url,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">statusPage = '/_error'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!using404Page &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(await this.hasPage('/_error')) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!(await this.hasPage('/404'))</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.customErrorNo404Warn()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!result) {</span><span class="s3">\n        </span><span class="s1">// this can occur when a project directory has been moved/deleted</span><span class="s3">\n        </span><span class="s1">// which is handled in the parent process in development</span><span class="s3">\n        </span><span class="s1">if (this.renderOpts.dev) {</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">// wait for dev-server to restart before refreshing</span><span class="s3">\n            </span><span class="s1">body: RenderResult.fromStatic(</span><span class="s3">\n              </span><span class="s1">`</span><span class="s3">\n              </span><span class="s1">&lt;pre&gt;missing required error components, refreshing...&lt;/pre&gt;</span><span class="s3">\n              </span><span class="s1">&lt;script&gt;</span><span class="s3">\n                </span><span class="s1">async function check() {</span><span class="s3">\n                  </span><span class="s1">const res = await fetch(location.href).catch(() =&gt; ({}))</span><span class="s3">\n\n                  </span><span class="s1">if (res.status === 200) {</span><span class="s3">\n                    </span><span class="s1">location.reload()</span><span class="s3">\n                  </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">setTimeout(check, 1000)</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">check()</span><span class="s3">\n              </span><span class="s1">&lt;/script&gt;`,</span><span class="s3">\n              </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">throw new WrappedBuildError(</span><span class="s3">\n          </span><span class="s1">new Error('missing required error components')</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If the page has a route module, use it for the new match. If it doesn't</span><span class="s3">\n      </span><span class="s1">// have a route module, remove the match.</span><span class="s3">\n      </span><span class="s1">if (result.components.routeModule) {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(ctx.req, 'match', {</span><span class="s3">\n          </span><span class="s1">definition: result.components.routeModule.definition,</span><span class="s3">\n          </span><span class="s1">params: undefined,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">removeRequestMeta(ctx.req, 'match')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return await this.renderToResponseWithComponents(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">...ctx,</span><span class="s3">\n            </span><span class="s1">pathname: statusPage,</span><span class="s3">\n            </span><span class="s1">renderOpts: {</span><span class="s3">\n              </span><span class="s1">...ctx.renderOpts,</span><span class="s3">\n              </span><span class="s1">err,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">result</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (maybeFallbackError) {</span><span class="s3">\n        </span><span class="s1">if (maybeFallbackError instanceof NoFallbackError) {</span><span class="s3">\n          </span><span class="s1">throw new Error('invariant: failed to render error page')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw maybeFallbackError</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (error) {</span><span class="s3">\n      </span><span class="s1">const renderToHtmlError = getProperError(error)</span><span class="s3">\n      </span><span class="s1">const isWrappedError = renderToHtmlError instanceof WrappedBuildError</span><span class="s3">\n      </span><span class="s1">if (!isWrappedError) {</span><span class="s3">\n        </span><span class="s1">this.logError(renderToHtmlError)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n      </span><span class="s1">const fallbackComponents = await this.getFallbackErrorComponents(</span><span class="s3">\n        </span><span class="s1">ctx.req.url</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (fallbackComponents) {</span><span class="s3">\n        </span><span class="s1">// There was an error, so use it's definition from the route module</span><span class="s3">\n        </span><span class="s1">// to add the match to the request.</span><span class="s3">\n        </span><span class="s1">addRequestMeta(ctx.req, 'match', {</span><span class="s3">\n          </span><span class="s1">definition: fallbackComponents.routeModule!.definition,</span><span class="s3">\n          </span><span class="s1">params: undefined,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">return this.renderToResponseWithComponents(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">...ctx,</span><span class="s3">\n            </span><span class="s1">pathname: '/_error',</span><span class="s3">\n            </span><span class="s1">renderOpts: {</span><span class="s3">\n              </span><span class="s1">...ctx.renderOpts,</span><span class="s3">\n              </span><span class="s1">// We render `renderToHtmlError` here because `err` is</span><span class="s3">\n              </span><span class="s1">// already captured in the stacktrace.</span><span class="s3">\n              </span><span class="s1">err: isWrappedError</span><span class="s3">\n                </span><span class="s1">? renderToHtmlError.innerError</span><span class="s3">\n                </span><span class="s1">: renderToHtmlError,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">components: fallbackComponents,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">body: RenderResult.fromStatic('Internal Server Error', 'text/plain'),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async renderErrorToHTML(</span><span class="s3">\n    </span><span class="s1">err: Error | null,</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">return this.getStaticHTML((ctx) =&gt; this.renderErrorToResponse(ctx, err), {</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async render404(</span><span class="s3">\n    </span><span class="s1">req: ServerRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: Pick&lt;NextUrlWithParsedQuery, 'pathname' | 'query'&gt;,</span><span class="s3">\n    </span><span class="s1">setHeaders = true</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">const { pathname, query } = parsedUrl ? parsedUrl : parseUrl(req.url!, true)</span><span class="s3">\n\n    </span><span class="s1">// Ensure the locales are provided on the request meta.</span><span class="s3">\n    </span><span class="s1">if (this.nextConfig.i18n) {</span><span class="s3">\n      </span><span class="s1">if (!getRequestMeta(req, 'locale')) {</span><span class="s3">\n        </span><span class="s1">addRequestMeta(req, 'locale', this.nextConfig.i18n.defaultLocale)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'defaultLocale', this.nextConfig.i18n.defaultLocale)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">res.statusCode = 404</span><span class="s3">\n    </span><span class="s1">return this.renderError(null, req, res, pathname!, query, setHeaders)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingHttpHeaders } from 'node:http'</span><span class="s3">\n\n</span><span class="s1">import { FLIGHT_HEADERS } from '../../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes the flight headers from the request.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to strip the headers from</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function stripFlightHeaders(headers: IncomingHttpHeaders) {</span><span class="s3">\n  </span><span class="s1">for (const header of FLIGHT_HEADERS) {</span><span class="s3">\n    </span><span class="s1">delete headers[header]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Translate a pages asset path (relative from a common prefix) back into its logical route</span><span class="s3">\n\n</span><span class="s1">import { isDynamicRoute } from './is-dynamic'</span><span class="s3">\n\n</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">asset path</span><span class="s3">\&quot; </span><span class="s1">being its javascript file, data file, prerendered html,...</span><span class="s3">\n</span><span class="s1">export default function getRouteFromAssetPath(</span><span class="s3">\n  </span><span class="s1">assetPath: string,</span><span class="s3">\n  </span><span class="s1">ext: string = ''</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">assetPath = assetPath.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n  </span><span class="s1">assetPath =</span><span class="s3">\n    </span><span class="s1">ext &amp;&amp; assetPath.endsWith(ext) ? assetPath.slice(0, -ext.length) : assetPath</span><span class="s3">\n  </span><span class="s1">if (assetPath.startsWith('/index/') &amp;&amp; !isDynamicRoute(assetPath)) {</span><span class="s3">\n    </span><span class="s1">assetPath = assetPath.slice(6)</span><span class="s3">\n  </span><span class="s1">} else if (assetPath === '/index') {</span><span class="s3">\n    </span><span class="s1">assetPath = '/'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return assetPath</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isIPv6 } from './is-ipv6'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Formats a hostname so that it is a valid host that can be fetched by wrapping</span><span class="s3">\n </span><span class="s1">* IPv6 hosts with brackets.</span><span class="s3">\n </span><span class="s1">* @param hostname</span><span class="s3">\n </span><span class="s1">* @returns</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function formatHostname(hostname: string): string {</span><span class="s3">\n  </span><span class="s1">return isIPv6(hostname) ? `[${hostname}]` : hostname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* If set to `incremental`, only those leaf pages that export</span><span class="s3">\n </span><span class="s1">* `experimental_ppr = true` will have partial prerendering enabled. If any</span><span class="s3">\n </span><span class="s1">* page exports this value as `false` or does not export it at all will not</span><span class="s3">\n </span><span class="s1">* have partial prerendering enabled. If set to a boolean, the options for</span><span class="s3">\n </span><span class="s1">* `experimental_ppr` will be ignored.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export type ExperimentalPPRConfig = boolean | 'incremental'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns true if partial prerendering is enabled for the application. It does</span><span class="s3">\n </span><span class="s1">* not tell you if a given route has PPR enabled, as that requires analysis of</span><span class="s3">\n </span><span class="s1">* the route's configuration.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @see {@link checkIsRoutePPREnabled} - for checking if a specific route has PPR enabled.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function checkIsAppPPREnabled(</span><span class="s3">\n  </span><span class="s1">config: ExperimentalPPRConfig | undefined</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// If the config is undefined, partial prerendering is disabled.</span><span class="s3">\n  </span><span class="s1">if (typeof config === 'undefined') return false</span><span class="s3">\n\n  </span><span class="s1">// If the config is a boolean, use it directly.</span><span class="s3">\n  </span><span class="s1">if (typeof config === 'boolean') return config</span><span class="s3">\n\n  </span><span class="s1">// If the config is a string, it must be 'incremental' to enable partial</span><span class="s3">\n  </span><span class="s1">// prerendering.</span><span class="s3">\n  </span><span class="s1">if (config === 'incremental') return true</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns true if partial prerendering is supported for the current page with</span><span class="s3">\n </span><span class="s1">* the provided app configuration. If the application doesn't have partial</span><span class="s3">\n </span><span class="s1">* prerendering enabled, this function will always return false. If you want to</span><span class="s3">\n </span><span class="s1">* check if the application has partial prerendering enabled</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @see {@link checkIsAppPPREnabled} for checking if the application has PPR enabled.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function checkIsRoutePPREnabled(</span><span class="s3">\n  </span><span class="s1">config: ExperimentalPPRConfig | undefined,</span><span class="s3">\n  </span><span class="s1">appConfig: {</span><span class="s3">\n    </span><span class="s1">experimental_ppr?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// If the config is undefined, partial prerendering is disabled.</span><span class="s3">\n  </span><span class="s1">if (typeof config === 'undefined') return false</span><span class="s3">\n\n  </span><span class="s1">// If the config is a boolean, use it directly.</span><span class="s3">\n  </span><span class="s1">if (typeof config === 'boolean') return config</span><span class="s3">\n\n  </span><span class="s1">// If the config is a string, it must be 'incremental' to enable partial</span><span class="s3">\n  </span><span class="s1">// prerendering.</span><span class="s3">\n  </span><span class="s1">if (config === 'incremental' &amp;&amp; appConfig.experimental_ppr === true) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { getRequestMeta, type NextIncomingMessage } from '../request-meta'</span><span class="s3">\n\n</span><span class="s1">type PatchableResponse = {</span><span class="s3">\n  </span><span class="s1">setHeader(key: string, value: string | string[]): PatchableResponse</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensure cookies set in middleware are merged and not overridden by API</span><span class="s3">\n </span><span class="s1">* routes/getServerSideProps.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req Incoming request</span><span class="s3">\n </span><span class="s1">* @param res Outgoing response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function patchSetHeaderWithCookieSupport(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">res: PatchableResponse</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const setHeader = res.setHeader.bind(res)</span><span class="s3">\n  </span><span class="s1">res.setHeader = (</span><span class="s3">\n    </span><span class="s1">name: string,</span><span class="s3">\n    </span><span class="s1">value: string | string[]</span><span class="s3">\n  </span><span class="s1">): PatchableResponse =&gt; {</span><span class="s3">\n    </span><span class="s1">// When renders /_error after page is failed, it could attempt to set</span><span class="s3">\n    </span><span class="s1">// headers after headers.</span><span class="s3">\n    </span><span class="s1">if ('headersSent' in res &amp;&amp; res.headersSent) {</span><span class="s3">\n      </span><span class="s1">return res</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (name.toLowerCase() === 'set-cookie') {</span><span class="s3">\n      </span><span class="s1">const middlewareValue = getRequestMeta(req, 'middlewareCookie')</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!middlewareValue ||</span><span class="s3">\n        </span><span class="s1">!Array.isArray(value) ||</span><span class="s3">\n        </span><span class="s1">!value.every((item, idx) =&gt; item === middlewareValue[idx])</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">value = [</span><span class="s3">\n          </span><span class="s1">// TODO: (wyattjoh) find out why this is called multiple times resulting in duplicate cookies being added</span><span class="s3">\n          </span><span class="s1">...new Set([</span><span class="s3">\n            </span><span class="s1">...(middlewareValue || []),</span><span class="s3">\n            </span><span class="s1">...(typeof value === 'string'</span><span class="s3">\n              </span><span class="s1">? [value]</span><span class="s3">\n              </span><span class="s1">: Array.isArray(value)</span><span class="s3">\n                </span><span class="s1">? value</span><span class="s3">\n                </span><span class="s1">: []),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return setHeader(name, value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// x-matched-path header can be decoded incorrectly</span><span class="s3">\n</span><span class="s1">// and should only be utf8 characters so this fixes</span><span class="s3">\n</span><span class="s1">// incorrectly encoded values</span><span class="s3">\n</span><span class="s1">export function fixMojibake(input: string): string {</span><span class="s3">\n  </span><span class="s1">// Convert each character's char code to a byte</span><span class="s3">\n  </span><span class="s1">const bytes = new Uint8Array(input.length)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; input.length; i++) {</span><span class="s3">\n    </span><span class="s1">bytes[i] = input.charCodeAt(i)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Decode the bytes as proper UTF-8</span><span class="s3">\n  </span><span class="s1">const decoder = new TextDecoder('utf-8')</span><span class="s3">\n  </span><span class="s1">return decoder.decode(bytes)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isGroupSegment,</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n\n</span><span class="s1">const removeLeadingSlash = (segment: string): string =&gt; {</span><span class="s3">\n  </span><span class="s1">return segment[0] === '/' ? segment.slice(1) : segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const segmentToPathname = (segment: Segment): string =&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">// 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page</span><span class="s3">\n    </span><span class="s1">// if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.</span><span class="s3">\n    </span><span class="s1">if (segment === 'children') return ''</span><span class="s3">\n\n    </span><span class="s1">return segment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment[1]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function normalizeSegments(segments: string[]): string {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">segments.reduce((acc, segment) =&gt; {</span><span class="s3">\n      </span><span class="s1">segment = removeLeadingSlash(segment)</span><span class="s3">\n      </span><span class="s1">if (segment === '' || isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return acc</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${acc}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '') || '/'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractPathFromFlightRouterState(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">const segment = Array.isArray(flightRouterState[0])</span><span class="s3">\n    </span><span class="s1">? flightRouterState[0][1]</span><span class="s3">\n    </span><span class="s1">: flightRouterState[0]</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">segment === DEFAULT_SEGMENT_KEY ||</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some((m) =&gt; segment.startsWith(m))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n\n  </span><span class="s1">if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''</span><span class="s3">\n\n  </span><span class="s1">const segments = [segmentToPathname(segment)]</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = flightRouterState[1] ?? {}</span><span class="s3">\n\n  </span><span class="s1">const childrenPath = parallelRoutes.children</span><span class="s3">\n    </span><span class="s1">? extractPathFromFlightRouterState(parallelRoutes.children)</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">if (childrenPath !== undefined) {</span><span class="s3">\n    </span><span class="s1">segments.push(childrenPath)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of Object.entries(parallelRoutes)) {</span><span class="s3">\n      </span><span class="s1">if (key === 'children') continue</span><span class="s3">\n\n      </span><span class="s1">const childPath = extractPathFromFlightRouterState(value)</span><span class="s3">\n\n      </span><span class="s1">if (childPath !== undefined) {</span><span class="s3">\n        </span><span class="s1">segments.push(childPath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalizeSegments(segments)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeChangedPathImpl(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const [segmentA, parallelRoutesA] = treeA</span><span class="s3">\n  </span><span class="s1">const [segmentB, parallelRoutesB] = treeB</span><span class="s3">\n\n  </span><span class="s1">const normalizedSegmentA = segmentToPathname(segmentA)</span><span class="s3">\n  </span><span class="s1">const normalizedSegmentB = segmentToPathname(segmentB)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some(</span><span class="s3">\n      </span><span class="s1">(m) =&gt;</span><span class="s3">\n        </span><span class="s1">normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!matchSegment(segmentA, segmentB)) {</span><span class="s3">\n    </span><span class="s1">// once we find where the tree changed, we compute the rest of the path by traversing the tree</span><span class="s3">\n    </span><span class="s1">return extractPathFromFlightRouterState(treeB) ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRouterKey in parallelRoutesA) {</span><span class="s3">\n    </span><span class="s1">if (parallelRoutesB[parallelRouterKey]) {</span><span class="s3">\n      </span><span class="s1">const changedPath = computeChangedPathImpl(</span><span class="s3">\n        </span><span class="s1">parallelRoutesA[parallelRouterKey],</span><span class="s3">\n        </span><span class="s1">parallelRoutesB[parallelRouterKey]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (changedPath !== null) {</span><span class="s3">\n        </span><span class="s1">return `${segmentToPathname(segmentB)}/${changedPath}`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function computeChangedPath(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const changedPath = computeChangedPathImpl(treeA, treeB)</span><span class="s3">\n\n  </span><span class="s1">if (changedPath == null || changedPath === '/') {</span><span class="s3">\n    </span><span class="s1">return changedPath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// lightweight normalization to remove route groups</span><span class="s3">\n  </span><span class="s1">return normalizeSegments(changedPath.split('/'))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively extracts dynamic parameters from FlightRouterState.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSelectedParams(</span><span class="s3">\n  </span><span class="s1">currentTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">params: Params = {}</span><span class="s3">\n</span><span class="s1">): Params {</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = currentTree[1]</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRoute of Object.values(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">const segment = parallelRoute[0]</span><span class="s3">\n    </span><span class="s1">const isDynamicParameter = Array.isArray(segment)</span><span class="s3">\n    </span><span class="s1">const segmentValue = isDynamicParameter ? segment[1] : segment</span><span class="s3">\n    </span><span class="s1">if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue</span><span class="s3">\n\n    </span><span class="s1">// Ensure catchAll and optional catchall are turned into an array</span><span class="s3">\n    </span><span class="s1">const isCatchAll =</span><span class="s3">\n      </span><span class="s1">isDynamicParameter &amp;&amp; (segment[2] === 'c' || segment[2] === 'oc')</span><span class="s3">\n\n    </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1].split('/')</span><span class="s3">\n    </span><span class="s1">} else if (isDynamicParameter) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">params = getSelectedParams(parallelRoute, params)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { FlightRouterState } from './types'</span><span class="s3">\n</span><span class="s1">import { flightRouterStateSchema } from './types'</span><span class="s3">\n</span><span class="s1">import { assert } from 'next/dist/compiled/superstruct'</span><span class="s3">\n\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[]</span><span class="s3">\n</span><span class="s1">): FlightRouterState</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: undefined</span><span class="s3">\n</span><span class="s1">): undefined</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[] | undefined</span><span class="s3">\n</span><span class="s1">): FlightRouterState | undefined</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[] | undefined</span><span class="s3">\n</span><span class="s1">): FlightRouterState | undefined {</span><span class="s3">\n  </span><span class="s1">if (typeof stateHeader === 'undefined') {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(stateHeader)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Multiple router state headers were sent. This is not allowed.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We limit the size of the router state header to ~40kb. This is to prevent</span><span class="s3">\n  </span><span class="s1">// a malicious user from sending a very large header and slowing down the</span><span class="s3">\n  </span><span class="s1">// resolving of the router state.</span><span class="s3">\n  </span><span class="s1">// This is around 2,000 nested or parallel route segment states:</span><span class="s3">\n  </span><span class="s1">// '{</span><span class="s3">\&quot;</span><span class="s1">children</span><span class="s3">\&quot;</span><span class="s1">:[</span><span class="s3">\&quot;\&quot;</span><span class="s1">,{}]}'.length === 20.</span><span class="s3">\n  </span><span class="s1">if (stateHeader.length &gt; 20 * 2000) {</span><span class="s3">\n    </span><span class="s1">throw new Error('The router state header was too large.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const state = JSON.parse(decodeURIComponent(stateHeader))</span><span class="s3">\n    </span><span class="s1">assert(state, flightRouterStateSchema)</span><span class="s3">\n    </span><span class="s1">return state</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">throw new Error('The router state header was sent but could not be parsed.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">const DUMMY_ORIGIN = 'http://n'</span><span class="s3">\n\n</span><span class="s1">export function isFullStringUrl(url: string) {</span><span class="s3">\n  </span><span class="s1">return /https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//.test(url)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseUrl(url: string): URL | undefined {</span><span class="s3">\n  </span><span class="s1">let parsed: URL | undefined = undefined</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">parsed = new URL(url, DUMMY_ORIGIN)</span><span class="s3">\n  </span><span class="s1">} catch {}</span><span class="s3">\n  </span><span class="s1">return parsed</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseReqUrl(url: string): UrlWithParsedQuery | undefined {</span><span class="s3">\n  </span><span class="s1">const parsedUrl: URL | undefined = parseUrl(url)</span><span class="s3">\n\n  </span><span class="s1">if (!parsedUrl) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const query: Record&lt;string, string | string[]&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const key of parsedUrl.searchParams.keys()) {</span><span class="s3">\n    </span><span class="s1">const values = parsedUrl.searchParams.getAll(key)</span><span class="s3">\n    </span><span class="s1">query[key] = values.length &gt; 1 ? values : values[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const legacyUrl: UrlWithParsedQuery = {</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">hash: parsedUrl.hash,</span><span class="s3">\n    </span><span class="s1">search: parsedUrl.search,</span><span class="s3">\n    </span><span class="s1">path: parsedUrl.pathname,</span><span class="s3">\n    </span><span class="s1">pathname: parsedUrl.pathname,</span><span class="s3">\n    </span><span class="s1">href: `${parsedUrl.pathname}${parsedUrl.search}${parsedUrl.hash}`,</span><span class="s3">\n    </span><span class="s1">host: '',</span><span class="s3">\n    </span><span class="s1">hostname: '',</span><span class="s3">\n    </span><span class="s1">auth: '',</span><span class="s3">\n    </span><span class="s1">protocol: '',</span><span class="s3">\n    </span><span class="s1">slashes: null,</span><span class="s3">\n    </span><span class="s1">port: '',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return legacyUrl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stripNextRscUnionQuery(relativeUrl: string): string {</span><span class="s3">\n  </span><span class="s1">const urlInstance = new URL(relativeUrl, DUMMY_ORIGIN)</span><span class="s3">\n  </span><span class="s1">urlInstance.searchParams.delete(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n\n  </span><span class="s1">return urlInstance.pathname + urlInstance.search</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">getBotType,</span><span class="s3">\n  </span><span class="s1">HTML_LIMITED_BOT_UA_RE_STRING,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/router/utils/is-bot'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n\n</span><span class="s1">export function shouldServeStreamingMetadata(</span><span class="s3">\n  </span><span class="s1">userAgent: string,</span><span class="s3">\n  </span><span class="s1">htmlLimitedBots: string | undefined</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const blockingMetadataUARegex = new RegExp(</span><span class="s3">\n    </span><span class="s1">htmlLimitedBots || HTML_LIMITED_BOT_UA_RE_STRING,</span><span class="s3">\n    </span><span class="s1">'i'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">// Only block metadata for HTML-limited bots</span><span class="s3">\n  </span><span class="s1">if (userAgent &amp;&amp; blockingMetadataUARegex.test(userAgent)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// When the request UA is a html-limited bot, we should do a dynamic render.</span><span class="s3">\n</span><span class="s1">// In this case, postpone state is not sent.</span><span class="s3">\n</span><span class="s1">export function isHtmlBotRequest(req: {</span><span class="s3">\n  </span><span class="s1">headers: BaseNextRequest['headers']</span><span class="s3">\n</span><span class="s1">}): boolean {</span><span class="s3">\n  </span><span class="s1">const ua = req.headers['user-agent'] || ''</span><span class="s3">\n  </span><span class="s1">const botType = getBotType(ua)</span><span class="s3">\n\n  </span><span class="s1">return botType === 'html'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { BLOCKED_PAGES } from '../shared/lib/constants'</span><span class="s3">\n\n</span><span class="s1">export function isBlockedPage(page: string): boolean {</span><span class="s3">\n  </span><span class="s1">return BLOCKED_PAGES.includes(page)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function cleanAmpPath(pathname: string): string {</span><span class="s3">\n  </span><span class="s1">if (pathname.match(/</span><span class="s3">\\</span><span class="s1">?amp=(y|yes|true|1)/)) {</span><span class="s3">\n    </span><span class="s1">pathname = pathname.replace(/</span><span class="s3">\\</span><span class="s1">?amp=(y|yes|true|1)&amp;?/, '?')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (pathname.match(/&amp;amp=(y|yes|true|1)/)) {</span><span class="s3">\n    </span><span class="s1">pathname = pathname.replace(/&amp;amp=(y|yes|true|1)/, '')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">pathname = pathname.replace(/</span><span class="s3">\\</span><span class="s1">?$/, '')</span><span class="s3">\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type AnyFunc&lt;T&gt; = (this: T, ...args: any) =&gt; any</span><span class="s3">\n</span><span class="s1">export function debounce&lt;T, F extends AnyFunc&lt;T&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">fn: F,</span><span class="s3">\n  </span><span class="s1">ms: number,</span><span class="s3">\n  </span><span class="s1">maxWait = Infinity</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let timeoutId: undefined | NodeJS.Timeout</span><span class="s3">\n\n  </span><span class="s1">// The time the debouncing function was first called during this debounce queue.</span><span class="s3">\n  </span><span class="s1">let startTime = 0</span><span class="s3">\n  </span><span class="s1">// The time the debouncing function was last called.</span><span class="s3">\n  </span><span class="s1">let lastCall = 0</span><span class="s3">\n\n  </span><span class="s1">// The arguments and this context of the last call to the debouncing function.</span><span class="s3">\n  </span><span class="s1">let args: Parameters&lt;F&gt;, context: T</span><span class="s3">\n\n  </span><span class="s1">// A helper used to that either invokes the debounced function, or</span><span class="s3">\n  </span><span class="s1">// reschedules the timer if a more recent call was made.</span><span class="s3">\n  </span><span class="s1">function run() {</span><span class="s3">\n    </span><span class="s1">const now = Date.now()</span><span class="s3">\n    </span><span class="s1">const diff = lastCall + ms - now</span><span class="s3">\n\n    </span><span class="s1">// If the diff is non-positive, then we've waited at least `ms`</span><span class="s3">\n    </span><span class="s1">// milliseconds since the last call. Or if we've waited for longer than the</span><span class="s3">\n    </span><span class="s1">// max wait time, we must call the debounced function.</span><span class="s3">\n    </span><span class="s1">if (diff &lt;= 0 || startTime + maxWait &gt;= now) {</span><span class="s3">\n      </span><span class="s1">// It's important to clear the timeout id before invoking the debounced</span><span class="s3">\n      </span><span class="s1">// function, in case the function calls the debouncing function again.</span><span class="s3">\n      </span><span class="s1">timeoutId = undefined</span><span class="s3">\n      </span><span class="s1">fn.apply(context, args)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Else, a new call was made after the original timer was scheduled. We</span><span class="s3">\n      </span><span class="s1">// didn't clear the timeout (doing so is very slow), so now we need to</span><span class="s3">\n      </span><span class="s1">// reschedule the timer for the time difference.</span><span class="s3">\n      </span><span class="s1">timeoutId = setTimeout(run, diff)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return function (this: T, ...passedArgs: Parameters&lt;F&gt;) {</span><span class="s3">\n    </span><span class="s1">// The arguments and this context of the most recent call are saved so the</span><span class="s3">\n    </span><span class="s1">// debounced function can be invoked with them later.</span><span class="s3">\n    </span><span class="s1">args = passedArgs</span><span class="s3">\n    </span><span class="s1">context = this</span><span class="s3">\n\n    </span><span class="s1">// Instead of constantly clearing and scheduling a timer, we record the</span><span class="s3">\n    </span><span class="s1">// time of the last call. If a second call comes in before the timer fires,</span><span class="s3">\n    </span><span class="s1">// then we'll reschedule in the run function. Doing this is considerably</span><span class="s3">\n    </span><span class="s1">// faster.</span><span class="s3">\n    </span><span class="s1">lastCall = Date.now()</span><span class="s3">\n\n    </span><span class="s1">// Only schedule a new timer if we're not currently waiting.</span><span class="s3">\n    </span><span class="s1">if (timeoutId === undefined) {</span><span class="s3">\n      </span><span class="s1">startTime = lastCall</span><span class="s3">\n      </span><span class="s1">timeoutId = setTimeout(run, ms)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Describes the different fallback modes that a given page can have.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const enum FallbackMode {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A BLOCKING_STATIC_RENDER fallback will block the request until the page is</span><span class="s3">\n   </span><span class="s1">* generated. No fallback page will be rendered, and users will have to wait</span><span class="s3">\n   </span><span class="s1">* to render the page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">BLOCKING_STATIC_RENDER = 'BLOCKING_STATIC_RENDER',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When set to PRERENDER, a fallback page will be sent to users in place of</span><span class="s3">\n   </span><span class="s1">* forcing them to wait for the page to be generated. This allows the user to</span><span class="s3">\n   </span><span class="s1">* see a rendered page earlier.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PRERENDER = 'PRERENDER',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When set to NOT_FOUND, pages that are not already prerendered will result</span><span class="s3">\n   </span><span class="s1">* in a not found response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">NOT_FOUND = 'NOT_FOUND',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The fallback value returned from the `getStaticPaths` function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type GetStaticPathsFallback = boolean | 'blocking'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses the fallback field from the prerender manifest.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param fallbackField The fallback field from the prerender manifest.</span><span class="s3">\n </span><span class="s1">* @returns The fallback mode.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseFallbackField(</span><span class="s3">\n  </span><span class="s1">fallbackField: string | boolean | null | undefined</span><span class="s3">\n</span><span class="s1">): FallbackMode | undefined {</span><span class="s3">\n  </span><span class="s1">if (typeof fallbackField === 'string') {</span><span class="s3">\n    </span><span class="s1">return FallbackMode.PRERENDER</span><span class="s3">\n  </span><span class="s1">} else if (fallbackField === null) {</span><span class="s3">\n    </span><span class="s1">return FallbackMode.BLOCKING_STATIC_RENDER</span><span class="s3">\n  </span><span class="s1">} else if (fallbackField === false) {</span><span class="s3">\n    </span><span class="s1">return FallbackMode.NOT_FOUND</span><span class="s3">\n  </span><span class="s1">} else if (fallbackField === undefined) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid fallback option: ${fallbackField}. Fallback option must be a string, null, undefined, or false.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function fallbackModeToFallbackField(</span><span class="s3">\n  </span><span class="s1">fallback: FallbackMode,</span><span class="s3">\n  </span><span class="s1">page: string | undefined</span><span class="s3">\n</span><span class="s1">): string | false | null {</span><span class="s3">\n  </span><span class="s1">switch (fallback) {</span><span class="s3">\n    </span><span class="s1">case FallbackMode.BLOCKING_STATIC_RENDER:</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">case FallbackMode.NOT_FOUND:</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">case FallbackMode.PRERENDER:</span><span class="s3">\n      </span><span class="s1">if (!page) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invariant: expected a page to be provided when fallback mode is </span><span class="s3">\&quot;</span><span class="s1">${fallback}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return page</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error(`Invalid fallback mode: ${fallback}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses the fallback from the static paths result.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param result The result from the static paths function.</span><span class="s3">\n </span><span class="s1">* @returns The fallback mode.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseStaticPathsResult(</span><span class="s3">\n  </span><span class="s1">result: GetStaticPathsFallback</span><span class="s3">\n</span><span class="s1">): FallbackMode {</span><span class="s3">\n  </span><span class="s1">if (result === true) {</span><span class="s3">\n    </span><span class="s1">return FallbackMode.PRERENDER</span><span class="s3">\n  </span><span class="s1">} else if (result === 'blocking') {</span><span class="s3">\n    </span><span class="s1">return FallbackMode.BLOCKING_STATIC_RENDER</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return FallbackMode.NOT_FOUND</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { NextRequest } from '../web/exports'</span><span class="s3">\n</span><span class="s1">import { ACTION_HEADER } from '../../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">export function getServerActionRequestMetadata(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage | BaseNextRequest | NextRequest</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">actionId: string | null</span><span class="s3">\n  </span><span class="s1">isURLEncodedAction: boolean</span><span class="s3">\n  </span><span class="s1">isMultipartAction: boolean</span><span class="s3">\n  </span><span class="s1">isFetchAction: boolean</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction: boolean</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">let actionId: string | null</span><span class="s3">\n  </span><span class="s1">let contentType: string | null</span><span class="s3">\n\n  </span><span class="s1">if (req.headers instanceof Headers) {</span><span class="s3">\n    </span><span class="s1">actionId = req.headers.get(ACTION_HEADER) ?? null</span><span class="s3">\n    </span><span class="s1">contentType = req.headers.get('content-type')</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">actionId = (req.headers[ACTION_HEADER] as string) ?? null</span><span class="s3">\n    </span><span class="s1">contentType = req.headers['content-type'] ?? null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const isURLEncodedAction = Boolean(</span><span class="s3">\n    </span><span class="s1">req.method === 'POST' &amp;&amp; contentType === 'application/x-www-form-urlencoded'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const isMultipartAction = Boolean(</span><span class="s3">\n    </span><span class="s1">req.method === 'POST' &amp;&amp; contentType?.startsWith('multipart/form-data')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const isFetchAction = Boolean(</span><span class="s3">\n    </span><span class="s1">actionId !== undefined &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof actionId === 'string' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.method === 'POST'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const isPossibleServerAction = Boolean(</span><span class="s3">\n    </span><span class="s1">isFetchAction || isURLEncodedAction || isMultipartAction</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">actionId,</span><span class="s3">\n    </span><span class="s1">isURLEncodedAction,</span><span class="s3">\n    </span><span class="s1">isMultipartAction,</span><span class="s3">\n    </span><span class="s1">isFetchAction,</span><span class="s3">\n    </span><span class="s1">isPossibleServerAction,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getIsPossibleServerAction(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage | BaseNextRequest | NextRequest</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return getServerActionRequestMetadata(req).isPossibleServerAction</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AppRouteRouteModule } from './app-route/module'</span><span class="s3">\n</span><span class="s1">import type { AppPageRouteModule } from './app-page/module'</span><span class="s3">\n</span><span class="s1">import type { PagesRouteModule } from './pages/module'</span><span class="s3">\n</span><span class="s1">import type { PagesAPIRouteModule } from './pages-api/module'</span><span class="s3">\n\n</span><span class="s1">import type { RouteModule } from './route-module'</span><span class="s3">\n\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export function isAppRouteRouteModule(</span><span class="s3">\n  </span><span class="s1">routeModule: RouteModule</span><span class="s3">\n</span><span class="s1">): routeModule is AppRouteRouteModule {</span><span class="s3">\n  </span><span class="s1">return routeModule.definition.kind === RouteKind.APP_ROUTE</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isAppPageRouteModule(</span><span class="s3">\n  </span><span class="s1">routeModule: RouteModule</span><span class="s3">\n</span><span class="s1">): routeModule is AppPageRouteModule {</span><span class="s3">\n  </span><span class="s1">return routeModule.definition.kind === RouteKind.APP_PAGE</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isPagesRouteModule(</span><span class="s3">\n  </span><span class="s1">routeModule: RouteModule</span><span class="s3">\n</span><span class="s1">): routeModule is PagesRouteModule {</span><span class="s3">\n  </span><span class="s1">return routeModule.definition.kind === RouteKind.PAGES</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isPagesAPIRouteModule(</span><span class="s3">\n  </span><span class="s1">routeModule: RouteModule</span><span class="s3">\n</span><span class="s1">): routeModule is PagesAPIRouteModule {</span><span class="s3">\n  </span><span class="s1">return routeModule.definition.kind === RouteKind.PAGES_API</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from 'path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PAGES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SERVER_DIRECTORY,</span><span class="s3">\n  </span><span class="s1">APP_PATHS_MANIFEST,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n</span><span class="s1">import { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'</span><span class="s3">\n</span><span class="s1">import type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import { PageNotFoundError, MissingStaticPage } from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { LRUCache } from '../server/lib/lru-cache'</span><span class="s3">\n</span><span class="s1">import { loadManifest } from './load-manifest.external'</span><span class="s3">\n</span><span class="s1">import { promises } from 'fs'</span><span class="s3">\n\n</span><span class="s1">const isDev = process.env.NODE_ENV === 'development'</span><span class="s3">\n</span><span class="s1">const pagePathCache = !isDev ? new LRUCache&lt;string | null&gt;(1000) : null</span><span class="s3">\n\n</span><span class="s1">export function getMaybePagePath(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">distDir: string,</span><span class="s3">\n  </span><span class="s1">locales: readonly string[] | undefined,</span><span class="s3">\n  </span><span class="s1">isAppPath: boolean</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const cacheKey = `${page}:${distDir}:${locales}:${isAppPath}`</span><span class="s3">\n\n  </span><span class="s1">let pagePath = pagePathCache?.get(cacheKey)</span><span class="s3">\n\n  </span><span class="s1">// If we have a cached path, we can return it directly.</span><span class="s3">\n  </span><span class="s1">if (pagePath) return pagePath</span><span class="s3">\n\n  </span><span class="s1">const serverBuildPath = path.join(distDir, SERVER_DIRECTORY)</span><span class="s3">\n  </span><span class="s1">let appPathsManifest: undefined | PagesManifest</span><span class="s3">\n\n  </span><span class="s1">if (isAppPath) {</span><span class="s3">\n    </span><span class="s1">appPathsManifest = loadManifest(</span><span class="s3">\n      </span><span class="s1">path.join(serverBuildPath, APP_PATHS_MANIFEST),</span><span class="s3">\n      </span><span class="s1">!isDev</span><span class="s3">\n    </span><span class="s1">) as PagesManifest</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const pagesManifest = loadManifest(</span><span class="s3">\n    </span><span class="s1">path.join(serverBuildPath, PAGES_MANIFEST),</span><span class="s3">\n    </span><span class="s1">!isDev</span><span class="s3">\n  </span><span class="s1">) as PagesManifest</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">page = denormalizePagePath(normalizePagePath(page))</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">console.error(err)</span><span class="s3">\n    </span><span class="s1">throw new PageNotFoundError(page)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const checkManifest = (manifest: PagesManifest) =&gt; {</span><span class="s3">\n    </span><span class="s1">let curPath = manifest[page]</span><span class="s3">\n\n    </span><span class="s1">if (!manifest[curPath] &amp;&amp; locales) {</span><span class="s3">\n      </span><span class="s1">const manifestNoLocales: typeof pagesManifest = {}</span><span class="s3">\n\n      </span><span class="s1">for (const key of Object.keys(manifest)) {</span><span class="s3">\n        </span><span class="s1">manifestNoLocales[normalizeLocalePath(key, locales).pathname] =</span><span class="s3">\n          </span><span class="s1">pagesManifest[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">curPath = manifestNoLocales[page]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return curPath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (appPathsManifest) {</span><span class="s3">\n    </span><span class="s1">pagePath = checkManifest(appPathsManifest)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!pagePath) {</span><span class="s3">\n    </span><span class="s1">pagePath = checkManifest(pagesManifest)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!pagePath) {</span><span class="s3">\n    </span><span class="s1">pagePathCache?.set(cacheKey, null)</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">pagePath = path.join(serverBuildPath, pagePath)</span><span class="s3">\n\n  </span><span class="s1">pagePathCache?.set(cacheKey, pagePath)</span><span class="s3">\n  </span><span class="s1">return pagePath</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getPagePath(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">distDir: string,</span><span class="s3">\n  </span><span class="s1">locales: string[] | undefined,</span><span class="s3">\n  </span><span class="s1">isAppPath: boolean</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const pagePath = getMaybePagePath(page, distDir, locales, isAppPath)</span><span class="s3">\n\n  </span><span class="s1">if (!pagePath) {</span><span class="s3">\n    </span><span class="s1">throw new PageNotFoundError(page)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pagePath</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function requirePage(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">distDir: string,</span><span class="s3">\n  </span><span class="s1">isAppPath: boolean</span><span class="s3">\n</span><span class="s1">): Promise&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">const pagePath = getPagePath(page, distDir, undefined, isAppPath)</span><span class="s3">\n  </span><span class="s1">if (pagePath.endsWith('.html')) {</span><span class="s3">\n    </span><span class="s1">return promises.readFile(pagePath, 'utf8').catch((err) =&gt; {</span><span class="s3">\n      </span><span class="s1">throw new MissingStaticPage(page, err.message)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const mod = process.env.NEXT_MINIMAL</span><span class="s3">\n    </span><span class="s1">? // @ts-ignore</span><span class="s3">\n      </span><span class="s1">__non_webpack_require__(pagePath)</span><span class="s3">\n    </span><span class="s1">: require(pagePath)</span><span class="s3">\n  </span><span class="s1">return mod</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function interopDefault(mod: any) {</span><span class="s3">\n  </span><span class="s1">return mod.default || mod</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Wait for a given number of milliseconds and then resolve.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param ms the number of milliseconds to wait</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function wait(ms: number) {</span><span class="s3">\n  </span><span class="s1">return new Promise((resolve) =&gt; setTimeout(resolve, ms))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ClientReferenceManifest,</span><span class="s3">\n  </span><span class="s1">ClientReferenceManifestForRsc,</span><span class="s3">\n</span><span class="s1">} from '../../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from './work-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">let __next_loaded_action_key: CryptoKey</span><span class="s3">\n\n</span><span class="s1">export function arrayBufferToString(</span><span class="s3">\n  </span><span class="s1">buffer: ArrayBuffer | Uint8Array&lt;ArrayBufferLike&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const bytes = new Uint8Array(buffer)</span><span class="s3">\n  </span><span class="s1">const len = bytes.byteLength</span><span class="s3">\n\n  </span><span class="s1">// @anonrig: V8 has a limit of 65535 arguments in a function.</span><span class="s3">\n  </span><span class="s1">// For len &lt; 65535, this is faster.</span><span class="s3">\n  </span><span class="s1">// https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623</span><span class="s3">\n  </span><span class="s1">if (len &lt; 65535) {</span><span class="s3">\n    </span><span class="s1">return String.fromCharCode.apply(null, bytes as unknown as number[])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let binary = ''</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">binary += String.fromCharCode(bytes[i])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return binary</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stringToUint8Array(binary: string) {</span><span class="s3">\n  </span><span class="s1">const len = binary.length</span><span class="s3">\n  </span><span class="s1">const arr = new Uint8Array(len)</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">arr[i] = binary.charCodeAt(i)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return arr</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function encrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {</span><span class="s3">\n  </span><span class="s1">return crypto.subtle.encrypt(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">name: 'AES-GCM',</span><span class="s3">\n      </span><span class="s1">iv,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">data</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function decrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {</span><span class="s3">\n  </span><span class="s1">return crypto.subtle.decrypt(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">name: 'AES-GCM',</span><span class="s3">\n      </span><span class="s1">iv,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">data</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// This is a global singleton that is used to encode/decode the action bound args from</span><span class="s3">\n</span><span class="s1">// the closure. This can't be using a AsyncLocalStorage as it might happen on the module</span><span class="s3">\n</span><span class="s1">// level. Since the client reference manifest won't be mutated, let's use a global singleton</span><span class="s3">\n</span><span class="s1">// to keep it.</span><span class="s3">\n</span><span class="s1">const SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for(</span><span class="s3">\n  </span><span class="s1">'next.server.action-manifests'</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export function setReferenceManifestsSingleton({</span><span class="s3">\n  </span><span class="s1">page,</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n  </span><span class="s1">serverActionsManifest,</span><span class="s3">\n  </span><span class="s1">serverModuleMap,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">serverActionsManifest: DeepReadonly&lt;ActionManifest&gt;</span><span class="s3">\n  </span><span class="s1">serverModuleMap: {</span><span class="s3">\n    </span><span class="s1">[id: string]: {</span><span class="s3">\n      </span><span class="s1">id: string</span><span class="s3">\n      </span><span class="s1">chunks: string[]</span><span class="s3">\n      </span><span class="s1">name: string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error</span><span class="s3">\n  </span><span class="s1">const clientReferenceManifestsPerPage = globalThis[</span><span class="s3">\n    </span><span class="s1">SERVER_ACTION_MANIFESTS_SINGLETON</span><span class="s3">\n  </span><span class="s1">]?.clientReferenceManifestsPerPage as</span><span class="s3">\n    </span><span class="s1">| undefined</span><span class="s3">\n    </span><span class="s1">| DeepReadonly&lt;Record&lt;string, ClientReferenceManifest&gt;&gt;</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error</span><span class="s3">\n  </span><span class="s1">globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {</span><span class="s3">\n    </span><span class="s1">clientReferenceManifestsPerPage: {</span><span class="s3">\n      </span><span class="s1">...clientReferenceManifestsPerPage,</span><span class="s3">\n      </span><span class="s1">[normalizeAppPath(page)]: clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">serverActionsManifest,</span><span class="s3">\n    </span><span class="s1">serverModuleMap,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getServerModuleMap() {</span><span class="s3">\n  </span><span class="s1">const serverActionsManifestSingleton = (globalThis as any)[</span><span class="s3">\n    </span><span class="s1">SERVER_ACTION_MANIFESTS_SINGLETON</span><span class="s3">\n  </span><span class="s1">] as {</span><span class="s3">\n    </span><span class="s1">serverModuleMap: {</span><span class="s3">\n      </span><span class="s1">[id: string]: {</span><span class="s3">\n        </span><span class="s1">id: string</span><span class="s3">\n        </span><span class="s1">chunks: string[]</span><span class="s3">\n        </span><span class="s1">name: string</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!serverActionsManifestSingleton) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError('Missing manifest for Server Actions.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return serverActionsManifestSingleton.serverModuleMap</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getClientReferenceManifestForRsc(): DeepReadonly&lt;ClientReferenceManifestForRsc&gt; {</span><span class="s3">\n  </span><span class="s1">const serverActionsManifestSingleton = (globalThis as any)[</span><span class="s3">\n    </span><span class="s1">SERVER_ACTION_MANIFESTS_SINGLETON</span><span class="s3">\n  </span><span class="s1">] as {</span><span class="s3">\n    </span><span class="s1">clientReferenceManifestsPerPage: DeepReadonly&lt;</span><span class="s3">\n      </span><span class="s1">Record&lt;string, ClientReferenceManifest&gt;</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!serverActionsManifestSingleton) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError('Missing manifest for Server Actions.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { clientReferenceManifestsPerPage } = serverActionsManifestSingleton</span><span class="s3">\n  </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n\n  </span><span class="s1">if (!workStore) {</span><span class="s3">\n    </span><span class="s1">// If there's no work store defined, we can assume that a client reference</span><span class="s3">\n    </span><span class="s1">// manifest is needed during module evaluation, e.g. to create a server</span><span class="s3">\n    </span><span class="s1">// action using a higher-order function. This might also use client</span><span class="s3">\n    </span><span class="s1">// components which need to be serialized by Flight, and therefore client</span><span class="s3">\n    </span><span class="s1">// references need to be resolvable. To make this work, we're returning a</span><span class="s3">\n    </span><span class="s1">// merged manifest across all pages. This is fine as long as the module IDs</span><span class="s3">\n    </span><span class="s1">// are not page specific, which they are not for Webpack. TODO: Fix this in</span><span class="s3">\n    </span><span class="s1">// Turbopack.</span><span class="s3">\n    </span><span class="s1">return mergeClientReferenceManifests(clientReferenceManifestsPerPage)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const clientReferenceManifest =</span><span class="s3">\n    </span><span class="s1">clientReferenceManifestsPerPage[workStore.route]</span><span class="s3">\n\n  </span><span class="s1">if (!clientReferenceManifest) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      </span><span class="s1">`Missing Client Reference Manifest for ${workStore.route}.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return clientReferenceManifest</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function getActionEncryptionKey() {</span><span class="s3">\n  </span><span class="s1">if (__next_loaded_action_key) {</span><span class="s3">\n    </span><span class="s1">return __next_loaded_action_key</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const serverActionsManifestSingleton = (globalThis as any)[</span><span class="s3">\n    </span><span class="s1">SERVER_ACTION_MANIFESTS_SINGLETON</span><span class="s3">\n  </span><span class="s1">] as {</span><span class="s3">\n    </span><span class="s1">serverActionsManifest: DeepReadonly&lt;ActionManifest&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!serverActionsManifestSingleton) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError('Missing manifest for Server Actions.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const rawKey =</span><span class="s3">\n    </span><span class="s1">process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||</span><span class="s3">\n    </span><span class="s1">serverActionsManifestSingleton.serverActionsManifest.encryptionKey</span><span class="s3">\n\n  </span><span class="s1">if (rawKey === undefined) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError('Missing encryption key for Server Actions')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">__next_loaded_action_key = await crypto.subtle.importKey(</span><span class="s3">\n    </span><span class="s1">'raw',</span><span class="s3">\n    </span><span class="s1">stringToUint8Array(atob(rawKey)),</span><span class="s3">\n    </span><span class="s1">'AES-GCM',</span><span class="s3">\n    </span><span class="s1">true,</span><span class="s3">\n    </span><span class="s1">['encrypt', 'decrypt']</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return __next_loaded_action_key</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeClientReferenceManifests(</span><span class="s3">\n  </span><span class="s1">clientReferenceManifestsPerPage: DeepReadonly&lt;</span><span class="s3">\n    </span><span class="s1">Record&lt;string, ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">&gt;</span><span class="s3">\n</span><span class="s1">): ClientReferenceManifestForRsc {</span><span class="s3">\n  </span><span class="s1">const clientReferenceManifests = Object.values(</span><span class="s3">\n    </span><span class="s1">clientReferenceManifestsPerPage as Record&lt;string, ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const mergedClientReferenceManifest: ClientReferenceManifestForRsc = {</span><span class="s3">\n    </span><span class="s1">clientModules: {},</span><span class="s3">\n    </span><span class="s1">edgeRscModuleMapping: {},</span><span class="s3">\n    </span><span class="s1">rscModuleMapping: {},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const clientReferenceManifest of clientReferenceManifests) {</span><span class="s3">\n    </span><span class="s1">mergedClientReferenceManifest.clientModules = {</span><span class="s3">\n      </span><span class="s1">...mergedClientReferenceManifest.clientModules,</span><span class="s3">\n      </span><span class="s1">...clientReferenceManifest.clientModules,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mergedClientReferenceManifest.edgeRscModuleMapping = {</span><span class="s3">\n      </span><span class="s1">...mergedClientReferenceManifest.edgeRscModuleMapping,</span><span class="s3">\n      </span><span class="s1">...clientReferenceManifest.edgeRscModuleMapping,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mergedClientReferenceManifest.rscModuleMapping = {</span><span class="s3">\n      </span><span class="s1">...mergedClientReferenceManifest.rscModuleMapping,</span><span class="s3">\n      </span><span class="s1">...clientReferenceManifest.rscModuleMapping,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return mergedClientReferenceManifest</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">AppType,</span><span class="s3">\n  </span><span class="s1">DocumentType,</span><span class="s3">\n  </span><span class="s1">NextComponentType,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { ClientReferenceManifest } from '../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">PageConfig,</span><span class="s3">\n  </span><span class="s1">GetStaticPaths,</span><span class="s3">\n  </span><span class="s1">GetServerSideProps,</span><span class="s3">\n  </span><span class="s1">GetStaticProps,</span><span class="s3">\n</span><span class="s1">} from '../types'</span><span class="s3">\n</span><span class="s1">import type { RouteModule } from './route-modules/route-module'</span><span class="s3">\n</span><span class="s1">import type { BuildManifest } from './get-page-files'</span><span class="s3">\n</span><span class="s1">import type { ActionManifest } from '../build/webpack/plugins/flight-client-entry-plugin'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">BUILD_MANIFEST,</span><span class="s3">\n  </span><span class="s1">REACT_LOADABLE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">CLIENT_REFERENCE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SERVER_REFERENCE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">DYNAMIC_CSS_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SUBRESOURCE_INTEGRITY_MANIFEST,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { join } from 'path'</span><span class="s3">\n</span><span class="s1">import { requirePage } from './require'</span><span class="s3">\n</span><span class="s1">import { interopDefault } from '../lib/interop-default'</span><span class="s3">\n</span><span class="s1">import { getTracer } from './lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { LoadComponentsSpan } from './lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { evalManifest, loadManifest } from './load-manifest.external'</span><span class="s3">\n</span><span class="s1">import { wait } from '../lib/wait'</span><span class="s3">\n</span><span class="s1">import { setReferenceManifestsSingleton } from './app-render/encryption-utils'</span><span class="s3">\n</span><span class="s1">import { createServerModuleMap } from './app-render/action-utils'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n</span><span class="s1">import { isStaticMetadataRoute } from '../lib/metadata/is-metadata-route'</span><span class="s3">\n\n</span><span class="s1">export type ManifestItem = {</span><span class="s3">\n  </span><span class="s1">id: number | string</span><span class="s3">\n  </span><span class="s1">files: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReactLoadableManifest = { [moduleId: string]: ManifestItem }</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This manifest prevents removing server rendered &lt;link&gt; tags after client</span><span class="s3">\n </span><span class="s1">* navigation. This is only needed under `Pages dir &amp;&amp; Production &amp;&amp; Webpack`.</span><span class="s3">\n </span><span class="s1">* @see https://github.com/vercel/next.js/pull/72959</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type DynamicCssManifest = string[]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A manifest entry type for the react-loadable-manifest.json.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The whole manifest.json is a type of `Record&lt;pathname, LoadableManifest&gt;`</span><span class="s3">\n </span><span class="s1">* where pathname is a string-based key points to the path of the page contains</span><span class="s3">\n </span><span class="s1">* each dynamic imports.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface LoadableManifest {</span><span class="s3">\n  </span><span class="s1">[k: string]: { id: string | number; files: string[] }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type LoadComponentsReturnType&lt;NextModule = any&gt; = {</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType</span><span class="s3">\n  </span><span class="s1">pageConfig: PageConfig</span><span class="s3">\n  </span><span class="s1">buildManifest: DeepReadonly&lt;BuildManifest&gt;</span><span class="s3">\n  </span><span class="s1">subresourceIntegrityManifest?: DeepReadonly&lt;Record&lt;string, string&gt;&gt;</span><span class="s3">\n  </span><span class="s1">reactLoadableManifest: DeepReadonly&lt;ReactLoadableManifest&gt;</span><span class="s3">\n  </span><span class="s1">dynamicCssManifest?: DeepReadonly&lt;DynamicCssManifest&gt;</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest?: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">serverActionsManifest?: any</span><span class="s3">\n  </span><span class="s1">Document: DocumentType</span><span class="s3">\n  </span><span class="s1">App: AppType</span><span class="s3">\n  </span><span class="s1">getStaticProps?: GetStaticProps</span><span class="s3">\n  </span><span class="s1">getStaticPaths?: GetStaticPaths</span><span class="s3">\n  </span><span class="s1">getServerSideProps?: GetServerSideProps</span><span class="s3">\n  </span><span class="s1">ComponentMod: NextModule</span><span class="s3">\n  </span><span class="s1">routeModule: RouteModule</span><span class="s3">\n  </span><span class="s1">isAppPath?: boolean</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">multiZoneDraftMode?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Load manifest file with retries, defaults to 3 attempts.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function loadManifestWithRetries&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">manifestPath: string,</span><span class="s3">\n  </span><span class="s1">attempts = 3</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">return loadManifest&lt;T&gt;(manifestPath)</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">attempts--</span><span class="s3">\n      </span><span class="s1">if (attempts &lt;= 0) throw err</span><span class="s3">\n\n      </span><span class="s1">await wait(100)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Load manifest file with retries, defaults to 3 attempts, or return undefined.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function tryLoadManifestWithRetries&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">manifestPath: string,</span><span class="s3">\n  </span><span class="s1">attempts = 3</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return await loadManifestWithRetries&lt;T&gt;(manifestPath, attempts)</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Load manifest file with retries, defaults to 3 attempts.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function evalManifestWithRetries&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">manifestPath: string,</span><span class="s3">\n  </span><span class="s1">attempts = 3</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">return evalManifest&lt;T&gt;(manifestPath)</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">attempts--</span><span class="s3">\n      </span><span class="s1">if (attempts &lt;= 0) throw err</span><span class="s3">\n\n      </span><span class="s1">await wait(100)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function tryLoadClientReferenceManifest(</span><span class="s3">\n  </span><span class="s1">manifestPath: string,</span><span class="s3">\n  </span><span class="s1">entryName: string,</span><span class="s3">\n  </span><span class="s1">attempts?: number</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const context = await evalManifestWithRetries&lt;{</span><span class="s3">\n      </span><span class="s1">__RSC_MANIFEST: { [key: string]: ClientReferenceManifest }</span><span class="s3">\n    </span><span class="s1">}&gt;(manifestPath, attempts)</span><span class="s3">\n    </span><span class="s1">return context.__RSC_MANIFEST[entryName]</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function loadComponentsImpl&lt;N = any&gt;({</span><span class="s3">\n  </span><span class="s1">distDir,</span><span class="s3">\n  </span><span class="s1">page,</span><span class="s3">\n  </span><span class="s1">isAppPath,</span><span class="s3">\n  </span><span class="s1">isDev,</span><span class="s3">\n  </span><span class="s1">sriEnabled,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">distDir: string</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">isAppPath: boolean</span><span class="s3">\n  </span><span class="s1">isDev: boolean</span><span class="s3">\n  </span><span class="s1">sriEnabled: boolean</span><span class="s3">\n</span><span class="s1">}): Promise&lt;LoadComponentsReturnType&lt;N&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">let DocumentMod = {}</span><span class="s3">\n  </span><span class="s1">let AppMod = {}</span><span class="s3">\n  </span><span class="s1">if (!isAppPath) {</span><span class="s3">\n    </span><span class="s1">;[DocumentMod, AppMod] = await Promise.all([</span><span class="s3">\n      </span><span class="s1">requirePage('/_document', distDir, false),</span><span class="s3">\n      </span><span class="s1">requirePage('/_app', distDir, false),</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// In dev mode we retry loading a manifest file to handle a race condition</span><span class="s3">\n  </span><span class="s1">// that can occur while app and pages are compiling at the same time, and the</span><span class="s3">\n  </span><span class="s1">// build-manifest is still being written to disk while an app path is</span><span class="s3">\n  </span><span class="s1">// attempting to load.</span><span class="s3">\n  </span><span class="s1">const manifestLoadAttempts = isDev ? 3 : 1</span><span class="s3">\n\n  </span><span class="s1">let reactLoadableManifestPath</span><span class="s3">\n  </span><span class="s1">if (!process.env.TURBOPACK) {</span><span class="s3">\n    </span><span class="s1">reactLoadableManifestPath = join(distDir, REACT_LOADABLE_MANIFEST)</span><span class="s3">\n  </span><span class="s1">} else if (isAppPath) {</span><span class="s3">\n    </span><span class="s1">reactLoadableManifestPath = join(</span><span class="s3">\n      </span><span class="s1">distDir,</span><span class="s3">\n      </span><span class="s1">'server',</span><span class="s3">\n      </span><span class="s1">'app',</span><span class="s3">\n      </span><span class="s1">page,</span><span class="s3">\n      </span><span class="s1">REACT_LOADABLE_MANIFEST</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">reactLoadableManifestPath = join(</span><span class="s3">\n      </span><span class="s1">distDir,</span><span class="s3">\n      </span><span class="s1">'server',</span><span class="s3">\n      </span><span class="s1">'pages',</span><span class="s3">\n      </span><span class="s1">normalizePagePath(page),</span><span class="s3">\n      </span><span class="s1">REACT_LOADABLE_MANIFEST</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Make sure to avoid loading the manifest for static metadata routes for better performance.</span><span class="s3">\n  </span><span class="s1">const hasClientManifest = !isStaticMetadataRoute(page)</span><span class="s3">\n\n  </span><span class="s1">// Load the manifest files first</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Loading page-specific manifests shouldn't throw an error if the manifest couldn't be found, so</span><span class="s3">\n  </span><span class="s1">// that the `requirePage` call below will throw the correct error in that case</span><span class="s3">\n  </span><span class="s1">// (a `PageNotFoundError`).</span><span class="s3">\n  </span><span class="s1">const [</span><span class="s3">\n    </span><span class="s1">buildManifest,</span><span class="s3">\n    </span><span class="s1">reactLoadableManifest,</span><span class="s3">\n    </span><span class="s1">dynamicCssManifest,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">serverActionsManifest,</span><span class="s3">\n    </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n  </span><span class="s1">] = await Promise.all([</span><span class="s3">\n    </span><span class="s1">loadManifestWithRetries&lt;BuildManifest&gt;(</span><span class="s3">\n      </span><span class="s1">join(distDir, BUILD_MANIFEST),</span><span class="s3">\n      </span><span class="s1">manifestLoadAttempts</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">tryLoadManifestWithRetries&lt;ReactLoadableManifest&gt;(</span><span class="s3">\n      </span><span class="s1">reactLoadableManifestPath,</span><span class="s3">\n      </span><span class="s1">manifestLoadAttempts</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">// This manifest will only exist in Pages dir &amp;&amp; Production &amp;&amp; Webpack.</span><span class="s3">\n    </span><span class="s1">isAppPath || process.env.TURBOPACK</span><span class="s3">\n      </span><span class="s1">? undefined</span><span class="s3">\n      </span><span class="s1">: loadManifestWithRetries&lt;DynamicCssManifest&gt;(</span><span class="s3">\n          </span><span class="s1">join(distDir, `${DYNAMIC_CSS_MANIFEST}.json`),</span><span class="s3">\n          </span><span class="s1">manifestLoadAttempts</span><span class="s3">\n        </span><span class="s1">).catch(() =&gt; undefined),</span><span class="s3">\n    </span><span class="s1">isAppPath &amp;&amp; hasClientManifest</span><span class="s3">\n      </span><span class="s1">? tryLoadClientReferenceManifest(</span><span class="s3">\n          </span><span class="s1">join(</span><span class="s3">\n            </span><span class="s1">distDir,</span><span class="s3">\n            </span><span class="s1">'server',</span><span class="s3">\n            </span><span class="s1">'app',</span><span class="s3">\n            </span><span class="s1">page.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST + '.js'</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">page.replace(/%5F/g, '_'),</span><span class="s3">\n          </span><span class="s1">manifestLoadAttempts</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: undefined,</span><span class="s3">\n    </span><span class="s1">isAppPath</span><span class="s3">\n      </span><span class="s1">? loadManifestWithRetries&lt;ActionManifest&gt;(</span><span class="s3">\n          </span><span class="s1">join(distDir, 'server', SERVER_REFERENCE_MANIFEST + '.json'),</span><span class="s3">\n          </span><span class="s1">manifestLoadAttempts</span><span class="s3">\n        </span><span class="s1">).catch(() =&gt; null)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n    </span><span class="s1">sriEnabled</span><span class="s3">\n      </span><span class="s1">? loadManifestWithRetries&lt;DeepReadonly&lt;Record&lt;string, string&gt;&gt;&gt;(</span><span class="s3">\n          </span><span class="s1">join(distDir, 'server', SUBRESOURCE_INTEGRITY_MANIFEST + '.json')</span><span class="s3">\n        </span><span class="s1">).catch(() =&gt; undefined)</span><span class="s3">\n      </span><span class="s1">: undefined,</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n\n  </span><span class="s1">// Before requiring the actual page module, we have to set the reference</span><span class="s3">\n  </span><span class="s1">// manifests to our global store so Server Action's encryption util can access</span><span class="s3">\n  </span><span class="s1">// to them at the top level of the page module.</span><span class="s3">\n  </span><span class="s1">if (serverActionsManifest &amp;&amp; clientReferenceManifest) {</span><span class="s3">\n    </span><span class="s1">setReferenceManifestsSingleton({</span><span class="s3">\n      </span><span class="s1">page,</span><span class="s3">\n      </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n      </span><span class="s1">serverActionsManifest,</span><span class="s3">\n      </span><span class="s1">serverModuleMap: createServerModuleMap({</span><span class="s3">\n        </span><span class="s1">serverActionsManifest,</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const ComponentMod = await requirePage(page, distDir, isAppPath)</span><span class="s3">\n\n  </span><span class="s1">const Component = interopDefault(ComponentMod)</span><span class="s3">\n  </span><span class="s1">const Document = interopDefault(DocumentMod)</span><span class="s3">\n  </span><span class="s1">const App = interopDefault(AppMod)</span><span class="s3">\n\n  </span><span class="s1">const { getServerSideProps, getStaticProps, getStaticPaths, routeModule } =</span><span class="s3">\n    </span><span class="s1">ComponentMod</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">App,</span><span class="s3">\n    </span><span class="s1">Document,</span><span class="s3">\n    </span><span class="s1">Component,</span><span class="s3">\n    </span><span class="s1">buildManifest,</span><span class="s3">\n    </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n    </span><span class="s1">reactLoadableManifest: reactLoadableManifest || {},</span><span class="s3">\n    </span><span class="s1">dynamicCssManifest,</span><span class="s3">\n    </span><span class="s1">pageConfig: ComponentMod.config || {},</span><span class="s3">\n    </span><span class="s1">ComponentMod,</span><span class="s3">\n    </span><span class="s1">getServerSideProps,</span><span class="s3">\n    </span><span class="s1">getStaticProps,</span><span class="s3">\n    </span><span class="s1">getStaticPaths,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">serverActionsManifest,</span><span class="s3">\n    </span><span class="s1">isAppPath,</span><span class="s3">\n    </span><span class="s1">page,</span><span class="s3">\n    </span><span class="s1">routeModule,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const loadComponents = getTracer().wrap(</span><span class="s3">\n  </span><span class="s1">LoadComponentsSpan.loadComponents,</span><span class="s3">\n  </span><span class="s1">loadComponentsImpl</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from './work-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">// This function creates a Flight-acceptable server module map proxy from our</span><span class="s3">\n</span><span class="s1">// Server Reference Manifest similar to our client module map.</span><span class="s3">\n</span><span class="s1">// This is because our manifest contains a lot of internal Next.js data that</span><span class="s3">\n</span><span class="s1">// are relevant to the runtime, workers, etc. that React doesn't need to know.</span><span class="s3">\n</span><span class="s1">export function createServerModuleMap({</span><span class="s3">\n  </span><span class="s1">serverActionsManifest,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">serverActionsManifest: ActionManifest</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">return new Proxy(</span><span class="s3">\n    </span><span class="s1">{},</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">get: (_, id: string) =&gt; {</span><span class="s3">\n        </span><span class="s1">const workers =</span><span class="s3">\n          </span><span class="s1">serverActionsManifest[</span><span class="s3">\n            </span><span class="s1">process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'</span><span class="s3">\n          </span><span class="s1">]?.[id]?.workers</span><span class="s3">\n\n        </span><span class="s1">if (!workers) {</span><span class="s3">\n          </span><span class="s1">return undefined</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n\n        </span><span class="s1">let workerEntry:</span><span class="s3">\n          </span><span class="s1">| { moduleId: string | number; async: boolean }</span><span class="s3">\n          </span><span class="s1">| undefined</span><span class="s3">\n\n        </span><span class="s1">if (workStore) {</span><span class="s3">\n          </span><span class="s1">workerEntry = workers[normalizeWorkerPageName(workStore.page)]</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// If there's no work store defined, we can assume that a server</span><span class="s3">\n          </span><span class="s1">// module map is needed during module evaluation, e.g. to create a</span><span class="s3">\n          </span><span class="s1">// server action using a higher-order function. Therefore it should be</span><span class="s3">\n          </span><span class="s1">// safe to return any entry from the manifest that matches the action</span><span class="s3">\n          </span><span class="s1">// ID. They all refer to the same module ID, which must also exist in</span><span class="s3">\n          </span><span class="s1">// the current page bundle. TODO: This is currently not guaranteed in</span><span class="s3">\n          </span><span class="s1">// Turbopack, and needs to be fixed.</span><span class="s3">\n          </span><span class="s1">workerEntry = Object.values(workers).at(0)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (!workerEntry) {</span><span class="s3">\n          </span><span class="s1">return undefined</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const { moduleId, async } = workerEntry</span><span class="s3">\n\n        </span><span class="s1">return { id: moduleId, name: id, chunks: [], async }</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the requested action has a worker for the current page.</span><span class="s3">\n </span><span class="s1">* If not, it returns the first worker that has a handler for the action.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function selectWorkerForForwarding(</span><span class="s3">\n  </span><span class="s1">actionId: string,</span><span class="s3">\n  </span><span class="s1">pageName: string,</span><span class="s3">\n  </span><span class="s1">serverActionsManifest: ActionManifest</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const workers =</span><span class="s3">\n    </span><span class="s1">serverActionsManifest[</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'</span><span class="s3">\n    </span><span class="s1">][actionId]?.workers</span><span class="s3">\n  </span><span class="s1">const workerName = normalizeWorkerPageName(pageName)</span><span class="s3">\n\n  </span><span class="s1">// no workers, nothing to forward to</span><span class="s3">\n  </span><span class="s1">if (!workers) return</span><span class="s3">\n\n  </span><span class="s1">// if there is a worker for this page, no need to forward it.</span><span class="s3">\n  </span><span class="s1">if (workers[workerName]) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// otherwise, grab the first worker that has a handler for this action id</span><span class="s3">\n  </span><span class="s1">return denormalizeWorkerPageName(Object.keys(workers)[0])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The flight entry loader keys actions by bundlePath.</span><span class="s3">\n </span><span class="s1">* bundlePath corresponds with the relative path (including 'app') to the page entrypoint.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function normalizeWorkerPageName(pageName: string) {</span><span class="s3">\n  </span><span class="s1">if (pathHasPrefix(pageName, 'app')) {</span><span class="s3">\n    </span><span class="s1">return pageName</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return 'app' + pageName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a bundlePath (relative path to the entrypoint) to a routable page name</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function denormalizeWorkerPageName(bundlePath: string) {</span><span class="s3">\n  </span><span class="s1">return normalizeAppPath(removePathPrefix(bundlePath, 'app'))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { BaseNextRequest } from '../../../../server/base-http'</span><span class="s3">\n</span><span class="s1">import type { MiddlewareMatcher } from '../../../../build/analysis/get-page-static-info'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { matchHas } from './prepare-destination'</span><span class="s3">\n\n</span><span class="s1">export interface MiddlewareRouteMatch {</span><span class="s3">\n  </span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">pathname: string | null | undefined,</span><span class="s3">\n    </span><span class="s1">request: BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">query: Params</span><span class="s3">\n  </span><span class="s1">): boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getMiddlewareRouteMatcher(</span><span class="s3">\n  </span><span class="s1">matchers: MiddlewareMatcher[]</span><span class="s3">\n</span><span class="s1">): MiddlewareRouteMatch {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">pathname: string | null | undefined,</span><span class="s3">\n    </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">query: Params</span><span class="s3">\n  </span><span class="s1">) =&gt; {</span><span class="s3">\n    </span><span class="s1">for (const matcher of matchers) {</span><span class="s3">\n      </span><span class="s1">const routeMatch = new RegExp(matcher.regexp).exec(pathname!)</span><span class="s3">\n      </span><span class="s1">if (!routeMatch) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (matcher.has || matcher.missing) {</span><span class="s3">\n        </span><span class="s1">const hasParams = matchHas(req, query, matcher.has, matcher.missing)</span><span class="s3">\n        </span><span class="s1">if (!hasParams) {</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { SchedulerFn } from './scheduler'</span><span class="s3">\n\n</span><span class="s1">import { DetachedPromise } from './detached-promise'</span><span class="s3">\n\n</span><span class="s1">type CacheKeyFn&lt;K, C extends string | number | null&gt; = (</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">) =&gt; PromiseLike&lt;C&gt; | C</span><span class="s3">\n\n</span><span class="s1">type BatcherOptions&lt;K, C extends string | number | null&gt; = {</span><span class="s3">\n  </span><span class="s1">cacheKeyFn?: CacheKeyFn&lt;K, C&gt;</span><span class="s3">\n  </span><span class="s1">schedulerFn?: SchedulerFn&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type WorkFn&lt;V, C&gt; = (</span><span class="s3">\n  </span><span class="s1">key: C,</span><span class="s3">\n  </span><span class="s1">resolve: (value: V | PromiseLike&lt;V&gt;) =&gt; void</span><span class="s3">\n</span><span class="s1">) =&gt; Promise&lt;V&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A wrapper for a function that will only allow one call to the function to</span><span class="s3">\n </span><span class="s1">* execute at a time.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Batcher&lt;K, V, C extends string | number | null&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly pending = new Map&lt;C, Promise&lt;V&gt;&gt;()</span><span class="s3">\n\n  </span><span class="s1">protected constructor(</span><span class="s3">\n    </span><span class="s1">private readonly cacheKeyFn?: CacheKeyFn&lt;K, C&gt;,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A function that will be called to schedule the wrapped function to be</span><span class="s3">\n     </span><span class="s1">* executed. This defaults to a function that will execute the function</span><span class="s3">\n     </span><span class="s1">* immediately.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">private readonly schedulerFn: SchedulerFn&lt;void&gt; = (fn) =&gt; fn()</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a new instance of PendingWrapper. If the key extends a string or</span><span class="s3">\n   </span><span class="s1">* number, the key will be used as the cache key. If the key is an object, a</span><span class="s3">\n   </span><span class="s1">* cache key function must be provided.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static create&lt;K extends string | number | null, V&gt;(</span><span class="s3">\n    </span><span class="s1">options?: BatcherOptions&lt;K, K&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, K&gt;</span><span class="s3">\n  </span><span class="s1">public static create&lt;K, V, C extends string | number | null&gt;(</span><span class="s3">\n    </span><span class="s1">options: BatcherOptions&lt;K, C&gt; &amp;</span><span class="s3">\n      </span><span class="s1">Required&lt;Pick&lt;BatcherOptions&lt;K, C&gt;, 'cacheKeyFn'&gt;&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, C&gt;</span><span class="s3">\n  </span><span class="s1">public static create&lt;K, V, C extends string | number | null&gt;(</span><span class="s3">\n    </span><span class="s1">options?: BatcherOptions&lt;K, C&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, C&gt; {</span><span class="s3">\n    </span><span class="s1">return new Batcher&lt;K, V, C&gt;(options?.cacheKeyFn, options?.schedulerFn)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Wraps a function in a promise that will be resolved or rejected only once</span><span class="s3">\n   </span><span class="s1">* for a given key. This will allow multiple calls to the function to be</span><span class="s3">\n   </span><span class="s1">* made, but only one will be executed at a time. The result of the first</span><span class="s3">\n   </span><span class="s1">* call will be returned to all callers.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param key the key to use for the cache</span><span class="s3">\n   </span><span class="s1">* @param fn the function to wrap</span><span class="s3">\n   </span><span class="s1">* @returns a promise that resolves to the result of the function</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async batch(key: K, fn: WorkFn&lt;V, C&gt;): Promise&lt;V&gt; {</span><span class="s3">\n    </span><span class="s1">const cacheKey = (this.cacheKeyFn ? await this.cacheKeyFn(key) : key) as C</span><span class="s3">\n    </span><span class="s1">if (cacheKey === null) {</span><span class="s3">\n      </span><span class="s1">return fn(cacheKey, Promise.resolve)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const pending = this.pending.get(cacheKey)</span><span class="s3">\n    </span><span class="s1">if (pending) return pending</span><span class="s3">\n\n    </span><span class="s1">const { promise, resolve, reject } = new DetachedPromise&lt;V&gt;()</span><span class="s3">\n    </span><span class="s1">this.pending.set(cacheKey, promise)</span><span class="s3">\n\n    </span><span class="s1">this.schedulerFn(async () =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const result = await fn(cacheKey, resolve)</span><span class="s3">\n\n        </span><span class="s1">// Resolving a promise multiple times is a no-op, so we can safely</span><span class="s3">\n        </span><span class="s1">// resolve all pending promises with the same result.</span><span class="s3">\n        </span><span class="s1">resolve(result)</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">reject(err)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">this.pending.delete(cacheKey)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">return promise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export type ScheduledFn&lt;T = void&gt; = () =&gt; T | PromiseLike&lt;T&gt;</span><span class="s3">\n</span><span class="s1">export type SchedulerFn&lt;T = void&gt; = (cb: ScheduledFn&lt;T&gt;) =&gt; void</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Schedules a function to be called on the next tick after the other promises</span><span class="s3">\n </span><span class="s1">* have been resolved.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cb the function to schedule</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const scheduleOnNextTick = (cb: ScheduledFn&lt;void&gt;) =&gt; {</span><span class="s3">\n  </span><span class="s1">// We use Promise.resolve().then() here so that the operation is scheduled at</span><span class="s3">\n  </span><span class="s1">// the end of the promise job queue, we then add it to the next process tick</span><span class="s3">\n  </span><span class="s1">// to ensure it's evaluated afterwards.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">Promise.resolve().then(() =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">setTimeout(cb, 0)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">process.nextTick(cb)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Schedules a function to be called using `setImmediate` or `setTimeout` if</span><span class="s3">\n </span><span class="s1">* `setImmediate` is not available (like in the Edge runtime).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cb the function to schedule</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const scheduleImmediate = (cb: ScheduledFn&lt;void&gt;): void =&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">setTimeout(cb, 0)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">setImmediate(cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* returns a promise than resolves in a future task. There is no guarantee that the task it resolves in</span><span class="s3">\n </span><span class="s1">* will be the next task but if you await it you can at least be sure that the current task is over and</span><span class="s3">\n </span><span class="s1">* most usefully that the entire microtask queue of the current task has been emptied.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function atLeastOneTask() {</span><span class="s3">\n  </span><span class="s1">return new Promise&lt;void&gt;((resolve) =&gt; scheduleImmediate(resolve))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This utility function is extracted to make it easier to find places where we are doing</span><span class="s3">\n </span><span class="s1">* specific timing tricks to try to schedule work after React has rendered. This is especially</span><span class="s3">\n </span><span class="s1">* important at the moment because Next.js uses the edge builds of React which use setTimeout to</span><span class="s3">\n </span><span class="s1">* schedule work when you might expect that something like setImmediate would do the trick.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Long term we should switch to the node versions of React rendering when possible and then</span><span class="s3">\n </span><span class="s1">* update this to use setImmediate rather than setTimeout</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function waitAtLeastOneReactRenderTask(): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">return new Promise((r) =&gt; setTimeout(r, 0))</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return new Promise((r) =&gt; setImmediate(r))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type RenderResult from '../render-result'</span><span class="s3">\n</span><span class="s1">import type { CacheControl, Revalidate } from '../lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export interface ResponseCacheBase {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">key: string | null,</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator,</span><span class="s3">\n    </span><span class="s1">context: {</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n      </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n      </span><span class="s1">incrementalCache: IncrementalCache</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* This is a hint to the cache to help it determine what kind of route</span><span class="s3">\n       </span><span class="s1">* this is so it knows where to look up the cache entry from. If not</span><span class="s3">\n       </span><span class="s1">* provided it will test the filesystem to check.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">isFallback?: boolean</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// The server components HMR cache might store other data as well in the future,</span><span class="s3">\n</span><span class="s1">// at which point this should be refactored to a discriminated union type.</span><span class="s3">\n</span><span class="s1">export interface ServerComponentsHmrCache {</span><span class="s3">\n  </span><span class="s1">get(key: string): CachedFetchData | undefined</span><span class="s3">\n  </span><span class="s1">set(key: string, data: CachedFetchData): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type CachedFetchData = {</span><span class="s3">\n  </span><span class="s1">headers: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">body: string</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">status?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const enum CachedRouteKind {</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">FETCH = 'FETCH',</span><span class="s3">\n  </span><span class="s1">REDIRECT = 'REDIRECT',</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedFetchValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.FETCH</span><span class="s3">\n  </span><span class="s1">data: CachedFetchData</span><span class="s3">\n  </span><span class="s1">// tags are only present with file-system-cache</span><span class="s3">\n  </span><span class="s1">// fetch cache stores tags outside of cache entry</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">revalidate: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedRedirectValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.REDIRECT</span><span class="s3">\n  </span><span class="s1">props: Object</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedAppPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_PAGE</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">html: RenderResult</span><span class="s3">\n  </span><span class="s1">rscData: Buffer | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">postponed: string | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">segmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.PAGES</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">html: RenderResult</span><span class="s3">\n  </span><span class="s1">pageData: Object</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedRouteValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_ROUTE</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">body: Buffer</span><span class="s3">\n  </span><span class="s1">status: number</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedImageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.IMAGE</span><span class="s3">\n  </span><span class="s1">etag: string</span><span class="s3">\n  </span><span class="s1">upstreamEtag: string</span><span class="s3">\n  </span><span class="s1">buffer: Buffer</span><span class="s3">\n  </span><span class="s1">extension: string</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n  </span><span class="s1">isStale?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCachedAppPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_PAGE</span><span class="s3">\n  </span><span class="s1">// this needs to be a string since the cache expects to store</span><span class="s3">\n  </span><span class="s1">// the string value</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">rscData: Buffer | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">postponed: string | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">segmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCachedPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.PAGES</span><span class="s3">\n  </span><span class="s1">// this needs to be a string since the cache expects to store</span><span class="s3">\n  </span><span class="s1">// the string value</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">pageData: Object</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalResponseCacheEntry {</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* timestamp in milliseconds to revalidate after</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">revalidateAfter?: Revalidate</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `-1` here dictates a blocking revalidate should be used</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n  </span><span class="s1">value: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalFetchCacheEntry {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `-1` here dictates a blocking revalidate should be used</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">value: CachedFetchValue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type IncrementalCacheEntry =</span><span class="s3">\n  </span><span class="s1">| IncrementalResponseCacheEntry</span><span class="s3">\n  </span><span class="s1">| IncrementalFetchCacheEntry</span><span class="s3">\n\n</span><span class="s1">export type IncrementalCacheValue =</span><span class="s3">\n  </span><span class="s1">| CachedRedirectValue</span><span class="s3">\n  </span><span class="s1">| IncrementalCachedPageValue</span><span class="s3">\n  </span><span class="s1">| IncrementalCachedAppPageValue</span><span class="s3">\n  </span><span class="s1">| CachedImageValue</span><span class="s3">\n  </span><span class="s1">| CachedFetchValue</span><span class="s3">\n  </span><span class="s1">| CachedRouteValue</span><span class="s3">\n\n</span><span class="s1">export type ResponseCacheValue =</span><span class="s3">\n  </span><span class="s1">| CachedRedirectValue</span><span class="s3">\n  </span><span class="s1">| CachedPageValue</span><span class="s3">\n  </span><span class="s1">| CachedAppPageValue</span><span class="s3">\n  </span><span class="s1">| CachedImageValue</span><span class="s3">\n  </span><span class="s1">| CachedRouteValue</span><span class="s3">\n\n</span><span class="s1">export type ResponseCacheEntry = {</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">value: ResponseCacheValue | null</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param hasResolved whether the responseGenerator has resolved it's promise</span><span class="s3">\n </span><span class="s1">* @param previousCacheEntry the previous cache entry if it exists or the current</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type ResponseGenerator = (state: {</span><span class="s3">\n  </span><span class="s1">hasResolved: boolean</span><span class="s3">\n  </span><span class="s1">previousCacheEntry?: IncrementalResponseCacheEntry | null</span><span class="s3">\n  </span><span class="s1">isRevalidating?: boolean</span><span class="s3">\n  </span><span class="s1">span?: any</span><span class="s3">\n</span><span class="s1">}) =&gt; Promise&lt;ResponseCacheEntry | null&gt;</span><span class="s3">\n\n</span><span class="s1">export const enum IncrementalCacheKind {</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">FETCH = 'FETCH',</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface GetIncrementalFetchCacheContext {</span><span class="s3">\n  </span><span class="s1">kind: IncrementalCacheKind.FETCH</span><span class="s3">\n  </span><span class="s1">revalidate?: Revalidate</span><span class="s3">\n  </span><span class="s1">fetchUrl?: string</span><span class="s3">\n  </span><span class="s1">fetchIdx?: number</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">softTags?: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface GetIncrementalResponseCacheContext {</span><span class="s3">\n  </span><span class="s1">kind: Exclude&lt;IncrementalCacheKind, IncrementalCacheKind.FETCH&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isFallback: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface SetIncrementalFetchCacheContext {</span><span class="s3">\n  </span><span class="s1">fetchCache: true</span><span class="s3">\n  </span><span class="s1">fetchUrl?: string</span><span class="s3">\n  </span><span class="s1">fetchIdx?: number</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">isImplicitBuildTimeCache?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface SetIncrementalResponseCacheContext {</span><span class="s3">\n  </span><span class="s1">fetchCache?: false</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isFallback?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalResponseCache {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCache extends IncrementalResponseCache {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalFetchCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: CachedFetchValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedAppPageValue,</span><span class="s3">\n  </span><span class="s1">type CachedPageValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">type ResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n\n</span><span class="s1">import RenderResult from '../render-result'</span><span class="s3">\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import { HTML_CONTENT_TYPE_HEADER } from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">export async function fromResponseCacheEntry(</span><span class="s3">\n  </span><span class="s1">cacheEntry: ResponseCacheEntry</span><span class="s3">\n</span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry&gt; {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...cacheEntry,</span><span class="s3">\n    </span><span class="s1">value:</span><span class="s3">\n      </span><span class="s1">cacheEntry.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n        </span><span class="s1">? {</span><span class="s3">\n            </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">html: await cacheEntry.value.html.toUnchunkedString(true),</span><span class="s3">\n            </span><span class="s1">pageData: cacheEntry.value.pageData,</span><span class="s3">\n            </span><span class="s1">headers: cacheEntry.value.headers,</span><span class="s3">\n            </span><span class="s1">status: cacheEntry.value.status,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: cacheEntry.value?.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n          </span><span class="s1">? {</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n              </span><span class="s1">html: await cacheEntry.value.html.toUnchunkedString(true),</span><span class="s3">\n              </span><span class="s1">postponed: cacheEntry.value.postponed,</span><span class="s3">\n              </span><span class="s1">rscData: cacheEntry.value.rscData,</span><span class="s3">\n              </span><span class="s1">headers: cacheEntry.value.headers,</span><span class="s3">\n              </span><span class="s1">status: cacheEntry.value.status,</span><span class="s3">\n              </span><span class="s1">segmentData: cacheEntry.value.segmentData,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">: cacheEntry.value,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function toResponseCacheEntry(</span><span class="s3">\n  </span><span class="s1">response: IncrementalResponseCacheEntry | null</span><span class="s3">\n</span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt; {</span><span class="s3">\n  </span><span class="s1">if (!response) return null</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">isMiss: response.isMiss,</span><span class="s3">\n    </span><span class="s1">isStale: response.isStale,</span><span class="s3">\n    </span><span class="s1">cacheControl: response.cacheControl,</span><span class="s3">\n    </span><span class="s1">value:</span><span class="s3">\n      </span><span class="s1">response.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n        </span><span class="s1">? ({</span><span class="s3">\n            </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">html: RenderResult.fromStatic(</span><span class="s3">\n              </span><span class="s1">response.value.html,</span><span class="s3">\n              </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">pageData: response.value.pageData,</span><span class="s3">\n            </span><span class="s1">headers: response.value.headers,</span><span class="s3">\n            </span><span class="s1">status: response.value.status,</span><span class="s3">\n          </span><span class="s1">} satisfies CachedPageValue)</span><span class="s3">\n        </span><span class="s1">: response.value?.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n          </span><span class="s1">? ({</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n              </span><span class="s1">html: RenderResult.fromStatic(</span><span class="s3">\n                </span><span class="s1">response.value.html,</span><span class="s3">\n                </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">rscData: response.value.rscData,</span><span class="s3">\n              </span><span class="s1">headers: response.value.headers,</span><span class="s3">\n              </span><span class="s1">status: response.value.status,</span><span class="s3">\n              </span><span class="s1">postponed: response.value.postponed,</span><span class="s3">\n              </span><span class="s1">segmentData: response.value.segmentData,</span><span class="s3">\n            </span><span class="s1">} satisfies CachedAppPageValue)</span><span class="s3">\n          </span><span class="s1">: response.value,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function routeKindToIncrementalCacheKind(</span><span class="s3">\n  </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n</span><span class="s1">): Exclude&lt;IncrementalCacheKind, IncrementalCacheKind.FETCH&gt; {</span><span class="s3">\n  </span><span class="s1">switch (routeKind) {</span><span class="s3">\n    </span><span class="s1">case RouteKind.PAGES:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.PAGES</span><span class="s3">\n    </span><span class="s1">case RouteKind.APP_PAGE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.APP_PAGE</span><span class="s3">\n    </span><span class="s1">case RouteKind.IMAGE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.IMAGE</span><span class="s3">\n    </span><span class="s1">case RouteKind.APP_ROUTE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n    </span><span class="s1">case RouteKind.PAGES_API:</span><span class="s3">\n      </span><span class="s1">// Pages Router API routes are not cached in the incremental cache.</span><span class="s3">\n      </span><span class="s1">throw new Error(`Unexpected route kind ${routeKind}`)</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return routeKind satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">ResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">ResponseGenerator,</span><span class="s3">\n  </span><span class="s1">ResponseCacheBase,</span><span class="s3">\n  </span><span class="s1">IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">IncrementalResponseCache,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n\n</span><span class="s1">import { Batcher } from '../../lib/batcher'</span><span class="s3">\n</span><span class="s1">import { scheduleOnNextTick } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">fromResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">routeKindToIncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">toResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './utils'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export * from './types'</span><span class="s3">\n\n</span><span class="s1">export default class ResponseCache implements ResponseCacheBase {</span><span class="s3">\n  </span><span class="s1">private readonly batcher = Batcher.create&lt;</span><span class="s3">\n    </span><span class="s1">{ key: string; isOnDemandRevalidate: boolean },</span><span class="s3">\n    </span><span class="s1">IncrementalResponseCacheEntry | null,</span><span class="s3">\n    </span><span class="s1">string</span><span class="s3">\n  </span><span class="s1">&gt;({</span><span class="s3">\n    </span><span class="s1">// Ensure on-demand revalidate doesn't block normal requests, it should be</span><span class="s3">\n    </span><span class="s1">// safe to run an on-demand revalidate for the same key as a normal request.</span><span class="s3">\n    </span><span class="s1">cacheKeyFn: ({ key, isOnDemandRevalidate }) =&gt;</span><span class="s3">\n      </span><span class="s1">`${key}-${isOnDemandRevalidate ? '1' : '0'}`,</span><span class="s3">\n    </span><span class="s1">// We wait to do any async work until after we've added our promise to</span><span class="s3">\n    </span><span class="s1">// `pendingResponses` to ensure that any any other calls will reuse the</span><span class="s3">\n    </span><span class="s1">// same promise until we've fully finished our work.</span><span class="s3">\n    </span><span class="s1">schedulerFn: scheduleOnNextTick,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">private previousCacheItem?: {</span><span class="s3">\n    </span><span class="s1">key: string</span><span class="s3">\n    </span><span class="s1">entry: IncrementalResponseCacheEntry | null</span><span class="s3">\n    </span><span class="s1">expiresAt: number</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// we don't use minimal_mode name here as this.minimal_mode is</span><span class="s3">\n  </span><span class="s1">// statically replace for server runtimes but we need it to</span><span class="s3">\n  </span><span class="s1">// be dynamic here</span><span class="s3">\n  </span><span class="s1">private minimal_mode?: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(minimal_mode: boolean) {</span><span class="s3">\n    </span><span class="s1">this.minimal_mode = minimal_mode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async get(</span><span class="s3">\n    </span><span class="s1">key: string | null,</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator,</span><span class="s3">\n    </span><span class="s1">context: {</span><span class="s3">\n      </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n      </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n      </span><span class="s1">incrementalCache: IncrementalResponseCache</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n      </span><span class="s1">isFallback?: boolean</span><span class="s3">\n      </span><span class="s1">waitUntil?: (prom: Promise&lt;any&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">// If there is no key for the cache, we can't possibly look this up in the</span><span class="s3">\n    </span><span class="s1">// cache so just return the result of the response generator.</span><span class="s3">\n    </span><span class="s1">if (!key) {</span><span class="s3">\n      </span><span class="s1">return responseGenerator({ hasResolved: false, previousCacheEntry: null })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">incrementalCache,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate = false,</span><span class="s3">\n      </span><span class="s1">isFallback = false,</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled = false,</span><span class="s3">\n      </span><span class="s1">waitUntil,</span><span class="s3">\n    </span><span class="s1">} = context</span><span class="s3">\n\n    </span><span class="s1">const response = await this.batcher.batch(</span><span class="s3">\n      </span><span class="s1">{ key, isOnDemandRevalidate },</span><span class="s3">\n      </span><span class="s1">(cacheKey, resolve) =&gt; {</span><span class="s3">\n        </span><span class="s1">const prom = (async () =&gt; {</span><span class="s3">\n          </span><span class="s1">// We keep the previous cache entry around to leverage when the</span><span class="s3">\n          </span><span class="s1">// incremental cache is disabled in minimal mode.</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">this.minimal_mode &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.previousCacheItem?.key === cacheKey &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.previousCacheItem.expiresAt &gt; Date.now()</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return this.previousCacheItem.entry</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Coerce the kindHint into a given kind for the incremental cache.</span><span class="s3">\n          </span><span class="s1">const kind = routeKindToIncrementalCacheKind(context.routeKind)</span><span class="s3">\n\n          </span><span class="s1">let resolved = false</span><span class="s3">\n          </span><span class="s1">let cachedResponse: IncrementalResponseCacheEntry | null = null</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">cachedResponse = !this.minimal_mode</span><span class="s3">\n              </span><span class="s1">? await incrementalCache.get(key, {</span><span class="s3">\n                  </span><span class="s1">kind,</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled: context.isRoutePPREnabled,</span><span class="s3">\n                  </span><span class="s1">isFallback,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">: null</span><span class="s3">\n\n            </span><span class="s1">if (cachedResponse &amp;&amp; !isOnDemandRevalidate) {</span><span class="s3">\n              </span><span class="s1">resolve(cachedResponse)</span><span class="s3">\n              </span><span class="s1">resolved = true</span><span class="s3">\n\n              </span><span class="s1">if (!cachedResponse.isStale || context.isPrefetch) {</span><span class="s3">\n                </span><span class="s1">// The cached value is still valid, so we don't need</span><span class="s3">\n                </span><span class="s1">// to update it yet.</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const cacheEntry = await responseGenerator({</span><span class="s3">\n              </span><span class="s1">hasResolved: resolved,</span><span class="s3">\n              </span><span class="s1">previousCacheEntry: cachedResponse,</span><span class="s3">\n              </span><span class="s1">isRevalidating: true,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">// If the cache entry couldn't be generated, we don't want to cache</span><span class="s3">\n            </span><span class="s1">// the result.</span><span class="s3">\n            </span><span class="s1">if (!cacheEntry) {</span><span class="s3">\n              </span><span class="s1">// Unset the previous cache item if it was set.</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) this.previousCacheItem = undefined</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const resolveValue = await fromResponseCacheEntry({</span><span class="s3">\n              </span><span class="s1">...cacheEntry,</span><span class="s3">\n              </span><span class="s1">isMiss: !cachedResponse,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">if (!resolveValue) {</span><span class="s3">\n              </span><span class="s1">// Unset the previous cache item if it was set.</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) this.previousCacheItem = undefined</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// For on-demand revalidate wait to resolve until cache is set.</span><span class="s3">\n            </span><span class="s1">// Otherwise resolve now.</span><span class="s3">\n            </span><span class="s1">if (!isOnDemandRevalidate &amp;&amp; !resolved) {</span><span class="s3">\n              </span><span class="s1">resolve(resolveValue)</span><span class="s3">\n              </span><span class="s1">resolved = true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// We want to persist the result only if it has a cache control value</span><span class="s3">\n            </span><span class="s1">// defined.</span><span class="s3">\n            </span><span class="s1">if (resolveValue.cacheControl) {</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) {</span><span class="s3">\n                </span><span class="s1">this.previousCacheItem = {</span><span class="s3">\n                  </span><span class="s1">key: cacheKey,</span><span class="s3">\n                  </span><span class="s1">entry: resolveValue,</span><span class="s3">\n                  </span><span class="s1">expiresAt: Date.now() + 1000,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">await incrementalCache.set(key, resolveValue.value, {</span><span class="s3">\n                  </span><span class="s1">cacheControl: resolveValue.cacheControl,</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n                  </span><span class="s1">isFallback,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return resolveValue</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">// When a path is erroring we automatically re-set the existing cache</span><span class="s3">\n            </span><span class="s1">// with new revalidate and expire times to prevent non-stop retrying.</span><span class="s3">\n            </span><span class="s1">if (cachedResponse?.cacheControl) {</span><span class="s3">\n              </span><span class="s1">const newRevalidate = Math.min(</span><span class="s3">\n                </span><span class="s1">Math.max(cachedResponse.cacheControl.revalidate || 3, 3),</span><span class="s3">\n                </span><span class="s1">30</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">const newExpire =</span><span class="s3">\n                </span><span class="s1">cachedResponse.cacheControl.expire === undefined</span><span class="s3">\n                  </span><span class="s1">? undefined</span><span class="s3">\n                  </span><span class="s1">: Math.max(</span><span class="s3">\n                      </span><span class="s1">newRevalidate + 3,</span><span class="s3">\n                      </span><span class="s1">cachedResponse.cacheControl.expire</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">await incrementalCache.set(key, cachedResponse.value, {</span><span class="s3">\n                </span><span class="s1">cacheControl: { revalidate: newRevalidate, expire: newExpire },</span><span class="s3">\n                </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n                </span><span class="s1">isFallback,</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// While revalidating in the background we can't reject as we already</span><span class="s3">\n            </span><span class="s1">// resolved the cache entry so log the error here.</span><span class="s3">\n            </span><span class="s1">if (resolved) {</span><span class="s3">\n              </span><span class="s1">console.error(err)</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// We haven't resolved yet, so let's throw to indicate an error.</span><span class="s3">\n            </span><span class="s1">throw err</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})()</span><span class="s3">\n\n        </span><span class="s1">// we need to ensure background revalidates are</span><span class="s3">\n        </span><span class="s1">// passed to waitUntil</span><span class="s3">\n        </span><span class="s1">if (waitUntil) {</span><span class="s3">\n          </span><span class="s1">waitUntil(prom)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return prom</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return toResponseCacheEntry(response)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from '../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import type { CacheFs } from '../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A task to be written.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type Task = [</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The directory to create.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">directory: string,</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The promise to create the directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mkdir: Promise&lt;unknown&gt;,</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The promises to write the files that are dependent on the directory being</span><span class="s3">\n   </span><span class="s1">* created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeFile: Promise&lt;unknown&gt;[],</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* MultiFileWriter is a utility for writing multiple files in parallel that</span><span class="s3">\n </span><span class="s1">* guarantees that all files will be written after their containing directory</span><span class="s3">\n </span><span class="s1">* is created, and that the directory will only be created once.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class MultiFileWriter {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The tasks to be written.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly tasks: Task[] = []</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The file system methods to use.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">private readonly fs: Pick&lt;CacheFs, 'mkdir' | 'writeFile'&gt;</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Finds or creates a task for a directory.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param directory - The directory to find or create a task for.</span><span class="s3">\n   </span><span class="s1">* @returns The task for the directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private findOrCreateTask(directory: string): Task {</span><span class="s3">\n    </span><span class="s1">// See if this directory already has a task to create it.</span><span class="s3">\n    </span><span class="s1">for (const task of this.tasks) {</span><span class="s3">\n      </span><span class="s1">if (task[0] === directory) {</span><span class="s3">\n        </span><span class="s1">return task</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const promise = this.fs.mkdir(directory)</span><span class="s3">\n\n    </span><span class="s1">// Attach a catch handler so that it doesn't throw an unhandled promise</span><span class="s3">\n    </span><span class="s1">// rejection warning.</span><span class="s3">\n    </span><span class="s1">promise.catch(() =&gt; {})</span><span class="s3">\n\n    </span><span class="s1">// Otherwise, create a new task for this directory.</span><span class="s3">\n    </span><span class="s1">const task: Task = [directory, promise, []]</span><span class="s3">\n    </span><span class="s1">this.tasks.push(task)</span><span class="s3">\n\n    </span><span class="s1">return task</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Appends a file to the writer to be written after its containing directory</span><span class="s3">\n   </span><span class="s1">* is created. The file writer should be awaited after all the files have been</span><span class="s3">\n   </span><span class="s1">* appended. Any async operation that occurs between appending and awaiting</span><span class="s3">\n   </span><span class="s1">* may cause an unhandled promise rejection warning and potentially crash the</span><span class="s3">\n   </span><span class="s1">* process.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param filePath - The path to the file to write.</span><span class="s3">\n   </span><span class="s1">* @param data - The data to write to the file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public append(filePath: string, data: Buffer | string): void {</span><span class="s3">\n    </span><span class="s1">// Find or create a task for the directory that contains the file.</span><span class="s3">\n    </span><span class="s1">const task = this.findOrCreateTask(path.dirname(filePath))</span><span class="s3">\n\n    </span><span class="s1">const promise = task[1].then(() =&gt; this.fs.writeFile(filePath, data))</span><span class="s3">\n\n    </span><span class="s1">// Attach a catch handler so that it doesn't throw an unhandled promise</span><span class="s3">\n    </span><span class="s1">// rejection warning.</span><span class="s3">\n    </span><span class="s1">promise.catch(() =&gt; {})</span><span class="s3">\n\n    </span><span class="s1">// Add the file write to the task AFTER the directory promise has resolved.</span><span class="s3">\n    </span><span class="s1">task[2].push(promise)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a promise that resolves when all the files have been written.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public wait(): Promise&lt;unknown&gt; {</span><span class="s3">\n    </span><span class="s1">return Promise.all(this.tasks.flatMap((task) =&gt; task[2]))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RouteMetadata } from '../../../export/routes/types'</span><span class="s3">\n</span><span class="s1">import type { CacheHandler, CacheHandlerContext, CacheHandlerValue } from '.'</span><span class="s3">\n</span><span class="s1">import type { CacheFs } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedFetchValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalResponseCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n\n</span><span class="s1">import type { LRUCache } from '../lru-cache'</span><span class="s3">\n</span><span class="s1">import path from '../../../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_DATA_SUFFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_META_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_PREFETCH_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENT_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SUFFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { isStale, tagsManifest } from './tags-manifest.external'</span><span class="s3">\n</span><span class="s1">import { MultiFileWriter } from '../../../lib/multi-file-writer'</span><span class="s3">\n</span><span class="s1">import { getMemoryCache } from './memory-cache.external'</span><span class="s3">\n\n</span><span class="s1">type FileSystemCacheContext = Omit&lt;</span><span class="s3">\n  </span><span class="s1">CacheHandlerContext,</span><span class="s3">\n  </span><span class="s1">'fs' | 'serverDistDir'</span><span class="s3">\n</span><span class="s1">&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">fs: CacheFs</span><span class="s3">\n  </span><span class="s1">serverDistDir: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class FileSystemCache implements CacheHandler {</span><span class="s3">\n  </span><span class="s1">private fs: FileSystemCacheContext['fs']</span><span class="s3">\n  </span><span class="s1">private flushToDisk?: FileSystemCacheContext['flushToDisk']</span><span class="s3">\n  </span><span class="s1">private serverDistDir: FileSystemCacheContext['serverDistDir']</span><span class="s3">\n  </span><span class="s1">private revalidatedTags: string[]</span><span class="s3">\n  </span><span class="s1">private static debug: boolean = !!process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">private static memoryCache: LRUCache&lt;CacheHandlerValue&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(ctx: FileSystemCacheContext) {</span><span class="s3">\n    </span><span class="s1">this.fs = ctx.fs</span><span class="s3">\n    </span><span class="s1">this.flushToDisk = ctx.flushToDisk</span><span class="s3">\n    </span><span class="s1">this.serverDistDir = ctx.serverDistDir</span><span class="s3">\n    </span><span class="s1">this.revalidatedTags = ctx.revalidatedTags</span><span class="s3">\n\n    </span><span class="s1">if (ctx.maxMemoryCacheSize) {</span><span class="s3">\n      </span><span class="s1">if (!FileSystemCache.memoryCache) {</span><span class="s3">\n        </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n          </span><span class="s1">console.log('using memory store for fetch cache')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">FileSystemCache.memoryCache = getMemoryCache(ctx.maxMemoryCacheSize)</span><span class="s3">\n      </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n        </span><span class="s1">console.log('memory store already initialized')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('not using memory store for fetch cache')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public resetRequestCache(): void {}</span><span class="s3">\n\n  </span><span class="s1">public async revalidateTag(</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;CacheHandler['revalidateTag']&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let [tags] = args</span><span class="s3">\n    </span><span class="s1">tags = typeof tags === 'string' ? [tags] : tags</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('revalidateTag', tags)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (tags.length === 0) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const tag of tags) {</span><span class="s3">\n      </span><span class="s1">if (!tagsManifest.has(tag)) {</span><span class="s3">\n        </span><span class="s1">tagsManifest.set(tag, Date.now())</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async get(...args: Parameters&lt;CacheHandler['get']&gt;) {</span><span class="s3">\n    </span><span class="s1">const [key, ctx] = args</span><span class="s3">\n    </span><span class="s1">const { kind } = ctx</span><span class="s3">\n\n    </span><span class="s1">let data = FileSystemCache.memoryCache?.get(key)</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, ctx.tags, kind, !!data)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, kind, !!data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// let's check the disk for seed data</span><span class="s3">\n    </span><span class="s1">if (!data &amp;&amp; process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (kind === IncrementalCacheKind.APP_ROUTE) {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}.body`,</span><span class="s3">\n            </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath)</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">const meta = JSON.parse(</span><span class="s3">\n            </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n              </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n              </span><span class="s1">'utf8'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">data = {</span><span class="s3">\n            </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n            </span><span class="s1">value: {</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_ROUTE,</span><span class="s3">\n              </span><span class="s1">body: fileData,</span><span class="s3">\n              </span><span class="s1">headers: meta.headers,</span><span class="s3">\n              </span><span class="s1">status: meta.status,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">kind === IncrementalCacheKind.FETCH ? key : `${key}.html`,</span><span class="s3">\n            </span><span class="s1">kind</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath, 'utf8')</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n            </span><span class="s1">const { tags, fetchIdx, fetchUrl } = ctx</span><span class="s3">\n\n            </span><span class="s1">if (!this.flushToDisk) return null</span><span class="s3">\n\n            </span><span class="s1">const lastModified = mtime.getTime()</span><span class="s3">\n            </span><span class="s1">const parsedData: CachedFetchValue = JSON.parse(fileData)</span><span class="s3">\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified,</span><span class="s3">\n              </span><span class="s1">value: parsedData,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (data.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n              </span><span class="s1">const storedTags = data.value?.tags</span><span class="s3">\n\n              </span><span class="s1">// update stored tags if a new one is being added</span><span class="s3">\n              </span><span class="s1">// TODO: remove this when we can send the tags</span><span class="s3">\n              </span><span class="s1">// via header on GET same as SET</span><span class="s3">\n              </span><span class="s1">if (!tags?.every((tag) =&gt; storedTags?.includes(tag))) {</span><span class="s3">\n                </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n                  </span><span class="s1">console.log('tags vs storedTags mismatch', tags, storedTags)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">await this.set(key, data.value, {</span><span class="s3">\n                  </span><span class="s1">fetchCache: true,</span><span class="s3">\n                  </span><span class="s1">tags,</span><span class="s3">\n                  </span><span class="s1">fetchIdx,</span><span class="s3">\n                  </span><span class="s1">fetchUrl,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.APP_PAGE) {</span><span class="s3">\n            </span><span class="s1">// We try to load the metadata file, but if it fails, we don't</span><span class="s3">\n            </span><span class="s1">// error. We also don't load it if this is a fallback.</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">meta = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} catch {}</span><span class="s3">\n\n            </span><span class="s1">let maybeSegmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n            </span><span class="s1">if (meta?.segmentPaths) {</span><span class="s3">\n              </span><span class="s1">// Collect all the segment data for this page.</span><span class="s3">\n              </span><span class="s1">// TODO: To optimize file system reads, we should consider creating</span><span class="s3">\n              </span><span class="s1">// separate cache entries for each segment, rather than storing them</span><span class="s3">\n              </span><span class="s1">// all on the page's entry. Though the behavior is</span><span class="s3">\n              </span><span class="s1">// identical regardless.</span><span class="s3">\n              </span><span class="s1">const segmentData: Map&lt;string, Buffer&gt; = new Map()</span><span class="s3">\n              </span><span class="s1">maybeSegmentData = segmentData</span><span class="s3">\n              </span><span class="s1">const segmentsDir = key + RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n              </span><span class="s1">await Promise.all(</span><span class="s3">\n                </span><span class="s1">meta.segmentPaths.map(async (segmentPath: string) =&gt; {</span><span class="s3">\n                  </span><span class="s1">const segmentDataFilePath = this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">segmentData.set(</span><span class="s3">\n                      </span><span class="s1">segmentPath,</span><span class="s3">\n                      </span><span class="s1">await this.fs.readFile(segmentDataFilePath)</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">} catch {</span><span class="s3">\n                    </span><span class="s1">// This shouldn't happen, but if for some reason we fail to</span><span class="s3">\n                    </span><span class="s1">// load a segment from the filesystem, treat it the same as if</span><span class="s3">\n                    </span><span class="s1">// the segment is dynamic and does not have a prefetch.</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">let rscData: Buffer | undefined</span><span class="s3">\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">rscData = await this.fs.readFile(</span><span class="s3">\n                </span><span class="s1">this.getFilePath(</span><span class="s3">\n                  </span><span class="s1">`${key}${ctx.isRoutePPREnabled ? RSC_PREFETCH_SUFFIX : RSC_SUFFIX}`,</span><span class="s3">\n                  </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">rscData,</span><span class="s3">\n                </span><span class="s1">postponed: meta?.postponed,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n                </span><span class="s1">segmentData: maybeSegmentData,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.PAGES) {</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">let pageData: string | object = {}</span><span class="s3">\n\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">pageData = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">`${key}${NEXT_DATA_SUFFIX}`,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.PAGES</span><span class="s3">\n                  </span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">pageData,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`Invariant: Unexpected route kind ${kind} in file system cache.`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (data) {</span><span class="s3">\n          </span><span class="s1">FileSystemCache.memoryCache?.set(key, data)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_PAGE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_ROUTE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">let cacheTags: undefined | string[]</span><span class="s3">\n      </span><span class="s1">const tagsHeader = data.value.headers?.[NEXT_CACHE_TAGS_HEADER]</span><span class="s3">\n\n      </span><span class="s1">if (typeof tagsHeader === 'string') {</span><span class="s3">\n        </span><span class="s1">cacheTags = tagsHeader.split(',')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheTags?.length) {</span><span class="s3">\n        </span><span class="s1">// we trigger a blocking validation if an ISR page</span><span class="s3">\n        </span><span class="s1">// had a tag revalidated, if we want to be a background</span><span class="s3">\n        </span><span class="s1">// revalidation instead we return data.lastModified = -1</span><span class="s3">\n        </span><span class="s1">if (isStale(cacheTags, data?.lastModified || Date.now())) {</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data?.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const combinedTags =</span><span class="s3">\n        </span><span class="s1">ctx.kind === IncrementalCacheKind.FETCH</span><span class="s3">\n          </span><span class="s1">? [...(ctx.tags || []), ...(ctx.softTags || [])]</span><span class="s3">\n          </span><span class="s1">: []</span><span class="s3">\n\n      </span><span class="s1">const wasRevalidated = combinedTags.some((tag) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (this.revalidatedTags.includes(tag)) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return isStale([tag], data?.lastModified || Date.now())</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">// When revalidate tag is called we don't return</span><span class="s3">\n      </span><span class="s1">// stale data so it's updated right away</span><span class="s3">\n      </span><span class="s1">if (wasRevalidated) {</span><span class="s3">\n        </span><span class="s1">data = undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return data ?? null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">FileSystemCache.memoryCache?.set(key, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">lastModified: Date.now(),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('set', key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.flushToDisk || !data) return</span><span class="s3">\n\n    </span><span class="s1">// Create a new writer that will prepare to write all the files to disk</span><span class="s3">\n    </span><span class="s1">// after their containing directory is created.</span><span class="s3">\n    </span><span class="s1">const writer = new MultiFileWriter(this.fs)</span><span class="s3">\n\n    </span><span class="s1">if (data.kind === CachedRouteKind.APP_ROUTE) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.body`,</span><span class="s3">\n        </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(filePath, data.body)</span><span class="s3">\n\n      </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n        </span><span class="s1">headers: data.headers,</span><span class="s3">\n        </span><span class="s1">status: data.status,</span><span class="s3">\n        </span><span class="s1">postponed: undefined,</span><span class="s3">\n        </span><span class="s1">segmentPaths: undefined,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n        </span><span class="s1">JSON.stringify(meta, null, 2)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.PAGES ||</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const isAppPath = data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n      </span><span class="s1">const htmlPath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.html`,</span><span class="s3">\n        </span><span class="s1">isAppPath ? IncrementalCacheKind.APP_PAGE : IncrementalCacheKind.PAGES</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(htmlPath, data.html)</span><span class="s3">\n\n      </span><span class="s1">// Fallbacks don't generate a data file.</span><span class="s3">\n      </span><span class="s1">if (!ctx.fetchCache &amp;&amp; !ctx.isFallback) {</span><span class="s3">\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}${</span><span class="s3">\n              </span><span class="s1">isAppPath</span><span class="s3">\n                </span><span class="s1">? ctx.isRoutePPREnabled</span><span class="s3">\n                  </span><span class="s1">? RSC_PREFETCH_SUFFIX</span><span class="s3">\n                  </span><span class="s1">: RSC_SUFFIX</span><span class="s3">\n                </span><span class="s1">: NEXT_DATA_SUFFIX</span><span class="s3">\n            </span><span class="s1">}`,</span><span class="s3">\n            </span><span class="s1">isAppPath</span><span class="s3">\n              </span><span class="s1">? IncrementalCacheKind.APP_PAGE</span><span class="s3">\n              </span><span class="s1">: IncrementalCacheKind.PAGES</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">isAppPath ? data.rscData! : JSON.stringify(data.pageData)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (data?.kind === CachedRouteKind.APP_PAGE) {</span><span class="s3">\n        </span><span class="s1">let segmentPaths: string[] | undefined</span><span class="s3">\n        </span><span class="s1">if (data.segmentData) {</span><span class="s3">\n          </span><span class="s1">segmentPaths = []</span><span class="s3">\n          </span><span class="s1">const segmentsDir = htmlPath.replace(</span><span class="s3">\n            </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.html$/,</span><span class="s3">\n            </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">for (const [segmentPath, buffer] of data.segmentData) {</span><span class="s3">\n            </span><span class="s1">segmentPaths.push(segmentPath)</span><span class="s3">\n            </span><span class="s1">const segmentDataFilePath =</span><span class="s3">\n              </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX</span><span class="s3">\n            </span><span class="s1">writer.append(segmentDataFilePath, buffer)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n          </span><span class="s1">headers: data.headers,</span><span class="s3">\n          </span><span class="s1">status: data.status,</span><span class="s3">\n          </span><span class="s1">postponed: data.postponed,</span><span class="s3">\n          </span><span class="s1">segmentPaths,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">htmlPath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n          </span><span class="s1">JSON.stringify(meta)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(key, IncrementalCacheKind.FETCH)</span><span class="s3">\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath,</span><span class="s3">\n        </span><span class="s1">JSON.stringify({</span><span class="s3">\n          </span><span class="s1">...data,</span><span class="s3">\n          </span><span class="s1">tags: ctx.fetchCache ? ctx.tags : [],</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Wait for all FS operations to complete.</span><span class="s3">\n    </span><span class="s1">await writer.wait()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private getFilePath(pathname: string, kind: IncrementalCacheKind): string {</span><span class="s3">\n    </span><span class="s1">switch (kind) {</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.FETCH:</span><span class="s3">\n        </span><span class="s1">// we store in .next/cache/fetch-cache so it can be persisted</span><span class="s3">\n        </span><span class="s1">// across deploys</span><span class="s3">\n        </span><span class="s1">return path.join(</span><span class="s3">\n          </span><span class="s1">this.serverDistDir,</span><span class="s3">\n          </span><span class="s1">'..',</span><span class="s3">\n          </span><span class="s1">'cache',</span><span class="s3">\n          </span><span class="s1">'fetch-cache',</span><span class="s3">\n          </span><span class="s1">pathname</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.PAGES:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'pages', pathname)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.IMAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_PAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_ROUTE:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'app', pathname)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">throw new Error(`Unexpected file path kind: ${kind}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { CacheFs } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { PrerenderManifest } from '../../../build'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheEntry,</span><span class="s3">\n  </span><span class="s1">type IncrementalCache as IncrementalCacheType,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">type IncrementalFetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">type GetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type GetIncrementalResponseCacheContext,</span><span class="s3">\n  </span><span class="s1">type CachedFetchValue,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalResponseCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">import FileSystemCache from './file-system-cache'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CACHE_ONE_YEAR,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { toRoute } from '../to-route'</span><span class="s3">\n</span><span class="s1">import { SharedCacheControls } from './shared-cache-controls.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getPrerenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">getRenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import type { Revalidate } from '../cache-control'</span><span class="s3">\n</span><span class="s1">import { getPreviouslyRevalidatedTags } from '../../server-utils'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../../lib/detached-promise'</span><span class="s3">\n\n</span><span class="s1">export interface CacheHandlerContext {</span><span class="s3">\n  </span><span class="s1">fs?: CacheFs</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">flushToDisk?: boolean</span><span class="s3">\n  </span><span class="s1">serverDistDir?: string</span><span class="s3">\n  </span><span class="s1">maxMemoryCacheSize?: number</span><span class="s3">\n  </span><span class="s1">fetchCacheKeyPrefix?: string</span><span class="s3">\n  </span><span class="s1">prerenderManifest?: PrerenderManifest</span><span class="s3">\n  </span><span class="s1">revalidatedTags: string[]</span><span class="s3">\n  </span><span class="s1">_requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CacheHandlerValue {</span><span class="s3">\n  </span><span class="s1">lastModified?: number</span><span class="s3">\n  </span><span class="s1">age?: number</span><span class="s3">\n  </span><span class="s1">cacheState?: string</span><span class="s3">\n  </span><span class="s1">value: IncrementalCacheValue | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class CacheHandler {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line</span><span class="s3">\n  </span><span class="s1">constructor(_ctx: CacheHandlerContext) {}</span><span class="s3">\n\n  </span><span class="s1">public async get(</span><span class="s3">\n    </span><span class="s1">_cacheKey: string,</span><span class="s3">\n    </span><span class="s1">_ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;CacheHandlerValue | null&gt; {</span><span class="s3">\n    </span><span class="s1">return {} as any</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async set(</span><span class="s3">\n    </span><span class="s1">_cacheKey: string,</span><span class="s3">\n    </span><span class="s1">_data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">_ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public async revalidateTag(</span><span class="s3">\n    </span><span class="s1">..._args: Parameters&lt;IncrementalCache['revalidateTag']&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public resetRequestCache(): void {}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class IncrementalCache implements IncrementalCacheType {</span><span class="s3">\n  </span><span class="s1">readonly dev?: boolean</span><span class="s3">\n  </span><span class="s1">readonly disableForTestmode?: boolean</span><span class="s3">\n  </span><span class="s1">readonly cacheHandler?: CacheHandler</span><span class="s3">\n  </span><span class="s1">readonly hasCustomCacheHandler: boolean</span><span class="s3">\n  </span><span class="s1">readonly prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">readonly requestHeaders: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n  </span><span class="s1">readonly allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n  </span><span class="s1">readonly minimalMode?: boolean</span><span class="s3">\n  </span><span class="s1">readonly fetchCacheKeyPrefix?: string</span><span class="s3">\n  </span><span class="s1">readonly revalidatedTags?: string[]</span><span class="s3">\n  </span><span class="s1">readonly isOnDemandRevalidate?: boolean</span><span class="s3">\n\n  </span><span class="s1">private static readonly debug: boolean =</span><span class="s3">\n    </span><span class="s1">!!process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">private readonly locks = new Map&lt;string, Promise&lt;void&gt;&gt;()</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cache controls for routes. This will source the values from the</span><span class="s3">\n   </span><span class="s1">* prerender manifest until the in-memory cache is updated with new values.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly cacheControls: SharedCacheControls</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">fs,</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">flushToDisk,</span><span class="s3">\n    </span><span class="s1">minimalMode,</span><span class="s3">\n    </span><span class="s1">serverDistDir,</span><span class="s3">\n    </span><span class="s1">requestHeaders,</span><span class="s3">\n    </span><span class="s1">maxMemoryCacheSize,</span><span class="s3">\n    </span><span class="s1">getPrerenderManifest,</span><span class="s3">\n    </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n    </span><span class="s1">CurCacheHandler,</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">fs?: CacheFs</span><span class="s3">\n    </span><span class="s1">dev: boolean</span><span class="s3">\n    </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n    </span><span class="s1">serverDistDir?: string</span><span class="s3">\n    </span><span class="s1">flushToDisk?: boolean</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n    </span><span class="s1">requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n    </span><span class="s1">maxMemoryCacheSize?: number</span><span class="s3">\n    </span><span class="s1">getPrerenderManifest: () =&gt; DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">fetchCacheKeyPrefix?: string</span><span class="s3">\n    </span><span class="s1">CurCacheHandler?: typeof CacheHandler</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">this.hasCustomCacheHandler = Boolean(CurCacheHandler)</span><span class="s3">\n\n    </span><span class="s1">const cacheHandlersSymbol = Symbol.for('@next/cache-handlers')</span><span class="s3">\n    </span><span class="s1">const _globalThis: typeof globalThis &amp; {</span><span class="s3">\n      </span><span class="s1">[cacheHandlersSymbol]?: {</span><span class="s3">\n        </span><span class="s1">FetchCache?: typeof CacheHandler</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} = globalThis</span><span class="s3">\n\n    </span><span class="s1">if (!CurCacheHandler) {</span><span class="s3">\n      </span><span class="s1">// if we have a global cache handler available leverage it</span><span class="s3">\n      </span><span class="s1">const globalCacheHandler = _globalThis[cacheHandlersSymbol]</span><span class="s3">\n\n      </span><span class="s1">if (globalCacheHandler?.FetchCache) {</span><span class="s3">\n        </span><span class="s1">CurCacheHandler = globalCacheHandler.FetchCache</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (fs &amp;&amp; serverDistDir) {</span><span class="s3">\n          </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n            </span><span class="s1">console.log('using filesystem cache handler')</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">CurCacheHandler = FileSystemCache</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (IncrementalCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('using custom cache handler', CurCacheHandler.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {</span><span class="s3">\n      </span><span class="s1">// Allow cache size to be overridden for testing purposes</span><span class="s3">\n      </span><span class="s1">maxMemoryCacheSize = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.dev = dev</span><span class="s3">\n    </span><span class="s1">this.disableForTestmode = process.env.NEXT_PRIVATE_TEST_PROXY === 'true'</span><span class="s3">\n    </span><span class="s1">// this is a hack to avoid Webpack knowing this is equal to this.minimalMode</span><span class="s3">\n    </span><span class="s1">// because we replace this.minimalMode to true in production bundles.</span><span class="s3">\n    </span><span class="s1">const minimalModeKey = 'minimalMode'</span><span class="s3">\n    </span><span class="s1">this[minimalModeKey] = minimalMode</span><span class="s3">\n    </span><span class="s1">this.requestHeaders = requestHeaders</span><span class="s3">\n    </span><span class="s1">this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys</span><span class="s3">\n    </span><span class="s1">this.prerenderManifest = getPrerenderManifest()</span><span class="s3">\n    </span><span class="s1">this.cacheControls = new SharedCacheControls(this.prerenderManifest)</span><span class="s3">\n    </span><span class="s1">this.fetchCacheKeyPrefix = fetchCacheKeyPrefix</span><span class="s3">\n    </span><span class="s1">let revalidatedTags: string[] = []</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">requestHeaders[PRERENDER_REVALIDATE_HEADER] ===</span><span class="s3">\n      </span><span class="s1">this.prerenderManifest?.preview?.previewModeId</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.isOnDemandRevalidate = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (minimalMode) {</span><span class="s3">\n      </span><span class="s1">revalidatedTags = getPreviouslyRevalidatedTags(</span><span class="s3">\n        </span><span class="s1">requestHeaders,</span><span class="s3">\n        </span><span class="s1">this.prerenderManifest?.preview?.previewModeId</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (CurCacheHandler) {</span><span class="s3">\n      </span><span class="s1">this.cacheHandler = new CurCacheHandler({</span><span class="s3">\n        </span><span class="s1">dev,</span><span class="s3">\n        </span><span class="s1">fs,</span><span class="s3">\n        </span><span class="s1">flushToDisk,</span><span class="s3">\n        </span><span class="s1">serverDistDir,</span><span class="s3">\n        </span><span class="s1">revalidatedTags,</span><span class="s3">\n        </span><span class="s1">maxMemoryCacheSize,</span><span class="s3">\n        </span><span class="s1">_requestHeaders: requestHeaders,</span><span class="s3">\n        </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private calculateRevalidate(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">fromTime: number,</span><span class="s3">\n    </span><span class="s1">dev: boolean,</span><span class="s3">\n    </span><span class="s1">isFallback: boolean | undefined</span><span class="s3">\n  </span><span class="s1">): Revalidate {</span><span class="s3">\n    </span><span class="s1">// in development we don't have a prerender-manifest</span><span class="s3">\n    </span><span class="s1">// and default to always revalidating to allow easier debugging</span><span class="s3">\n    </span><span class="s1">if (dev)</span><span class="s3">\n      </span><span class="s1">return Math.floor(performance.timeOrigin + performance.now() - 1000)</span><span class="s3">\n\n    </span><span class="s1">const cacheControl = this.cacheControls.get(toRoute(pathname))</span><span class="s3">\n\n    </span><span class="s1">// if an entry isn't present in routes we fallback to a default</span><span class="s3">\n    </span><span class="s1">// of revalidating after 1 second unless it's a fallback request.</span><span class="s3">\n    </span><span class="s1">const initialRevalidateSeconds = cacheControl</span><span class="s3">\n      </span><span class="s1">? cacheControl.revalidate</span><span class="s3">\n      </span><span class="s1">: isFallback</span><span class="s3">\n        </span><span class="s1">? false</span><span class="s3">\n        </span><span class="s1">: 1</span><span class="s3">\n\n    </span><span class="s1">const revalidateAfter =</span><span class="s3">\n      </span><span class="s1">typeof initialRevalidateSeconds === 'number'</span><span class="s3">\n        </span><span class="s1">? initialRevalidateSeconds * 1000 + fromTime</span><span class="s3">\n        </span><span class="s1">: initialRevalidateSeconds</span><span class="s3">\n\n    </span><span class="s1">return revalidateAfter</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_getPathname(pathname: string, fetchCache?: boolean) {</span><span class="s3">\n    </span><span class="s1">return fetchCache ? pathname : normalizePagePath(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">resetRequestCache() {</span><span class="s3">\n    </span><span class="s1">this.cacheHandler?.resetRequestCache?.()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async lock(cacheKey: string): Promise&lt;() =&gt; Promise&lt;void&gt; | void&gt; {</span><span class="s3">\n    </span><span class="s1">// Wait for any existing lock on this cache key to be released</span><span class="s3">\n    </span><span class="s1">// This implements a simple queue-based locking mechanism</span><span class="s3">\n    </span><span class="s1">while (true) {</span><span class="s3">\n      </span><span class="s1">const lock = this.locks.get(cacheKey)</span><span class="s3">\n\n      </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n        </span><span class="s1">console.log('lock get', cacheKey, !!lock)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If no lock exists, we can proceed to acquire it</span><span class="s3">\n      </span><span class="s1">if (!lock) break</span><span class="s3">\n\n      </span><span class="s1">// Wait for the existing lock to be released before trying again</span><span class="s3">\n      </span><span class="s1">await lock</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Create a new detached promise that will represent this lock</span><span class="s3">\n    </span><span class="s1">// The resolve function (unlock) will be returned to the caller</span><span class="s3">\n    </span><span class="s1">const { resolve, promise } = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n\n    </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('successfully locked', cacheKey)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Store the lock promise in the locks map</span><span class="s3">\n    </span><span class="s1">this.locks.set(cacheKey, promise)</span><span class="s3">\n\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">// Resolve the promise to release the lock.</span><span class="s3">\n      </span><span class="s1">resolve()</span><span class="s3">\n\n      </span><span class="s1">// Remove the lock from the map once it's released so that future gets</span><span class="s3">\n      </span><span class="s1">// can acquire the lock.</span><span class="s3">\n      </span><span class="s1">this.locks.delete(cacheKey)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async revalidateTag(tags: string | string[]): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return this.cacheHandler?.revalidateTag(tags)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23</span><span class="s3">\n  </span><span class="s1">async generateCacheKey(</span><span class="s3">\n    </span><span class="s1">url: string,</span><span class="s3">\n    </span><span class="s1">init: RequestInit | Request = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">// this should be bumped anytime a fix is made to cache entries</span><span class="s3">\n    </span><span class="s1">// that should bust the cache</span><span class="s3">\n    </span><span class="s1">const MAIN_KEY_PREFIX = 'v3'</span><span class="s3">\n\n    </span><span class="s1">const bodyChunks: string[] = []</span><span class="s3">\n\n    </span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n    </span><span class="s1">const decoder = new TextDecoder()</span><span class="s3">\n\n    </span><span class="s1">if (init.body) {</span><span class="s3">\n      </span><span class="s1">// handle Uint8Array body</span><span class="s3">\n      </span><span class="s1">if (init.body instanceof Uint8Array) {</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(decoder.decode(init.body))</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n      </span><span class="s1">} // handle ReadableStream body</span><span class="s3">\n      </span><span class="s1">else if (typeof (init.body as any).getReader === 'function') {</span><span class="s3">\n        </span><span class="s1">const readableBody = init.body as ReadableStream&lt;Uint8Array | string&gt;</span><span class="s3">\n\n        </span><span class="s1">const chunks: Uint8Array[] = []</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">await readableBody.pipeTo(</span><span class="s3">\n            </span><span class="s1">new WritableStream({</span><span class="s3">\n              </span><span class="s1">write(chunk) {</span><span class="s3">\n                </span><span class="s1">if (typeof chunk === 'string') {</span><span class="s3">\n                  </span><span class="s1">chunks.push(encoder.encode(chunk))</span><span class="s3">\n                  </span><span class="s1">bodyChunks.push(chunk)</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                  </span><span class="s1">chunks.push(chunk)</span><span class="s3">\n                  </span><span class="s1">bodyChunks.push(decoder.decode(chunk, { stream: true }))</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// Flush the decoder.</span><span class="s3">\n          </span><span class="s1">bodyChunks.push(decoder.decode())</span><span class="s3">\n\n          </span><span class="s1">// Create a new buffer with all the chunks.</span><span class="s3">\n          </span><span class="s1">const length = chunks.reduce((total, arr) =&gt; total + arr.length, 0)</span><span class="s3">\n          </span><span class="s1">const arrayBuffer = new Uint8Array(length)</span><span class="s3">\n\n          </span><span class="s1">// Push each of the chunks into the new array buffer.</span><span class="s3">\n          </span><span class="s1">let offset = 0</span><span class="s3">\n          </span><span class="s1">for (const chunk of chunks) {</span><span class="s3">\n            </span><span class="s1">arrayBuffer.set(chunk, offset)</span><span class="s3">\n            </span><span class="s1">offset += chunk.length</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">;(init as any)._ogBody = arrayBuffer</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">console.error('Problem reading body', err)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // handle FormData or URLSearchParams bodies</span><span class="s3">\n      </span><span class="s1">else if (typeof (init.body as any).keys === 'function') {</span><span class="s3">\n        </span><span class="s1">const formData = init.body as FormData</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n        </span><span class="s1">for (const key of new Set([...formData.keys()])) {</span><span class="s3">\n          </span><span class="s1">const values = formData.getAll(key)</span><span class="s3">\n          </span><span class="s1">bodyChunks.push(</span><span class="s3">\n            </span><span class="s1">`${key}=${(</span><span class="s3">\n              </span><span class="s1">await Promise.all(</span><span class="s3">\n                </span><span class="s1">values.map(async (val) =&gt; {</span><span class="s3">\n                  </span><span class="s1">if (typeof val === 'string') {</span><span class="s3">\n                    </span><span class="s1">return val</span><span class="s3">\n                  </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">return await val.text()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">).join(',')}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// handle blob body</span><span class="s3">\n      </span><span class="s1">} else if (typeof (init.body as any).arrayBuffer === 'function') {</span><span class="s3">\n        </span><span class="s1">const blob = init.body as Blob</span><span class="s3">\n        </span><span class="s1">const arrayBuffer = await blob.arrayBuffer()</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(await blob.text())</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = new Blob([arrayBuffer], { type: blob.type })</span><span class="s3">\n      </span><span class="s1">} else if (typeof init.body === 'string') {</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(init.body)</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const headers =</span><span class="s3">\n      </span><span class="s1">typeof (init.headers || {}).keys === 'function'</span><span class="s3">\n        </span><span class="s1">? Object.fromEntries(init.headers as Headers)</span><span class="s3">\n        </span><span class="s1">: Object.assign({}, init.headers)</span><span class="s3">\n\n    </span><span class="s1">// w3c trace context headers can break request caching and deduplication</span><span class="s3">\n    </span><span class="s1">// so we remove them from the cache key</span><span class="s3">\n    </span><span class="s1">if ('traceparent' in headers) delete headers['traceparent']</span><span class="s3">\n    </span><span class="s1">if ('tracestate' in headers) delete headers['tracestate']</span><span class="s3">\n\n    </span><span class="s1">const cacheString = JSON.stringify([</span><span class="s3">\n      </span><span class="s1">MAIN_KEY_PREFIX,</span><span class="s3">\n      </span><span class="s1">this.fetchCacheKeyPrefix || '',</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">init.method,</span><span class="s3">\n      </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">init.mode,</span><span class="s3">\n      </span><span class="s1">init.redirect,</span><span class="s3">\n      </span><span class="s1">init.credentials,</span><span class="s3">\n      </span><span class="s1">init.referrer,</span><span class="s3">\n      </span><span class="s1">init.referrerPolicy,</span><span class="s3">\n      </span><span class="s1">init.integrity,</span><span class="s3">\n      </span><span class="s1">init.cache,</span><span class="s3">\n      </span><span class="s1">bodyChunks,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">function bufferToHex(buffer: ArrayBuffer): string {</span><span class="s3">\n        </span><span class="s1">return Array.prototype.map</span><span class="s3">\n          </span><span class="s1">.call(new Uint8Array(buffer), (b) =&gt; b.toString(16).padStart(2, '0'))</span><span class="s3">\n          </span><span class="s1">.join('')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const buffer = encoder.encode(cacheString)</span><span class="s3">\n      </span><span class="s1">return bufferToHex(await crypto.subtle.digest('SHA-256', buffer))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const crypto = require('crypto') as typeof import('crypto')</span><span class="s3">\n      </span><span class="s1">return crypto.createHash('sha256').update(cacheString).digest('hex')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalFetchCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">// Unlike other caches if we have a resume data cache, we use it even if</span><span class="s3">\n    </span><span class="s1">// testmode would normally disable it or if requestHeaders say 'no-cache'.</span><span class="s3">\n    </span><span class="s1">if (ctx.kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const resumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getRenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">if (resumeDataCache) {</span><span class="s3">\n        </span><span class="s1">const memoryCacheData = resumeDataCache.fetch.get(cacheKey)</span><span class="s3">\n        </span><span class="s1">if (memoryCacheData?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n          </span><span class="s1">return { isStale: false, value: memoryCacheData }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// we don't leverage the prerender cache in dev mode</span><span class="s3">\n    </span><span class="s1">// so that getStaticProps is always called for easier debugging</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this.disableForTestmode ||</span><span class="s3">\n      </span><span class="s1">(this.dev &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(ctx.kind !== IncrementalCacheKind.FETCH ||</span><span class="s3">\n          </span><span class="s1">this.requestHeaders['cache-control'] === 'no-cache'))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">cacheKey = this._getPathname(</span><span class="s3">\n      </span><span class="s1">cacheKey,</span><span class="s3">\n      </span><span class="s1">ctx.kind === IncrementalCacheKind.FETCH</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const cacheData = await this.cacheHandler?.get(cacheKey, ctx)</span><span class="s3">\n\n    </span><span class="s1">if (ctx.kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">if (!cacheData) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheData.value?.kind !== CachedRouteKind.FETCH) {</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">`Expected cached value for cache key ${JSON.stringify(cacheKey)} to be a </span><span class="s3">\&quot;</span><span class="s1">FETCH</span><span class="s3">\&quot; </span><span class="s1">kind, got ${JSON.stringify(cacheData.value?.kind)} instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const combinedTags = [...(ctx.tags || []), ...(ctx.softTags || [])]</span><span class="s3">\n      </span><span class="s1">// if a tag was revalidated we don't return stale data</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">combinedTags.some(</span><span class="s3">\n          </span><span class="s1">(tag) =&gt;</span><span class="s3">\n            </span><span class="s1">this.revalidatedTags?.includes(tag) ||</span><span class="s3">\n            </span><span class="s1">workStore?.pendingRevalidatedTags?.includes(tag)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const revalidate = ctx.revalidate || cacheData.value.revalidate</span><span class="s3">\n      </span><span class="s1">const age =</span><span class="s3">\n        </span><span class="s1">(performance.timeOrigin +</span><span class="s3">\n          </span><span class="s1">performance.now() -</span><span class="s3">\n          </span><span class="s1">(cacheData.lastModified || 0)) /</span><span class="s3">\n        </span><span class="s1">1000</span><span class="s3">\n\n      </span><span class="s1">const isStale = age &gt; revalidate</span><span class="s3">\n      </span><span class="s1">const data = cacheData.value.data</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">value: { kind: CachedRouteKind.FETCH, data, revalidate },</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (cacheData?.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">`Expected cached value for cache key ${JSON.stringify(cacheKey)} not to be a ${JSON.stringify(ctx.kind)} kind, got </span><span class="s3">\&quot;</span><span class="s1">FETCH</span><span class="s3">\&quot; </span><span class="s1">instead.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let entry: IncrementalResponseCacheEntry | null = null</span><span class="s3">\n    </span><span class="s1">const cacheControl = this.cacheControls.get(toRoute(cacheKey))</span><span class="s3">\n\n    </span><span class="s1">let isStale: boolean | -1 | undefined</span><span class="s3">\n    </span><span class="s1">let revalidateAfter: Revalidate</span><span class="s3">\n\n    </span><span class="s1">if (cacheData?.lastModified === -1) {</span><span class="s3">\n      </span><span class="s1">isStale = -1</span><span class="s3">\n      </span><span class="s1">revalidateAfter = -1 * CACHE_ONE_YEAR</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">revalidateAfter = this.calculateRevalidate(</span><span class="s3">\n        </span><span class="s1">cacheKey,</span><span class="s3">\n        </span><span class="s1">cacheData?.lastModified || performance.timeOrigin + performance.now(),</span><span class="s3">\n        </span><span class="s1">this.dev ?? false,</span><span class="s3">\n        </span><span class="s1">ctx.isFallback</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">isStale =</span><span class="s3">\n        </span><span class="s1">revalidateAfter !== false &amp;&amp;</span><span class="s3">\n        </span><span class="s1">revalidateAfter &lt; performance.timeOrigin + performance.now()</span><span class="s3">\n          </span><span class="s1">? true</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (cacheData) {</span><span class="s3">\n      </span><span class="s1">entry = {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n        </span><span class="s1">revalidateAfter,</span><span class="s3">\n        </span><span class="s1">value: cacheData.value,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!cacheData &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.prerenderManifest.notFoundRoutes.includes(cacheKey)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// for the first hit after starting the server the cache</span><span class="s3">\n      </span><span class="s1">// may not have a way to save notFound: true so if</span><span class="s3">\n      </span><span class="s1">// the prerender-manifest marks this as notFound then we</span><span class="s3">\n      </span><span class="s1">// return that entry and trigger a cache set to give it a</span><span class="s3">\n      </span><span class="s1">// chance to update in-memory entries</span><span class="s3">\n      </span><span class="s1">entry = {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">value: null,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n        </span><span class="s1">revalidateAfter,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.set(cacheKey, entry.value, { ...ctx, cacheControl })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return entry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: CachedFetchValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">// Even if we otherwise disable caching for testMode or if no fetchCache is</span><span class="s3">\n    </span><span class="s1">// configured we still always stash results in the resume data cache if one</span><span class="s3">\n    </span><span class="s1">// exists. This is because this is a transient in memory cache that</span><span class="s3">\n    </span><span class="s1">// populates caches ahead of a dynamic render in dev mode to allow the RSC</span><span class="s3">\n    </span><span class="s1">// debug info to have the right environment associated to it.</span><span class="s3">\n    </span><span class="s1">if (data?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const prerenderResumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getPrerenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">if (prerenderResumeDataCache) {</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache.fetch.set(pathname, data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.disableForTestmode || (this.dev &amp;&amp; !ctx.fetchCache)) return</span><span class="s3">\n\n    </span><span class="s1">pathname = this._getPathname(pathname, ctx.fetchCache)</span><span class="s3">\n\n    </span><span class="s1">// FetchCache has upper limit of 2MB per-entry currently</span><span class="s3">\n    </span><span class="s1">const itemSize = JSON.stringify(data).length</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">ctx.fetchCache &amp;&amp;</span><span class="s3">\n      </span><span class="s1">itemSize &gt; 2 * 1024 * 1024 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We ignore the size limit when custom cache handler is being used, as it</span><span class="s3">\n      </span><span class="s1">// might not have this limit</span><span class="s3">\n      </span><span class="s1">!this.hasCustomCacheHandler &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We also ignore the size limit when it's an implicit build-time-only</span><span class="s3">\n      </span><span class="s1">// caching that the user isn't even aware of.</span><span class="s3">\n      </span><span class="s1">!ctx.isImplicitBuildTimeCache</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const warningText = `Failed to set Next.js data cache for ${ctx.fetchUrl || pathname}, items over 2MB can not be cached (${itemSize} bytes)`</span><span class="s3">\n\n      </span><span class="s1">if (this.dev) {</span><span class="s3">\n        </span><span class="s1">throw new Error(warningText)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">console.warn(warningText)</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">if (!ctx.fetchCache &amp;&amp; ctx.cacheControl) {</span><span class="s3">\n        </span><span class="s1">this.cacheControls.set(toRoute(pathname), ctx.cacheControl)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">await this.cacheHandler?.set(pathname, data, ctx)</span><span class="s3">\n    </span><span class="s1">} catch (error) {</span><span class="s3">\n      </span><span class="s1">console.warn('Failed to update prerender cache for', pathname, error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { CacheFs } from '../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">import fs from 'fs'</span><span class="s3">\n\n</span><span class="s1">export const nodeFs: CacheFs = {</span><span class="s3">\n  </span><span class="s1">existsSync: fs.existsSync,</span><span class="s3">\n  </span><span class="s1">readFile: fs.promises.readFile,</span><span class="s3">\n  </span><span class="s1">readFileSync: fs.readFileSync,</span><span class="s3">\n  </span><span class="s1">writeFile: (f, d) =&gt; fs.promises.writeFile(f, d),</span><span class="s3">\n  </span><span class="s1">mkdir: (dir) =&gt; fs.promises.mkdir(dir, { recursive: true }),</span><span class="s3">\n  </span><span class="s1">stat: (f) =&gt; fs.promises.stat(f),</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">ServerResponse,</span><span class="s3">\n  </span><span class="s1">OutgoingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">OutgoingHttpHeader,</span><span class="s3">\n  </span><span class="s1">IncomingMessage,</span><span class="s3">\n  </span><span class="s1">IncomingHttpHeaders,</span><span class="s3">\n</span><span class="s1">} from 'http'</span><span class="s3">\n</span><span class="s1">import type { Socket } from 'net'</span><span class="s3">\n</span><span class="s1">import type { TLSSocket } from 'tls'</span><span class="s3">\n\n</span><span class="s1">import Stream from 'stream'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">fromNodeOutgoingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">toNodeOutgoingHttpHeaders,</span><span class="s3">\n</span><span class="s1">} from '../web/utils'</span><span class="s3">\n\n</span><span class="s1">interface MockedRequestOptions {</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders</span><span class="s3">\n  </span><span class="s1">method: string</span><span class="s3">\n  </span><span class="s1">readable?: Stream.Readable</span><span class="s3">\n  </span><span class="s1">socket?: Socket | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MockedRequest extends Stream.Readable implements IncomingMessage {</span><span class="s3">\n  </span><span class="s1">public url: string</span><span class="s3">\n  </span><span class="s1">public readonly statusCode?: number | undefined</span><span class="s3">\n  </span><span class="s1">public readonly statusMessage?: string | undefined</span><span class="s3">\n  </span><span class="s1">public readonly headers: IncomingHttpHeaders</span><span class="s3">\n  </span><span class="s1">public readonly method: string</span><span class="s3">\n\n  </span><span class="s1">// This is hardcoded for now, but can be updated to be configurable if needed.</span><span class="s3">\n  </span><span class="s1">public readonly httpVersion = '1.0'</span><span class="s3">\n  </span><span class="s1">public readonly httpVersionMajor = 1</span><span class="s3">\n  </span><span class="s1">public readonly httpVersionMinor = 0</span><span class="s3">\n\n  </span><span class="s1">private bodyReadable?: Stream.Readable</span><span class="s3">\n\n  </span><span class="s1">// If we don't actually have a socket, we'll just use a mock one that</span><span class="s3">\n  </span><span class="s1">// always returns false for the `encrypted` property and undefined for the</span><span class="s3">\n  </span><span class="s1">// `remoteAddress` property.</span><span class="s3">\n  </span><span class="s1">public socket: Socket = new Proxy&lt;TLSSocket&gt;({} as TLSSocket, {</span><span class="s3">\n    </span><span class="s1">get: (_target, prop) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (prop !== 'encrypted' &amp;&amp; prop !== 'remoteAddress') {</span><span class="s3">\n        </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (prop === 'remoteAddress') return undefined</span><span class="s3">\n      </span><span class="s1">// For this mock request, always ensure we just respond with the encrypted</span><span class="s3">\n      </span><span class="s1">// set to false to ensure there's no odd leakages.</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">headers,</span><span class="s3">\n    </span><span class="s1">method,</span><span class="s3">\n    </span><span class="s1">socket = null,</span><span class="s3">\n    </span><span class="s1">readable,</span><span class="s3">\n  </span><span class="s1">}: MockedRequestOptions) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n\n    </span><span class="s1">this.url = url</span><span class="s3">\n    </span><span class="s1">this.headers = headers</span><span class="s3">\n    </span><span class="s1">this.method = method</span><span class="s3">\n\n    </span><span class="s1">if (readable) {</span><span class="s3">\n      </span><span class="s1">this.bodyReadable = readable</span><span class="s3">\n      </span><span class="s1">this.bodyReadable.on('end', () =&gt; this.emit('end'))</span><span class="s3">\n      </span><span class="s1">this.bodyReadable.on('close', () =&gt; this.emit('close'))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (socket) {</span><span class="s3">\n      </span><span class="s1">this.socket = socket</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get headersDistinct(): NodeJS.Dict&lt;string[]&gt; {</span><span class="s3">\n    </span><span class="s1">const headers: NodeJS.Dict&lt;string[]&gt; = {}</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of Object.entries(this.headers)) {</span><span class="s3">\n      </span><span class="s1">if (!value) continue</span><span class="s3">\n\n      </span><span class="s1">headers[key] = Array.isArray(value) ? value : [value]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return headers</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public _read(size: number): void {</span><span class="s3">\n    </span><span class="s1">if (this.bodyReadable) {</span><span class="s3">\n      </span><span class="s1">return this.bodyReadable._read(size)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.emit('end')</span><span class="s3">\n      </span><span class="s1">this.emit('close')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `connection` property is just an alias for the `socket` property.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @deprecated  since v13.0.0 - Use socket instead.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get connection(): Socket {</span><span class="s3">\n    </span><span class="s1">return this.socket</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// The following methods are not implemented as they are not used in the</span><span class="s3">\n  </span><span class="s1">// Next.js codebase.</span><span class="s3">\n\n  </span><span class="s1">public get aborted(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get complete(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get trailers(): NodeJS.Dict&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get trailersDistinct(): NodeJS.Dict&lt;string[]&gt; {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get rawTrailers(): string[] {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get rawHeaders(): string[] {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public setTimeout(): this {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface MockedResponseOptions {</span><span class="s3">\n  </span><span class="s1">statusCode?: number</span><span class="s3">\n  </span><span class="s1">socket?: Socket | null</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">resWriter?: (chunk: Uint8Array | Buffer | string) =&gt; boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MockedResponse extends Stream.Writable implements ServerResponse {</span><span class="s3">\n  </span><span class="s1">public statusCode: number</span><span class="s3">\n  </span><span class="s1">public statusMessage: string = ''</span><span class="s3">\n  </span><span class="s1">public finished = false</span><span class="s3">\n  </span><span class="s1">public headersSent = false</span><span class="s3">\n  </span><span class="s1">public readonly socket: Socket | null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A promise that resolves to `true` when the response has been streamed.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @internal - used internally by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly hasStreamed: Promise&lt;boolean&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A list of buffers that have been written to the response.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @internal - used internally by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly buffers: Buffer[] = []</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The headers object that contains the headers that were initialized on the</span><span class="s3">\n   </span><span class="s1">* response and any that were added subsequently.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @internal - used internally by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly headers: Headers</span><span class="s3">\n\n  </span><span class="s1">private resWriter: MockedResponseOptions['resWriter']</span><span class="s3">\n\n  </span><span class="s1">public readonly headPromise: Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">private headPromiseResolve?: () =&gt; void</span><span class="s3">\n\n  </span><span class="s1">constructor(res: MockedResponseOptions = {}) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n\n    </span><span class="s1">this.statusCode = res.statusCode ?? 200</span><span class="s3">\n    </span><span class="s1">this.socket = res.socket ?? null</span><span class="s3">\n    </span><span class="s1">this.headers = res.headers</span><span class="s3">\n      </span><span class="s1">? fromNodeOutgoingHttpHeaders(res.headers)</span><span class="s3">\n      </span><span class="s1">: new Headers()</span><span class="s3">\n\n    </span><span class="s1">this.headPromise = new Promise&lt;void&gt;((resolve) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.headPromiseResolve = resolve</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// Attach listeners for the `finish`, `end`, and `error` events to the</span><span class="s3">\n    </span><span class="s1">// `MockedResponse` instance.</span><span class="s3">\n    </span><span class="s1">this.hasStreamed = new Promise&lt;boolean&gt;((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.on('finish', () =&gt; resolve(true))</span><span class="s3">\n      </span><span class="s1">this.on('end', () =&gt; resolve(true))</span><span class="s3">\n      </span><span class="s1">this.on('error', (err) =&gt; reject(err))</span><span class="s3">\n    </span><span class="s1">}).then((val) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.headPromiseResolve?.()</span><span class="s3">\n      </span><span class="s1">return val</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (res.resWriter) {</span><span class="s3">\n      </span><span class="s1">this.resWriter = res.resWriter</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public appendHeader(name: string, value: string | string[]): this {</span><span class="s3">\n    </span><span class="s1">const values = Array.isArray(value) ? value : [value]</span><span class="s3">\n    </span><span class="s1">for (const v of values) {</span><span class="s3">\n      </span><span class="s1">this.headers.append(name, v)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns true if the response has been sent, false otherwise.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @internal - used internally by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isSent() {</span><span class="s3">\n    </span><span class="s1">return this.finished || this.headersSent</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `connection` property is just an alias for the `socket` property.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @deprecated  since v13.0.0 - Use socket instead.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get connection(): Socket | null {</span><span class="s3">\n    </span><span class="s1">return this.socket</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public write(chunk: Uint8Array | Buffer | string) {</span><span class="s3">\n    </span><span class="s1">if (this.resWriter) {</span><span class="s3">\n      </span><span class="s1">return this.resWriter(chunk)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.buffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public end() {</span><span class="s3">\n    </span><span class="s1">this.finished = true</span><span class="s3">\n    </span><span class="s1">return super.end(...arguments)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This method is a no-op because the `MockedResponse` instance is not</span><span class="s3">\n   </span><span class="s1">* actually connected to a socket. This method is not specified on the</span><span class="s3">\n   </span><span class="s1">* interface type for `ServerResponse` but is called by Node.js.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @see https://github.com/nodejs/node/pull/7949</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public _implicitHeader() {}</span><span class="s3">\n\n  </span><span class="s1">public _write(</span><span class="s3">\n    </span><span class="s1">chunk: Buffer | string,</span><span class="s3">\n    </span><span class="s1">_encoding: string,</span><span class="s3">\n    </span><span class="s1">callback: () =&gt; void</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.write(chunk)</span><span class="s3">\n\n    </span><span class="s1">// According to Node.js documentation, the callback MUST be invoked to</span><span class="s3">\n    </span><span class="s1">// signal that the write completed successfully. If this callback is not</span><span class="s3">\n    </span><span class="s1">// invoked, the 'finish' event will not be emitted.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// https://nodejs.org/docs/latest-v16.x/api/stream.html#writable_writechunk-encoding-callback</span><span class="s3">\n    </span><span class="s1">callback()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public writeHead(</span><span class="s3">\n    </span><span class="s1">statusCode: number,</span><span class="s3">\n    </span><span class="s1">statusMessage?: string | undefined,</span><span class="s3">\n    </span><span class="s1">headers?: OutgoingHttpHeaders | OutgoingHttpHeader[] | undefined</span><span class="s3">\n  </span><span class="s1">): this</span><span class="s3">\n  </span><span class="s1">public writeHead(</span><span class="s3">\n    </span><span class="s1">statusCode: number,</span><span class="s3">\n    </span><span class="s1">headers?: OutgoingHttpHeaders | OutgoingHttpHeader[] | undefined</span><span class="s3">\n  </span><span class="s1">): this</span><span class="s3">\n  </span><span class="s1">public writeHead(</span><span class="s3">\n    </span><span class="s1">statusCode: number,</span><span class="s3">\n    </span><span class="s1">statusMessage?:</span><span class="s3">\n      </span><span class="s1">| string</span><span class="s3">\n      </span><span class="s1">| OutgoingHttpHeaders</span><span class="s3">\n      </span><span class="s1">| OutgoingHttpHeader[]</span><span class="s3">\n      </span><span class="s1">| undefined,</span><span class="s3">\n    </span><span class="s1">headers?: OutgoingHttpHeaders | OutgoingHttpHeader[] | undefined</span><span class="s3">\n  </span><span class="s1">): this {</span><span class="s3">\n    </span><span class="s1">if (!headers &amp;&amp; typeof statusMessage !== 'string') {</span><span class="s3">\n      </span><span class="s1">headers = statusMessage</span><span class="s3">\n    </span><span class="s1">} else if (typeof statusMessage === 'string' &amp;&amp; statusMessage.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.statusMessage = statusMessage</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (headers) {</span><span class="s3">\n      </span><span class="s1">// When headers have been set with response.setHeader(), they will be</span><span class="s3">\n      </span><span class="s1">// merged with any headers passed to response.writeHead(), with the</span><span class="s3">\n      </span><span class="s1">// headers passed to response.writeHead() given precedence.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// https://nodejs.org/api/http.html#responsewriteheadstatuscode-statusmessage-headers</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// For this reason, we need to only call `set` to ensure that this will</span><span class="s3">\n      </span><span class="s1">// overwrite any existing headers.</span><span class="s3">\n      </span><span class="s1">if (Array.isArray(headers)) {</span><span class="s3">\n        </span><span class="s1">// headers may be an Array where the keys and values are in the same list.</span><span class="s3">\n        </span><span class="s1">// It is not a list of tuples. So, the even-numbered offsets are key</span><span class="s3">\n        </span><span class="s1">// values, and the odd-numbered offsets are the associated values. The</span><span class="s3">\n        </span><span class="s1">// array is in the same format as request.rawHeaders.</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; headers.length; i += 2) {</span><span class="s3">\n          </span><span class="s1">// The header key is always a string according to the spec.</span><span class="s3">\n          </span><span class="s1">this.setHeader(headers[i] as string, headers[i + 1])</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">for (const [key, value] of Object.entries(headers)) {</span><span class="s3">\n          </span><span class="s1">// Skip undefined values</span><span class="s3">\n          </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n\n          </span><span class="s1">this.setHeader(key, value)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.statusCode = statusCode</span><span class="s3">\n    </span><span class="s1">this.headersSent = true</span><span class="s3">\n    </span><span class="s1">this.headPromiseResolve?.()</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public hasHeader(name: string): boolean {</span><span class="s3">\n    </span><span class="s1">return this.headers.has(name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getHeader(name: string): string | undefined {</span><span class="s3">\n    </span><span class="s1">return this.headers.get(name) ?? undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getHeaders(): OutgoingHttpHeaders {</span><span class="s3">\n    </span><span class="s1">return toNodeOutgoingHttpHeaders(this.headers)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getHeaderNames(): string[] {</span><span class="s3">\n    </span><span class="s1">return Array.from(this.headers.keys())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public setHeader(name: string, value: OutgoingHttpHeader) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">// Because `set` here should override any existing values, we need to</span><span class="s3">\n      </span><span class="s1">// delete the existing values before setting the new ones via `append`.</span><span class="s3">\n      </span><span class="s1">this.headers.delete(name)</span><span class="s3">\n\n      </span><span class="s1">for (const v of value) {</span><span class="s3">\n        </span><span class="s1">this.headers.append(name, v)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (typeof value === 'number') {</span><span class="s3">\n      </span><span class="s1">this.headers.set(name, value.toString())</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.headers.set(name, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public removeHeader(name: string): void {</span><span class="s3">\n    </span><span class="s1">this.headers.delete(name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public flushHeaders(): void {</span><span class="s3">\n    </span><span class="s1">// This is a no-op because we don't actually have a socket to flush the</span><span class="s3">\n    </span><span class="s1">// headers to.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// The following methods are not implemented as they are not used in the</span><span class="s3">\n  </span><span class="s1">// Next.js codebase.</span><span class="s3">\n\n  </span><span class="s1">public get strictContentLength(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public writeEarlyHints() {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get req(): IncomingMessage {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public assignSocket() {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public detachSocket(): void {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public writeContinue(): void {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public writeProcessing(): void {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get upgrading(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get chunkedEncoding(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get shouldKeepAlive(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get useChunkedEncodingByDefault(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get sendDate(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public setTimeout(): this {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public addTrailers(): void {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public setHeaders(): this {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface RequestResponseMockerOptions {</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">headers?: IncomingHttpHeaders</span><span class="s3">\n  </span><span class="s1">method?: string</span><span class="s3">\n  </span><span class="s1">bodyReadable?: Stream.Readable</span><span class="s3">\n  </span><span class="s1">resWriter?: (chunk: Uint8Array | Buffer | string) =&gt; boolean</span><span class="s3">\n  </span><span class="s1">socket?: Socket | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createRequestResponseMocks({</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">headers = {},</span><span class="s3">\n  </span><span class="s1">method = 'GET',</span><span class="s3">\n  </span><span class="s1">bodyReadable,</span><span class="s3">\n  </span><span class="s1">resWriter,</span><span class="s3">\n  </span><span class="s1">socket = null,</span><span class="s3">\n</span><span class="s1">}: RequestResponseMockerOptions) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">req: new MockedRequest({</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">method,</span><span class="s3">\n      </span><span class="s1">socket,</span><span class="s3">\n      </span><span class="s1">readable: bodyReadable,</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">res: new MockedResponse({ socket, resWriter }),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from 'path'</span><span class="s3">\n</span><span class="s1">import { pathToFileURL } from 'url'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The path for a dynamic route must be URLs with a valid scheme.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* When an absolute Windows path is passed to it, it interprets the beginning of the path as a protocol (`C:`).</span><span class="s3">\n </span><span class="s1">* Therefore, it is important to always construct a complete path.</span><span class="s3">\n </span><span class="s1">* @param dir File directory</span><span class="s3">\n </span><span class="s1">* @param filePath Absolute or relative path</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const formatDynamicImportPath = (dir: string, filePath: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">const absoluteFilePath = path.isAbsolute(filePath)</span><span class="s3">\n    </span><span class="s1">? filePath</span><span class="s3">\n    </span><span class="s1">: path.join(dir, filePath)</span><span class="s3">\n  </span><span class="s1">const formattedFilePath = pathToFileURL(absoluteFilePath).toString()</span><span class="s3">\n\n  </span><span class="s1">return formattedFilePath</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class AsyncCallbackSet {</span><span class="s3">\n  </span><span class="s1">private callbacks: (() =&gt; Promise&lt;void&gt;)[] = []</span><span class="s3">\n\n  </span><span class="s1">public add(callback: () =&gt; Promise&lt;void&gt;) {</span><span class="s3">\n    </span><span class="s1">this.callbacks.push(callback)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async runAll(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (!this.callbacks.length) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const callbacks = this.callbacks</span><span class="s3">\n    </span><span class="s1">this.callbacks = []</span><span class="s3">\n    </span><span class="s1">await Promise.allSettled(</span><span class="s3">\n      </span><span class="s1">callbacks.map(</span><span class="s3">\n        </span><span class="s1">// NOTE: wrapped in an async function to protect against synchronous exceptions</span><span class="s3">\n        </span><span class="s1">async (f) =&gt; f()</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone')</span><span class="s3">\n\n</span><span class="s1">export function isPostpone(error: any): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof error === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error.$$typeof === REACT_POSTPONE_TYPE</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ModuleLoader } from './module-loader'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Loads a module using `await require(id)`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class NodeModuleLoader implements ModuleLoader {</span><span class="s3">\n  </span><span class="s1">public async load&lt;M&gt;(id: string): Promise&lt;M&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">// Need to `await` to cover the case that route is marked ESM modules by ESM escalation.</span><span class="s3">\n      </span><span class="s1">return await (process.env.NEXT_MINIMAL</span><span class="s3">\n        </span><span class="s1">? // @ts-ignore</span><span class="s3">\n          </span><span class="s1">__non_webpack_require__(id)</span><span class="s3">\n        </span><span class="s1">: require(id))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">throw new Error('NodeModuleLoader is not supported in edge runtime.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'node:http'</span><span class="s3">\n</span><span class="s1">import type { NextConfigComplete } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'node:url'</span><span class="s3">\n\n</span><span class="s1">export type RevalidateFn = (config: {</span><span class="s3">\n  </span><span class="s1">urlPath: string</span><span class="s3">\n  </span><span class="s1">revalidateHeaders: { [key: string]: string | string[] }</span><span class="s3">\n  </span><span class="s1">opts: { unstable_onlyGenerated?: boolean }</span><span class="s3">\n</span><span class="s1">}) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n</span><span class="s1">// The RouterServerContext contains instance specific</span><span class="s3">\n</span><span class="s1">// information that isn't available/relevant when</span><span class="s3">\n</span><span class="s1">// deployed in serverless environments, the key is</span><span class="s3">\n</span><span class="s1">// the relative project dir this allows separate contexts</span><span class="s3">\n</span><span class="s1">// when running multiple next instances in same process</span><span class="s3">\n</span><span class="s1">export type RouterServerContext = Record&lt;</span><span class="s3">\n  </span><span class="s1">string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">// hostname the server is started with</span><span class="s3">\n    </span><span class="s1">hostname?: string</span><span class="s3">\n    </span><span class="s1">// revalidate function to bypass going through network</span><span class="s3">\n    </span><span class="s1">// to invoke revalidate request (uses mocked req/res)</span><span class="s3">\n    </span><span class="s1">revalidate?: RevalidateFn</span><span class="s3">\n    </span><span class="s1">// function to render the 404 page</span><span class="s3">\n    </span><span class="s1">render404?: (</span><span class="s3">\n      </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n      </span><span class="s1">res: ServerResponse,</span><span class="s3">\n      </span><span class="s1">parsedUrl?: UrlWithParsedQuery,</span><span class="s3">\n      </span><span class="s1">setHeaders?: boolean</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n    </span><span class="s1">// current loaded public runtime config</span><span class="s3">\n    </span><span class="s1">publicRuntimeConfig?: NextConfigComplete['publicRuntimeConfig']</span><span class="s3">\n    </span><span class="s1">// exposing nextConfig for dev mode specifically</span><span class="s3">\n    </span><span class="s1">nextConfig?: NextConfigComplete</span><span class="s3">\n    </span><span class="s1">// whether running in custom server mode</span><span class="s3">\n    </span><span class="s1">isCustomServer?: boolean</span><span class="s3">\n    </span><span class="s1">// whether test proxy is enabled</span><span class="s3">\n    </span><span class="s1">experimentalTestProxy?: boolean</span><span class="s3">\n    </span><span class="s1">// allow dev server to log with original stack</span><span class="s3">\n    </span><span class="s1">logErrorWithOriginalStack?: (err: unknown, type: string) =&gt; void</span><span class="s3">\n    </span><span class="s1">// allow setting ISR status in dev</span><span class="s3">\n    </span><span class="s1">setIsrStatus?: (key: string, value: boolean | null) =&gt; void</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export const RouterServerContextSymbol = Symbol.for(</span><span class="s3">\n  </span><span class="s1">'@next/router-server-methods'</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export const routerServerGlobal = globalThis as typeof globalThis &amp; {</span><span class="s3">\n  </span><span class="s1">[RouterServerContextSymbol]?: RouterServerContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import './node-environment'</span><span class="s3">\n</span><span class="s1">import './require-hook'</span><span class="s3">\n</span><span class="s1">import './node-polyfill-crypto'</span><span class="s3">\n\n</span><span class="s1">import type { CacheFs } from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">DecodeError,</span><span class="s3">\n  </span><span class="s1">PageNotFoundError,</span><span class="s3">\n  </span><span class="s1">MiddlewareNotFoundError,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { MiddlewareManifest } from '../build/webpack/plugins/middleware-plugin'</span><span class="s3">\n</span><span class="s1">import type RenderResult from './render-result'</span><span class="s3">\n</span><span class="s1">import type { FetchEventResult } from './web/types'</span><span class="s3">\n</span><span class="s1">import type { PrerenderManifest, RoutesManifest } from '../build'</span><span class="s3">\n</span><span class="s1">import type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { NextParsedUrlQuery, NextUrlWithParsedQuery } from './request-meta'</span><span class="s3">\n</span><span class="s1">import type { Params } from './request/params'</span><span class="s3">\n</span><span class="s1">import type { MiddlewareRouteMatch } from '../shared/lib/router/utils/middleware-route-matcher'</span><span class="s3">\n</span><span class="s1">import type { RouteMatch } from './route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrl } from '../shared/lib/router/utils/parse-url'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { WaitUntil } from './after/builtin-request-context'</span><span class="s3">\n\n</span><span class="s1">import fs from 'fs'</span><span class="s3">\n</span><span class="s1">import { join, relative } from 'path'</span><span class="s3">\n</span><span class="s1">import { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import { addRequestMeta, getRequestMeta } from './request-meta'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PAGES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">BUILD_ID_FILE,</span><span class="s3">\n  </span><span class="s1">MIDDLEWARE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">PRERENDER_MANIFEST,</span><span class="s3">\n  </span><span class="s1">ROUTES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">CLIENT_PUBLIC_FILES_PATH,</span><span class="s3">\n  </span><span class="s1">APP_PATHS_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SERVER_DIRECTORY,</span><span class="s3">\n  </span><span class="s1">NEXT_FONT_MANIFEST,</span><span class="s3">\n  </span><span class="s1">UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span><span class="s3">\n  </span><span class="s1">FUNCTIONS_CONFIG_MANIFEST,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { findDir } from '../lib/find-pages-dir'</span><span class="s3">\n</span><span class="s1">import { NodeNextRequest, NodeNextResponse } from './base-http/node'</span><span class="s3">\n</span><span class="s1">import { sendRenderResult } from './send-payload'</span><span class="s3">\n</span><span class="s1">import { parseUrl } from '../shared/lib/router/utils/parse-url'</span><span class="s3">\n</span><span class="s1">import * as Log from '../build/output/log'</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Options,</span><span class="s3">\n  </span><span class="s1">FindComponentsResult,</span><span class="s3">\n  </span><span class="s1">MiddlewareRoutingItem,</span><span class="s3">\n  </span><span class="s1">RequestContext,</span><span class="s3">\n  </span><span class="s1">NormalizedRouteManifest,</span><span class="s3">\n  </span><span class="s1">LoadedRenderOpts,</span><span class="s3">\n  </span><span class="s1">RouteHandler,</span><span class="s3">\n  </span><span class="s1">NextEnabledDirectories,</span><span class="s3">\n  </span><span class="s1">BaseRequestHandler,</span><span class="s3">\n</span><span class="s1">} from './base-server'</span><span class="s3">\n</span><span class="s1">import BaseServer from './base-server'</span><span class="s3">\n</span><span class="s1">import { getMaybePagePath, getPagePath } from './require'</span><span class="s3">\n</span><span class="s1">import { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n</span><span class="s1">import { loadComponents } from './load-components'</span><span class="s3">\n</span><span class="s1">import type { LoadComponentsReturnType } from './load-components'</span><span class="s3">\n</span><span class="s1">import isError, { getProperError } from '../lib/is-error'</span><span class="s3">\n</span><span class="s1">import { splitCookiesString, toNodeOutgoingHttpHeaders } from './web/utils'</span><span class="s3">\n</span><span class="s1">import { getMiddlewareRouteMatcher } from '../shared/lib/router/utils/middleware-route-matcher'</span><span class="s3">\n</span><span class="s1">import { loadEnvConfig } from '@next/env'</span><span class="s3">\n</span><span class="s1">import { urlQueryToSearchParams } from '../shared/lib/router/utils/querystring'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { getNextPathnameInfo } from '../shared/lib/router/utils/get-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import { getCloneableBody } from './body-streams'</span><span class="s3">\n</span><span class="s1">import { checkIsOnDemandRevalidate } from './api-utils'</span><span class="s3">\n</span><span class="s1">import ResponseCache, {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './response-cache'</span><span class="s3">\n</span><span class="s1">import { IncrementalCache } from './lib/incremental-cache'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../shared/lib/router/utils/app-paths'</span><span class="s3">\n\n</span><span class="s1">import { setHttpClientAndAgentOptions } from './setup-http-agent-env'</span><span class="s3">\n\n</span><span class="s1">import { isPagesAPIRouteMatch } from './route-matches/pages-api-route-match'</span><span class="s3">\n</span><span class="s1">import type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match'</span><span class="s3">\n</span><span class="s1">import type { MatchOptions } from './route-matcher-managers/route-matcher-manager'</span><span class="s3">\n</span><span class="s1">import { BubbledError, getTracer } from './lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NextNodeServerSpan } from './lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { nodeFs } from './lib/node-fs-methods'</span><span class="s3">\n</span><span class="s1">import { getRouteRegex } from '../shared/lib/router/utils/route-regex'</span><span class="s3">\n</span><span class="s1">import { pipeToNodeResponse } from './pipe-readable'</span><span class="s3">\n</span><span class="s1">import { createRequestResponseMocks } from './lib/mock-request'</span><span class="s3">\n</span><span class="s1">import { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { signalFromNodeResponse } from './web/spec-extension/adapters/next-request'</span><span class="s3">\n</span><span class="s1">import { loadManifest } from './load-manifest.external'</span><span class="s3">\n</span><span class="s1">import { lazyRenderAppPage } from './route-modules/app-page/module.render'</span><span class="s3">\n</span><span class="s1">import { lazyRenderPagesPage } from './route-modules/pages/module.render'</span><span class="s3">\n</span><span class="s1">import { interopDefault } from '../lib/interop-default'</span><span class="s3">\n</span><span class="s1">import { formatDynamicImportPath } from '../lib/format-dynamic-import-path'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites'</span><span class="s3">\n</span><span class="s1">import type { ServerOnInstrumentationRequestError } from './app-render/types'</span><span class="s3">\n</span><span class="s1">import { RouteKind } from './route-kind'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import { AwaiterOnce } from './after/awaiter'</span><span class="s3">\n</span><span class="s1">import { AsyncCallbackSet } from './lib/async-callback-set'</span><span class="s3">\n</span><span class="s1">import { initializeCacheHandlers, setCacheHandler } from './use-cache/handlers'</span><span class="s3">\n</span><span class="s1">import type { UnwrapPromise } from '../lib/coalesced-function'</span><span class="s3">\n</span><span class="s1">import { populateStaticEnv } from '../lib/static-env'</span><span class="s3">\n</span><span class="s1">import { isPostpone } from './lib/router-utils/is-postpone'</span><span class="s3">\n</span><span class="s1">import { NodeModuleLoader } from './lib/module-loader/node-module-loader'</span><span class="s3">\n</span><span class="s1">import { NoFallbackError } from '../shared/lib/no-fallback-error.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ensureInstrumentationRegistered,</span><span class="s3">\n  </span><span class="s1">getInstrumentationModule,</span><span class="s3">\n</span><span class="s1">} from './lib/router-utils/instrumentation-globals.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RouterServerContextSymbol,</span><span class="s3">\n  </span><span class="s1">routerServerGlobal,</span><span class="s3">\n</span><span class="s1">} from './lib/router-utils/router-server-context'</span><span class="s3">\n\n</span><span class="s1">export * from './base-server'</span><span class="s3">\n\n</span><span class="s1">// For module that can be both CJS or ESM</span><span class="s3">\n</span><span class="s1">const dynamicImportEsmDefault = process.env.NEXT_MINIMAL</span><span class="s3">\n  </span><span class="s1">? (id: string) =&gt;</span><span class="s3">\n      </span><span class="s1">import(/* webpackIgnore: true */ id).then((mod) =&gt; mod.default || mod)</span><span class="s3">\n  </span><span class="s1">: (id: string) =&gt; import(id).then((mod) =&gt; mod.default || mod)</span><span class="s3">\n\n</span><span class="s1">export type NodeRequestHandler = BaseRequestHandler&lt;</span><span class="s3">\n  </span><span class="s1">IncomingMessage | NodeNextRequest,</span><span class="s3">\n  </span><span class="s1">ServerResponse | NodeNextResponse</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">type NodeRouteHandler = RouteHandler&lt;NodeNextRequest, NodeNextResponse&gt;</span><span class="s3">\n\n</span><span class="s1">const MiddlewareMatcherCache = new WeakMap&lt;</span><span class="s3">\n  </span><span class="s1">MiddlewareManifest['middleware'][string],</span><span class="s3">\n  </span><span class="s1">MiddlewareRouteMatch</span><span class="s3">\n</span><span class="s1">&gt;()</span><span class="s3">\n\n</span><span class="s1">function getMiddlewareMatcher(</span><span class="s3">\n  </span><span class="s1">info: MiddlewareManifest['middleware'][string]</span><span class="s3">\n</span><span class="s1">): MiddlewareRouteMatch {</span><span class="s3">\n  </span><span class="s1">const stored = MiddlewareMatcherCache.get(info)</span><span class="s3">\n  </span><span class="s1">if (stored) {</span><span class="s3">\n    </span><span class="s1">return stored</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!Array.isArray(info.matchers)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invariant: invalid matchers for middleware ${JSON.stringify(info)}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const matcher = getMiddlewareRouteMatcher(info.matchers)</span><span class="s3">\n  </span><span class="s1">MiddlewareMatcherCache.set(info, matcher)</span><span class="s3">\n  </span><span class="s1">return matcher</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function installProcessErrorHandlers(</span><span class="s3">\n  </span><span class="s1">shouldRemoveUncaughtErrorAndRejectionListeners: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// The conventional wisdom of Node.js and other runtimes is to treat</span><span class="s3">\n  </span><span class="s1">// unhandled errors as fatal and exit the process.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// But Next.js is not a generic JS runtime  it's a specialized runtime for</span><span class="s3">\n  </span><span class="s1">// React Server Components.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Many unhandled rejections are due to the late-awaiting pattern for</span><span class="s3">\n  </span><span class="s1">// prefetching data. In Next.js it's OK to call an async function without</span><span class="s3">\n  </span><span class="s1">// immediately awaiting it, to start the request as soon as possible</span><span class="s3">\n  </span><span class="s1">// without blocking unncessarily on the result. These can end up</span><span class="s3">\n  </span><span class="s1">// triggering an </span><span class="s3">\&quot;</span><span class="s1">unhandledRejection</span><span class="s3">\&quot; </span><span class="s1">if it later turns out that the</span><span class="s3">\n  </span><span class="s1">// data is not needed to render the page. Example:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//     const promise = fetchData()</span><span class="s3">\n  </span><span class="s1">//     const shouldShow = await checkCondition()</span><span class="s3">\n  </span><span class="s1">//     if (shouldShow) {</span><span class="s3">\n  </span><span class="s1">//       return &lt;Component promise={promise} /&gt;</span><span class="s3">\n  </span><span class="s1">//     }</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// In this example, `fetchData` is called immediately to start the request</span><span class="s3">\n  </span><span class="s1">// as soon as possible, but if `shouldShow` is false, then it will be</span><span class="s3">\n  </span><span class="s1">// discarded without unwrapping its result. If it errors, it will trigger</span><span class="s3">\n  </span><span class="s1">// an </span><span class="s3">\&quot;</span><span class="s1">unhandledRejection</span><span class="s3">\&quot; </span><span class="s1">event.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Ideally, we would suppress these rejections completely without warning,</span><span class="s3">\n  </span><span class="s1">// because we don't consider them real errors. (TODO: Currently we do warn.)</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// But regardless of whether we do or don't warn, we definitely shouldn't</span><span class="s3">\n  </span><span class="s1">// crash the entire process.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Even a </span><span class="s3">\&quot;</span><span class="s1">legit</span><span class="s3">\&quot; </span><span class="s1">unhandled error unrelated to prefetching shouldn't</span><span class="s3">\n  </span><span class="s1">// prevent the rest of the page from rendering.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// So, we're going to intentionally override the default error handling</span><span class="s3">\n  </span><span class="s1">// behavior of the outer JS runtime to be more forgiving</span><span class="s3">\n\n  </span><span class="s1">// Remove any existing </span><span class="s3">\&quot;</span><span class="s1">unhandledRejection</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">uncaughtException</span><span class="s3">\&quot; </span><span class="s1">handlers.</span><span class="s3">\n  </span><span class="s1">// This is gated behind an experimental flag until we've considered the impact</span><span class="s3">\n  </span><span class="s1">// in various deployment environments. It's possible this may always need to</span><span class="s3">\n  </span><span class="s1">// be configurable.</span><span class="s3">\n  </span><span class="s1">if (shouldRemoveUncaughtErrorAndRejectionListeners) {</span><span class="s3">\n    </span><span class="s1">process.removeAllListeners('uncaughtException')</span><span class="s3">\n    </span><span class="s1">process.removeAllListeners('unhandledRejection')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Install a new handler to prevent the process from crashing.</span><span class="s3">\n  </span><span class="s1">process.on('unhandledRejection', (reason: unknown) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (isPostpone(reason)) {</span><span class="s3">\n      </span><span class="s1">// React postpones that are unhandled might end up logged here but they're</span><span class="s3">\n      </span><span class="s1">// not really errors. They're just part of rendering.</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Immediately log the error.</span><span class="s3">\n    </span><span class="s1">// TODO: Ideally, if we knew that this error was triggered by application</span><span class="s3">\n    </span><span class="s1">// code, we would suppress it entirely without logging. We can't reliably</span><span class="s3">\n    </span><span class="s1">// detect all of these, but when cacheComponents is enabled, we could suppress</span><span class="s3">\n    </span><span class="s1">// at least some of them by waiting to log the error until after all in-</span><span class="s3">\n    </span><span class="s1">// progress renders have completed. Then, only log errors for which there</span><span class="s3">\n    </span><span class="s1">// was not a corresponding </span><span class="s3">\&quot;</span><span class="s1">rejectionHandled</span><span class="s3">\&quot; </span><span class="s1">event.</span><span class="s3">\n    </span><span class="s1">console.error(reason)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">process.on('rejectionHandled', () =&gt; {</span><span class="s3">\n    </span><span class="s1">// TODO: See note in the unhandledRejection handler above. In the future,</span><span class="s3">\n    </span><span class="s1">// we may use the </span><span class="s3">\&quot;</span><span class="s1">rejectionHandled</span><span class="s3">\&quot; </span><span class="s1">event to de-queue an error from</span><span class="s3">\n    </span><span class="s1">// being logged.</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Unhandled exceptions are errors triggered by non-async functions, so this</span><span class="s3">\n  </span><span class="s1">// is unrelated to the late-awaiting pattern. However, for similar reasons,</span><span class="s3">\n  </span><span class="s1">// we still shouldn't crash the process. Just log it.</span><span class="s3">\n  </span><span class="s1">process.on('uncaughtException', (reason: unknown) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (isPostpone(reason)) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">console.error(reason)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class NextNodeServer extends BaseServer&lt;</span><span class="s3">\n  </span><span class="s1">Options,</span><span class="s3">\n  </span><span class="s1">NodeNextRequest,</span><span class="s3">\n  </span><span class="s1">NodeNextResponse</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">protected middlewareManifestPath: string</span><span class="s3">\n  </span><span class="s1">private _serverDistDir: string | undefined</span><span class="s3">\n  </span><span class="s1">private imageResponseCache?: ResponseCache</span><span class="s3">\n  </span><span class="s1">protected renderWorkersPromises?: Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">protected dynamicRoutes?: {</span><span class="s3">\n    </span><span class="s1">match: import('../shared/lib/router/utils/route-matcher').RouteMatchFn</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">re: RegExp</span><span class="s3">\n  </span><span class="s1">}[]</span><span class="s3">\n  </span><span class="s1">private routerServerHandler?: (</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse</span><span class="s3">\n  </span><span class="s1">) =&gt; void</span><span class="s3">\n\n  </span><span class="s1">protected cleanupListeners = new AsyncCallbackSet()</span><span class="s3">\n  </span><span class="s1">protected internalWaitUntil: WaitUntil | undefined</span><span class="s3">\n  </span><span class="s1">private isDev: boolean</span><span class="s3">\n  </span><span class="s1">private sriEnabled: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(options: Options) {</span><span class="s3">\n    </span><span class="s1">// Initialize super class</span><span class="s3">\n    </span><span class="s1">super(options)</span><span class="s3">\n\n    </span><span class="s1">const isDev = options.dev ?? false</span><span class="s3">\n    </span><span class="s1">this.isDev = isDev</span><span class="s3">\n    </span><span class="s1">this.sriEnabled = Boolean(options.conf.experimental?.sri?.algorithm)</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* This sets environment variable to be used at the time of SSR by head.tsx.</span><span class="s3">\n     </span><span class="s1">* Using this from process.env allows targeting SSR by calling</span><span class="s3">\n     </span><span class="s1">* `process.env.__NEXT_OPTIMIZE_CSS`.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (this.renderOpts.optimizeCss) {</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.renderOpts.nextScriptWorkers) {</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_SCRIPT_WORKERS = JSON.stringify(true)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.experimental.useSkewCookie</span><span class="s3">\n      </span><span class="s1">? ''</span><span class="s3">\n      </span><span class="s1">: this.nextConfig.deploymentId || ''</span><span class="s3">\n\n    </span><span class="s1">if (!this.minimalMode) {</span><span class="s3">\n      </span><span class="s1">this.imageResponseCache = new ResponseCache(this.minimalMode)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { appDocumentPreloading } = this.nextConfig.experimental</span><span class="s3">\n    </span><span class="s1">const isDefaultEnabled = typeof appDocumentPreloading === 'undefined'</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!options.dev &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(appDocumentPreloading === true ||</span><span class="s3">\n        </span><span class="s1">!(this.minimalMode &amp;&amp; isDefaultEnabled))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// pre-warm _document and _app as these will be</span><span class="s3">\n      </span><span class="s1">// needed for most requests</span><span class="s3">\n      </span><span class="s1">loadComponents({</span><span class="s3">\n        </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n        </span><span class="s1">page: '/_document',</span><span class="s3">\n        </span><span class="s1">isAppPath: false,</span><span class="s3">\n        </span><span class="s1">isDev: this.isDev,</span><span class="s3">\n        </span><span class="s1">sriEnabled: this.sriEnabled,</span><span class="s3">\n      </span><span class="s1">}).catch(() =&gt; {})</span><span class="s3">\n      </span><span class="s1">loadComponents({</span><span class="s3">\n        </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n        </span><span class="s1">page: '/_app',</span><span class="s3">\n        </span><span class="s1">isAppPath: false,</span><span class="s3">\n        </span><span class="s1">isDev: this.isDev,</span><span class="s3">\n        </span><span class="s1">sriEnabled: this.sriEnabled,</span><span class="s3">\n      </span><span class="s1">}).catch(() =&gt; {})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!options.dev &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.nextConfig.experimental.preloadEntriesOnStart</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.unstable_preloadEntries()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!options.dev) {</span><span class="s3">\n      </span><span class="s1">const { dynamicRoutes = [] } = this.getRoutesManifest() ?? {}</span><span class="s3">\n      </span><span class="s1">this.dynamicRoutes = dynamicRoutes.map((r) =&gt; {</span><span class="s3">\n        </span><span class="s1">// TODO: can we just re-use the regex from the manifest?</span><span class="s3">\n        </span><span class="s1">const regex = getRouteRegex(r.page)</span><span class="s3">\n        </span><span class="s1">const match = getRouteMatcher(regex)</span><span class="s3">\n\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">match,</span><span class="s3">\n          </span><span class="s1">page: r.page,</span><span class="s3">\n          </span><span class="s1">re: regex.re,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// ensure options are set when loadConfig isn't called</span><span class="s3">\n    </span><span class="s1">setHttpClientAndAgentOptions(this.nextConfig)</span><span class="s3">\n\n    </span><span class="s1">// Intercept fetch and other testmode apis.</span><span class="s3">\n    </span><span class="s1">if (this.serverOptions.experimentalTestProxy) {</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_PRIVATE_TEST_PROXY = 'true'</span><span class="s3">\n      </span><span class="s1">const { interceptTestApis } =</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @next/internal/typechecked-require -- experimental/testmode is not built ins next/dist/esm</span><span class="s3">\n        </span><span class="s1">require('next/dist/experimental/testmode/server') as typeof import('../experimental/testmode/server')</span><span class="s3">\n      </span><span class="s1">interceptTestApis()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.middlewareManifestPath = join(this.serverDistDir, MIDDLEWARE_MANIFEST)</span><span class="s3">\n\n    </span><span class="s1">// This is just optimization to fire prepare as soon as possible. It will be</span><span class="s3">\n    </span><span class="s1">// properly awaited later. We add the catch here to ensure that it does not</span><span class="s3">\n    </span><span class="s1">// cause a unhandled promise rejection. The promise rejection will be</span><span class="s3">\n    </span><span class="s1">// handled later on via the `await` when the request handler is called.</span><span class="s3">\n    </span><span class="s1">if (!options.dev) {</span><span class="s3">\n      </span><span class="s1">this.prepare().catch((err) =&gt; {</span><span class="s3">\n        </span><span class="s1">console.error('Failed to prepare server', err)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// when using compile mode static env isn't inlined so we</span><span class="s3">\n    </span><span class="s1">// need to populate in normal runtime env</span><span class="s3">\n    </span><span class="s1">if (this.renderOpts.isExperimentalCompile) {</span><span class="s3">\n      </span><span class="s1">populateStaticEnv(this.nextConfig)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const shouldRemoveUncaughtErrorAndRejectionListeners = Boolean(</span><span class="s3">\n      </span><span class="s1">options.conf.experimental?.removeUncaughtErrorAndRejectionListeners</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">installProcessErrorHandlers(shouldRemoveUncaughtErrorAndRejectionListeners)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async unstable_preloadEntries(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">// Ensure prepare process will be finished before preloading entries.</span><span class="s3">\n    </span><span class="s1">await this.prepare()</span><span class="s3">\n\n    </span><span class="s1">const appPathsManifest = this.getAppPathsManifest()</span><span class="s3">\n    </span><span class="s1">const pagesManifest = this.getPagesManifest()</span><span class="s3">\n\n    </span><span class="s1">await this.loadCustomCacheHandlers()</span><span class="s3">\n\n    </span><span class="s1">for (const page of Object.keys(pagesManifest || {})) {</span><span class="s3">\n      </span><span class="s1">await loadComponents({</span><span class="s3">\n        </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n        </span><span class="s1">page,</span><span class="s3">\n        </span><span class="s1">isAppPath: false,</span><span class="s3">\n        </span><span class="s1">isDev: this.isDev,</span><span class="s3">\n        </span><span class="s1">sriEnabled: this.sriEnabled,</span><span class="s3">\n      </span><span class="s1">}).catch(() =&gt; {})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const page of Object.keys(appPathsManifest || {})) {</span><span class="s3">\n      </span><span class="s1">await loadComponents({</span><span class="s3">\n        </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n        </span><span class="s1">page,</span><span class="s3">\n        </span><span class="s1">isAppPath: true,</span><span class="s3">\n        </span><span class="s1">isDev: this.isDev,</span><span class="s3">\n        </span><span class="s1">sriEnabled: this.sriEnabled,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">.then(async ({ ComponentMod }) =&gt; {</span><span class="s3">\n          </span><span class="s1">// we need to ensure fetch is patched before we require the page,</span><span class="s3">\n          </span><span class="s1">// otherwise if the fetch is patched by user code, we will be patching it</span><span class="s3">\n          </span><span class="s1">// too late and there won't be any caching behaviors</span><span class="s3">\n          </span><span class="s1">ComponentMod.patchFetch()</span><span class="s3">\n\n          </span><span class="s1">const webpackRequire = ComponentMod.__next_app__.require</span><span class="s3">\n          </span><span class="s1">if (webpackRequire?.m) {</span><span class="s3">\n            </span><span class="s1">for (const id of Object.keys(webpackRequire.m)) {</span><span class="s3">\n              </span><span class="s1">await webpackRequire(id)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">.catch(() =&gt; {})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async handleUpgrade(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">// The web server does not support web sockets, it's only used for HMR in</span><span class="s3">\n    </span><span class="s1">// development.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async loadInstrumentationModule() {</span><span class="s3">\n    </span><span class="s1">if (!this.serverOptions.dev) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">this.instrumentation = await getInstrumentationModule(</span><span class="s3">\n          </span><span class="s1">this.dir,</span><span class="s3">\n          </span><span class="s1">this.nextConfig.distDir</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (err: any) {</span><span class="s3">\n        </span><span class="s1">if (err.code !== 'MODULE_NOT_FOUND') {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">'An error occurred while loading the instrumentation hook',</span><span class="s3">\n            </span><span class="s1">{ cause: err }</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.instrumentation</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async prepareImpl() {</span><span class="s3">\n    </span><span class="s1">await super.prepareImpl()</span><span class="s3">\n    </span><span class="s1">await this.runInstrumentationHookIfAvailable()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async runInstrumentationHookIfAvailable() {</span><span class="s3">\n    </span><span class="s1">await ensureInstrumentationRegistered(this.dir, this.nextConfig.distDir)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected loadEnvConfig({</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">forceReload,</span><span class="s3">\n    </span><span class="s1">silent,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">dev: boolean</span><span class="s3">\n    </span><span class="s1">forceReload?: boolean</span><span class="s3">\n    </span><span class="s1">silent?: boolean</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">loadEnvConfig(</span><span class="s3">\n      </span><span class="s1">this.dir,</span><span class="s3">\n      </span><span class="s1">dev,</span><span class="s3">\n      </span><span class="s1">silent ? { info: () =&gt; {}, error: () =&gt; {} } : Log,</span><span class="s3">\n      </span><span class="s1">forceReload</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async loadCustomCacheHandlers() {</span><span class="s3">\n    </span><span class="s1">const { cacheHandlers } = this.nextConfig.experimental</span><span class="s3">\n    </span><span class="s1">if (!cacheHandlers) return</span><span class="s3">\n\n    </span><span class="s1">// If we've already initialized the cache handlers interface, don't do it</span><span class="s3">\n    </span><span class="s1">// again.</span><span class="s3">\n    </span><span class="s1">if (!initializeCacheHandlers()) return</span><span class="s3">\n\n    </span><span class="s1">for (const [kind, handler] of Object.entries(cacheHandlers)) {</span><span class="s3">\n      </span><span class="s1">if (!handler) continue</span><span class="s3">\n\n      </span><span class="s1">setCacheHandler(</span><span class="s3">\n        </span><span class="s1">kind,</span><span class="s3">\n        </span><span class="s1">interopDefault(</span><span class="s3">\n          </span><span class="s1">await dynamicImportEsmDefault(</span><span class="s3">\n            </span><span class="s1">formatDynamicImportPath(this.distDir, handler)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async getIncrementalCache({</span><span class="s3">\n    </span><span class="s1">requestHeaders,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">const dev = !!this.renderOpts.dev</span><span class="s3">\n    </span><span class="s1">let CacheHandler: any</span><span class="s3">\n    </span><span class="s1">const { cacheHandler } = this.nextConfig</span><span class="s3">\n\n    </span><span class="s1">if (cacheHandler) {</span><span class="s3">\n      </span><span class="s1">CacheHandler = interopDefault(</span><span class="s3">\n        </span><span class="s1">await dynamicImportEsmDefault(</span><span class="s3">\n          </span><span class="s1">formatDynamicImportPath(this.distDir, cacheHandler)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">await this.loadCustomCacheHandlers()</span><span class="s3">\n\n    </span><span class="s1">// incremental-cache is request specific</span><span class="s3">\n    </span><span class="s1">// although can have shared caches in module scope</span><span class="s3">\n    </span><span class="s1">// per-cache handler</span><span class="s3">\n    </span><span class="s1">return new IncrementalCache({</span><span class="s3">\n      </span><span class="s1">fs: this.getCacheFilesystem(),</span><span class="s3">\n      </span><span class="s1">dev,</span><span class="s3">\n      </span><span class="s1">requestHeaders,</span><span class="s3">\n      </span><span class="s1">allowedRevalidateHeaderKeys:</span><span class="s3">\n        </span><span class="s1">this.nextConfig.experimental.allowedRevalidateHeaderKeys,</span><span class="s3">\n      </span><span class="s1">minimalMode: this.minimalMode,</span><span class="s3">\n      </span><span class="s1">serverDistDir: this.serverDistDir,</span><span class="s3">\n      </span><span class="s1">fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,</span><span class="s3">\n      </span><span class="s1">maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,</span><span class="s3">\n      </span><span class="s1">flushToDisk:</span><span class="s3">\n        </span><span class="s1">!this.minimalMode &amp;&amp; this.nextConfig.experimental.isrFlushToDisk,</span><span class="s3">\n      </span><span class="s1">getPrerenderManifest: () =&gt; this.getPrerenderManifest(),</span><span class="s3">\n      </span><span class="s1">CurCacheHandler: CacheHandler,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getResponseCache() {</span><span class="s3">\n    </span><span class="s1">return new ResponseCache(this.minimalMode)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getPublicDir(): string {</span><span class="s3">\n    </span><span class="s1">return join(this.dir, CLIENT_PUBLIC_FILES_PATH)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getHasStaticDir(): boolean {</span><span class="s3">\n    </span><span class="s1">return fs.existsSync(join(this.dir, 'static'))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getPagesManifest(): PagesManifest | undefined {</span><span class="s3">\n    </span><span class="s1">return loadManifest(</span><span class="s3">\n      </span><span class="s1">join(this.serverDistDir, PAGES_MANIFEST)</span><span class="s3">\n    </span><span class="s1">) as PagesManifest</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getAppPathsManifest(): PagesManifest | undefined {</span><span class="s3">\n    </span><span class="s1">if (!this.enabledDirectories.app) return undefined</span><span class="s3">\n\n    </span><span class="s1">return loadManifest(</span><span class="s3">\n      </span><span class="s1">join(this.serverDistDir, APP_PATHS_MANIFEST)</span><span class="s3">\n    </span><span class="s1">) as PagesManifest</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getinterceptionRoutePatterns(): RegExp[] {</span><span class="s3">\n    </span><span class="s1">if (!this.enabledDirectories.app) return []</span><span class="s3">\n\n    </span><span class="s1">const routesManifest = this.getRoutesManifest()</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">routesManifest?.rewrites.beforeFiles</span><span class="s3">\n        </span><span class="s1">.filter(isInterceptionRouteRewrite)</span><span class="s3">\n        </span><span class="s1">.map((rewrite) =&gt; new RegExp(rewrite.regex)) ?? []</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async hasPage(pathname: string): Promise&lt;boolean&gt; {</span><span class="s3">\n    </span><span class="s1">return !!getMaybePagePath(</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">this.distDir,</span><span class="s3">\n      </span><span class="s1">this.nextConfig.i18n?.locales,</span><span class="s3">\n      </span><span class="s1">this.enabledDirectories.app</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getBuildId(): string {</span><span class="s3">\n    </span><span class="s1">const buildIdFile = join(this.distDir, BUILD_ID_FILE)</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">return fs.readFileSync(buildIdFile, 'utf8').trim()</span><span class="s3">\n    </span><span class="s1">} catch (err: any) {</span><span class="s3">\n      </span><span class="s1">if (err.code === 'ENOENT') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getEnabledDirectories(dev: boolean): NextEnabledDirectories {</span><span class="s3">\n    </span><span class="s1">const dir = dev ? this.dir : this.serverDistDir</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">app: findDir(dir, 'app') ? true : false,</span><span class="s3">\n      </span><span class="s1">pages: findDir(dir, 'pages') ? true : false,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected sendRenderResult(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse,</span><span class="s3">\n    </span><span class="s1">options: {</span><span class="s3">\n      </span><span class="s1">result: RenderResult</span><span class="s3">\n      </span><span class="s1">generateEtags: boolean</span><span class="s3">\n      </span><span class="s1">poweredByHeader: boolean</span><span class="s3">\n      </span><span class="s1">cacheControl: CacheControl | undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return sendRenderResult({</span><span class="s3">\n      </span><span class="s1">req: req.originalRequest,</span><span class="s3">\n      </span><span class="s1">res: res.originalResponse,</span><span class="s3">\n      </span><span class="s1">result: options.result,</span><span class="s3">\n      </span><span class="s1">generateEtags: options.generateEtags,</span><span class="s3">\n      </span><span class="s1">poweredByHeader: options.poweredByHeader,</span><span class="s3">\n      </span><span class="s1">cacheControl: options.cacheControl,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async runApi(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">match: PagesAPIRouteMatch</span><span class="s3">\n  </span><span class="s1">): Promise&lt;boolean&gt; {</span><span class="s3">\n    </span><span class="s1">const edgeFunctionsPages = this.getEdgeFunctionsPages()</span><span class="s3">\n\n    </span><span class="s1">for (const edgeFunctionsPage of edgeFunctionsPages) {</span><span class="s3">\n      </span><span class="s1">if (edgeFunctionsPage === match.definition.pathname) {</span><span class="s3">\n        </span><span class="s1">const handledAsEdgeFunction = await this.runEdgeFunction({</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">res,</span><span class="s3">\n          </span><span class="s1">query,</span><span class="s3">\n          </span><span class="s1">params: match.params,</span><span class="s3">\n          </span><span class="s1">page: match.definition.pathname,</span><span class="s3">\n          </span><span class="s1">appPaths: null,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">if (handledAsEdgeFunction) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// The module supports minimal mode, load the minimal module.</span><span class="s3">\n    </span><span class="s1">// Restore original URL as the handler handles it's own parsing</span><span class="s3">\n    </span><span class="s1">const parsedInitUrl = parseUrl(getRequestMeta(req, 'initURL') || req.url)</span><span class="s3">\n    </span><span class="s1">req.url = `${parsedInitUrl.pathname}${parsedInitUrl.search || ''}`</span><span class="s3">\n\n    </span><span class="s1">const loader = new NodeModuleLoader()</span><span class="s3">\n    </span><span class="s1">const module = (await loader.load(match.definition.filename)) as {</span><span class="s3">\n      </span><span class="s1">handler: (</span><span class="s3">\n        </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n        </span><span class="s1">res: ServerResponse,</span><span class="s3">\n        </span><span class="s1">ctx: {</span><span class="s3">\n          </span><span class="s1">waitUntil: ReturnType&lt;BaseServer['getWaitUntil']&gt;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addRequestMeta(</span><span class="s3">\n      </span><span class="s1">req.originalRequest,</span><span class="s3">\n      </span><span class="s1">'relativeProjectDir',</span><span class="s3">\n      </span><span class="s1">relative(process.cwd(), this.dir)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(req.originalRequest, 'distDir', this.distDir)</span><span class="s3">\n    </span><span class="s1">await module.handler(req.originalRequest, res.originalResponse, {</span><span class="s3">\n      </span><span class="s1">waitUntil: this.getWaitUntil(),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async renderHTML(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">renderOpts: LoadedRenderOpts</span><span class="s3">\n  </span><span class="s1">): Promise&lt;RenderResult&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(NextNodeServerSpan.renderHTML, async () =&gt;</span><span class="s3">\n      </span><span class="s1">this.renderHTMLImpl(req, res, pathname, query, renderOpts)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async renderHTMLImpl(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">renderOpts: LoadedRenderOpts</span><span class="s3">\n  </span><span class="s1">): Promise&lt;RenderResult&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_MINIMAL) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Invariant: renderHTML should not be called in minimal mode'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// the `else` branch is needed for tree-shaking</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Due to the way we pass data by mutating `renderOpts`, we can't extend the</span><span class="s3">\n      </span><span class="s1">// object here but only updating its `nextFontManifest` field.</span><span class="s3">\n      </span><span class="s1">// https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952</span><span class="s3">\n      </span><span class="s1">renderOpts.nextFontManifest = this.nextFontManifest</span><span class="s3">\n\n      </span><span class="s1">if (this.enabledDirectories.app &amp;&amp; renderOpts.isAppPath) {</span><span class="s3">\n        </span><span class="s1">return lazyRenderAppPage(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">res,</span><span class="s3">\n          </span><span class="s1">pathname,</span><span class="s3">\n          </span><span class="s1">query,</span><span class="s3">\n          </span><span class="s1">// This code path does not service revalidations for unknown param</span><span class="s3">\n          </span><span class="s1">// shells. As a result, we don't need to pass in the unknown params.</span><span class="s3">\n          </span><span class="s1">null,</span><span class="s3">\n          </span><span class="s1">renderOpts,</span><span class="s3">\n          </span><span class="s1">this.getServerComponentsHmrCache(),</span><span class="s3">\n          </span><span class="s1">false,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">buildId: this.buildId,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// TODO: re-enable this once we've refactored to use implicit matches</span><span class="s3">\n      </span><span class="s1">// throw new Error('Invariant: render should have used routeModule')</span><span class="s3">\n\n      </span><span class="s1">return lazyRenderPagesPage(</span><span class="s3">\n        </span><span class="s1">req.originalRequest,</span><span class="s3">\n        </span><span class="s1">res.originalResponse,</span><span class="s3">\n        </span><span class="s1">pathname,</span><span class="s3">\n        </span><span class="s1">query,</span><span class="s3">\n        </span><span class="s1">renderOpts,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">buildId: this.buildId,</span><span class="s3">\n          </span><span class="s1">deploymentId: this.nextConfig.deploymentId,</span><span class="s3">\n          </span><span class="s1">customServer: this.serverOptions.customServer || undefined,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">isFallback: false,</span><span class="s3">\n          </span><span class="s1">isDraftMode: renderOpts.isDraftMode,</span><span class="s3">\n          </span><span class="s1">developmentNotFoundSourcePage: getRequestMeta(</span><span class="s3">\n            </span><span class="s1">req,</span><span class="s3">\n            </span><span class="s1">'developmentNotFoundSourcePage'</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async imageOptimizer(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse,</span><span class="s3">\n    </span><span class="s1">paramsResult: import('./image-optimizer').ImageParamsResult,</span><span class="s3">\n    </span><span class="s1">previousCacheEntry?: IncrementalResponseCacheEntry | null</span><span class="s3">\n  </span><span class="s1">): Promise&lt;{</span><span class="s3">\n    </span><span class="s1">buffer: Buffer</span><span class="s3">\n    </span><span class="s1">contentType: string</span><span class="s3">\n    </span><span class="s1">maxAge: number</span><span class="s3">\n    </span><span class="s1">upstreamEtag: string</span><span class="s3">\n    </span><span class="s1">etag: string</span><span class="s3">\n  </span><span class="s1">}&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_MINIMAL) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'invariant: imageOptimizer should not be called in minimal mode'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const { imageOptimizer, fetchExternalImage, fetchInternalImage } =</span><span class="s3">\n        </span><span class="s1">require('./image-optimizer') as typeof import('./image-optimizer')</span><span class="s3">\n\n      </span><span class="s1">const handleInternalReq = async (</span><span class="s3">\n        </span><span class="s1">newReq: IncomingMessage,</span><span class="s3">\n        </span><span class="s1">newRes: ServerResponse</span><span class="s3">\n      </span><span class="s1">) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (newReq.url === req.url) {</span><span class="s3">\n          </span><span class="s1">throw new Error(`Invariant attempted to optimize _next/image itself`)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (!this.routerServerHandler) {</span><span class="s3">\n          </span><span class="s1">throw new Error(`Invariant missing routerServerHandler`)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">await this.routerServerHandler(newReq, newRes)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const { isAbsolute, href } = paramsResult</span><span class="s3">\n\n      </span><span class="s1">const imageUpstream = isAbsolute</span><span class="s3">\n        </span><span class="s1">? await fetchExternalImage(href)</span><span class="s3">\n        </span><span class="s1">: await fetchInternalImage(</span><span class="s3">\n            </span><span class="s1">href,</span><span class="s3">\n            </span><span class="s1">req.originalRequest,</span><span class="s3">\n            </span><span class="s1">res.originalResponse,</span><span class="s3">\n            </span><span class="s1">handleInternalReq</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">return imageOptimizer(imageUpstream, paramsResult, this.nextConfig, {</span><span class="s3">\n        </span><span class="s1">isDev: this.renderOpts.dev,</span><span class="s3">\n        </span><span class="s1">previousCacheEntry,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getPagePath(pathname: string, locales?: string[]): string {</span><span class="s3">\n    </span><span class="s1">return getPagePath(</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">this.distDir,</span><span class="s3">\n      </span><span class="s1">locales,</span><span class="s3">\n      </span><span class="s1">this.enabledDirectories.app</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async renderPageComponent(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;NodeNextRequest, NodeNextResponse&gt;,</span><span class="s3">\n    </span><span class="s1">bubbleNoFallback: boolean</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const edgeFunctionsPages = this.getEdgeFunctionsPages() || []</span><span class="s3">\n    </span><span class="s1">if (edgeFunctionsPages.length) {</span><span class="s3">\n      </span><span class="s1">const appPaths = this.getOriginalAppPaths(ctx.pathname)</span><span class="s3">\n      </span><span class="s1">const isAppPath = Array.isArray(appPaths)</span><span class="s3">\n\n      </span><span class="s1">let page = ctx.pathname</span><span class="s3">\n      </span><span class="s1">if (isAppPath) {</span><span class="s3">\n        </span><span class="s1">// When it's an array, we need to pass all parallel routes to the loader.</span><span class="s3">\n        </span><span class="s1">page = appPaths[0]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">for (const edgeFunctionsPage of edgeFunctionsPages) {</span><span class="s3">\n        </span><span class="s1">if (edgeFunctionsPage === page) {</span><span class="s3">\n          </span><span class="s1">await this.runEdgeFunction({</span><span class="s3">\n            </span><span class="s1">req: ctx.req,</span><span class="s3">\n            </span><span class="s1">res: ctx.res,</span><span class="s3">\n            </span><span class="s1">query: ctx.query,</span><span class="s3">\n            </span><span class="s1">params: ctx.renderOpts.params,</span><span class="s3">\n            </span><span class="s1">page,</span><span class="s3">\n            </span><span class="s1">appPaths,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return super.renderPageComponent(ctx, bubbleNoFallback)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async findPageComponents({</span><span class="s3">\n    </span><span class="s1">locale,</span><span class="s3">\n    </span><span class="s1">page,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">isAppPath,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">locale: string | undefined</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n    </span><span class="s1">params: Params</span><span class="s3">\n    </span><span class="s1">isAppPath: boolean</span><span class="s3">\n    </span><span class="s1">// The following parameters are used in the development server's</span><span class="s3">\n    </span><span class="s1">// implementation.</span><span class="s3">\n    </span><span class="s1">sriEnabled?: boolean</span><span class="s3">\n    </span><span class="s1">appPaths?: ReadonlyArray&lt;string&gt; | null</span><span class="s3">\n    </span><span class="s1">shouldEnsure: boolean</span><span class="s3">\n    </span><span class="s1">url?: string</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;FindComponentsResult | null&gt; {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">NextNodeServerSpan.findPageComponents,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">spanName: 'resolve page components',</span><span class="s3">\n        </span><span class="s1">attributes: {</span><span class="s3">\n          </span><span class="s1">'next.route': isAppPath ? normalizeAppPath(page) : page,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">() =&gt;</span><span class="s3">\n        </span><span class="s1">this.findPageComponentsImpl({</span><span class="s3">\n          </span><span class="s1">locale,</span><span class="s3">\n          </span><span class="s1">page,</span><span class="s3">\n          </span><span class="s1">query,</span><span class="s3">\n          </span><span class="s1">params,</span><span class="s3">\n          </span><span class="s1">isAppPath,</span><span class="s3">\n          </span><span class="s1">url,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async findPageComponentsImpl({</span><span class="s3">\n    </span><span class="s1">locale,</span><span class="s3">\n    </span><span class="s1">page,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">isAppPath,</span><span class="s3">\n    </span><span class="s1">url: _url,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">locale: string | undefined</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n    </span><span class="s1">params: Params</span><span class="s3">\n    </span><span class="s1">isAppPath: boolean</span><span class="s3">\n    </span><span class="s1">url?: string</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;FindComponentsResult | null&gt; {</span><span class="s3">\n    </span><span class="s1">const pagePaths: string[] = [page]</span><span class="s3">\n    </span><span class="s1">if (query.amp) {</span><span class="s3">\n      </span><span class="s1">// try serving a static AMP version first</span><span class="s3">\n      </span><span class="s1">pagePaths.unshift(</span><span class="s3">\n        </span><span class="s1">(isAppPath ? normalizeAppPath(page) : normalizePagePath(page)) + '.amp'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (locale) {</span><span class="s3">\n      </span><span class="s1">pagePaths.unshift(</span><span class="s3">\n        </span><span class="s1">...pagePaths.map((path) =&gt; `/${locale}${path === '/' ? '' : path}`)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const pagePath of pagePaths) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const components = await loadComponents({</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">page: pagePath,</span><span class="s3">\n          </span><span class="s1">isAppPath,</span><span class="s3">\n          </span><span class="s1">isDev: this.isDev,</span><span class="s3">\n          </span><span class="s1">sriEnabled: this.sriEnabled,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">locale &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof components.Component === 'string' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!pagePath.startsWith(`/${locale}/`) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">pagePath !== `/${locale}`</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// if loading an static HTML file the locale is required</span><span class="s3">\n          </span><span class="s1">// to be present since all HTML files are output under their locale</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">components,</span><span class="s3">\n          </span><span class="s1">query: {</span><span class="s3">\n            </span><span class="s1">...(!this.renderOpts.isExperimentalCompile &amp;&amp;</span><span class="s3">\n            </span><span class="s1">components.getStaticProps</span><span class="s3">\n              </span><span class="s1">? ({</span><span class="s3">\n                  </span><span class="s1">amp: query.amp,</span><span class="s3">\n                </span><span class="s1">} as NextParsedUrlQuery)</span><span class="s3">\n              </span><span class="s1">: query),</span><span class="s3">\n            </span><span class="s1">// For appDir params is excluded.</span><span class="s3">\n            </span><span class="s1">...((isAppPath ? {} : params) || {}),</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">// we should only not throw if we failed to find the page</span><span class="s3">\n        </span><span class="s1">// in the pages-manifest</span><span class="s3">\n        </span><span class="s1">if (!(err instanceof PageNotFoundError)) {</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getNextFontManifest(): NextFontManifest | undefined {</span><span class="s3">\n    </span><span class="s1">return loadManifest(</span><span class="s3">\n      </span><span class="s1">join(this.distDir, 'server', NEXT_FONT_MANIFEST + '.json')</span><span class="s3">\n    </span><span class="s1">) as NextFontManifest</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected handleNextImageRequest: NodeRouteHandler = async (</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">res,</span><span class="s3">\n    </span><span class="s1">parsedUrl</span><span class="s3">\n  </span><span class="s1">) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!parsedUrl.pathname || !parsedUrl.pathname.startsWith('/_next/image')) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Ignore if its a middleware request</span><span class="s3">\n    </span><span class="s1">if (getRequestMeta(req, 'middlewareInvoke')) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this.minimalMode ||</span><span class="s3">\n      </span><span class="s1">this.nextConfig.output === 'export' ||</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_MINIMAL</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = 400</span><span class="s3">\n      </span><span class="s1">res.body('Bad Request').send()</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">// the `else` branch is needed for tree-shaking</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const { ImageOptimizerCache } =</span><span class="s3">\n        </span><span class="s1">require('./image-optimizer') as typeof import('./image-optimizer')</span><span class="s3">\n\n      </span><span class="s1">const imageOptimizerCache = new ImageOptimizerCache({</span><span class="s3">\n        </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n        </span><span class="s1">nextConfig: this.nextConfig,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">const { sendResponse, ImageError } =</span><span class="s3">\n        </span><span class="s1">require('./image-optimizer') as typeof import('./image-optimizer')</span><span class="s3">\n\n      </span><span class="s1">if (!this.imageResponseCache) {</span><span class="s3">\n        </span><span class="s1">throw new Error('invariant image optimizer cache was not initialized')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const imagesConfig = this.nextConfig.images</span><span class="s3">\n\n      </span><span class="s1">if (imagesConfig.loader !== 'default' || imagesConfig.unoptimized) {</span><span class="s3">\n        </span><span class="s1">await this.render404(req, res)</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const paramsResult = ImageOptimizerCache.validateParams(</span><span class="s3">\n        </span><span class="s1">req.originalRequest,</span><span class="s3">\n        </span><span class="s1">parsedUrl.query,</span><span class="s3">\n        </span><span class="s1">this.nextConfig,</span><span class="s3">\n        </span><span class="s1">!!this.renderOpts.dev</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if ('errorMessage' in paramsResult) {</span><span class="s3">\n        </span><span class="s1">res.statusCode = 400</span><span class="s3">\n        </span><span class="s1">res.body(paramsResult.errorMessage).send()</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const cacheKey = ImageOptimizerCache.getCacheKey(paramsResult)</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const { getExtension } =</span><span class="s3">\n          </span><span class="s1">require('./serve-static') as typeof import('./serve-static')</span><span class="s3">\n        </span><span class="s1">const cacheEntry = await this.imageResponseCache.get(</span><span class="s3">\n          </span><span class="s1">cacheKey,</span><span class="s3">\n          </span><span class="s1">async ({ previousCacheEntry }) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { buffer, contentType, maxAge, upstreamEtag, etag } =</span><span class="s3">\n              </span><span class="s1">await this.imageOptimizer(</span><span class="s3">\n                </span><span class="s1">req,</span><span class="s3">\n                </span><span class="s1">res,</span><span class="s3">\n                </span><span class="s1">paramsResult,</span><span class="s3">\n                </span><span class="s1">previousCacheEntry</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">return {</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.IMAGE,</span><span class="s3">\n                </span><span class="s1">buffer,</span><span class="s3">\n                </span><span class="s1">etag,</span><span class="s3">\n                </span><span class="s1">extension: getExtension(contentType) as string,</span><span class="s3">\n                </span><span class="s1">upstreamEtag,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">cacheControl: { revalidate: maxAge, expire: undefined },</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">routeKind: RouteKind.IMAGE,</span><span class="s3">\n            </span><span class="s1">incrementalCache: imageOptimizerCache,</span><span class="s3">\n            </span><span class="s1">isFallback: false,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (cacheEntry?.value?.kind !== CachedRouteKind.IMAGE) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">'invariant did not get entry from image response cache'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">sendResponse(</span><span class="s3">\n          </span><span class="s1">req.originalRequest,</span><span class="s3">\n          </span><span class="s1">res.originalResponse,</span><span class="s3">\n          </span><span class="s1">paramsResult.href,</span><span class="s3">\n          </span><span class="s1">cacheEntry.value.extension,</span><span class="s3">\n          </span><span class="s1">cacheEntry.value.buffer,</span><span class="s3">\n          </span><span class="s1">cacheEntry.value.etag,</span><span class="s3">\n          </span><span class="s1">paramsResult.isStatic,</span><span class="s3">\n          </span><span class="s1">cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT',</span><span class="s3">\n          </span><span class="s1">imagesConfig,</span><span class="s3">\n          </span><span class="s1">cacheEntry.cacheControl?.revalidate || 0,</span><span class="s3">\n          </span><span class="s1">Boolean(this.renderOpts.dev)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">if (err instanceof ImageError) {</span><span class="s3">\n          </span><span class="s1">res.statusCode = err.statusCode</span><span class="s3">\n          </span><span class="s1">res.body(err.message).send()</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected handleCatchallRenderRequest: NodeRouteHandler = async (</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">res,</span><span class="s3">\n    </span><span class="s1">parsedUrl</span><span class="s3">\n  </span><span class="s1">) =&gt; {</span><span class="s3">\n    </span><span class="s1">let { pathname, query } = parsedUrl</span><span class="s3">\n    </span><span class="s1">if (!pathname) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: pathname is undefined')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// When in minimal mode we do not bubble the fallback as the</span><span class="s3">\n    </span><span class="s1">// router-server is not present to handle the error</span><span class="s3">\n    </span><span class="s1">addRequestMeta(req, 'bubbleNoFallback', this.minimalMode ? undefined : true)</span><span class="s3">\n\n    </span><span class="s1">// This is needed to expose render404 and nextConfig</span><span class="s3">\n    </span><span class="s1">// for environments without router-server</span><span class="s3">\n    </span><span class="s1">if (!routerServerGlobal[RouterServerContextSymbol]) {</span><span class="s3">\n      </span><span class="s1">routerServerGlobal[RouterServerContextSymbol] = {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const relativeProjectDir = relative(process.cwd(), this.dir)</span><span class="s3">\n    </span><span class="s1">const existingServerContext =</span><span class="s3">\n      </span><span class="s1">routerServerGlobal[RouterServerContextSymbol][relativeProjectDir]</span><span class="s3">\n\n    </span><span class="s1">if (!existingServerContext) {</span><span class="s3">\n      </span><span class="s1">routerServerGlobal[RouterServerContextSymbol][relativeProjectDir] = {</span><span class="s3">\n        </span><span class="s1">render404: this.render404.bind(this),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">routerServerGlobal[RouterServerContextSymbol][</span><span class="s3">\n      </span><span class="s1">relativeProjectDir</span><span class="s3">\n    </span><span class="s1">].nextConfig = this.nextConfig</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">// next.js core assumes page path without trailing slash</span><span class="s3">\n      </span><span class="s1">pathname = removeTrailingSlash(pathname)</span><span class="s3">\n\n      </span><span class="s1">const options: MatchOptions = {</span><span class="s3">\n        </span><span class="s1">i18n: this.i18nProvider?.fromRequest(req, pathname),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const match = await this.matchers.match(pathname, options)</span><span class="s3">\n\n      </span><span class="s1">// If we don't have a match, try to render it anyways.</span><span class="s3">\n      </span><span class="s1">if (!match) {</span><span class="s3">\n        </span><span class="s1">await this.render(req, res, pathname, query, parsedUrl, true)</span><span class="s3">\n\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Add the match to the request so we don't have to re-run the matcher</span><span class="s3">\n      </span><span class="s1">// for the same request.</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'match', match)</span><span class="s3">\n\n      </span><span class="s1">// TODO-APP: move this to a route handler</span><span class="s3">\n      </span><span class="s1">const edgeFunctionsPages = this.getEdgeFunctionsPages()</span><span class="s3">\n      </span><span class="s1">for (const edgeFunctionsPage of edgeFunctionsPages) {</span><span class="s3">\n        </span><span class="s1">// If the page doesn't match the edge function page, skip it.</span><span class="s3">\n        </span><span class="s1">if (edgeFunctionsPage !== match.definition.page) continue</span><span class="s3">\n\n        </span><span class="s1">if (this.nextConfig.output === 'export') {</span><span class="s3">\n          </span><span class="s1">await this.render404(req, res, parsedUrl)</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">delete query[NEXT_RSC_UNION_QUERY]</span><span class="s3">\n\n        </span><span class="s1">// If we handled the request, we can return early.</span><span class="s3">\n        </span><span class="s1">// For api routes edge runtime</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">const handled = await this.runEdgeFunction({</span><span class="s3">\n            </span><span class="s1">req,</span><span class="s3">\n            </span><span class="s1">res,</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">params: match.params,</span><span class="s3">\n            </span><span class="s1">page: match.definition.page,</span><span class="s3">\n            </span><span class="s1">match,</span><span class="s3">\n            </span><span class="s1">appPaths: null,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">if (handled) return true</span><span class="s3">\n        </span><span class="s1">} catch (apiError) {</span><span class="s3">\n          </span><span class="s1">await this.instrumentationOnRequestError(apiError, req, {</span><span class="s3">\n            </span><span class="s1">routePath: match.definition.page,</span><span class="s3">\n            </span><span class="s1">routerKind: 'Pages Router',</span><span class="s3">\n            </span><span class="s1">routeType: 'route',</span><span class="s3">\n            </span><span class="s1">// Edge runtime does not support ISR</span><span class="s3">\n            </span><span class="s1">revalidateReason: undefined,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">throw apiError</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If the route was detected as being a Pages API route, then handle</span><span class="s3">\n      </span><span class="s1">// it.</span><span class="s3">\n      </span><span class="s1">// TODO: move this behavior into a route handler.</span><span class="s3">\n      </span><span class="s1">if (isPagesAPIRouteMatch(match)) {</span><span class="s3">\n        </span><span class="s1">if (this.nextConfig.output === 'export') {</span><span class="s3">\n          </span><span class="s1">await this.render404(req, res, parsedUrl)</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const handled = await this.handleApiRequest(req, res, query, match)</span><span class="s3">\n        </span><span class="s1">if (handled) return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">await this.render(req, res, pathname, query, parsedUrl, true)</span><span class="s3">\n\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">} catch (err: any) {</span><span class="s3">\n      </span><span class="s1">if (err instanceof NoFallbackError) {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (this.renderOpts.dev) {</span><span class="s3">\n          </span><span class="s1">const { formatServerError } =</span><span class="s3">\n            </span><span class="s1">require('../lib/format-server-error') as typeof import('../lib/format-server-error')</span><span class="s3">\n          </span><span class="s1">formatServerError(err)</span><span class="s3">\n          </span><span class="s1">this.logErrorWithOriginalStack(err)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">this.logError(err)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">res.statusCode = 500</span><span class="s3">\n        </span><span class="s1">await this.renderError(err, req, res, pathname, query)</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">} catch {}</span><span class="s3">\n\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Used in development only, overloaded in next-dev-server</span><span class="s3">\n  </span><span class="s1">protected logErrorWithOriginalStack(</span><span class="s3">\n    </span><span class="s1">_err?: unknown,</span><span class="s3">\n    </span><span class="s1">_type?: 'unhandledRejection' | 'uncaughtException' | 'warning' | 'app-dir'</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Invariant: logErrorWithOriginalStack can only be called on the development server'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Used in development only, overloaded in next-dev-server</span><span class="s3">\n  </span><span class="s1">protected async ensurePage(_opts: {</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">clientOnly: boolean</span><span class="s3">\n    </span><span class="s1">appPaths?: ReadonlyArray&lt;string&gt; | null</span><span class="s3">\n    </span><span class="s1">match?: RouteMatch</span><span class="s3">\n    </span><span class="s1">url?: string</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Invariant: ensurePage can only be called on the development server'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Resolves `API` request, in development builds on demand</span><span class="s3">\n   </span><span class="s1">* @param req http request</span><span class="s3">\n   </span><span class="s1">* @param res http response</span><span class="s3">\n   </span><span class="s1">* @param pathname path of request</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">protected async handleApiRequest(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">match: PagesAPIRouteMatch</span><span class="s3">\n  </span><span class="s1">): Promise&lt;boolean&gt; {</span><span class="s3">\n    </span><span class="s1">return this.runApi(req, res, query, match)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getCacheFilesystem(): CacheFs {</span><span class="s3">\n    </span><span class="s1">return nodeFs</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected normalizeReq(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest | IncomingMessage</span><span class="s3">\n  </span><span class="s1">): NodeNextRequest {</span><span class="s3">\n    </span><span class="s1">return !(req instanceof NodeNextRequest) ? new NodeNextRequest(req) : req</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected normalizeRes(</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse | ServerResponse</span><span class="s3">\n  </span><span class="s1">): NodeNextResponse {</span><span class="s3">\n    </span><span class="s1">return !(res instanceof NodeNextResponse) ? new NodeNextResponse(res) : res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getRequestHandler(): NodeRequestHandler {</span><span class="s3">\n    </span><span class="s1">const handler = this.makeRequestHandler()</span><span class="s3">\n    </span><span class="s1">if (this.serverOptions.experimentalTestProxy) {</span><span class="s3">\n      </span><span class="s1">const { wrapRequestHandlerNode } =</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @next/internal/typechecked-require -- experimental/testmode is not built ins next/dist/esm</span><span class="s3">\n        </span><span class="s1">require('next/dist/experimental/testmode/server') as typeof import('../experimental/testmode/server')</span><span class="s3">\n      </span><span class="s1">return wrapRequestHandlerNode(handler)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return handler</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private makeRequestHandler(): NodeRequestHandler {</span><span class="s3">\n    </span><span class="s1">// This is just optimization to fire prepare as soon as possible. It will be</span><span class="s3">\n    </span><span class="s1">// properly awaited later. We add the catch here to ensure that it does not</span><span class="s3">\n    </span><span class="s1">// cause an unhandled promise rejection. The promise rejection will be</span><span class="s3">\n    </span><span class="s1">// handled later on via the `await` when the request handler is called.</span><span class="s3">\n    </span><span class="s1">this.prepare().catch((err) =&gt; {</span><span class="s3">\n      </span><span class="s1">console.error('Failed to prepare server', err)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const handler = super.getRequestHandler()</span><span class="s3">\n\n    </span><span class="s1">return (req, res, parsedUrl) =&gt;</span><span class="s3">\n      </span><span class="s1">handler(this.normalizeReq(req), this.normalizeRes(res), parsedUrl)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async revalidate({</span><span class="s3">\n    </span><span class="s1">urlPath,</span><span class="s3">\n    </span><span class="s1">revalidateHeaders,</span><span class="s3">\n    </span><span class="s1">opts,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">urlPath: string</span><span class="s3">\n    </span><span class="s1">revalidateHeaders: { [key: string]: string | string[] }</span><span class="s3">\n    </span><span class="s1">opts: { unstable_onlyGenerated?: boolean }</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">const mocked = createRequestResponseMocks({</span><span class="s3">\n      </span><span class="s1">url: urlPath,</span><span class="s3">\n      </span><span class="s1">headers: revalidateHeaders,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const handler = this.getRequestHandler()</span><span class="s3">\n    </span><span class="s1">await handler(</span><span class="s3">\n      </span><span class="s1">new NodeNextRequest(mocked.req),</span><span class="s3">\n      </span><span class="s1">new NodeNextResponse(mocked.res)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">await mocked.res.hasStreamed</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">mocked.res.getHeader('x-nextjs-cache') !== 'REVALIDATED' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">mocked.res.statusCode !== 200 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!(mocked.res.statusCode === 404 &amp;&amp; opts.unstable_onlyGenerated)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`Invalid response ${mocked.res.statusCode}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async render(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse | ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query?: NextParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery,</span><span class="s3">\n    </span><span class="s1">internal = false</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return super.render(</span><span class="s3">\n      </span><span class="s1">this.normalizeReq(req),</span><span class="s3">\n      </span><span class="s1">this.normalizeRes(res),</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n      </span><span class="s1">parsedUrl,</span><span class="s3">\n      </span><span class="s1">internal</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async renderToHTML(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse | ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query?: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">return super.renderToHTML(</span><span class="s3">\n      </span><span class="s1">this.normalizeReq(req),</span><span class="s3">\n      </span><span class="s1">this.normalizeRes(res),</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async renderErrorToResponseImpl(</span><span class="s3">\n    </span><span class="s1">ctx: RequestContext&lt;NodeNextRequest, NodeNextResponse&gt;,</span><span class="s3">\n    </span><span class="s1">err: Error | null</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { req, res, query } = ctx</span><span class="s3">\n    </span><span class="s1">const is404 = res.statusCode === 404</span><span class="s3">\n\n    </span><span class="s1">if (is404 &amp;&amp; this.enabledDirectories.app) {</span><span class="s3">\n      </span><span class="s1">if (this.renderOpts.dev) {</span><span class="s3">\n        </span><span class="s1">await this.ensurePage({</span><span class="s3">\n          </span><span class="s1">page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span><span class="s3">\n          </span><span class="s1">clientOnly: false,</span><span class="s3">\n          </span><span class="s1">url: req.url,</span><span class="s3">\n        </span><span class="s1">}).catch(() =&gt; {})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">this.getEdgeFunctionsPages().includes(UNDERSCORE_NOT_FOUND_ROUTE_ENTRY)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">await this.runEdgeFunction({</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">res,</span><span class="s3">\n          </span><span class="s1">query: query || {},</span><span class="s3">\n          </span><span class="s1">params: {},</span><span class="s3">\n          </span><span class="s1">page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span><span class="s3">\n          </span><span class="s1">appPaths: null,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return super.renderErrorToResponseImpl(ctx, err)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async renderError(</span><span class="s3">\n    </span><span class="s1">err: Error | null,</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse | ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query?: NextParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">setHeaders?: boolean</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return super.renderError(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">this.normalizeReq(req),</span><span class="s3">\n      </span><span class="s1">this.normalizeRes(res),</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n      </span><span class="s1">setHeaders</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async renderErrorToHTML(</span><span class="s3">\n    </span><span class="s1">err: Error | null,</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse | ServerResponse,</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query?: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n    </span><span class="s1">return super.renderErrorToHTML(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">this.normalizeReq(req),</span><span class="s3">\n      </span><span class="s1">this.normalizeRes(res),</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">query</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async render404(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse | ServerResponse,</span><span class="s3">\n    </span><span class="s1">parsedUrl?: NextUrlWithParsedQuery,</span><span class="s3">\n    </span><span class="s1">setHeaders?: boolean</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return super.render404(</span><span class="s3">\n      </span><span class="s1">this.normalizeReq(req),</span><span class="s3">\n      </span><span class="s1">this.normalizeRes(res),</span><span class="s3">\n      </span><span class="s1">parsedUrl,</span><span class="s3">\n      </span><span class="s1">setHeaders</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getMiddlewareManifest(): MiddlewareManifest | null {</span><span class="s3">\n    </span><span class="s1">if (this.minimalMode) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const manifest: MiddlewareManifest = require(this.middlewareManifestPath)</span><span class="s3">\n      </span><span class="s1">return manifest</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/** Returns the middleware routing item if there is one. */</span><span class="s3">\n  </span><span class="s1">protected async getMiddleware(): Promise&lt;MiddlewareRoutingItem | undefined&gt; {</span><span class="s3">\n    </span><span class="s1">const manifest = this.getMiddlewareManifest()</span><span class="s3">\n    </span><span class="s1">const middleware = manifest?.middleware?.['/']</span><span class="s3">\n    </span><span class="s1">if (!middleware) {</span><span class="s3">\n      </span><span class="s1">const middlewareModule = await this.loadNodeMiddleware()</span><span class="s3">\n\n      </span><span class="s1">if (middlewareModule) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">match: getMiddlewareRouteMatcher(</span><span class="s3">\n            </span><span class="s1">middlewareModule.config?.matchers || [</span><span class="s3">\n              </span><span class="s1">{ regexp: '.*', originalSource: '/:path*' },</span><span class="s3">\n            </span><span class="s1">]</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">page: '/',</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">match: getMiddlewareMatcher(middleware),</span><span class="s3">\n      </span><span class="s1">page: '/',</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getEdgeFunctionsPages(): string[] {</span><span class="s3">\n    </span><span class="s1">const manifest = this.getMiddlewareManifest()</span><span class="s3">\n    </span><span class="s1">if (!manifest) {</span><span class="s3">\n      </span><span class="s1">return []</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return Object.keys(manifest.functions)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Get information for the edge function located in the provided page</span><span class="s3">\n   </span><span class="s1">* folder. If the edge function info can't be found it will throw</span><span class="s3">\n   </span><span class="s1">* an error.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">protected getEdgeFunctionInfo(params: {</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">/** Whether we should look for a middleware or not */</span><span class="s3">\n    </span><span class="s1">middleware: boolean</span><span class="s3">\n  </span><span class="s1">}): {</span><span class="s3">\n    </span><span class="s1">name: string</span><span class="s3">\n    </span><span class="s1">paths: string[]</span><span class="s3">\n    </span><span class="s1">wasm: { filePath: string; name: string }[]</span><span class="s3">\n    </span><span class="s1">env: { [key: string]: string }</span><span class="s3">\n    </span><span class="s1">assets?: { filePath: string; name: string }[]</span><span class="s3">\n  </span><span class="s1">} | null {</span><span class="s3">\n    </span><span class="s1">const manifest = this.getMiddlewareManifest()</span><span class="s3">\n    </span><span class="s1">if (!manifest) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let foundPage: string</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">foundPage = denormalizePagePath(normalizePagePath(params.page))</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let pageInfo = params.middleware</span><span class="s3">\n      </span><span class="s1">? manifest.middleware[foundPage]</span><span class="s3">\n      </span><span class="s1">: manifest.functions[foundPage]</span><span class="s3">\n\n    </span><span class="s1">if (!pageInfo) {</span><span class="s3">\n      </span><span class="s1">if (!params.middleware) {</span><span class="s3">\n        </span><span class="s1">throw new PageNotFoundError(foundPage)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: pageInfo.name,</span><span class="s3">\n      </span><span class="s1">paths: pageInfo.files.map((file) =&gt; join(this.distDir, file)),</span><span class="s3">\n      </span><span class="s1">wasm: (pageInfo.wasm ?? []).map((binding) =&gt; ({</span><span class="s3">\n        </span><span class="s1">...binding,</span><span class="s3">\n        </span><span class="s1">filePath: join(this.distDir, binding.filePath),</span><span class="s3">\n      </span><span class="s1">})),</span><span class="s3">\n      </span><span class="s1">assets:</span><span class="s3">\n        </span><span class="s1">pageInfo.assets &amp;&amp;</span><span class="s3">\n        </span><span class="s1">pageInfo.assets.map((binding) =&gt; {</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">...binding,</span><span class="s3">\n            </span><span class="s1">filePath: join(this.distDir, binding.filePath),</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n      </span><span class="s1">env: pageInfo.env,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async loadNodeMiddleware() {</span><span class="s3">\n    </span><span class="s1">if (!process.env.NEXT_MINIMAL) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const functionsConfig = this.renderOpts.dev</span><span class="s3">\n          </span><span class="s1">? {}</span><span class="s3">\n          </span><span class="s1">: require(join(this.distDir, 'server', FUNCTIONS_CONFIG_MANIFEST))</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">this.renderOpts.dev ||</span><span class="s3">\n          </span><span class="s1">functionsConfig?.functions?.['/_middleware']</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// if used with top level await, this will be a promise</span><span class="s3">\n          </span><span class="s1">return require(join(this.distDir, 'server', 'middleware.js'))</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">isError(err) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">err.code !== 'ENOENT' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">err.code !== 'MODULE_NOT_FOUND'</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">throw err</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Checks if a middleware exists. This method is useful for the development</span><span class="s3">\n   </span><span class="s1">* server where we need to check the filesystem. Here we just check the</span><span class="s3">\n   </span><span class="s1">* middleware manifest.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">protected async hasMiddleware(pathname: string): Promise&lt;boolean&gt; {</span><span class="s3">\n    </span><span class="s1">const info = this.getEdgeFunctionInfo({ page: pathname, middleware: true })</span><span class="s3">\n    </span><span class="s1">const nodeMiddleware = await this.loadNodeMiddleware()</span><span class="s3">\n\n    </span><span class="s1">if (!info &amp;&amp; nodeMiddleware) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return Boolean(info &amp;&amp; info.paths.length &gt; 0)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A placeholder for a function to be defined in the development server.</span><span class="s3">\n   </span><span class="s1">* It will make sure that the root middleware or an edge function has been compiled</span><span class="s3">\n   </span><span class="s1">* so that we can run it.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">protected async ensureMiddleware(_url?: string) {}</span><span class="s3">\n  </span><span class="s1">protected async ensureEdgeFunction(_params: {</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">appPaths: string[] | null</span><span class="s3">\n    </span><span class="s1">url?: string</span><span class="s3">\n  </span><span class="s1">}) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This method gets all middleware matchers and execute them when the request</span><span class="s3">\n   </span><span class="s1">* matches. It will make sure that each middleware exists and is compiled and</span><span class="s3">\n   </span><span class="s1">* ready to be invoked. The development server will decorate it to add warns</span><span class="s3">\n   </span><span class="s1">* and errors with rich traces.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">protected async runMiddleware(params: {</span><span class="s3">\n    </span><span class="s1">request: NodeNextRequest</span><span class="s3">\n    </span><span class="s1">response: NodeNextResponse</span><span class="s3">\n    </span><span class="s1">parsedUrl: ParsedUrl</span><span class="s3">\n    </span><span class="s1">parsed: UrlWithParsedQuery</span><span class="s3">\n    </span><span class="s1">onWarning?: (warning: Error) =&gt; void</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_MINIMAL) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'invariant: runMiddleware should not be called in minimal mode'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Middleware is skipped for on-demand revalidate requests</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">checkIsOnDemandRevalidate(params.request, this.renderOpts.previewProps)</span><span class="s3">\n        </span><span class="s1">.isOnDemandRevalidate</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">response: new Response(null, { headers: { 'x-middleware-next': '1' } }),</span><span class="s3">\n      </span><span class="s1">} as FetchEventResult</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let url: string</span><span class="s3">\n\n    </span><span class="s1">if (this.nextConfig.skipMiddlewareUrlNormalize) {</span><span class="s3">\n      </span><span class="s1">url = getRequestMeta(params.request, 'initURL')!</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// For middleware to </span><span class="s3">\&quot;</span><span class="s1">fetch</span><span class="s3">\&quot; </span><span class="s1">we must always provide an absolute URL</span><span class="s3">\n      </span><span class="s1">const query = urlQueryToSearchParams(params.parsed.query).toString()</span><span class="s3">\n      </span><span class="s1">const locale = getRequestMeta(params.request, 'locale')</span><span class="s3">\n\n      </span><span class="s1">url = `${getRequestMeta(params.request, 'initProtocol')}://${</span><span class="s3">\n        </span><span class="s1">this.fetchHostname || 'localhost'</span><span class="s3">\n      </span><span class="s1">}:${this.port}${locale ? `/${locale}` : ''}${params.parsed.pathname}${</span><span class="s3">\n        </span><span class="s1">query ? `?${query}` : ''</span><span class="s3">\n      </span><span class="s1">}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!url.startsWith('http')) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'To use middleware you must provide a `hostname` and `port` to the Next.js Server'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const page: {</span><span class="s3">\n      </span><span class="s1">name?: string</span><span class="s3">\n      </span><span class="s1">params?: { [key: string]: string | string[] }</span><span class="s3">\n    </span><span class="s1">} = {}</span><span class="s3">\n\n    </span><span class="s1">const middleware = await this.getMiddleware()</span><span class="s3">\n    </span><span class="s1">if (!middleware) {</span><span class="s3">\n      </span><span class="s1">return { finished: false }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(await this.hasMiddleware(middleware.page))) {</span><span class="s3">\n      </span><span class="s1">return { finished: false }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">await this.ensureMiddleware(params.request.url)</span><span class="s3">\n    </span><span class="s1">const middlewareInfo = this.getEdgeFunctionInfo({</span><span class="s3">\n      </span><span class="s1">page: middleware.page,</span><span class="s3">\n      </span><span class="s1">middleware: true,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const method = (params.request.method || 'GET').toUpperCase()</span><span class="s3">\n    </span><span class="s1">const requestData = {</span><span class="s3">\n      </span><span class="s1">headers: params.request.headers,</span><span class="s3">\n      </span><span class="s1">method,</span><span class="s3">\n      </span><span class="s1">nextConfig: {</span><span class="s3">\n        </span><span class="s1">basePath: this.nextConfig.basePath,</span><span class="s3">\n        </span><span class="s1">i18n: this.nextConfig.i18n,</span><span class="s3">\n        </span><span class="s1">trailingSlash: this.nextConfig.trailingSlash,</span><span class="s3">\n        </span><span class="s1">experimental: this.nextConfig.experimental,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">url: url,</span><span class="s3">\n      </span><span class="s1">page,</span><span class="s3">\n      </span><span class="s1">body:</span><span class="s3">\n        </span><span class="s1">method !== 'GET' &amp;&amp; method !== 'HEAD'</span><span class="s3">\n          </span><span class="s1">? (getRequestMeta(params.request, 'clonableBody') as any)</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n\n      </span><span class="s1">signal: signalFromNodeResponse(params.response.originalResponse),</span><span class="s3">\n      </span><span class="s1">waitUntil: this.getWaitUntil(),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let result:</span><span class="s3">\n      </span><span class="s1">| UnwrapPromise&lt;ReturnType&lt;typeof import('./web/sandbox').run&gt;&gt;</span><span class="s3">\n      </span><span class="s1">| undefined</span><span class="s3">\n\n    </span><span class="s1">// if no middleware info check for Node.js middleware</span><span class="s3">\n    </span><span class="s1">// this is not in the middleware-manifest as that historically</span><span class="s3">\n    </span><span class="s1">// has only included edge-functions, we need to do a breaking</span><span class="s3">\n    </span><span class="s1">// version bump for that manifest to write this info there if</span><span class="s3">\n    </span><span class="s1">// we decide we want to</span><span class="s3">\n    </span><span class="s1">if (!middlewareInfo) {</span><span class="s3">\n      </span><span class="s1">let middlewareModule</span><span class="s3">\n      </span><span class="s1">middlewareModule = await this.loadNodeMiddleware()</span><span class="s3">\n\n      </span><span class="s1">if (!middlewareModule) {</span><span class="s3">\n        </span><span class="s1">throw new MiddlewareNotFoundError()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const adapterFn: typeof import('./web/adapter').adapter =</span><span class="s3">\n        </span><span class="s1">middlewareModule.default || middlewareModule</span><span class="s3">\n\n      </span><span class="s1">const hasRequestBody =</span><span class="s3">\n        </span><span class="s1">!['HEAD', 'GET'].includes(params.request.method) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">Boolean(requestData.body)</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">result = await adapterFn({</span><span class="s3">\n          </span><span class="s1">handler: middlewareModule.middleware || middlewareModule,</span><span class="s3">\n          </span><span class="s1">request: {</span><span class="s3">\n            </span><span class="s1">...requestData,</span><span class="s3">\n            </span><span class="s1">body: hasRequestBody</span><span class="s3">\n              </span><span class="s1">? requestData.body.cloneBodyStream()</span><span class="s3">\n              </span><span class="s1">: undefined,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">page: 'middleware',</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">if (hasRequestBody) {</span><span class="s3">\n          </span><span class="s1">requestData.body.finalize()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const { run } = require('./web/sandbox') as typeof import('./web/sandbox')</span><span class="s3">\n\n      </span><span class="s1">result = await run({</span><span class="s3">\n        </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n        </span><span class="s1">name: middlewareInfo.name,</span><span class="s3">\n        </span><span class="s1">paths: middlewareInfo.paths,</span><span class="s3">\n        </span><span class="s1">edgeFunctionEntry: middlewareInfo,</span><span class="s3">\n        </span><span class="s1">request: requestData,</span><span class="s3">\n        </span><span class="s1">useCache: true,</span><span class="s3">\n        </span><span class="s1">onWarning: params.onWarning,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.renderOpts.dev) {</span><span class="s3">\n      </span><span class="s1">result.waitUntil.catch((error) =&gt; {</span><span class="s3">\n        </span><span class="s1">console.error(`Uncaught: middleware waitUntil errored`, error)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!result) {</span><span class="s3">\n      </span><span class="s1">this.render404(params.request, params.response, params.parsed)</span><span class="s3">\n      </span><span class="s1">return { finished: true }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Split compound (comma-separated) set-cookie headers</span><span class="s3">\n    </span><span class="s1">if (result.response.headers.has('set-cookie')) {</span><span class="s3">\n      </span><span class="s1">const cookies = result.response.headers</span><span class="s3">\n        </span><span class="s1">.getSetCookie()</span><span class="s3">\n        </span><span class="s1">.flatMap((maybeCompoundCookie) =&gt;</span><span class="s3">\n          </span><span class="s1">splitCookiesString(maybeCompoundCookie)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// Clear existing header(s)</span><span class="s3">\n      </span><span class="s1">result.response.headers.delete('set-cookie')</span><span class="s3">\n\n      </span><span class="s1">// Append each cookie individually.</span><span class="s3">\n      </span><span class="s1">for (const cookie of cookies) {</span><span class="s3">\n        </span><span class="s1">result.response.headers.append('set-cookie', cookie)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Add cookies to request meta.</span><span class="s3">\n      </span><span class="s1">addRequestMeta(params.request, 'middlewareCookie', cookies)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected handleCatchallMiddlewareRequest: NodeRouteHandler = async (</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">res,</span><span class="s3">\n    </span><span class="s1">parsed</span><span class="s3">\n  </span><span class="s1">) =&gt; {</span><span class="s3">\n    </span><span class="s1">const isMiddlewareInvoke = getRequestMeta(req, 'middlewareInvoke')</span><span class="s3">\n\n    </span><span class="s1">if (!isMiddlewareInvoke) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const handleFinished = () =&gt; {</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'middlewareInvoke', true)</span><span class="s3">\n      </span><span class="s1">res.body('').send()</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const middleware = await this.getMiddleware()</span><span class="s3">\n    </span><span class="s1">if (!middleware) {</span><span class="s3">\n      </span><span class="s1">return handleFinished()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const initUrl = getRequestMeta(req, 'initURL')!</span><span class="s3">\n    </span><span class="s1">const parsedUrl = parseUrl(initUrl)</span><span class="s3">\n    </span><span class="s1">const pathnameInfo = getNextPathnameInfo(parsedUrl.pathname, {</span><span class="s3">\n      </span><span class="s1">nextConfig: this.nextConfig,</span><span class="s3">\n      </span><span class="s1">i18nProvider: this.i18nProvider,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">parsedUrl.pathname = pathnameInfo.pathname</span><span class="s3">\n    </span><span class="s1">const normalizedPathname = removeTrailingSlash(parsed.pathname || '')</span><span class="s3">\n    </span><span class="s1">let maybeDecodedPathname = normalizedPathname</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">maybeDecodedPathname = decodeURIComponent(normalizedPathname)</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n      </span><span class="s1">/* non-fatal we can't decode so can't match it */</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!(</span><span class="s3">\n        </span><span class="s1">middleware.match(normalizedPathname, req, parsedUrl.query) ||</span><span class="s3">\n        </span><span class="s1">middleware.match(maybeDecodedPathname, req, parsedUrl.query)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return handleFinished()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let result: Awaited&lt;</span><span class="s3">\n      </span><span class="s1">ReturnType&lt;typeof NextNodeServer.prototype.runMiddleware&gt;</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n    </span><span class="s1">let bubblingResult = false</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">await this.ensureMiddleware(req.url)</span><span class="s3">\n\n      </span><span class="s1">result = await this.runMiddleware({</span><span class="s3">\n        </span><span class="s1">request: req,</span><span class="s3">\n        </span><span class="s1">response: res,</span><span class="s3">\n        </span><span class="s1">parsedUrl: parsedUrl,</span><span class="s3">\n        </span><span class="s1">parsed: parsed,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">if ('response' in result) {</span><span class="s3">\n        </span><span class="s1">if (isMiddlewareInvoke) {</span><span class="s3">\n          </span><span class="s1">bubblingResult = true</span><span class="s3">\n          </span><span class="s1">throw new BubbledError(true, result)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">for (const [key, value] of Object.entries(</span><span class="s3">\n          </span><span class="s1">toNodeOutgoingHttpHeaders(result.response.headers)</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">if (key !== 'content-encoding' &amp;&amp; value !== undefined) {</span><span class="s3">\n            </span><span class="s1">res.setHeader(key, value as string | string[])</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">res.statusCode = result.response.status</span><span class="s3">\n\n        </span><span class="s1">const { originalResponse } = res</span><span class="s3">\n        </span><span class="s1">if (result.response.body) {</span><span class="s3">\n          </span><span class="s1">await pipeToNodeResponse(result.response.body, originalResponse)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">originalResponse.end()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (err: unknown) {</span><span class="s3">\n      </span><span class="s1">if (bubblingResult) {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isError(err) &amp;&amp; err.code === 'ENOENT') {</span><span class="s3">\n        </span><span class="s1">await this.render404(req, res, parsed)</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (err instanceof DecodeError) {</span><span class="s3">\n        </span><span class="s1">res.statusCode = 400</span><span class="s3">\n        </span><span class="s1">await this.renderError(err, req, res, parsed.pathname || '')</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const error = getProperError(err)</span><span class="s3">\n      </span><span class="s1">console.error(error)</span><span class="s3">\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n      </span><span class="s1">await this.renderError(error, req, res, parsed.pathname || '')</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return result.finished</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private _cachedPreviewManifest: PrerenderManifest | undefined</span><span class="s3">\n  </span><span class="s1">protected getPrerenderManifest(): PrerenderManifest {</span><span class="s3">\n    </span><span class="s1">if (this._cachedPreviewManifest) {</span><span class="s3">\n      </span><span class="s1">return this._cachedPreviewManifest</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._cachedPreviewManifest = loadManifest(</span><span class="s3">\n      </span><span class="s1">join(this.distDir, PRERENDER_MANIFEST)</span><span class="s3">\n    </span><span class="s1">) as PrerenderManifest</span><span class="s3">\n\n    </span><span class="s1">return this._cachedPreviewManifest</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getRoutesManifest(): NormalizedRouteManifest | undefined {</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">NextNodeServerSpan.getRoutesManifest,</span><span class="s3">\n      </span><span class="s1">() =&gt; loadManifest(join(this.distDir, ROUTES_MANIFEST)) as RoutesManifest</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected attachRequestMeta(</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">parsedUrl: NextUrlWithParsedQuery,</span><span class="s3">\n    </span><span class="s1">isUpgradeReq?: boolean</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// Injected in base-server.ts</span><span class="s3">\n    </span><span class="s1">const protocol = req.headers['x-forwarded-proto']?.includes('https')</span><span class="s3">\n      </span><span class="s1">? 'https'</span><span class="s3">\n      </span><span class="s1">: 'http'</span><span class="s3">\n\n    </span><span class="s1">// When there are hostname and port we build an absolute URL</span><span class="s3">\n    </span><span class="s1">const initUrl =</span><span class="s3">\n      </span><span class="s1">this.fetchHostname &amp;&amp; this.port</span><span class="s3">\n        </span><span class="s1">? `${protocol}://${this.fetchHostname}:${this.port}${req.url}`</span><span class="s3">\n        </span><span class="s1">: this.nextConfig.experimental.trustHostHeader</span><span class="s3">\n          </span><span class="s1">? `https://${req.headers.host || 'localhost'}${req.url}`</span><span class="s3">\n          </span><span class="s1">: req.url</span><span class="s3">\n\n    </span><span class="s1">addRequestMeta(req, 'initURL', initUrl)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(req, 'initQuery', { ...parsedUrl.query })</span><span class="s3">\n    </span><span class="s1">addRequestMeta(req, 'initProtocol', protocol)</span><span class="s3">\n\n    </span><span class="s1">if (!isUpgradeReq) {</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'clonableBody', getCloneableBody(req.originalRequest))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async runEdgeFunction(params: {</span><span class="s3">\n    </span><span class="s1">req: NodeNextRequest</span><span class="s3">\n    </span><span class="s1">res: NodeNextResponse</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n    </span><span class="s1">params: Params | undefined</span><span class="s3">\n    </span><span class="s1">page: string</span><span class="s3">\n    </span><span class="s1">appPaths: string[] | null</span><span class="s3">\n    </span><span class="s1">match?: RouteMatch</span><span class="s3">\n    </span><span class="s1">onError?: (err: unknown) =&gt; void</span><span class="s3">\n    </span><span class="s1">onWarning?: (warning: Error) =&gt; void</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;FetchEventResult | null&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_MINIMAL) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Middleware is not supported in minimal mode. Please remove the `NEXT_MINIMAL` environment variable.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let edgeInfo: ReturnType&lt;typeof this.getEdgeFunctionInfo&gt; | undefined</span><span class="s3">\n\n    </span><span class="s1">const { query, page, match } = params</span><span class="s3">\n\n    </span><span class="s1">if (!match)</span><span class="s3">\n      </span><span class="s1">await this.ensureEdgeFunction({</span><span class="s3">\n        </span><span class="s1">page,</span><span class="s3">\n        </span><span class="s1">appPaths: params.appPaths,</span><span class="s3">\n        </span><span class="s1">url: params.req.url,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">edgeInfo = this.getEdgeFunctionInfo({</span><span class="s3">\n      </span><span class="s1">page,</span><span class="s3">\n      </span><span class="s1">middleware: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (!edgeInfo) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// For edge to </span><span class="s3">\&quot;</span><span class="s1">fetch</span><span class="s3">\&quot; </span><span class="s1">we must always provide an absolute URL</span><span class="s3">\n    </span><span class="s1">const isNextDataRequest = getRequestMeta(params.req, 'isNextDataReq')</span><span class="s3">\n    </span><span class="s1">const initialUrl = new URL(</span><span class="s3">\n      </span><span class="s1">getRequestMeta(params.req, 'initURL') || '/',</span><span class="s3">\n      </span><span class="s1">'http://n'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const queryString = urlQueryToSearchParams({</span><span class="s3">\n      </span><span class="s1">...Object.fromEntries(initialUrl.searchParams),</span><span class="s3">\n      </span><span class="s1">...query,</span><span class="s3">\n      </span><span class="s1">...params.params,</span><span class="s3">\n    </span><span class="s1">}).toString()</span><span class="s3">\n\n    </span><span class="s1">if (isNextDataRequest) {</span><span class="s3">\n      </span><span class="s1">params.req.headers['x-nextjs-data'] = '1'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">initialUrl.search = queryString</span><span class="s3">\n    </span><span class="s1">const url = initialUrl.toString()</span><span class="s3">\n\n    </span><span class="s1">if (!url.startsWith('http')) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'To use middleware you must provide a `hostname` and `port` to the Next.js Server'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { run } = require('./web/sandbox') as typeof import('./web/sandbox')</span><span class="s3">\n    </span><span class="s1">const result = await run({</span><span class="s3">\n      </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n      </span><span class="s1">name: edgeInfo.name,</span><span class="s3">\n      </span><span class="s1">paths: edgeInfo.paths,</span><span class="s3">\n      </span><span class="s1">edgeFunctionEntry: edgeInfo,</span><span class="s3">\n      </span><span class="s1">request: {</span><span class="s3">\n        </span><span class="s1">headers: params.req.headers,</span><span class="s3">\n        </span><span class="s1">method: params.req.method,</span><span class="s3">\n        </span><span class="s1">nextConfig: {</span><span class="s3">\n          </span><span class="s1">basePath: this.nextConfig.basePath,</span><span class="s3">\n          </span><span class="s1">i18n: this.nextConfig.i18n,</span><span class="s3">\n          </span><span class="s1">trailingSlash: this.nextConfig.trailingSlash,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">url,</span><span class="s3">\n        </span><span class="s1">page: {</span><span class="s3">\n          </span><span class="s1">name: params.page,</span><span class="s3">\n          </span><span class="s1">...(params.params &amp;&amp; { params: params.params }),</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">body: getRequestMeta(params.req, 'clonableBody'),</span><span class="s3">\n        </span><span class="s1">signal: signalFromNodeResponse(params.res.originalResponse),</span><span class="s3">\n        </span><span class="s1">waitUntil: this.getWaitUntil(),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">useCache: true,</span><span class="s3">\n      </span><span class="s1">onError: params.onError,</span><span class="s3">\n      </span><span class="s1">onWarning: params.onWarning,</span><span class="s3">\n      </span><span class="s1">incrementalCache:</span><span class="s3">\n        </span><span class="s1">(globalThis as any).__incrementalCache ||</span><span class="s3">\n        </span><span class="s1">getRequestMeta(params.req, 'incrementalCache'),</span><span class="s3">\n      </span><span class="s1">serverComponentsHmrCache: getRequestMeta(</span><span class="s3">\n        </span><span class="s1">params.req,</span><span class="s3">\n        </span><span class="s1">'serverComponentsHmrCache'</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (result.fetchMetrics) {</span><span class="s3">\n      </span><span class="s1">params.req.fetchMetrics = result.fetchMetrics</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!params.res.statusCode || params.res.statusCode &lt; 400) {</span><span class="s3">\n      </span><span class="s1">params.res.statusCode = result.response.status</span><span class="s3">\n      </span><span class="s1">params.res.statusMessage = result.response.statusText</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// TODO: (wyattjoh) investigate improving this</span><span class="s3">\n\n    </span><span class="s1">result.response.headers.forEach((value, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">// The append handling is special cased for `set-cookie`.</span><span class="s3">\n      </span><span class="s1">if (key.toLowerCase() === 'set-cookie') {</span><span class="s3">\n        </span><span class="s1">// TODO: (wyattjoh) replace with native response iteration when we can upgrade undici</span><span class="s3">\n        </span><span class="s1">for (const cookie of splitCookiesString(value)) {</span><span class="s3">\n          </span><span class="s1">params.res.appendHeader(key, cookie)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">params.res.appendHeader(key, value)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const { originalResponse } = params.res</span><span class="s3">\n    </span><span class="s1">if (result.response.body) {</span><span class="s3">\n      </span><span class="s1">await pipeToNodeResponse(result.response.body, originalResponse)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">originalResponse.end()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected get serverDistDir(): string {</span><span class="s3">\n    </span><span class="s1">if (this._serverDistDir) {</span><span class="s3">\n      </span><span class="s1">return this._serverDistDir</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const serverDistDir = join(this.distDir, SERVER_DIRECTORY)</span><span class="s3">\n    </span><span class="s1">this._serverDistDir = serverDistDir</span><span class="s3">\n    </span><span class="s1">return serverDistDir</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async getFallbackErrorComponents(</span><span class="s3">\n    </span><span class="s1">_url?: string</span><span class="s3">\n  </span><span class="s1">): Promise&lt;LoadComponentsReturnType | null&gt; {</span><span class="s3">\n    </span><span class="s1">// Not implemented for production use cases, this is implemented on the</span><span class="s3">\n    </span><span class="s1">// development server.</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected async instrumentationOnRequestError(</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;ServerOnInstrumentationRequestError&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">await super.instrumentationOnRequestError(...args)</span><span class="s3">\n\n    </span><span class="s1">// For Node.js runtime production logs, in dev it will be overridden by next-dev-server</span><span class="s3">\n    </span><span class="s1">if (!this.renderOpts.dev) {</span><span class="s3">\n      </span><span class="s1">this.logError(args[0] as Error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected onServerClose(listener: () =&gt; Promise&lt;void&gt;) {</span><span class="s3">\n    </span><span class="s1">this.cleanupListeners.add(listener)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async close(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">await this.cleanupListeners.runAll()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected getInternalWaitUntil(): WaitUntil {</span><span class="s3">\n    </span><span class="s1">this.internalWaitUntil ??= this.createInternalWaitUntil()</span><span class="s3">\n    </span><span class="s1">return this.internalWaitUntil</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private createInternalWaitUntil() {</span><span class="s3">\n    </span><span class="s1">if (this.minimalMode) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">'createInternalWaitUntil should never be called in minimal mode'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const awaiter = new AwaiterOnce({ onError: console.error })</span><span class="s3">\n\n    </span><span class="s1">// TODO(after): warn if the process exits before these are awaited</span><span class="s3">\n    </span><span class="s1">this.onServerClose(() =&gt; awaiter.awaiting())</span><span class="s3">\n\n    </span><span class="s1">return awaiter.waitUntil</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RouteMatch } from './route-match'</span><span class="s3">\n</span><span class="s1">import type { PagesAPIRouteDefinition } from '../route-definitions/pages-api-route-definition'</span><span class="s3">\n\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export interface PagesAPIRouteMatch</span><span class="s3">\n  </span><span class="s1">extends RouteMatch&lt;PagesAPIRouteDefinition&gt; {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given match is a Pages API route match.</span><span class="s3">\n </span><span class="s1">* @param match the match to check</span><span class="s3">\n </span><span class="s1">* @returns true if the match is a Pages API route match, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isPagesAPIRouteMatch(</span><span class="s3">\n  </span><span class="s1">match: RouteMatch</span><span class="s3">\n</span><span class="s1">): match is PagesAPIRouteMatch {</span><span class="s3">\n  </span><span class="s1">return match.definition.kind === RouteKind.PAGES_API</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextConfig } from '../types'</span><span class="s3">\n</span><span class="s1">import { Agent as HttpAgent } from 'http'</span><span class="s3">\n</span><span class="s1">import { Agent as HttpsAgent } from 'https'</span><span class="s3">\n\n</span><span class="s1">export function setHttpClientAndAgentOptions(config: {</span><span class="s3">\n  </span><span class="s1">httpAgentOptions?: NextConfig['httpAgentOptions']</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">if (globalThis.__NEXT_HTTP_AGENT) {</span><span class="s3">\n    </span><span class="s1">// We only need to assign once because we want</span><span class="s3">\n    </span><span class="s1">// to reuse the same agent for all requests.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!config) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Expected config.httpAgentOptions to be an object')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">globalThis.__NEXT_HTTP_AGENT_OPTIONS = config.httpAgentOptions</span><span class="s3">\n  </span><span class="s1">globalThis.__NEXT_HTTP_AGENT = new HttpAgent(config.httpAgentOptions)</span><span class="s3">\n  </span><span class="s1">globalThis.__NEXT_HTTPS_AGENT = new HttpsAgent(config.httpAgentOptions)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextConfigComplete } from '../server/config-shared'</span><span class="s3">\n\n</span><span class="s1">function errorIfEnvConflicted(config: NextConfigComplete, key: string) {</span><span class="s3">\n  </span><span class="s1">const isPrivateKey = /^(?:NODE_.+)|^(?:__.+)$/i.test(key)</span><span class="s3">\n  </span><span class="s1">const hasNextRuntimeKey = key === 'NEXT_RUNTIME'</span><span class="s3">\n\n  </span><span class="s1">if (isPrivateKey || hasNextRuntimeKey) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`The key </span><span class="s3">\&quot;</span><span class="s1">${key}</span><span class="s3">\&quot; </span><span class="s1">under </span><span class="s3">\&quot;</span><span class="s1">env</span><span class="s3">\&quot; </span><span class="s1">in ${config.configFileName} is not allowed. https://nextjs.org/docs/messages/env-key-not-allowed`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Collects all environment variables that are using the `NEXT_PUBLIC_` prefix.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNextPublicEnvironmentVariables() {</span><span class="s3">\n  </span><span class="s1">const defineEnv: Record&lt;string, string | undefined&gt; = {}</span><span class="s3">\n  </span><span class="s1">for (const key in process.env) {</span><span class="s3">\n    </span><span class="s1">if (key.startsWith('NEXT_PUBLIC_')) {</span><span class="s3">\n      </span><span class="s1">const value = process.env[key]</span><span class="s3">\n      </span><span class="s1">if (value != null) {</span><span class="s3">\n        </span><span class="s1">defineEnv[`process.env.${key}`] = value</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return defineEnv</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Collects the `env` config value from the Next.js config.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNextConfigEnv(config: NextConfigComplete) {</span><span class="s3">\n  </span><span class="s1">// Refactored code below to use for-of</span><span class="s3">\n  </span><span class="s1">const defineEnv: Record&lt;string, string | undefined&gt; = {}</span><span class="s3">\n  </span><span class="s1">const env = config.env</span><span class="s3">\n  </span><span class="s1">for (const key in env) {</span><span class="s3">\n    </span><span class="s1">const value = env[key]</span><span class="s3">\n    </span><span class="s1">if (value != null) {</span><span class="s3">\n      </span><span class="s1">errorIfEnvConflicted(config, key)</span><span class="s3">\n      </span><span class="s1">defineEnv[`process.env.${key}`] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return defineEnv</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getStaticEnv(config: NextConfigComplete) {</span><span class="s3">\n  </span><span class="s1">const staticEnv: Record&lt;string, string | undefined&gt; = {</span><span class="s3">\n    </span><span class="s1">...getNextPublicEnvironmentVariables(),</span><span class="s3">\n    </span><span class="s1">...getNextConfigEnv(config),</span><span class="s3">\n    </span><span class="s1">'process.env.NEXT_DEPLOYMENT_ID': config.deploymentId || '',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return staticEnv</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function populateStaticEnv(config: NextConfigComplete) {</span><span class="s3">\n  </span><span class="s1">// since inlining comes after static generation we need</span><span class="s3">\n  </span><span class="s1">// to ensure this value is assigned to process env so it</span><span class="s3">\n  </span><span class="s1">// can still be accessed</span><span class="s3">\n  </span><span class="s1">const staticEnv = getStaticEnv(config)</span><span class="s3">\n  </span><span class="s1">for (const key in staticEnv) {</span><span class="s3">\n    </span><span class="s1">const innerKey = key.split('.').pop() || ''</span><span class="s3">\n    </span><span class="s1">if (!process.env[innerKey]) {</span><span class="s3">\n      </span><span class="s1">process.env[innerKey] = staticEnv[key] || ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { Readable } from 'stream'</span><span class="s3">\n</span><span class="s1">import { PassThrough } from 'stream'</span><span class="s3">\n\n</span><span class="s1">export function requestToBodyStream(</span><span class="s3">\n  </span><span class="s1">context: { ReadableStream: typeof ReadableStream },</span><span class="s3">\n  </span><span class="s1">KUint8Array: typeof Uint8Array,</span><span class="s3">\n  </span><span class="s1">stream: Readable</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return new context.ReadableStream({</span><span class="s3">\n    </span><span class="s1">start: async (controller) =&gt; {</span><span class="s3">\n      </span><span class="s1">for await (const chunk of stream) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(new KUint8Array(chunk))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function replaceRequestBody&lt;T extends IncomingMessage&gt;(</span><span class="s3">\n  </span><span class="s1">base: T,</span><span class="s3">\n  </span><span class="s1">stream: Readable</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">for (const key in stream) {</span><span class="s3">\n    </span><span class="s1">let v = stream[key as keyof Readable] as any</span><span class="s3">\n    </span><span class="s1">if (typeof v === 'function') {</span><span class="s3">\n      </span><span class="s1">v = v.bind(base)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">base[key as keyof T] = v</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return base</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CloneableBody {</span><span class="s3">\n  </span><span class="s1">finalize(): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">cloneBodyStream(): Readable</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getCloneableBody&lt;T extends IncomingMessage&gt;(</span><span class="s3">\n  </span><span class="s1">readable: T</span><span class="s3">\n</span><span class="s1">): CloneableBody {</span><span class="s3">\n  </span><span class="s1">let buffered: Readable | null = null</span><span class="s3">\n\n  </span><span class="s1">const endPromise = new Promise&lt;void | { error?: unknown }&gt;(</span><span class="s3">\n    </span><span class="s1">(resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">readable.on('end', resolve)</span><span class="s3">\n      </span><span class="s1">readable.on('error', reject)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">).catch((error) =&gt; {</span><span class="s3">\n    </span><span class="s1">return { error }</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Replaces the original request body if necessary.</span><span class="s3">\n     </span><span class="s1">* This is done because once we read the body from the original request,</span><span class="s3">\n     </span><span class="s1">* we can't read it again.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async finalize(): Promise&lt;void&gt; {</span><span class="s3">\n      </span><span class="s1">if (buffered) {</span><span class="s3">\n        </span><span class="s1">const res = await endPromise</span><span class="s3">\n\n        </span><span class="s1">if (res &amp;&amp; typeof res === 'object' &amp;&amp; res.error) {</span><span class="s3">\n          </span><span class="s1">throw res.error</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">replaceRequestBody(readable, buffered)</span><span class="s3">\n        </span><span class="s1">buffered = readable</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Clones the body stream</span><span class="s3">\n     </span><span class="s1">* to pass into a middleware</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cloneBodyStream() {</span><span class="s3">\n      </span><span class="s1">const input = buffered ?? readable</span><span class="s3">\n      </span><span class="s1">const p1 = new PassThrough()</span><span class="s3">\n      </span><span class="s1">const p2 = new PassThrough()</span><span class="s3">\n      </span><span class="s1">input.on('data', (chunk) =&gt; {</span><span class="s3">\n        </span><span class="s1">p1.push(chunk)</span><span class="s3">\n        </span><span class="s1">p2.push(chunk)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">input.on('end', () =&gt; {</span><span class="s3">\n        </span><span class="s1">p1.push(null)</span><span class="s3">\n        </span><span class="s1">p2.push(null)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">buffered = p2</span><span class="s3">\n      </span><span class="s1">return p1</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;reportError&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;RangeError&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;__dirname&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;__nccwpck_require__&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinite&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;NaN&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;clearTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;clearInterval&quot;</span><span class="s0">,</span><span class="s1">&quot;setInterval&quot;</span><span class="s0">,</span><span class="s1">&quot;u&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;AsyncLocalStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;WebSocket&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;global&quot;</span><span class="s0">,</span><span class="s1">&quot;crypto&quot;</span><span class="s0">,</span><span class="s1">&quot;webcrypto&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;webCrypto&quot;</span><span class="s0">,</span><span class="s1">&quot;LRUNode&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;prev&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;SentinelNode&quot;</span><span class="s0">,</span><span class="s1">&quot;LRUCache&quot;</span><span class="s0">,</span><span class="s1">&quot;maxSize&quot;</span><span class="s0">,</span><span class="s1">&quot;calculateSize&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;totalSize&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;tail&quot;</span><span class="s0">,</span><span class="s1">&quot;addToHead&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;removeNode&quot;</span><span class="s0">,</span><span class="s1">&quot;moveToHead&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTail&quot;</span><span class="s0">,</span><span class="s1">&quot;lastNode&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;newNode&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;currentSize&quot;</span><span class="s0">,</span><span class="s1">&quot;versions&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;isAnonymousFrameLikelyJSNative&quot;</span><span class="s0">,</span><span class="s1">&quot;methodName&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;regexNextStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;reactVendoredRe&quot;</span><span class="s0">,</span><span class="s1">&quot;reactNodeModulesRe&quot;</span><span class="s0">,</span><span class="s1">&quot;nextInternalsRe&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;stdout&quot;</span><span class="s0">,</span><span class="s1">&quot;enabled&quot;</span><span class="s0">,</span><span class="s1">&quot;NO_COLOR&quot;</span><span class="s0">,</span><span class="s1">&quot;FORCE_COLOR&quot;</span><span class="s0">,</span><span class="s1">&quot;isTTY&quot;</span><span class="s0">,</span><span class="s1">&quot;CI&quot;</span><span class="s0">,</span><span class="s1">&quot;TERM&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceClose&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;nextIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;formatter&quot;</span><span class="s0">,</span><span class="s1">&quot;open&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;string&quot;</span><span class="s0">,</span><span class="s1">&quot;bold&quot;</span><span class="s0">,</span><span class="s1">&quot;red&quot;</span><span class="s0">,</span><span class="s1">&quot;green&quot;</span><span class="s0">,</span><span class="s1">&quot;yellow&quot;</span><span class="s0">,</span><span class="s1">&quot;magenta&quot;</span><span class="s0">,</span><span class="s1">&quot;white&quot;</span><span class="s0">,</span><span class="s1">&quot;frameToString&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceURL&quot;</span><span class="s0">,</span><span class="s1">&quot;line1&quot;</span><span class="s0">,</span><span class="s1">&quot;column1&quot;</span><span class="s0">,</span><span class="s1">&quot;fileLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;canParse&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;cwd&quot;</span><span class="s0">,</span><span class="s1">&quot;computeErrorName&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareUnsourcemappedStackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;structuredStackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldIgnoreListGeneratedFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnsourcemappedFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;frame&quot;</span><span class="s0">,</span><span class="s1">&quot;ignored&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;patchErrorInspectNodeJS&quot;</span><span class="s0">,</span><span class="s1">&quot;errorConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;inspectSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;for&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareStackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;depth&quot;</span><span class="s0">,</span><span class="s1">&quot;inspectOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;inspect&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;newError&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapError&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;unparsedStack&quot;</span><span class="s0">,</span><span class="s1">&quot;errorName&quot;</span><span class="s0">,</span><span class="s1">&quot;idx&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;unsourcemappedStack&quot;</span><span class="s0">,</span><span class="s1">&quot;parseStack&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_DIST_DIR&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;frames&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;effectiveDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;lineNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapCache&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMappedFrames&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcemappedFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;getSourcemappedFrameIfPossible&quot;</span><span class="s0">,</span><span class="s1">&quot;applicableSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapConsumer&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;codeFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeSourceMapPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;nativeFindSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;SyncSourceMapConsumer&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPositionFor&quot;</span><span class="s0">,</span><span class="s1">&quot;findApplicableSourceMapPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;line0&quot;</span><span class="s0">,</span><span class="s1">&quot;column0&quot;</span><span class="s0">,</span><span class="s1">&quot;sections&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;middle&quot;</span><span class="s0">,</span><span class="s1">&quot;section&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;colors&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContent&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContentFor&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;codeFrameColumns&quot;</span><span class="s0">,</span><span class="s1">&quot;forceColor&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreListAnonymousStackFramesIfSandwichedGeneric&quot;</span><span class="s0">,</span><span class="s1">&quot;isAnonymousFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;isIgnoredFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;getMethodName&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;currentFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;previousFrameIsIgnored&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreSandwich&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMappedStack&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;originalCustomInspect&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;abortOnSynchronousPlatformIOAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;errorWithStack&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrerenderInterruptedError&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicAccesses&quot;</span><span class="s0">,</span><span class="s1">&quot;isDebugDynamicAccesses&quot;</span><span class="s0">,</span><span class="s1">&quot;syncDynamicErrorWithStack&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicPostponeReason&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;io&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderPhase&quot;</span><span class="s0">,</span><span class="s1">&quot;requestStore&quot;</span><span class="s0">,</span><span class="s1">&quot;_random&quot;</span><span class="s0">,</span><span class="s1">&quot;random&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;createDate&quot;</span><span class="s0">,</span><span class="s1">&quot;originalConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;originalNow&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;Reflect&quot;</span><span class="s0">,</span><span class="s1">&quot;construct&quot;</span><span class="s0">,</span><span class="s1">&quot;newConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;getRandomValuesExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_getRandomValues&quot;</span><span class="s0">,</span><span class="s1">&quot;getRandomValues&quot;</span><span class="s0">,</span><span class="s1">&quot;_randomUUID&quot;</span><span class="s0">,</span><span class="s1">&quot;randomUUID&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeCrypto&quot;</span><span class="s0">,</span><span class="s1">&quot;randomUUIDExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;randomBytesExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_randomBytes&quot;</span><span class="s0">,</span><span class="s1">&quot;randomBytes&quot;</span><span class="s0">,</span><span class="s1">&quot;randomFillSyncExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_randomFillSync&quot;</span><span class="s0">,</span><span class="s1">&quot;randomFillSync&quot;</span><span class="s0">,</span><span class="s1">&quot;_randomInt&quot;</span><span class="s0">,</span><span class="s1">&quot;randomInt&quot;</span><span class="s0">,</span><span class="s1">&quot;generatePrimeSyncExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_generatePrimeSync&quot;</span><span class="s0">,</span><span class="s1">&quot;generatePrimeSync&quot;</span><span class="s0">,</span><span class="s1">&quot;generateKeyPairSyncExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_generateKeyPairSync&quot;</span><span class="s0">,</span><span class="s1">&quot;generateKeyPairSync&quot;</span><span class="s0">,</span><span class="s1">&quot;generateKeySyncExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_generateKeySync&quot;</span><span class="s0">,</span><span class="s1">&quot;generateKeySync&quot;</span><span class="s0">,</span><span class="s1">&quot;mod&quot;</span><span class="s0">,</span><span class="s1">&quot;originalRequire&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveFilename&quot;</span><span class="s0">,</span><span class="s1">&quot;_resolveFilename&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;__non_webpack_require__&quot;</span><span class="s0">,</span><span class="s1">&quot;hookPropertyMap&quot;</span><span class="s0">,</span><span class="s1">&quot;addHookAliases&quot;</span><span class="s0">,</span><span class="s1">&quot;aliases&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;dirname&quot;</span><span class="s0">,</span><span class="s1">&quot;originalResolveFilename&quot;</span><span class="s0">,</span><span class="s1">&quot;requestMap&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;isMain&quot;</span><span class="s0">,</span><span class="s1">&quot;hookResolved&quot;</span><span class="s0">,</span><span class="s1">&quot;basename&quot;</span><span class="s0">,</span><span class="s1">&quot;SP&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;DecodeError&quot;</span><span class="s0">,</span><span class="s1">&quot;NormalizeError&quot;</span><span class="s0">,</span><span class="s1">&quot;PageNotFoundError&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;MissingStaticPage&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAM_SEPARATOR&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAdjacentParameterIssues&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAdjacentParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;normalized&quot;</span><span class="s0">,</span><span class="s1">&quot;safePathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;needsNormalization&quot;</span><span class="s0">,</span><span class="s1">&quot;routeToUse&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;retryError&quot;</span><span class="s0">,</span><span class="s1">&quot;safeCompile&quot;</span><span class="s0">,</span><span class="s1">&quot;compile&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;matcherFn&quot;</span><span class="s0">,</span><span class="s1">&quot;re&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;group&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;cleaned&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REQUEST_META&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;addRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;removeRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;COMPILER_NAMES&quot;</span><span class="s0">,</span><span class="s1">&quot;client&quot;</span><span class="s0">,</span><span class="s1">&quot;server&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeServer&quot;</span><span class="s0">,</span><span class="s1">&quot;UNDERSCORE_NOT_FOUND_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;UNDERSCORE_NOT_FOUND_ROUTE_ENTRY&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGES_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;APP_PATHS_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_DIRECTORY&quot;</span><span class="s0">,</span><span class="s1">&quot;BLOCKED_PAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_STATUS_PAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;findDir&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;curDir&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;ReflectAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;receiver&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadonlyHeadersError&quot;</span><span class="s0">,</span><span class="s1">&quot;callable&quot;</span><span class="s0">,</span><span class="s1">&quot;HeadersAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;Headers&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;Proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;lowercased&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;original&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;seal&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;callbackfn&quot;</span><span class="s0">,</span><span class="s1">&quot;thisArg&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;HTML_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_QUERY_PARAM_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_INTERCEPTION_MARKER_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;MATCHED_PATH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_PREFETCH_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENTS_DIR_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENT_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DATA_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_META_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATED_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;WEBPACK_LAYERS_NAMES&quot;</span><span class="s0">,</span><span class="s1">&quot;shared&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;serverSideRendering&quot;</span><span class="s0">,</span><span class="s1">&quot;actionBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;apiNode&quot;</span><span class="s0">,</span><span class="s1">&quot;apiEdge&quot;</span><span class="s0">,</span><span class="s1">&quot;middleware&quot;</span><span class="s0">,</span><span class="s1">&quot;instrument&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeAsset&quot;</span><span class="s0">,</span><span class="s1">&quot;appPagesBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirEdge&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirNode&quot;</span><span class="s0">,</span><span class="s1">&quot;GROUP&quot;</span><span class="s0">,</span><span class="s1">&quot;builtinReact&quot;</span><span class="s0">,</span><span class="s1">&quot;serverOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;neutralTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;clientOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;bundled&quot;</span><span class="s0">,</span><span class="s1">&quot;appPages&quot;</span><span class="s0">,</span><span class="s1">&quot;SYMBOL_CLEARED_COOKIES&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;getCookieParser&quot;</span><span class="s0">,</span><span class="s1">&quot;cookie&quot;</span><span class="s0">,</span><span class="s1">&quot;parseCookieFn&quot;</span><span class="s0">,</span><span class="s1">&quot;BaseNextRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;_cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;BaseNextResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;NodeNextRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;_req&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;streaming&quot;</span><span class="s0">,</span><span class="s1">&quot;originalRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;NodeNextResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;originalResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;_res&quot;</span><span class="s0">,</span><span class="s1">&quot;textBody&quot;</span><span class="s0">,</span><span class="s1">&quot;sent&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;headersSent&quot;</span><span class="s0">,</span><span class="s1">&quot;statusMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;removeHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeaderValues&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;hasHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;appendHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;currentValues&quot;</span><span class="s0">,</span><span class="s1">&quot;send&quot;</span><span class="s0">,</span><span class="s1">&quot;onClose&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;sendRenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;generateEtags&quot;</span><span class="s0">,</span><span class="s1">&quot;poweredByHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControl&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheControlHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;expire&quot;</span><span class="s0">,</span><span class="s1">&quot;swrHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnchunkedString&quot;</span><span class="s0">,</span><span class="s1">&quot;etag&quot;</span><span class="s0">,</span><span class="s1">&quot;generateETag&quot;</span><span class="s0">,</span><span class="s1">&quot;weak&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;fnv1a52&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;t0&quot;</span><span class="s0">,</span><span class="s1">&quot;v0&quot;</span><span class="s0">,</span><span class="s1">&quot;t1&quot;</span><span class="s0">,</span><span class="s1">&quot;v1&quot;</span><span class="s0">,</span><span class="s1">&quot;t2&quot;</span><span class="s0">,</span><span class="s1">&quot;v2&quot;</span><span class="s0">,</span><span class="s1">&quot;t3&quot;</span><span class="s0">,</span><span class="s1">&quot;v3&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;fresh&quot;</span><span class="s0">,</span><span class="s1">&quot;byteLength&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeToNodeResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParamsToUrlQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyUrlQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;parseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseRelativeUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;parseQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;globalBase&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedBase&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;slashes&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedURL&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixes&quot;</span><span class="s0">,</span><span class="s1">&quot;wait&quot;</span><span class="s0">,</span><span class="s1">&quot;ready&quot;</span><span class="s0">,</span><span class="s1">&quot;info&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;LOGGING_METHOD&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixedLog&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixType&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;consoleMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;bootstrap&quot;</span><span class="s0">,</span><span class="s1">&quot;warnOnceCache&quot;</span><span class="s0">,</span><span class="s1">&quot;warnOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;v4Seg&quot;</span><span class="s0">,</span><span class="s1">&quot;v4Str&quot;</span><span class="s0">,</span><span class="s1">&quot;v6Seg&quot;</span><span class="s0">,</span><span class="s1">&quot;IPv6Reg&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureLeadingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRscURL&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_ROUTE_MARKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;TEST_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;TEST_STRICT_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;strict&quot;</span><span class="s0">,</span><span class="s1">&quot;extractInterceptionRouteInformation&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;marker&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;splitInterceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;HTML_LIMITED_BOT_UA_RE&quot;</span><span class="s0">,</span><span class="s1">&quot;HEADLESS_BROWSER_BOT_UA_RE&quot;</span><span class="s0">,</span><span class="s1">&quot;HTML_LIMITED_BOT_UA_RE_STRING&quot;</span><span class="s0">,</span><span class="s1">&quot;voidCatch&quot;</span><span class="s0">,</span><span class="s1">&quot;encoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromString&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;streamToString&quot;</span><span class="s0">,</span><span class="s1">&quot;decoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextDecoder&quot;</span><span class="s0">,</span><span class="s1">&quot;fatal&quot;</span><span class="s0">,</span><span class="s1">&quot;splitCookiesString&quot;</span><span class="s0">,</span><span class="s1">&quot;cookiesString&quot;</span><span class="s0">,</span><span class="s1">&quot;ch&quot;</span><span class="s0">,</span><span class="s1">&quot;lastComma&quot;</span><span class="s0">,</span><span class="s1">&quot;nextStart&quot;</span><span class="s0">,</span><span class="s1">&quot;cookiesSeparatorFound&quot;</span><span class="s0">,</span><span class="s1">&quot;cookiesStrings&quot;</span><span class="s0">,</span><span class="s1">&quot;skipWhitespace&quot;</span><span class="s0">,</span><span class="s1">&quot;charAt&quot;</span><span class="s0">,</span><span class="s1">&quot;toNodeOutgoingHttpHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;validateURL&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeNextQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePath&quot;</span><span class="s0">,</span><span class="s1">&quot;hashIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;queryIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;hasQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;suffix&quot;</span><span class="s0">,</span><span class="s1">&quot;pathHasPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;getHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;parsed&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeLocalePath&quot;</span><span class="s0">,</span><span class="s1">&quot;locales&quot;</span><span class="s0">,</span><span class="s1">&quot;detectedLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;lowercasedLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;locale&quot;</span><span class="s0">,</span><span class="s1">&quot;removePathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;withoutPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextPathnameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;i18n&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameNoDataPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;parseData&quot;</span><span class="s0">,</span><span class="s1">&quot;i18nProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;analyze&quot;</span><span class="s0">,</span><span class="s1">&quot;REGEX_LOCALHOST_HOSTNAME&quot;</span><span class="s0">,</span><span class="s1">&quot;parseURL&quot;</span><span class="s0">,</span><span class="s1">&quot;Internal&quot;</span><span class="s0">,</span><span class="s1">&quot;NextURL&quot;</span><span class="s0">,</span><span class="s1">&quot;baseOrOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_NO_MIDDLEWARE_URL_NORMALIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;detectDomainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;domainItems&quot;</span><span class="s0">,</span><span class="s1">&quot;domain&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;domains&quot;</span><span class="s0">,</span><span class="s1">&quot;formatPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;addLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;ignorePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;lower&quot;</span><span class="s0">,</span><span class="s1">&quot;forceLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;formatSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;password&quot;</span><span class="s0">,</span><span class="s1">&quot;username&quot;</span><span class="s0">,</span><span class="s1">&quot;toJSON&quot;</span><span class="s0">,</span><span class="s1">&quot;clone&quot;</span><span class="s0">,</span><span class="s1">&quot;PageSignatureError&quot;</span><span class="s0">,</span><span class="s1">&quot;RemovedPageError&quot;</span><span class="s0">,</span><span class="s1">&quot;RemovedUAError&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERNALS&quot;</span><span class="s0">,</span><span class="s1">&quot;NextRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;Request&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;duplex&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;RequestCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyUsed&quot;</span><span class="s0">,</span><span class="s1">&quot;credentials&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;integrity&quot;</span><span class="s0">,</span><span class="s1">&quot;keepalive&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;referrer&quot;</span><span class="s0">,</span><span class="s1">&quot;referrerPolicy&quot;</span><span class="s0">,</span><span class="s1">&quot;ua&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseAbortedName&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseAborted&quot;</span><span class="s0">,</span><span class="s1">&quot;DetachedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;rej&quot;</span><span class="s0">,</span><span class="s1">&quot;BaseServerSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;LoadComponentsSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;NextNodeServerSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadStart&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadTimes&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadCount&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbortError&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntilForEnd&quot;</span><span class="s0">,</span><span class="s1">&quot;errored&quot;</span><span class="s0">,</span><span class="s1">&quot;destroyed&quot;</span><span class="s0">,</span><span class="s1">&quot;createAbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;writableFinished&quot;</span><span class="s0">,</span><span class="s1">&quot;writer&quot;</span><span class="s0">,</span><span class="s1">&quot;createWriterFromResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;started&quot;</span><span class="s0">,</span><span class="s1">&quot;drained&quot;</span><span class="s0">,</span><span class="s1">&quot;onDrain&quot;</span><span class="s0">,</span><span class="s1">&quot;off&quot;</span><span class="s0">,</span><span class="s1">&quot;WritableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;write&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_OTEL_PERFORMANCE_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;metrics&quot;</span><span class="s0">,</span><span class="s1">&quot;getClientComponentLoaderMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;measure&quot;</span><span class="s0">,</span><span class="s1">&quot;flushHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;spanName&quot;</span><span class="s0">,</span><span class="s1">&quot;ok&quot;</span><span class="s0">,</span><span class="s1">&quot;flush&quot;</span><span class="s0">,</span><span class="s1">&quot;destroy&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeTo&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;EMPTY&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;fromStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;assignMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;isNull&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;chainStreams&quot;</span><span class="s0">,</span><span class="s1">&quot;streams&quot;</span><span class="s0">,</span><span class="s1">&quot;TransformStream&quot;</span><span class="s0">,</span><span class="s1">&quot;preventClose&quot;</span><span class="s0">,</span><span class="s1">&quot;nextStream&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;lastStream&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;coerce&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePathSep&quot;</span><span class="s0">,</span><span class="s1">&quot;denormalizePagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;_page&quot;</span><span class="s0">,</span><span class="s1">&quot;getPathMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;regexp&quot;</span><span class="s0">,</span><span class="s1">&quot;delimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;sensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;regexpToFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;regexModifier&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;removeUnnamedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;reHasRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;reReplaceRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeStringRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAMETER_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;parseMatchedParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;includeSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;includePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;excludeOptionalTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;parameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;getParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;groupIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;markerMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;paramMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeKeyFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;backreferenceDuplicateKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;unescapeSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;matchHas&quot;</span><span class="s0">,</span><span class="s1">&quot;missing&quot;</span><span class="s0">,</span><span class="s1">&quot;hasMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasItem&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;paramName&quot;</span><span class="s0">,</span><span class="s1">&quot;newParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;charCode&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;groupKey&quot;</span><span class="s0">,</span><span class="s1">&quot;compileNonPath&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeQueryPathParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;slashedProtocols&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParamTypesSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterStateSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_SEGMENT_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;FLIGHT_HEADERS&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RSC_UNION_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;filterInternalQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;paramKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextQueryPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextInterceptionMarkerPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreviouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeId&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">,</span><span class="s1">&quot;getProperError&quot;</span><span class="s0">,</span><span class="s1">&quot;isPlainObject&quot;</span><span class="s0">,</span><span class="s1">&quot;getObjectClassLabel&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrototypeOf&quot;</span><span class="s0">,</span><span class="s1">&quot;safeStringify&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;seen&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;_key&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;LocaleRouteNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;provider&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;UrlNode&quot;</span><span class="s0">,</span><span class="s1">&quot;insert&quot;</span><span class="s0">,</span><span class="s1">&quot;urlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;_insert&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;smoosh&quot;</span><span class="s0">,</span><span class="s1">&quot;_smoosh&quot;</span><span class="s0">,</span><span class="s1">&quot;childrenPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;slugName&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;restSlugName&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalRestSlugName&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;curr&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholder&quot;</span><span class="s0">,</span><span class="s1">&quot;urlPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;slugNames&quot;</span><span class="s0">,</span><span class="s1">&quot;isCatchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;nextSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentName&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;handleSlug&quot;</span><span class="s0">,</span><span class="s1">&quot;previousSlug&quot;</span><span class="s0">,</span><span class="s1">&quot;nextSlug&quot;</span><span class="s0">,</span><span class="s1">&quot;slug&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;identity&quot;</span><span class="s0">,</span><span class="s1">&quot;LocaleRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultRouteMatcherManager&quot;</span><span class="s0">,</span><span class="s1">&quot;compilationID&quot;</span><span class="s0">,</span><span class="s1">&quot;providers&quot;</span><span class="s0">,</span><span class="s1">&quot;waitTillReady&quot;</span><span class="s0">,</span><span class="s1">&quot;waitTillReadyPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;reload&quot;</span><span class="s0">,</span><span class="s1">&quot;matchers&quot;</span><span class="s0">,</span><span class="s1">&quot;providersMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicates&quot;</span><span class="s0">,</span><span class="s1">&quot;providerMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicated&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicate&quot;</span><span class="s0">,</span><span class="s1">&quot;others&quot;</span><span class="s0">,</span><span class="s1">&quot;previousMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;reference&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnames&quot;</span><span class="s0">,</span><span class="s1">&quot;indexes&quot;</span><span class="s0">,</span><span class="s1">&quot;sorted&quot;</span><span class="s0">,</span><span class="s1">&quot;getSortedRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPages&quot;</span><span class="s0">,</span><span class="s1">&quot;root&quot;</span><span class="s0">,</span><span class="s1">&quot;pagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;sortedDynamicMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCompilationID&quot;</span><span class="s0">,</span><span class="s1">&quot;matchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;inferredFromDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;skipDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;Normalizers&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizers&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefixingNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;posix&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPage&quot;</span><span class="s0">,</span><span class="s1">&quot;UnderscoreNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;AppBundlePathNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;AppFilenameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestFilename&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRouteRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_METADATA_IMAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;icon&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;extensions&quot;</span><span class="s0">,</span><span class="s1">&quot;apple&quot;</span><span class="s0">,</span><span class="s1">&quot;openGraph&quot;</span><span class="s0">,</span><span class="s1">&quot;twitter&quot;</span><span class="s0">,</span><span class="s1">&quot;getExtensionRegexString&quot;</span><span class="s0">,</span><span class="s1">&quot;staticExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapNormalizerFn&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;AppPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;AppNormalizers&quot;</span><span class="s0">,</span><span class="s1">&quot;bundlePath&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;AppPageRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;loader&quot;</span><span class="s0">,</span><span class="s1">&quot;cached&quot;</span><span class="s0">,</span><span class="s1">&quot;load&quot;</span><span class="s0">,</span><span class="s1">&quot;compare&quot;</span><span class="s0">,</span><span class="s1">&quot;transform&quot;</span><span class="s0">,</span><span class="s1">&quot;ManifestRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestName&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;AppPageRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;manifest&quot;</span><span class="s0">,</span><span class="s1">&quot;pages&quot;</span><span class="s0">,</span><span class="s1">&quot;allAppPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;appPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouteRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouteRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;isAPIRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesAPIRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesAPILocaleRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesBundlePathNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesFilenameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesNormalizers&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesAPIRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesLocaleRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesRouteMatcherProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerManifestLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;I18NProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;lowerCaseLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;lowerCaseDomains&quot;</span><span class="s0">,</span><span class="s1">&quot;http&quot;</span><span class="s0">,</span><span class="s1">&quot;fromRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;analysis&quot;</span><span class="s0">,</span><span class="s1">&quot;sendResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;statusText&quot;</span><span class="s0">,</span><span class="s1">&quot;headersWithMultipleValuesAllowed&quot;</span><span class="s0">,</span><span class="s1">&quot;isHeaderPresent&quot;</span><span class="s0">,</span><span class="s1">&quot;SuffixPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;matched&quot;</span><span class="s0">,</span><span class="s1">&quot;RSCPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchRSCPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefixPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;NextDataPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;buildID&quot;</span><span class="s0">,</span><span class="s1">&quot;toRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REQUEST_CONTEXT_SYMBOL&quot;</span><span class="s0">,</span><span class="s1">&quot;REDIRECTS&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMiddlewareField&quot;</span><span class="s0">,</span><span class="s1">&quot;NextResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;Response&quot;</span><span class="s0">,</span><span class="s1">&quot;cookiesProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;newHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getAll&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyCookie&quot;</span><span class="s0">,</span><span class="s1">&quot;redirected&quot;</span><span class="s0">,</span><span class="s1">&quot;json&quot;</span><span class="s0">,</span><span class="s1">&quot;initObj&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_DEBUG_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersMapSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersSetSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;NextRequestHint&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePage&quot;</span><span class="s0">,</span><span class="s1">&quot;respondWith&quot;</span><span class="s0">,</span><span class="s1">&quot;PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentPrefixRSCPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;extract&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;WrappedBuildError&quot;</span><span class="s0">,</span><span class="s1">&quot;innerError&quot;</span><span class="s0">,</span><span class="s1">&quot;Server&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;serverComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;__serverComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRSCRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPrefetchRSC&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRSC&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;header&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPrefetchRSCRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;formatUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;handleNextDataRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;getMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;matchNextDataPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;render404&quot;</span><span class="s0">,</span><span class="s1">&quot;lastParam&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteFromAssetPath&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPath&quot;</span><span class="s0">,</span><span class="s1">&quot;ext&quot;</span><span class="s0">,</span><span class="s1">&quot;localePathResult&quot;</span><span class="s0">,</span><span class="s1">&quot;handleNextImageRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;handleCatchallRenderRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;handleCatchallMiddlewareRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAndAttachMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;enabledDirectories&quot;</span><span class="s0">,</span><span class="s1">&quot;prepared&quot;</span><span class="s0">,</span><span class="s1">&quot;preparedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;customErrorNo404Warn&quot;</span><span class="s0">,</span><span class="s1">&quot;execOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;used&quot;</span><span class="s0">,</span><span class="s1">&quot;Log&quot;</span><span class="s0">,</span><span class="s1">&quot;quiet&quot;</span><span class="s0">,</span><span class="s1">&quot;conf&quot;</span><span class="s0">,</span><span class="s1">&quot;dev&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalMode&quot;</span><span class="s0">,</span><span class="s1">&quot;experimentalTestProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;serverOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;loadEnvConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;formatHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;isIPv6&quot;</span><span class="s0">,</span><span class="s1">&quot;publicDir&quot;</span><span class="s0">,</span><span class="s1">&quot;getPublicDir&quot;</span><span class="s0">,</span><span class="s1">&quot;hasStaticDir&quot;</span><span class="s0">,</span><span class="s1">&quot;getHasStaticDir&quot;</span><span class="s0">,</span><span class="s1">&quot;localeNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;serverRuntimeConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;publicRuntimeConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;getBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_MINIMAL_MODE&quot;</span><span class="s0">,</span><span class="s1">&quot;getEnabledDirectories&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppPPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;app&quot;</span><span class="s0">,</span><span class="s1">&quot;checkIsAppPPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;ppr&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppSegmentPrefetchEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;clientSegmentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFontManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFontManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DEPLOYMENT_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;deploymentId&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsDynamicResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalBase&quot;</span><span class="s0">,</span><span class="s1">&quot;amp&quot;</span><span class="s0">,</span><span class="s1">&quot;previewProps&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;preview&quot;</span><span class="s0">,</span><span class="s1">&quot;ampOptimizerConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizer&quot;</span><span class="s0">,</span><span class="s1">&quot;images&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizeCss&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfigOutput&quot;</span><span class="s0">,</span><span class="s1">&quot;output&quot;</span><span class="s0">,</span><span class="s1">&quot;nextScriptWorkers&quot;</span><span class="s0">,</span><span class="s1">&quot;disableOptimizedLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;serverComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheLifeProfiles&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheLife&quot;</span><span class="s0">,</span><span class="s1">&quot;enableTainting&quot;</span><span class="s0">,</span><span class="s1">&quot;taint&quot;</span><span class="s0">,</span><span class="s1">&quot;crossOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;largePageDataBytes&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;isExperimentalCompile&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlLimitedBots&quot;</span><span class="s0">,</span><span class="s1">&quot;expireTime&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTimes&quot;</span><span class="s0">,</span><span class="s1">&quot;clientTraceMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;clientParamParsing&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicOnHover&quot;</span><span class="s0">,</span><span class="s1">&quot;inlineCss&quot;</span><span class="s0">,</span><span class="s1">&quot;authInterrupts&quot;</span><span class="s0">,</span><span class="s1">&quot;onInstrumentationRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentationOnRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;reactMaxHeadersLength&quot;</span><span class="s0">,</span><span class="s1">&quot;devtoolSegmentExplorer&quot;</span><span class="s0">,</span><span class="s1">&quot;setConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getPagesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;appPathsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppPathsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;appPathRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppPathRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionRoutePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;getinterceptionRoutePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;setAssetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;responseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentation&quot;</span><span class="s0">,</span><span class="s1">&quot;onRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerErr&quot;</span><span class="s0">,</span><span class="s1">&quot;logError&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;prepare&quot;</span><span class="s0">,</span><span class="s1">&quot;tracer&quot;</span><span class="s0">,</span><span class="s1">&quot;withPropagatedContext&quot;</span><span class="s0">,</span><span class="s1">&quot;SpanKind&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;span&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRequestImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;finally&quot;</span><span class="s0">,</span><span class="s1">&quot;isRSCRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;setStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;SpanStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;rootSpanAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;getRootSpanAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;updateName&quot;</span><span class="s0">,</span><span class="s1">&quot;utils&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewareValue&quot;</span><span class="s0">,</span><span class="s1">&quot;urlNoQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;urlParts&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRepeatedSlashes&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;xForwardedProto&quot;</span><span class="s0">,</span><span class="s1">&quot;isHttps&quot;</span><span class="s0">,</span><span class="s1">&quot;socket&quot;</span><span class="s0">,</span><span class="s1">&quot;encrypted&quot;</span><span class="s0">,</span><span class="s1">&quot;remoteAddress&quot;</span><span class="s0">,</span><span class="s1">&quot;attachRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;parseUrlUtil&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;useMatchedPathHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;fixMojibake&quot;</span><span class="s0">,</span><span class="s1">&quot;bytes&quot;</span><span class="s0">,</span><span class="s1">&quot;urlPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedUrlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;stripNextDataPath&quot;</span><span class="s0">,</span><span class="s1">&quot;localeAnalysisResult&quot;</span><span class="s0">,</span><span class="s1">&quot;srcPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;pageIsDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;hasValidParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixRouteKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInterceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;namedParameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;namedRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;checkRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;hasParams&quot;</span><span class="s0">,</span><span class="s1">&quot;stateHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndValidateFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;assert&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;newUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;escaped&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;destSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;destPath&quot;</span><span class="s0">,</span><span class="s1">&quot;destParams&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;strOrArray&quot;</span><span class="s0">,</span><span class="s1">&quot;appendParamsToQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;actualValue&quot;</span><span class="s0">,</span><span class="s1">&quot;nextInternalLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParams&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;afterFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesPage&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathnameNoSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeQueryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;routeParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;getParamsFromRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatchesHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;keyName&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDynamicRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreMissingOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isDefaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultVal&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeCdnUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;_parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseReqUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;auth&quot;</span><span class="s0">,</span><span class="s1">&quot;urlObj&quot;</span><span class="s0">,</span><span class="s1">&quot;querystring&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolateDynamicPath&quot;</span><span class="s0">,</span><span class="s1">&quot;paramValue&quot;</span><span class="s0">,</span><span class="s1">&quot;builtParam&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceAll&quot;</span><span class="s0">,</span><span class="s1">&quot;getRoutesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitiveRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;originQueryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameBeforeRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;queryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;didRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;matcherParams&quot;</span><span class="s0">,</span><span class="s1">&quot;curParamsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;renderError&quot;</span><span class="s0">,</span><span class="s1">&quot;webServerConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getIncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;resetRequestCache&quot;</span><span class="s0">,</span><span class="s1">&quot;__incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;previouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;receiveExpiredTags&quot;</span><span class="s0">,</span><span class="s1">&quot;invokePath&quot;</span><span class="s0">,</span><span class="s1">&quot;invokeStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;invokeQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedMatchedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;invokePathnameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeResult&quot;</span><span class="s0">,</span><span class="s1">&quot;bubble&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;NoFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestHandlerWithMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;loadInstrumentationModule&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;runImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;pipe&quot;</span><span class="s0">,</span><span class="s1">&quot;partialContext&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;botType&quot;</span><span class="s0">,</span><span class="s1">&quot;serveStreamingMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldServeStreamingMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;userAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;blockingMetadataUARegex&quot;</span><span class="s0">,</span><span class="s1">&quot;originalStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;internalRender&quot;</span><span class="s0">,</span><span class="s1">&quot;renderImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;getWaitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;builtinRequestContext&quot;</span><span class="s0">,</span><span class="s1">&quot;getBuiltinRequestContext&quot;</span><span class="s0">,</span><span class="s1">&quot;_globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;getInternalWaitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;customServer&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPage&quot;</span><span class="s0">,</span><span class="s1">&quot;getBotType&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;staticPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackMode&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFallbackField&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackField&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToResponseWithComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;requestContext&quot;</span><span class="s0">,</span><span class="s1">&quot;findComponentsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToResponseWithComponentsImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathCouldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;setVaryHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;baseVaryHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;addedNextUrlToVary&quot;</span><span class="s0">,</span><span class="s1">&quot;components&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;pathsResults&quot;</span><span class="s0">,</span><span class="s1">&quot;routeModule&quot;</span><span class="s0">,</span><span class="s1">&quot;isErrorPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;is404Page&quot;</span><span class="s0">,</span><span class="s1">&quot;is500Page&quot;</span><span class="s0">,</span><span class="s1">&quot;hasServerProps&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerSideProps&quot;</span><span class="s0">,</span><span class="s1">&quot;isPossibleServerAction&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerActionRequestMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;actionId&quot;</span><span class="s0">,</span><span class="s1">&quot;isURLEncodedAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isMultipartAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isFetchAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isSSG&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticProps&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedUrlPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;hasFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextDataRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;couldSupportPPR&quot;</span><span class="s0">,</span><span class="s1">&quot;hasDebugStaticShellQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING&quot;</span><span class="s0">,</span><span class="s1">&quot;__nextppronly&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalPostponed&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;renderingMode&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;isBotRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isDomBotUA&quot;</span><span class="s0">,</span><span class="s1">&quot;isSupportedDocument&quot;</span><span class="s0">,</span><span class="s1">&quot;Document&quot;</span><span class="s0">,</span><span class="s1">&quot;getInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_BUILTIN_DOCUMENT&quot;</span><span class="s0">,</span><span class="s1">&quot;isDev&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderedRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;smallestFallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedInitUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;initPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;ampValidator&quot;</span><span class="s0">,</span><span class="s1">&quot;ComponentMod&quot;</span><span class="s0">,</span><span class="s1">&quot;stripLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;splitPath&quot;</span><span class="s0">,</span><span class="s1">&quot;getOriginalAppPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;originalAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;renderPageComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;bubbleNoFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;findPageComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;sriEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;sri&quot;</span><span class="s0">,</span><span class="s1">&quot;algorithm&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldEnsure&quot;</span><span class="s0">,</span><span class="s1">&quot;setRootSpanAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;isNoFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToResponseImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;initUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;rewroteUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;renderErrorToResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isWrappedError&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToHTMLImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;renderErrorImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;renderErrorToResponseImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;statusPage&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToHtmlError&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;getFallbackErrorComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;renderErrorToHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;pagePathCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getMaybePagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;serverBuildPath&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;checkManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;curPath&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestNoLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;getPagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;requirePage&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;interopDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;ms&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_ACTION_MANIFESTS_SINGLETON&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifestWithRetries&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestPath&quot;</span><span class="s0">,</span><span class="s1">&quot;attempts&quot;</span><span class="s0">,</span><span class="s1">&quot;tryLoadManifestWithRetries&quot;</span><span class="s0">,</span><span class="s1">&quot;evalManifestWithRetries&quot;</span><span class="s0">,</span><span class="s1">&quot;evalManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;tryLoadClientReferenceManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;entryName&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;__RSC_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;loadComponentsImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;reactLoadableManifestPath&quot;</span><span class="s0">,</span><span class="s1">&quot;DocumentMod&quot;</span><span class="s0">,</span><span class="s1">&quot;AppMod&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestLoadAttempts&quot;</span><span class="s0">,</span><span class="s1">&quot;hasClientManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticMetadataRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isMetadataRouteFile&quot;</span><span class="s0">,</span><span class="s1">&quot;appDirRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;pageExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;strictlyMatchExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;suffixMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;metadataRouteFilesRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedAppDirRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;buildManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;reactLoadableManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicCssManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;clientReferenceManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;serverActionsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;subresourceIntegrityManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_REFERENCE_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;SUBRESOURCE_INTEGRITY_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;setReferenceManifestsSingleton&quot;</span><span class="s0">,</span><span class="s1">&quot;serverModuleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;clientReferenceManifestsPerPage&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerModuleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;pageName&quot;</span><span class="s0">,</span><span class="s1">&quot;workerEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;workers&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleId&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;chunks&quot;</span><span class="s0">,</span><span class="s1">&quot;App&quot;</span><span class="s0">,</span><span class="s1">&quot;pageConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;loadComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;wrap&quot;</span><span class="s0">,</span><span class="s1">&quot;getMiddlewareRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;Batcher&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyFn&quot;</span><span class="s0">,</span><span class="s1">&quot;schedulerFn&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;batch&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleOnNextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedRouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;fromResponseCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;html&quot;</span><span class="s0">,</span><span class="s1">&quot;pageData&quot;</span><span class="s0">,</span><span class="s1">&quot;rscData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;toResponseCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isMiss&quot;</span><span class="s0">,</span><span class="s1">&quot;isStale&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;minimal_mode&quot;</span><span class="s0">,</span><span class="s1">&quot;batcher&quot;</span><span class="s0">,</span><span class="s1">&quot;isOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;responseGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;hasResolved&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;prom&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheItem&quot;</span><span class="s0">,</span><span class="s1">&quot;expiresAt&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKindToIncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKind&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;isRevalidating&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveValue&quot;</span><span class="s0">,</span><span class="s1">&quot;newRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpire&quot;</span><span class="s0">,</span><span class="s1">&quot;MultiFileWriter&quot;</span><span class="s0">,</span><span class="s1">&quot;tasks&quot;</span><span class="s0">,</span><span class="s1">&quot;findOrCreateTask&quot;</span><span class="s0">,</span><span class="s1">&quot;directory&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;mkdir&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;writeFile&quot;</span><span class="s0">,</span><span class="s1">&quot;flatMap&quot;</span><span class="s0">,</span><span class="s1">&quot;FileSystemCache&quot;</span><span class="s0">,</span><span class="s1">&quot;flushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;serverDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;maxMemoryCacheSize&quot;</span><span class="s0">,</span><span class="s1">&quot;memoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getMemoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateTag&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;fileData&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">,</span><span class="s1">&quot;mtime&quot;</span><span class="s0">,</span><span class="s1">&quot;stat&quot;</span><span class="s0">,</span><span class="s1">&quot;lastModified&quot;</span><span class="s0">,</span><span class="s1">&quot;getTime&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedData&quot;</span><span class="s0">,</span><span class="s1">&quot;storedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeSegmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentsDir&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentDataFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheTags&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;combinedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;softTags&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCacheKeyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;CurCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedRevalidateHeaderKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;locks&quot;</span><span class="s0">,</span><span class="s1">&quot;hasCustomCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlersSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;globalCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TEST_MAX_ISR_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;disableForTestmode&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_TEST_PROXY&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControls&quot;</span><span class="s0">,</span><span class="s1">&quot;SharedCacheControls&quot;</span><span class="s0">,</span><span class="s1">&quot;_requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;calculateRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;fromTime&quot;</span><span class="s0">,</span><span class="s1">&quot;timeOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;initialRevalidateSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;_getPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;lock&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyChunks&quot;</span><span class="s0">,</span><span class="s1">&quot;_ogBody&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;readableBody&quot;</span><span class="s0">,</span><span class="s1">&quot;total&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;formData&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;blob&quot;</span><span class="s0">,</span><span class="s1">&quot;Blob&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheString&quot;</span><span class="s0">,</span><span class="s1">&quot;createHash&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheData&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;resumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;memoryCacheData&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;age&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;itemSize&quot;</span><span class="s0">,</span><span class="s1">&quot;isImplicitBuildTimeCache&quot;</span><span class="s0">,</span><span class="s1">&quot;warningText&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeFs&quot;</span><span class="s0">,</span><span class="s1">&quot;existsSync&quot;</span><span class="s0">,</span><span class="s1">&quot;readFileSync&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;MockedRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;Stream&quot;</span><span class="s0">,</span><span class="s1">&quot;httpVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;httpVersionMajor&quot;</span><span class="s0">,</span><span class="s1">&quot;httpVersionMinor&quot;</span><span class="s0">,</span><span class="s1">&quot;_target&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyReadable&quot;</span><span class="s0">,</span><span class="s1">&quot;emit&quot;</span><span class="s0">,</span><span class="s1">&quot;headersDistinct&quot;</span><span class="s0">,</span><span class="s1">&quot;_read&quot;</span><span class="s0">,</span><span class="s1">&quot;connection&quot;</span><span class="s0">,</span><span class="s1">&quot;complete&quot;</span><span class="s0">,</span><span class="s1">&quot;trailers&quot;</span><span class="s0">,</span><span class="s1">&quot;trailersDistinct&quot;</span><span class="s0">,</span><span class="s1">&quot;rawTrailers&quot;</span><span class="s0">,</span><span class="s1">&quot;rawHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;MockedResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;buffers&quot;</span><span class="s0">,</span><span class="s1">&quot;fromNodeOutgoingHttpHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;headPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;headPromiseResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;hasStreamed&quot;</span><span class="s0">,</span><span class="s1">&quot;resWriter&quot;</span><span class="s0">,</span><span class="s1">&quot;isSent&quot;</span><span class="s0">,</span><span class="s1">&quot;_implicitHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;_write&quot;</span><span class="s0">,</span><span class="s1">&quot;_encoding&quot;</span><span class="s0">,</span><span class="s1">&quot;writeHead&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeaderNames&quot;</span><span class="s0">,</span><span class="s1">&quot;strictContentLength&quot;</span><span class="s0">,</span><span class="s1">&quot;writeEarlyHints&quot;</span><span class="s0">,</span><span class="s1">&quot;assignSocket&quot;</span><span class="s0">,</span><span class="s1">&quot;detachSocket&quot;</span><span class="s0">,</span><span class="s1">&quot;writeContinue&quot;</span><span class="s0">,</span><span class="s1">&quot;writeProcessing&quot;</span><span class="s0">,</span><span class="s1">&quot;upgrading&quot;</span><span class="s0">,</span><span class="s1">&quot;chunkedEncoding&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldKeepAlive&quot;</span><span class="s0">,</span><span class="s1">&quot;useChunkedEncodingByDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;sendDate&quot;</span><span class="s0">,</span><span class="s1">&quot;addTrailers&quot;</span><span class="s0">,</span><span class="s1">&quot;formatDynamicImportPath&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToFileURL&quot;</span><span class="s0">,</span><span class="s1">&quot;AsyncCallbackSet&quot;</span><span class="s0">,</span><span class="s1">&quot;callbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;runAll&quot;</span><span class="s0">,</span><span class="s1">&quot;allSettled&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_POSTPONE_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;isPostpone&quot;</span><span class="s0">,</span><span class="s1">&quot;$$typeof&quot;</span><span class="s0">,</span><span class="s1">&quot;NodeModuleLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;RouterServerContextSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;routerServerGlobal&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicImportEsmDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;MiddlewareMatcherCache&quot;</span><span class="s0">,</span><span class="s1">&quot;NextNodeServer&quot;</span><span class="s0">,</span><span class="s1">&quot;BaseServer&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeProjectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeFunctionsPage&quot;</span><span class="s0">,</span><span class="s1">&quot;getEdgeFunctionsPages&quot;</span><span class="s0">,</span><span class="s1">&quot;runEdgeFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;apiError&quot;</span><span class="s0">,</span><span class="s1">&quot;routePath&quot;</span><span class="s0">,</span><span class="s1">&quot;routerKind&quot;</span><span class="s0">,</span><span class="s1">&quot;routeType&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateReason&quot;</span><span class="s0">,</span><span class="s1">&quot;handleApiRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isMiddlewareInvoke&quot;</span><span class="s0">,</span><span class="s1">&quot;handleFinished&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeDecodedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;bubblingResult&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;runMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;BubbledError&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_OPTIMIZE_CSS&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_SCRIPT_WORKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;useSkewCookie&quot;</span><span class="s0">,</span><span class="s1">&quot;appDocumentPreloading&quot;</span><span class="s0">,</span><span class="s1">&quot;regex&quot;</span><span class="s0">,</span><span class="s1">&quot;setHttpClientAndAgentOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_HTTP_AGENT&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_HTTP_AGENT_OPTIONS&quot;</span><span class="s0">,</span><span class="s1">&quot;httpAgentOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;HttpAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_HTTPS_AGENT&quot;</span><span class="s0">,</span><span class="s1">&quot;HttpsAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewareManifestPath&quot;</span><span class="s0">,</span><span class="s1">&quot;populateStaticEnv&quot;</span><span class="s0">,</span><span class="s1">&quot;staticEnv&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextPublicEnvironmentVariables&quot;</span><span class="s0">,</span><span class="s1">&quot;defineEnv&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextConfigEnv&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;hasNextRuntimeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;configFileName&quot;</span><span class="s0">,</span><span class="s1">&quot;innerKey&quot;</span><span class="s0">,</span><span class="s1">&quot;removeUncaughtErrorAndRejectionListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;removeAllListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_preloadEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;loadCustomCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;patchFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;webpackRequire&quot;</span><span class="s0">,</span><span class="s1">&quot;__next_app__&quot;</span><span class="s0">,</span><span class="s1">&quot;handleUpgrade&quot;</span><span class="s0">,</span><span class="s1">&quot;getInstrumentationModule&quot;</span><span class="s0">,</span><span class="s1">&quot;runInstrumentationHookIfAvailable&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureInstrumentationRegistered&quot;</span><span class="s0">,</span><span class="s1">&quot;forceReload&quot;</span><span class="s0">,</span><span class="s1">&quot;silent&quot;</span><span class="s0">,</span><span class="s1">&quot;initializeCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultCache&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;RemoteCache&quot;</span><span class="s0">,</span><span class="s1">&quot;setCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;CacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheFilesystem&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheMaxMemorySize&quot;</span><span class="s0">,</span><span class="s1">&quot;routesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;buildIdFile&quot;</span><span class="s0">,</span><span class="s1">&quot;trim&quot;</span><span class="s0">,</span><span class="s1">&quot;runApi&quot;</span><span class="s0">,</span><span class="s1">&quot;renderHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;renderHTMLImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;imageOptimizer&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeFunctionsPages&quot;</span><span class="s0">,</span><span class="s1">&quot;findPageComponentsImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;_url&quot;</span><span class="s0">,</span><span class="s1">&quot;pagePaths&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_FONT_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;logErrorWithOriginalStack&quot;</span><span class="s0">,</span><span class="s1">&quot;_err&quot;</span><span class="s0">,</span><span class="s1">&quot;_type&quot;</span><span class="s0">,</span><span class="s1">&quot;ensurePage&quot;</span><span class="s0">,</span><span class="s1">&quot;_opts&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeReq&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRes&quot;</span><span class="s0">,</span><span class="s1">&quot;makeRequestHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;mocked&quot;</span><span class="s0">,</span><span class="s1">&quot;createRequestResponseMocks&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_onlyGenerated&quot;</span><span class="s0">,</span><span class="s1">&quot;internal&quot;</span><span class="s0">,</span><span class="s1">&quot;is404&quot;</span><span class="s0">,</span><span class="s1">&quot;getMiddlewareManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewareModule&quot;</span><span class="s0">,</span><span class="s1">&quot;loadNodeMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;originalSource&quot;</span><span class="s0">,</span><span class="s1">&quot;getMiddlewareMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;stored&quot;</span><span class="s0">,</span><span class="s1">&quot;functions&quot;</span><span class="s0">,</span><span class="s1">&quot;getEdgeFunctionInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;foundPage&quot;</span><span class="s0">,</span><span class="s1">&quot;pageInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;files&quot;</span><span class="s0">,</span><span class="s1">&quot;wasm&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;assets&quot;</span><span class="s0">,</span><span class="s1">&quot;hasMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureEdgeFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;_params&quot;</span><span class="s0">,</span><span class="s1">&quot;_cachedPreviewManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;isUpgradeReq&quot;</span><span class="s0">,</span><span class="s1">&quot;trustHostHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;getCloneableBody&quot;</span><span class="s0">,</span><span class="s1">&quot;buffered&quot;</span><span class="s0">,</span><span class="s1">&quot;endPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;finalize&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceRequestBody&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneBodyStream&quot;</span><span class="s0">,</span><span class="s1">&quot;p1&quot;</span><span class="s0">,</span><span class="s1">&quot;PassThrough&quot;</span><span class="s0">,</span><span class="s1">&quot;p2&quot;</span><span class="s0">,</span><span class="s1">&quot;_serverDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;onServerClose&quot;</span><span class="s0">,</span><span class="s1">&quot;listener&quot;</span><span class="s0">,</span><span class="s1">&quot;internalWaitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;createInternalWaitUntil&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">33</span><span class="s0">,</span><span class="s2">34</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">38</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">40</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">51</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">53</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">55</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">57</span><span class="s0">,</span><span class="s2">58</span><span class="s0">,</span><span class="s2">59</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">61</span><span class="s0">,</span><span class="s2">62</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">64</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">68</span><span class="s0">,</span><span class="s2">69</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">73</span><span class="s0">,</span><span class="s2">74</span><span class="s0">,</span><span class="s2">75</span><span class="s0">,</span><span class="s2">76</span><span class="s0">,</span><span class="s2">77</span><span class="s0">,</span><span class="s2">78</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">80</span><span class="s0">,</span><span class="s2">81</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">85</span><span class="s0">,</span><span class="s2">86</span><span class="s0">,</span><span class="s2">87</span><span class="s0">,</span><span class="s2">88</span><span class="s0">,</span><span class="s2">89</span><span class="s0">,</span><span class="s2">90</span><span class="s0">,</span><span class="s2">91</span><span class="s0">,</span><span class="s2">92</span><span class="s0">,</span><span class="s2">93</span><span class="s0">,</span><span class="s2">94</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">96</span><span class="s0">,</span><span class="s2">97</span><span class="s0">,</span><span class="s2">98</span><span class="s0">,</span><span class="s2">99</span><span class="s0">,</span><span class="s2">100</span><span class="s0">,</span><span class="s2">101</span><span class="s0">,</span><span class="s2">102</span><span class="s0">,</span><span class="s2">103</span><span class="s0">,</span><span class="s2">104</span><span class="s0">,</span><span class="s2">105</span><span class="s0">,</span><span class="s2">106</span><span class="s0">,</span><span class="s2">107</span><span class="s0">,</span><span class="s2">108</span><span class="s0">,</span><span class="s2">109</span><span class="s0">,</span><span class="s2">110</span><span class="s0">,</span><span class="s2">111</span><span class="s0">,</span><span class="s2">112</span><span class="s0">,</span><span class="s2">113</span><span class="s0">,</span><span class="s2">114</span><span class="s0">,</span><span class="s2">115</span><span class="s0">,</span><span class="s2">116</span><span class="s0">,</span><span class="s2">117</span><span class="s0">,</span><span class="s2">118</span><span class="s0">,</span><span class="s2">119</span><span class="s0">,</span><span class="s2">120</span><span class="s0">,</span><span class="s2">121</span><span class="s0">,</span><span class="s2">122</span><span class="s0">,</span><span class="s2">123</span><span class="s0">,</span><span class="s2">124</span><span class="s0">,</span><span class="s2">125</span><span class="s0">,</span><span class="s2">126</span><span class="s0">,</span><span class="s2">127</span><span class="s0">,</span><span class="s2">128</span><span class="s0">,</span><span class="s2">129</span><span class="s0">,</span><span class="s2">130</span><span class="s0">,</span><span class="s2">131</span><span class="s0">,</span><span class="s2">132</span><span class="s0">,</span><span class="s2">133</span><span class="s0">,</span><span class="s2">134</span><span class="s0">,</span><span class="s2">135</span><span class="s0">,</span><span class="s2">136</span><span class="s0">,</span><span class="s2">137</span><span class="s0">,</span><span class="s2">138</span><span class="s0">,</span><span class="s2">139</span><span class="s0">,</span><span class="s2">140</span><span class="s0">,</span><span class="s2">141</span><span class="s0">,</span><span class="s2">142</span><span class="s0">,</span><span class="s2">143</span><span class="s0">,</span><span class="s2">144</span><span class="s0">,</span><span class="s2">145</span><span class="s0">,</span><span class="s2">146</span><span class="s0">,</span><span class="s2">147</span><span class="s0">,</span><span class="s2">148</span><span class="s0">,</span><span class="s2">149</span><span class="s0">,</span><span class="s2">150</span><span class="s0">,</span><span class="s2">151</span><span class="s0">,</span><span class="s2">152</span><span class="s0">,</span><span class="s2">153</span><span class="s0">,</span><span class="s2">154</span><span class="s0">,</span><span class="s2">155</span><span class="s0">,</span><span class="s2">156</span><span class="s0">,</span><span class="s2">157</span><span class="s0">,</span><span class="s2">158</span><span class="s0">,</span><span class="s2">159</span><span class="s0">,</span><span class="s2">160</span><span class="s0">,</span><span class="s2">161</span><span class="s0">,</span><span class="s2">162</span><span class="s0">,</span><span class="s2">163</span><span class="s0">,</span><span class="s2">164</span><span class="s0">,</span><span class="s2">165</span><span class="s0">,</span><span class="s2">166</span><span class="s0">,</span><span class="s2">167</span><span class="s0">,</span><span class="s2">168</span><span class="s0">,</span><span class="s2">169</span><span class="s0">,</span><span class="s2">170</span><span class="s0">,</span><span class="s2">171</span><span class="s0">,</span><span class="s2">172</span><span class="s0">,</span><span class="s2">173</span><span class="s0">,</span><span class="s2">174</span><span class="s0">,</span><span class="s2">175</span><span class="s0">,</span><span class="s2">176</span><span class="s0">,</span><span class="s2">177</span><span class="s0">,</span><span class="s2">178</span><span class="s0">,</span><span class="s2">179</span><span class="s0">,</span><span class="s2">180</span><span class="s0">,</span><span class="s2">181</span><span class="s0">,</span><span class="s2">182</span><span class="s0">,</span><span class="s2">183</span><span class="s0">,</span><span class="s2">184</span><span class="s0">,</span><span class="s2">185</span><span class="s0">,</span><span class="s2">186</span><span class="s0">,</span><span class="s2">187</span><span class="s0">,</span><span class="s2">188</span><span class="s0">,</span><span class="s2">189</span><span class="s0">,</span><span class="s2">190</span><span class="s0">,</span><span class="s2">191</span><span class="s0">,</span><span class="s2">192</span><span class="s0">,</span><span class="s2">193</span><span class="s0">,</span><span class="s2">194</span><span class="s0">]}</span></pre>
</body>
</html>