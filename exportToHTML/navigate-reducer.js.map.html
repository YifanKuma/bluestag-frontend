<html>
<head>
<title>navigate-reducer.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
navigate-reducer.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../../src/client/components/router-reducer/reducers/navigate-reducer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { fetchServerResponse } from '../fetch-server-response'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from '../create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'</span><span class="s3">\n</span><span class="s1">import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'</span><span class="s3">\n</span><span class="s1">import { shouldHardNavigate } from '../should-hard-navigate'</span><span class="s3">\n</span><span class="s1">import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PrefetchCacheEntryStatus,</span><span class="s3">\n  </span><span class="s1">type Mutable,</span><span class="s3">\n  </span><span class="s1">type NavigateAction,</span><span class="s3">\n  </span><span class="s1">type ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">type ReducerState,</span><span class="s3">\n</span><span class="s1">} from '../router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { handleMutable } from '../handle-mutable'</span><span class="s3">\n</span><span class="s1">import { applyFlightData } from '../apply-flight-data'</span><span class="s3">\n</span><span class="s1">import { prefetchQueue } from './prefetch-reducer'</span><span class="s3">\n</span><span class="s1">import { createEmptyCacheNode } from '../../app-router'</span><span class="s3">\n</span><span class="s1">import { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { listenForDynamicRequest, startPPRNavigation } from '../ppr-navigations'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getOrCreatePrefetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">prunePrefetchCache,</span><span class="s3">\n</span><span class="s1">} from '../prefetch-cache-utils'</span><span class="s3">\n</span><span class="s1">import { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'</span><span class="s3">\n</span><span class="s1">import { handleAliasedPrefetchEntry } from '../aliased-prefetch-navigations'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">navigate as navigateUsingSegmentCache,</span><span class="s3">\n  </span><span class="s1">NavigationResultTag,</span><span class="s3">\n  </span><span class="s1">type NavigationResult,</span><span class="s3">\n</span><span class="s1">} from '../../segment-cache'</span><span class="s3">\n\n</span><span class="s1">export function handleExternalUrl(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">mutable: Mutable,</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">pendingPush: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">mutable.mpaNavigation = true</span><span class="s3">\n  </span><span class="s1">mutable.canonicalUrl = url</span><span class="s3">\n  </span><span class="s1">mutable.pendingPush = pendingPush</span><span class="s3">\n  </span><span class="s1">mutable.scrollableSegments = undefined</span><span class="s3">\n\n  </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateSegmentsFromPatch(</span><span class="s3">\n  </span><span class="s1">flightRouterPatch: FlightRouterState</span><span class="s3">\n</span><span class="s1">): FlightSegmentPath[] {</span><span class="s3">\n  </span><span class="s1">const segments: FlightSegmentPath[] = []</span><span class="s3">\n  </span><span class="s1">const [segment, parallelRoutes] = flightRouterPatch</span><span class="s3">\n\n  </span><span class="s1">if (Object.keys(parallelRoutes).length === 0) {</span><span class="s3">\n    </span><span class="s1">return [[segment]]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const [parallelRouteKey, parallelRoute] of Object.entries(</span><span class="s3">\n    </span><span class="s1">parallelRoutes</span><span class="s3">\n  </span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {</span><span class="s3">\n      </span><span class="s1">// If the segment is empty, it means we are at the root of the tree</span><span class="s3">\n      </span><span class="s1">if (segment === '') {</span><span class="s3">\n        </span><span class="s1">segments.push([parallelRouteKey, ...childSegment])</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">segments.push([segment, parallelRouteKey, ...childSegment])</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segments</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function triggerLazyFetchForLeafSegments(</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">currentCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">treePatch: FlightRouterState</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let appliedPatch = false</span><span class="s3">\n\n  </span><span class="s1">newCache.rsc = currentCache.rsc</span><span class="s3">\n  </span><span class="s1">newCache.prefetchRsc = currentCache.prefetchRsc</span><span class="s3">\n  </span><span class="s1">newCache.loading = currentCache.loading</span><span class="s3">\n  </span><span class="s1">newCache.parallelRoutes = new Map(currentCache.parallelRoutes)</span><span class="s3">\n\n  </span><span class="s1">const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(</span><span class="s3">\n    </span><span class="s1">(segment) =&gt; [...flightSegmentPath, ...segment]</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">for (const segmentPaths of segmentPathsToFill) {</span><span class="s3">\n    </span><span class="s1">clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)</span><span class="s3">\n\n    </span><span class="s1">appliedPatch = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return appliedPatch</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleNavigationResult(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">mutable: Mutable,</span><span class="s3">\n  </span><span class="s1">pendingPush: boolean,</span><span class="s3">\n  </span><span class="s1">result: NavigationResult</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">switch (result.tag) {</span><span class="s3">\n    </span><span class="s1">case NavigationResultTag.MPA: {</span><span class="s3">\n      </span><span class="s1">// Perform an MPA navigation.</span><span class="s3">\n      </span><span class="s1">const newUrl = result.data</span><span class="s3">\n      </span><span class="s1">return handleExternalUrl(state, mutable, newUrl, pendingPush)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case NavigationResultTag.NoOp: {</span><span class="s3">\n      </span><span class="s1">// The server responded with no change to the current page. However, if</span><span class="s3">\n      </span><span class="s1">// the URL changed, we still need to update that.</span><span class="s3">\n      </span><span class="s1">const newCanonicalUrl = result.data.canonicalUrl</span><span class="s3">\n      </span><span class="s1">mutable.canonicalUrl = newCanonicalUrl</span><span class="s3">\n\n      </span><span class="s1">// Check if the only thing that changed was the hash fragment.</span><span class="s3">\n      </span><span class="s1">const oldUrl = new URL(state.canonicalUrl, url)</span><span class="s3">\n      </span><span class="s1">const onlyHashChange =</span><span class="s3">\n        </span><span class="s1">// We don't need to compare the origins, because client-driven</span><span class="s3">\n        </span><span class="s1">// navigations are always same-origin.</span><span class="s3">\n        </span><span class="s1">url.pathname === oldUrl.pathname &amp;&amp;</span><span class="s3">\n        </span><span class="s1">url.search === oldUrl.search &amp;&amp;</span><span class="s3">\n        </span><span class="s1">url.hash !== oldUrl.hash</span><span class="s3">\n      </span><span class="s1">if (onlyHashChange) {</span><span class="s3">\n        </span><span class="s1">// The only updated part of the URL is the hash.</span><span class="s3">\n        </span><span class="s1">mutable.onlyHashChange = true</span><span class="s3">\n        </span><span class="s1">mutable.shouldScroll = result.data.shouldScroll</span><span class="s3">\n        </span><span class="s1">mutable.hashFragment = url.hash</span><span class="s3">\n        </span><span class="s1">// Setting this to an empty array triggers a scroll for all new and</span><span class="s3">\n        </span><span class="s1">// updated segments. See `ScrollAndFocusHandler` for more details.</span><span class="s3">\n        </span><span class="s1">mutable.scrollableSegments = []</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case NavigationResultTag.Success: {</span><span class="s3">\n      </span><span class="s1">// Received a new result.</span><span class="s3">\n      </span><span class="s1">mutable.cache = result.data.cacheNode</span><span class="s3">\n      </span><span class="s1">mutable.patchedTree = result.data.flightRouterState</span><span class="s3">\n      </span><span class="s1">mutable.canonicalUrl = result.data.canonicalUrl</span><span class="s3">\n      </span><span class="s1">mutable.scrollableSegments = result.data.scrollableSegments</span><span class="s3">\n      </span><span class="s1">mutable.shouldScroll = result.data.shouldScroll</span><span class="s3">\n      </span><span class="s1">mutable.hashFragment = result.data.hash</span><span class="s3">\n      </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case NavigationResultTag.Async: {</span><span class="s3">\n      </span><span class="s1">return result.data.then(</span><span class="s3">\n        </span><span class="s1">(asyncResult) =&gt;</span><span class="s3">\n          </span><span class="s1">handleNavigationResult(url, state, mutable, pendingPush, asyncResult),</span><span class="s3">\n        </span><span class="s1">// If the navigation failed, return the current state.</span><span class="s3">\n        </span><span class="s1">// TODO: This matches the current behavior but we need to do something</span><span class="s3">\n        </span><span class="s1">// better here if the network fails.</span><span class="s3">\n        </span><span class="s1">() =&gt; {</span><span class="s3">\n          </span><span class="s1">return state</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">default: {</span><span class="s3">\n      </span><span class="s1">result satisfies never</span><span class="s3">\n      </span><span class="s1">return state</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function navigateReducer(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">action: NavigateAction</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } =</span><span class="s3">\n    </span><span class="s1">action</span><span class="s3">\n  </span><span class="s1">const mutable: Mutable = {}</span><span class="s3">\n  </span><span class="s1">const { hash } = url</span><span class="s3">\n  </span><span class="s1">const href = createHrefFromUrl(url)</span><span class="s3">\n  </span><span class="s1">const pendingPush = navigateType === 'push'</span><span class="s3">\n  </span><span class="s1">// we want to prune the prefetch cache on every navigation to avoid it growing too large</span><span class="s3">\n  </span><span class="s1">prunePrefetchCache(state.prefetchCache)</span><span class="s3">\n\n  </span><span class="s1">mutable.preserveCustomHistoryState = false</span><span class="s3">\n  </span><span class="s1">mutable.pendingPush = pendingPush</span><span class="s3">\n\n  </span><span class="s1">if (isExternalUrl) {</span><span class="s3">\n    </span><span class="s1">return handleExternalUrl(state, mutable, url.toString(), pendingPush)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Handles case where `&lt;meta http-equiv=</span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot;</span><span class="s1">&gt;` tag is present,</span><span class="s3">\n  </span><span class="s1">// which will trigger an MPA navigation.</span><span class="s3">\n  </span><span class="s1">if (document.getElementById('__next-page-redirect')) {</span><span class="s3">\n    </span><span class="s1">return handleExternalUrl(state, mutable, href, pendingPush)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span><span class="s3">\n    </span><span class="s1">// (Very Early Experimental Feature) Segment Cache</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Bypass the normal prefetch cache and use the new per-segment cache</span><span class="s3">\n    </span><span class="s1">// implementation instead. This is only supported if PPR is enabled, too.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Temporary glue code between the router reducer and the new navigation</span><span class="s3">\n    </span><span class="s1">// implementation. Eventually we'll rewrite the router reducer to a</span><span class="s3">\n    </span><span class="s1">// state machine.</span><span class="s3">\n    </span><span class="s1">const result = navigateUsingSegmentCache(</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">state.cache,</span><span class="s3">\n      </span><span class="s1">state.tree,</span><span class="s3">\n      </span><span class="s1">state.nextUrl,</span><span class="s3">\n      </span><span class="s1">shouldScroll</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return handleNavigationResult(url, state, mutable, pendingPush, result)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const prefetchValues = getOrCreatePrefetchCacheEntry({</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">nextUrl: state.nextUrl,</span><span class="s3">\n    </span><span class="s1">tree: state.tree,</span><span class="s3">\n    </span><span class="s1">prefetchCache: state.prefetchCache,</span><span class="s3">\n    </span><span class="s1">allowAliasing,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">const { treeAtTimeOfPrefetch, data } = prefetchValues</span><span class="s3">\n\n  </span><span class="s1">prefetchQueue.bump(data)</span><span class="s3">\n\n  </span><span class="s1">return data.then(</span><span class="s3">\n    </span><span class="s1">({ flightData, canonicalUrl: canonicalUrlOverride, postponed }) =&gt; {</span><span class="s3">\n      </span><span class="s1">const navigatedAt = Date.now()</span><span class="s3">\n\n      </span><span class="s1">let isFirstRead = false</span><span class="s3">\n      </span><span class="s1">// we only want to mark this once</span><span class="s3">\n      </span><span class="s1">if (!prefetchValues.lastUsedTime) {</span><span class="s3">\n        </span><span class="s1">// important: we should only mark the cache node as dirty after we unsuspend from the call above</span><span class="s3">\n        </span><span class="s1">prefetchValues.lastUsedTime = navigatedAt</span><span class="s3">\n        </span><span class="s1">isFirstRead = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (prefetchValues.aliased) {</span><span class="s3">\n        </span><span class="s1">// When alias is enabled, search param may not be included in the canonicalUrl.</span><span class="s3">\n        </span><span class="s1">// But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.</span><span class="s3">\n        </span><span class="s1">const urlWithCanonicalPathname = new URL(url.href)</span><span class="s3">\n        </span><span class="s1">if (canonicalUrlOverride) {</span><span class="s3">\n          </span><span class="s1">urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const result = handleAliasedPrefetchEntry(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">flightData,</span><span class="s3">\n          </span><span class="s1">urlWithCanonicalPathname,</span><span class="s3">\n          </span><span class="s1">mutable</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// We didn't return new router state because we didn't apply the aliased entry for some reason.</span><span class="s3">\n        </span><span class="s1">// We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This</span><span class="s3">\n        </span><span class="s1">// will create an on-demand prefetch entry.</span><span class="s3">\n        </span><span class="s1">if (result === false) {</span><span class="s3">\n          </span><span class="s1">return navigateReducer(state, { ...action, allowAliasing: false })</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return result</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Handle case when navigating to page in `pages` from `app`</span><span class="s3">\n      </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n        </span><span class="s1">return handleExternalUrl(state, mutable, flightData, pendingPush)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const updatedCanonicalUrl = canonicalUrlOverride</span><span class="s3">\n        </span><span class="s1">? createHrefFromUrl(canonicalUrlOverride)</span><span class="s3">\n        </span><span class="s1">: href</span><span class="s3">\n\n      </span><span class="s1">const onlyHashChange =</span><span class="s3">\n        </span><span class="s1">!!hash &amp;&amp;</span><span class="s3">\n        </span><span class="s1">state.canonicalUrl.split('#', 1)[0] ===</span><span class="s3">\n          </span><span class="s1">updatedCanonicalUrl.split('#', 1)[0]</span><span class="s3">\n\n      </span><span class="s1">// If only the hash has changed, the server hasn't sent us any new data. We can just update</span><span class="s3">\n      </span><span class="s1">// the mutable properties responsible for URL and scroll handling and return early.</span><span class="s3">\n      </span><span class="s1">if (onlyHashChange) {</span><span class="s3">\n        </span><span class="s1">mutable.onlyHashChange = true</span><span class="s3">\n        </span><span class="s1">mutable.canonicalUrl = updatedCanonicalUrl</span><span class="s3">\n        </span><span class="s1">mutable.shouldScroll = shouldScroll</span><span class="s3">\n        </span><span class="s1">mutable.hashFragment = hash</span><span class="s3">\n        </span><span class="s1">mutable.scrollableSegments = []</span><span class="s3">\n        </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let currentTree = state.tree</span><span class="s3">\n      </span><span class="s1">let currentCache = state.cache</span><span class="s3">\n      </span><span class="s1">let scrollableSegments: FlightSegmentPath[] = []</span><span class="s3">\n      </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n        </span><span class="s1">const {</span><span class="s3">\n          </span><span class="s1">pathToSegment: flightSegmentPath,</span><span class="s3">\n          </span><span class="s1">seedData,</span><span class="s3">\n          </span><span class="s1">head,</span><span class="s3">\n          </span><span class="s1">isHeadPartial,</span><span class="s3">\n          </span><span class="s1">isRootRender,</span><span class="s3">\n        </span><span class="s1">} = normalizedFlightData</span><span class="s3">\n        </span><span class="s1">let treePatch = normalizedFlightData.tree</span><span class="s3">\n\n        </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n        </span><span class="s1">const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]</span><span class="s3">\n\n        </span><span class="s1">// Create new tree based on the flightSegmentPath and router state patch</span><span class="s3">\n        </span><span class="s1">let newTree = applyRouterStatePatchToTree(</span><span class="s3">\n          </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n          </span><span class="s1">flightSegmentPathWithLeadingEmpty,</span><span class="s3">\n          </span><span class="s1">currentTree,</span><span class="s3">\n          </span><span class="s1">treePatch,</span><span class="s3">\n          </span><span class="s1">href</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the tree patch can't be applied to the current tree then we use the tree at time of prefetch</span><span class="s3">\n        </span><span class="s1">// TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.</span><span class="s3">\n        </span><span class="s1">if (newTree === null) {</span><span class="s3">\n          </span><span class="s1">newTree = applyRouterStatePatchToTree(</span><span class="s3">\n            </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n            </span><span class="s1">flightSegmentPathWithLeadingEmpty,</span><span class="s3">\n            </span><span class="s1">treeAtTimeOfPrefetch,</span><span class="s3">\n            </span><span class="s1">treePatch,</span><span class="s3">\n            </span><span class="s1">href</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (newTree !== null) {</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">// This is just a paranoid check. When a route is PPRed, the server</span><span class="s3">\n            </span><span class="s1">// will send back a static response that's rendered from</span><span class="s3">\n            </span><span class="s1">// the root. If for some reason it doesn't, we fall back to the</span><span class="s3">\n            </span><span class="s1">// non-PPR implementation.</span><span class="s3">\n            </span><span class="s1">// TODO: We should get rid of the else branch and do all navigations</span><span class="s3">\n            </span><span class="s1">// via startPPRNavigation. The current structure is just</span><span class="s3">\n            </span><span class="s1">// an incremental step.</span><span class="s3">\n            </span><span class="s1">seedData &amp;&amp;</span><span class="s3">\n            </span><span class="s1">isRootRender &amp;&amp;</span><span class="s3">\n            </span><span class="s1">postponed</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const task = startPPRNavigation(</span><span class="s3">\n              </span><span class="s1">navigatedAt,</span><span class="s3">\n              </span><span class="s1">currentCache,</span><span class="s3">\n              </span><span class="s1">currentTree,</span><span class="s3">\n              </span><span class="s1">treePatch,</span><span class="s3">\n              </span><span class="s1">seedData,</span><span class="s3">\n              </span><span class="s1">head,</span><span class="s3">\n              </span><span class="s1">isHeadPartial,</span><span class="s3">\n              </span><span class="s1">false,</span><span class="s3">\n              </span><span class="s1">scrollableSegments</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">if (task !== null) {</span><span class="s3">\n              </span><span class="s1">if (task.route === null) {</span><span class="s3">\n                </span><span class="s1">// Detected a change to the root layout. Perform an full-</span><span class="s3">\n                </span><span class="s1">// page navigation.</span><span class="s3">\n                </span><span class="s1">return handleExternalUrl(state, mutable, href, pendingPush)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">// Use the tree computed by startPPRNavigation instead</span><span class="s3">\n              </span><span class="s1">// of the one computed by applyRouterStatePatchToTree.</span><span class="s3">\n              </span><span class="s1">// TODO: We should remove applyRouterStatePatchToTree</span><span class="s3">\n              </span><span class="s1">// from the PPR path entirely.</span><span class="s3">\n              </span><span class="s1">const patchedRouterState: FlightRouterState = task.route</span><span class="s3">\n              </span><span class="s1">newTree = patchedRouterState</span><span class="s3">\n\n              </span><span class="s1">const newCache = task.node</span><span class="s3">\n              </span><span class="s1">if (newCache !== null) {</span><span class="s3">\n                </span><span class="s1">// We've created a new Cache Node tree that contains a prefetched</span><span class="s3">\n                </span><span class="s1">// version of the next page. This can be rendered instantly.</span><span class="s3">\n                </span><span class="s1">mutable.cache = newCache</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">const dynamicRequestTree = task.dynamicRequestTree</span><span class="s3">\n              </span><span class="s1">if (dynamicRequestTree !== null) {</span><span class="s3">\n                </span><span class="s1">// The prefetched tree has dynamic holes in it. We initiate a</span><span class="s3">\n                </span><span class="s1">// dynamic request to fill them in.</span><span class="s3">\n                </span><span class="s1">//</span><span class="s3">\n                </span><span class="s1">// Do not block on the result. We'll immediately render the Cache</span><span class="s3">\n                </span><span class="s1">// Node tree and suspend on the dynamic parts. When the request</span><span class="s3">\n                </span><span class="s1">// comes in, we'll fill in missing data and ping React to</span><span class="s3">\n                </span><span class="s1">// re-render. Unlike the lazy fetching model in the non-PPR</span><span class="s3">\n                </span><span class="s1">// implementation, this is modeled as a single React update +</span><span class="s3">\n                </span><span class="s1">// streaming, rather than multiple top-level updates. (However,</span><span class="s3">\n                </span><span class="s1">// even in the new model, we'll still need to sometimes update the</span><span class="s3">\n                </span><span class="s1">// root multiple times per navigation, like if the server sends us</span><span class="s3">\n                </span><span class="s1">// a different response than we expected. For now, we revert back</span><span class="s3">\n                </span><span class="s1">// to the lazy fetching mechanism in that case.)</span><span class="s3">\n                </span><span class="s1">const dynamicRequest = fetchServerResponse(</span><span class="s3">\n                  </span><span class="s1">new URL(updatedCanonicalUrl, url.origin),</span><span class="s3">\n                  </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">flightRouterState: dynamicRequestTree,</span><span class="s3">\n                    </span><span class="s1">nextUrl: state.nextUrl,</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">listenForDynamicRequest(task, dynamicRequest)</span><span class="s3">\n                </span><span class="s1">// We store the dynamic request on the `lazyData` property of the CacheNode</span><span class="s3">\n                </span><span class="s1">// because we're not going to await the dynamic request here. Since we're not blocking</span><span class="s3">\n                </span><span class="s1">// on the dynamic request, `layout-router` will</span><span class="s3">\n                </span><span class="s1">// task.node.lazyData = dynamicRequest</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">// The prefetched tree does not contain dynamic holes â€” it's</span><span class="s3">\n                </span><span class="s1">// fully static. We can skip the dynamic request.</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// Nothing changed, so reuse the old cache.</span><span class="s3">\n              </span><span class="s1">// TODO: What if the head changed but not any of the segment data?</span><span class="s3">\n              </span><span class="s1">// Is that possible? If so, we should clone the whole tree and</span><span class="s3">\n              </span><span class="s1">// update the head.</span><span class="s3">\n              </span><span class="s1">newTree = treePatch</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The static response does not include any dynamic holes, so</span><span class="s3">\n            </span><span class="s1">// there's no need to do a second request.</span><span class="s3">\n            </span><span class="s1">// TODO: As an incremental step this just reverts back to the</span><span class="s3">\n            </span><span class="s1">// non-PPR implementation. We can simplify this branch further,</span><span class="s3">\n            </span><span class="s1">// given that PPR prefetches are always static and return the whole</span><span class="s3">\n            </span><span class="s1">// tree. Or in the meantime we could factor it out into a</span><span class="s3">\n            </span><span class="s1">// separate function.</span><span class="s3">\n\n            </span><span class="s1">if (isNavigatingToNewRootLayout(currentTree, newTree)) {</span><span class="s3">\n              </span><span class="s1">return handleExternalUrl(state, mutable, href, pendingPush)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const cache: CacheNode = createEmptyCacheNode()</span><span class="s3">\n            </span><span class="s1">let applied = false</span><span class="s3">\n\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">prefetchValues.status === PrefetchCacheEntryStatus.stale &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!isFirstRead</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">// When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations</span><span class="s3">\n              </span><span class="s1">// this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,</span><span class="s3">\n              </span><span class="s1">// while copying over the `loading` for the segment that contains the page data.</span><span class="s3">\n              </span><span class="s1">// We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.</span><span class="s3">\n\n              </span><span class="s1">// We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case</span><span class="s3">\n              </span><span class="s1">applied = triggerLazyFetchForLeafSegments(</span><span class="s3">\n                </span><span class="s1">cache,</span><span class="s3">\n                </span><span class="s1">currentCache,</span><span class="s3">\n                </span><span class="s1">flightSegmentPath,</span><span class="s3">\n                </span><span class="s1">treePatch</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">// since we re-used the stale cache's loading state &amp; refreshed the data,</span><span class="s3">\n              </span><span class="s1">// update the `lastUsedTime` so that it can continue to be re-used for the next 30s</span><span class="s3">\n              </span><span class="s1">prefetchValues.lastUsedTime = navigatedAt</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">applied = applyFlightData(</span><span class="s3">\n                </span><span class="s1">navigatedAt,</span><span class="s3">\n                </span><span class="s1">currentCache,</span><span class="s3">\n                </span><span class="s1">cache,</span><span class="s3">\n                </span><span class="s1">normalizedFlightData,</span><span class="s3">\n                </span><span class="s1">prefetchValues</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const hardNavigate = shouldHardNavigate(</span><span class="s3">\n              </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n              </span><span class="s1">flightSegmentPathWithLeadingEmpty,</span><span class="s3">\n              </span><span class="s1">currentTree</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">if (hardNavigate) {</span><span class="s3">\n              </span><span class="s1">// Copy rsc for the root node of the cache.</span><span class="s3">\n              </span><span class="s1">cache.rsc = currentCache.rsc</span><span class="s3">\n              </span><span class="s1">cache.prefetchRsc = currentCache.prefetchRsc</span><span class="s3">\n\n              </span><span class="s1">invalidateCacheBelowFlightSegmentPath(</span><span class="s3">\n                </span><span class="s1">cache,</span><span class="s3">\n                </span><span class="s1">currentCache,</span><span class="s3">\n                </span><span class="s1">flightSegmentPath</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">// Ensure the existing cache value is used when the cache was not invalidated.</span><span class="s3">\n              </span><span class="s1">mutable.cache = cache</span><span class="s3">\n            </span><span class="s1">} else if (applied) {</span><span class="s3">\n              </span><span class="s1">mutable.cache = cache</span><span class="s3">\n              </span><span class="s1">// If we applied the cache, we update the </span><span class="s3">\&quot;</span><span class="s1">current cache</span><span class="s3">\&quot; </span><span class="s1">value so any other</span><span class="s3">\n              </span><span class="s1">// segments in the FlightDataPath will be able to reference the updated cache.</span><span class="s3">\n              </span><span class="s1">currentCache = cache</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">for (const subSegment of generateSegmentsFromPatch(treePatch)) {</span><span class="s3">\n              </span><span class="s1">const scrollableSegmentPath = [</span><span class="s3">\n                </span><span class="s1">...flightSegmentPath,</span><span class="s3">\n                </span><span class="s1">...subSegment,</span><span class="s3">\n              </span><span class="s1">]</span><span class="s3">\n              </span><span class="s1">// Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">scrollableSegmentPath[scrollableSegmentPath.length - 1] !==</span><span class="s3">\n                </span><span class="s1">DEFAULT_SEGMENT_KEY</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">scrollableSegments.push(scrollableSegmentPath)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">currentTree = newTree</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">mutable.patchedTree = currentTree</span><span class="s3">\n      </span><span class="s1">mutable.canonicalUrl = updatedCanonicalUrl</span><span class="s3">\n      </span><span class="s1">mutable.scrollableSegments = scrollableSegments</span><span class="s3">\n      </span><span class="s1">mutable.hashFragment = hash</span><span class="s3">\n      </span><span class="s1">mutable.shouldScroll = shouldScroll</span><span class="s3">\n\n      </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">() =&gt; state</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;generateSegmentsFromPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;handleExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;mpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;triggerLazyFetchForLeafSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;currentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;appliedPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPathsToFill&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;clearCacheNodeDataForSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;handleNavigationResult&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;NavigationResultTag&quot;</span><span class="s0">,</span><span class="s1">&quot;MPA&quot;</span><span class="s0">,</span><span class="s1">&quot;newUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;NoOp&quot;</span><span class="s0">,</span><span class="s1">&quot;newCanonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;oldUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyHashChange&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;hashFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;Success&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;Async&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;asyncResult&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;isExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateType&quot;</span><span class="s0">,</span><span class="s1">&quot;allowAliasing&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;prunePrefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementById&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateUsingSegmentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchValues&quot;</span><span class="s0">,</span><span class="s1">&quot;getOrCreatePrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;treeAtTimeOfPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;bump&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrlOverride&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;isFirstRead&quot;</span><span class="s0">,</span><span class="s1">&quot;lastUsedTime&quot;</span><span class="s0">,</span><span class="s1">&quot;aliased&quot;</span><span class="s0">,</span><span class="s1">&quot;urlWithCanonicalPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;handleAliasedPrefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedCanonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;isHeadPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPathWithLeadingEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;newTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;startPPRNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequestTree&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;listenForDynamicRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;createEmptyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;applied&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchCacheEntryStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;stale&quot;</span><span class="s0">,</span><span class="s1">&quot;applyFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;hardNavigate&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldHardNavigate&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidateCacheBelowFlightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;subSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>