<html>
<head>
<title>app.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">assignErrorIfEmpty: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">buildAppStaticPaths: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">calculateFallbackMode: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">filterUniqueParams: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">generateAllParamCombinations: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">generateRouteStaticParams: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">assignErrorIfEmpty: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">assignErrorIfEmpty;</span>
    <span class="s1">},</span>
    <span class="s1">buildAppStaticPaths: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">buildAppStaticPaths;</span>
    <span class="s1">},</span>
    <span class="s1">calculateFallbackMode: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">calculateFallbackMode;</span>
    <span class="s1">},</span>
    <span class="s1">filterUniqueParams: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">filterUniqueParams;</span>
    <span class="s1">},</span>
    <span class="s1">generateAllParamCombinations: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">generateAllParamCombinations;</span>
    <span class="s1">},</span>
    <span class="s1">generateRouteStaticParams: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">generateRouteStaticParams;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_nodepath = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;node:path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_runwithafter = require(</span><span class="s0">&quot;../../server/after/run-with-after&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workstore = require(</span><span class="s0">&quot;../../server/async-storage/work-store&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fallback = require(</span><span class="s0">&quot;../../lib/fallback&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routematcher = require(</span><span class="s0">&quot;../../shared/lib/router/utils/route-matcher&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routeregex = require(</span><span class="s0">&quot;../../shared/lib/router/utils/route-regex&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;./utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_escapepathdelimiters = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../../shared/lib/router/utils/escape-path-delimiters&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_createincrementalcache = require(</span><span class="s0">&quot;../../export/helpers/create-incremental-cache&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">filterUniqueParams(routeParamKeys, routeParams) {</span>
    <span class="s4">// A Map is used to store unique parameter combinations. The key of the Map</span>
    <span class="s4">// is a string representation of the parameter combination, and the value</span>
    <span class="s4">// is the actual `Params` object.</span>
    <span class="s2">const </span><span class="s1">unique = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s4">// Iterate over each parameter object in the input array.</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">params of routeParams){</span>
        <span class="s2">let </span><span class="s1">key = </span><span class="s0">'' </span><span class="s4">// Initialize an empty string to build the unique key for the current `params` object.</span>
        <span class="s1">;</span>
        <span class="s4">// Iterate through the `routeParamKeys` (which are assumed to be sorted).</span>
        <span class="s4">// This consistent order is crucial for generating a stable and unique key</span>
        <span class="s4">// for each parameter combination.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">paramKey of routeParamKeys){</span>
            <span class="s2">const </span><span class="s1">value = params[paramKey];</span>
            <span class="s4">// Construct a part of the key using the parameter key and its value.</span>
            <span class="s4">// A type prefix (`A:` for Array, `S:` for String, `U:` for undefined) is added to the value</span>
            <span class="s4">// to prevent collisions. For example, `['a', 'b']` and `'a,b'` would</span>
            <span class="s4">// otherwise generate the same string representation, leading to incorrect</span>
            <span class="s4">// deduplication. This ensures that different types with the same string</span>
            <span class="s4">// representation are treated as distinct.</span>
            <span class="s2">let </span><span class="s1">valuePart;</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                <span class="s1">valuePart = </span><span class="s0">`A:</span><span class="s1">${value.join(</span><span class="s0">','</span><span class="s1">)}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value === undefined) {</span>
                <span class="s1">valuePart = </span><span class="s0">`U:undefined`</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">valuePart = </span><span class="s0">`S:</span><span class="s1">${value}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">key += </span><span class="s0">`</span><span class="s1">${paramKey}</span><span class="s0">:</span><span class="s1">${valuePart}</span><span class="s0">|`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// If the generated key is not already in the `unique` Map, it means this</span>
        <span class="s4">// parameter combination is unique so far. Add it to the Map.</span>
        <span class="s2">if </span><span class="s1">(!unique.has(key)) {</span>
            <span class="s1">unique.set(key, params);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// Convert the Map's values (the unique `Params` objects) back into an array</span>
    <span class="s4">// and return it.</span>
    <span class="s2">return </span><span class="s1">Array.from(unique.values());</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateAllParamCombinations(routeParamKeys, routeParams, rootParamKeys) {</span>
    <span class="s4">// A Map is used to store unique combinations of Route Parameters.</span>
    <span class="s4">// The key of the Map is a string representation of the Route Parameter</span>
    <span class="s4">// combination, and the value is the `Params` object containing only</span>
    <span class="s4">// the Route Parameters.</span>
    <span class="s2">const </span><span class="s1">combinations = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s4">// Determine the minimum index where all Root Parameters are included.</span>
    <span class="s4">// This optimization ensures we only generate combinations that include</span>
    <span class="s4">// a complete set of Root Parameters, preventing invalid Static Shells.</span>
    <span class="s4">//</span>
    <span class="s4">// For example, if rootParamKeys = ['lang', 'region'] and routeParamKeys = ['lang', 'region', 'slug']:</span>
    <span class="s4">// - 'lang' is at index 0, 'region' is at index 1</span>
    <span class="s4">// - minIndexForCompleteRootParams = max(0, 1) = 1</span>
    <span class="s4">// - We'll only generate combinations starting from index 1 (which includes both lang and region)</span>
    <span class="s2">let </span><span class="s1">minIndexForCompleteRootParams = -</span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(rootParamKeys.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s4">// Find the index of the last Root Parameter in routeParamKeys.</span>
        <span class="s4">// This tells us the minimum combination length needed to include all Root Parameters.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">rootParamKey of rootParamKeys){</span>
            <span class="s2">const </span><span class="s1">index = routeParamKeys.indexOf(rootParamKey);</span>
            <span class="s2">if </span><span class="s1">(index === -</span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s4">// Root Parameter not found in Route Parameters - this shouldn't happen in normal cases</span>
                <span class="s4">// but we handle it gracefully by treating it as if there are no Root Parameters.</span>
                <span class="s4">// This allows the function to fall back to generating all sub-combinations.</span>
                <span class="s1">minIndexForCompleteRootParams = -</span><span class="s3">1</span><span class="s1">;</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Track the highest index among all Root Parameters.</span>
            <span class="s4">// This ensures all Root Parameters are included in any generated combination.</span>
            <span class="s1">minIndexForCompleteRootParams = Math.max(minIndexForCompleteRootParams, index);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// Iterate over each Static Parameter object in the input array.</span>
    <span class="s4">// Each params object represents one potential route combination (e.g., { lang: 'en', region: 'US', slug: 'home' })</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">params of routeParams){</span>
        <span class="s4">// Generate all possible prefix combinations for this Static Parameter set.</span>
        <span class="s4">// For routeParamKeys = ['lang', 'region', 'slug'], we'll generate combinations at:</span>
        <span class="s4">// - i=0: { lang: 'en' }</span>
        <span class="s4">// - i=1: { lang: 'en', region: 'US' }</span>
        <span class="s4">// - i=2: { lang: 'en', region: 'US', slug: 'home' }</span>
        <span class="s4">//</span>
        <span class="s4">// The iteration order is crucial for generating stable and unique keys</span>
        <span class="s4">// for each Route Parameter combination.</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; routeParamKeys.length; i++){</span>
            <span class="s4">// Skip generating combinations that don't include all Root Parameters.</span>
            <span class="s4">// This prevents creating invalid Static Shells that are missing required Root Parameters.</span>
            <span class="s4">//</span>
            <span class="s4">// For example, if Root Parameters are ['lang', 'region'] and minIndexForCompleteRootParams = 1:</span>
            <span class="s4">// - Skip i=0 (would only include 'lang', missing 'region')</span>
            <span class="s4">// - Process i=1 and higher (includes both 'lang' and 'region')</span>
            <span class="s2">if </span><span class="s1">(minIndexForCompleteRootParams &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; i &lt; minIndexForCompleteRootParams) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Initialize data structures for building this specific combination</span>
            <span class="s2">const </span><span class="s1">combination = {};</span>
            <span class="s2">const </span><span class="s1">keyParts = [];</span>
            <span class="s2">let </span><span class="s1">hasAllRootParams = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s4">// Build the sub-combination with parameters from index 0 to i (inclusive).</span>
            <span class="s4">// This creates a prefix of the full parameter set, building up combinations incrementally.</span>
            <span class="s4">//</span>
            <span class="s4">// For example, if routeParamKeys = ['lang', 'region', 'slug'] and i = 1:</span>
            <span class="s4">// - j=0: Add 'lang' parameter</span>
            <span class="s4">// - j=1: Add 'region' parameter</span>
            <span class="s4">// Result: { lang: 'en', region: 'US' }</span>
            <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s3">0</span><span class="s1">; j &lt;= i; j++){</span>
                <span class="s2">const </span><span class="s1">routeKey = routeParamKeys[j];</span>
                <span class="s4">// Check if the parameter exists in the original params object and has a defined value.</span>
                <span class="s4">// This handles cases where generateStaticParams doesn't provide all possible parameters,</span>
                <span class="s4">// or where some parameters are optional/undefined.</span>
                <span class="s2">if </span><span class="s1">(!params.hasOwnProperty(routeKey) || params[routeKey] === undefined) {</span>
                    <span class="s4">// If this missing parameter is a Root Parameter, mark the combination as invalid.</span>
                    <span class="s4">// Root Parameters are required for Static Shells, so we can't generate partial combinations without them.</span>
                    <span class="s2">if </span><span class="s1">(rootParamKeys.includes(routeKey)) {</span>
                        <span class="s1">hasAllRootParams = </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">value = params[routeKey];</span>
                <span class="s1">combination[routeKey] = value;</span>
                <span class="s4">// Construct a unique key part for this parameter to enable deduplication.</span>
                <span class="s4">// We use type prefixes to prevent collisions between different value types</span>
                <span class="s4">// that might have the same string representation.</span>
                <span class="s4">//</span>
                <span class="s4">// Examples:</span>
                <span class="s4">// - Array ['foo', 'bar'] becomes &quot;A:foo,bar&quot;</span>
                <span class="s4">// - String &quot;foo,bar&quot; becomes &quot;S:foo,bar&quot;</span>
                <span class="s4">// - This prevents collisions between ['foo', 'bar'] and &quot;foo,bar&quot;</span>
                <span class="s2">let </span><span class="s1">valuePart;</span>
                <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                    <span class="s1">valuePart = </span><span class="s0">`A:</span><span class="s1">${value.join(</span><span class="s0">','</span><span class="s1">)}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">valuePart = </span><span class="s0">`S:</span><span class="s1">${value}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">keyParts.push(</span><span class="s0">`</span><span class="s1">${routeKey}</span><span class="s0">:</span><span class="s1">${valuePart}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">// Build the final unique key by joining all parameter parts.</span>
            <span class="s4">// This key is used for deduplication in the combinations Map.</span>
            <span class="s4">// Format: &quot;lang:S:en|region:S:US|slug:A:home,about&quot;</span>
            <span class="s2">const </span><span class="s1">currentKey = keyParts.join(</span><span class="s0">'|'</span><span class="s1">);</span>
            <span class="s4">// Only add the combination if it meets our criteria:</span>
            <span class="s4">// 1. hasAllRootParams: Contains all required Root Parameters</span>
            <span class="s4">// 2. !combinations.has(currentKey): Is not a duplicate of an existing combination</span>
            <span class="s4">//</span>
            <span class="s4">// This ensures we only generate valid, unique parameter combinations for Static Shells.</span>
            <span class="s2">if </span><span class="s1">(hasAllRootParams &amp;&amp; !combinations.has(currentKey)) {</span>
                <span class="s1">combinations.set(currentKey, combination);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// Convert the Map's values back into an array and return the final result.</span>
    <span class="s4">// The Map ensures all combinations are unique, and we return only the</span>
    <span class="s4">// parameter objects themselves, discarding the internal deduplication keys.</span>
    <span class="s2">return </span><span class="s1">Array.from(combinations.values());</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">calculateFallbackMode(dynamicParams, fallbackRootParams, baseFallbackMode) {</span>
    <span class="s2">return </span><span class="s1">dynamicParams ? </span><span class="s4">// perform a blocking static render.</span>
    <span class="s1">fallbackRootParams.length &gt; </span><span class="s3">0 </span><span class="s1">? _fallback.FallbackMode.BLOCKING_STATIC_RENDER : baseFallbackMode ?? _fallback.FallbackMode.NOT_FOUND : _fallback.FallbackMode.NOT_FOUND;</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Validates the parameters to ensure they're accessible and have the correct</span>
 <span class="s4">* types.</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">page - The page to validate.</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">regex - The route regex.</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">isRoutePPREnabled - Whether the route has partial prerendering enabled.</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">routeParamKeys - The keys of the parameters.</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">rootParamKeys - The keys of the root params.</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">routeParams - The list of parameters to validate.</span>
 <span class="s4">* </span><span class="s5">@returns </span><span class="s4">The list of validated parameters.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">validateParams(page, regex, isRoutePPREnabled, routeParamKeys, rootParamKeys, routeParams) {</span>
    <span class="s2">const </span><span class="s1">valid = [];</span>
    <span class="s4">// Validate that if there are any root params, that the user has provided at</span>
    <span class="s4">// least one value for them only if we're using partial prerendering.</span>
    <span class="s2">if </span><span class="s1">(isRoutePPREnabled &amp;&amp; rootParamKeys.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(routeParams.length === </span><span class="s3">0 </span><span class="s1">|| rootParamKeys.some((key)=&gt;routeParams.some((params)=&gt;!(key </span><span class="s2">in </span><span class="s1">params)))) {</span>
            <span class="s2">if </span><span class="s1">(rootParamKeys.length === </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`A required root parameter (</span><span class="s1">${rootParamKeys[</span><span class="s3">0</span><span class="s1">]}</span><span class="s0">) was not provided in generateStaticParams for </span><span class="s1">${page}</span><span class="s0">, please provide at least one value.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E622&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Required root params (</span><span class="s1">${rootParamKeys.join(</span><span class="s0">', '</span><span class="s1">)}</span><span class="s0">) were not provided in generateStaticParams for </span><span class="s1">${page}</span><span class="s0">, please provide at least one value for each.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E621&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">params of routeParams){</span>
        <span class="s2">const </span><span class="s1">item = {};</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of routeParamKeys){</span>
            <span class="s2">const </span><span class="s1">{ repeat, optional } = regex.groups[key];</span>
            <span class="s2">let </span><span class="s1">paramValue = params[key];</span>
            <span class="s2">if </span><span class="s1">(optional &amp;&amp; params.hasOwnProperty(key) &amp;&amp; (paramValue === </span><span class="s2">null </span><span class="s1">|| paramValue === undefined || paramValue === </span><span class="s2">false</span><span class="s1">)) {</span>
                <span class="s1">paramValue = [];</span>
            <span class="s1">}</span>
            <span class="s4">// A parameter is missing, so the rest of the params are not accessible.</span>
            <span class="s4">// We only support this when the route has partial prerendering enabled.</span>
            <span class="s4">// This will make it so that the remaining params are marked as missing so</span>
            <span class="s4">// we can generate a fallback route for them.</span>
            <span class="s2">if </span><span class="s1">(!paramValue &amp;&amp; isRoutePPREnabled) {</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Perform validation for the parameter based on whether it's a repeat</span>
            <span class="s4">// parameter or not.</span>
            <span class="s2">if </span><span class="s1">(repeat) {</span>
                <span class="s2">if </span><span class="s1">(!Array.isArray(paramValue)) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`A required parameter (</span><span class="s1">${key}</span><span class="s0">) was not provided as an array received </span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">paramValue} </span><span class="s0">in generateStaticParams for </span><span class="s1">${page}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E618&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">paramValue !== </span><span class="s0">'string'</span><span class="s1">) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`A required parameter (</span><span class="s1">${key}</span><span class="s0">) was not provided as a string received </span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">paramValue} </span><span class="s0">in generateStaticParams for </span><span class="s1">${page}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E617&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">item[key] = paramValue;</span>
        <span class="s1">}</span>
        <span class="s1">valid.push(item);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">valid;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">assignErrorIfEmpty(prerenderedRoutes, routeParamKeys) {</span>
    <span class="s4">// If there are no routes to process, exit early.</span>
    <span class="s2">if </span><span class="s1">(prerenderedRoutes.length === </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Initialize the root of the Trie. This node represents the starting point</span>
    <span class="s4">// before any parameters have been considered.</span>
    <span class="s2">const </span><span class="s1">root = {</span>
        <span class="s1">children: </span><span class="s2">new </span><span class="s1">Map(),</span>
        <span class="s1">routes: []</span>
    <span class="s1">};</span>
    <span class="s4">// Phase 1: Build the Trie.</span>
    <span class="s4">// Iterate over each prerendered route and insert it into the Trie.</span>
    <span class="s4">// Each route's concrete parameter values form a path in the Trie.</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">route of prerenderedRoutes){</span>
        <span class="s2">let </span><span class="s1">currentNode = root </span><span class="s4">// Start building the path from the root for each route.</span>
        <span class="s1">;</span>
        <span class="s4">// Iterate through the sorted parameter keys. The order of keys is crucial</span>
        <span class="s4">// for ensuring that routes with the same concrete parameters follow the</span>
        <span class="s4">// same path in the Trie, regardless of the original order of properties</span>
        <span class="s4">// in the `params` object.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of routeParamKeys){</span>
            <span class="s4">// Check if the current route actually has a concrete value for this parameter.</span>
            <span class="s4">// If a dynamic segment is not filled (i.e., it's a fallback), it won't have</span>
            <span class="s4">// this property, and we stop building the path for this route at this point.</span>
            <span class="s2">if </span><span class="s1">(route.params.hasOwnProperty(key)) {</span>
                <span class="s2">const </span><span class="s1">value = route.params[key];</span>
                <span class="s4">// Generate a unique key for the parameter's value. This is critical</span>
                <span class="s4">// to prevent collisions between different data types that might have</span>
                <span class="s4">// the same string representation (e.g., `['a', 'b']` vs `'a,b'`).</span>
                <span class="s4">// A type prefix (`A:` for Array, `S:` for String, `U:` for undefined)</span>
                <span class="s4">// is added to the value to prevent collisions. This ensures that</span>
                <span class="s4">// different types with the same string representation are treated as</span>
                <span class="s4">// distinct.</span>
                <span class="s2">let </span><span class="s1">valueKey;</span>
                <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                    <span class="s1">valueKey = </span><span class="s0">`A:</span><span class="s1">${value.join(</span><span class="s0">','</span><span class="s1">)}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value === undefined) {</span>
                    <span class="s1">valueKey = </span><span class="s0">`U:undefined`</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">valueKey = </span><span class="s0">`S:</span><span class="s1">${value}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// Look for a child node corresponding to this `valueKey` from the `currentNode`.</span>
                <span class="s2">let </span><span class="s1">childNode = currentNode.children.get(valueKey);</span>
                <span class="s2">if </span><span class="s1">(!childNode) {</span>
                    <span class="s4">// If the child node doesn't exist, create a new one and add it to</span>
                    <span class="s4">// the current node's children.</span>
                    <span class="s1">childNode = {</span>
                        <span class="s1">children: </span><span class="s2">new </span><span class="s1">Map(),</span>
                        <span class="s1">routes: []</span>
                    <span class="s1">};</span>
                    <span class="s1">currentNode.children.set(valueKey, childNode);</span>
                <span class="s1">}</span>
                <span class="s4">// Move deeper into the Trie to the `childNode` for the next parameter.</span>
                <span class="s1">currentNode = childNode;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// After processing all concrete parameters for the route, add the full</span>
        <span class="s4">// `PrerenderedRoute` object to the `routes` array of the `currentNode`.</span>
        <span class="s4">// This node represents the unique concrete parameter combination for this route.</span>
        <span class="s1">currentNode.routes.push(route);</span>
    <span class="s1">}</span>
    <span class="s4">// Phase 2: Traverse the Trie to assign the `throwOnEmptyStaticShell` property.</span>
    <span class="s4">// This is done using an iterative Depth-First Search (DFS) approach with an</span>
    <span class="s4">// explicit stack to avoid JavaScript's recursion depth limits (stack overflow)</span>
    <span class="s4">// for very deep routing structures.</span>
    <span class="s2">const </span><span class="s1">stack = [</span>
        <span class="s1">root</span>
    <span class="s1">] </span><span class="s4">// Initialize the stack with the root node.</span>
    <span class="s1">;</span>
    <span class="s2">while</span><span class="s1">(stack.length &gt; </span><span class="s3">0</span><span class="s1">){</span>
        <span class="s2">const </span><span class="s1">node = stack.pop()</span><span class="s4">// Pop the next node to process from the stack.</span>
        <span class="s1">;</span>
        <span class="s4">// `hasChildren` indicates if this node has any more specific concrete</span>
        <span class="s4">// parameter combinations branching off from it. If true, it means this</span>
        <span class="s4">// node represents a prefix for other, more specific routes.</span>
        <span class="s2">const </span><span class="s1">hasChildren = node.children.size &gt; </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s4">// If the current node has routes associated with it (meaning, routes whose</span>
        <span class="s4">// concrete parameters lead to this node's path in the Trie).</span>
        <span class="s2">if </span><span class="s1">(node.routes.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">// Determine the minimum number of fallback parameters among all routes</span>
            <span class="s4">// that are associated with this current Trie node. This is used to</span>
            <span class="s4">// identify if a route should not throw on empty static shell relative to another route *at the same level*</span>
            <span class="s4">// of concrete parameters, but with fewer fallback parameters.</span>
            <span class="s2">let </span><span class="s1">minFallbacks = Infinity;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">r of node.routes){</span>
                <span class="s2">var </span><span class="s1">_r_fallbackRouteParams;</span>
                <span class="s4">// `fallbackRouteParams?.length ?? 0` handles cases where `fallbackRouteParams`</span>
                <span class="s4">// might be `undefined` or `null`, treating them as 0 length.</span>
                <span class="s1">minFallbacks = Math.min(minFallbacks, ((_r_fallbackRouteParams = r.fallbackRouteParams) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _r_fallbackRouteParams.length) ?? </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">// Now, for each `PrerenderedRoute` associated with this node:</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">route of node.routes){</span>
                <span class="s4">// A route is ok not to throw on an empty static shell (and thus</span>
                <span class="s4">// `throwOnEmptyStaticShell` should be `false`) if either of the</span>
                <span class="s4">// following conditions is met:</span>
                <span class="s4">// 1. `hasChildren` is true: This node has further concrete parameter children.</span>
                <span class="s4">//    This means the current route is a parent to more specific routes (e.g.,</span>
                <span class="s4">//    `/blog/[slug]` should not throw when concrete routes like `/blog/first-post` exist).</span>
                <span class="s4">// OR</span>
                <span class="s4">// 2. `route.fallbackRouteParams.length &gt; minFallbacks`: This route has</span>
                <span class="s4">//    more fallback parameters than another route at the same Trie node.</span>
                <span class="s4">//    This implies the current route is a more general version that should not throw</span>
                <span class="s4">//    compared to a more specific route that has fewer fallback parameters</span>
                <span class="s4">//    (e.g., `/1234/[...slug]` should not throw relative to `/[id]/[...slug]`).</span>
                <span class="s2">if </span><span class="s1">(hasChildren || route.fallbackRouteParams &amp;&amp; route.fallbackRouteParams.length &gt; minFallbacks) {</span>
                    <span class="s1">route.throwOnEmptyStaticShell = </span><span class="s2">false </span><span class="s4">// Should not throw on empty static shell.</span>
                    <span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">route.throwOnEmptyStaticShell = </span><span class="s2">true </span><span class="s4">// Should throw on empty static shell.</span>
                    <span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// Add all children of the current node to the stack. This ensures that</span>
        <span class="s4">// the traversal continues to explore deeper paths in the Trie.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">child of node.children.values()){</span>
            <span class="s1">stack.push(child);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">generateRouteStaticParams(segments, store) {</span>
    <span class="s4">// Early return if no segments to process</span>
    <span class="s2">if </span><span class="s1">(segments.length === </span><span class="s3">0</span><span class="s1">) </span><span class="s2">return </span><span class="s1">[];</span>
    <span class="s2">const </span><span class="s1">queue = [</span>
        <span class="s1">{</span>
            <span class="s1">segmentIndex: </span><span class="s3">0</span><span class="s1">,</span>
            <span class="s1">params: []</span>
        <span class="s1">}</span>
    <span class="s1">];</span>
    <span class="s2">let </span><span class="s1">currentParams = [];</span>
    <span class="s2">while</span><span class="s1">(queue.length &gt; </span><span class="s3">0</span><span class="s1">){</span>
        <span class="s2">var </span><span class="s1">_current_config;</span>
        <span class="s2">const </span><span class="s1">{ segmentIndex, params } = queue.shift();</span>
        <span class="s4">// If we've processed all segments, this is our final result</span>
        <span class="s2">if </span><span class="s1">(segmentIndex &gt;= segments.length) {</span>
            <span class="s1">currentParams = params;</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">current = segments[segmentIndex];</span>
        <span class="s4">// Skip segments without generateStaticParams and continue to next</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">current.generateStaticParams !== </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">queue.push({</span>
                <span class="s1">segmentIndex: segmentIndex + </span><span class="s3">1</span><span class="s1">,</span>
                <span class="s1">params</span>
            <span class="s1">});</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// Configure fetchCache if specified</span>
        <span class="s2">if </span><span class="s1">(((_current_config = current.config) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _current_config.fetchCache) !== undefined) {</span>
            <span class="s1">store.fetchCache = current.config.fetchCache;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">nextParams = [];</span>
        <span class="s4">// If there are parent params, we need to process them.</span>
        <span class="s2">if </span><span class="s1">(params.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">// Process each parent parameter combination</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">parentParams of params){</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">current.generateStaticParams({</span>
                    <span class="s1">params: parentParams</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(result.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s4">// Merge parent params with each result item</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">item of result){</span>
                        <span class="s1">nextParams.push({</span>
                            <span class="s1">...parentParams,</span>
                            <span class="s1">...item</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// No results, just pass through parent params</span>
                    <span class="s1">nextParams.push(parentParams);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// No parent params, call generateStaticParams with empty object</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">current.generateStaticParams({</span>
                <span class="s1">params: {}</span>
            <span class="s1">});</span>
            <span class="s1">nextParams.push(...result);</span>
        <span class="s1">}</span>
        <span class="s4">// Add next segment to work queue</span>
        <span class="s1">queue.push({</span>
            <span class="s1">segmentIndex: segmentIndex + </span><span class="s3">1</span><span class="s1">,</span>
            <span class="s1">params: nextParams</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">currentParams;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">buildAppStaticPaths({ dir, page, distDir, cacheComponents, authInterrupts, segments, isrFlushToDisk, cacheHandler, cacheLifeProfiles, requestHeaders, cacheHandlers, maxMemoryCacheSize, fetchCacheKeyPrefix, nextConfigOutput, ComponentMod, isRoutePPREnabled = </span><span class="s2">false</span><span class="s1">, buildId, rootParamKeys }) {</span>
    <span class="s2">if </span><span class="s1">(segments.some((generate)=&gt;{</span>
        <span class="s2">var </span><span class="s1">_generate_config;</span>
        <span class="s2">return </span><span class="s1">((_generate_config = generate.config) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _generate_config.dynamicParams) === </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}) &amp;&amp; nextConfigOutput === </span><span class="s0">'export'</span><span class="s1">) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'&quot;dynamicParams: true&quot; cannot be used with &quot;output: export&quot;. See more info here: https://nextjs.org/docs/app/building-your-application/deploying/static-exports'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E393&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">ComponentMod.patchFetch();</span>
    <span class="s2">const </span><span class="s1">incrementalCache = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _createincrementalcache.createIncrementalCache)({</span>
        <span class="s1">dir,</span>
        <span class="s1">distDir,</span>
        <span class="s1">cacheHandler,</span>
        <span class="s1">cacheHandlers,</span>
        <span class="s1">requestHeaders,</span>
        <span class="s1">fetchCacheKeyPrefix,</span>
        <span class="s1">flushToDisk: isrFlushToDisk,</span>
        <span class="s1">cacheMaxMemorySize: maxMemoryCacheSize</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">regex = (</span><span class="s3">0</span><span class="s1">, _routeregex.getRouteRegex)(page);</span>
    <span class="s2">const </span><span class="s1">routeParamKeys = Object.keys((</span><span class="s3">0</span><span class="s1">, _routematcher.getRouteMatcher)(regex)(page) || {});</span>
    <span class="s2">const </span><span class="s1">afterRunner = </span><span class="s2">new </span><span class="s1">_runwithafter.AfterRunner();</span>
    <span class="s2">const </span><span class="s1">store = (</span><span class="s3">0</span><span class="s1">, _workstore.createWorkStore)({</span>
        <span class="s1">page,</span>
        <span class="s1">renderOpts: {</span>
            <span class="s1">incrementalCache,</span>
            <span class="s1">cacheLifeProfiles,</span>
            <span class="s1">supportsDynamicResponse: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">isRevalidate: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">experimental: {</span>
                <span class="s1">cacheComponents,</span>
                <span class="s1">authInterrupts</span>
            <span class="s1">},</span>
            <span class="s1">waitUntil: afterRunner.context.waitUntil,</span>
            <span class="s1">onClose: afterRunner.context.onClose,</span>
            <span class="s1">onAfterTaskError: afterRunner.context.onTaskError</span>
        <span class="s1">},</span>
        <span class="s1">buildId,</span>
        <span class="s1">previouslyRevalidatedTags: []</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">routeParams = </span><span class="s2">await </span><span class="s1">ComponentMod.workAsyncStorage.run(store, ()=&gt;generateRouteStaticParams(segments, store));</span>
    <span class="s2">await </span><span class="s1">afterRunner.executeAfter();</span>
    <span class="s2">let </span><span class="s1">lastDynamicSegmentHadGenerateStaticParams = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">segment of segments){</span>
        <span class="s2">var </span><span class="s1">_segment_config;</span>
        <span class="s4">// Check to see if there are any missing params for segments that have</span>
        <span class="s4">// dynamicParams set to false.</span>
        <span class="s2">if </span><span class="s1">(segment.param &amp;&amp; segment.isDynamicSegment &amp;&amp; ((_segment_config = segment.config) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _segment_config.dynamicParams) === </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">params of routeParams){</span>
                <span class="s2">if </span><span class="s1">(segment.param </span><span class="s2">in </span><span class="s1">params) </span><span class="s2">continue</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">relative = segment.filePath ? _nodepath.default.relative(dir, segment.filePath) : undefined;</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Segment &quot;</span><span class="s1">${relative}</span><span class="s0">&quot; exports &quot;dynamicParams: false&quot; but the param &quot;</span><span class="s1">${segment.param}</span><span class="s0">&quot; is missing from the generated route params.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E280&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(segment.isDynamicSegment &amp;&amp; </span><span class="s2">typeof </span><span class="s1">segment.generateStaticParams !== </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">lastDynamicSegmentHadGenerateStaticParams = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">segment.generateStaticParams === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">lastDynamicSegmentHadGenerateStaticParams = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// Determine if all the segments have had their parameters provided.</span>
    <span class="s2">const </span><span class="s1">hadAllParamsGenerated = routeParamKeys.length === </span><span class="s3">0 </span><span class="s1">|| routeParams.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; routeParams.every((params)=&gt;{</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of routeParamKeys){</span>
            <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">params) </span><span class="s2">continue</span><span class="s1">;</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s4">// TODO: dynamic params should be allowed to be granular per segment but</span>
    <span class="s4">// we need additional information stored/leveraged in the prerender</span>
    <span class="s4">// manifest to allow this behavior.</span>
    <span class="s2">const </span><span class="s1">dynamicParams = segments.every((segment)=&gt;{</span>
        <span class="s2">var </span><span class="s1">_segment_config;</span>
        <span class="s2">return </span><span class="s1">((_segment_config = segment.config) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _segment_config.dynamicParams) !== </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">supportsRoutePreGeneration = hadAllParamsGenerated || process.env.NODE_ENV === </span><span class="s0">'production'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">fallbackMode = dynamicParams ? supportsRoutePreGeneration ? isRoutePPREnabled ? _fallback.FallbackMode.PRERENDER : _fallback.FallbackMode.BLOCKING_STATIC_RENDER : undefined : _fallback.FallbackMode.NOT_FOUND;</span>
    <span class="s2">const </span><span class="s1">prerenderedRoutesByPathname = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s4">// Precompile the regex patterns for the route params.</span>
    <span class="s2">const </span><span class="s1">paramPatterns = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of routeParamKeys){</span>
        <span class="s2">const </span><span class="s1">{ repeat, optional } = regex.groups[key];</span>
        <span class="s2">let </span><span class="s1">pattern = </span><span class="s0">`[</span><span class="s1">${repeat ? </span><span class="s0">'...' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${key}</span><span class="s0">]`</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(optional) {</span>
            <span class="s1">pattern = </span><span class="s0">`[</span><span class="s1">${pattern}</span><span class="s0">]`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">paramPatterns.set(key, pattern);</span>
    <span class="s1">}</span>
    <span class="s4">// Convert rootParamKeys to Set for O(1) lookup.</span>
    <span class="s2">const </span><span class="s1">rootParamSet = </span><span class="s2">new </span><span class="s1">Set(rootParamKeys);</span>
    <span class="s2">if </span><span class="s1">(hadAllParamsGenerated || isRoutePPREnabled) {</span>
        <span class="s2">let </span><span class="s1">paramsToProcess = routeParams;</span>
        <span class="s2">if </span><span class="s1">(isRoutePPREnabled) {</span>
            <span class="s4">// Discover all unique combinations of the routeParams so we can generate</span>
            <span class="s4">// routes that won't throw on empty static shell for each of them if</span>
            <span class="s4">// they're available.</span>
            <span class="s1">paramsToProcess = generateAllParamCombinations(routeParamKeys, routeParams, rootParamKeys);</span>
            <span class="s4">// Add the base route, this is the route with all the placeholders as it's</span>
            <span class="s4">// derived from the `page` string.</span>
            <span class="s1">prerenderedRoutesByPathname.set(page, {</span>
                <span class="s1">params: {},</span>
                <span class="s1">pathname: page,</span>
                <span class="s1">encodedPathname: page,</span>
                <span class="s1">fallbackRouteParams: routeParamKeys,</span>
                <span class="s1">fallbackMode: calculateFallbackMode(dynamicParams, rootParamKeys, fallbackMode),</span>
                <span class="s1">fallbackRootParams: rootParamKeys,</span>
                <span class="s1">throwOnEmptyStaticShell: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">filterUniqueParams(routeParamKeys, validateParams(page, regex, isRoutePPREnabled, routeParamKeys, rootParamKeys, paramsToProcess)).forEach((params)=&gt;{</span>
            <span class="s2">let </span><span class="s1">pathname = page;</span>
            <span class="s2">let </span><span class="s1">encodedPathname = page;</span>
            <span class="s2">const </span><span class="s1">fallbackRouteParams = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of routeParamKeys){</span>
                <span class="s2">const </span><span class="s1">paramValue = params[key];</span>
                <span class="s2">if </span><span class="s1">(!paramValue) {</span>
                    <span class="s2">if </span><span class="s1">(isRoutePPREnabled) {</span>
                        <span class="s4">// Mark remaining params as fallback params.</span>
                        <span class="s1">fallbackRouteParams.push(key);</span>
                        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = routeParamKeys.indexOf(key) + </span><span class="s3">1</span><span class="s1">; i &lt; routeParamKeys.length; i++){</span>
                            <span class="s1">fallbackRouteParams.push(routeParamKeys[i]);</span>
                        <span class="s1">}</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// This route is not complete, and we aren't performing a partial</span>
                        <span class="s4">// prerender, so we should return, skipping this route.</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">// Use pre-compiled pattern for replacement</span>
                <span class="s2">const </span><span class="s1">pattern = paramPatterns.get(key);</span>
                <span class="s1">pathname = pathname.replace(pattern, (</span><span class="s3">0</span><span class="s1">, _utils.encodeParam)(paramValue, (value)=&gt;(</span><span class="s3">0</span><span class="s1">, _escapepathdelimiters.default)(value, </span><span class="s2">true</span><span class="s1">)));</span>
                <span class="s1">encodedPathname = encodedPathname.replace(pattern, (</span><span class="s3">0</span><span class="s1">, _utils.encodeParam)(paramValue, encodeURIComponent));</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">fallbackRootParams = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">param of fallbackRouteParams){</span>
                <span class="s2">if </span><span class="s1">(rootParamSet.has(param)) {</span>
                    <span class="s1">fallbackRootParams.push(param);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">pathname = (</span><span class="s3">0</span><span class="s1">, _utils.normalizePathname)(pathname);</span>
            <span class="s1">prerenderedRoutesByPathname.set(pathname, {</span>
                <span class="s1">params,</span>
                <span class="s1">pathname,</span>
                <span class="s1">encodedPathname: (</span><span class="s3">0</span><span class="s1">, _utils.normalizePathname)(encodedPathname),</span>
                <span class="s1">fallbackRouteParams,</span>
                <span class="s1">fallbackMode: calculateFallbackMode(dynamicParams, fallbackRootParams, fallbackMode),</span>
                <span class="s1">fallbackRootParams,</span>
                <span class="s1">throwOnEmptyStaticShell: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">prerenderedRoutes = prerenderedRoutesByPathname.size &gt; </span><span class="s3">0 </span><span class="s1">|| lastDynamicSegmentHadGenerateStaticParams ? [</span>
        <span class="s1">...prerenderedRoutesByPathname.values()</span>
    <span class="s1">] : undefined;</span>
    <span class="s4">// Now we have to set the throwOnEmptyStaticShell for each of the routes.</span>
    <span class="s2">if </span><span class="s1">(prerenderedRoutes &amp;&amp; cacheComponents) {</span>
        <span class="s1">assignErrorIfEmpty(prerenderedRoutes, routeParamKeys);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">fallbackMode,</span>
        <span class="s1">prerenderedRoutes</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=app.js.map</span></pre>
</body>
</html>