<html>
<head>
<title>lib.decorators.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lib.decorators.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/*! ***************************************************************************** 
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use 
this file except in compliance with the License. You may obtain a copy of the 
License at http://www.apache.org/licenses/LICENSE-2.0 
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED 
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions 
and limitations under the License. 
***************************************************************************** */</span>


<span class="s0">/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</span>

<span class="s0">/**</span>
 <span class="s0">* The decorator context types provided to class element decorators.</span>
 <span class="s0">*/</span>
<span class="s1">type ClassMemberDecoratorContext =</span>
    <span class="s1">| ClassMethodDecoratorContext</span>
    <span class="s1">| ClassGetterDecoratorContext</span>
    <span class="s1">| ClassSetterDecoratorContext</span>
    <span class="s1">| ClassFieldDecoratorContext</span>
    <span class="s1">| ClassAccessorDecoratorContext;</span>

<span class="s0">/**</span>
 <span class="s0">* The decorator context types provided to any decorator.</span>
 <span class="s0">*/</span>
<span class="s1">type DecoratorContext =</span>
    <span class="s1">| ClassDecoratorContext</span>
    <span class="s1">| ClassMemberDecoratorContext;</span>

<span class="s1">type DecoratorMetadataObject = Record&lt;PropertyKey, unknown&gt; &amp; object;</span>

<span class="s1">type DecoratorMetadata = </span><span class="s2">typeof </span><span class="s1">globalThis </span><span class="s2">extends </span><span class="s1">{ Symbol: { readonly metadata: symbol; }; } ? DecoratorMetadataObject : DecoratorMetadataObject | undefined;</span>

<span class="s0">/**</span>
 <span class="s0">* Context provided to a class decorator.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">Class The type of the decorated class associated with this context.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">ClassDecoratorContext&lt;</span>
    <span class="s1">Class </span><span class="s2">extends </span><span class="s1">abstract </span><span class="s2">new </span><span class="s1">(...args: any) =&gt; any = abstract </span><span class="s2">new </span><span class="s1">(...args: any) =&gt; any,</span>
<span class="s1">&gt; {</span>
    <span class="s0">/** The kind of element that was decorated. */</span>
    <span class="s1">readonly kind: </span><span class="s4">&quot;class&quot;</span><span class="s1">;</span>

    <span class="s0">/** The name of the decorated class. */</span>
    <span class="s1">readonly name: string | undefined;</span>

    <span class="s0">/**</span>
     <span class="s0">* Adds a callback to be invoked after the class definition has been finalized.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s3">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* function customElement(name: string): ClassDecoratorFunction {</span>
     <span class="s0">*   return (target, context) =&gt; {</span>
     <span class="s0">*     context.addInitializer(function () {</span>
     <span class="s0">*       customElements.define(name, this);</span>
     <span class="s0">*     });</span>
     <span class="s0">*   }</span>
     <span class="s0">* }</span>
     <span class="s0">*</span>
     <span class="s0">* @customElement(&quot;my-element&quot;)</span>
     <span class="s0">* class MyElement {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">addInitializer(initializer: (</span><span class="s2">this</span><span class="s1">: Class) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

    <span class="s1">readonly metadata: DecoratorMetadata;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Context provided to a class method decorator.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">This The type on which the class element will be defined. For a static class element, this will be</span>
 <span class="s0">* the type of the constructor. For a non-static class element, this will be the type of the instance.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">Value The type of the decorated class method.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">ClassMethodDecoratorContext&lt;</span>
    <span class="s1">This = unknown,</span>
    <span class="s1">Value </span><span class="s2">extends </span><span class="s1">(</span><span class="s2">this</span><span class="s1">: This, ...args: any) =&gt; any = (</span><span class="s2">this</span><span class="s1">: This, ...args: any) =&gt; any,</span>
<span class="s1">&gt; {</span>
    <span class="s0">/** The kind of class element that was decorated. */</span>
    <span class="s1">readonly kind: </span><span class="s4">&quot;method&quot;</span><span class="s1">;</span>

    <span class="s0">/** The name of the decorated class element. */</span>
    <span class="s1">readonly name: string | symbol;</span>

    <span class="s0">/** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */</span>
    <span class="s1">readonly </span><span class="s2">static</span><span class="s1">: boolean;</span>

    <span class="s0">/** A value indicating whether the class element has a private name. */</span>
    <span class="s1">readonly </span><span class="s2">private</span><span class="s1">: boolean;</span>

    <span class="s0">/** An object that can be used to access the current value of the class element at runtime. */</span>
    <span class="s1">readonly access: {</span>
        <span class="s0">/**</span>
         <span class="s0">* Determines whether an object has a property with the same name as the decorated element.</span>
         <span class="s0">*/</span>
        <span class="s1">has(object: This): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the current value of the method from the provided object.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s3">@example</span>
         <span class="s0">* let fn = context.access.get(instance);</span>
         <span class="s0">*/</span>
        <span class="s1">get(object: This): Value;</span>
    <span class="s1">};</span>

    <span class="s0">/**</span>
     <span class="s0">* Adds a callback to be invoked either after static methods are defined but before</span>
     <span class="s0">* static initializers are run (when decorating a `static` element), or before instance</span>
     <span class="s0">* initializers are run (when decorating a non-`static` element).</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s3">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* const bound: ClassMethodDecoratorFunction = (value, context) {</span>
     <span class="s0">*   if (context.private) throw new TypeError(&quot;Not supported on private methods.&quot;);</span>
     <span class="s0">*   context.addInitializer(function () {</span>
     <span class="s0">*     this[context.name] = this[context.name].bind(this);</span>
     <span class="s0">*   });</span>
     <span class="s0">* }</span>
     <span class="s0">*</span>
     <span class="s0">* class C {</span>
     <span class="s0">*   message = &quot;Hello&quot;;</span>
     <span class="s0">*</span>
     <span class="s0">*   @bound</span>
     <span class="s0">*   m() {</span>
     <span class="s0">*     console.log(this.message);</span>
     <span class="s0">*   }</span>
     <span class="s0">* }</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">addInitializer(initializer: (</span><span class="s2">this</span><span class="s1">: This) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

    <span class="s1">readonly metadata: DecoratorMetadata;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Context provided to a class getter decorator.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">This The type on which the class element will be defined. For a static class element, this will be</span>
 <span class="s0">* the type of the constructor. For a non-static class element, this will be the type of the instance.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">Value The property type of the decorated class getter.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">ClassGetterDecoratorContext&lt;</span>
    <span class="s1">This = unknown,</span>
    <span class="s1">Value = unknown,</span>
<span class="s1">&gt; {</span>
    <span class="s0">/** The kind of class element that was decorated. */</span>
    <span class="s1">readonly kind: </span><span class="s4">&quot;getter&quot;</span><span class="s1">;</span>

    <span class="s0">/** The name of the decorated class element. */</span>
    <span class="s1">readonly name: string | symbol;</span>

    <span class="s0">/** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */</span>
    <span class="s1">readonly </span><span class="s2">static</span><span class="s1">: boolean;</span>

    <span class="s0">/** A value indicating whether the class element has a private name. */</span>
    <span class="s1">readonly </span><span class="s2">private</span><span class="s1">: boolean;</span>

    <span class="s0">/** An object that can be used to access the current value of the class element at runtime. */</span>
    <span class="s1">readonly access: {</span>
        <span class="s0">/**</span>
         <span class="s0">* Determines whether an object has a property with the same name as the decorated element.</span>
         <span class="s0">*/</span>
        <span class="s1">has(object: This): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Invokes the getter on the provided object.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s3">@example</span>
         <span class="s0">* let value = context.access.get(instance);</span>
         <span class="s0">*/</span>
        <span class="s1">get(object: This): Value;</span>
    <span class="s1">};</span>

    <span class="s0">/**</span>
     <span class="s0">* Adds a callback to be invoked either after static methods are defined but before</span>
     <span class="s0">* static initializers are run (when decorating a `static` element), or before instance</span>
     <span class="s0">* initializers are run (when decorating a non-`static` element).</span>
     <span class="s0">*/</span>
    <span class="s1">addInitializer(initializer: (</span><span class="s2">this</span><span class="s1">: This) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

    <span class="s1">readonly metadata: DecoratorMetadata;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Context provided to a class setter decorator.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">This The type on which the class element will be defined. For a static class element, this will be</span>
 <span class="s0">* the type of the constructor. For a non-static class element, this will be the type of the instance.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">Value The type of the decorated class setter.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">ClassSetterDecoratorContext&lt;</span>
    <span class="s1">This = unknown,</span>
    <span class="s1">Value = unknown,</span>
<span class="s1">&gt; {</span>
    <span class="s0">/** The kind of class element that was decorated. */</span>
    <span class="s1">readonly kind: </span><span class="s4">&quot;setter&quot;</span><span class="s1">;</span>

    <span class="s0">/** The name of the decorated class element. */</span>
    <span class="s1">readonly name: string | symbol;</span>

    <span class="s0">/** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */</span>
    <span class="s1">readonly </span><span class="s2">static</span><span class="s1">: boolean;</span>

    <span class="s0">/** A value indicating whether the class element has a private name. */</span>
    <span class="s1">readonly </span><span class="s2">private</span><span class="s1">: boolean;</span>

    <span class="s0">/** An object that can be used to access the current value of the class element at runtime. */</span>
    <span class="s1">readonly access: {</span>
        <span class="s0">/**</span>
         <span class="s0">* Determines whether an object has a property with the same name as the decorated element.</span>
         <span class="s0">*/</span>
        <span class="s1">has(object: This): boolean;</span>
        <span class="s0">/**</span>
         <span class="s0">* Invokes the setter on the provided object.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s3">@example</span>
         <span class="s0">* context.access.set(instance, value);</span>
         <span class="s0">*/</span>
        <span class="s1">set(object: This, value: Value): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s0">/**</span>
     <span class="s0">* Adds a callback to be invoked either after static methods are defined but before</span>
     <span class="s0">* static initializers are run (when decorating a `static` element), or before instance</span>
     <span class="s0">* initializers are run (when decorating a non-`static` element).</span>
     <span class="s0">*/</span>
    <span class="s1">addInitializer(initializer: (</span><span class="s2">this</span><span class="s1">: This) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

    <span class="s1">readonly metadata: DecoratorMetadata;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Context provided to a class `accessor` field decorator.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">This The type on which the class element will be defined. For a static class element, this will be</span>
 <span class="s0">* the type of the constructor. For a non-static class element, this will be the type of the instance.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">Value The type of decorated class field.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">ClassAccessorDecoratorContext&lt;</span>
    <span class="s1">This = unknown,</span>
    <span class="s1">Value = unknown,</span>
<span class="s1">&gt; {</span>
    <span class="s0">/** The kind of class element that was decorated. */</span>
    <span class="s1">readonly kind: </span><span class="s4">&quot;accessor&quot;</span><span class="s1">;</span>

    <span class="s0">/** The name of the decorated class element. */</span>
    <span class="s1">readonly name: string | symbol;</span>

    <span class="s0">/** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */</span>
    <span class="s1">readonly </span><span class="s2">static</span><span class="s1">: boolean;</span>

    <span class="s0">/** A value indicating whether the class element has a private name. */</span>
    <span class="s1">readonly </span><span class="s2">private</span><span class="s1">: boolean;</span>

    <span class="s0">/** An object that can be used to access the current value of the class element at runtime. */</span>
    <span class="s1">readonly access: {</span>
        <span class="s0">/**</span>
         <span class="s0">* Determines whether an object has a property with the same name as the decorated element.</span>
         <span class="s0">*/</span>
        <span class="s1">has(object: This): boolean;</span>

        <span class="s0">/**</span>
         <span class="s0">* Invokes the getter on the provided object.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s3">@example</span>
         <span class="s0">* let value = context.access.get(instance);</span>
         <span class="s0">*/</span>
        <span class="s1">get(object: This): Value;</span>

        <span class="s0">/**</span>
         <span class="s0">* Invokes the setter on the provided object.</span>
         <span class="s0">*</span>
         <span class="s0">* </span><span class="s3">@example</span>
         <span class="s0">* context.access.set(instance, value);</span>
         <span class="s0">*/</span>
        <span class="s1">set(object: This, value: Value): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s0">/**</span>
     <span class="s0">* Adds a callback to be invoked immediately after the auto `accessor` being</span>
     <span class="s0">* decorated is initialized (regardless if the `accessor` is `static` or not).</span>
     <span class="s0">*/</span>
    <span class="s1">addInitializer(initializer: (</span><span class="s2">this</span><span class="s1">: This) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

    <span class="s1">readonly metadata: DecoratorMetadata;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Describes the target provided to class `accessor` field decorators.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">This The `this` type to which the target applies.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">Value The property type for the class `accessor` field.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">ClassAccessorDecoratorTarget&lt;This, Value&gt; {</span>
    <span class="s0">/**</span>
     <span class="s0">* Invokes the getter that was defined prior to decorator application.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s3">@example</span>
     <span class="s0">* let value = target.get.call(instance);</span>
     <span class="s0">*/</span>
    <span class="s1">get(</span><span class="s2">this</span><span class="s1">: This): Value;</span>

    <span class="s0">/**</span>
     <span class="s0">* Invokes the setter that was defined prior to decorator application.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s3">@example</span>
     <span class="s0">* target.set.call(instance, value);</span>
     <span class="s0">*/</span>
    <span class="s1">set(</span><span class="s2">this</span><span class="s1">: This, value: Value): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Describes the allowed return value from a class `accessor` field decorator.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">This The `this` type to which the target applies.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">Value The property type for the class `accessor` field.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">ClassAccessorDecoratorResult&lt;This, Value&gt; {</span>
    <span class="s0">/**</span>
     <span class="s0">* An optional replacement getter function. If not provided, the existing getter function is used instead.</span>
     <span class="s0">*/</span>
    <span class="s1">get?(</span><span class="s2">this</span><span class="s1">: This): Value;</span>

    <span class="s0">/**</span>
     <span class="s0">* An optional replacement setter function. If not provided, the existing setter function is used instead.</span>
     <span class="s0">*/</span>
    <span class="s1">set?(</span><span class="s2">this</span><span class="s1">: This, value: Value): </span><span class="s2">void</span><span class="s1">;</span>

    <span class="s0">/**</span>
     <span class="s0">* An optional initializer mutator that is invoked when the underlying field initializer is evaluated.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">value The incoming initializer value.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">The replacement initializer value.</span>
     <span class="s0">*/</span>
    <span class="s1">init?(</span><span class="s2">this</span><span class="s1">: This, value: Value): Value;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Context provided to a class field decorator.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">This The type on which the class element will be defined. For a static class element, this will be</span>
 <span class="s0">* the type of the constructor. For a non-static class element, this will be the type of the instance.</span>
 <span class="s0">* </span><span class="s3">@template </span><span class="s0">Value The type of the decorated class field.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">ClassFieldDecoratorContext&lt;</span>
    <span class="s1">This = unknown,</span>
    <span class="s1">Value = unknown,</span>
<span class="s1">&gt; {</span>
    <span class="s0">/** The kind of class element that was decorated. */</span>
    <span class="s1">readonly kind: </span><span class="s4">&quot;field&quot;</span><span class="s1">;</span>

    <span class="s0">/** The name of the decorated class element. */</span>
    <span class="s1">readonly name: string | symbol;</span>

    <span class="s0">/** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */</span>
    <span class="s1">readonly </span><span class="s2">static</span><span class="s1">: boolean;</span>

    <span class="s0">/** A value indicating whether the class element has a private name. */</span>
    <span class="s1">readonly </span><span class="s2">private</span><span class="s1">: boolean;</span>

    <span class="s0">/** An object that can be used to access the current value of the class element at runtime. */</span>
    <span class="s1">readonly access: {</span>
        <span class="s0">/**</span>
         <span class="s0">* Determines whether an object has a property with the same name as the decorated element.</span>
         <span class="s0">*/</span>
        <span class="s1">has(object: This): boolean;</span>

        <span class="s0">/**</span>
         <span class="s0">* Gets the value of the field on the provided object.</span>
         <span class="s0">*/</span>
        <span class="s1">get(object: This): Value;</span>

        <span class="s0">/**</span>
         <span class="s0">* Sets the value of the field on the provided object.</span>
         <span class="s0">*/</span>
        <span class="s1">set(object: This, value: Value): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s0">/**</span>
     <span class="s0">* Adds a callback to be invoked immediately after the field being decorated</span>
     <span class="s0">* is initialized (regardless if the field is `static` or not).</span>
     <span class="s0">*/</span>
    <span class="s1">addInitializer(initializer: (</span><span class="s2">this</span><span class="s1">: This) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

    <span class="s1">readonly metadata: DecoratorMetadata;</span>
<span class="s1">}</span>
</pre>
</body>
</html>