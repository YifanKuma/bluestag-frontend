<html>
<head>
<title>render-result.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
render-result.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { OutgoingHttpHeaders, ServerResponse } from </span><span class="s2">'http'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { CacheControl } from </span><span class="s2">'./lib/cache-control'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FetchMetrics } from </span><span class="s2">'./base-http'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { RenderResumeDataCache } from </span><span class="s2">'./resume-data-cache/resume-data-cache'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { HTML_CONTENT_TYPE_HEADER, JSON_CONTENT_TYPE_HEADER, TEXT_PLAIN_CONTENT_TYPE_HEADER } from </span><span class="s2">'../lib/constants'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { RSC_CONTENT_TYPE_HEADER } from </span><span class="s2">'../client/components/app-router-headers'</span><span class="s1">;</span>
<span class="s1">type ContentTypeOption = </span><span class="s0">typeof </span><span class="s1">RSC_CONTENT_TYPE_HEADER | </span><span class="s0">typeof </span><span class="s1">HTML_CONTENT_TYPE_HEADER | </span><span class="s0">typeof </span><span class="s1">JSON_CONTENT_TYPE_HEADER | </span><span class="s0">typeof </span><span class="s1">TEXT_PLAIN_CONTENT_TYPE_HEADER;</span>
<span class="s0">export </span><span class="s1">type AppPageRenderResultMetadata = {</span>
    <span class="s1">flightData?: Buffer;</span>
    <span class="s1">cacheControl?: CacheControl;</span>
    <span class="s1">staticBailoutInfo?: {</span>
        <span class="s1">stack?: string;</span>
        <span class="s1">description?: string;</span>
    <span class="s1">};</span>
    <span class="s3">/**</span>
     <span class="s3">* The postponed state if the render had postponed and needs to be resumed.</span>
     <span class="s3">*/</span>
    <span class="s1">postponed?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The headers to set on the response that were added by the render.</span>
     <span class="s3">*/</span>
    <span class="s1">headers?: OutgoingHttpHeaders;</span>
    <span class="s1">statusCode?: number;</span>
    <span class="s1">fetchTags?: string;</span>
    <span class="s1">fetchMetrics?: FetchMetrics;</span>
    <span class="s1">segmentData?: Map&lt;string, Buffer&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* In development, the resume data cache is warmed up before the render. This</span>
     <span class="s3">* is attached to the metadata so that it can be used during the render. When</span>
     <span class="s3">* prerendering, the filled resume data cache is also attached to the metadata</span>
     <span class="s3">* so that it can be used when prerendering matching fallback shells.</span>
     <span class="s3">*/</span>
    <span class="s1">renderResumeDataCache?: RenderResumeDataCache;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">type PagesRenderResultMetadata = {</span>
    <span class="s1">pageData?: any;</span>
    <span class="s1">cacheControl?: CacheControl;</span>
    <span class="s1">assetQueryString?: string;</span>
    <span class="s1">isNotFound?: boolean;</span>
    <span class="s1">isRedirect?: boolean;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">type StaticRenderResultMetadata = {};</span>
<span class="s0">export </span><span class="s1">type RenderResultMetadata = AppPageRenderResultMetadata &amp; PagesRenderResultMetadata &amp; StaticRenderResultMetadata;</span>
<span class="s0">export </span><span class="s1">type RenderResultResponse = ReadableStream&lt;Uint8Array&gt;[] | ReadableStream&lt;Uint8Array&gt; | string | Buffer | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">type RenderResultOptions&lt;Metadata </span><span class="s0">extends </span><span class="s1">RenderResultMetadata = RenderResultMetadata&gt; = {</span>
    <span class="s1">contentType: ContentTypeOption | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">waitUntil?: Promise&lt;unknown&gt;;</span>
    <span class="s1">metadata: Metadata;</span>
<span class="s1">};</span>
<span class="s0">export default class </span><span class="s1">RenderResult&lt;Metadata </span><span class="s0">extends </span><span class="s1">RenderResultMetadata = RenderResultMetadata&gt; {</span>
    <span class="s3">/**</span>
     <span class="s3">* The detected content type for the response. This is used to set the</span>
     <span class="s3">* `Content-Type` header.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly contentType: ContentTypeOption | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The metadata for the response. This is used to set the revalidation times</span>
     <span class="s3">* and other metadata.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly metadata: Readonly&lt;Metadata&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* The response itself. This can be a string, a stream, or null. If it's a</span>
     <span class="s3">* string, then it's a static response. If it's a stream, then it's a</span>
     <span class="s3">* dynamic response. If it's null, then the response was not found or was</span>
     <span class="s3">* already sent.</span>
     <span class="s3">*/</span>
    <span class="s0">private </span><span class="s1">response;</span>
    <span class="s3">/**</span>
     <span class="s3">* A render result that represents an empty response. This is used to</span>
     <span class="s3">* represent a response that was not found or was already sent.</span>
     <span class="s3">*/</span>
    <span class="s0">static </span><span class="s1">readonly EMPTY: RenderResult&lt;StaticRenderResultMetadata&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* Creates a new RenderResult instance from a static response.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">value the static response value</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">contentType the content type of the response</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">a new RenderResult instance</span>
     <span class="s3">*/</span>
    <span class="s0">static </span><span class="s1">fromStatic(value: string | Buffer, contentType: ContentTypeOption): RenderResult&lt;StaticRenderResultMetadata&gt;;</span>
    <span class="s0">private </span><span class="s1">readonly waitUntil?;</span>
    <span class="s1">constructor(response: RenderResultResponse, { contentType, waitUntil, metadata }: RenderResultOptions&lt;Metadata&gt;);</span>
    <span class="s1">assignMetadata(metadata: Metadata): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns true if the response is null. It can be null if the response was</span>
     <span class="s3">* not found or was already sent.</span>
     <span class="s3">*/</span>
    <span class="s1">get isNull(): boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns false if the response is a string. It can be a string if the page</span>
     <span class="s3">* was prerendered. If it's not, then it was generated dynamically.</span>
     <span class="s3">*/</span>
    <span class="s1">get isDynamic(): boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns the response if it is a string. If the page was dynamic, this will</span>
     <span class="s3">* return a promise if the `stream` option is true, or it will throw an error.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">stream Whether or not to return a promise if the response is dynamic</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The response as a string</span>
     <span class="s3">*/</span>
    <span class="s1">toUnchunkedString(stream?: </span><span class="s0">false</span><span class="s1">): string;</span>
    <span class="s1">toUnchunkedString(stream: </span><span class="s0">true</span><span class="s1">): Promise&lt;string&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns a readable stream of the response.</span>
     <span class="s3">*/</span>
    <span class="s0">private </span><span class="s1">get readable();</span>
    <span class="s3">/**</span>
     <span class="s3">* Coerces the response to an array of streams. This will convert the response</span>
     <span class="s3">* to an array of streams if it is not already one.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An array of streams</span>
     <span class="s3">*/</span>
    <span class="s0">private </span><span class="s1">coerce;</span>
    <span class="s3">/**</span>
     <span class="s3">* Unshifts a new stream to the response. This will convert the response to an</span>
     <span class="s3">* array of streams if it is not already one and will add the new stream to</span>
     <span class="s3">* the start of the array. When this response is piped, all of the streams</span>
     <span class="s3">* will be piped one after the other.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">readable The new stream to unshift</span>
     <span class="s3">*/</span>
    <span class="s1">unshift(readable: ReadableStream&lt;Uint8Array&gt;): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Chains a new stream to the response. This will convert the response to an</span>
     <span class="s3">* array of streams if it is not already one and will add the new stream to</span>
     <span class="s3">* the end. When this response is piped, all of the streams will be piped</span>
     <span class="s3">* one after the other.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">readable The new stream to chain</span>
     <span class="s3">*/</span>
    <span class="s1">push(readable: ReadableStream&lt;Uint8Array&gt;): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Pipes the response to a writable stream. This will close/cancel the</span>
     <span class="s3">* writable stream if an error is encountered. If this doesn't throw, then</span>
     <span class="s3">* the writable stream will be closed or aborted.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">writable Writable stream to pipe the response to</span>
     <span class="s3">*/</span>
    <span class="s1">pipeTo(writable: WritableStream&lt;Uint8Array&gt;): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* Pipes the response to a node response. This will close/cancel the node</span>
     <span class="s3">* response if an error is encountered.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">res</span>
     <span class="s3">*/</span>
    <span class="s1">pipeToNodeResponse(res: ServerResponse): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">{};</span>
</pre>
</body>
</html>