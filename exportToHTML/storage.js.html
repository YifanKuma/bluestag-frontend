<html>
<head>
<title>storage.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
storage.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;Telemetry&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">Telemetry;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_picocolors = require(</span><span class="s0">&quot;../lib/picocolors&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_conf = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/conf&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_crypto = require(</span><span class="s0">&quot;crypto&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isdocker = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/is-docker&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_anonymousmeta = require(</span><span class="s0">&quot;./anonymous-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ciinfo = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../server/ci-info&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_posttelemetrypayload = require(</span><span class="s0">&quot;./post-telemetry-payload&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_projectid = require(</span><span class="s0">&quot;./project-id&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ponyfill = require(</span><span class="s0">&quot;next/dist/compiled/@edge-runtime/ponyfill&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fs = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s3">// This is the key that stores whether or not telemetry is enabled or disabled.</span>
<span class="s2">const </span><span class="s1">TELEMETRY_KEY_ENABLED = </span><span class="s0">'telemetry.enabled'</span><span class="s1">;</span>
<span class="s3">// This is the key that specifies when the user was informed about anonymous</span>
<span class="s3">// telemetry collection.</span>
<span class="s2">const </span><span class="s1">TELEMETRY_KEY_NOTIFY_DATE = </span><span class="s0">'telemetry.notifiedAt'</span><span class="s1">;</span>
<span class="s3">// This is a quasi-persistent identifier used to dedupe recurring events. It's</span>
<span class="s3">// generated from random data and completely anonymous.</span>
<span class="s2">const </span><span class="s1">TELEMETRY_KEY_ID = </span><span class="s0">`telemetry.anonymousId`</span><span class="s1">;</span>
<span class="s3">// This is the cryptographic salt that is included within every hashed value.</span>
<span class="s3">// This salt value is never sent to us, ensuring privacy and the one-way nature</span>
<span class="s3">// of the hash (prevents dictionary lookups of pre-computed hashes).</span>
<span class="s3">// See the `oneWayHash` function.</span>
<span class="s2">const </span><span class="s1">TELEMETRY_KEY_SALT = </span><span class="s0">`telemetry.salt`</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">getStorageDirectory(distDir) {</span>
    <span class="s2">const </span><span class="s1">isLikelyEphemeral = _ciinfo.isCI || (</span><span class="s4">0</span><span class="s1">, _isdocker.default)();</span>
    <span class="s2">if </span><span class="s1">(isLikelyEphemeral) {</span>
        <span class="s2">return </span><span class="s1">_path.default.join(distDir, </span><span class="s0">'cache'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">Telemetry {</span>
    <span class="s1">constructor({ distDir }){</span>
        <span class="s2">this</span><span class="s1">.notify = ()=&gt;{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isDisabled || !</span><span class="s2">this</span><span class="s1">.conf) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// The end-user has already been notified about our telemetry integration. We</span>
            <span class="s3">// don't need to constantly annoy them about it.</span>
            <span class="s3">// We will re-inform users about the telemetry if significant changes are</span>
            <span class="s3">// ever made.</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.conf.get(TELEMETRY_KEY_NOTIFY_DATE, </span><span class="s0">''</span><span class="s1">)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.conf.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now().toString());</span>
            <span class="s1">console.log(</span><span class="s0">`</span><span class="s1">${(</span><span class="s4">0</span><span class="s1">, _picocolors.magenta)((</span><span class="s4">0</span><span class="s1">, _picocolors.bold)(</span><span class="s0">'Attention'</span><span class="s1">))}</span><span class="s0">: Next.js now collects completely anonymous telemetry regarding usage.`</span><span class="s1">);</span>
            <span class="s1">console.log(</span><span class="s0">`This information is used to shape Next.js' roadmap and prioritize features.`</span><span class="s1">);</span>
            <span class="s1">console.log(</span><span class="s0">`You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`</span><span class="s1">);</span>
            <span class="s1">console.log((</span><span class="s4">0</span><span class="s1">, _picocolors.cyan)(</span><span class="s0">'https://nextjs.org/telemetry'</span><span class="s1">));</span>
            <span class="s1">console.log();</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.setEnabled = (_enabled)=&gt;{</span>
            <span class="s2">const </span><span class="s1">enabled = !!_enabled;</span>
            <span class="s2">this</span><span class="s1">.conf &amp;&amp; </span><span class="s2">this</span><span class="s1">.conf.set(TELEMETRY_KEY_ENABLED, enabled);</span>
            <span class="s2">return this</span><span class="s1">.conf &amp;&amp; </span><span class="s2">this</span><span class="s1">.conf.path;</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.oneWayHash = (payload)=&gt;{</span>
            <span class="s2">const </span><span class="s1">hash = (</span><span class="s4">0</span><span class="s1">, _crypto.createHash)(</span><span class="s0">'sha256'</span><span class="s1">);</span>
            <span class="s3">// Always prepend the payload value with salt. This ensures the hash is truly</span>
            <span class="s3">// one-way.</span>
            <span class="s1">hash.update(</span><span class="s2">this</span><span class="s1">.salt);</span>
            <span class="s3">// Update is an append operation, not a replacement. The salt from the prior</span>
            <span class="s3">// update is still present!</span>
            <span class="s1">hash.update(payload);</span>
            <span class="s2">return </span><span class="s1">hash.digest(</span><span class="s0">'hex'</span><span class="s1">);</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.record = (_events, deferred)=&gt;{</span>
            <span class="s2">const </span><span class="s1">prom = (deferred ? </span><span class="s3">// flushDetached we can skip starting the initial</span>
            <span class="s3">// submitRecord which will then be cancelled</span>
            <span class="s2">new </span><span class="s1">Promise((resolve)=&gt;resolve({</span>
                    <span class="s1">isFulfilled: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">isRejected: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">value: _events</span>
                <span class="s1">})) : </span><span class="s2">this</span><span class="s1">.submitRecord(_events)).then((value)=&gt;({</span>
                    <span class="s1">isFulfilled: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">isRejected: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">value</span>
                <span class="s1">})).catch((reason)=&gt;({</span>
                    <span class="s1">isFulfilled: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">isRejected: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">reason</span>
                <span class="s1">}))</span><span class="s3">// Acts as `Promise#finally` because `catch` transforms the error</span>
            <span class="s1">.then((res)=&gt;{</span>
                <span class="s3">// Clean up the event to prevent unbounded `Set` growth</span>
                <span class="s2">if </span><span class="s1">(!deferred) {</span>
                    <span class="s2">this</span><span class="s1">.queue.delete(prom);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">res;</span>
            <span class="s1">});</span>
            <span class="s1">prom._events = Array.isArray(_events) ? _events : [</span>
                <span class="s1">_events</span>
            <span class="s1">];</span>
            <span class="s1">prom._controller = prom._controller;</span>
            <span class="s3">// Track this `Promise` so we can flush pending events</span>
            <span class="s2">this</span><span class="s1">.queue.add(prom);</span>
            <span class="s2">return </span><span class="s1">prom;</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.flush = async ()=&gt;Promise.all(</span><span class="s2">this</span><span class="s1">.queue).catch(()=&gt;</span><span class="s2">null</span><span class="s1">);</span>
        <span class="s3">// writes current events to disk and spawns separate</span>
        <span class="s3">// detached process to submit the records without blocking</span>
        <span class="s3">// the main process from exiting</span>
        <span class="s2">this</span><span class="s1">.flushDetached = (mode, dir)=&gt;{</span>
            <span class="s2">const </span><span class="s1">allEvents = [];</span>
            <span class="s2">this</span><span class="s1">.queue.forEach((item)=&gt;{</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">var </span><span class="s1">_item__controller;</span>
                    <span class="s1">(_item__controller = item._controller) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _item__controller.abort();</span>
                    <span class="s1">allEvents.push(...item._events);</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_) {</span>
                <span class="s3">// if we fail to abort ignore this event</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s1">_fs.default.mkdirSync(</span><span class="s2">this</span><span class="s1">.distDir, {</span>
                <span class="s1">recursive: </span><span class="s2">true</span>
            <span class="s1">});</span>
            <span class="s1">_fs.default.writeFileSync(_path.default.join(</span><span class="s2">this</span><span class="s1">.distDir, </span><span class="s0">'_events.json'</span><span class="s1">), JSON.stringify(allEvents));</span>
            <span class="s3">// Note: cross-spawn is not used here as it causes</span>
            <span class="s3">// a new command window to appear when we don't want it to</span>
            <span class="s2">const </span><span class="s1">child_process = require(</span><span class="s0">'child_process'</span><span class="s1">);</span>
            <span class="s3">// we use spawnSync when debugging to ensure logs are piped</span>
            <span class="s3">// correctly to stdout/stderr</span>
            <span class="s2">const </span><span class="s1">spawn = </span><span class="s2">this</span><span class="s1">.NEXT_TELEMETRY_DEBUG ? child_process.spawnSync : child_process.spawn;</span>
            <span class="s1">spawn(process.execPath, [</span>
                <span class="s1">require.resolve(</span><span class="s0">'./detached-flush'</span><span class="s1">),</span>
                <span class="s1">mode,</span>
                <span class="s1">dir</span>
            <span class="s1">], {</span>
                <span class="s1">detached: !</span><span class="s2">this</span><span class="s1">.NEXT_TELEMETRY_DEBUG,</span>
                <span class="s1">windowsHide: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">shell: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">...</span><span class="s2">this</span><span class="s1">.NEXT_TELEMETRY_DEBUG ? {</span>
                    <span class="s1">stdio: </span><span class="s0">'inherit'</span>
                <span class="s1">} : {}</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.submitRecord = async (_events)=&gt;{</span>
            <span class="s2">let </span><span class="s1">events;</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(_events)) {</span>
                <span class="s1">events = _events;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">events = [</span>
                    <span class="s1">_events</span>
                <span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(events.length &lt; </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">Promise.resolve();</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.NEXT_TELEMETRY_DEBUG) {</span>
                <span class="s3">// Print to standard error to simplify selecting the output</span>
                <span class="s1">events.forEach(({ eventName, payload })=&gt;console.error(</span><span class="s0">`[telemetry] ` </span><span class="s1">+ JSON.stringify({</span>
                        <span class="s1">eventName,</span>
                        <span class="s1">payload</span>
                    <span class="s1">}, </span><span class="s2">null</span><span class="s1">, </span><span class="s4">2</span><span class="s1">)));</span>
                <span class="s3">// Do not send the telemetry data if debugging. Users may use this feature</span>
                <span class="s3">// to preview what data would be sent.</span>
                <span class="s2">return </span><span class="s1">Promise.resolve();</span>
            <span class="s1">}</span>
            <span class="s3">// Skip recording telemetry if the feature is disabled</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isDisabled) {</span>
                <span class="s2">return </span><span class="s1">Promise.resolve();</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">postController = </span><span class="s2">new </span><span class="s1">_ponyfill.AbortController();</span>
            <span class="s2">const </span><span class="s1">res = (</span><span class="s4">0</span><span class="s1">, _posttelemetrypayload.postNextTelemetryPayload)({</span>
                <span class="s1">context: {</span>
                    <span class="s1">anonymousId: </span><span class="s2">this</span><span class="s1">.anonymousId,</span>
                    <span class="s1">projectId: </span><span class="s2">await this</span><span class="s1">.getProjectId(),</span>
                    <span class="s1">sessionId: </span><span class="s2">this</span><span class="s1">.sessionId</span>
                <span class="s1">},</span>
                <span class="s1">meta: (</span><span class="s4">0</span><span class="s1">, _anonymousmeta.getAnonymousMeta)(),</span>
                <span class="s1">events: events.map(({ eventName, payload })=&gt;({</span>
                        <span class="s1">eventName,</span>
                        <span class="s1">fields: payload</span>
                    <span class="s1">}))</span>
            <span class="s1">}, postController.signal);</span>
            <span class="s1">res._controller = postController;</span>
            <span class="s2">return </span><span class="s1">res;</span>
        <span class="s1">};</span>
        <span class="s3">// Read in the constructor so that .env can be loaded before reading</span>
        <span class="s2">const </span><span class="s1">{ NEXT_TELEMETRY_DISABLED, NEXT_TELEMETRY_DEBUG } = process.env;</span>
        <span class="s2">this</span><span class="s1">.NEXT_TELEMETRY_DISABLED = NEXT_TELEMETRY_DISABLED;</span>
        <span class="s2">this</span><span class="s1">.NEXT_TELEMETRY_DEBUG = NEXT_TELEMETRY_DEBUG;</span>
        <span class="s2">this</span><span class="s1">.distDir = distDir;</span>
        <span class="s2">const </span><span class="s1">storageDirectory = getStorageDirectory(distDir);</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s3">// `conf` incorrectly throws a permission error during initialization</span>
            <span class="s3">// instead of waiting for first use. We need to handle it, otherwise the</span>
            <span class="s3">// process may crash.</span>
            <span class="s2">this</span><span class="s1">.conf = </span><span class="s2">new </span><span class="s1">_conf.default({</span>
                <span class="s1">projectName: </span><span class="s0">'nextjs'</span><span class="s1">,</span>
                <span class="s1">cwd: storageDirectory</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_) {</span>
            <span class="s2">this</span><span class="s1">.conf = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.sessionId = (</span><span class="s4">0</span><span class="s1">, _crypto.randomBytes)(</span><span class="s4">32</span><span class="s1">).toString(</span><span class="s0">'hex'</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.queue = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">this</span><span class="s1">.notify();</span>
    <span class="s1">}</span>
    <span class="s1">get anonymousId() {</span>
        <span class="s2">const </span><span class="s1">val = </span><span class="s2">this</span><span class="s1">.conf &amp;&amp; </span><span class="s2">this</span><span class="s1">.conf.get(TELEMETRY_KEY_ID);</span>
        <span class="s2">if </span><span class="s1">(val) {</span>
            <span class="s2">return </span><span class="s1">val;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">generated = (</span><span class="s4">0</span><span class="s1">, _crypto.randomBytes)(</span><span class="s4">32</span><span class="s1">).toString(</span><span class="s0">'hex'</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.conf &amp;&amp; </span><span class="s2">this</span><span class="s1">.conf.set(TELEMETRY_KEY_ID, generated);</span>
        <span class="s2">return </span><span class="s1">generated;</span>
    <span class="s1">}</span>
    <span class="s1">get salt() {</span>
        <span class="s2">const </span><span class="s1">val = </span><span class="s2">this</span><span class="s1">.conf &amp;&amp; </span><span class="s2">this</span><span class="s1">.conf.get(TELEMETRY_KEY_SALT);</span>
        <span class="s2">if </span><span class="s1">(val) {</span>
            <span class="s2">return </span><span class="s1">val;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">generated = (</span><span class="s4">0</span><span class="s1">, _crypto.randomBytes)(</span><span class="s4">16</span><span class="s1">).toString(</span><span class="s0">'hex'</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.conf &amp;&amp; </span><span class="s2">this</span><span class="s1">.conf.set(TELEMETRY_KEY_SALT, generated);</span>
        <span class="s2">return </span><span class="s1">generated;</span>
    <span class="s1">}</span>
    <span class="s1">get isDisabled() {</span>
        <span class="s2">if </span><span class="s1">(!!</span><span class="s2">this</span><span class="s1">.NEXT_TELEMETRY_DISABLED || !</span><span class="s2">this</span><span class="s1">.conf) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.conf.get(TELEMETRY_KEY_ENABLED, </span><span class="s2">true</span><span class="s1">) === </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">get isEnabled() {</span>
        <span class="s2">return </span><span class="s1">!</span><span class="s2">this</span><span class="s1">.NEXT_TELEMETRY_DISABLED &amp;&amp; !!</span><span class="s2">this</span><span class="s1">.conf &amp;&amp; </span><span class="s2">this</span><span class="s1">.conf.get(TELEMETRY_KEY_ENABLED, </span><span class="s2">true</span><span class="s1">) !== </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">async getProjectId() {</span>
        <span class="s2">this</span><span class="s1">.loadProjectId = </span><span class="s2">this</span><span class="s1">.loadProjectId || (</span><span class="s4">0</span><span class="s1">, _projectid.getRawProjectId)();</span>
        <span class="s2">return this</span><span class="s1">.oneWayHash(</span><span class="s2">await this</span><span class="s1">.loadProjectId);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=storage.js.map</span></pre>
</body>
</html>