<html>
<head>
<title>[turbopack]_browser_dev_hmr-client_hmr-client_ts_c8c997ce._.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
.s4 { color: #0033b3;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
[turbopack]_browser_dev_hmr-client_hmr-client_ts_c8c997ce._.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span>
  <span class="s1">&quot;version&quot;</span><span class="s0">: </span><span class="s2">3</span><span class="s0">,</span>
  <span class="s1">&quot;sources&quot;</span><span class="s0">: [],</span>
  <span class="s1">&quot;sections&quot;</span><span class="s0">: [</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/browser/dev/hmr-client/hmr-client.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../../../shared/runtime-types.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../../runtime/base/dev-globals.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../../runtime/base/dev-protocol.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../../runtime/base/dev-extensions.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">type SendMessage = (msg: any) =&gt; void</span><span class="s3">\n</span><span class="s1">export type WebSocketMessage =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'turbopack-connected'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'turbopack-message'</span><span class="s3">\n      </span><span class="s1">data: Record&lt;string, any&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ClientOptions = {</span><span class="s3">\n  </span><span class="s1">addMessageListener: (cb: (msg: WebSocketMessage) =&gt; void) =&gt; void</span><span class="s3">\n  </span><span class="s1">sendMessage: SendMessage</span><span class="s3">\n  </span><span class="s1">onUpdateError: (err: unknown) =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function connect({</span><span class="s3">\n  </span><span class="s1">addMessageListener,</span><span class="s3">\n  </span><span class="s1">sendMessage,</span><span class="s3">\n  </span><span class="s1">onUpdateError = console.error,</span><span class="s3">\n</span><span class="s1">}: ClientOptions) {</span><span class="s3">\n  </span><span class="s1">addMessageListener((msg) =&gt; {</span><span class="s3">\n    </span><span class="s1">switch (msg.type) {</span><span class="s3">\n      </span><span class="s1">case 'turbopack-connected':</span><span class="s3">\n        </span><span class="s1">handleSocketConnected(sendMessage)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">if (Array.isArray(msg.data)) {</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; msg.data.length; i++) {</span><span class="s3">\n              </span><span class="s1">handleSocketMessage(msg.data[i] as ServerMessage)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">handleSocketMessage(msg.data as ServerMessage)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">applyAggregatedUpdates()</span><span class="s3">\n        </span><span class="s1">} catch (e: unknown) {</span><span class="s3">\n          </span><span class="s1">console.warn(</span><span class="s3">\n            </span><span class="s1">'[Fast Refresh] performing full reload</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n              \&quot;</span><span class="s1">Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n              </span><span class="s1">'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n              </span><span class="s1">'Consider migrating the non-React component export to a separate file and importing it into both files.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n              </span><span class="s1">'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n              </span><span class="s1">'Fast Refresh requires at least one parent function component in your React tree.'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">onUpdateError(e)</span><span class="s3">\n          </span><span class="s1">location.reload()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const queued = globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS</span><span class="s3">\n  </span><span class="s1">if (queued != null &amp;&amp; !Array.isArray(queued)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('A separate HMR handler was already registered')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS = {</span><span class="s3">\n    </span><span class="s1">push: ([chunkPath, callback]: [ChunkListPath, UpdateCallback]) =&gt; {</span><span class="s3">\n      </span><span class="s1">subscribeToChunkUpdate(chunkPath, sendMessage, callback)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(queued)) {</span><span class="s3">\n    </span><span class="s1">for (const [chunkPath, callback] of queued) {</span><span class="s3">\n      </span><span class="s1">subscribeToChunkUpdate(chunkPath, sendMessage, callback)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type UpdateCallbackSet = {</span><span class="s3">\n  </span><span class="s1">callbacks: Set&lt;UpdateCallback&gt;</span><span class="s3">\n  </span><span class="s1">unsubscribe: () =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const updateCallbackSets: Map&lt;ResourceKey, UpdateCallbackSet&gt; = new Map()</span><span class="s3">\n\n</span><span class="s1">function sendJSON(sendMessage: SendMessage, message: ClientMessage) {</span><span class="s3">\n  </span><span class="s1">sendMessage(JSON.stringify(message))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ResourceKey = string</span><span class="s3">\n\n</span><span class="s1">function resourceKey(resource: ResourceIdentifier): ResourceKey {</span><span class="s3">\n  </span><span class="s1">return JSON.stringify({</span><span class="s3">\n    </span><span class="s1">path: resource.path,</span><span class="s3">\n    </span><span class="s1">headers: resource.headers || null,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function subscribeToUpdates(</span><span class="s3">\n  </span><span class="s1">sendMessage: SendMessage,</span><span class="s3">\n  </span><span class="s1">resource: ResourceIdentifier</span><span class="s3">\n</span><span class="s1">): () =&gt; void {</span><span class="s3">\n  </span><span class="s1">sendJSON(sendMessage, {</span><span class="s3">\n    </span><span class="s1">type: 'turbopack-subscribe',</span><span class="s3">\n    </span><span class="s1">...resource,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return () =&gt; {</span><span class="s3">\n    </span><span class="s1">sendJSON(sendMessage, {</span><span class="s3">\n      </span><span class="s1">type: 'turbopack-unsubscribe',</span><span class="s3">\n      </span><span class="s1">...resource,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleSocketConnected(sendMessage: SendMessage) {</span><span class="s3">\n  </span><span class="s1">for (const key of updateCallbackSets.keys()) {</span><span class="s3">\n    </span><span class="s1">subscribeToUpdates(sendMessage, JSON.parse(key))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// we aggregate all pending updates until the issues are resolved</span><span class="s3">\n</span><span class="s1">const chunkListsWithPendingUpdates: Map&lt;ResourceKey, PartialServerMessage&gt; =</span><span class="s3">\n  </span><span class="s1">new Map()</span><span class="s3">\n\n</span><span class="s1">function aggregateUpdates(msg: PartialServerMessage) {</span><span class="s3">\n  </span><span class="s1">const key = resourceKey(msg.resource)</span><span class="s3">\n  </span><span class="s1">let aggregated = chunkListsWithPendingUpdates.get(key)</span><span class="s3">\n\n  </span><span class="s1">if (aggregated) {</span><span class="s3">\n    </span><span class="s1">aggregated.instruction = mergeChunkListUpdates(</span><span class="s3">\n      </span><span class="s1">aggregated.instruction,</span><span class="s3">\n      </span><span class="s1">msg.instruction</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">chunkListsWithPendingUpdates.set(key, msg)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyAggregatedUpdates() {</span><span class="s3">\n  </span><span class="s1">if (chunkListsWithPendingUpdates.size === 0) return</span><span class="s3">\n  </span><span class="s1">hooks.beforeRefresh()</span><span class="s3">\n  </span><span class="s1">for (const msg of chunkListsWithPendingUpdates.values()) {</span><span class="s3">\n    </span><span class="s1">triggerUpdate(msg)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">chunkListsWithPendingUpdates.clear()</span><span class="s3">\n  </span><span class="s1">finalizeUpdate()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeChunkListUpdates(</span><span class="s3">\n  </span><span class="s1">updateA: ChunkListUpdate,</span><span class="s3">\n  </span><span class="s1">updateB: ChunkListUpdate</span><span class="s3">\n</span><span class="s1">): ChunkListUpdate {</span><span class="s3">\n  </span><span class="s1">let chunks</span><span class="s3">\n  </span><span class="s1">if (updateA.chunks != null) {</span><span class="s3">\n    </span><span class="s1">if (updateB.chunks == null) {</span><span class="s3">\n      </span><span class="s1">chunks = updateA.chunks</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">chunks = mergeChunkListChunks(updateA.chunks, updateB.chunks)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (updateB.chunks != null) {</span><span class="s3">\n    </span><span class="s1">chunks = updateB.chunks</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let merged</span><span class="s3">\n  </span><span class="s1">if (updateA.merged != null) {</span><span class="s3">\n    </span><span class="s1">if (updateB.merged == null) {</span><span class="s3">\n      </span><span class="s1">merged = updateA.merged</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Since `merged` is an array of updates, we need to merge them all into</span><span class="s3">\n      </span><span class="s1">// one, consistent update.</span><span class="s3">\n      </span><span class="s1">// Since there can only be `EcmascriptMergeUpdates` in the array, there is</span><span class="s3">\n      </span><span class="s1">// no need to key on the `type` field.</span><span class="s3">\n      </span><span class="s1">let update = updateA.merged[0]</span><span class="s3">\n      </span><span class="s1">for (let i = 1; i &lt; updateA.merged.length; i++) {</span><span class="s3">\n        </span><span class="s1">update = mergeChunkListEcmascriptMergedUpdates(</span><span class="s3">\n          </span><span class="s1">update,</span><span class="s3">\n          </span><span class="s1">updateA.merged[i]</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">for (let i = 0; i &lt; updateB.merged.length; i++) {</span><span class="s3">\n        </span><span class="s1">update = mergeChunkListEcmascriptMergedUpdates(</span><span class="s3">\n          </span><span class="s1">update,</span><span class="s3">\n          </span><span class="s1">updateB.merged[i]</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">merged = [update]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (updateB.merged != null) {</span><span class="s3">\n    </span><span class="s1">merged = updateB.merged</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: 'ChunkListUpdate',</span><span class="s3">\n    </span><span class="s1">chunks,</span><span class="s3">\n    </span><span class="s1">merged,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeChunkListChunks(</span><span class="s3">\n  </span><span class="s1">chunksA: Record&lt;ChunkPath, ChunkUpdate&gt;,</span><span class="s3">\n  </span><span class="s1">chunksB: Record&lt;ChunkPath, ChunkUpdate&gt;</span><span class="s3">\n</span><span class="s1">): Record&lt;ChunkPath, ChunkUpdate&gt; {</span><span class="s3">\n  </span><span class="s1">const chunks: Record&lt;ChunkPath, ChunkUpdate&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array&lt;</span><span class="s3">\n    </span><span class="s1">[ChunkPath, ChunkUpdate]</span><span class="s3">\n  </span><span class="s1">&gt;) {</span><span class="s3">\n    </span><span class="s1">const chunkUpdateB = chunksB[chunkPath]</span><span class="s3">\n    </span><span class="s1">if (chunkUpdateB != null) {</span><span class="s3">\n      </span><span class="s1">const mergedUpdate = mergeChunkUpdates(chunkUpdateA, chunkUpdateB)</span><span class="s3">\n      </span><span class="s1">if (mergedUpdate != null) {</span><span class="s3">\n        </span><span class="s1">chunks[chunkPath] = mergedUpdate</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">chunks[chunkPath] = chunkUpdateA</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array&lt;</span><span class="s3">\n    </span><span class="s1">[ChunkPath, ChunkUpdate]</span><span class="s3">\n  </span><span class="s1">&gt;) {</span><span class="s3">\n    </span><span class="s1">if (chunks[chunkPath] == null) {</span><span class="s3">\n      </span><span class="s1">chunks[chunkPath] = chunkUpdateB</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return chunks</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeChunkUpdates(</span><span class="s3">\n  </span><span class="s1">updateA: ChunkUpdate,</span><span class="s3">\n  </span><span class="s1">updateB: ChunkUpdate</span><span class="s3">\n</span><span class="s1">): ChunkUpdate | undefined {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(updateA.type === 'added' &amp;&amp; updateB.type === 'deleted') ||</span><span class="s3">\n    </span><span class="s1">(updateA.type === 'deleted' &amp;&amp; updateB.type === 'added')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (updateA.type === 'partial') {</span><span class="s3">\n    </span><span class="s1">invariant(updateA.instruction, 'Partial updates are unsupported')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (updateB.type === 'partial') {</span><span class="s3">\n    </span><span class="s1">invariant(updateB.instruction, 'Partial updates are unsupported')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeChunkListEcmascriptMergedUpdates(</span><span class="s3">\n  </span><span class="s1">mergedA: EcmascriptMergedUpdate,</span><span class="s3">\n  </span><span class="s1">mergedB: EcmascriptMergedUpdate</span><span class="s3">\n</span><span class="s1">): EcmascriptMergedUpdate {</span><span class="s3">\n  </span><span class="s1">const entries = mergeEcmascriptChunkEntries(mergedA.entries, mergedB.entries)</span><span class="s3">\n  </span><span class="s1">const chunks = mergeEcmascriptChunksUpdates(mergedA.chunks, mergedB.chunks)</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: 'EcmascriptMergedUpdate',</span><span class="s3">\n    </span><span class="s1">entries,</span><span class="s3">\n    </span><span class="s1">chunks,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeEcmascriptChunkEntries(</span><span class="s3">\n  </span><span class="s1">entriesA: Record&lt;ModuleId, EcmascriptModuleEntry&gt; | undefined,</span><span class="s3">\n  </span><span class="s1">entriesB: Record&lt;ModuleId, EcmascriptModuleEntry&gt; | undefined</span><span class="s3">\n</span><span class="s1">): Record&lt;ModuleId, EcmascriptModuleEntry&gt; {</span><span class="s3">\n  </span><span class="s1">return { ...entriesA, ...entriesB }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeEcmascriptChunksUpdates(</span><span class="s3">\n  </span><span class="s1">chunksA: Record&lt;ChunkPath, EcmascriptMergedChunkUpdate&gt; | undefined,</span><span class="s3">\n  </span><span class="s1">chunksB: Record&lt;ChunkPath, EcmascriptMergedChunkUpdate&gt; | undefined</span><span class="s3">\n</span><span class="s1">): Record&lt;ChunkPath, EcmascriptMergedChunkUpdate&gt; | undefined {</span><span class="s3">\n  </span><span class="s1">if (chunksA == null) {</span><span class="s3">\n    </span><span class="s1">return chunksB</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (chunksB == null) {</span><span class="s3">\n    </span><span class="s1">return chunksA</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const chunks: Record&lt;ChunkPath, EcmascriptMergedChunkUpdate&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA) as Array&lt;</span><span class="s3">\n    </span><span class="s1">[ChunkPath, EcmascriptMergedChunkUpdate]</span><span class="s3">\n  </span><span class="s1">&gt;) {</span><span class="s3">\n    </span><span class="s1">const chunkUpdateB = chunksB[chunkPath]</span><span class="s3">\n    </span><span class="s1">if (chunkUpdateB != null) {</span><span class="s3">\n      </span><span class="s1">const mergedUpdate = mergeEcmascriptChunkUpdates(</span><span class="s3">\n        </span><span class="s1">chunkUpdateA,</span><span class="s3">\n        </span><span class="s1">chunkUpdateB</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (mergedUpdate != null) {</span><span class="s3">\n        </span><span class="s1">chunks[chunkPath] = mergedUpdate</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">chunks[chunkPath] = chunkUpdateA</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB) as Array&lt;</span><span class="s3">\n    </span><span class="s1">[ChunkPath, EcmascriptMergedChunkUpdate]</span><span class="s3">\n  </span><span class="s1">&gt;) {</span><span class="s3">\n    </span><span class="s1">if (chunks[chunkPath] == null) {</span><span class="s3">\n      </span><span class="s1">chunks[chunkPath] = chunkUpdateB</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Object.keys(chunks).length === 0) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return chunks</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeEcmascriptChunkUpdates(</span><span class="s3">\n  </span><span class="s1">updateA: EcmascriptMergedChunkUpdate,</span><span class="s3">\n  </span><span class="s1">updateB: EcmascriptMergedChunkUpdate</span><span class="s3">\n</span><span class="s1">): EcmascriptMergedChunkUpdate | undefined {</span><span class="s3">\n  </span><span class="s1">if (updateA.type === 'added' &amp;&amp; updateB.type === 'deleted') {</span><span class="s3">\n    </span><span class="s1">// These two completely cancel each other out.</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (updateA.type === 'deleted' &amp;&amp; updateB.type === 'added') {</span><span class="s3">\n    </span><span class="s1">const added = []</span><span class="s3">\n    </span><span class="s1">const deleted = []</span><span class="s3">\n    </span><span class="s1">const deletedModules = new Set(updateA.modules ?? [])</span><span class="s3">\n    </span><span class="s1">const addedModules = new Set(updateB.modules ?? [])</span><span class="s3">\n\n    </span><span class="s1">for (const moduleId of addedModules) {</span><span class="s3">\n      </span><span class="s1">if (!deletedModules.has(moduleId)) {</span><span class="s3">\n        </span><span class="s1">added.push(moduleId)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const moduleId of deletedModules) {</span><span class="s3">\n      </span><span class="s1">if (!addedModules.has(moduleId)) {</span><span class="s3">\n        </span><span class="s1">deleted.push(moduleId)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (added.length === 0 &amp;&amp; deleted.length === 0) {</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">type: 'partial',</span><span class="s3">\n      </span><span class="s1">added,</span><span class="s3">\n      </span><span class="s1">deleted,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (updateA.type === 'partial' &amp;&amp; updateB.type === 'partial') {</span><span class="s3">\n    </span><span class="s1">const added = new Set([...(updateA.added ?? []), ...(updateB.added ?? [])])</span><span class="s3">\n    </span><span class="s1">const deleted = new Set([</span><span class="s3">\n      </span><span class="s1">...(updateA.deleted ?? []),</span><span class="s3">\n      </span><span class="s1">...(updateB.deleted ?? []),</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n\n    </span><span class="s1">if (updateB.added != null) {</span><span class="s3">\n      </span><span class="s1">for (const moduleId of updateB.added) {</span><span class="s3">\n        </span><span class="s1">deleted.delete(moduleId)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (updateB.deleted != null) {</span><span class="s3">\n      </span><span class="s1">for (const moduleId of updateB.deleted) {</span><span class="s3">\n        </span><span class="s1">added.delete(moduleId)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">type: 'partial',</span><span class="s3">\n      </span><span class="s1">added: [...added],</span><span class="s3">\n      </span><span class="s1">deleted: [...deleted],</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (updateA.type === 'added' &amp;&amp; updateB.type === 'partial') {</span><span class="s3">\n    </span><span class="s1">const modules = new Set([</span><span class="s3">\n      </span><span class="s1">...(updateA.modules ?? []),</span><span class="s3">\n      </span><span class="s1">...(updateB.added ?? []),</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n\n    </span><span class="s1">for (const moduleId of updateB.deleted ?? []) {</span><span class="s3">\n      </span><span class="s1">modules.delete(moduleId)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">type: 'added',</span><span class="s3">\n      </span><span class="s1">modules: [...modules],</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (updateA.type === 'partial' &amp;&amp; updateB.type === 'deleted') {</span><span class="s3">\n    </span><span class="s1">// We could eagerly return `updateB` here, but this would potentially be</span><span class="s3">\n    </span><span class="s1">// incorrect if `updateA` has added modules.</span><span class="s3">\n\n    </span><span class="s1">const modules = new Set(updateB.modules ?? [])</span><span class="s3">\n\n    </span><span class="s1">if (updateA.added != null) {</span><span class="s3">\n      </span><span class="s1">for (const moduleId of updateA.added) {</span><span class="s3">\n        </span><span class="s1">modules.delete(moduleId)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">type: 'deleted',</span><span class="s3">\n      </span><span class="s1">modules: [...modules],</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Any other update combination is invalid.</span><span class="s3">\n\n  </span><span class="s1">return undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function invariant(_: never, message: string): never {</span><span class="s3">\n  </span><span class="s1">throw new Error(`Invariant: ${message}`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const CRITICAL = ['bug', 'error', 'fatal']</span><span class="s3">\n\n</span><span class="s1">function compareByList(list: any[], a: any, b: any) {</span><span class="s3">\n  </span><span class="s1">const aI = list.indexOf(a) + 1 || list.length</span><span class="s3">\n  </span><span class="s1">const bI = list.indexOf(b) + 1 || list.length</span><span class="s3">\n  </span><span class="s1">return aI - bI</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const chunksWithIssues: Map&lt;ResourceKey, Issue[]&gt; = new Map()</span><span class="s3">\n\n</span><span class="s1">function emitIssues() {</span><span class="s3">\n  </span><span class="s1">const issues = []</span><span class="s3">\n  </span><span class="s1">const deduplicationSet = new Set()</span><span class="s3">\n\n  </span><span class="s1">for (const [_, chunkIssues] of chunksWithIssues) {</span><span class="s3">\n    </span><span class="s1">for (const chunkIssue of chunkIssues) {</span><span class="s3">\n      </span><span class="s1">if (deduplicationSet.has(chunkIssue.formatted)) continue</span><span class="s3">\n\n      </span><span class="s1">issues.push(chunkIssue)</span><span class="s3">\n      </span><span class="s1">deduplicationSet.add(chunkIssue.formatted)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sortIssues(issues)</span><span class="s3">\n\n  </span><span class="s1">hooks.issues(issues)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleIssues(msg: ServerMessage): boolean {</span><span class="s3">\n  </span><span class="s1">const key = resourceKey(msg.resource)</span><span class="s3">\n  </span><span class="s1">let hasCriticalIssues = false</span><span class="s3">\n\n  </span><span class="s1">for (const issue of msg.issues) {</span><span class="s3">\n    </span><span class="s1">if (CRITICAL.includes(issue.severity)) {</span><span class="s3">\n      </span><span class="s1">hasCriticalIssues = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (msg.issues.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">chunksWithIssues.set(key, msg.issues)</span><span class="s3">\n  </span><span class="s1">} else if (chunksWithIssues.has(key)) {</span><span class="s3">\n    </span><span class="s1">chunksWithIssues.delete(key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">emitIssues()</span><span class="s3">\n\n  </span><span class="s1">return hasCriticalIssues</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const SEVERITY_ORDER = ['bug', 'fatal', 'error', 'warning', 'info', 'log']</span><span class="s3">\n</span><span class="s1">const CATEGORY_ORDER = [</span><span class="s3">\n  </span><span class="s1">'parse',</span><span class="s3">\n  </span><span class="s1">'resolve',</span><span class="s3">\n  </span><span class="s1">'code generation',</span><span class="s3">\n  </span><span class="s1">'rendering',</span><span class="s3">\n  </span><span class="s1">'typescript',</span><span class="s3">\n  </span><span class="s1">'other',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">function sortIssues(issues: Issue[]) {</span><span class="s3">\n  </span><span class="s1">issues.sort((a, b) =&gt; {</span><span class="s3">\n    </span><span class="s1">const first = compareByList(SEVERITY_ORDER, a.severity, b.severity)</span><span class="s3">\n    </span><span class="s1">if (first !== 0) return first</span><span class="s3">\n    </span><span class="s1">return compareByList(CATEGORY_ORDER, a.category, b.category)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const hooks = {</span><span class="s3">\n  </span><span class="s1">beforeRefresh: () =&gt; {},</span><span class="s3">\n  </span><span class="s1">refresh: () =&gt; {},</span><span class="s3">\n  </span><span class="s1">buildOk: () =&gt; {},</span><span class="s3">\n  </span><span class="s1">issues: (_issues: Issue[]) =&gt; {},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function setHooks(newHooks: typeof hooks) {</span><span class="s3">\n  </span><span class="s1">Object.assign(hooks, newHooks)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleSocketMessage(msg: ServerMessage) {</span><span class="s3">\n  </span><span class="s1">sortIssues(msg.issues)</span><span class="s3">\n\n  </span><span class="s1">handleIssues(msg)</span><span class="s3">\n\n  </span><span class="s1">switch (msg.type) {</span><span class="s3">\n    </span><span class="s1">case 'issues':</span><span class="s3">\n      </span><span class="s1">// issues are already handled</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'partial':</span><span class="s3">\n      </span><span class="s1">// aggregate updates</span><span class="s3">\n      </span><span class="s1">aggregateUpdates(msg)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">// run single update</span><span class="s3">\n      </span><span class="s1">const runHooks = chunkListsWithPendingUpdates.size === 0</span><span class="s3">\n      </span><span class="s1">if (runHooks) hooks.beforeRefresh()</span><span class="s3">\n      </span><span class="s1">triggerUpdate(msg)</span><span class="s3">\n      </span><span class="s1">if (runHooks) finalizeUpdate()</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function finalizeUpdate() {</span><span class="s3">\n  </span><span class="s1">hooks.refresh()</span><span class="s3">\n  </span><span class="s1">hooks.buildOk()</span><span class="s3">\n\n  </span><span class="s1">// This is used by the Next.js integration test suite to notify it when HMR</span><span class="s3">\n  </span><span class="s1">// updates have been completed.</span><span class="s3">\n  </span><span class="s1">// TODO: Only run this in test environments (gate by `process.env.__NEXT_TEST_MODE`)</span><span class="s3">\n  </span><span class="s1">if (globalThis.__NEXT_HMR_CB) {</span><span class="s3">\n    </span><span class="s1">globalThis.__NEXT_HMR_CB()</span><span class="s3">\n    </span><span class="s1">globalThis.__NEXT_HMR_CB = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function subscribeToChunkUpdate(</span><span class="s3">\n  </span><span class="s1">chunkListPath: ChunkListPath,</span><span class="s3">\n  </span><span class="s1">sendMessage: SendMessage,</span><span class="s3">\n  </span><span class="s1">callback: UpdateCallback</span><span class="s3">\n</span><span class="s1">): () =&gt; void {</span><span class="s3">\n  </span><span class="s1">return subscribeToUpdate(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">path: chunkListPath,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">sendMessage,</span><span class="s3">\n    </span><span class="s1">callback</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function subscribeToUpdate(</span><span class="s3">\n  </span><span class="s1">resource: ResourceIdentifier,</span><span class="s3">\n  </span><span class="s1">sendMessage: SendMessage,</span><span class="s3">\n  </span><span class="s1">callback: UpdateCallback</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const key = resourceKey(resource)</span><span class="s3">\n  </span><span class="s1">let callbackSet: UpdateCallbackSet</span><span class="s3">\n  </span><span class="s1">const existingCallbackSet = updateCallbackSets.get(key)</span><span class="s3">\n  </span><span class="s1">if (!existingCallbackSet) {</span><span class="s3">\n    </span><span class="s1">callbackSet = {</span><span class="s3">\n      </span><span class="s1">callbacks: new Set([callback]),</span><span class="s3">\n      </span><span class="s1">unsubscribe: subscribeToUpdates(sendMessage, resource),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateCallbackSets.set(key, callbackSet)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">existingCallbackSet.callbacks.add(callback)</span><span class="s3">\n    </span><span class="s1">callbackSet = existingCallbackSet</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return () =&gt; {</span><span class="s3">\n    </span><span class="s1">callbackSet.callbacks.delete(callback)</span><span class="s3">\n\n    </span><span class="s1">if (callbackSet.callbacks.size === 0) {</span><span class="s3">\n      </span><span class="s1">callbackSet.unsubscribe()</span><span class="s3">\n      </span><span class="s1">updateCallbackSets.delete(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function triggerUpdate(msg: ServerMessage) {</span><span class="s3">\n  </span><span class="s1">const key = resourceKey(msg.resource)</span><span class="s3">\n  </span><span class="s1">const callbackSet = updateCallbackSets.get(key)</span><span class="s3">\n  </span><span class="s1">if (!callbackSet) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const callback of callbackSet.callbacks) {</span><span class="s3">\n    </span><span class="s1">callback(msg)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (msg.type === 'notFound') {</span><span class="s3">\n    </span><span class="s1">// This indicates that the resource which we subscribed to either does not exist or</span><span class="s3">\n    </span><span class="s1">// has been deleted. In either case, we should clear all update callbacks, so if a</span><span class="s3">\n    </span><span class="s1">// new subscription is created for the same resource, it will send a new </span><span class="s3">\&quot;</span><span class="s1">subscribe</span><span class="s3">\&quot;\n    </span><span class="s1">// message to the server.</span><span class="s3">\n    </span><span class="s1">// No need to send an </span><span class="s3">\&quot;</span><span class="s1">unsubscribe</span><span class="s3">\&quot; </span><span class="s1">message to the server, it will have already</span><span class="s3">\n    </span><span class="s1">// dropped the update stream before sending the </span><span class="s3">\&quot;</span><span class="s1">notFound</span><span class="s3">\&quot; </span><span class="s1">message.</span><span class="s3">\n    </span><span class="s1">updateCallbackSets.delete(key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}}]</span>
<span class="s0">}</span></pre>
</body>
</html>