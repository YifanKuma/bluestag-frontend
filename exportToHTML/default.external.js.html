<html>
<head>
<title>default.external.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
default.external.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* This is the default &quot;use cache&quot; handler it defaults to an in-memory store.</span>
 <span class="s0">* In-memory caches are fragile and should not use stale-while-revalidate</span>
 <span class="s0">* semantics on the caches because it's not worth warming up an entry that's</span>
 <span class="s0">* likely going to get evicted before we get to use it anyway. However, we also</span>
 <span class="s0">* don't want to reuse a stale entry for too long so stale entries should be</span>
 <span class="s0">* considered expired/missing in such cache handlers.</span>
 <span class="s0">*/ </span><span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;default&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">_default;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">_lrucache = require(</span><span class="s2">&quot;../lru-cache&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_tagsmanifestexternal = require(</span><span class="s2">&quot;../incremental-cache/tags-manifest.external&quot;</span><span class="s1">);</span>
<span class="s0">// LRU cache default to max 50 MB but in future track</span>
<span class="s3">const </span><span class="s1">memoryCache = </span><span class="s3">new </span><span class="s1">_lrucache.LRUCache(</span><span class="s4">50 </span><span class="s1">* </span><span class="s4">1024 </span><span class="s1">* </span><span class="s4">1024</span><span class="s1">, (entry)=&gt;entry.size);</span>
<span class="s3">const </span><span class="s1">pendingSets = </span><span class="s3">new </span><span class="s1">Map();</span>
<span class="s3">const </span><span class="s1">debug = process.env.NEXT_PRIVATE_DEBUG_CACHE ? console.debug.bind(console, </span><span class="s2">'DefaultCacheHandler:'</span><span class="s1">) : undefined;</span>
<span class="s3">const </span><span class="s1">DefaultCacheHandler = {</span>
    <span class="s1">async get (cacheKey) {</span>
        <span class="s3">const </span><span class="s1">pendingPromise = pendingSets.get(cacheKey);</span>
        <span class="s3">if </span><span class="s1">(pendingPromise) {</span>
            <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'get'</span><span class="s1">, cacheKey, </span><span class="s2">'pending'</span><span class="s1">);</span>
            <span class="s3">await </span><span class="s1">pendingPromise;</span>
        <span class="s1">}</span>
        <span class="s3">const </span><span class="s1">privateEntry = memoryCache.get(cacheKey);</span>
        <span class="s3">if </span><span class="s1">(!privateEntry) {</span>
            <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'get'</span><span class="s1">, cacheKey, </span><span class="s2">'not found'</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s3">const </span><span class="s1">entry = privateEntry.entry;</span>
        <span class="s3">if </span><span class="s1">(performance.timeOrigin + performance.now() &gt; entry.timestamp + entry.revalidate * </span><span class="s4">1000</span><span class="s1">) {</span>
            <span class="s0">// In-memory caches should expire after revalidate time because it is</span>
            <span class="s0">// unlikely that a new entry will be able to be used before it is dropped</span>
            <span class="s0">// from the cache.</span>
            <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'get'</span><span class="s1">, cacheKey, </span><span class="s2">'expired'</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _tagsmanifestexternal.isStale)(entry.tags, entry.timestamp)) {</span>
            <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'get'</span><span class="s1">, cacheKey, </span><span class="s2">'had stale tag'</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s3">const </span><span class="s1">[returnStream, newSaved] = entry.value.tee();</span>
        <span class="s1">entry.value = newSaved;</span>
        <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'get'</span><span class="s1">, cacheKey, </span><span class="s2">'found'</span><span class="s1">, {</span>
            <span class="s1">tags: entry.tags,</span>
            <span class="s1">timestamp: entry.timestamp,</span>
            <span class="s1">revalidate: entry.revalidate,</span>
            <span class="s1">expire: entry.expire</span>
        <span class="s1">});</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">...entry,</span>
            <span class="s1">value: returnStream</span>
        <span class="s1">};</span>
    <span class="s1">},</span>
    <span class="s1">async set (cacheKey, pendingEntry) {</span>
        <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'set'</span><span class="s1">, cacheKey, </span><span class="s2">'start'</span><span class="s1">);</span>
        <span class="s3">let </span><span class="s1">resolvePending = ()=&gt;{};</span>
        <span class="s3">const </span><span class="s1">pendingPromise = </span><span class="s3">new </span><span class="s1">Promise((resolve)=&gt;{</span>
            <span class="s1">resolvePending = resolve;</span>
        <span class="s1">});</span>
        <span class="s1">pendingSets.set(cacheKey, pendingPromise);</span>
        <span class="s3">const </span><span class="s1">entry = </span><span class="s3">await </span><span class="s1">pendingEntry;</span>
        <span class="s3">let </span><span class="s1">size = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">const </span><span class="s1">[value, clonedValue] = entry.value.tee();</span>
            <span class="s1">entry.value = value;</span>
            <span class="s3">const </span><span class="s1">reader = clonedValue.getReader();</span>
            <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">chunk; !(chunk = </span><span class="s3">await </span><span class="s1">reader.read()).done;){</span>
                <span class="s1">size += Buffer.from(chunk.value).byteLength;</span>
            <span class="s1">}</span>
            <span class="s1">memoryCache.set(cacheKey, {</span>
                <span class="s1">entry,</span>
                <span class="s1">isErrored: </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">errorRetryCount: </span><span class="s4">0</span><span class="s1">,</span>
                <span class="s1">size</span>
            <span class="s1">});</span>
            <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'set'</span><span class="s1">, cacheKey, </span><span class="s2">'done'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
            <span class="s0">// TODO: store partial buffer with error after we retry 3 times</span>
            <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'set'</span><span class="s1">, cacheKey, </span><span class="s2">'failed'</span><span class="s1">, err);</span>
        <span class="s1">} </span><span class="s3">finally</span><span class="s1">{</span>
            <span class="s1">resolvePending();</span>
            <span class="s1">pendingSets.delete(cacheKey);</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">async refreshTags () {</span>
    <span class="s0">// Nothing to do for an in-memory cache handler.</span>
    <span class="s1">},</span>
    <span class="s1">async getExpiration (...tags) {</span>
        <span class="s3">const </span><span class="s1">expiration = Math.max(...tags.map((tag)=&gt;_tagsmanifestexternal.tagsManifest.get(tag) ?? </span><span class="s4">0</span><span class="s1">));</span>
        <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'getExpiration'</span><span class="s1">, {</span>
            <span class="s1">tags,</span>
            <span class="s1">expiration</span>
        <span class="s1">});</span>
        <span class="s3">return </span><span class="s1">expiration;</span>
    <span class="s1">},</span>
    <span class="s1">async expireTags (...tags) {</span>
        <span class="s3">const </span><span class="s1">timestamp = Math.round(performance.timeOrigin + performance.now());</span>
        <span class="s1">debug == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s2">'expireTags'</span><span class="s1">, {</span>
            <span class="s1">tags,</span>
            <span class="s1">timestamp</span>
        <span class="s1">});</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">tag of tags){</span>
            <span class="s0">// TODO: update file-system-cache?</span>
            <span class="s1">_tagsmanifestexternal.tagsManifest.set(tag, timestamp);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">};</span>
<span class="s3">const </span><span class="s1">_default = DefaultCacheHandler;</span>

<span class="s0">//# sourceMappingURL=default.external.js.map</span></pre>
</body>
</html>