<html>
<head>
<title>image-optimizer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
image-optimizer.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">ImageError: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">ImageOptimizerCache: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">detectContentType: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">extractEtag: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">fetchExternalImage: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">fetchInternalImage: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getHash: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getImageEtag: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getImageSize: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getMaxAge: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getPreviouslyCachedImageOrNull: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getSharp: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">imageOptimizer: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">optimizeImage: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">sendResponse: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">ImageError: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">ImageError;</span>
    <span class="s1">},</span>
    <span class="s1">ImageOptimizerCache: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">ImageOptimizerCache;</span>
    <span class="s1">},</span>
    <span class="s1">detectContentType: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">detectContentType;</span>
    <span class="s1">},</span>
    <span class="s1">extractEtag: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">extractEtag;</span>
    <span class="s1">},</span>
    <span class="s1">fetchExternalImage: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">fetchExternalImage;</span>
    <span class="s1">},</span>
    <span class="s1">fetchInternalImage: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">fetchInternalImage;</span>
    <span class="s1">},</span>
    <span class="s1">getHash: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getHash;</span>
    <span class="s1">},</span>
    <span class="s1">getImageEtag: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getImageEtag;</span>
    <span class="s1">},</span>
    <span class="s1">getImageSize: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getImageSize;</span>
    <span class="s1">},</span>
    <span class="s1">getMaxAge: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getMaxAge;</span>
    <span class="s1">},</span>
    <span class="s1">getPreviouslyCachedImageOrNull: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getPreviouslyCachedImageOrNull;</span>
    <span class="s1">},</span>
    <span class="s1">getSharp: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getSharp;</span>
    <span class="s1">},</span>
    <span class="s1">imageOptimizer: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">imageOptimizer;</span>
    <span class="s1">},</span>
    <span class="s1">optimizeImage: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">optimizeImage;</span>
    <span class="s1">},</span>
    <span class="s1">sendResponse: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">sendResponse;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_crypto = require(</span><span class="s0">&quot;crypto&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fs = require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_accept = require(</span><span class="s0">&quot;next/dist/compiled/@hapi/accept&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_contentdisposition = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/content-disposition&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_imagesize = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/image-size&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_detector = require(</span><span class="s0">&quot;next/dist/compiled/image-detector/detector.js&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isanimated = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/is-animated&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_path = require(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_url = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;url&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_imageblursvg = require(</span><span class="s0">&quot;../shared/lib/image-blur-svg&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_matchlocalpattern = require(</span><span class="s0">&quot;../shared/lib/match-local-pattern&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_matchremotepattern = require(</span><span class="s0">&quot;../shared/lib/match-remote-pattern&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_mockrequest = require(</span><span class="s0">&quot;./lib/mock-request&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_responsecache = require(</span><span class="s0">&quot;./response-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_sendpayload = require(</span><span class="s0">&quot;./send-payload&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_servestatic = require(</span><span class="s0">&quot;./serve-static&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../build/output/log&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_iserror = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../lib/is-error&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_url1 = require(</span><span class="s0">&quot;../lib/url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_invarianterror = require(</span><span class="s0">&quot;../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">AVIF = </span><span class="s0">'image/avif'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">WEBP = </span><span class="s0">'image/webp'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">PNG = </span><span class="s0">'image/png'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">JPEG = </span><span class="s0">'image/jpeg'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">JXL = </span><span class="s0">'image/jxl'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">JP2 = </span><span class="s0">'image/jp2'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">HEIC = </span><span class="s0">'image/heic'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">GIF = </span><span class="s0">'image/gif'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">SVG = </span><span class="s0">'image/svg+xml'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">ICO = </span><span class="s0">'image/x-icon'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">ICNS = </span><span class="s0">'image/x-icns'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">TIFF = </span><span class="s0">'image/tiff'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">BMP = </span><span class="s0">'image/bmp'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">PDF = </span><span class="s0">'application/pdf'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">CACHE_VERSION = </span><span class="s3">4</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">ANIMATABLE_TYPES = [</span>
    <span class="s1">WEBP,</span>
    <span class="s1">PNG,</span>
    <span class="s1">GIF</span>
<span class="s1">];</span>
<span class="s2">const </span><span class="s1">BYPASS_TYPES = [</span>
    <span class="s1">SVG,</span>
    <span class="s1">ICO,</span>
    <span class="s1">ICNS,</span>
    <span class="s1">BMP,</span>
    <span class="s1">JXL,</span>
    <span class="s1">HEIC</span>
<span class="s1">];</span>
<span class="s2">const </span><span class="s1">BLUR_IMG_SIZE = </span><span class="s3">8 </span><span class="s4">// should match `next-image-loader`</span>
<span class="s1">;</span>
<span class="s2">const </span><span class="s1">BLUR_QUALITY = </span><span class="s3">70 </span><span class="s4">// should match `next-image-loader`</span>
<span class="s1">;</span>
<span class="s2">let </span><span class="s1">_sharp;</span>
<span class="s2">function </span><span class="s1">getSharp(concurrency) {</span>
    <span class="s2">if </span><span class="s1">(_sharp) {</span>
        <span class="s2">return </span><span class="s1">_sharp;</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">_sharp = require(</span><span class="s0">'sharp'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(_sharp &amp;&amp; _sharp.concurrency() &gt; </span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s4">// Reducing concurrency should reduce the memory usage too.</span>
            <span class="s4">// We more aggressively reduce in dev but also reduce in prod.</span>
            <span class="s4">// https://sharp.pixelplumbing.com/api-utility#concurrency</span>
            <span class="s2">const </span><span class="s1">divisor = process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">? </span><span class="s3">4 </span><span class="s1">: </span><span class="s3">2</span><span class="s1">;</span>
            <span class="s1">_sharp.concurrency(concurrency ?? Math.floor(Math.max(_sharp.concurrency() / divisor, </span><span class="s3">1</span><span class="s1">)));</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _iserror.default)(e) &amp;&amp; e.code === </span><span class="s0">'MODULE_NOT_FOUND'</span><span class="s1">) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Module `sharp` not found. Please run `npm install --cpu=wasm32 sharp` to install it.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E47&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_sharp;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSupportedMimeType(options, accept = </span><span class="s0">''</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">mimeType = (</span><span class="s3">0</span><span class="s1">, _accept.mediaType)(accept, options);</span>
    <span class="s2">return </span><span class="s1">accept.includes(mimeType) ? mimeType : </span><span class="s0">''</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getHash(items) {</span>
    <span class="s2">const </span><span class="s1">hash = (</span><span class="s3">0</span><span class="s1">, _crypto.createHash)(</span><span class="s0">'sha256'</span><span class="s1">);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">item of items){</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">item === </span><span class="s0">'number'</span><span class="s1">) hash.update(String(item));</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">hash.update(item);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// See https://en.wikipedia.org/wiki/Base64#URL_applications</span>
    <span class="s2">return </span><span class="s1">hash.digest(</span><span class="s0">'base64url'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">extractEtag(etag, imageBuffer) {</span>
    <span class="s2">if </span><span class="s1">(etag) {</span>
        <span class="s4">// upstream etag needs to be base64url encoded due to weak etag signature</span>
        <span class="s4">// as we store this in the cache-entry file name.</span>
        <span class="s2">return </span><span class="s1">Buffer.from(etag).toString(</span><span class="s0">'base64url'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">getImageEtag(imageBuffer);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getImageEtag(image) {</span>
    <span class="s2">return </span><span class="s1">getHash([</span>
        <span class="s1">image</span>
    <span class="s1">]);</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">writeToCacheDir(dir, extension, maxAge, expireAt, buffer, etag, upstreamEtag) {</span>
    <span class="s2">const </span><span class="s1">filename = (</span><span class="s3">0</span><span class="s1">, _path.join)(dir, </span><span class="s0">`</span><span class="s1">${maxAge}</span><span class="s0">.</span><span class="s1">${expireAt}</span><span class="s0">.</span><span class="s1">${etag}</span><span class="s0">.</span><span class="s1">${upstreamEtag}</span><span class="s0">.</span><span class="s1">${extension}</span><span class="s0">`</span><span class="s1">);</span>
    <span class="s2">await </span><span class="s1">_fs.promises.rm(dir, {</span>
        <span class="s1">recursive: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">force: </span><span class="s2">true</span>
    <span class="s1">}).catch(()=&gt;{});</span>
    <span class="s2">await </span><span class="s1">_fs.promises.mkdir(dir, {</span>
        <span class="s1">recursive: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s2">await </span><span class="s1">_fs.promises.writeFile(filename, buffer);</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">detectContentType(buffer, skipMetadata, concurrency) {</span>
    <span class="s2">if </span><span class="s1">(buffer.byteLength === </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0xff</span><span class="s1">,</span>
        <span class="s3">0xd8</span><span class="s1">,</span>
        <span class="s3">0xff</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">JPEG;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x89</span><span class="s1">,</span>
        <span class="s3">0x50</span><span class="s1">,</span>
        <span class="s3">0x4e</span><span class="s1">,</span>
        <span class="s3">0x47</span><span class="s1">,</span>
        <span class="s3">0x0d</span><span class="s1">,</span>
        <span class="s3">0x0a</span><span class="s1">,</span>
        <span class="s3">0x1a</span><span class="s1">,</span>
        <span class="s3">0x0a</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">PNG;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x47</span><span class="s1">,</span>
        <span class="s3">0x49</span><span class="s1">,</span>
        <span class="s3">0x46</span><span class="s1">,</span>
        <span class="s3">0x38</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">GIF;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x52</span><span class="s1">,</span>
        <span class="s3">0x49</span><span class="s1">,</span>
        <span class="s3">0x46</span><span class="s1">,</span>
        <span class="s3">0x46</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0x57</span><span class="s1">,</span>
        <span class="s3">0x45</span><span class="s1">,</span>
        <span class="s3">0x42</span><span class="s1">,</span>
        <span class="s3">0x50</span>
    <span class="s1">].every((b, i)=&gt;!b || buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">WEBP;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x3c</span><span class="s1">,</span>
        <span class="s3">0x3f</span><span class="s1">,</span>
        <span class="s3">0x78</span><span class="s1">,</span>
        <span class="s3">0x6d</span><span class="s1">,</span>
        <span class="s3">0x6c</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">SVG;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x3c</span><span class="s1">,</span>
        <span class="s3">0x73</span><span class="s1">,</span>
        <span class="s3">0x76</span><span class="s1">,</span>
        <span class="s3">0x67</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">SVG;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0x66</span><span class="s1">,</span>
        <span class="s3">0x74</span><span class="s1">,</span>
        <span class="s3">0x79</span><span class="s1">,</span>
        <span class="s3">0x70</span><span class="s1">,</span>
        <span class="s3">0x61</span><span class="s1">,</span>
        <span class="s3">0x76</span><span class="s1">,</span>
        <span class="s3">0x69</span><span class="s1">,</span>
        <span class="s3">0x66</span>
    <span class="s1">].every((b, i)=&gt;!b || buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">AVIF;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x00</span><span class="s1">,</span>
        <span class="s3">0x00</span><span class="s1">,</span>
        <span class="s3">0x01</span><span class="s1">,</span>
        <span class="s3">0x00</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">ICO;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x69</span><span class="s1">,</span>
        <span class="s3">0x63</span><span class="s1">,</span>
        <span class="s3">0x6e</span><span class="s1">,</span>
        <span class="s3">0x73</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">ICNS;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x49</span><span class="s1">,</span>
        <span class="s3">0x49</span><span class="s1">,</span>
        <span class="s3">0x2a</span><span class="s1">,</span>
        <span class="s3">0x00</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">TIFF;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x42</span><span class="s1">,</span>
        <span class="s3">0x4d</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">BMP;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0xff</span><span class="s1">,</span>
        <span class="s3">0x0a</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">JXL;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x00</span><span class="s1">,</span>
        <span class="s3">0x00</span><span class="s1">,</span>
        <span class="s3">0x00</span><span class="s1">,</span>
        <span class="s3">0x0c</span><span class="s1">,</span>
        <span class="s3">0x4a</span><span class="s1">,</span>
        <span class="s3">0x58</span><span class="s1">,</span>
        <span class="s3">0x4c</span><span class="s1">,</span>
        <span class="s3">0x20</span><span class="s1">,</span>
        <span class="s3">0x0d</span><span class="s1">,</span>
        <span class="s3">0x0a</span><span class="s1">,</span>
        <span class="s3">0x87</span><span class="s1">,</span>
        <span class="s3">0x0a</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">JXL;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0</span><span class="s1">,</span>
        <span class="s3">0x66</span><span class="s1">,</span>
        <span class="s3">0x74</span><span class="s1">,</span>
        <span class="s3">0x79</span><span class="s1">,</span>
        <span class="s3">0x70</span><span class="s1">,</span>
        <span class="s3">0x68</span><span class="s1">,</span>
        <span class="s3">0x65</span><span class="s1">,</span>
        <span class="s3">0x69</span><span class="s1">,</span>
        <span class="s3">0x63</span>
    <span class="s1">].every((b, i)=&gt;!b || buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">HEIC;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x25</span><span class="s1">,</span>
        <span class="s3">0x50</span><span class="s1">,</span>
        <span class="s3">0x44</span><span class="s1">,</span>
        <span class="s3">0x46</span><span class="s1">,</span>
        <span class="s3">0x2d</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">PDF;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s3">0x00</span><span class="s1">,</span>
        <span class="s3">0x00</span><span class="s1">,</span>
        <span class="s3">0x00</span><span class="s1">,</span>
        <span class="s3">0x0c</span><span class="s1">,</span>
        <span class="s3">0x6a</span><span class="s1">,</span>
        <span class="s3">0x50</span><span class="s1">,</span>
        <span class="s3">0x20</span><span class="s1">,</span>
        <span class="s3">0x20</span><span class="s1">,</span>
        <span class="s3">0x0d</span><span class="s1">,</span>
        <span class="s3">0x0a</span><span class="s1">,</span>
        <span class="s3">0x87</span><span class="s1">,</span>
        <span class="s3">0x0a</span>
    <span class="s1">].every((b, i)=&gt;buffer[i] === b)) {</span>
        <span class="s2">return </span><span class="s1">JP2;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">format;</span>
    <span class="s1">format = (</span><span class="s3">0</span><span class="s1">, _detector.detector)(buffer);</span>
    <span class="s2">if </span><span class="s1">(!format &amp;&amp; !skipMetadata) {</span>
        <span class="s2">const </span><span class="s1">sharp = getSharp(concurrency);</span>
        <span class="s2">const </span><span class="s1">meta = </span><span class="s2">await </span><span class="s1">sharp(buffer).metadata().catch((_)=&gt;</span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">format = meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: meta.format;</span>
    <span class="s1">}</span>
    <span class="s2">switch</span><span class="s1">(format){</span>
        <span class="s2">case </span><span class="s0">'avif'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">AVIF;</span>
        <span class="s2">case </span><span class="s0">'webp'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">WEBP;</span>
        <span class="s2">case </span><span class="s0">'png'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">PNG;</span>
        <span class="s2">case </span><span class="s0">'jpeg'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'jpg'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">JPEG;</span>
        <span class="s2">case </span><span class="s0">'gif'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">GIF;</span>
        <span class="s2">case </span><span class="s0">'svg'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">SVG;</span>
        <span class="s2">case </span><span class="s0">'jxl'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'jxl-stream'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">JXL;</span>
        <span class="s2">case </span><span class="s0">'jp2'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">JP2;</span>
        <span class="s2">case </span><span class="s0">'tiff'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'tif'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">TIFF;</span>
        <span class="s2">case </span><span class="s0">'pdf'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">PDF;</span>
        <span class="s2">case </span><span class="s0">'bmp'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">BMP;</span>
        <span class="s2">case </span><span class="s0">'ico'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">ICO;</span>
        <span class="s2">case </span><span class="s0">'icns'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">ICNS;</span>
        <span class="s2">case </span><span class="s0">'dcraw'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'dz'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'exr'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'fits'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'heif'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'input'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'magick'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'openslide'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'ppm'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'rad'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'raw'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'v'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'cur'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'dds'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'j2c'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'ktx'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'pnm'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'psd'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'tga'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s1">undefined:</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">ImageOptimizerCache {</span>
    <span class="s2">static </span><span class="s1">validateParams(req, query, nextConfig, isDev) {</span>
        <span class="s2">var </span><span class="s1">_nextConfig_images, _nextConfig_images1, _nextConfig_images2;</span>
        <span class="s2">const </span><span class="s1">imageData = nextConfig.images;</span>
        <span class="s2">const </span><span class="s1">{ deviceSizes = [], imageSizes = [], domains = [], minimumCacheTTL = </span><span class="s3">60</span><span class="s1">, formats = [</span>
            <span class="s0">'image/webp'</span>
        <span class="s1">] } = imageData;</span>
        <span class="s2">const </span><span class="s1">remotePatterns = ((_nextConfig_images = nextConfig.images) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _nextConfig_images.remotePatterns) || [];</span>
        <span class="s2">const </span><span class="s1">localPatterns = (_nextConfig_images1 = nextConfig.images) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _nextConfig_images1.localPatterns;</span>
        <span class="s2">const </span><span class="s1">qualities = (_nextConfig_images2 = nextConfig.images) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _nextConfig_images2.qualities;</span>
        <span class="s2">const </span><span class="s1">{ url, w, q } = query;</span>
        <span class="s2">let </span><span class="s1">href;</span>
        <span class="s2">if </span><span class="s1">(domains.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">_log.warnOnce(</span><span class="s0">'The &quot;images.domains&quot; configuration is deprecated. Please use &quot;images.remotePatterns&quot; configuration instead.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!url) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;url&quot; parameter is required'</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Array.isArray(url)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;url&quot; parameter cannot be an array'</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(url.length &gt; </span><span class="s3">3072</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;url&quot; parameter is too long'</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(url.startsWith(</span><span class="s0">'//'</span><span class="s1">)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;url&quot; parameter cannot be a protocol-relative URL (//)'</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">isAbsolute;</span>
        <span class="s2">if </span><span class="s1">(url.startsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
            <span class="s2">var </span><span class="s1">_parseUrl;</span>
            <span class="s1">href = url;</span>
            <span class="s1">isAbsolute = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s5">/\/_next\/image($|\/)/</span><span class="s1">.test(decodeURIComponent(((_parseUrl = (</span><span class="s3">0</span><span class="s1">, _url1.parseUrl)(url)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _parseUrl.pathname) ?? </span><span class="s0">''</span><span class="s1">))) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">errorMessage: </span><span class="s0">'&quot;url&quot; parameter cannot be recursive'</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _matchlocalpattern.hasLocalMatch)(localPatterns, url)) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">errorMessage: </span><span class="s0">'&quot;url&quot; parameter is not allowed'</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">let </span><span class="s1">hrefParsed;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">hrefParsed = </span><span class="s2">new </span><span class="s1">URL(url);</span>
                <span class="s1">href = hrefParsed.toString();</span>
                <span class="s1">isAbsolute = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_error) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">errorMessage: </span><span class="s0">'&quot;url&quot; parameter is invalid'</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(![</span>
                <span class="s0">'http:'</span><span class="s1">,</span>
                <span class="s0">'https:'</span>
            <span class="s1">].includes(hrefParsed.protocol)) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">errorMessage: </span><span class="s0">'&quot;url&quot; parameter is invalid'</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _matchremotepattern.hasRemoteMatch)(domains, remotePatterns, hrefParsed)) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">errorMessage: </span><span class="s0">'&quot;url&quot; parameter is not allowed'</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!w) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;w&quot; parameter (width) is required'</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Array.isArray(w)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;w&quot; parameter (width) cannot be an array'</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!</span><span class="s5">/^[0-9]+$/</span><span class="s1">.test(w)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;w&quot; parameter (width) must be an integer greater than 0'</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!q) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;q&quot; parameter (quality) is required'</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Array.isArray(q)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;q&quot; parameter (quality) cannot be an array'</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!</span><span class="s5">/^[0-9]+$/</span><span class="s1">.test(q)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;q&quot; parameter (quality) must be an integer between 1 and 100'</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">width = parseInt(w, </span><span class="s3">10</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(width &lt;= </span><span class="s3">0 </span><span class="s1">|| isNaN(width)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;w&quot; parameter (width) must be an integer greater than 0'</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">sizes = [</span>
            <span class="s1">...deviceSizes || [],</span>
            <span class="s1">...imageSizes || []</span>
        <span class="s1">];</span>
        <span class="s2">if </span><span class="s1">(isDev) {</span>
            <span class="s1">sizes.push(BLUR_IMG_SIZE);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">isValidSize = sizes.includes(width) || isDev &amp;&amp; width &lt;= BLUR_IMG_SIZE;</span>
        <span class="s2">if </span><span class="s1">(!isValidSize) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">`&quot;w&quot; parameter (width) of </span><span class="s1">${width} </span><span class="s0">is not allowed`</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">quality = parseInt(q, </span><span class="s3">10</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(isNaN(quality) || quality &lt; </span><span class="s3">1 </span><span class="s1">|| quality &gt; </span><span class="s3">100</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">errorMessage: </span><span class="s0">'&quot;q&quot; parameter (quality) must be an integer between 1 and 100'</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(qualities) {</span>
            <span class="s2">if </span><span class="s1">(isDev) {</span>
                <span class="s1">qualities.push(BLUR_QUALITY);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!qualities.includes(quality)) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">errorMessage: </span><span class="s0">`&quot;q&quot; parameter (quality) of </span><span class="s1">${q} </span><span class="s0">is not allowed`</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">mimeType = getSupportedMimeType(formats || [], req.headers[</span><span class="s0">'accept'</span><span class="s1">]);</span>
        <span class="s2">const </span><span class="s1">isStatic = url.startsWith(</span><span class="s0">`</span><span class="s1">${nextConfig.basePath || </span><span class="s0">''</span><span class="s1">}</span><span class="s0">/_next/static/media`</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">href,</span>
            <span class="s1">sizes,</span>
            <span class="s1">isAbsolute,</span>
            <span class="s1">isStatic,</span>
            <span class="s1">width,</span>
            <span class="s1">quality,</span>
            <span class="s1">mimeType,</span>
            <span class="s1">minimumCacheTTL</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">static </span><span class="s1">getCacheKey({ href, width, quality, mimeType }) {</span>
        <span class="s2">return </span><span class="s1">getHash([</span>
            <span class="s1">CACHE_VERSION,</span>
            <span class="s1">href,</span>
            <span class="s1">width,</span>
            <span class="s1">quality,</span>
            <span class="s1">mimeType</span>
        <span class="s1">]);</span>
    <span class="s1">}</span>
    <span class="s1">constructor({ distDir, nextConfig }){</span>
        <span class="s2">this</span><span class="s1">.cacheDir = (</span><span class="s3">0</span><span class="s1">, _path.join)(distDir, </span><span class="s0">'cache'</span><span class="s1">, </span><span class="s0">'images'</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.nextConfig = nextConfig;</span>
    <span class="s1">}</span>
    <span class="s1">async get(cacheKey) {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">cacheDir = (</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.cacheDir, cacheKey);</span>
            <span class="s2">const </span><span class="s1">files = </span><span class="s2">await </span><span class="s1">_fs.promises.readdir(cacheDir);</span>
            <span class="s2">const </span><span class="s1">now = Date.now();</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of files){</span>
                <span class="s2">const </span><span class="s1">[maxAgeSt, expireAtSt, etag, upstreamEtag, extension] = file.split(</span><span class="s0">'.'</span><span class="s1">, </span><span class="s3">5</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">buffer = </span><span class="s2">await </span><span class="s1">_fs.promises.readFile((</span><span class="s3">0</span><span class="s1">, _path.join)(cacheDir, file));</span>
                <span class="s2">const </span><span class="s1">expireAt = Number(expireAtSt);</span>
                <span class="s2">const </span><span class="s1">maxAge = Number(maxAgeSt);</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">value: {</span>
                        <span class="s1">kind: _responsecache.CachedRouteKind.IMAGE,</span>
                        <span class="s1">etag,</span>
                        <span class="s1">buffer,</span>
                        <span class="s1">extension,</span>
                        <span class="s1">upstreamEtag</span>
                    <span class="s1">},</span>
                    <span class="s1">revalidateAfter: Math.max(maxAge, </span><span class="s2">this</span><span class="s1">.nextConfig.images.minimumCacheTTL) * </span><span class="s3">1000 </span><span class="s1">+ Date.now(),</span>
                    <span class="s1">cacheControl: {</span>
                        <span class="s1">revalidate: maxAge,</span>
                        <span class="s1">expire: undefined</span>
                    <span class="s1">},</span>
                    <span class="s1">isStale: now &gt; expireAt</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_) {</span>
        <span class="s4">// failed to read from cache dir, treat as cache miss</span>
        <span class="s1">}</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">async set(cacheKey, value, { cacheControl }) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.nextConfig.experimental.isrFlushToDisk) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((value == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: value.kind) !== _responsecache.CachedRouteKind.IMAGE) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant attempted to set non-image to image-cache'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E366&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">revalidate = cacheControl == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: cacheControl.revalidate;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">revalidate !== </span><span class="s0">'number'</span><span class="s1">) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'revalidate must be a number for image-cache'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E657&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">expireAt = Math.max(revalidate, </span><span class="s2">this</span><span class="s1">.nextConfig.images.minimumCacheTTL) * </span><span class="s3">1000 </span><span class="s1">+ Date.now();</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">await </span><span class="s1">writeToCacheDir((</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.cacheDir, cacheKey), value.extension, revalidate, expireAt, value.buffer, value.etag, value.upstreamEtag);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s1">_log.error(</span><span class="s0">`Failed to write image to cache </span><span class="s1">${cacheKey}</span><span class="s0">`</span><span class="s1">, err);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">ImageError </span><span class="s2">extends </span><span class="s1">Error {</span>
    <span class="s1">constructor(statusCode, message){</span>
        <span class="s2">super</span><span class="s1">(message);</span>
        <span class="s4">// ensure an error status is used &gt; 400</span>
        <span class="s2">if </span><span class="s1">(statusCode &gt;= </span><span class="s3">400</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.statusCode = statusCode;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseCacheControl(str) {</span>
    <span class="s2">const </span><span class="s1">map = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">if </span><span class="s1">(!str) {</span>
        <span class="s2">return </span><span class="s1">map;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">directive of str.split(</span><span class="s0">','</span><span class="s1">)){</span>
        <span class="s2">let </span><span class="s1">[key, value] = directive.trim().split(</span><span class="s0">'='</span><span class="s1">, </span><span class="s3">2</span><span class="s1">);</span>
        <span class="s1">key = key.toLowerCase();</span>
        <span class="s2">if </span><span class="s1">(value) {</span>
            <span class="s1">value = value.toLowerCase();</span>
        <span class="s1">}</span>
        <span class="s1">map.set(key, value);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">map;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getMaxAge(str) {</span>
    <span class="s2">const </span><span class="s1">map = parseCacheControl(str);</span>
    <span class="s2">if </span><span class="s1">(map) {</span>
        <span class="s2">let </span><span class="s1">age = map.get(</span><span class="s0">'s-maxage'</span><span class="s1">) || map.get(</span><span class="s0">'max-age'</span><span class="s1">) || </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(age.startsWith(</span><span class="s0">'&quot;'</span><span class="s1">) &amp;&amp; age.endsWith(</span><span class="s0">'&quot;'</span><span class="s1">)) {</span>
            <span class="s1">age = age.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">n = parseInt(age, </span><span class="s3">10</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(!isNaN(n)) {</span>
            <span class="s2">return </span><span class="s1">n;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPreviouslyCachedImageOrNull(upstreamImage, previousCacheEntry) {</span>
    <span class="s2">var </span><span class="s1">_previousCacheEntry_value;</span>
    <span class="s2">if </span><span class="s1">((previousCacheEntry == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_previousCacheEntry_value = previousCacheEntry.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _previousCacheEntry_value.kind) === </span><span class="s0">'IMAGE' </span><span class="s1">&amp;&amp; </span><span class="s4">// Images that are SVGs, animated or failed the optimization previously end up using upstreamEtag as their etag as well,</span>
    <span class="s4">// in these cases we want to trigger a new &quot;optimization&quot; attempt.</span>
    <span class="s1">previousCacheEntry.value.upstreamEtag !== previousCacheEntry.value.etag &amp;&amp; </span><span class="s4">// and the upstream etag is the same as the previous cache entry's</span>
    <span class="s1">upstreamImage.etag === previousCacheEntry.value.upstreamEtag) {</span>
        <span class="s2">return </span><span class="s1">previousCacheEntry.value;</span>
    <span class="s1">}</span>
    <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">optimizeImage({ buffer, contentType, quality, width, height, concurrency, limitInputPixels, sequentialRead, timeoutInSeconds }) {</span>
    <span class="s2">const </span><span class="s1">sharp = getSharp(concurrency);</span>
    <span class="s2">const </span><span class="s1">transformer = sharp(buffer, {</span>
        <span class="s1">limitInputPixels,</span>
        <span class="s1">sequentialRead: sequentialRead ?? undefined</span>
    <span class="s1">}).timeout({</span>
        <span class="s1">seconds: timeoutInSeconds ?? </span><span class="s3">7</span>
    <span class="s1">}).rotate();</span>
    <span class="s2">if </span><span class="s1">(height) {</span>
        <span class="s1">transformer.resize(width, height);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">transformer.resize(width, undefined, {</span>
            <span class="s1">withoutEnlargement: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(contentType === AVIF) {</span>
        <span class="s1">transformer.avif({</span>
            <span class="s1">quality: Math.max(quality - </span><span class="s3">20</span><span class="s1">, </span><span class="s3">1</span><span class="s1">),</span>
            <span class="s1">effort: </span><span class="s3">3</span>
        <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(contentType === WEBP) {</span>
        <span class="s1">transformer.webp({</span>
            <span class="s1">quality</span>
        <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(contentType === PNG) {</span>
        <span class="s1">transformer.png({</span>
            <span class="s1">quality</span>
        <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(contentType === JPEG) {</span>
        <span class="s1">transformer.jpeg({</span>
            <span class="s1">quality,</span>
            <span class="s1">mozjpeg: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">optimizedBuffer = </span><span class="s2">await </span><span class="s1">transformer.toBuffer();</span>
    <span class="s2">return </span><span class="s1">optimizedBuffer;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">fetchExternalImage(href) {</span>
    <span class="s2">const </span><span class="s1">res = </span><span class="s2">await </span><span class="s1">fetch(href, {</span>
        <span class="s1">signal: AbortSignal.timeout(</span><span class="s3">7000</span><span class="s1">)</span>
    <span class="s1">}).catch((err)=&gt;err);</span>
    <span class="s2">if </span><span class="s1">(res </span><span class="s2">instanceof </span><span class="s1">Error) {</span>
        <span class="s2">const </span><span class="s1">err = res;</span>
        <span class="s2">if </span><span class="s1">(err.name === </span><span class="s0">'TimeoutError'</span><span class="s1">) {</span>
            <span class="s1">_log.error(</span><span class="s0">'upstream image response timed out for'</span><span class="s1">, href);</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">ImageError(</span><span class="s3">504</span><span class="s1">, </span><span class="s0">'&quot;url&quot; parameter is valid but upstream response timed out'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">throw </span><span class="s1">err;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!res.ok) {</span>
        <span class="s1">_log.error(</span><span class="s0">'upstream image response failed for'</span><span class="s1">, href, res.status);</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">ImageError(res.status, </span><span class="s0">'&quot;url&quot; parameter is valid but upstream response is invalid'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">buffer = Buffer.from(</span><span class="s2">await </span><span class="s1">res.arrayBuffer());</span>
    <span class="s2">const </span><span class="s1">contentType = res.headers.get(</span><span class="s0">'Content-Type'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">cacheControl = res.headers.get(</span><span class="s0">'Cache-Control'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">etag = extractEtag(res.headers.get(</span><span class="s0">'ETag'</span><span class="s1">), buffer);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">buffer,</span>
        <span class="s1">contentType,</span>
        <span class="s1">cacheControl,</span>
        <span class="s1">etag</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">fetchInternalImage(href, _req, _res, handleRequest) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">mocked = (</span><span class="s3">0</span><span class="s1">, _mockrequest.createRequestResponseMocks)({</span>
            <span class="s1">url: href,</span>
            <span class="s1">method: _req.method || </span><span class="s0">'GET'</span><span class="s1">,</span>
            <span class="s1">socket: _req.socket</span>
        <span class="s1">});</span>
        <span class="s2">await </span><span class="s1">handleRequest(mocked.req, mocked.res, _url.default.parse(href, </span><span class="s2">true</span><span class="s1">));</span>
        <span class="s2">await </span><span class="s1">mocked.res.hasStreamed;</span>
        <span class="s2">if </span><span class="s1">(!mocked.res.statusCode) {</span>
            <span class="s1">_log.error(</span><span class="s0">'image response failed for'</span><span class="s1">, href, mocked.res.statusCode);</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">ImageError(mocked.res.statusCode, </span><span class="s0">'&quot;url&quot; parameter is valid but internal response is invalid'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">buffer = Buffer.concat(mocked.res.buffers);</span>
        <span class="s2">const </span><span class="s1">contentType = mocked.res.getHeader(</span><span class="s0">'Content-Type'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">cacheControl = mocked.res.getHeader(</span><span class="s0">'Cache-Control'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">etag = extractEtag(mocked.res.getHeader(</span><span class="s0">'ETag'</span><span class="s1">), buffer);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">buffer,</span>
            <span class="s1">contentType,</span>
            <span class="s1">cacheControl,</span>
            <span class="s1">etag</span>
        <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s1">_log.error(</span><span class="s0">'upstream image response failed for'</span><span class="s1">, href, err);</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">ImageError(</span><span class="s3">500</span><span class="s1">, </span><span class="s0">'&quot;url&quot; parameter is valid but upstream response is invalid'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">imageOptimizer(imageUpstream, paramsResult, nextConfig, opts) {</span>
    <span class="s2">const </span><span class="s1">{ href, quality, width, mimeType } = paramsResult;</span>
    <span class="s2">const </span><span class="s1">{ buffer: upstreamBuffer, etag: upstreamEtag } = imageUpstream;</span>
    <span class="s2">const </span><span class="s1">maxAge = Math.max(nextConfig.images.minimumCacheTTL, getMaxAge(imageUpstream.cacheControl));</span>
    <span class="s2">const </span><span class="s1">upstreamType = </span><span class="s2">await </span><span class="s1">detectContentType(upstreamBuffer, nextConfig.experimental.imgOptSkipMetadata, nextConfig.experimental.imgOptConcurrency);</span>
    <span class="s2">if </span><span class="s1">(!upstreamType || !upstreamType.startsWith(</span><span class="s0">'image/'</span><span class="s1">) || upstreamType.includes(</span><span class="s0">','</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(!opts.silent) {</span>
            <span class="s1">_log.error(</span><span class="s0">&quot;The requested resource isn't a valid image for&quot;</span><span class="s1">, href, </span><span class="s0">'received'</span><span class="s1">, upstreamType);</span>
        <span class="s1">}</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">ImageError(</span><span class="s3">400</span><span class="s1">, </span><span class="s0">&quot;The requested resource isn't a valid image.&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(upstreamType.startsWith(</span><span class="s0">'image/svg'</span><span class="s1">) &amp;&amp; !nextConfig.images.dangerouslyAllowSVG) {</span>
        <span class="s2">if </span><span class="s1">(!opts.silent) {</span>
            <span class="s1">_log.error(</span><span class="s0">`The requested resource &quot;</span><span class="s1">${href}</span><span class="s0">&quot; has type &quot;</span><span class="s1">${upstreamType}</span><span class="s0">&quot; but dangerouslyAllowSVG is disabled. Consider adding the &quot;unoptimized&quot; property to the &lt;Image&gt;.`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">ImageError(</span><span class="s3">400</span><span class="s1">, </span><span class="s0">'&quot;url&quot; parameter is valid but image type is not allowed'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ANIMATABLE_TYPES.includes(upstreamType) &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _isanimated.default)(upstreamBuffer)) {</span>
        <span class="s2">if </span><span class="s1">(!opts.silent) {</span>
            <span class="s1">_log.warnOnce(</span><span class="s0">`The requested resource &quot;</span><span class="s1">${href}</span><span class="s0">&quot; is an animated image so it will not be optimized. Consider adding the &quot;unoptimized&quot; property to the &lt;Image&gt;.`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">buffer: upstreamBuffer,</span>
            <span class="s1">contentType: upstreamType,</span>
            <span class="s1">maxAge,</span>
            <span class="s1">etag: upstreamEtag,</span>
            <span class="s1">upstreamEtag</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(BYPASS_TYPES.includes(upstreamType)) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">buffer: upstreamBuffer,</span>
            <span class="s1">contentType: upstreamType,</span>
            <span class="s1">maxAge,</span>
            <span class="s1">etag: upstreamEtag,</span>
            <span class="s1">upstreamEtag</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">contentType;</span>
    <span class="s2">if </span><span class="s1">(mimeType) {</span>
        <span class="s1">contentType = mimeType;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _servestatic.getExtension)(upstreamType) &amp;&amp; upstreamType !== WEBP &amp;&amp; upstreamType !== AVIF) {</span>
        <span class="s1">contentType = upstreamType;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">contentType = JPEG;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">previouslyCachedImage = getPreviouslyCachedImageOrNull(imageUpstream, opts.previousCacheEntry);</span>
    <span class="s2">if </span><span class="s1">(previouslyCachedImage) {</span>
        <span class="s2">var </span><span class="s1">_opts_previousCacheEntry_cacheControl, _opts_previousCacheEntry;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">buffer: previouslyCachedImage.buffer,</span>
            <span class="s1">contentType,</span>
            <span class="s1">maxAge: (opts == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_opts_previousCacheEntry = opts.previousCacheEntry) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_opts_previousCacheEntry_cacheControl = _opts_previousCacheEntry.cacheControl) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _opts_previousCacheEntry_cacheControl.revalidate) || maxAge,</span>
            <span class="s1">etag: previouslyCachedImage.etag,</span>
            <span class="s1">upstreamEtag: previouslyCachedImage.upstreamEtag</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">let </span><span class="s1">optimizedBuffer = </span><span class="s2">await </span><span class="s1">optimizeImage({</span>
            <span class="s1">buffer: upstreamBuffer,</span>
            <span class="s1">contentType,</span>
            <span class="s1">quality,</span>
            <span class="s1">width,</span>
            <span class="s1">concurrency: nextConfig.experimental.imgOptConcurrency,</span>
            <span class="s1">limitInputPixels: nextConfig.experimental.imgOptMaxInputPixels,</span>
            <span class="s1">sequentialRead: nextConfig.experimental.imgOptSequentialRead,</span>
            <span class="s1">timeoutInSeconds: nextConfig.experimental.imgOptTimeoutInSeconds</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(opts.isDev &amp;&amp; width &lt;= BLUR_IMG_SIZE &amp;&amp; quality === BLUR_QUALITY) {</span>
            <span class="s4">// During `next dev`, we don't want to generate blur placeholders with webpack</span>
            <span class="s4">// because it can delay starting the dev server. Instead, `next-image-loader.js`</span>
            <span class="s4">// will inline a special url to lazily generate the blur placeholder at request time.</span>
            <span class="s2">const </span><span class="s1">meta = </span><span class="s2">await </span><span class="s1">getImageSize(optimizedBuffer);</span>
            <span class="s2">const </span><span class="s1">blurOpts = {</span>
                <span class="s1">blurWidth: meta.width,</span>
                <span class="s1">blurHeight: meta.height,</span>
                <span class="s1">blurDataURL: </span><span class="s0">`data:</span><span class="s1">${contentType}</span><span class="s0">;base64,</span><span class="s1">${optimizedBuffer.toString(</span><span class="s0">'base64'</span><span class="s1">)}</span><span class="s0">`</span>
            <span class="s1">};</span>
            <span class="s1">optimizedBuffer = Buffer.from(unescape((</span><span class="s3">0</span><span class="s1">, _imageblursvg.getImageBlurSvg)(blurOpts)));</span>
            <span class="s1">contentType = </span><span class="s0">'image/svg+xml'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">buffer: optimizedBuffer,</span>
            <span class="s1">contentType,</span>
            <span class="s1">maxAge,</span>
            <span class="s1">etag: getImageEtag(optimizedBuffer),</span>
            <span class="s1">upstreamEtag</span>
        <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
        <span class="s2">if </span><span class="s1">(upstreamType) {</span>
            <span class="s4">// If we fail to optimize, fallback to the original image</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">buffer: upstreamBuffer,</span>
                <span class="s1">contentType: upstreamType,</span>
                <span class="s1">maxAge: nextConfig.images.minimumCacheTTL,</span>
                <span class="s1">etag: upstreamEtag,</span>
                <span class="s1">upstreamEtag,</span>
                <span class="s1">error</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">ImageError(</span><span class="s3">400</span><span class="s1">, </span><span class="s0">'Unable to optimize image and unable to fallback to upstream image'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getFileNameWithExtension(url, contentType) {</span>
    <span class="s2">const </span><span class="s1">[urlWithoutQueryParams] = url.split(</span><span class="s0">'?'</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">fileNameWithExtension = urlWithoutQueryParams.split(</span><span class="s0">'/'</span><span class="s1">).pop();</span>
    <span class="s2">if </span><span class="s1">(!contentType || !fileNameWithExtension) {</span>
        <span class="s2">return </span><span class="s0">'image.bin'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">[fileName] = fileNameWithExtension.split(</span><span class="s0">'.'</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">extension = (</span><span class="s3">0</span><span class="s1">, _servestatic.getExtension)(contentType);</span>
    <span class="s2">return </span><span class="s0">`</span><span class="s1">${fileName}</span><span class="s0">.</span><span class="s1">${extension}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setResponseHeaders(req, res, url, etag, contentType, isStatic, xCache, imagesConfig, maxAge, isDev) {</span>
    <span class="s1">res.setHeader(</span><span class="s0">'Vary'</span><span class="s1">, </span><span class="s0">'Accept'</span><span class="s1">);</span>
    <span class="s1">res.setHeader(</span><span class="s0">'Cache-Control'</span><span class="s1">, isStatic ? </span><span class="s0">'public, max-age=315360000, immutable' </span><span class="s1">: </span><span class="s0">`public, max-age=</span><span class="s1">${isDev ? </span><span class="s3">0 </span><span class="s1">: maxAge}</span><span class="s0">, must-revalidate`</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _sendpayload.sendEtagResponse)(req, res, etag)) {</span>
        <span class="s4">// already called res.end() so we're finished</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">finished: </span><span class="s2">true</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(contentType) {</span>
        <span class="s1">res.setHeader(</span><span class="s0">'Content-Type'</span><span class="s1">, contentType);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">fileName = getFileNameWithExtension(url, contentType);</span>
    <span class="s1">res.setHeader(</span><span class="s0">'Content-Disposition'</span><span class="s1">, (</span><span class="s3">0</span><span class="s1">, _contentdisposition.default)(fileName, {</span>
        <span class="s1">type: imagesConfig.contentDispositionType</span>
    <span class="s1">}));</span>
    <span class="s1">res.setHeader(</span><span class="s0">'Content-Security-Policy'</span><span class="s1">, imagesConfig.contentSecurityPolicy);</span>
    <span class="s1">res.setHeader(</span><span class="s0">'X-Nextjs-Cache'</span><span class="s1">, xCache);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">finished: </span><span class="s2">false</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sendResponse(req, res, url, extension, buffer, etag, isStatic, xCache, imagesConfig, maxAge, isDev) {</span>
    <span class="s2">const </span><span class="s1">contentType = (</span><span class="s3">0</span><span class="s1">, _servestatic.getContentType)(extension);</span>
    <span class="s2">const </span><span class="s1">result = setResponseHeaders(req, res, url, etag, contentType, isStatic, xCache, imagesConfig, maxAge, isDev);</span>
    <span class="s2">if </span><span class="s1">(!result.finished) {</span>
        <span class="s1">res.setHeader(</span><span class="s0">'Content-Length'</span><span class="s1">, Buffer.byteLength(buffer));</span>
        <span class="s1">res.end(buffer);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">getImageSize(buffer) {</span>
    <span class="s2">const </span><span class="s1">{ width, height } = (</span><span class="s3">0</span><span class="s1">, _imagesize.default)(buffer);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">width,</span>
        <span class="s1">height</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=image-optimizer.js.map</span></pre>
</body>
</html>