<html>
<head>
<title>normalize-catchall-routes.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
normalize-catchall-routes.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/build/normalize-catchall-routes.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isInterceptionRouteAppPath } from '../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import { AppPathnameNormalizer } from '../server/normalizers/built/app/app-pathname-normalizer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function will transform the appPaths in order to support catch-all routes and parallel routes.</span><span class="s3">\n </span><span class="s1">* It will traverse the appPaths, looking for catch-all routes and try to find parallel routes that could match</span><span class="s3">\n </span><span class="s1">* the catch-all. If it finds a match, it will add the catch-all to the parallel route's list of possible routes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param appPaths The appPaths to transform</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeCatchAllRoutes(</span><span class="s3">\n  </span><span class="s1">appPaths: Record&lt;string, string[]&gt;,</span><span class="s3">\n  </span><span class="s1">normalizer = new AppPathnameNormalizer()</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const catchAllRoutes = [</span><span class="s3">\n    </span><span class="s1">...new Set(</span><span class="s3">\n      </span><span class="s1">Object.values(appPaths)</span><span class="s3">\n        </span><span class="s1">.flat()</span><span class="s3">\n        </span><span class="s1">.filter(isCatchAllRoute)</span><span class="s3">\n        </span><span class="s1">// Sorting is important because we want to match the most specific path.</span><span class="s3">\n        </span><span class="s1">.sort((a, b) =&gt; b.split('/').length - a.split('/').length)</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">// interception routes should only be matched by a single entrypoint</span><span class="s3">\n  </span><span class="s1">// we don't want to push a catch-all route to an interception route</span><span class="s3">\n  </span><span class="s1">// because it would mean the interception would be handled by the wrong page component</span><span class="s3">\n  </span><span class="s1">const filteredAppPaths = Object.keys(appPaths).filter(</span><span class="s3">\n    </span><span class="s1">(route) =&gt; !isInterceptionRouteAppPath(route)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">for (const appPath of filteredAppPaths) {</span><span class="s3">\n    </span><span class="s1">for (const catchAllRoute of catchAllRoutes) {</span><span class="s3">\n      </span><span class="s1">const normalizedCatchAllRoute = normalizer.normalize(catchAllRoute)</span><span class="s3">\n      </span><span class="s1">const normalizedCatchAllRouteBasePath = normalizedCatchAllRoute.slice(</span><span class="s3">\n        </span><span class="s1">0,</span><span class="s3">\n        </span><span class="s1">normalizedCatchAllRoute.search(catchAllRouteRegex)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">// check if the appPath could match the catch-all</span><span class="s3">\n        </span><span class="s1">appPath.startsWith(normalizedCatchAllRouteBasePath) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// check if there's not already a slot value that could match the catch-all</span><span class="s3">\n        </span><span class="s1">!appPaths[appPath].some((path) =&gt; hasMatchedSlots(path, catchAllRoute))</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// optional catch-all routes are not currently supported, but leaving this logic in place</span><span class="s3">\n        </span><span class="s1">// for when they are eventually supported.</span><span class="s3">\n        </span><span class="s1">if (isOptionalCatchAll(catchAllRoute)) {</span><span class="s3">\n          </span><span class="s1">// optional catch-all routes should match both the root segment and any segment after it</span><span class="s3">\n          </span><span class="s1">// for example, `/[[...slug]]` should match `/` and `/foo` and `/foo/bar`</span><span class="s3">\n          </span><span class="s1">appPaths[appPath].push(catchAllRoute)</span><span class="s3">\n        </span><span class="s1">} else if (isCatchAll(catchAllRoute)) {</span><span class="s3">\n          </span><span class="s1">// regular catch-all (single bracket) should only match segments after it</span><span class="s3">\n          </span><span class="s1">// for example, `/[...slug]` should match `/foo` and `/foo/bar` but not `/`</span><span class="s3">\n          </span><span class="s1">if (normalizedCatchAllRouteBasePath !== appPath) {</span><span class="s3">\n            </span><span class="s1">appPaths[appPath].push(catchAllRoute)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasMatchedSlots(path1: string, path2: string): boolean {</span><span class="s3">\n  </span><span class="s1">const slots1 = path1.split('/').filter(isMatchableSlot)</span><span class="s3">\n  </span><span class="s1">const slots2 = path2.split('/').filter(isMatchableSlot)</span><span class="s3">\n\n  </span><span class="s1">// if the catch-all route does not have the same number of slots as the app path, it can't match</span><span class="s3">\n  </span><span class="s1">if (slots1.length !== slots2.length) return false</span><span class="s3">\n\n  </span><span class="s1">// compare the slots in both paths. For there to be a match, each slot must be the same</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; slots1.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (slots1[i] !== slots2[i]) return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns true for slots that should be considered when checking for match compatibility.</span><span class="s3">\n </span><span class="s1">* Excludes children slots because these are similar to having a segment-level `page`</span><span class="s3">\n </span><span class="s1">* which would cause a slot length mismatch when comparing it to a catch-all route.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isMatchableSlot(segment: string): boolean {</span><span class="s3">\n  </span><span class="s1">return segment.startsWith('@') &amp;&amp; segment !== '@children'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const catchAllRouteRegex = /</span><span class="s3">\\</span><span class="s1">[?</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">./</span><span class="s3">\n\n</span><span class="s1">function isCatchAllRoute(pathname: string): boolean {</span><span class="s3">\n  </span><span class="s1">// Optional catch-all slots are not currently supported, and as such they are not considered when checking for match compatability.</span><span class="s3">\n  </span><span class="s1">return !isOptionalCatchAll(pathname) &amp;&amp; isCatchAll(pathname)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isOptionalCatchAll(pathname: string): boolean {</span><span class="s3">\n  </span><span class="s1">return pathname.includes('[[...')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isCatchAll(pathname: string): boolean {</span><span class="s3">\n  </span><span class="s1">return pathname.includes('[...')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;normalizeCatchAllRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;appPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;AppPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;catchAllRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;flat&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;isCatchAllRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;filteredAppPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;appPath&quot;</span><span class="s0">,</span><span class="s1">&quot;catchAllRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedCatchAllRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedCatchAllRouteBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;catchAllRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;hasMatchedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalCatchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;isCatchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;path1&quot;</span><span class="s0">,</span><span class="s1">&quot;path2&quot;</span><span class="s0">,</span><span class="s1">&quot;slots1&quot;</span><span class="s0">,</span><span class="s1">&quot;isMatchableSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;slots2&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAUgBA;;;eAAAA;;;oCAV2B;uCACL;AAS/B,SAASA,wBACdC,QAAkC,EAClCC,aAAa,IAAIC,4CAAqB,EAAE;IAExC,MAAMC,iBAAiB;WAClB,IAAIC,IACLC,OAAOC,MAAM,CAACN,UACXO,IAAI,GACJC,MAAM,CAACC,gBACR,wEAAwE;SACvEC,IAAI,CAAC,CAACC,GAAGC,IAAMA,EAAEC,KAAK,CAAC,KAAKC,MAAM,GAAGH,EAAEE,KAAK,CAAC,KAAKC,MAAM;KAE9D;IAED,oEAAoE;IACpE,mEAAmE;IACnE,sFAAsF;IACtF,MAAMC,mBAAmBV,OAAOW,IAAI,CAAChB,UAAUQ,MAAM,CACnD,CAACS,QAAU,CAACC,IAAAA,8CAA0B,EAACD;IAGzC,KAAK,MAAME,WAAWJ,iBAAkB;QACtC,KAAK,MAAMK,iBAAiBjB,eAAgB;YAC1C,MAAMkB,0BAA0BpB,WAAWqB,SAAS,CAACF;YACrD,MAAMG,kCAAkCF,wBAAwBG,KAAK,CACnE,GACAH,wBAAwBI,MAAM,CAACC;YAGjC,IACE,iDAAiD;YACjDP,QAAQQ,UAAU,CAACJ,oCACnB,2EAA2E;YAC3E,CAACvB,QAAQ,CAACmB,QAAQ,CAACS,IAAI,CAAC,CAACC,OAASC,gBAAgBD,MAAMT,iBACxD;gBACA,yFAAyF;gBACzF,0CAA0C;gBAC1C,IAAIW,mBAAmBX,gBAAgB;oBACrC,wFAAwF;oBACxF,yEAAyE;oBACzEpB,QAAQ,CAACmB,QAAQ,CAACa,IAAI,CAACZ;gBACzB,OAAO,IAAIa,WAAWb,gBAAgB;oBACpC,yEAAyE;oBACzE,2EAA2E;oBAC3E,IAAIG,oCAAoCJ,SAAS;wBAC/CnB,QAAQ,CAACmB,QAAQ,CAACa,IAAI,CAACZ;oBACzB;gBACF;YACF;QACF;IACF;AACF;AAEA,SAASU,gBAAgBI,KAAa,EAAEC,KAAa;IACnD,MAAMC,SAASF,MAAMrB,KAAK,CAAC,KAAKL,MAAM,CAAC6B;IACvC,MAAMC,SAASH,MAAMtB,KAAK,CAAC,KAAKL,MAAM,CAAC6B;IAEvC,gGAAgG;IAChG,IAAID,OAAOtB,MAAM,KAAKwB,OAAOxB,MAAM,EAAE,OAAO;IAE5C,uFAAuF;IACvF,IAAK,IAAIyB,IAAI,GAAGA,IAAIH,OAAOtB,MAAM,EAAEyB,IAAK;QACtC,IAAIH,MAAM,CAACG,EAAE,KAAKD,MAAM,CAACC,EAAE,EAAE,OAAO;IACtC;IAEA,OAAO;AACT;AAEA;;;;CAIC,GACD,SAASF,gBAAgBG,OAAe;IACtC,OAAOA,QAAQb,UAAU,CAAC,QAAQa,YAAY;AAChD;AAEA,MAAMd,qBAAqB;AAE3B,SAASjB,gBAAgBgC,QAAgB;IACvC,mIAAmI;IACnI,OAAO,CAACV,mBAAmBU,aAAaR,WAAWQ;AACrD;AAEA,SAASV,mBAAmBU,QAAgB;IAC1C,OAAOA,SAASC,QAAQ,CAAC;AAC3B;AAEA,SAAST,WAAWQ,QAAgB;IAClC,OAAOA,SAASC,QAAQ,CAAC;AAC3B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>