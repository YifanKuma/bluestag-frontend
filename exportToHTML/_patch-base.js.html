<html>
<head>
<title>_patch-base.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_patch-base.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.</span>
<span class="s2">// See LICENSE in the project root for license information.</span>
<span class="s3">var </span><span class="s1">__importDefault = (</span><span class="s3">this </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.__importDefault) || </span><span class="s3">function </span><span class="s1">(mod) {</span>
    <span class="s3">return </span><span class="s1">(mod &amp;&amp; mod.__esModule) ? mod : { </span><span class="s0">&quot;default&quot;</span><span class="s1">: mod };</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s3">true </span><span class="s1">});</span>
<span class="s1">exports.isModuleResolutionError = exports.ESLINT_MAJOR_VERSION = exports.Naming = exports.ModuleResolver = exports.configArrayFactory = exports.eslintFolder = exports.eslintPackageVersion = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s2">// This is a workaround for https://github.com/eslint/eslint/issues/3458</span>
<span class="s2">//</span>
<span class="s2">// To correct how ESLint searches for plugin packages, add this line to the top of your project's .eslintrc.js file:</span>
<span class="s2">//</span>
<span class="s2">//    require(&quot;@rushstack/eslint-patch/modern-module-resolution&quot;);</span>
<span class="s2">//</span>
<span class="s3">const </span><span class="s1">path_1 = __importDefault(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">isModuleResolutionError = (ex) =&gt; </span><span class="s3">typeof </span><span class="s1">ex === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; !!ex &amp;&amp; </span><span class="s0">'code' </span><span class="s3">in </span><span class="s1">ex &amp;&amp; ex.code === </span><span class="s0">'MODULE_NOT_FOUND'</span><span class="s1">;</span>
<span class="s1">exports.isModuleResolutionError = isModuleResolutionError;</span>
<span class="s3">const </span><span class="s1">FLAT_CONFIG_REGEX = </span><span class="s5">/eslint\.config\.(cjs|mjs|js)$/i</span><span class="s1">;</span>
<span class="s2">// Ex:</span>
<span class="s2">//     at async ESLint.lintFiles (C:\\path\\to\\\\eslint\\lib\\eslint\\eslint.js:720:21)</span>
<span class="s3">const </span><span class="s1">NODE_STACK_REGEX = </span><span class="s5">/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?)(?::(\d+)| (\d+))(?::(\d+))?\)?\s*$/i</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">parseNodeStack(stack) {</span>
    <span class="s3">const </span><span class="s1">stackTraceMatch = NODE_STACK_REGEX.exec(stack);</span>
    <span class="s3">if </span><span class="s1">(!stackTraceMatch) {</span>
        <span class="s3">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">file: stackTraceMatch[</span><span class="s4">2</span><span class="s1">],</span>
        <span class="s1">method: stackTraceMatch[</span><span class="s4">1</span><span class="s1">],</span>
        <span class="s1">lineNumber: parseInt(stackTraceMatch[</span><span class="s4">3</span><span class="s1">], </span><span class="s4">10</span><span class="s1">),</span>
        <span class="s1">column: stackTraceMatch[</span><span class="s4">4</span><span class="s1">] ? parseInt(stackTraceMatch[</span><span class="s4">4</span><span class="s1">], </span><span class="s4">10</span><span class="s1">) : undefined</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getStackTrace() {</span>
    <span class="s3">const </span><span class="s1">stackObj = {};</span>
    <span class="s3">const </span><span class="s1">originalStackTraceLimit = Error.stackTraceLimit;</span>
    <span class="s1">Error.stackTraceLimit = Infinity;</span>
    <span class="s1">Error.captureStackTrace(stackObj, getStackTrace);</span>
    <span class="s1">Error.stackTraceLimit = originalStackTraceLimit;</span>
    <span class="s3">if </span><span class="s1">(!stackObj.stack) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'Unable to capture stack trace'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">{ stack } = stackObj;</span>
    <span class="s3">const </span><span class="s1">stackLines = stack.split(</span><span class="s0">'</span><span class="s6">\n</span><span class="s0">'</span><span class="s1">);</span>
    <span class="s3">const </span><span class="s1">frames = [];</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">line of stackLines) {</span>
        <span class="s3">const </span><span class="s1">frame = parseNodeStack(line);</span>
        <span class="s3">if </span><span class="s1">(frame) {</span>
            <span class="s1">frames.push(frame);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">frames;</span>
<span class="s1">}</span>
<span class="s2">// Module path for eslintrc.cjs</span>
<span class="s2">// Example: &quot;.../@eslint/eslintrc/dist/eslintrc.cjs&quot;</span>
<span class="s3">let </span><span class="s1">eslintrcBundlePath = undefined;</span>
<span class="s2">// Module path for config-array-factory.js</span>
<span class="s2">// Example: &quot;.../@eslint/eslintrc/lib/config-array-factory&quot;</span>
<span class="s3">let </span><span class="s1">configArrayFactoryPath = undefined;</span>
<span class="s2">// Module path for relative-module-resolver.js</span>
<span class="s2">// Example: &quot;.../@eslint/eslintrc/lib/shared/relative-module-resolver&quot;</span>
<span class="s3">let </span><span class="s1">moduleResolverPath = undefined;</span>
<span class="s2">// Module path for naming.js</span>
<span class="s2">// Example: &quot;.../@eslint/eslintrc/lib/shared/naming&quot;</span>
<span class="s3">let </span><span class="s1">namingPath = undefined;</span>
<span class="s2">// Folder path where ESLint's package.json can be found</span>
<span class="s2">// Example: &quot;.../node_modules/eslint&quot;</span>
<span class="s3">let </span><span class="s1">eslintFolder = undefined;</span>
<span class="s1">exports.eslintFolder = eslintFolder;</span>
<span class="s2">// Probe for the ESLint &gt;=9.0.0 flat config layout:</span>
<span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">currentModule = module;;) {</span>
    <span class="s3">if </span><span class="s1">(FLAT_CONFIG_REGEX.test(currentModule.filename)) {</span>
        <span class="s2">// Obtain the stack trace of the current module, since the</span>
        <span class="s2">// parent module of a flat config is undefined. From the</span>
        <span class="s2">// stack trace, we can find the ESLint folder.</span>
        <span class="s3">const </span><span class="s1">stackTrace = getStackTrace();</span>
        <span class="s3">const </span><span class="s1">targetFrame = stackTrace.find((frame) =&gt; frame.file &amp;&amp; frame.file.endsWith(</span><span class="s0">'eslint.js'</span><span class="s1">));</span>
        <span class="s3">if </span><span class="s1">(targetFrame) {</span>
            <span class="s2">// Walk up the path and continuously attempt to resolve the ESLint folder</span>
            <span class="s3">let </span><span class="s1">currentPath = targetFrame.file;</span>
            <span class="s3">while </span><span class="s1">(currentPath) {</span>
                <span class="s3">const </span><span class="s1">potentialPath = path_1.default.dirname(currentPath);</span>
                <span class="s3">if </span><span class="s1">(potentialPath === currentPath) {</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">currentPath = potentialPath;</span>
                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s1">exports.eslintFolder = eslintFolder = path_1.default.dirname(require.resolve(</span><span class="s0">'eslint/package.json'</span><span class="s1">, { paths: [currentPath] }));</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">catch </span><span class="s1">(ex) {</span>
                    <span class="s3">if </span><span class="s1">(!isModuleResolutionError(ex)) {</span>
                        <span class="s3">throw </span><span class="s1">ex;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(eslintFolder) {</span>
            <span class="s3">const </span><span class="s1">eslintrcFolderPath = path_1.default.dirname(require.resolve(</span><span class="s0">'@eslint/eslintrc/package.json'</span><span class="s1">, { paths: [eslintFolder] }));</span>
            <span class="s1">eslintrcBundlePath = path_1.default.join(eslintrcFolderPath, </span><span class="s0">'dist/eslintrc.cjs'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!currentModule.parent) {</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">currentModule = currentModule.parent;</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(!eslintFolder) {</span>
    <span class="s2">// Probe for the ESLint &gt;=8.0.0 layout:</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">currentModule = module;;) {</span>
        <span class="s3">if </span><span class="s1">(!eslintrcBundlePath) {</span>
            <span class="s3">if </span><span class="s1">(currentModule.filename.endsWith(</span><span class="s0">'eslintrc.cjs'</span><span class="s1">)) {</span>
                <span class="s2">// For ESLint &gt;=8.0.0, all @eslint/eslintrc code is bundled at this path:</span>
                <span class="s2">//   .../@eslint/eslintrc/dist/eslintrc.cjs</span>
                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s3">const </span><span class="s1">eslintrcFolderPath = path_1.default.dirname(require.resolve(</span><span class="s0">'@eslint/eslintrc/package.json'</span><span class="s1">, { paths: [currentModule.path] }));</span>
                    <span class="s2">// Make sure we actually resolved the module in our call path</span>
                    <span class="s2">// and not some other spurious dependency.</span>
                    <span class="s3">const </span><span class="s1">resolvedEslintrcBundlePath = path_1.default.join(eslintrcFolderPath, </span><span class="s0">'dist/eslintrc.cjs'</span><span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(resolvedEslintrcBundlePath === currentModule.filename) {</span>
                        <span class="s1">eslintrcBundlePath = resolvedEslintrcBundlePath;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">catch </span><span class="s1">(ex) {</span>
                    <span class="s2">// Module resolution failures are expected, as we're walking</span>
                    <span class="s2">// up our require stack to look for eslint. All other errors</span>
                    <span class="s2">// are re-thrown.</span>
                    <span class="s3">if </span><span class="s1">(!isModuleResolutionError(ex)) {</span>
                        <span class="s3">throw </span><span class="s1">ex;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s2">// Next look for a file in ESLint's folder</span>
            <span class="s2">//   .../eslint/lib/cli-engine/cli-engine.js</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">const </span><span class="s1">eslintCandidateFolder = path_1.default.dirname(require.resolve(</span><span class="s0">'eslint/package.json'</span><span class="s1">, {</span>
                    <span class="s1">paths: [currentModule.path]</span>
                <span class="s1">}));</span>
                <span class="s2">// Make sure we actually resolved the module in our call path</span>
                <span class="s2">// and not some other spurious dependency.</span>
                <span class="s3">if </span><span class="s1">(currentModule.filename.startsWith(eslintCandidateFolder + path_1.default.sep)) {</span>
                    <span class="s1">exports.eslintFolder = eslintFolder = eslintCandidateFolder;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">catch </span><span class="s1">(ex) {</span>
                <span class="s2">// Module resolution failures are expected, as we're walking</span>
                <span class="s2">// up our require stack to look for eslint. All other errors</span>
                <span class="s2">// are re-thrown.</span>
                <span class="s3">if </span><span class="s1">(!isModuleResolutionError(ex)) {</span>
                    <span class="s3">throw </span><span class="s1">ex;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!currentModule.parent) {</span>
            <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">currentModule = currentModule.parent;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(!eslintFolder) {</span>
    <span class="s2">// Probe for the ESLint &gt;=7.12.0 layout:</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">currentModule = module;;) {</span>
        <span class="s3">if </span><span class="s1">(!configArrayFactoryPath) {</span>
            <span class="s2">// For ESLint &gt;=7.12.0, config-array-factory.js is at this path:</span>
            <span class="s2">//   .../@eslint/eslintrc/lib/config-array-factory.js</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">const </span><span class="s1">eslintrcFolder = path_1.default.dirname(require.resolve(</span><span class="s0">'@eslint/eslintrc/package.json'</span><span class="s1">, {</span>
                    <span class="s1">paths: [currentModule.path]</span>
                <span class="s1">}));</span>
                <span class="s3">const </span><span class="s1">resolvedConfigArrayFactoryPath = path_1.default.join(eslintrcFolder, </span><span class="s0">'/lib/config-array-factory.js'</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(resolvedConfigArrayFactoryPath === currentModule.filename) {</span>
                    <span class="s1">configArrayFactoryPath = resolvedConfigArrayFactoryPath;</span>
                    <span class="s1">moduleResolverPath = </span><span class="s0">`</span><span class="s1">${eslintrcFolder}</span><span class="s0">/lib/shared/relative-module-resolver`</span><span class="s1">;</span>
                    <span class="s1">namingPath = </span><span class="s0">`</span><span class="s1">${eslintrcFolder}</span><span class="s0">/lib/shared/naming`</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">catch </span><span class="s1">(ex) {</span>
                <span class="s2">// Module resolution failures are expected, as we're walking</span>
                <span class="s2">// up our require stack to look for eslint. All other errors</span>
                <span class="s2">// are re-thrown.</span>
                <span class="s3">if </span><span class="s1">(!isModuleResolutionError(ex)) {</span>
                    <span class="s3">throw </span><span class="s1">ex;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(currentModule.filename.endsWith(</span><span class="s0">'cli-engine.js'</span><span class="s1">)) {</span>
            <span class="s2">// Next look for a file in ESLint's folder</span>
            <span class="s2">//   .../eslint/lib/cli-engine/cli-engine.js</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">const </span><span class="s1">eslintCandidateFolder = path_1.default.dirname(require.resolve(</span><span class="s0">'eslint/package.json'</span><span class="s1">, {</span>
                    <span class="s1">paths: [currentModule.path]</span>
                <span class="s1">}));</span>
                <span class="s3">if </span><span class="s1">(path_1.default.join(eslintCandidateFolder, </span><span class="s0">'lib/cli-engine/cli-engine.js'</span><span class="s1">) === currentModule.filename) {</span>
                    <span class="s1">exports.eslintFolder = eslintFolder = eslintCandidateFolder;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">catch </span><span class="s1">(ex) {</span>
                <span class="s2">// Module resolution failures are expected, as we're walking</span>
                <span class="s2">// up our require stack to look for eslint. All other errors</span>
                <span class="s2">// are rethrown.</span>
                <span class="s3">if </span><span class="s1">(!isModuleResolutionError(ex)) {</span>
                    <span class="s3">throw </span><span class="s1">ex;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!currentModule.parent) {</span>
            <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">currentModule = currentModule.parent;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(!eslintFolder) {</span>
    <span class="s2">// Probe for the &lt;7.12.0 layout:</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">currentModule = module;;) {</span>
        <span class="s2">// For ESLint &lt;7.12.0, config-array-factory.js was at this path:</span>
        <span class="s2">//   .../eslint/lib/cli-engine/config-array-factory.js</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s5">/[\\/]eslint[\\/]lib[\\/]cli-engine[\\/]config-array-factory\.js$/i</span><span class="s1">.test(currentModule.filename)) {</span>
            <span class="s1">exports.eslintFolder = eslintFolder = path_1.default.join(path_1.default.dirname(currentModule.filename), </span><span class="s0">'../..'</span><span class="s1">);</span>
            <span class="s1">configArrayFactoryPath = </span><span class="s0">`</span><span class="s1">${eslintFolder}</span><span class="s0">/lib/cli-engine/config-array-factory`</span><span class="s1">;</span>
            <span class="s1">moduleResolverPath = </span><span class="s0">`</span><span class="s1">${eslintFolder}</span><span class="s0">/lib/shared/relative-module-resolver`</span><span class="s1">;</span>
            <span class="s2">// The naming module was moved to @eslint/eslintrc in ESLint 7.8.0, which is also when the @eslint/eslintrc</span>
            <span class="s2">// package was created and added to ESLint, so we need to probe for whether it's in the old or new location.</span>
            <span class="s3">let </span><span class="s1">eslintrcFolder;</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">eslintrcFolder = path_1.default.dirname(require.resolve(</span><span class="s0">'@eslint/eslintrc/package.json'</span><span class="s1">, {</span>
                    <span class="s1">paths: [currentModule.path]</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s3">catch </span><span class="s1">(ex) {</span>
                <span class="s3">if </span><span class="s1">(!isModuleResolutionError(ex)) {</span>
                    <span class="s3">throw </span><span class="s1">ex;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">namingPath = </span><span class="s0">`</span><span class="s1">${eslintrcFolder !== </span><span class="s3">null </span><span class="s1">&amp;&amp; eslintrcFolder !== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">? eslintrcFolder : eslintFolder}</span><span class="s0">/lib/shared/naming`</span><span class="s1">;</span>
            <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!currentModule.parent) {</span>
            <span class="s2">// This was tested with ESLint 6.1.0 .. 7.12.1.</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'Failed to patch ESLint because the calling module was not recognized.</span><span class="s6">\n</span><span class="s0">' </span><span class="s1">+</span>
                <span class="s0">'If you are using a newer ESLint version that may be unsupported, please create a GitHub issue:</span><span class="s6">\n</span><span class="s0">' </span><span class="s1">+</span>
                <span class="s0">'https://github.com/microsoft/rushstack/issues'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">currentModule = currentModule.parent;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">// Detect the ESLint package version</span>
<span class="s3">const </span><span class="s1">eslintPackageJsonPath = </span><span class="s0">`</span><span class="s1">${eslintFolder}</span><span class="s0">/package.json`</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">eslintPackageObject = require(eslintPackageJsonPath);</span>
<span class="s1">exports.eslintPackageVersion = eslintPackageObject.version;</span>
<span class="s3">const </span><span class="s1">ESLINT_MAJOR_VERSION = parseInt(exports.eslintPackageVersion, </span><span class="s4">10</span><span class="s1">);</span>
<span class="s1">exports.ESLINT_MAJOR_VERSION = ESLINT_MAJOR_VERSION;</span>
<span class="s3">if </span><span class="s1">(isNaN(ESLINT_MAJOR_VERSION)) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">`Unable to parse ESLint version &quot;</span><span class="s1">${exports.eslintPackageVersion}</span><span class="s0">&quot; in file &quot;</span><span class="s1">${eslintPackageJsonPath}</span><span class="s0">&quot;`</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(!(ESLINT_MAJOR_VERSION &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; ESLINT_MAJOR_VERSION &lt;= </span><span class="s4">9</span><span class="s1">)) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'The ESLint patch script has only been tested with ESLint version 6.x, 7.x, 8.x, and 9.x.' </span><span class="s1">+</span>
        <span class="s0">` (Your version: </span><span class="s1">${exports.eslintPackageVersion}</span><span class="s0">)</span><span class="s6">\n</span><span class="s0">` </span><span class="s1">+</span>
        <span class="s0">'Consider reporting a GitHub issue:</span><span class="s6">\n</span><span class="s0">' </span><span class="s1">+</span>
        <span class="s0">'https://github.com/microsoft/rushstack/issues'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span>
<span class="s3">let </span><span class="s1">configArrayFactory;</span>
<span class="s3">if </span><span class="s1">(ESLINT_MAJOR_VERSION &gt;= </span><span class="s4">8 </span><span class="s1">&amp;&amp; eslintrcBundlePath) {</span>
    <span class="s1">exports.configArrayFactory = configArrayFactory = require(eslintrcBundlePath).Legacy.ConfigArrayFactory;</span>
<span class="s1">}</span>
<span class="s3">else if </span><span class="s1">(configArrayFactoryPath) {</span>
    <span class="s1">exports.configArrayFactory = configArrayFactory = require(configArrayFactoryPath).ConfigArrayFactory;</span>
<span class="s1">}</span>
<span class="s2">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span>
<span class="s3">let </span><span class="s1">ModuleResolver;</span>
<span class="s2">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span>
<span class="s3">let </span><span class="s1">Naming;</span>
<span class="s3">if </span><span class="s1">(ESLINT_MAJOR_VERSION &gt;= </span><span class="s4">8 </span><span class="s1">&amp;&amp; eslintrcBundlePath) {</span>
    <span class="s1">exports.ModuleResolver = ModuleResolver = require(eslintrcBundlePath).Legacy.ModuleResolver;</span>
    <span class="s1">exports.Naming = Naming = require(eslintrcBundlePath).Legacy.naming;</span>
<span class="s1">}</span>
<span class="s3">else if </span><span class="s1">(moduleResolverPath &amp;&amp; namingPath) {</span>
    <span class="s1">exports.ModuleResolver = ModuleResolver = require(moduleResolverPath);</span>
    <span class="s1">exports.Naming = Naming = require(namingPath);</span>
<span class="s1">}</span>
<span class="s2">//# sourceMappingURL=_patch-base.js.map</span></pre>
</body>
</html>