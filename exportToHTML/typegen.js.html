<html>
<head>
<title>typegen.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typegen.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">generateLinkTypesFile: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">generateRouteTypesFile: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">generateValidatorFile: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">generateLinkTypesFile: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">generateLinkTypesFile;</span>
    <span class="s1">},</span>
    <span class="s1">generateRouteTypesFile: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">generateRouteTypesFile;</span>
    <span class="s1">},</span>
    <span class="s1">generateValidatorFile: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">generateValidatorFile;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_isdynamic = require(</span><span class="s0">&quot;../../../shared/lib/router/utils/is-dynamic&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">generateRouteTypes(routesManifest) {</span>
    <span class="s2">const </span><span class="s1">appRoutes = Object.keys(routesManifest.appRoutes).sort();</span>
    <span class="s2">const </span><span class="s1">pageRoutes = Object.keys(routesManifest.pageRoutes).sort();</span>
    <span class="s2">const </span><span class="s1">layoutRoutes = Object.keys(routesManifest.layoutRoutes).sort();</span>
    <span class="s2">const </span><span class="s1">redirectRoutes = Object.keys(routesManifest.redirectRoutes).sort();</span>
    <span class="s2">const </span><span class="s1">rewriteRoutes = Object.keys(routesManifest.rewriteRoutes).sort();</span>
    <span class="s2">let </span><span class="s1">result = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s4">// Generate AppRoutes union type (pages only)</span>
    <span class="s2">if </span><span class="s1">(appRoutes.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s1">result += </span><span class="s0">`type AppRoutes = </span><span class="s1">${appRoutes.map((route)=&gt;JSON.stringify(route)).join(</span><span class="s0">' | '</span><span class="s1">)}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result += </span><span class="s0">'type AppRoutes = never</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Generate AppRouteHandlerRoutes union type for route handlers</span>
    <span class="s2">const </span><span class="s1">appRouteHandlerRoutes = Object.keys(routesManifest.appRouteHandlerRoutes).sort();</span>
    <span class="s2">const </span><span class="s1">hasAppRouteHandlers = appRouteHandlerRoutes.length &gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(hasAppRouteHandlers) {</span>
        <span class="s1">result += </span><span class="s0">`type AppRouteHandlerRoutes = </span><span class="s1">${appRouteHandlerRoutes.map((route)=&gt;JSON.stringify(route)).join(</span><span class="s0">' | '</span><span class="s1">)}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Generate PageRoutes union type</span>
    <span class="s2">if </span><span class="s1">(pageRoutes.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s1">result += </span><span class="s0">`type PageRoutes = </span><span class="s1">${pageRoutes.map((route)=&gt;JSON.stringify(route)).join(</span><span class="s0">' | '</span><span class="s1">)}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result += </span><span class="s0">'type PageRoutes = never</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Generate LayoutRoutes union type</span>
    <span class="s2">if </span><span class="s1">(layoutRoutes.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s1">result += </span><span class="s0">`type LayoutRoutes = </span><span class="s1">${layoutRoutes.map((route)=&gt;JSON.stringify(route)).join(</span><span class="s0">' | '</span><span class="s1">)}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result += </span><span class="s0">'type LayoutRoutes = never</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Generate RedirectRoutes union type</span>
    <span class="s2">if </span><span class="s1">(redirectRoutes.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s1">result += </span><span class="s0">`type RedirectRoutes = </span><span class="s1">${redirectRoutes.map((route)=&gt;JSON.stringify(route)).join(</span><span class="s0">' | '</span><span class="s1">)}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result += </span><span class="s0">'type RedirectRoutes = never</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Generate RewriteRoutes union type</span>
    <span class="s2">if </span><span class="s1">(rewriteRoutes.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s1">result += </span><span class="s0">`type RewriteRoutes = </span><span class="s1">${rewriteRoutes.map((route)=&gt;JSON.stringify(route)).join(</span><span class="s0">' | '</span><span class="s1">)}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result += </span><span class="s0">'type RewriteRoutes = never</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Only include AppRouteHandlerRoutes in Routes union if there are actual route handlers</span>
    <span class="s2">const </span><span class="s1">routeUnionParts = [</span>
        <span class="s0">'AppRoutes'</span><span class="s1">,</span>
        <span class="s0">'PageRoutes'</span><span class="s1">,</span>
        <span class="s0">'LayoutRoutes'</span><span class="s1">,</span>
        <span class="s0">'RedirectRoutes'</span><span class="s1">,</span>
        <span class="s0">'RewriteRoutes'</span>
    <span class="s1">];</span>
    <span class="s2">if </span><span class="s1">(hasAppRouteHandlers) {</span>
        <span class="s1">routeUnionParts.push(</span><span class="s0">'AppRouteHandlerRoutes'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">result += </span><span class="s0">`type Routes = </span><span class="s1">${routeUnionParts.join(</span><span class="s0">' | '</span><span class="s1">)}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateParamTypes(routesManifest) {</span>
    <span class="s2">const </span><span class="s1">allRoutes = {</span>
        <span class="s1">...routesManifest.appRoutes,</span>
        <span class="s1">...routesManifest.appRouteHandlerRoutes,</span>
        <span class="s1">...routesManifest.pageRoutes,</span>
        <span class="s1">...routesManifest.layoutRoutes,</span>
        <span class="s1">...routesManifest.redirectRoutes,</span>
        <span class="s1">...routesManifest.rewriteRoutes</span>
    <span class="s1">};</span>
    <span class="s2">let </span><span class="s1">paramTypes = </span><span class="s0">'interface ParamMap {</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s4">// Sort routes deterministically for consistent output</span>
    <span class="s2">const </span><span class="s1">sortedRoutes = Object.entries(allRoutes).sort(([a], [b])=&gt;a.localeCompare(b));</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[route, routeInfo] of sortedRoutes){</span>
        <span class="s2">const </span><span class="s1">{ groups } = routeInfo;</span>
        <span class="s4">// For static routes (no dynamic segments), we can produce an empty parameter map.</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _isdynamic.isDynamicRoute)(route) || Object.keys(groups ?? {}).length === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">paramTypes += </span><span class="s0">`  </span><span class="s1">${JSON.stringify(route)}</span><span class="s0">: {}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">paramType = </span><span class="s0">'{'</span><span class="s1">;</span>
        <span class="s4">// Process each group based on its properties</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, group] of Object.entries(groups)){</span>
            <span class="s2">const </span><span class="s1">escapedKey = JSON.stringify(key);</span>
            <span class="s2">if </span><span class="s1">(group.repeat) {</span>
                <span class="s4">// Catch-all parameters</span>
                <span class="s2">if </span><span class="s1">(group.optional) {</span>
                    <span class="s1">paramType += </span><span class="s0">` </span><span class="s1">${escapedKey}</span><span class="s0">?: string[];`</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">paramType += </span><span class="s0">` </span><span class="s1">${escapedKey}</span><span class="s0">: string[];`</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// Regular parameters</span>
                <span class="s2">if </span><span class="s1">(group.optional) {</span>
                    <span class="s1">paramType += </span><span class="s0">` </span><span class="s1">${escapedKey}</span><span class="s0">?: string;`</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">paramType += </span><span class="s0">` </span><span class="s1">${escapedKey}</span><span class="s0">: string;`</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">paramType += </span><span class="s0">' }'</span><span class="s1">;</span>
        <span class="s1">paramTypes += </span><span class="s0">`  </span><span class="s1">${JSON.stringify(route)}</span><span class="s0">: </span><span class="s1">${paramType}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">paramTypes += </span><span class="s0">'}</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">paramTypes;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateLayoutSlotMap(routesManifest) {</span>
    <span class="s2">let </span><span class="s1">slotMap = </span><span class="s0">'interface LayoutSlotMap {</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s4">// Sort routes deterministically for consistent output</span>
    <span class="s2">const </span><span class="s1">sortedLayoutRoutes = Object.entries(routesManifest.layoutRoutes).sort(([a], [b])=&gt;a.localeCompare(b));</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[route, routeInfo] of sortedLayoutRoutes){</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'slots' </span><span class="s2">in </span><span class="s1">routeInfo) {</span>
            <span class="s2">const </span><span class="s1">slots = routeInfo.slots.sort();</span>
            <span class="s2">if </span><span class="s1">(slots.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">slotMap += </span><span class="s0">`  </span><span class="s1">${JSON.stringify(route)}</span><span class="s0">: </span><span class="s1">${slots.map((slot)=&gt;JSON.stringify(slot)).join(</span><span class="s0">' | '</span><span class="s1">)}</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">slotMap += </span><span class="s0">`  </span><span class="s1">${JSON.stringify(route)}</span><span class="s0">: never</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">slotMap += </span><span class="s0">`  </span><span class="s1">${JSON.stringify(route)}</span><span class="s0">: never</span><span class="s5">\n</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">slotMap += </span><span class="s0">'}</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">slotMap;</span>
<span class="s1">}</span>
<span class="s4">// Helper function to format routes to route types (matches the plugin logic exactly)</span>
<span class="s2">function </span><span class="s1">formatRouteToRouteType(route) {</span>
    <span class="s2">const </span><span class="s1">isDynamic = (</span><span class="s3">0</span><span class="s1">, _isdynamic.isDynamicRoute)(route);</span>
    <span class="s2">if </span><span class="s1">(isDynamic) {</span>
        <span class="s1">route = route.split(</span><span class="s0">'/'</span><span class="s1">).map((part)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(part.startsWith(</span><span class="s0">'['</span><span class="s1">) &amp;&amp; part.endsWith(</span><span class="s0">']'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(part.startsWith(</span><span class="s0">'[...'</span><span class="s1">)) {</span>
                    <span class="s4">// /[...slug]</span>
                    <span class="s2">return </span><span class="s0">`</span><span class="s5">\$</span><span class="s0">{CatchAllSlug&lt;T&gt;}`</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(part.startsWith(</span><span class="s0">'[[...'</span><span class="s1">) &amp;&amp; part.endsWith(</span><span class="s0">']]'</span><span class="s1">)) {</span>
                    <span class="s4">// /[[...slug]]</span>
                    <span class="s2">return </span><span class="s0">`</span><span class="s5">\$</span><span class="s0">{OptionalCatchAllSlug&lt;T&gt;}`</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// /[slug]</span>
                <span class="s2">return </span><span class="s0">`</span><span class="s5">\$</span><span class="s0">{SafeSlug&lt;T&gt;}`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">part;</span>
        <span class="s1">}).join(</span><span class="s0">'/'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">isDynamic,</span>
        <span class="s1">routeType: route</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s4">// Helper function to serialize route types (matches the plugin logic exactly)</span>
<span class="s2">function </span><span class="s1">serializeRouteTypes(routeTypes) {</span>
    <span class="s4">// route collection is not deterministic, this makes the output of the file deterministic</span>
    <span class="s2">return </span><span class="s1">routeTypes.sort().map((route)=&gt;</span><span class="s0">`</span><span class="s5">\n    </span><span class="s0">| </span><span class="s5">\`</span><span class="s1">${route}</span><span class="s5">\`</span><span class="s0">`</span><span class="s1">).join(</span><span class="s0">''</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateLinkTypesFile(routesManifest) {</span>
    <span class="s4">// Generate serialized static and dynamic routes for the internal namespace</span>
    <span class="s4">// Build a unified set of routes across app/pages/redirect/rewrite as well as</span>
    <span class="s4">// app route handlers and Pages Router API routes.</span>
    <span class="s2">const </span><span class="s1">allRoutesSet = </span><span class="s2">new </span><span class="s1">Set([</span>
        <span class="s1">...Object.keys(routesManifest.appRoutes),</span>
        <span class="s1">...Object.keys(routesManifest.pageRoutes),</span>
        <span class="s1">...Object.keys(routesManifest.redirectRoutes),</span>
        <span class="s1">...Object.keys(routesManifest.rewriteRoutes),</span>
        <span class="s4">// Allow linking to App Route Handlers (e.g. `/logout/route.ts`)</span>
        <span class="s1">...Object.keys(routesManifest.appRouteHandlerRoutes),</span>
        <span class="s4">// Allow linking to Pages Router API routes (e.g. `/api/*`)</span>
        <span class="s1">...Array.from(routesManifest.pageApiRoutes)</span>
    <span class="s1">]);</span>
    <span class="s2">const </span><span class="s1">staticRouteTypes = [];</span>
    <span class="s2">const </span><span class="s1">dynamicRouteTypes = [];</span>
    <span class="s4">// Process each route using the same logic as the plugin</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">route of allRoutesSet){</span>
        <span class="s2">const </span><span class="s1">{ isDynamic, routeType } = formatRouteToRouteType(route);</span>
        <span class="s2">if </span><span class="s1">(isDynamic) {</span>
            <span class="s1">dynamicRouteTypes.push(routeType);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">staticRouteTypes.push(routeType);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">serializedStaticRouteTypes = serializeRouteTypes(staticRouteTypes);</span>
    <span class="s2">const </span><span class="s1">serializedDynamicRouteTypes = serializeRouteTypes(dynamicRouteTypes);</span>
    <span class="s4">// If both StaticRoutes and DynamicRoutes are empty, fallback to type 'string &amp; {}'.</span>
    <span class="s2">const </span><span class="s1">routeTypesFallback = !serializedStaticRouteTypes &amp;&amp; !serializedDynamicRouteTypes ? </span><span class="s0">'string &amp; {}' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s0">`// This file is generated automatically by Next.js 
// Do not edit this file manually 
 
// Type definitions for Next.js routes 
 
/** 
 * Internal types used by the Next.js router and Link component. 
 * These types are not meant to be used directly. 
 * @internal 
 */ 
declare namespace __next_route_internal_types__ { 
  type SearchOrHash = </span><span class="s5">\`</span><span class="s0">?</span><span class="s5">\$</span><span class="s0">{string}</span><span class="s5">\` </span><span class="s0">| </span><span class="s5">\`</span><span class="s0">#</span><span class="s5">\$</span><span class="s0">{string}</span><span class="s5">\`</span>
  <span class="s0">type WithProtocol = </span><span class="s5">\`\$</span><span class="s0">{string}:</span><span class="s5">\$</span><span class="s0">{string}</span><span class="s5">\`</span>

  <span class="s0">type Suffix = '' | SearchOrHash 
 
  type SafeSlug&lt;S extends string&gt; = S extends </span><span class="s5">\`\$</span><span class="s0">{string}/</span><span class="s5">\$</span><span class="s0">{string}</span><span class="s5">\`</span>
    <span class="s0">? never 
    : S extends </span><span class="s5">\`\$</span><span class="s0">{string}</span><span class="s5">\$</span><span class="s0">{SearchOrHash}</span><span class="s5">\`</span>
    <span class="s0">? never 
    : S extends '' 
    ? never 
    : S 
 
  type CatchAllSlug&lt;S extends string&gt; = S extends </span><span class="s5">\`\$</span><span class="s0">{string}</span><span class="s5">\$</span><span class="s0">{SearchOrHash}</span><span class="s5">\`</span>
    <span class="s0">? never 
    : S extends '' 
    ? never 
    : S 
 
  type OptionalCatchAllSlug&lt;S extends string&gt; = 
    S extends </span><span class="s5">\`\$</span><span class="s0">{string}</span><span class="s5">\$</span><span class="s0">{SearchOrHash}</span><span class="s5">\` </span><span class="s0">? never : S 
 
  type StaticRoutes = </span><span class="s1">${serializedStaticRouteTypes || </span><span class="s0">'never'</span><span class="s1">}</span>
  <span class="s0">type DynamicRoutes&lt;T extends string = string&gt; = </span><span class="s1">${serializedDynamicRouteTypes || </span><span class="s0">'never'</span><span class="s1">}</span>

  <span class="s0">type RouteImpl&lt;T&gt; = </span><span class="s1">${routeTypesFallback || </span><span class="s0">`</span>
    <span class="s1">${</span><span class="s4">// This keeps autocompletion working for static routes.</span>
    <span class="s0">'| StaticRoutes'</span><span class="s1">}</span>
    <span class="s0">| SearchOrHash 
    | WithProtocol 
    | </span><span class="s5">\`\$</span><span class="s0">{StaticRoutes}</span><span class="s5">\$</span><span class="s0">{SearchOrHash}</span><span class="s5">\`</span>
    <span class="s0">| (T extends </span><span class="s5">\`\$</span><span class="s0">{DynamicRoutes&lt;infer _&gt;}</span><span class="s5">\$</span><span class="s0">{Suffix}</span><span class="s5">\` </span><span class="s0">? T : never) 
    `</span><span class="s1">}</span>
<span class="s0">} 
 
declare module 'next' { 
  export { default } from 'next/types.js' 
  export * from 'next/types.js' 
 
  export type Route&lt;T extends string = string&gt; = 
    __next_route_internal_types__.RouteImpl&lt;T&gt; 
} 
 
declare module 'next/link' { 
  import type { LinkProps as OriginalLinkProps } from 'next/dist/client/link.js' 
  import type { AnchorHTMLAttributes, DetailedHTMLProps } from 'react' 
  import type { UrlObject } from 'url' 
 
  type LinkRestProps = Omit&lt; 
    Omit&lt; 
      DetailedHTMLProps&lt; 
        AnchorHTMLAttributes&lt;HTMLAnchorElement&gt;, 
        HTMLAnchorElement 
      &gt;, 
      keyof OriginalLinkProps 
    &gt; &amp; 
      OriginalLinkProps, 
    'href' 
  &gt; 
 
  export type LinkProps&lt;RouteInferType&gt; = LinkRestProps &amp; { 
    /** 
     * The path or URL to navigate to. This is the only required prop. It can also be an object. 
     * @see https://nextjs.org/docs/api-reference/next/link 
     */ 
    href: __next_route_internal_types__.RouteImpl&lt;RouteInferType&gt; | UrlObject 
  } 
 
  export default function Link&lt;RouteType&gt;(props: LinkProps&lt;RouteType&gt;): JSX.Element 
} 
 
declare module 'next/navigation' { 
  export * from 'next/dist/client/components/navigation.js' 
 
  import type { NavigateOptions, AppRouterInstance as OriginalAppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js' 
  import type { RedirectType } from 'next/dist/client/components/redirect-error.js' 
   
  interface AppRouterInstance extends OriginalAppRouterInstance { 
    /** 
     * Navigate to the provided href. 
     * Pushes a new history entry. 
     */ 
    push&lt;RouteType&gt;(href: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;, options?: NavigateOptions): void 
    /** 
     * Navigate to the provided href. 
     * Replaces the current history entry. 
     */ 
    replace&lt;RouteType&gt;(href: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;, options?: NavigateOptions): void 
    /** 
     * Prefetch the provided href. 
     */ 
    prefetch&lt;RouteType&gt;(href: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;): void 
  } 
 
  export function useRouter(): AppRouterInstance; 
   
  /** 
   * This function allows you to redirect the user to another URL. It can be used in 
   * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components), 
   * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and 
   * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations). 
   * 
   * - In a Server Component, this will insert a meta tag to redirect the user to the target page. 
   * - In a Route Handler or Server Action, it will serve a 307/303 to the caller. 
   * - In a Server Action, type defaults to 'push' and 'replace' elsewhere. 
   * 
   * Read more: [Next.js Docs: redirect](https://nextjs.org/docs/app/api-reference/functions/redirect) 
   */ 
  export function redirect&lt;RouteType&gt;( 
    /** The URL to redirect to */ 
    url: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;, 
    type?: RedirectType 
  ): never; 
   
  /** 
   * This function allows you to redirect the user to another URL. It can be used in 
   * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components), 
   * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and 
   * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations). 
   * 
   * - In a Server Component, this will insert a meta tag to redirect the user to the target page. 
   * - In a Route Handler or Server Action, it will serve a 308/303 to the caller. 
   * 
   * Read more: [Next.js Docs: redirect](https://nextjs.org/docs/app/api-reference/functions/redirect) 
   */ 
  export function permanentRedirect&lt;RouteType&gt;( 
    /** The URL to redirect to */ 
    url: __next_route_internal_types__.RouteImpl&lt;RouteType&gt;, 
    type?: RedirectType 
  ): never; 
} 
 
declare module 'next/form' { 
  import type { FormProps as OriginalFormProps } from 'next/dist/client/form.js' 
 
  type FormRestProps = Omit&lt;OriginalFormProps, 'action'&gt; 
 
  export type FormProps&lt;RouteInferType&gt; = { 
    /** 
     * </span><span class="s5">\`</span><span class="s0">action</span><span class="s5">\` </span><span class="s0">can be either a </span><span class="s5">\`</span><span class="s0">string</span><span class="s5">\` </span><span class="s0">or a function. 
     * - If </span><span class="s5">\`</span><span class="s0">action</span><span class="s5">\` </span><span class="s0">is a string, it will be interpreted as a path or URL to navigate to when the form is submitted. 
     *   The path will be prefetched when the form becomes visible. 
     * - If </span><span class="s5">\`</span><span class="s0">action</span><span class="s5">\` </span><span class="s0">is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more. 
     */ 
    action: __next_route_internal_types__.RouteImpl&lt;RouteInferType&gt; | ((formData: FormData) =&gt; void) 
  } &amp; FormRestProps 
 
  export default function Form&lt;RouteType&gt;(props: FormProps&lt;RouteType&gt;): JSX.Element 
} 
`</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateValidatorFile(routesManifest) {</span>
    <span class="s2">const </span><span class="s1">generateValidations = (paths, type, pathToRouteMap)=&gt;paths.sort()</span><span class="s4">// Only validate TypeScript files - JavaScript files have too many type inference limitations</span>
        <span class="s1">.filter((filePath)=&gt;filePath.endsWith(</span><span class="s0">'.ts'</span><span class="s1">) || filePath.endsWith(</span><span class="s0">'.tsx'</span><span class="s1">)).filter(</span><span class="s4">// Don't include metadata routes or pages</span>
        <span class="s4">// (e.g. /manifest.webmanifest)</span>
        <span class="s1">(filePath)=&gt;type !== </span><span class="s0">'AppPageConfig' </span><span class="s1">|| filePath.endsWith(</span><span class="s0">'page.ts'</span><span class="s1">) || filePath.endsWith(</span><span class="s0">'page.tsx'</span><span class="s1">)).map((filePath)=&gt;{</span>
            <span class="s4">// Keep the file extension for TypeScript imports to support node16 module resolution</span>
            <span class="s2">const </span><span class="s1">importPath = filePath;</span>
            <span class="s2">const </span><span class="s1">route = pathToRouteMap == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: pathToRouteMap.get(filePath);</span>
            <span class="s2">const </span><span class="s1">typeWithRoute = route &amp;&amp; (type === </span><span class="s0">'AppPageConfig' </span><span class="s1">|| type === </span><span class="s0">'LayoutConfig' </span><span class="s1">|| type === </span><span class="s0">'RouteHandlerConfig'</span><span class="s1">) ? </span><span class="s0">`</span><span class="s1">${type}</span><span class="s0">&lt;</span><span class="s1">${JSON.stringify(route)}</span><span class="s0">&gt;` </span><span class="s1">: type;</span>
            <span class="s2">return </span><span class="s0">`// Validate </span><span class="s1">${filePath}</span>
<span class="s0">{ 
  type __IsExpected&lt;Specific extends </span><span class="s1">${typeWithRoute}</span><span class="s0">&gt; = Specific 
  const handler = {} as typeof import(</span><span class="s1">${JSON.stringify(importPath.replace(</span><span class="s6">/\.tsx?$/</span><span class="s1">, </span><span class="s0">'.js'</span><span class="s1">))}</span><span class="s0">) 
  type __Check = __IsExpected&lt;typeof handler&gt; 
  // @ts-ignore 
  type __Unused = __Check 
}`</span><span class="s1">;</span>
        <span class="s1">}).join(</span><span class="s0">'</span><span class="s5">\n\n</span><span class="s0">'</span><span class="s1">);</span>
    <span class="s4">// Use direct mappings from the manifest</span>
    <span class="s4">// Generate validations for different route types</span>
    <span class="s2">const </span><span class="s1">appPageValidations = generateValidations(Array.from(routesManifest.appPagePaths).sort(), </span><span class="s0">'AppPageConfig'</span><span class="s1">, routesManifest.filePathToRoute);</span>
    <span class="s2">const </span><span class="s1">appRouteHandlerValidations = generateValidations(Array.from(routesManifest.appRouteHandlers).sort(), </span><span class="s0">'RouteHandlerConfig'</span><span class="s1">, routesManifest.filePathToRoute);</span>
    <span class="s2">const </span><span class="s1">pagesRouterPageValidations = generateValidations(Array.from(routesManifest.pagesRouterPagePaths).sort(), </span><span class="s0">'PagesPageConfig'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">pagesApiRouteValidations = generateValidations(Array.from(routesManifest.pageApiRoutes).sort(), </span><span class="s0">'ApiRouteConfig'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">layoutValidations = generateValidations(Array.from(routesManifest.layoutPaths).sort(), </span><span class="s0">'LayoutConfig'</span><span class="s1">, routesManifest.filePathToRoute);</span>
    <span class="s2">const </span><span class="s1">hasAppRouteHandlers = Object.keys(routesManifest.appRouteHandlerRoutes).length &gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s4">// Build type definitions based on what's actually used</span>
    <span class="s2">let </span><span class="s1">typeDefinitions = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(appPageValidations) {</span>
        <span class="s1">typeDefinitions += </span><span class="s0">`type AppPageConfig&lt;Route extends AppRoutes = AppRoutes&gt; = { 
  default: React.ComponentType&lt;{ params: Promise&lt;ParamMap[Route]&gt; } &amp; any&gt; | ((props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any) =&gt; React.ReactNode | Promise&lt;React.ReactNode&gt; | never | void | Promise&lt;void&gt;) 
  generateStaticParams?: (props: { params: ParamMap[Route] }) =&gt; Promise&lt;any[]&gt; | any[] 
  generateMetadata?: ( 
    props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any, 
    parent: ResolvingMetadata 
  ) =&gt; Promise&lt;any&gt; | any 
  generateViewport?: ( 
    props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any, 
    parent: ResolvingViewport 
  ) =&gt; Promise&lt;any&gt; | any 
  metadata?: any 
  viewport?: any 
} 
 
`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(pagesRouterPageValidations) {</span>
        <span class="s1">typeDefinitions += </span><span class="s0">`type PagesPageConfig = { 
  default: React.ComponentType&lt;any&gt; | ((props: any) =&gt; React.ReactNode | Promise&lt;React.ReactNode&gt; | never | void) 
  getStaticProps?: (context: any) =&gt; Promise&lt;any&gt; | any 
  getStaticPaths?: (context: any) =&gt; Promise&lt;any&gt; | any 
  getServerSideProps?: (context: any) =&gt; Promise&lt;any&gt; | any 
  getInitialProps?: (context: any) =&gt; Promise&lt;any&gt; | any 
  /** 
   * Segment configuration for legacy Pages Router pages. 
   * Validated at build-time by parsePagesSegmentConfig. 
   */ 
  config?: { 
    amp?: boolean | 'hybrid' | string // necessary for JS 
    maxDuration?: number 
    runtime?: 'edge' | 'experimental-edge' | 'nodejs' | string // necessary unless config is exported as const 
    regions?: string[] 
  } 
} 
 
`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(layoutValidations) {</span>
        <span class="s1">typeDefinitions += </span><span class="s0">`type LayoutConfig&lt;Route extends LayoutRoutes = LayoutRoutes&gt; = { 
  default: React.ComponentType&lt;LayoutProps&lt;Route&gt;&gt; | ((props: LayoutProps&lt;Route&gt;) =&gt; React.ReactNode | Promise&lt;React.ReactNode&gt; | never | void | Promise&lt;void&gt;) 
  generateStaticParams?: (props: { params: ParamMap[Route] }) =&gt; Promise&lt;any[]&gt; | any[] 
  generateMetadata?: ( 
    props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any, 
    parent: ResolvingMetadata 
  ) =&gt; Promise&lt;any&gt; | any 
  generateViewport?: ( 
    props: { params: Promise&lt;ParamMap[Route]&gt; } &amp; any, 
    parent: ResolvingViewport 
  ) =&gt; Promise&lt;any&gt; | any 
  metadata?: any 
  viewport?: any 
} 
 
`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(appRouteHandlerValidations) {</span>
        <span class="s1">typeDefinitions += </span><span class="s0">`type RouteHandlerConfig&lt;Route extends AppRouteHandlerRoutes = AppRouteHandlerRoutes&gt; = { 
  GET?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void 
  POST?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void 
  PUT?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void 
  PATCH?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void 
  DELETE?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void 
  HEAD?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void 
  OPTIONS?: (request: NextRequest, context: { params: Promise&lt;ParamMap[Route]&gt; }) =&gt; Promise&lt;Response | void&gt; | Response | void 
} 
 
`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(pagesApiRouteValidations) {</span>
        <span class="s1">typeDefinitions += </span><span class="s0">`type ApiRouteConfig = { 
  default: (req: any, res: any) =&gt; ReturnType&lt;NextApiHandler&gt; 
  config?: { 
    api?: { 
      bodyParser?: boolean | { sizeLimit?: string } 
      responseLimit?: string | number | boolean 
      externalResolver?: boolean 
    } 
    runtime?: 'edge' | 'experimental-edge' | 'nodejs' | string // necessary unless config is exported as const 
    maxDuration?: number 
  } 
} 
 
`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Build import statement based on what's actually needed</span>
    <span class="s2">const </span><span class="s1">routeImports = [];</span>
    <span class="s4">// Only import AppRoutes if there are app pages</span>
    <span class="s2">if </span><span class="s1">(appPageValidations) {</span>
        <span class="s1">routeImports.push(</span><span class="s0">'AppRoutes'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">// Only import LayoutRoutes if there are layouts</span>
    <span class="s2">if </span><span class="s1">(layoutValidations) {</span>
        <span class="s1">routeImports.push(</span><span class="s0">'LayoutRoutes'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">// Only import ParamMap if there are routes that use it</span>
    <span class="s2">if </span><span class="s1">(appPageValidations || layoutValidations || appRouteHandlerValidations) {</span>
        <span class="s1">routeImports.push(</span><span class="s0">'ParamMap'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(hasAppRouteHandlers) {</span>
        <span class="s1">routeImports.push(</span><span class="s0">'AppRouteHandlerRoutes'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">routeImportStatement = routeImports.length &gt; </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">`import type { </span><span class="s1">${routeImports.join(</span><span class="s0">', '</span><span class="s1">)} </span><span class="s0">} from &quot;./routes.js&quot;` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">nextRequestImport = hasAppRouteHandlers ? </span><span class="s0">&quot;import type { NextRequest } from 'next/server.js'</span><span class="s5">\n</span><span class="s0">&quot; </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s4">// Conditionally import types from next/types, merged into a single statement</span>
    <span class="s2">const </span><span class="s1">nextTypes = [];</span>
    <span class="s2">if </span><span class="s1">(pagesApiRouteValidations) {</span>
        <span class="s1">nextTypes.push(</span><span class="s0">'NextApiHandler'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(appPageValidations || layoutValidations) {</span>
        <span class="s1">nextTypes.push(</span><span class="s0">'ResolvingMetadata'</span><span class="s1">, </span><span class="s0">'ResolvingViewport'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">nextTypesImport = nextTypes.length &gt; </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">`import type { </span><span class="s1">${nextTypes.join(</span><span class="s0">', '</span><span class="s1">)} </span><span class="s0">} from &quot;next/types.js&quot;</span><span class="s5">\n</span><span class="s0">` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s0">`// This file is generated automatically by Next.js 
// Do not edit this file manually 
// This file validates that all pages and layouts export the correct types 
 
</span><span class="s1">${routeImportStatement}</span>
<span class="s1">${nextTypesImport}${nextRequestImport}</span>
<span class="s1">${typeDefinitions}</span>
<span class="s1">${appPageValidations}</span>

<span class="s1">${appRouteHandlerValidations}</span>

<span class="s1">${pagesRouterPageValidations}</span>

<span class="s1">${pagesApiRouteValidations}</span>

<span class="s1">${layoutValidations}</span>
<span class="s0">`</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateRouteTypesFile(routesManifest) {</span>
    <span class="s2">const </span><span class="s1">routeTypes = generateRouteTypes(routesManifest);</span>
    <span class="s2">const </span><span class="s1">paramTypes = generateParamTypes(routesManifest);</span>
    <span class="s2">const </span><span class="s1">layoutSlotMap = generateLayoutSlotMap(routesManifest);</span>
    <span class="s2">const </span><span class="s1">hasAppRouteHandlers = Object.keys(routesManifest.appRouteHandlerRoutes).length &gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s4">// Build export statement based on what's actually generated</span>
    <span class="s2">const </span><span class="s1">routeExports = [</span>
        <span class="s0">'AppRoutes'</span><span class="s1">,</span>
        <span class="s0">'PageRoutes'</span><span class="s1">,</span>
        <span class="s0">'LayoutRoutes'</span><span class="s1">,</span>
        <span class="s0">'RedirectRoutes'</span><span class="s1">,</span>
        <span class="s0">'RewriteRoutes'</span><span class="s1">,</span>
        <span class="s0">'ParamMap'</span>
    <span class="s1">];</span>
    <span class="s2">if </span><span class="s1">(hasAppRouteHandlers) {</span>
        <span class="s1">routeExports.push(</span><span class="s0">'AppRouteHandlerRoutes'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">exportStatement = </span><span class="s0">`export type { </span><span class="s1">${routeExports.join(</span><span class="s0">', '</span><span class="s1">)} </span><span class="s0">}`</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">routeContextInterface = hasAppRouteHandlers ? </span><span class="s0">`</span>

  <span class="s0">/** 
   * Context for Next.js App Router route handlers 
   * @example 
   * </span><span class="s5">\`\`\`</span><span class="s0">tsx 
   * export async function GET(request: NextRequest, context: RouteContext&lt;'/api/users/[id]'&gt;) { 
   *   const { id } = await context.params 
   *   return Response.json({ id }) 
   * } 
   * </span><span class="s5">\`\`\`</span>
   <span class="s0">*/ 
  interface RouteContext&lt;AppRouteHandlerRoute extends AppRouteHandlerRoutes&gt; { 
    params: Promise&lt;ParamMap[AppRouteHandlerRoute]&gt; 
  }` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s0">`// This file is generated automatically by Next.js 
// Do not edit this file manually 
 
</span><span class="s1">${routeTypes}</span>

<span class="s1">${paramTypes}</span>

<span class="s0">export type ParamsOf&lt;Route extends Routes&gt; = ParamMap[Route] 
 
</span><span class="s1">${layoutSlotMap}</span>

<span class="s1">${exportStatement}</span>

<span class="s0">declare global { 
  /** 
   * Props for Next.js App Router page components 
   * @example 
   * </span><span class="s5">\`\`\`</span><span class="s0">tsx 
   * export default function Page(props: PageProps&lt;'/blog/[slug]'&gt;) { 
   *   const { slug } = await props.params 
   *   return &lt;div&gt;Blog post: {slug}&lt;/div&gt; 
   * } 
   * </span><span class="s5">\`\`\`</span>
   <span class="s0">*/ 
  interface PageProps&lt;AppRoute extends AppRoutes&gt; { 
    params: Promise&lt;ParamMap[AppRoute]&gt; 
    searchParams: Promise&lt;Record&lt;string, string | string[] | undefined&gt;&gt; 
  } 
 
  /** 
   * Props for Next.js App Router layout components 
   * @example 
   * </span><span class="s5">\`\`\`</span><span class="s0">tsx 
   * export default function Layout(props: LayoutProps&lt;'/dashboard'&gt;) { 
   *   return &lt;div&gt;{props.children}&lt;/div&gt; 
   * } 
   * </span><span class="s5">\`\`\`</span>
   <span class="s0">*/ 
  type LayoutProps&lt;LayoutRoute extends LayoutRoutes&gt; = { 
    params: Promise&lt;ParamMap[LayoutRoute]&gt; 
    children: React.ReactNode 
  } &amp; { 
    [K in LayoutSlotMap[LayoutRoute]]: React.ReactNode 
  }</span><span class="s1">${routeContextInterface}</span>
<span class="s0">} 
`</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=typegen.js.map</span></pre>
</body>
</html>