<html>
<head>
<title>patch-error-inspect.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
.s6 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
patch-error-inspect.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">patchErrorInspectEdgeLite: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">patchErrorInspectNodeJS: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">setBundlerFindSourceMapImplementation: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">patchErrorInspectEdgeLite: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">patchErrorInspectEdgeLite;</span>
    <span class="s1">},</span>
    <span class="s1">patchErrorInspectNodeJS: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">patchErrorInspectNodeJS;</span>
    <span class="s1">},</span>
    <span class="s1">setBundlerFindSourceMapImplementation: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">setBundlerFindSourceMapImplementation;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_module = require(</span><span class="s0">&quot;module&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_url = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;url&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_sourcemap = require(</span><span class="s0">&quot;next/dist/compiled/source-map&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_sourcemaps = require(</span><span class="s0">&quot;./lib/source-maps&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parsestack = require(</span><span class="s0">&quot;./lib/parse-stack&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_shared = require(</span><span class="s0">&quot;../next-devtools/server/shared&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;./app-render/work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_picocolors = require(</span><span class="s0">&quot;../lib/picocolors&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s4">// Find a source map using the bundler's API.</span>
<span class="s4">// This is only a fallback for when Node.js fails to due to bugs e.g. https://github.com/nodejs/node/issues/52102</span>
<span class="s4">// TODO: Remove once all supported Node.js versions are fixed.</span>
<span class="s4">// TODO(veil): Set from Webpack as well</span>
<span class="s2">let </span><span class="s1">bundlerFindSourceMapPayload = ()=&gt;undefined;</span>
<span class="s2">function </span><span class="s1">setBundlerFindSourceMapImplementation(findSourceMapImplementation) {</span>
    <span class="s1">bundlerFindSourceMapPayload = findSourceMapImplementation;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">frameToString(methodName, sourceURL, line1, column1) {</span>
    <span class="s2">let </span><span class="s1">sourceLocation = line1 !== </span><span class="s2">null </span><span class="s1">? </span><span class="s0">`:</span><span class="s1">${line1}</span><span class="s0">` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(column1 !== </span><span class="s2">null </span><span class="s1">&amp;&amp; sourceLocation !== </span><span class="s0">''</span><span class="s1">) {</span>
        <span class="s1">sourceLocation += </span><span class="s0">`:</span><span class="s1">${column1}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">fileLocation;</span>
    <span class="s2">if </span><span class="s1">(sourceURL !== </span><span class="s2">null </span><span class="s1">&amp;&amp; sourceURL.startsWith(</span><span class="s0">'file://'</span><span class="s1">) &amp;&amp; URL.canParse(sourceURL)) {</span>
        <span class="s4">// If not relative to CWD, the path is ambiguous to IDEs and clicking will prompt to select the file first.</span>
        <span class="s4">// In a multi-app repo, this leads to potentially larger file names but will make clicking snappy.</span>
        <span class="s4">// There's no tradeoff for the cases where `dir` in `next dev [dir]` is omitted</span>
        <span class="s4">// since relative to cwd is both the shortest and snappiest.</span>
        <span class="s1">fileLocation = _path.relative(process.cwd(), _url.fileURLToPath(sourceURL));</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(sourceURL !== </span><span class="s2">null </span><span class="s1">&amp;&amp; sourceURL.startsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
        <span class="s1">fileLocation = _path.relative(process.cwd(), sourceURL);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">fileLocation = sourceURL;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">methodName ? </span><span class="s0">`    at </span><span class="s1">${methodName} </span><span class="s0">(</span><span class="s1">${fileLocation}${sourceLocation}</span><span class="s0">)` </span><span class="s1">: </span><span class="s0">`    at </span><span class="s1">${fileLocation}${sourceLocation}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">computeErrorName(error) {</span>
    <span class="s4">// TODO: Node.js seems to use a different algorithm</span>
    <span class="s4">// class ReadonlyRequestCookiesError extends Error {}` would read `ReadonlyRequestCookiesError: [...]`</span>
    <span class="s4">// in the stack i.e. seems like under certain conditions it favors the constructor name.</span>
    <span class="s2">return </span><span class="s1">error.name || </span><span class="s0">'Error'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">prepareUnsourcemappedStackTrace(error, structuredStackTrace) {</span>
    <span class="s2">const </span><span class="s1">name = computeErrorName(error);</span>
    <span class="s2">const </span><span class="s1">message = error.message || </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">stack = name + </span><span class="s0">': ' </span><span class="s1">+ message;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; structuredStackTrace.length; i++){</span>
        <span class="s1">stack += </span><span class="s0">'</span><span class="s5">\n    </span><span class="s0">at ' </span><span class="s1">+ structuredStackTrace[i].toString();</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">stack;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shouldIgnoreListGeneratedFrame(file) {</span>
    <span class="s2">return </span><span class="s1">file.startsWith(</span><span class="s0">'node:'</span><span class="s1">) || file.includes(</span><span class="s0">'node_modules'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shouldIgnoreListOriginalFrame(file) {</span>
    <span class="s2">return </span><span class="s1">file.includes(</span><span class="s0">'node_modules'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createUnsourcemappedFrame(frame) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">stack: {</span>
            <span class="s1">file: frame.file,</span>
            <span class="s1">line1: frame.line1,</span>
            <span class="s1">column1: frame.column1,</span>
            <span class="s1">methodName: frame.methodName,</span>
            <span class="s1">arguments: frame.arguments,</span>
            <span class="s1">ignored: shouldIgnoreListGeneratedFrame(frame.file)</span>
        <span class="s1">},</span>
        <span class="s1">code: </span><span class="s2">null</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ignoreListAnonymousStackFramesIfSandwiched(sourceMappedFrames) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _sourcemaps.ignoreListAnonymousStackFramesIfSandwiched)(sourceMappedFrames, (frame)=&gt;frame.stack.file === </span><span class="s0">'&lt;anonymous&gt;'</span><span class="s1">, (frame)=&gt;frame.stack.ignored, (frame)=&gt;frame.stack.methodName, (frame)=&gt;{</span>
        <span class="s1">frame.stack.ignored = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* </span><span class="s6">@param </span><span class="s4">frame</span>
 <span class="s4">* </span><span class="s6">@param </span><span class="s4">sourceMapCache</span>
 <span class="s4">* </span><span class="s6">@returns </span><span class="s4">The original frame if not sourcemapped.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">getSourcemappedFrameIfPossible(frame, sourceMapCache, inspectOptions) {</span>
    <span class="s2">var </span><span class="s1">_frame_methodName_replace, _frame_methodName;</span>
    <span class="s2">const </span><span class="s1">sourceMapCacheEntry = sourceMapCache.get(frame.file);</span>
    <span class="s2">let </span><span class="s1">sourceMapConsumer;</span>
    <span class="s2">let </span><span class="s1">sourceMapPayload;</span>
    <span class="s2">if </span><span class="s1">(sourceMapCacheEntry === undefined) {</span>
        <span class="s2">let </span><span class="s1">sourceURL = frame.file;</span>
        <span class="s4">// e.g. &quot;/APP/.next/server/chunks/ssr/[root-of-the-server]__2934a0._.js&quot;</span>
        <span class="s4">// will be keyed by Node.js as &quot;file:///APP/.next/server/chunks/ssr/[root-of-the-server]__2934a0._.js&quot;.</span>
        <span class="s4">// This is likely caused by `callsite.toString()` in `Error.prepareStackTrace converting file URLs to paths.</span>
        <span class="s2">if </span><span class="s1">(sourceURL.startsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
            <span class="s1">sourceURL = _url.pathToFileURL(frame.file).toString();</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">maybeSourceMapPayload;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">sourceMap = (</span><span class="s3">0</span><span class="s1">, _module.findSourceMap)(sourceURL);</span>
            <span class="s1">maybeSourceMapPayload = sourceMap == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: sourceMap.payload;</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(cause) {</span>
            <span class="s4">// We should not log an actual error instance here because that will re-enter</span>
            <span class="s4">// this codepath during error inspection and could lead to infinite recursion.</span>
            <span class="s1">console.error(</span><span class="s0">`</span><span class="s1">${sourceURL}</span><span class="s0">: Invalid source map. Only conformant source maps can be used to find the original code. Cause: </span><span class="s1">${cause}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s4">// If loading fails once, it'll fail every time.</span>
            <span class="s4">// So set the cache to avoid duplicate errors.</span>
            <span class="s1">sourceMapCache.set(frame.file, </span><span class="s2">null</span><span class="s1">);</span>
            <span class="s4">// Don't even fall back to the bundler because it might be not as strict</span>
            <span class="s4">// with regards to parsing and then we fail later once we consume the</span>
            <span class="s4">// source map payload.</span>
            <span class="s4">// This essentially avoids a redundant error where we fail here and then</span>
            <span class="s4">// later on consumption because the bundler just handed back an invalid</span>
            <span class="s4">// source map.</span>
            <span class="s2">return </span><span class="s1">createUnsourcemappedFrame(frame);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(maybeSourceMapPayload === undefined) {</span>
            <span class="s1">maybeSourceMapPayload = bundlerFindSourceMapPayload(sourceURL);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(maybeSourceMapPayload === undefined) {</span>
            <span class="s2">return </span><span class="s1">createUnsourcemappedFrame(frame);</span>
        <span class="s1">}</span>
        <span class="s1">sourceMapPayload = maybeSourceMapPayload;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">sourceMapConsumer = </span><span class="s2">new </span><span class="s1">_sourcemap.SourceMapConsumer(</span><span class="s4">// @ts-expect-error -- Module.SourceMap['version'] is number but SyncSourceMapConsumer wants a string</span>
            <span class="s1">sourceMapPayload);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(cause) {</span>
            <span class="s4">// We should not log an actual error instance here because that will re-enter</span>
            <span class="s4">// this codepath during error inspection and could lead to infinite recursion.</span>
            <span class="s1">console.error(</span><span class="s0">`</span><span class="s1">${sourceURL}</span><span class="s0">: Invalid source map. Only conformant source maps can be used to find the original code. Cause: </span><span class="s1">${cause}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s4">// If creating the consumer fails once, it'll fail every time.</span>
            <span class="s4">// So set the cache to avoid duplicate errors.</span>
            <span class="s1">sourceMapCache.set(frame.file, </span><span class="s2">null</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">createUnsourcemappedFrame(frame);</span>
        <span class="s1">}</span>
        <span class="s1">sourceMapCache.set(frame.file, {</span>
            <span class="s1">map: sourceMapConsumer,</span>
            <span class="s1">payload: sourceMapPayload</span>
        <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(sourceMapCacheEntry === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s4">// We failed earlier getting the payload or consumer.</span>
        <span class="s4">// Just return an unsourcemapped frame.</span>
        <span class="s4">// Errors will already be logged.</span>
        <span class="s2">return </span><span class="s1">createUnsourcemappedFrame(frame);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">sourceMapConsumer = sourceMapCacheEntry.map;</span>
        <span class="s1">sourceMapPayload = sourceMapCacheEntry.payload;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">sourcePosition = sourceMapConsumer.originalPositionFor({</span>
        <span class="s1">column: (frame.column1 ?? </span><span class="s3">1</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">,</span>
        <span class="s1">line: frame.line1 ?? </span><span class="s3">1</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">applicableSourceMap = (</span><span class="s3">0</span><span class="s1">, _sourcemaps.findApplicableSourceMapPayload)((frame.line1 ?? </span><span class="s3">1</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">, (frame.column1 ?? </span><span class="s3">1</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">, sourceMapPayload);</span>
    <span class="s2">let </span><span class="s1">ignored = applicableSourceMap !== undefined &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _sourcemaps.sourceMapIgnoreListsEverything)(applicableSourceMap);</span>
    <span class="s2">if </span><span class="s1">(sourcePosition.source === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">stack: {</span>
                <span class="s1">arguments: frame.arguments,</span>
                <span class="s1">file: frame.file,</span>
                <span class="s1">line1: frame.line1,</span>
                <span class="s1">column1: frame.column1,</span>
                <span class="s1">methodName: frame.methodName,</span>
                <span class="s1">ignored: ignored || shouldIgnoreListGeneratedFrame(frame.file)</span>
            <span class="s1">},</span>
            <span class="s1">code: </span><span class="s2">null</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s4">// TODO(veil): Upstream a method to sourcemap consumer that immediately says if a frame is ignored or not.</span>
    <span class="s2">if </span><span class="s1">(applicableSourceMap === undefined) {</span>
        <span class="s1">console.error(</span><span class="s0">'No applicable source map found in sections for frame'</span><span class="s1">, frame);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!ignored &amp;&amp; shouldIgnoreListOriginalFrame(sourcePosition.source)) {</span>
        <span class="s4">// Externals may be libraries that don't ship ignoreLists.</span>
        <span class="s4">// This is really taking control away from libraries.</span>
        <span class="s4">// They should still ship `ignoreList` so that attached debuggers ignore-list their frames.</span>
        <span class="s4">// TODO: Maybe only ignore library sourcemaps if `ignoreList` is absent?</span>
        <span class="s4">// Though keep in mind that Turbopack omits empty `ignoreList`.</span>
        <span class="s4">// So if we establish this convention, we should communicate it to the ecosystem.</span>
        <span class="s1">ignored = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!ignored) {</span>
        <span class="s2">var </span><span class="s1">_applicableSourceMap_ignoreList;</span>
        <span class="s4">// TODO: O(n^2). Consider moving `ignoreList` into a Set</span>
        <span class="s2">const </span><span class="s1">sourceIndex = applicableSourceMap.sources.indexOf(sourcePosition.source);</span>
        <span class="s1">ignored = ((_applicableSourceMap_ignoreList = applicableSourceMap.ignoreList) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _applicableSourceMap_ignoreList.includes(sourceIndex)) ?? </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">originalFrame = {</span>
        <span class="s4">// We ignore the sourcemapped name since it won't be the correct name.</span>
        <span class="s4">// The callsite will point to the column of the variable name instead of the</span>
        <span class="s4">// name of the enclosing function.</span>
        <span class="s4">// TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.</span>
        <span class="s1">methodName: (_frame_methodName = frame.methodName) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_frame_methodName_replace = _frame_methodName.replace(</span><span class="s0">'__WEBPACK_DEFAULT_EXPORT__'</span><span class="s1">, </span><span class="s0">'default'</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _frame_methodName_replace.replace(</span><span class="s0">'__webpack_exports__.'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">),</span>
        <span class="s1">file: sourcePosition.source,</span>
        <span class="s1">line1: sourcePosition.line,</span>
        <span class="s1">column1: sourcePosition.column + </span><span class="s3">1</span><span class="s1">,</span>
        <span class="s4">// TODO: c&amp;p from async createOriginalStackFrame but why not frame.arguments?</span>
        <span class="s1">arguments: [],</span>
        <span class="s1">ignored</span>
    <span class="s1">};</span>
    <span class="s4">/** undefined = not yet computed*/ </span><span class="s2">let </span><span class="s1">codeFrame;</span>
    <span class="s2">return </span><span class="s1">Object.defineProperty({</span>
        <span class="s1">stack: originalFrame,</span>
        <span class="s1">code: </span><span class="s2">null</span>
    <span class="s1">}, </span><span class="s0">'code'</span><span class="s1">, {</span>
        <span class="s1">get: ()=&gt;{</span>
            <span class="s2">if </span><span class="s1">(codeFrame === undefined) {</span>
                <span class="s2">const </span><span class="s1">sourceContent = sourceMapConsumer.sourceContentFor(sourcePosition.source, </span><span class="s4">/* returnNullOnMissing */ </span><span class="s2">true</span><span class="s1">) ?? </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s1">codeFrame = (</span><span class="s3">0</span><span class="s1">, _shared.getOriginalCodeFrame)(originalFrame, sourceContent, inspectOptions.colors);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">codeFrame;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseAndSourceMap(error, inspectOptions) {</span>
    <span class="s4">// TODO(veil): Expose as CLI arg or config option. Useful for local debugging.</span>
    <span class="s2">const </span><span class="s1">showIgnoreListed = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s4">// We overwrote Error.prepareStackTrace earlier so error.stack is not sourcemapped.</span>
    <span class="s2">let </span><span class="s1">unparsedStack = String(error.stack);</span>
    <span class="s4">// We could just read it from `error.stack`.</span>
    <span class="s4">// This works around cases where a 3rd party `Error.prepareStackTrace` implementation</span>
    <span class="s4">// doesn't implement the name computation correctly.</span>
    <span class="s2">const </span><span class="s1">errorName = computeErrorName(error);</span>
    <span class="s2">let </span><span class="s1">idx = unparsedStack.indexOf(</span><span class="s0">'react_stack_bottom_frame'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(idx !== -</span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s1">idx = unparsedStack.lastIndexOf(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">, idx);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">idx = unparsedStack.indexOf(</span><span class="s0">'react-stack-bottom-frame'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(idx !== -</span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s1">idx = unparsedStack.lastIndexOf(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">, idx);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(idx !== -</span><span class="s3">1 </span><span class="s1">&amp;&amp; !showIgnoreListed) {</span>
        <span class="s4">// Cut off everything after the bottom frame since it'll be React internals.</span>
        <span class="s1">unparsedStack = unparsedStack.slice(</span><span class="s3">0</span><span class="s1">, idx);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">unsourcemappedStack = (</span><span class="s3">0</span><span class="s1">, _parsestack.parseStack)(unparsedStack);</span>
    <span class="s2">const </span><span class="s1">sourceMapCache = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">const </span><span class="s1">sourceMappedFrames = [];</span>
    <span class="s2">let </span><span class="s1">sourceFrame = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">frame of unsourcemappedStack){</span>
        <span class="s2">if </span><span class="s1">(frame.file === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">sourceMappedFrames.push({</span>
                <span class="s1">code: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">stack: {</span>
                    <span class="s1">file: frame.file,</span>
                    <span class="s1">line1: frame.line1,</span>
                    <span class="s1">column1: frame.column1,</span>
                    <span class="s1">methodName: frame.methodName,</span>
                    <span class="s1">arguments: frame.arguments,</span>
                    <span class="s1">ignored: </span><span class="s2">false</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">sourcemappedFrame = getSourcemappedFrameIfPossible(</span><span class="s4">// We narrowed this earlier by bailing if `frame.file` is null.</span>
            <span class="s1">frame, sourceMapCache, inspectOptions);</span>
            <span class="s1">sourceMappedFrames.push(sourcemappedFrame);</span>
            <span class="s4">// We can determine the sourceframe here.</span>
            <span class="s4">// anonymous frames won't have a sourceframe so we don't need to scan</span>
            <span class="s4">// all stacks again to check if they are sandwiched between ignored frames.</span>
            <span class="s2">if </span><span class="s1">(sourceFrame === </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s4">// TODO: Is this the right choice?</span>
            <span class="s1">!sourcemappedFrame.stack.ignored &amp;&amp; sourcemappedFrame.code !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">sourceFrame = sourcemappedFrame.code;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">ignoreListAnonymousStackFramesIfSandwiched(sourceMappedFrames);</span>
    <span class="s2">let </span><span class="s1">sourceMappedStack = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; sourceMappedFrames.length; i++){</span>
        <span class="s2">const </span><span class="s1">frame = sourceMappedFrames[i];</span>
        <span class="s2">if </span><span class="s1">(!frame.stack.ignored) {</span>
            <span class="s1">sourceMappedStack += </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ frameToString(frame.stack.methodName, frame.stack.file, frame.stack.line1, frame.stack.column1);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(showIgnoreListed) {</span>
            <span class="s1">sourceMappedStack += </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ (</span><span class="s3">0</span><span class="s1">, _picocolors.dim)(frameToString(frame.stack.methodName, frame.stack.file, frame.stack.line1, frame.stack.column1));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">errorName + </span><span class="s0">': ' </span><span class="s1">+ error.message + sourceMappedStack + (sourceFrame !== </span><span class="s2">null </span><span class="s1">? </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ sourceFrame : </span><span class="s0">''</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sourceMapError(error, inspectOptions) {</span>
    <span class="s4">// Create a new Error object with the source mapping applied and then use native</span>
    <span class="s4">// Node.js formatting on the result.</span>
    <span class="s2">const </span><span class="s1">newError = error.cause !== undefined ? Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(error.message, {</span>
        <span class="s1">cause: error.cause</span>
    <span class="s1">}), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">}) : Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(error.message), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s4">// TODO: Ensure `class MyError extends Error {}` prints `MyError` as the name</span>
    <span class="s1">newError.stack = parseAndSourceMap(error, inspectOptions);</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">error){</span>
        <span class="s2">if </span><span class="s1">(!Object.prototype.hasOwnProperty.call(newError, key)) {</span>
            <span class="s4">// @ts-expect-error -- We're copying all enumerable properties.</span>
            <span class="s4">// So they definitely exist on `this` and obviously have no type on `newError` (yet)</span>
            <span class="s1">newError[key] = error[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newError;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchErrorInspectNodeJS(errorConstructor) {</span>
    <span class="s2">const </span><span class="s1">inspectSymbol = Symbol.for(</span><span class="s0">'nodejs.util.inspect.custom'</span><span class="s1">);</span>
    <span class="s1">errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace;</span>
    <span class="s4">// @ts-expect-error -- TODO upstream types</span>
    <span class="s4">// eslint-disable-next-line no-extend-native -- We're not extending but overriding.</span>
    <span class="s1">errorConstructor.prototype[inspectSymbol] = </span><span class="s2">function</span><span class="s1">(depth, inspectOptions, inspect) {</span>
        <span class="s4">// avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.</span>
        <span class="s2">return </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.exit(()=&gt;{</span>
            <span class="s2">const </span><span class="s1">newError = sourceMapError(</span><span class="s2">this</span><span class="s1">, inspectOptions);</span>
            <span class="s2">const </span><span class="s1">originalCustomInspect = newError[inspectSymbol];</span>
            <span class="s4">// Prevent infinite recursion.</span>
            <span class="s4">// { customInspect: false } would result in `error.cause` not using our inspect.</span>
            <span class="s1">Object.defineProperty(newError, inspectSymbol, {</span>
                <span class="s1">value: undefined,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">writable: </span><span class="s2">true</span>
            <span class="s1">});</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">inspect(newError, {</span>
                    <span class="s1">...inspectOptions,</span>
                    <span class="s1">depth: (inspectOptions.depth ?? </span><span class="s4">// Default in Node.js</span>
                    <span class="s3">2</span><span class="s1">) - depth</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                <span class="s1">;</span>
                <span class="s1">newError[inspectSymbol] = originalCustomInspect;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchErrorInspectEdgeLite(errorConstructor) {</span>
    <span class="s2">const </span><span class="s1">inspectSymbol = Symbol.for(</span><span class="s0">'edge-runtime.inspect.custom'</span><span class="s1">);</span>
    <span class="s1">errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace;</span>
    <span class="s4">// @ts-expect-error -- TODO upstream types</span>
    <span class="s4">// eslint-disable-next-line no-extend-native -- We're not extending but overriding.</span>
    <span class="s1">errorConstructor.prototype[inspectSymbol] = </span><span class="s2">function</span><span class="s1">({ format }) {</span>
        <span class="s4">// avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.</span>
        <span class="s2">return </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.exit(()=&gt;{</span>
            <span class="s2">const </span><span class="s1">newError = sourceMapError(</span><span class="s2">this</span><span class="s1">, {});</span>
            <span class="s2">const </span><span class="s1">originalCustomInspect = newError[inspectSymbol];</span>
            <span class="s4">// Prevent infinite recursion.</span>
            <span class="s1">Object.defineProperty(newError, inspectSymbol, {</span>
                <span class="s1">value: undefined,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">writable: </span><span class="s2">true</span>
            <span class="s1">});</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">format(newError);</span>
            <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                <span class="s1">;</span>
                <span class="s1">newError[inspectSymbol] = originalCustomInspect;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=patch-error-inspect.js.map</span></pre>
</body>
</html>