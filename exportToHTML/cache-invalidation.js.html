<html>
<head>
<title>cache-invalidation.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cache-invalidation.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">checkPersistentCacheInvalidationAndCleanup: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">invalidatePersistentCache: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">checkPersistentCacheInvalidationAndCleanup: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">checkPersistentCacheInvalidationAndCleanup;</span>
    <span class="s1">},</span>
    <span class="s1">invalidatePersistentCache: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">invalidatePersistentCache;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_promises = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;node:fs/promises&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_nodepath = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;node:path&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">INVALIDATION_MARKER = </span><span class="s0">'__nextjs_invalidated_cache'</span><span class="s1">;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">invalidatePersistentCache(cacheDirectory) {</span>
    <span class="s2">let </span><span class="s1">file;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s4">// We're just opening it so that `open()` creates the file.</span>
        <span class="s1">file = </span><span class="s2">await </span><span class="s1">_promises.default.open(_nodepath.default.join(cacheDirectory, INVALIDATION_MARKER), </span><span class="s0">'w'</span><span class="s1">);</span>
    <span class="s4">// We don't currently write anything to the file, but we could choose to</span>
    <span class="s4">// later, e.g. a reason for the invalidation.</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s4">// it's valid for the cache to not exist at all</span>
        <span class="s2">if </span><span class="s1">(err.code !== </span><span class="s0">'ENOENT'</span><span class="s1">) {</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
        <span class="s1">file == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: file.close();</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">checkPersistentCacheInvalidationAndCleanup(cacheDirectory) {</span>
    <span class="s2">const </span><span class="s1">invalidated = </span><span class="s2">await </span><span class="s1">_promises.default.access(_nodepath.default.join(cacheDirectory, INVALIDATION_MARKER)).then(()=&gt;</span><span class="s2">true</span><span class="s1">, ()=&gt;</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(invalidated) {</span>
        <span class="s2">await </span><span class="s1">cleanupPersistentCache(cacheDirectory);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Helper for `checkPersistentCacheInvalidationAndCleanup`. You can call this to</span>
 <span class="s4">* explicitly clean up a database after running `invalidatePersistentCache` when</span>
 <span class="s4">* webpack is not running.</span>
 <span class="s4">*</span>
 <span class="s4">* You should not run this if the cache has not yet been invalidated, as this</span>
 <span class="s4">* operation is not atomic and could result in a partially-deleted and corrupted</span>
 <span class="s4">* database.</span>
 <span class="s4">*/ </span><span class="s1">async </span><span class="s2">function </span><span class="s1">cleanupPersistentCache(cacheDirectory) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">await </span><span class="s1">cleanupPersistentCacheInner(cacheDirectory);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s4">// generate a user-friendly error message</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Unable to remove an invalidated webpack cache. If this issue persists ` </span><span class="s1">+ </span><span class="s0">`you can work around it by deleting </span><span class="s1">${cacheDirectory}</span><span class="s0">`</span><span class="s1">, {</span>
            <span class="s1">cause: e</span>
        <span class="s1">}), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E710&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">cleanupPersistentCacheInner(cacheDirectory) {</span>
    <span class="s2">const </span><span class="s1">files = </span><span class="s2">await </span><span class="s1">_promises.default.readdir(cacheDirectory);</span>
    <span class="s4">// delete everything except the invalidation marker</span>
    <span class="s2">await </span><span class="s1">Promise.all(files.map((name)=&gt;name !== INVALIDATION_MARKER ? _promises.default.rm(_nodepath.default.join(cacheDirectory, name), {</span>
            <span class="s1">force: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">recursive: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">maxRetries: </span><span class="s3">2</span>
        <span class="s1">}) : </span><span class="s2">null</span><span class="s1">));</span>
    <span class="s4">// delete the invalidation marker last, once we're sure everything is cleaned</span>
    <span class="s4">// up</span>
    <span class="s2">await </span><span class="s1">_promises.default.rm(_nodepath.default.join(cacheDirectory, INVALIDATION_MARKER), {</span>
        <span class="s1">force: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">maxRetries: </span><span class="s3">2</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=cache-invalidation.js.map</span></pre>
</body>
</html>