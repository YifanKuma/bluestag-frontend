<html>
<head>
<title>AsYouTypeFormatter.PatternMatcher.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
AsYouTypeFormatter.PatternMatcher.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;AsYouTypeFormatter.PatternMatcher.js&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_AsYouTypeFormatterPatternParser&quot;</span><span class="s0">,</span><span class="s1">&quot;_interopRequireDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;_createForOfIteratorHelperLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;_unsupportedIterableToArray&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;_arrayLikeToArray&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;_typeof&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;_classCallCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;_defineProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;_toPropertyKey&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;_createClass&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;_toPrimitive&quot;</span><span class="s0">,</span><span class="s1">&quot;toPrimitive&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;PatternMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;matchTree&quot;</span><span class="s0">,</span><span class="s1">&quot;PatternParser&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;string&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;allowOverflow&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedChars&quot;</span><span class="s0">,</span><span class="s1">&quot;overflow&quot;</span><span class="s0">,</span><span class="s1">&quot;characters&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;characterString&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;partialMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;restCharacters&quot;</span><span class="s0">,</span><span class="s1">&quot;subtree&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;op&quot;</span><span class="s0">,</span><span class="s1">&quot;_iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;_step&quot;</span><span class="s0">,</span><span class="s1">&quot;branch&quot;</span><span class="s0">,</span><span class="s1">&quot;_iterator2&quot;</span><span class="s0">,</span><span class="s1">&quot;_step2&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../source/AsYouTypeFormatter.PatternMatcher.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import PatternParser from './AsYouTypeFormatter.PatternParser.js'</span><span class="s3">\r\n\r\n</span><span class="s1">export default class PatternMatcher {</span><span class="s3">\r\n\t</span><span class="s1">constructor(pattern) {</span><span class="s3">\r\n\t\t</span><span class="s1">this.matchTree = new PatternParser().parse(pattern)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">match(string, { allowOverflow } = {}) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (!string) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">throw new Error('String is required')</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">const result = match(string.split(''), this.matchTree, true)</span><span class="s3">\r\n\t\t</span><span class="s1">if (result &amp;&amp; result.match) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">delete result.matchedChars</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">if (result &amp;&amp; result.overflow) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (!allowOverflow) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">return result</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Matches `characters` against a pattern compiled into a `tree`.</span><span class="s3">\r\n </span><span class="s1">* @param  {string[]} characters</span><span class="s3">\r\n </span><span class="s1">* @param  {Tree} tree — A pattern compiled into a `tree`. See the `*.d.ts` file for the description of the `tree` structure.</span><span class="s3">\r\n </span><span class="s1">* @param  {boolean} last — Whether it's the last (rightmost) subtree on its level of the match tree.</span><span class="s3">\r\n </span><span class="s1">* @return {object} See the `*.d.ts` file for the description of the result object.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">function match(characters, tree, last) {</span><span class="s3">\r\n\t</span><span class="s1">// If `tree` is a string, then `tree` is a single character.</span><span class="s3">\r\n\t</span><span class="s1">// That's because when a pattern is parsed, multi-character-string parts</span><span class="s3">\r\n\t</span><span class="s1">// of a pattern are compiled into arrays of single characters.</span><span class="s3">\r\n\t</span><span class="s1">// I still wrote this piece of code for a </span><span class="s3">\&quot;</span><span class="s1">general</span><span class="s3">\&quot; </span><span class="s1">hypothetical case</span><span class="s3">\r\n\t</span><span class="s1">// when `tree` could be a string of several characters, even though</span><span class="s3">\r\n\t</span><span class="s1">// such case is not possible with the current implementation.</span><span class="s3">\r\n\t</span><span class="s1">if (typeof tree === 'string') {</span><span class="s3">\r\n\t\t</span><span class="s1">const characterString = characters.join('')</span><span class="s3">\r\n\t\t</span><span class="s1">if (tree.indexOf(characterString) === 0) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">// `tree` is always a single character.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// If `tree.indexOf(characterString) === 0`</span><span class="s3">\r\n\t\t\t</span><span class="s1">// then `characters.length === tree.length`.</span><span class="s3">\r\n\t\t\t</span><span class="s1">/* istanbul ignore else */</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (characters.length === tree.length) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">match: true,</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">matchedChars: characters</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">// `tree` is always a single character.</span><span class="s3">\r\n\t\t\t</span><span class="s1">// If `tree.indexOf(characterString) === 0`</span><span class="s3">\r\n\t\t\t</span><span class="s1">// then `characters.length === tree.length`.</span><span class="s3">\r\n\t\t\t</span><span class="s1">/* istanbul ignore next */</span><span class="s3">\r\n\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">partialMatch: true,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// matchedChars: characters</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">if (characterString.indexOf(tree) === 0) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (last) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// The `else` path is not possible because `tree` is always a single character.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// The `else` case for `characters.length &gt; tree.length` would be</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// `characters.length &lt;= tree.length` which means `characters.length &lt;= 1`.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// `characters` array can't be empty, so that means `characters === [tree]`,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// which would also mean `tree.indexOf(characterString) === 0` and that'd mean</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// that the `if (tree.indexOf(characterString) === 0)` condition before this</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// `if` condition would be entered, and returned from there, not reaching this code.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">/* istanbul ignore else */</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (characters.length &gt; tree.length) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">overflow: true</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">match: true,</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">matchedChars: characters.slice(0, tree.length)</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">return</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">if (Array.isArray(tree)) {</span><span class="s3">\r\n\t\t</span><span class="s1">let restCharacters = characters.slice()</span><span class="s3">\r\n\t\t</span><span class="s1">let i = 0</span><span class="s3">\r\n\t\t</span><span class="s1">while (i &lt; tree.length) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">const subtree = tree[i]</span><span class="s3">\r\n\t\t\t</span><span class="s1">const result = match(restCharacters, subtree, last &amp;&amp; (i === tree.length - 1))</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (!result) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t\t</span><span class="s1">} else if (result.overflow) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return result</span><span class="s3">\r\n\t\t\t</span><span class="s1">} else if (result.match) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// Continue with the next subtree with the rest of the characters.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">restCharacters = restCharacters.slice(result.matchedChars.length)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (restCharacters.length === 0) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">if (i === tree.length - 1) {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">match: true,</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">matchedChars: characters</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">partialMatch: true,</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">// matchedChars: characters</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">/* istanbul ignore else */</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (result.partialMatch) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">partialMatch: true,</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">// matchedChars: characters</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">throw new Error(`Unsupported match result:</span><span class="s3">\\</span><span class="s1">n${JSON.stringify(result, null, 2)}`)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">i++</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// If `last` then overflow has already been checked</span><span class="s3">\r\n\t\t</span><span class="s1">// by the last element of the `tree` array.</span><span class="s3">\r\n\t\t</span><span class="s1">/* istanbul ignore if */</span><span class="s3">\r\n\t\t</span><span class="s1">if (last) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">overflow: true</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t</span><span class="s1">match: true,</span><span class="s3">\r\n\t\t\t</span><span class="s1">matchedChars: characters.slice(0, characters.length - restCharacters.length)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">switch (tree.op) {</span><span class="s3">\r\n\t\t</span><span class="s1">case '|':</span><span class="s3">\r\n\t\t\t</span><span class="s1">let partialMatch</span><span class="s3">\r\n\t\t\t</span><span class="s1">for (const branch of tree.args) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">const result = match(characters, branch, last)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (result) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">if (result.overflow) {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">return result</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">} else if (result.match) {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">match: true,</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">matchedChars: result.matchedChars</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">/* istanbul ignore else */</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">if (result.partialMatch) {</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">partialMatch = true</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">throw new Error(`Unsupported match result:</span><span class="s3">\\</span><span class="s1">n${JSON.stringify(result, null, 2)}`)</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (partialMatch) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">partialMatch: true,</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">// matchedChars: ...</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">// Not even a partial match.</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">case '[]':</span><span class="s3">\r\n\t\t\t</span><span class="s1">for (const char of tree.args) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (characters[0] === char) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">if (characters.length === 1) {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">match: true,</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">matchedChars: characters</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">if (last) {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t\t\t</span><span class="s1">overflow: true</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">match: true,</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">matchedChars: [char]</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">// No character matches.</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">/* istanbul ignore next */</span><span class="s3">\r\n\t\t</span><span class="s1">default:</span><span class="s3">\r\n\t\t\t</span><span class="s1">throw new Error(`Unsupported instruction tree: ${tree}`)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>