<html>
<head>
<title>createExtensionPattern.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
createExtensionPattern.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ VALID_DIGITS } from </span><span class="s2">'../../constants.js'</span>

<span class="s3">// The RFC 3966 format for extensions.</span>
<span class="s0">const </span><span class="s1">RFC3966_EXTN_PREFIX = </span><span class="s2">';ext='</span>

<span class="s3">/**</span>
 <span class="s3">* Helper method for constructing regular expressions for parsing. Creates</span>
 <span class="s3">* an expression that captures up to max_length digits.</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string} RegEx pattern to capture extension digits.</span>
 <span class="s3">*/</span>
<span class="s0">const </span><span class="s1">getExtensionDigitsPattern = (maxLength) =&gt; </span><span class="s2">`([</span><span class="s1">${VALID_DIGITS}</span><span class="s2">]{1,</span><span class="s1">${maxLength}</span><span class="s2">})`</span>

<span class="s3">/**</span>
 <span class="s3">* Helper initialiser method to create the regular-expression pattern to match</span>
 <span class="s3">* extensions.</span>
 <span class="s3">* Copy-pasted from Google's `libphonenumber`:</span>
 <span class="s3">* https://github.com/google/libphonenumber/blob/55b2646ec9393f4d3d6661b9c82ef9e258e8b829/javascript/i18n/phonenumbers/phonenumberutil.js#L759-L766</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{string} RegEx pattern to capture extensions.</span>
 <span class="s3">*/</span>
<span class="s0">export default function </span><span class="s1">createExtensionPattern(purpose) {</span>
	<span class="s3">// We cap the maximum length of an extension based on the ambiguity of the way</span>
	<span class="s3">// the extension is prefixed. As per ITU, the officially allowed length for</span>
	<span class="s3">// extensions is actually 40, but we don't support this since we haven't seen real</span>
	<span class="s3">// examples and this introduces many false interpretations as the extension labels</span>
	<span class="s3">// are not standardized.</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">extLimitAfterExplicitLabel = </span><span class="s2">'20'</span><span class="s1">;</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">extLimitAfterLikelyLabel = </span><span class="s2">'15'</span><span class="s1">;</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">extLimitAfterAmbiguousChar = </span><span class="s2">'9'</span><span class="s1">;</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">extLimitWhenNotSure = </span><span class="s2">'6'</span><span class="s1">;</span>

	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">possibleSeparatorsBetweenNumberAndExtLabel = </span><span class="s2">&quot;[ </span><span class="s5">\u00A0\\</span><span class="s2">t,]*&quot;</span><span class="s1">;</span>
	<span class="s3">// Optional full stop (.) or colon, followed by zero or more spaces/tabs/commas.</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">possibleCharsAfterExtLabel = </span><span class="s2">&quot;[:</span><span class="s5">\\</span><span class="s2">.</span><span class="s5">\uFF0E</span><span class="s2">]?[ </span><span class="s5">\u00A0\\</span><span class="s2">t,-]*&quot;</span><span class="s1">;</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">optionalExtnSuffix = </span><span class="s2">&quot;#?&quot;</span><span class="s1">;</span>

	<span class="s3">// Here the extension is called out in more explicit way, i.e mentioning it obvious</span>
	<span class="s3">// patterns like &quot;ext.&quot;.</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">explicitExtLabels =</span>
	  <span class="s2">&quot;(?:e?xt(?:ensi(?:o</span><span class="s5">\u0301</span><span class="s2">?|</span><span class="s5">\u00F3</span><span class="s2">))?n?|</span><span class="s5">\uFF45</span><span class="s2">?</span><span class="s5">\uFF58\uFF54\uFF4E</span><span class="s2">?|</span><span class="s5">\u0434\u043E\u0431</span><span class="s2">|anexo)&quot;</span><span class="s1">;</span>
	<span class="s3">// One-character symbols that can be used to indicate an extension, and less</span>
	<span class="s3">// commonly used or more ambiguous extension labels.</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">ambiguousExtLabels = </span><span class="s2">&quot;(?:[x</span><span class="s5">\uFF58</span><span class="s2">#</span><span class="s5">\uFF03</span><span class="s2">~</span><span class="s5">\uFF5E</span><span class="s2">]|int|</span><span class="s5">\uFF49\uFF4E\uFF54</span><span class="s2">)&quot;</span><span class="s1">;</span>
	<span class="s3">// When extension is not separated clearly.</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">ambiguousSeparator = </span><span class="s2">&quot;[- ]+&quot;</span><span class="s1">;</span>
	<span class="s3">// This is the same as possibleSeparatorsBetweenNumberAndExtLabel, but not matching</span>
	<span class="s3">// comma as extension label may have it.</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">possibleSeparatorsNumberExtLabelNoComma = </span><span class="s2">&quot;[ </span><span class="s5">\u00A0\\</span><span class="s2">t]*&quot;</span><span class="s1">;</span>
	<span class="s3">// &quot;,,&quot; is commonly used for auto dialling the extension when connected. First</span>
	<span class="s3">// comma is matched through possibleSeparatorsBetweenNumberAndExtLabel, so we do</span>
	<span class="s3">// not repeat it here. Semi-colon works in Iphone and Android also to pop up a</span>
	<span class="s3">// button with the extension number following.</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">autoDiallingAndExtLabelsFound = </span><span class="s2">&quot;(?:,{2}|;)&quot;</span><span class="s1">;</span>

	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">rfcExtn = RFC3966_EXTN_PREFIX</span>
	     <span class="s1">+ getExtensionDigitsPattern(extLimitAfterExplicitLabel);</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels</span>
	     <span class="s1">+ possibleCharsAfterExtLabel</span>
	     <span class="s1">+ getExtensionDigitsPattern(extLimitAfterExplicitLabel)</span>
	     <span class="s1">+ optionalExtnSuffix;</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels</span>
	     <span class="s1">+ possibleCharsAfterExtLabel</span>
	<span class="s1">+ getExtensionDigitsPattern(extLimitAfterAmbiguousChar)</span>
	<span class="s1">+ optionalExtnSuffix;</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">americanStyleExtnWithSuffix = ambiguousSeparator</span>
	<span class="s1">+ getExtensionDigitsPattern(extLimitWhenNotSure) + </span><span class="s2">&quot;#&quot;</span><span class="s1">;</span>

	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma</span>
	     <span class="s1">+ autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel</span>
	     <span class="s1">+ getExtensionDigitsPattern(extLimitAfterLikelyLabel)</span>
	<span class="s1">+ optionalExtnSuffix;</span>
	<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
	<span class="s0">var </span><span class="s1">onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma</span>
	    <span class="s1">+ </span><span class="s2">&quot;(?:,)+&quot; </span><span class="s1">+ possibleCharsAfterExtLabel</span>
	    <span class="s1">+ getExtensionDigitsPattern(extLimitAfterAmbiguousChar)</span>
	    <span class="s1">+ optionalExtnSuffix;</span>

	<span class="s3">// The first regular expression covers RFC 3966 format, where the extension is added</span>
	<span class="s3">// using &quot;;ext=&quot;. The second more generic where extension is mentioned with explicit</span>
	<span class="s3">// labels like &quot;ext:&quot;. In both the above cases we allow more numbers in extension than</span>
	<span class="s3">// any other extension labels. The third one captures when single character extension</span>
	<span class="s3">// labels or less commonly used labels are used. In such cases we capture fewer</span>
	<span class="s3">// extension digits in order to reduce the chance of falsely interpreting two</span>
	<span class="s3">// numbers beside each other as a number + extension. The fourth one covers the</span>
	<span class="s3">// special case of American numbers where the extension is written with a hash</span>
	<span class="s3">// at the end, such as &quot;- 503#&quot;. The fifth one is exclusively for extension</span>
	<span class="s3">// autodialling formats which are used when dialling and in this case we accept longer</span>
	<span class="s3">// extensions. The last one is more liberal on the number of commas that acts as</span>
	<span class="s3">// extension labels, so we have a strict cap on the number of digits in such extensions.</span>
	<span class="s0">return </span><span class="s1">rfcExtn + </span><span class="s2">&quot;|&quot;</span>
	       <span class="s1">+ explicitExtn + </span><span class="s2">&quot;|&quot;</span>
	       <span class="s1">+ ambiguousExtn + </span><span class="s2">&quot;|&quot;</span>
	       <span class="s1">+ americanStyleExtnWithSuffix + </span><span class="s2">&quot;|&quot;</span>
	       <span class="s1">+ autoDiallingExtn + </span><span class="s2">&quot;|&quot;</span>
	       <span class="s1">+ onlyCommasExtn;</span>
<span class="s1">}</span></pre>
</body>
</html>