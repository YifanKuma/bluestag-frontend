<html>
<head>
<title>typed.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typed.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * @fileoverview Type expression parser. 
 * @author Yusuke Suzuki &lt;utatane.tea@gmail.com&gt; 
 * @author Dan Tao &lt;daniel.tao@gmail.com&gt; 
 * @author Andrew Eisenberg &lt;andrew@eisenberg.as&gt; 
 */</span>

<span class="s0">// &quot;typed&quot;, the Type Expression Parser for doctrine.</span>

<span class="s1">(</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s3">'use strict'</span><span class="s1">;</span>

    <span class="s2">var </span><span class="s1">Syntax,</span>
        <span class="s1">Token,</span>
        <span class="s1">source,</span>
        <span class="s1">length,</span>
        <span class="s1">index,</span>
        <span class="s1">previous,</span>
        <span class="s1">token,</span>
        <span class="s1">value,</span>
        <span class="s1">esutils,</span>
        <span class="s1">utility,</span>
        <span class="s1">rangeOffset,</span>
        <span class="s1">addRange;</span>

    <span class="s1">esutils = require(</span><span class="s3">'esutils'</span><span class="s1">);</span>
    <span class="s1">utility = require(</span><span class="s3">'./utility'</span><span class="s1">);</span>

    <span class="s1">Syntax = {</span>
        <span class="s1">NullableLiteral: </span><span class="s3">'NullableLiteral'</span><span class="s1">,</span>
        <span class="s1">AllLiteral: </span><span class="s3">'AllLiteral'</span><span class="s1">,</span>
        <span class="s1">NullLiteral: </span><span class="s3">'NullLiteral'</span><span class="s1">,</span>
        <span class="s1">UndefinedLiteral: </span><span class="s3">'UndefinedLiteral'</span><span class="s1">,</span>
        <span class="s1">VoidLiteral: </span><span class="s3">'VoidLiteral'</span><span class="s1">,</span>
        <span class="s1">UnionType: </span><span class="s3">'UnionType'</span><span class="s1">,</span>
        <span class="s1">ArrayType: </span><span class="s3">'ArrayType'</span><span class="s1">,</span>
        <span class="s1">RecordType: </span><span class="s3">'RecordType'</span><span class="s1">,</span>
        <span class="s1">FieldType: </span><span class="s3">'FieldType'</span><span class="s1">,</span>
        <span class="s1">FunctionType: </span><span class="s3">'FunctionType'</span><span class="s1">,</span>
        <span class="s1">ParameterType: </span><span class="s3">'ParameterType'</span><span class="s1">,</span>
        <span class="s1">RestType: </span><span class="s3">'RestType'</span><span class="s1">,</span>
        <span class="s1">NonNullableType: </span><span class="s3">'NonNullableType'</span><span class="s1">,</span>
        <span class="s1">OptionalType: </span><span class="s3">'OptionalType'</span><span class="s1">,</span>
        <span class="s1">NullableType: </span><span class="s3">'NullableType'</span><span class="s1">,</span>
        <span class="s1">NameExpression: </span><span class="s3">'NameExpression'</span><span class="s1">,</span>
        <span class="s1">TypeApplication: </span><span class="s3">'TypeApplication'</span><span class="s1">,</span>
        <span class="s1">StringLiteralType: </span><span class="s3">'StringLiteralType'</span><span class="s1">,</span>
        <span class="s1">NumericLiteralType: </span><span class="s3">'NumericLiteralType'</span><span class="s1">,</span>
        <span class="s1">BooleanLiteralType: </span><span class="s3">'BooleanLiteralType'</span>
    <span class="s1">};</span>

    <span class="s1">Token = {</span>
        <span class="s1">ILLEGAL: </span><span class="s4">0</span><span class="s1">,    </span><span class="s0">// ILLEGAL</span>
        <span class="s1">DOT_LT: </span><span class="s4">1</span><span class="s1">,     </span><span class="s0">// .&lt;</span>
        <span class="s1">REST: </span><span class="s4">2</span><span class="s1">,       </span><span class="s0">// ...</span>
        <span class="s1">LT: </span><span class="s4">3</span><span class="s1">,         </span><span class="s0">// &lt;</span>
        <span class="s1">GT: </span><span class="s4">4</span><span class="s1">,         </span><span class="s0">// &gt;</span>
        <span class="s1">LPAREN: </span><span class="s4">5</span><span class="s1">,     </span><span class="s0">// (</span>
        <span class="s1">RPAREN: </span><span class="s4">6</span><span class="s1">,     </span><span class="s0">// )</span>
        <span class="s1">LBRACE: </span><span class="s4">7</span><span class="s1">,     </span><span class="s0">// {</span>
        <span class="s1">RBRACE: </span><span class="s4">8</span><span class="s1">,     </span><span class="s0">// }</span>
        <span class="s1">LBRACK: </span><span class="s4">9</span><span class="s1">,    </span><span class="s0">// [</span>
        <span class="s1">RBRACK: </span><span class="s4">10</span><span class="s1">,    </span><span class="s0">// ]</span>
        <span class="s1">COMMA: </span><span class="s4">11</span><span class="s1">,     </span><span class="s0">// ,</span>
        <span class="s1">COLON: </span><span class="s4">12</span><span class="s1">,     </span><span class="s0">// :</span>
        <span class="s1">STAR: </span><span class="s4">13</span><span class="s1">,      </span><span class="s0">// *</span>
        <span class="s1">PIPE: </span><span class="s4">14</span><span class="s1">,      </span><span class="s0">// |</span>
        <span class="s1">QUESTION: </span><span class="s4">15</span><span class="s1">,  </span><span class="s0">// ?</span>
        <span class="s1">BANG: </span><span class="s4">16</span><span class="s1">,      </span><span class="s0">// !</span>
        <span class="s1">EQUAL: </span><span class="s4">17</span><span class="s1">,     </span><span class="s0">// =</span>
        <span class="s1">NAME: </span><span class="s4">18</span><span class="s1">,      </span><span class="s0">// name token</span>
        <span class="s1">STRING: </span><span class="s4">19</span><span class="s1">,    </span><span class="s0">// string</span>
        <span class="s1">NUMBER: </span><span class="s4">20</span><span class="s1">,    </span><span class="s0">// number</span>
        <span class="s1">EOF: </span><span class="s4">21</span>
    <span class="s1">};</span>

    <span class="s2">function </span><span class="s1">isTypeName(ch) {</span>
        <span class="s2">return </span><span class="s3">'&gt;&lt;(){}[],:*|?!='</span><span class="s1">.indexOf(String.fromCharCode(ch)) === -</span><span class="s4">1 </span><span class="s1">&amp;&amp; !esutils.code.isWhiteSpace(ch) &amp;&amp; !esutils.code.isLineTerminator(ch);</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">Context(previous, index, token, value) {</span>
        <span class="s2">this</span><span class="s1">._previous = previous;</span>
        <span class="s2">this</span><span class="s1">._index = index;</span>
        <span class="s2">this</span><span class="s1">._token = token;</span>
        <span class="s2">this</span><span class="s1">._value = value;</span>
    <span class="s1">}</span>

    <span class="s1">Context.prototype.restore = </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">previous = </span><span class="s2">this</span><span class="s1">._previous;</span>
        <span class="s1">index = </span><span class="s2">this</span><span class="s1">._index;</span>
        <span class="s1">token = </span><span class="s2">this</span><span class="s1">._token;</span>
        <span class="s1">value = </span><span class="s2">this</span><span class="s1">._value;</span>
    <span class="s1">};</span>

    <span class="s1">Context.save = </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">return new </span><span class="s1">Context(previous, index, token, value);</span>
    <span class="s1">};</span>

    <span class="s2">function </span><span class="s1">maybeAddRange(node, range) {</span>
        <span class="s2">if </span><span class="s1">(addRange) {</span>
            <span class="s1">node.range = [range[</span><span class="s4">0</span><span class="s1">] + rangeOffset, range[</span><span class="s4">1</span><span class="s1">] + rangeOffset];</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">advance() {</span>
        <span class="s2">var </span><span class="s1">ch = source.charAt(index);</span>
        <span class="s1">index += </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">ch;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">scanHexEscape(prefix) {</span>
        <span class="s2">var </span><span class="s1">i, len, ch, code = </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s1">len = (prefix === </span><span class="s3">'u'</span><span class="s1">) ? </span><span class="s4">4 </span><span class="s1">: </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; len; ++i) {</span>
            <span class="s2">if </span><span class="s1">(index &lt; length &amp;&amp; esutils.code.isHexDigit(source.charCodeAt(index))) {</span>
                <span class="s1">ch = advance();</span>
                <span class="s1">code = code * </span><span class="s4">16 </span><span class="s1">+ </span><span class="s3">'0123456789abcdef'</span><span class="s1">.indexOf(ch.toLowerCase());</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">String.fromCharCode(code);</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">scanString() {</span>
        <span class="s2">var </span><span class="s1">str = </span><span class="s3">''</span><span class="s1">, quote, ch, code, unescaped, restore; </span><span class="s0">//TODO review removal octal = false</span>
        <span class="s1">quote = source.charAt(index);</span>
        <span class="s1">++index;</span>

        <span class="s2">while </span><span class="s1">(index &lt; length) {</span>
            <span class="s1">ch = advance();</span>

            <span class="s2">if </span><span class="s1">(ch === quote) {</span>
                <span class="s1">quote = </span><span class="s3">''</span><span class="s1">;</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">'</span><span class="s1">) {</span>
                <span class="s1">ch = advance();</span>
                <span class="s2">if </span><span class="s1">(!esutils.code.isLineTerminator(ch.charCodeAt(</span><span class="s4">0</span><span class="s1">))) {</span>
                    <span class="s2">switch </span><span class="s1">(ch) {</span>
                    <span class="s2">case </span><span class="s3">'n'</span><span class="s1">:</span>
                        <span class="s1">str += </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s3">'r'</span><span class="s1">:</span>
                        <span class="s1">str += </span><span class="s3">'</span><span class="s5">\r</span><span class="s3">'</span><span class="s1">;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s3">'t'</span><span class="s1">:</span>
                        <span class="s1">str += </span><span class="s3">'</span><span class="s5">\t</span><span class="s3">'</span><span class="s1">;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s3">'u'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s3">'x'</span><span class="s1">:</span>
                        <span class="s1">restore = index;</span>
                        <span class="s1">unescaped = scanHexEscape(ch);</span>
                        <span class="s2">if </span><span class="s1">(unescaped) {</span>
                            <span class="s1">str += unescaped;</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">index = restore;</span>
                            <span class="s1">str += ch;</span>
                        <span class="s1">}</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s3">'b'</span><span class="s1">:</span>
                        <span class="s1">str += </span><span class="s3">'</span><span class="s5">\b</span><span class="s3">'</span><span class="s1">;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s3">'f'</span><span class="s1">:</span>
                        <span class="s1">str += </span><span class="s3">'</span><span class="s5">\f</span><span class="s3">'</span><span class="s1">;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s3">'v'</span><span class="s1">:</span>
                        <span class="s1">str += </span><span class="s3">'</span><span class="s5">\v</span><span class="s3">'</span><span class="s1">;</span>
                        <span class="s2">break</span><span class="s1">;</span>

                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">(esutils.code.isOctalDigit(ch.charCodeAt(</span><span class="s4">0</span><span class="s1">))) {</span>
                            <span class="s1">code = </span><span class="s3">'01234567'</span><span class="s1">.indexOf(ch);</span>

                            <span class="s0">// \0 is not octal escape sequence</span>
                            <span class="s0">// Deprecating unused code. TODO review removal</span>
                            <span class="s0">//if (code !== 0) {</span>
                            <span class="s0">//    octal = true;</span>
                            <span class="s0">//}</span>

                            <span class="s2">if </span><span class="s1">(index &lt; length &amp;&amp; esutils.code.isOctalDigit(source.charCodeAt(index))) {</span>
                                <span class="s0">//TODO Review Removal octal = true;</span>
                                <span class="s1">code = code * </span><span class="s4">8 </span><span class="s1">+ </span><span class="s3">'01234567'</span><span class="s1">.indexOf(advance());</span>

                                <span class="s0">// 3 digits are only allowed when string starts</span>
                                <span class="s0">// with 0, 1, 2, 3</span>
                                <span class="s2">if </span><span class="s1">(</span><span class="s3">'0123'</span><span class="s1">.indexOf(ch) &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
                                        <span class="s1">index &lt; length &amp;&amp;</span>
                                        <span class="s1">esutils.code.isOctalDigit(source.charCodeAt(index))) {</span>
                                    <span class="s1">code = code * </span><span class="s4">8 </span><span class="s1">+ </span><span class="s3">'01234567'</span><span class="s1">.indexOf(advance());</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s1">str += String.fromCharCode(code);</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">str += ch;</span>
                        <span class="s1">}</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(ch ===  </span><span class="s3">'</span><span class="s5">\r</span><span class="s3">' </span><span class="s1">&amp;&amp; source.charCodeAt(index) === </span><span class="s4">0x0A  </span><span class="s0">/* '\n' */</span><span class="s1">) {</span>
                        <span class="s1">++index;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(esutils.code.isLineTerminator(ch.charCodeAt(</span><span class="s4">0</span><span class="s1">))) {</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">str += ch;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(quote !== </span><span class="s3">''</span><span class="s1">) {</span>
            <span class="s1">utility.throwError(</span><span class="s3">'unexpected quote'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">value = str;</span>
        <span class="s2">return </span><span class="s1">Token.STRING;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">scanNumber() {</span>
        <span class="s2">var </span><span class="s1">number, ch;</span>

        <span class="s1">number = </span><span class="s3">''</span><span class="s1">;</span>
        <span class="s1">ch = source.charCodeAt(index);</span>

        <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0x2E  </span><span class="s0">/* '.' */</span><span class="s1">) {</span>
            <span class="s1">number = advance();</span>
            <span class="s1">ch = source.charCodeAt(index);</span>

            <span class="s2">if </span><span class="s1">(number === </span><span class="s3">'0'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x78  </span><span class="s0">/* 'x' */ </span><span class="s1">|| ch === </span><span class="s4">0x58  </span><span class="s0">/* 'X' */</span><span class="s1">) {</span>
                    <span class="s1">number += advance();</span>
                    <span class="s2">while </span><span class="s1">(index &lt; length) {</span>
                        <span class="s1">ch = source.charCodeAt(index);</span>
                        <span class="s2">if </span><span class="s1">(!esutils.code.isHexDigit(ch)) {</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s1">number += advance();</span>
                    <span class="s1">}</span>

                    <span class="s2">if </span><span class="s1">(number.length &lt;= </span><span class="s4">2</span><span class="s1">) {</span>
                        <span class="s0">// only 0x</span>
                        <span class="s1">utility.throwError(</span><span class="s3">'unexpected token'</span><span class="s1">);</span>
                    <span class="s1">}</span>

                    <span class="s2">if </span><span class="s1">(index &lt; length) {</span>
                        <span class="s1">ch = source.charCodeAt(index);</span>
                        <span class="s2">if </span><span class="s1">(esutils.code.isIdentifierStartES5(ch)) {</span>
                            <span class="s1">utility.throwError(</span><span class="s3">'unexpected token'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">value = parseInt(number, </span><span class="s4">16</span><span class="s1">);</span>
                    <span class="s2">return </span><span class="s1">Token.NUMBER;</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(esutils.code.isOctalDigit(ch)) {</span>
                    <span class="s1">number += advance();</span>
                    <span class="s2">while </span><span class="s1">(index &lt; length) {</span>
                        <span class="s1">ch = source.charCodeAt(index);</span>
                        <span class="s2">if </span><span class="s1">(!esutils.code.isOctalDigit(ch)) {</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s1">number += advance();</span>
                    <span class="s1">}</span>

                    <span class="s2">if </span><span class="s1">(index &lt; length) {</span>
                        <span class="s1">ch = source.charCodeAt(index);</span>
                        <span class="s2">if </span><span class="s1">(esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {</span>
                            <span class="s1">utility.throwError(</span><span class="s3">'unexpected token'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">value = parseInt(number, </span><span class="s4">8</span><span class="s1">);</span>
                    <span class="s2">return </span><span class="s1">Token.NUMBER;</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(esutils.code.isDecimalDigit(ch)) {</span>
                    <span class="s1">utility.throwError(</span><span class="s3">'unexpected token'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">while </span><span class="s1">(index &lt; length) {</span>
                <span class="s1">ch = source.charCodeAt(index);</span>
                <span class="s2">if </span><span class="s1">(!esutils.code.isDecimalDigit(ch)) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">number += advance();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x2E  </span><span class="s0">/* '.' */</span><span class="s1">) {</span>
            <span class="s1">number += advance();</span>
            <span class="s2">while </span><span class="s1">(index &lt; length) {</span>
                <span class="s1">ch = source.charCodeAt(index);</span>
                <span class="s2">if </span><span class="s1">(!esutils.code.isDecimalDigit(ch)) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">number += advance();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x65  </span><span class="s0">/* 'e' */ </span><span class="s1">|| ch === </span><span class="s4">0x45  </span><span class="s0">/* 'E' */</span><span class="s1">) {</span>
            <span class="s1">number += advance();</span>

            <span class="s1">ch = source.charCodeAt(index);</span>
            <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x2B  </span><span class="s0">/* '+' */ </span><span class="s1">|| ch === </span><span class="s4">0x2D  </span><span class="s0">/* '-' */</span><span class="s1">) {</span>
                <span class="s1">number += advance();</span>
            <span class="s1">}</span>

            <span class="s1">ch = source.charCodeAt(index);</span>
            <span class="s2">if </span><span class="s1">(esutils.code.isDecimalDigit(ch)) {</span>
                <span class="s1">number += advance();</span>
                <span class="s2">while </span><span class="s1">(index &lt; length) {</span>
                    <span class="s1">ch = source.charCodeAt(index);</span>
                    <span class="s2">if </span><span class="s1">(!esutils.code.isDecimalDigit(ch)) {</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">number += advance();</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">utility.throwError(</span><span class="s3">'unexpected token'</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(index &lt; length) {</span>
            <span class="s1">ch = source.charCodeAt(index);</span>
            <span class="s2">if </span><span class="s1">(esutils.code.isIdentifierStartES5(ch)) {</span>
                <span class="s1">utility.throwError(</span><span class="s3">'unexpected token'</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">value = parseFloat(number);</span>
        <span class="s2">return </span><span class="s1">Token.NUMBER;</span>
    <span class="s1">}</span>


    <span class="s2">function </span><span class="s1">scanTypeName() {</span>
        <span class="s2">var </span><span class="s1">ch, ch2;</span>

        <span class="s1">value = advance();</span>
        <span class="s2">while </span><span class="s1">(index &lt; length &amp;&amp; isTypeName(source.charCodeAt(index))) {</span>
            <span class="s1">ch = source.charCodeAt(index);</span>
            <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x2E  </span><span class="s0">/* '.' */</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">((index + </span><span class="s4">1</span><span class="s1">) &gt;= length) {</span>
                    <span class="s2">return </span><span class="s1">Token.ILLEGAL;</span>
                <span class="s1">}</span>
                <span class="s1">ch2 = source.charCodeAt(index + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(ch2 === </span><span class="s4">0x3C  </span><span class="s0">/* '&lt;' */</span><span class="s1">) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">value += advance();</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">Token.NAME;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">next() {</span>
        <span class="s2">var </span><span class="s1">ch;</span>

        <span class="s1">previous = index;</span>

        <span class="s2">while </span><span class="s1">(index &lt; length &amp;&amp; esutils.code.isWhiteSpace(source.charCodeAt(index))) {</span>
            <span class="s1">advance();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(index &gt;= length) {</span>
            <span class="s1">token = Token.EOF;</span>
            <span class="s2">return </span><span class="s1">token;</span>
        <span class="s1">}</span>

        <span class="s1">ch = source.charCodeAt(index);</span>
        <span class="s2">switch </span><span class="s1">(ch) {</span>
        <span class="s2">case </span><span class="s4">0x27</span><span class="s1">:  </span><span class="s0">/* ''' */</span>
        <span class="s2">case </span><span class="s4">0x22</span><span class="s1">:  </span><span class="s0">/* '&quot;' */</span>
            <span class="s1">token = scanString();</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x3A</span><span class="s1">:  </span><span class="s0">/* ':' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.COLON;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x2C</span><span class="s1">:  </span><span class="s0">/* ',' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.COMMA;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x28</span><span class="s1">:  </span><span class="s0">/* '(' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.LPAREN;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x29</span><span class="s1">:  </span><span class="s0">/* ')' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.RPAREN;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x5B</span><span class="s1">:  </span><span class="s0">/* '[' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.LBRACK;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x5D</span><span class="s1">:  </span><span class="s0">/* ']' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.RBRACK;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x7B</span><span class="s1">:  </span><span class="s0">/* '{' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.LBRACE;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x7D</span><span class="s1">:  </span><span class="s0">/* '}' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.RBRACE;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x2E</span><span class="s1">:  </span><span class="s0">/* '.' */</span>
            <span class="s2">if </span><span class="s1">(index + </span><span class="s4">1 </span><span class="s1">&lt; length) {</span>
                <span class="s1">ch = source.charCodeAt(index + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x3C  </span><span class="s0">/* '&lt;' */</span><span class="s1">) {</span>
                    <span class="s1">advance();  </span><span class="s0">// '.'</span>
                    <span class="s1">advance();  </span><span class="s0">// '&lt;'</span>
                    <span class="s1">token = Token.DOT_LT;</span>
                    <span class="s2">return </span><span class="s1">token;</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x2E  </span><span class="s0">/* '.' */ </span><span class="s1">&amp;&amp; index + </span><span class="s4">2 </span><span class="s1">&lt; length &amp;&amp; source.charCodeAt(index + </span><span class="s4">2</span><span class="s1">) === </span><span class="s4">0x2E  </span><span class="s0">/* '.' */</span><span class="s1">) {</span>
                    <span class="s1">advance();  </span><span class="s0">// '.'</span>
                    <span class="s1">advance();  </span><span class="s0">// '.'</span>
                    <span class="s1">advance();  </span><span class="s0">// '.'</span>
                    <span class="s1">token = Token.REST;</span>
                    <span class="s2">return </span><span class="s1">token;</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(esutils.code.isDecimalDigit(ch)) {</span>
                    <span class="s1">token = scanNumber();</span>
                    <span class="s2">return </span><span class="s1">token;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">token = Token.ILLEGAL;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x3C</span><span class="s1">:  </span><span class="s0">/* '&lt;' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.LT;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x3E</span><span class="s1">:  </span><span class="s0">/* '&gt;' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.GT;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x2A</span><span class="s1">:  </span><span class="s0">/* '*' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.STAR;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x7C</span><span class="s1">:  </span><span class="s0">/* '|' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.PIPE;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x3F</span><span class="s1">:  </span><span class="s0">/* '?' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.QUESTION;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x21</span><span class="s1">:  </span><span class="s0">/* '!' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.BANG;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x3D</span><span class="s1">:  </span><span class="s0">/* '=' */</span>
            <span class="s1">advance();</span>
            <span class="s1">token = Token.EQUAL;</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">case </span><span class="s4">0x2D</span><span class="s1">: </span><span class="s0">/* '-' */</span>
            <span class="s1">token = scanNumber();</span>
            <span class="s2">return </span><span class="s1">token;</span>

        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(esutils.code.isDecimalDigit(ch)) {</span>
                <span class="s1">token = scanNumber();</span>
                <span class="s2">return </span><span class="s1">token;</span>
            <span class="s1">}</span>

            <span class="s0">// type string permits following case,</span>
            <span class="s0">//</span>
            <span class="s0">// namespace.module.MyClass</span>
            <span class="s0">//</span>
            <span class="s0">// this reduced 1 token TK_NAME</span>
            <span class="s1">utility.assert(isTypeName(ch));</span>
            <span class="s1">token = scanTypeName();</span>
            <span class="s2">return </span><span class="s1">token;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">consume(target, text) {</span>
        <span class="s1">utility.assert(token === target, text || </span><span class="s3">'consumed token not matched'</span><span class="s1">);</span>
        <span class="s1">next();</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">expect(target, message) {</span>
        <span class="s2">if </span><span class="s1">(token !== target) {</span>
            <span class="s1">utility.throwError(message || </span><span class="s3">'unexpected token'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">next();</span>
    <span class="s1">}</span>

    <span class="s0">// UnionType := '(' TypeUnionList ')'</span>
    <span class="s0">//</span>
    <span class="s0">// TypeUnionList :=</span>
    <span class="s0">//     &lt;&lt;empty&gt;&gt;</span>
    <span class="s0">//   | NonemptyTypeUnionList</span>
    <span class="s0">//</span>
    <span class="s0">// NonemptyTypeUnionList :=</span>
    <span class="s0">//     TypeExpression</span>
    <span class="s0">//   | TypeExpression '|' NonemptyTypeUnionList</span>
    <span class="s2">function </span><span class="s1">parseUnionType() {</span>
        <span class="s2">var </span><span class="s1">elements, startIndex = index - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">consume(Token.LPAREN, </span><span class="s3">'UnionType should start with ('</span><span class="s1">);</span>
        <span class="s1">elements = [];</span>
        <span class="s2">if </span><span class="s1">(token !== Token.RPAREN) {</span>
            <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
                <span class="s1">elements.push(parseTypeExpression());</span>
                <span class="s2">if </span><span class="s1">(token === Token.RPAREN) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">expect(Token.PIPE);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">consume(Token.RPAREN, </span><span class="s3">'UnionType should end with )'</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">maybeAddRange({</span>
            <span class="s1">type: Syntax.UnionType,</span>
            <span class="s1">elements: elements</span>
        <span class="s1">}, [startIndex, previous]);</span>
    <span class="s1">}</span>

    <span class="s0">// ArrayType := '[' ElementTypeList ']'</span>
    <span class="s0">//</span>
    <span class="s0">// ElementTypeList :=</span>
    <span class="s0">//     &lt;&lt;empty&gt;&gt;</span>
    <span class="s0">//  | TypeExpression</span>
    <span class="s0">//  | '...' TypeExpression</span>
    <span class="s0">//  | TypeExpression ',' ElementTypeList</span>
    <span class="s2">function </span><span class="s1">parseArrayType() {</span>
        <span class="s2">var </span><span class="s1">elements, startIndex = index - </span><span class="s4">1</span><span class="s1">, restStartIndex;</span>
        <span class="s1">consume(Token.LBRACK, </span><span class="s3">'ArrayType should start with ['</span><span class="s1">);</span>
        <span class="s1">elements = [];</span>
        <span class="s2">while </span><span class="s1">(token !== Token.RBRACK) {</span>
            <span class="s2">if </span><span class="s1">(token === Token.REST) {</span>
                <span class="s1">restStartIndex = index - </span><span class="s4">3</span><span class="s1">;</span>
                <span class="s1">consume(Token.REST);</span>
                <span class="s1">elements.push(maybeAddRange({</span>
                    <span class="s1">type: Syntax.RestType,</span>
                    <span class="s1">expression: parseTypeExpression()</span>
                <span class="s1">}, [restStartIndex, previous]));</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">elements.push(parseTypeExpression());</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(token !== Token.RBRACK) {</span>
                <span class="s1">expect(Token.COMMA);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">expect(Token.RBRACK);</span>
        <span class="s2">return </span><span class="s1">maybeAddRange({</span>
            <span class="s1">type: Syntax.ArrayType,</span>
            <span class="s1">elements: elements</span>
        <span class="s1">}, [startIndex, previous]);</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">parseFieldName() {</span>
        <span class="s2">var </span><span class="s1">v = value;</span>
        <span class="s2">if </span><span class="s1">(token === Token.NAME || token === Token.STRING) {</span>
            <span class="s1">next();</span>
            <span class="s2">return </span><span class="s1">v;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(token === Token.NUMBER) {</span>
            <span class="s1">consume(Token.NUMBER);</span>
            <span class="s2">return </span><span class="s1">String(v);</span>
        <span class="s1">}</span>

        <span class="s1">utility.throwError(</span><span class="s3">'unexpected token'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">// FieldType :=</span>
    <span class="s0">//     FieldName</span>
    <span class="s0">//   | FieldName ':' TypeExpression</span>
    <span class="s0">//</span>
    <span class="s0">// FieldName :=</span>
    <span class="s0">//     NameExpression</span>
    <span class="s0">//   | StringLiteral</span>
    <span class="s0">//   | NumberLiteral</span>
    <span class="s0">//   | ReservedIdentifier</span>
    <span class="s2">function </span><span class="s1">parseFieldType() {</span>
        <span class="s2">var </span><span class="s1">key, rangeStart = previous;</span>

        <span class="s1">key = parseFieldName();</span>
        <span class="s2">if </span><span class="s1">(token === Token.COLON) {</span>
            <span class="s1">consume(Token.COLON);</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.FieldType,</span>
                <span class="s1">key: key,</span>
                <span class="s1">value: parseTypeExpression()</span>
            <span class="s1">}, [rangeStart, previous]);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">maybeAddRange({</span>
            <span class="s1">type: Syntax.FieldType,</span>
            <span class="s1">key: key,</span>
            <span class="s1">value: </span><span class="s2">null</span>
        <span class="s1">}, [rangeStart, previous]);</span>
    <span class="s1">}</span>

    <span class="s0">// RecordType := '{' FieldTypeList '}'</span>
    <span class="s0">//</span>
    <span class="s0">// FieldTypeList :=</span>
    <span class="s0">//     &lt;&lt;empty&gt;&gt;</span>
    <span class="s0">//   | FieldType</span>
    <span class="s0">//   | FieldType ',' FieldTypeList</span>
    <span class="s2">function </span><span class="s1">parseRecordType() {</span>
        <span class="s2">var </span><span class="s1">fields, rangeStart = index - </span><span class="s4">1</span><span class="s1">, rangeEnd;</span>

        <span class="s1">consume(Token.LBRACE, </span><span class="s3">'RecordType should start with {'</span><span class="s1">);</span>
        <span class="s1">fields = [];</span>
        <span class="s2">if </span><span class="s1">(token === Token.COMMA) {</span>
            <span class="s1">consume(Token.COMMA);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">while </span><span class="s1">(token !== Token.RBRACE) {</span>
                <span class="s1">fields.push(parseFieldType());</span>
                <span class="s2">if </span><span class="s1">(token !== Token.RBRACE) {</span>
                    <span class="s1">expect(Token.COMMA);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">rangeEnd = index;</span>
        <span class="s1">expect(Token.RBRACE);</span>
        <span class="s2">return </span><span class="s1">maybeAddRange({</span>
            <span class="s1">type: Syntax.RecordType,</span>
            <span class="s1">fields: fields</span>
        <span class="s1">}, [rangeStart, rangeEnd]);</span>
    <span class="s1">}</span>

    <span class="s0">// NameExpression :=</span>
    <span class="s0">//    Identifier</span>
    <span class="s0">//  | TagIdentifier ':' Identifier</span>
    <span class="s0">//</span>
    <span class="s0">// Tag identifier is one of &quot;module&quot;, &quot;external&quot; or &quot;event&quot;</span>
    <span class="s0">// Identifier is the same as Token.NAME, including any dots, something like</span>
    <span class="s0">// namespace.module.MyClass</span>
    <span class="s2">function </span><span class="s1">parseNameExpression() {</span>
        <span class="s2">var </span><span class="s1">name = value, rangeStart = index - name.length;</span>
        <span class="s1">expect(Token.NAME);</span>

        <span class="s2">if </span><span class="s1">(token === Token.COLON &amp;&amp; (</span>
                <span class="s1">name === </span><span class="s3">'module' </span><span class="s1">||</span>
                <span class="s1">name === </span><span class="s3">'external' </span><span class="s1">||</span>
                <span class="s1">name === </span><span class="s3">'event'</span><span class="s1">)) {</span>
            <span class="s1">consume(Token.COLON);</span>
            <span class="s1">name += </span><span class="s3">':' </span><span class="s1">+ value;</span>
            <span class="s1">expect(Token.NAME);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">maybeAddRange({</span>
            <span class="s1">type: Syntax.NameExpression,</span>
            <span class="s1">name: name</span>
        <span class="s1">}, [rangeStart, previous]);</span>
    <span class="s1">}</span>

    <span class="s0">// TypeExpressionList :=</span>
    <span class="s0">//     TopLevelTypeExpression</span>
    <span class="s0">//   | TopLevelTypeExpression ',' TypeExpressionList</span>
    <span class="s2">function </span><span class="s1">parseTypeExpressionList() {</span>
        <span class="s2">var </span><span class="s1">elements = [];</span>

        <span class="s1">elements.push(parseTop());</span>
        <span class="s2">while </span><span class="s1">(token === Token.COMMA) {</span>
            <span class="s1">consume(Token.COMMA);</span>
            <span class="s1">elements.push(parseTop());</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">elements;</span>
    <span class="s1">}</span>

    <span class="s0">// TypeName :=</span>
    <span class="s0">//     NameExpression</span>
    <span class="s0">//   | NameExpression TypeApplication</span>
    <span class="s0">//</span>
    <span class="s0">// TypeApplication :=</span>
    <span class="s0">//     '.&lt;' TypeExpressionList '&gt;'</span>
    <span class="s0">//   | '&lt;' TypeExpressionList '&gt;'   // this is extension of doctrine</span>
    <span class="s2">function </span><span class="s1">parseTypeName() {</span>
        <span class="s2">var </span><span class="s1">expr, applications, startIndex = index - value.length;</span>

        <span class="s1">expr = parseNameExpression();</span>
        <span class="s2">if </span><span class="s1">(token === Token.DOT_LT || token === Token.LT) {</span>
            <span class="s1">next();</span>
            <span class="s1">applications = parseTypeExpressionList();</span>
            <span class="s1">expect(Token.GT);</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.TypeApplication,</span>
                <span class="s1">expression: expr,</span>
                <span class="s1">applications: applications</span>
            <span class="s1">}, [startIndex, previous]);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">expr;</span>
    <span class="s1">}</span>

    <span class="s0">// ResultType :=</span>
    <span class="s0">//     &lt;&lt;empty&gt;&gt;</span>
    <span class="s0">//   | ':' void</span>
    <span class="s0">//   | ':' TypeExpression</span>
    <span class="s0">//</span>
    <span class="s0">// BNF is above</span>
    <span class="s0">// but, we remove &lt;&lt;empty&gt;&gt; pattern, so token is always TypeToken::COLON</span>
    <span class="s2">function </span><span class="s1">parseResultType() {</span>
        <span class="s1">consume(Token.COLON, </span><span class="s3">'ResultType should start with :'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(token === Token.NAME &amp;&amp; value === </span><span class="s3">'void'</span><span class="s1">) {</span>
            <span class="s1">consume(Token.NAME);</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">type: Syntax.VoidLiteral</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">parseTypeExpression();</span>
    <span class="s1">}</span>

    <span class="s0">// ParametersType :=</span>
    <span class="s0">//     RestParameterType</span>
    <span class="s0">//   | NonRestParametersType</span>
    <span class="s0">//   | NonRestParametersType ',' RestParameterType</span>
    <span class="s0">//</span>
    <span class="s0">// RestParameterType :=</span>
    <span class="s0">//     '...'</span>
    <span class="s0">//     '...' Identifier</span>
    <span class="s0">//</span>
    <span class="s0">// NonRestParametersType :=</span>
    <span class="s0">//     ParameterType ',' NonRestParametersType</span>
    <span class="s0">//   | ParameterType</span>
    <span class="s0">//   | OptionalParametersType</span>
    <span class="s0">//</span>
    <span class="s0">// OptionalParametersType :=</span>
    <span class="s0">//     OptionalParameterType</span>
    <span class="s0">//   | OptionalParameterType, OptionalParametersType</span>
    <span class="s0">//</span>
    <span class="s0">// OptionalParameterType := ParameterType=</span>
    <span class="s0">//</span>
    <span class="s0">// ParameterType := TypeExpression | Identifier ':' TypeExpression</span>
    <span class="s0">//</span>
    <span class="s0">// Identifier is &quot;new&quot; or &quot;this&quot;</span>
    <span class="s2">function </span><span class="s1">parseParametersType() {</span>
        <span class="s2">var </span><span class="s1">params = [], optionalSequence = </span><span class="s2">false</span><span class="s1">, expr, rest = </span><span class="s2">false</span><span class="s1">, startIndex, restStartIndex = index - </span><span class="s4">3</span><span class="s1">, nameStartIndex;</span>

        <span class="s2">while </span><span class="s1">(token !== Token.RPAREN) {</span>
            <span class="s2">if </span><span class="s1">(token === Token.REST) {</span>
                <span class="s0">// RestParameterType</span>
                <span class="s1">consume(Token.REST);</span>
                <span class="s1">rest = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">startIndex = previous;</span>

            <span class="s1">expr = parseTypeExpression();</span>
            <span class="s2">if </span><span class="s1">(expr.type === Syntax.NameExpression &amp;&amp; token === Token.COLON) {</span>
                <span class="s1">nameStartIndex = previous - expr.name.length;</span>
                <span class="s0">// Identifier ':' TypeExpression</span>
                <span class="s1">consume(Token.COLON);</span>
                <span class="s1">expr = maybeAddRange({</span>
                    <span class="s1">type: Syntax.ParameterType,</span>
                    <span class="s1">name: expr.name,</span>
                    <span class="s1">expression: parseTypeExpression()</span>
                <span class="s1">}, [nameStartIndex, previous]);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(token === Token.EQUAL) {</span>
                <span class="s1">consume(Token.EQUAL);</span>
                <span class="s1">expr = maybeAddRange({</span>
                    <span class="s1">type: Syntax.OptionalType,</span>
                    <span class="s1">expression: expr</span>
                <span class="s1">}, [startIndex, previous]);</span>
                <span class="s1">optionalSequence = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(optionalSequence) {</span>
                    <span class="s1">utility.throwError(</span><span class="s3">'unexpected token'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(rest) {</span>
                <span class="s1">expr = maybeAddRange({</span>
                    <span class="s1">type: Syntax.RestType,</span>
                    <span class="s1">expression: expr</span>
                <span class="s1">}, [restStartIndex, previous]);</span>
            <span class="s1">}</span>
            <span class="s1">params.push(expr);</span>
            <span class="s2">if </span><span class="s1">(token !== Token.RPAREN) {</span>
                <span class="s1">expect(Token.COMMA);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">params;</span>
    <span class="s1">}</span>

    <span class="s0">// FunctionType := 'function' FunctionSignatureType</span>
    <span class="s0">//</span>
    <span class="s0">// FunctionSignatureType :=</span>
    <span class="s0">//   | TypeParameters '(' ')' ResultType</span>
    <span class="s0">//   | TypeParameters '(' ParametersType ')' ResultType</span>
    <span class="s0">//   | TypeParameters '(' 'this' ':' TypeName ')' ResultType</span>
    <span class="s0">//   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType</span>
    <span class="s2">function </span><span class="s1">parseFunctionType() {</span>
        <span class="s2">var </span><span class="s1">isNew, thisBinding, params, result, fnType, startIndex = index - value.length;</span>
        <span class="s1">utility.assert(token === Token.NAME &amp;&amp; value === </span><span class="s3">'function'</span><span class="s1">, </span><span class="s3">'FunctionType should start with </span><span class="s5">\'</span><span class="s3">function</span><span class="s5">\'</span><span class="s3">'</span><span class="s1">);</span>
        <span class="s1">consume(Token.NAME);</span>

        <span class="s0">// Google Closure Compiler is not implementing TypeParameters.</span>
        <span class="s0">// So we do not. if we don't get '(', we see it as error.</span>
        <span class="s1">expect(Token.LPAREN);</span>

        <span class="s1">isNew = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">params = [];</span>
        <span class="s1">thisBinding = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(token !== Token.RPAREN) {</span>
            <span class="s0">// ParametersType or 'this'</span>
            <span class="s2">if </span><span class="s1">(token === Token.NAME &amp;&amp;</span>
                    <span class="s1">(value === </span><span class="s3">'this' </span><span class="s1">|| value === </span><span class="s3">'new'</span><span class="s1">)) {</span>
                <span class="s0">// 'this' or 'new'</span>
                <span class="s0">// 'new' is Closure Compiler extension</span>
                <span class="s1">isNew = value === </span><span class="s3">'new'</span><span class="s1">;</span>
                <span class="s1">consume(Token.NAME);</span>
                <span class="s1">expect(Token.COLON);</span>
                <span class="s1">thisBinding = parseTypeName();</span>
                <span class="s2">if </span><span class="s1">(token === Token.COMMA) {</span>
                    <span class="s1">consume(Token.COMMA);</span>
                    <span class="s1">params = parseParametersType();</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">params = parseParametersType();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">expect(Token.RPAREN);</span>

        <span class="s1">result = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(token === Token.COLON) {</span>
            <span class="s1">result = parseResultType();</span>
        <span class="s1">}</span>

        <span class="s1">fnType = maybeAddRange({</span>
            <span class="s1">type: Syntax.FunctionType,</span>
            <span class="s1">params: params,</span>
            <span class="s1">result: result</span>
        <span class="s1">}, [startIndex, previous]);</span>
        <span class="s2">if </span><span class="s1">(thisBinding) {</span>
            <span class="s0">// avoid adding null 'new' and 'this' properties</span>
            <span class="s1">fnType[</span><span class="s3">'this'</span><span class="s1">] = thisBinding;</span>
            <span class="s2">if </span><span class="s1">(isNew) {</span>
                <span class="s1">fnType[</span><span class="s3">'new'</span><span class="s1">] = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">fnType;</span>
    <span class="s1">}</span>

    <span class="s0">// BasicTypeExpression :=</span>
    <span class="s0">//     '*'</span>
    <span class="s0">//   | 'null'</span>
    <span class="s0">//   | 'undefined'</span>
    <span class="s0">//   | TypeName</span>
    <span class="s0">//   | FunctionType</span>
    <span class="s0">//   | UnionType</span>
    <span class="s0">//   | RecordType</span>
    <span class="s0">//   | ArrayType</span>
    <span class="s2">function </span><span class="s1">parseBasicTypeExpression() {</span>
        <span class="s2">var </span><span class="s1">context, startIndex;</span>
        <span class="s2">switch </span><span class="s1">(token) {</span>
        <span class="s2">case </span><span class="s1">Token.STAR:</span>
            <span class="s1">consume(Token.STAR);</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.AllLiteral</span>
            <span class="s1">}, [previous - </span><span class="s4">1</span><span class="s1">, previous]);</span>

        <span class="s2">case </span><span class="s1">Token.LPAREN:</span>
            <span class="s2">return </span><span class="s1">parseUnionType();</span>

        <span class="s2">case </span><span class="s1">Token.LBRACK:</span>
            <span class="s2">return </span><span class="s1">parseArrayType();</span>

        <span class="s2">case </span><span class="s1">Token.LBRACE:</span>
            <span class="s2">return </span><span class="s1">parseRecordType();</span>

        <span class="s2">case </span><span class="s1">Token.NAME:</span>
            <span class="s1">startIndex = index - value.length;</span>

            <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'null'</span><span class="s1">) {</span>
                <span class="s1">consume(Token.NAME);</span>
                <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                    <span class="s1">type: Syntax.NullLiteral</span>
                <span class="s1">}, [startIndex, previous]);</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'undefined'</span><span class="s1">) {</span>
                <span class="s1">consume(Token.NAME);</span>
                <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                    <span class="s1">type: Syntax.UndefinedLiteral</span>
                <span class="s1">}, [startIndex, previous]);</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'true' </span><span class="s1">|| value === </span><span class="s3">'false'</span><span class="s1">) {</span>
                <span class="s1">consume(Token.NAME);</span>
                <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                    <span class="s1">type: Syntax.BooleanLiteralType,</span>
                    <span class="s1">value: value === </span><span class="s3">'true'</span>
                <span class="s1">}, [startIndex, previous]);</span>
            <span class="s1">}</span>

            <span class="s1">context = Context.save();</span>
            <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'function'</span><span class="s1">) {</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">return </span><span class="s1">parseFunctionType();</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
                    <span class="s1">context.restore();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">parseTypeName();</span>

        <span class="s2">case </span><span class="s1">Token.STRING:</span>
            <span class="s1">next();</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.StringLiteralType,</span>
                <span class="s1">value: value</span>
            <span class="s1">}, [previous - value.length - </span><span class="s4">2</span><span class="s1">, previous]);</span>

        <span class="s2">case </span><span class="s1">Token.NUMBER:</span>
            <span class="s1">next();</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.NumericLiteralType,</span>
                <span class="s1">value: value</span>
            <span class="s1">}, [previous - String(value).length, previous]);</span>

        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">utility.throwError(</span><span class="s3">'unexpected token'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// TypeExpression :=</span>
    <span class="s0">//     BasicTypeExpression</span>
    <span class="s0">//   | '?' BasicTypeExpression</span>
    <span class="s0">//   | '!' BasicTypeExpression</span>
    <span class="s0">//   | BasicTypeExpression '?'</span>
    <span class="s0">//   | BasicTypeExpression '!'</span>
    <span class="s0">//   | '?'</span>
    <span class="s0">//   | BasicTypeExpression '[]'</span>
    <span class="s2">function </span><span class="s1">parseTypeExpression() {</span>
        <span class="s2">var </span><span class="s1">expr, rangeStart;</span>

        <span class="s2">if </span><span class="s1">(token === Token.QUESTION) {</span>
            <span class="s1">rangeStart = index - </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">consume(Token.QUESTION);</span>
            <span class="s2">if </span><span class="s1">(token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||</span>
                    <span class="s1">token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||</span>
                    <span class="s1">token === Token.RBRACK || token === Token.GT) {</span>
                <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                    <span class="s1">type: Syntax.NullableLiteral</span>
                <span class="s1">}, [rangeStart, previous]);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.NullableType,</span>
                <span class="s1">expression: parseBasicTypeExpression(),</span>
                <span class="s1">prefix: </span><span class="s2">true</span>
            <span class="s1">}, [rangeStart, previous]);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(token === Token.BANG) {</span>
            <span class="s1">rangeStart = index - </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">consume(Token.BANG);</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.NonNullableType,</span>
                <span class="s1">expression: parseBasicTypeExpression(),</span>
                <span class="s1">prefix: </span><span class="s2">true</span>
            <span class="s1">}, [rangeStart, previous]);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">rangeStart = previous;</span>
        <span class="s1">}</span>

        <span class="s1">expr = parseBasicTypeExpression();</span>
        <span class="s2">if </span><span class="s1">(token === Token.BANG) {</span>
            <span class="s1">consume(Token.BANG);</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.NonNullableType,</span>
                <span class="s1">expression: expr,</span>
                <span class="s1">prefix: </span><span class="s2">false</span>
            <span class="s1">}, [rangeStart, previous]);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(token === Token.QUESTION) {</span>
            <span class="s1">consume(Token.QUESTION);</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.NullableType,</span>
                <span class="s1">expression: expr,</span>
                <span class="s1">prefix: </span><span class="s2">false</span>
            <span class="s1">}, [rangeStart, previous]);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(token === Token.LBRACK) {</span>
            <span class="s1">consume(Token.LBRACK);</span>
            <span class="s1">expect(Token.RBRACK, </span><span class="s3">'expected an array-style type declaration (' </span><span class="s1">+ value + </span><span class="s3">'[])'</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.TypeApplication,</span>
                <span class="s1">expression: maybeAddRange({</span>
                    <span class="s1">type: Syntax.NameExpression,</span>
                    <span class="s1">name: </span><span class="s3">'Array'</span>
                <span class="s1">}, [rangeStart, previous]),</span>
                <span class="s1">applications: [expr]</span>
            <span class="s1">}, [rangeStart, previous]);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">expr;</span>
    <span class="s1">}</span>

    <span class="s0">// TopLevelTypeExpression :=</span>
    <span class="s0">//      TypeExpression</span>
    <span class="s0">//    | TypeUnionList</span>
    <span class="s0">//</span>
    <span class="s0">// This rule is Google Closure Compiler extension, not ES4</span>
    <span class="s0">// like,</span>
    <span class="s0">//   { number | string }</span>
    <span class="s0">// If strict to ES4, we should write it as</span>
    <span class="s0">//   { (number|string) }</span>
    <span class="s2">function </span><span class="s1">parseTop() {</span>
        <span class="s2">var </span><span class="s1">expr, elements;</span>

        <span class="s1">expr = parseTypeExpression();</span>
        <span class="s2">if </span><span class="s1">(token !== Token.PIPE) {</span>
            <span class="s2">return </span><span class="s1">expr;</span>
        <span class="s1">}</span>

        <span class="s1">elements = [expr];</span>
        <span class="s1">consume(Token.PIPE);</span>
        <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">elements.push(parseTypeExpression());</span>
            <span class="s2">if </span><span class="s1">(token !== Token.PIPE) {</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">consume(Token.PIPE);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">maybeAddRange({</span>
            <span class="s1">type: Syntax.UnionType,</span>
            <span class="s1">elements: elements</span>
        <span class="s1">}, [</span><span class="s4">0</span><span class="s1">, index]);</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">parseTopParamType() {</span>
        <span class="s2">var </span><span class="s1">expr;</span>

        <span class="s2">if </span><span class="s1">(token === Token.REST) {</span>
            <span class="s1">consume(Token.REST);</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.RestType,</span>
                <span class="s1">expression: parseTop()</span>
            <span class="s1">}, [</span><span class="s4">0</span><span class="s1">, index]);</span>
        <span class="s1">}</span>

        <span class="s1">expr = parseTop();</span>
        <span class="s2">if </span><span class="s1">(token === Token.EQUAL) {</span>
            <span class="s1">consume(Token.EQUAL);</span>
            <span class="s2">return </span><span class="s1">maybeAddRange({</span>
                <span class="s1">type: Syntax.OptionalType,</span>
                <span class="s1">expression: expr</span>
            <span class="s1">}, [</span><span class="s4">0</span><span class="s1">, index]);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">expr;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">parseType(src, opt) {</span>
        <span class="s2">var </span><span class="s1">expr;</span>

        <span class="s1">source = src;</span>
        <span class="s1">length = source.length;</span>
        <span class="s1">index = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">previous = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">addRange = opt &amp;&amp; opt.range;</span>
        <span class="s1">rangeOffset = opt &amp;&amp; opt.startIndex || </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s1">next();</span>
        <span class="s1">expr = parseTop();</span>

        <span class="s2">if </span><span class="s1">(opt &amp;&amp; opt.midstream) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">expression: expr,</span>
                <span class="s1">index: previous</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(token !== Token.EOF) {</span>
            <span class="s1">utility.throwError(</span><span class="s3">'not reach to EOF'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">expr;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">parseParamType(src, opt) {</span>
        <span class="s2">var </span><span class="s1">expr;</span>

        <span class="s1">source = src;</span>
        <span class="s1">length = source.length;</span>
        <span class="s1">index = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">previous = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">addRange = opt &amp;&amp; opt.range;</span>
        <span class="s1">rangeOffset = opt &amp;&amp; opt.startIndex || </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s1">next();</span>
        <span class="s1">expr = parseTopParamType();</span>

        <span class="s2">if </span><span class="s1">(opt &amp;&amp; opt.midstream) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">expression: expr,</span>
                <span class="s1">index: previous</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(token !== Token.EOF) {</span>
            <span class="s1">utility.throwError(</span><span class="s3">'not reach to EOF'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">expr;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">stringifyImpl(node, compact, topLevel) {</span>
        <span class="s2">var </span><span class="s1">result, i, iz;</span>

        <span class="s2">switch </span><span class="s1">(node.type) {</span>
        <span class="s2">case </span><span class="s1">Syntax.NullableLiteral:</span>
            <span class="s1">result = </span><span class="s3">'?'</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.AllLiteral:</span>
            <span class="s1">result = </span><span class="s3">'*'</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.NullLiteral:</span>
            <span class="s1">result = </span><span class="s3">'null'</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.UndefinedLiteral:</span>
            <span class="s1">result = </span><span class="s3">'undefined'</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.VoidLiteral:</span>
            <span class="s1">result = </span><span class="s3">'void'</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.UnionType:</span>
            <span class="s2">if </span><span class="s1">(!topLevel) {</span>
                <span class="s1">result = </span><span class="s3">'('</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">result = </span><span class="s3">''</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">, iz = node.elements.length; i &lt; iz; ++i) {</span>
                <span class="s1">result += stringifyImpl(node.elements[i], compact);</span>
                <span class="s2">if </span><span class="s1">((i + </span><span class="s4">1</span><span class="s1">) !== iz) {</span>
                    <span class="s1">result += compact ? </span><span class="s3">'|' </span><span class="s1">: </span><span class="s3">' | '</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(!topLevel) {</span>
                <span class="s1">result += </span><span class="s3">')'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.ArrayType:</span>
            <span class="s1">result = </span><span class="s3">'['</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">, iz = node.elements.length; i &lt; iz; ++i) {</span>
                <span class="s1">result += stringifyImpl(node.elements[i], compact);</span>
                <span class="s2">if </span><span class="s1">((i + </span><span class="s4">1</span><span class="s1">) !== iz) {</span>
                    <span class="s1">result += compact ? </span><span class="s3">',' </span><span class="s1">: </span><span class="s3">', '</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">result += </span><span class="s3">']'</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.RecordType:</span>
            <span class="s1">result = </span><span class="s3">'{'</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">, iz = node.fields.length; i &lt; iz; ++i) {</span>
                <span class="s1">result += stringifyImpl(node.fields[i], compact);</span>
                <span class="s2">if </span><span class="s1">((i + </span><span class="s4">1</span><span class="s1">) !== iz) {</span>
                    <span class="s1">result += compact ? </span><span class="s3">',' </span><span class="s1">: </span><span class="s3">', '</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">result += </span><span class="s3">'}'</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.FieldType:</span>
            <span class="s2">if </span><span class="s1">(node.value) {</span>
                <span class="s1">result = node.key + (compact ? </span><span class="s3">':' </span><span class="s1">: </span><span class="s3">': '</span><span class="s1">) + stringifyImpl(node.value, compact);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">result = node.key;</span>
            <span class="s1">}</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.FunctionType:</span>
            <span class="s1">result = compact ? </span><span class="s3">'function(' </span><span class="s1">: </span><span class="s3">'function ('</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(node[</span><span class="s3">'this'</span><span class="s1">]) {</span>
                <span class="s2">if </span><span class="s1">(node[</span><span class="s3">'new'</span><span class="s1">]) {</span>
                    <span class="s1">result += (compact ? </span><span class="s3">'new:' </span><span class="s1">: </span><span class="s3">'new: '</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">result += (compact ? </span><span class="s3">'this:' </span><span class="s1">: </span><span class="s3">'this: '</span><span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s1">result += stringifyImpl(node[</span><span class="s3">'this'</span><span class="s1">], compact);</span>

                <span class="s2">if </span><span class="s1">(node.params.length !== </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">result += compact ? </span><span class="s3">',' </span><span class="s1">: </span><span class="s3">', '</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">, iz = node.params.length; i &lt; iz; ++i) {</span>
                <span class="s1">result += stringifyImpl(node.params[i], compact);</span>
                <span class="s2">if </span><span class="s1">((i + </span><span class="s4">1</span><span class="s1">) !== iz) {</span>
                    <span class="s1">result += compact ? </span><span class="s3">',' </span><span class="s1">: </span><span class="s3">', '</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">result += </span><span class="s3">')'</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(node.result) {</span>
                <span class="s1">result += (compact ? </span><span class="s3">':' </span><span class="s1">: </span><span class="s3">': '</span><span class="s1">) + stringifyImpl(node.result, compact);</span>
            <span class="s1">}</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.ParameterType:</span>
            <span class="s1">result = node.name + (compact ? </span><span class="s3">':' </span><span class="s1">: </span><span class="s3">': '</span><span class="s1">) + stringifyImpl(node.expression, compact);</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.RestType:</span>
            <span class="s1">result = </span><span class="s3">'...'</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(node.expression) {</span>
                <span class="s1">result += stringifyImpl(node.expression, compact);</span>
            <span class="s1">}</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.NonNullableType:</span>
            <span class="s2">if </span><span class="s1">(node.prefix) {</span>
                <span class="s1">result = </span><span class="s3">'!' </span><span class="s1">+ stringifyImpl(node.expression, compact);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">result = stringifyImpl(node.expression, compact) + </span><span class="s3">'!'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.OptionalType:</span>
            <span class="s1">result = stringifyImpl(node.expression, compact) + </span><span class="s3">'='</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.NullableType:</span>
            <span class="s2">if </span><span class="s1">(node.prefix) {</span>
                <span class="s1">result = </span><span class="s3">'?' </span><span class="s1">+ stringifyImpl(node.expression, compact);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">result = stringifyImpl(node.expression, compact) + </span><span class="s3">'?'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.NameExpression:</span>
            <span class="s1">result = node.name;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.TypeApplication:</span>
            <span class="s1">result = stringifyImpl(node.expression, compact) + </span><span class="s3">'.&lt;'</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">, iz = node.applications.length; i &lt; iz; ++i) {</span>
                <span class="s1">result += stringifyImpl(node.applications[i], compact);</span>
                <span class="s2">if </span><span class="s1">((i + </span><span class="s4">1</span><span class="s1">) !== iz) {</span>
                    <span class="s1">result += compact ? </span><span class="s3">',' </span><span class="s1">: </span><span class="s3">', '</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">result += </span><span class="s3">'&gt;'</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.StringLiteralType:</span>
            <span class="s1">result = </span><span class="s3">'&quot;' </span><span class="s1">+ node.value + </span><span class="s3">'&quot;'</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.NumericLiteralType:</span>
            <span class="s1">result = String(node.value);</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">Syntax.BooleanLiteralType:</span>
            <span class="s1">result = String(node.value);</span>
            <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">utility.throwError(</span><span class="s3">'Unknown type ' </span><span class="s1">+ node.type);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">stringify(node, options) {</span>
        <span class="s2">if </span><span class="s1">(options == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">options = {};</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">stringifyImpl(node, options.compact, options.topLevel);</span>
    <span class="s1">}</span>

    <span class="s1">exports.parseType = parseType;</span>
    <span class="s1">exports.parseParamType = parseParamType;</span>
    <span class="s1">exports.stringify = stringify;</span>
    <span class="s1">exports.Syntax = Syntax;</span>
<span class="s1">}());</span>
<span class="s0">/* vim: set sw=4 ts=4 et tw=80 : */</span>
</pre>
</body>
</html>