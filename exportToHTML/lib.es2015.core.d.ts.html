<html>
<head>
<title>lib.es2015.core.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lib.es2015.core.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/*! ***************************************************************************** 
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use 
this file except in compliance with the License. You may obtain a copy of the 
License at http://www.apache.org/licenses/LICENSE-2.0 
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED 
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions 
and limitations under the License. 
***************************************************************************** */</span>


<span class="s0">/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</span>

<span class="s2">interface </span><span class="s1">Array&lt;T&gt; {</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the value of the first element in the array where predicate is true, and undefined</span>
     <span class="s0">* otherwise.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">predicate find calls predicate once for each element of the array, in ascending</span>
     <span class="s0">* order, until it finds one where predicate returns true. If such an element is found, find</span>
     <span class="s0">* immediately returns that element value. Otherwise, find returns undefined.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">thisArg If provided, it will be used as the this value for each invocation of</span>
     <span class="s0">* predicate. If it is not provided, undefined is used instead.</span>
     <span class="s0">*/</span>
    <span class="s1">find&lt;S </span><span class="s2">extends </span><span class="s1">T&gt;(predicate: (value: T, index: number, obj: T[]) =&gt; value is S, thisArg?: any): S | undefined;</span>
    <span class="s1">find(predicate: (value: T, index: number, obj: T[]) =&gt; unknown, thisArg?: any): T | undefined;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the index of the first element in the array where predicate is true, and -1</span>
     <span class="s0">* otherwise.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">predicate find calls predicate once for each element of the array, in ascending</span>
     <span class="s0">* order, until it finds one where predicate returns true. If such an element is found,</span>
     <span class="s0">* findIndex immediately returns that element index. Otherwise, findIndex returns -1.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">thisArg If provided, it will be used as the this value for each invocation of</span>
     <span class="s0">* predicate. If it is not provided, undefined is used instead.</span>
     <span class="s0">*/</span>
    <span class="s1">findIndex(predicate: (value: T, index: number, obj: T[]) =&gt; unknown, thisArg?: any): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Changes all array elements from `start` to `end` index to a static `value` and returns the modified array</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">value value to fill array section with</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">start index to start filling the array at. If start is negative, it is treated as</span>
     <span class="s0">* length+start where length is the length of the array.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">end index to stop filling the array at. If end is negative, it is treated as</span>
     <span class="s0">* length+end.</span>
     <span class="s0">*/</span>
    <span class="s1">fill(value: T, start?: number, end?: number): </span><span class="s2">this</span><span class="s1">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the this object after copying a section of the array identified by start and end</span>
     <span class="s0">* to the same array starting at position target</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">target If target is negative, it is treated as length+target where length is the</span>
     <span class="s0">* length of the array.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">start If start is negative, it is treated as length+start. If end is negative, it</span>
     <span class="s0">* is treated as length+end.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">end If not specified, length of the this object is used as its default value.</span>
     <span class="s0">*/</span>
    <span class="s1">copyWithin(target: number, start: number, end?: number): </span><span class="s2">this</span><span class="s1">;</span>

    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions &amp; Intl.DateTimeFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">ArrayConstructor {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates an array from an array-like object.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">arrayLike An array-like object to convert to an array.</span>
     <span class="s0">*/</span>
    <span class="s1">from&lt;T&gt;(arrayLike: ArrayLike&lt;T&gt;): T[];</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates an array from an iterable object.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">arrayLike An array-like object to convert to an array.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">mapfn A mapping function to call on every element of the array.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">thisArg Value of 'this' used to invoke the mapfn.</span>
     <span class="s0">*/</span>
    <span class="s1">from&lt;T, U&gt;(arrayLike: ArrayLike&lt;T&gt;, mapfn: (v: T, k: number) =&gt; U, thisArg?: any): U[];</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a new array from a set of elements.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">items A set of elements to include in the new array object.</span>
     <span class="s0">*/</span>
    <span class="s1">of&lt;T&gt;(...items: T[]): T[];</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">DateConstructor {</span>
    <span class="s2">new </span><span class="s1">(value: number | string | Date): Date;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Function {</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the name of the function. Function names are read-only and can not be changed.</span>
     <span class="s0">*/</span>
    <span class="s1">readonly name: string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Math {</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the number of leading zero bits in the 32-bit binary representation of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression.</span>
     <span class="s0">*/</span>
    <span class="s1">clz32(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the result of 32-bit multiplication of two numbers.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x First number</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">y Second number</span>
     <span class="s0">*/</span>
    <span class="s1">imul(x: number, y: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the sign of the x, indicating whether x is positive, negative or zero.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x The numeric expression to test</span>
     <span class="s0">*/</span>
    <span class="s1">sign(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the base 10 logarithm of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression.</span>
     <span class="s0">*/</span>
    <span class="s1">log10(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the base 2 logarithm of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression.</span>
     <span class="s0">*/</span>
    <span class="s1">log2(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the natural logarithm of 1 + x.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression.</span>
     <span class="s0">*/</span>
    <span class="s1">log1p(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the result of (e^x - 1), which is an implementation-dependent approximation to</span>
     <span class="s0">* subtracting 1 from the exponential function of x (e raised to the power of x, where e</span>
     <span class="s0">* is the base of the natural logarithms).</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression.</span>
     <span class="s0">*/</span>
    <span class="s1">expm1(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the hyperbolic cosine of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression that contains an angle measured in radians.</span>
     <span class="s0">*/</span>
    <span class="s1">cosh(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the hyperbolic sine of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression that contains an angle measured in radians.</span>
     <span class="s0">*/</span>
    <span class="s1">sinh(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the hyperbolic tangent of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression that contains an angle measured in radians.</span>
     <span class="s0">*/</span>
    <span class="s1">tanh(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the inverse hyperbolic cosine of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression that contains an angle measured in radians.</span>
     <span class="s0">*/</span>
    <span class="s1">acosh(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the inverse hyperbolic sine of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression that contains an angle measured in radians.</span>
     <span class="s0">*/</span>
    <span class="s1">asinh(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the inverse hyperbolic tangent of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression that contains an angle measured in radians.</span>
     <span class="s0">*/</span>
    <span class="s1">atanh(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the square root of the sum of squares of its arguments.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">values Values to compute the square root for.</span>
     <span class="s0">*     If no arguments are passed, the result is +0.</span>
     <span class="s0">*     If there is only one argument, the result is the absolute value.</span>
     <span class="s0">*     If any argument is +Infinity or -Infinity, the result is +Infinity.</span>
     <span class="s0">*     If any argument is NaN, the result is NaN.</span>
     <span class="s0">*     If all arguments are either +0 or −0, the result is +0.</span>
     <span class="s0">*/</span>
    <span class="s1">hypot(...values: number[]): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the integral part of the a numeric expression, x, removing any fractional digits.</span>
     <span class="s0">* If x is already an integer, the result is x.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression.</span>
     <span class="s0">*/</span>
    <span class="s1">trunc(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the nearest single precision float representation of a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression.</span>
     <span class="s0">*/</span>
    <span class="s1">fround(x: number): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns an implementation-dependent approximation to the cube root of number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">x A numeric expression.</span>
     <span class="s0">*/</span>
    <span class="s1">cbrt(x: number): number;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">NumberConstructor {</span>
    <span class="s0">/**</span>
     <span class="s0">* The value of Number.EPSILON is the difference between 1 and the smallest value greater than 1</span>
     <span class="s0">* that is representable as a Number value, which is approximately:</span>
     <span class="s0">* 2.2204460492503130808472633361816 x 10‍−‍16.</span>
     <span class="s0">*/</span>
    <span class="s1">readonly EPSILON: number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if passed value is finite.</span>
     <span class="s0">* Unlike the global isFinite, Number.isFinite doesn't forcibly convert the parameter to a</span>
     <span class="s0">* number. Only finite values of the type number, result in true.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">number A numeric value.</span>
     <span class="s0">*/</span>
    <span class="s1">isFinite(number: unknown): boolean;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the value passed is an integer, false otherwise.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">number A numeric value.</span>
     <span class="s0">*/</span>
    <span class="s1">isInteger(number: unknown): boolean;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a Boolean value that indicates whether a value is the reserved value NaN (not a</span>
     <span class="s0">* number). Unlike the global isNaN(), Number.isNaN() doesn't forcefully convert the parameter</span>
     <span class="s0">* to a number. Only values of the type number, that are also NaN, result in true.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">number A numeric value.</span>
     <span class="s0">*/</span>
    <span class="s1">isNaN(number: unknown): boolean;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the value passed is a safe integer.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">number A numeric value.</span>
     <span class="s0">*/</span>
    <span class="s1">isSafeInteger(number: unknown): boolean;</span>

    <span class="s0">/**</span>
     <span class="s0">* The value of the largest integer n such that n and n + 1 are both exactly representable as</span>
     <span class="s0">* a Number value.</span>
     <span class="s0">* The value of Number.MAX_SAFE_INTEGER is 9007199254740991 2^53 − 1.</span>
     <span class="s0">*/</span>
    <span class="s1">readonly MAX_SAFE_INTEGER: number;</span>

    <span class="s0">/**</span>
     <span class="s0">* The value of the smallest integer n such that n and n − 1 are both exactly representable as</span>
     <span class="s0">* a Number value.</span>
     <span class="s0">* The value of Number.MIN_SAFE_INTEGER is −9007199254740991 (−(2^53 − 1)).</span>
     <span class="s0">*/</span>
    <span class="s1">readonly MIN_SAFE_INTEGER: number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Converts a string to a floating-point number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">string A string that contains a floating-point number.</span>
     <span class="s0">*/</span>
    <span class="s1">parseFloat(string: string): number;</span>

    <span class="s0">/**</span>
     <span class="s0">* Converts A string to an integer.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">string A string to convert into a number.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">radix A value between 2 and 36 that specifies the base of the number in `string`.</span>
     <span class="s0">* If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.</span>
     <span class="s0">* All other strings are considered decimal.</span>
     <span class="s0">*/</span>
    <span class="s1">parseInt(string: string, radix?: number): number;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">ObjectConstructor {</span>
    <span class="s0">/**</span>
     <span class="s0">* Copy the values of all of the enumerable own properties from one or more source objects to a</span>
     <span class="s0">* target object. Returns the target object.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">target The target object to copy to.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">source The source object from which to copy properties.</span>
     <span class="s0">*/</span>
    <span class="s1">assign&lt;T </span><span class="s2">extends </span><span class="s1">{}, U&gt;(target: T, source: U): T &amp; U;</span>

    <span class="s0">/**</span>
     <span class="s0">* Copy the values of all of the enumerable own properties from one or more source objects to a</span>
     <span class="s0">* target object. Returns the target object.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">target The target object to copy to.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">source1 The first source object from which to copy properties.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">source2 The second source object from which to copy properties.</span>
     <span class="s0">*/</span>
    <span class="s1">assign&lt;T </span><span class="s2">extends </span><span class="s1">{}, U, V&gt;(target: T, source1: U, source2: V): T &amp; U &amp; V;</span>

    <span class="s0">/**</span>
     <span class="s0">* Copy the values of all of the enumerable own properties from one or more source objects to a</span>
     <span class="s0">* target object. Returns the target object.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">target The target object to copy to.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">source1 The first source object from which to copy properties.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">source2 The second source object from which to copy properties.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">source3 The third source object from which to copy properties.</span>
     <span class="s0">*/</span>
    <span class="s1">assign&lt;T </span><span class="s2">extends </span><span class="s1">{}, U, V, W&gt;(target: T, source1: U, source2: V, source3: W): T &amp; U &amp; V &amp; W;</span>

    <span class="s0">/**</span>
     <span class="s0">* Copy the values of all of the enumerable own properties from one or more source objects to a</span>
     <span class="s0">* target object. Returns the target object.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">target The target object to copy to.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">sources One or more source objects from which to copy properties</span>
     <span class="s0">*/</span>
    <span class="s1">assign(target: object, ...sources: any[]): any;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns an array of all symbol properties found directly on object o.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">o Object to retrieve the symbols from.</span>
     <span class="s0">*/</span>
    <span class="s1">getOwnPropertySymbols(o: any): symbol[];</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the names of the enumerable string properties and methods of an object.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.</span>
     <span class="s0">*/</span>
    <span class="s1">keys(o: {}): string[];</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the values are the same value, false otherwise.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">value1 The first value.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">value2 The second value.</span>
     <span class="s0">*/</span>
    <span class="s1">is(value1: any, value2: any): boolean;</span>

    <span class="s0">/**</span>
     <span class="s0">* Sets the prototype of a specified object o to object proto or null. Returns the object o.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">o The object to change its prototype.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">proto The value of the new prototype or null.</span>
     <span class="s0">*/</span>
    <span class="s1">setPrototypeOf(o: any, proto: object | </span><span class="s2">null</span><span class="s1">): any;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">ReadonlyArray&lt;T&gt; {</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the value of the first element in the array where predicate is true, and undefined</span>
     <span class="s0">* otherwise.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">predicate find calls predicate once for each element of the array, in ascending</span>
     <span class="s0">* order, until it finds one where predicate returns true. If such an element is found, find</span>
     <span class="s0">* immediately returns that element value. Otherwise, find returns undefined.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">thisArg If provided, it will be used as the this value for each invocation of</span>
     <span class="s0">* predicate. If it is not provided, undefined is used instead.</span>
     <span class="s0">*/</span>
    <span class="s1">find&lt;S </span><span class="s2">extends </span><span class="s1">T&gt;(predicate: (value: T, index: number, obj: readonly T[]) =&gt; value is S, thisArg?: any): S | undefined;</span>
    <span class="s1">find(predicate: (value: T, index: number, obj: readonly T[]) =&gt; unknown, thisArg?: any): T | undefined;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the index of the first element in the array where predicate is true, and -1</span>
     <span class="s0">* otherwise.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">predicate find calls predicate once for each element of the array, in ascending</span>
     <span class="s0">* order, until it finds one where predicate returns true. If such an element is found,</span>
     <span class="s0">* findIndex immediately returns that element index. Otherwise, findIndex returns -1.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">thisArg If provided, it will be used as the this value for each invocation of</span>
     <span class="s0">* predicate. If it is not provided, undefined is used instead.</span>
     <span class="s0">*/</span>
    <span class="s1">findIndex(predicate: (value: T, index: number, obj: readonly T[]) =&gt; unknown, thisArg?: any): number;</span>

    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions &amp; Intl.DateTimeFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">RegExp {</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a string indicating the flags of the regular expression in question. This field is read-only.</span>
     <span class="s0">* The characters in this string are sequenced and concatenated in the following order:</span>
     <span class="s0">*</span>
     <span class="s0">*    - &quot;g&quot; for global</span>
     <span class="s0">*    - &quot;i&quot; for ignoreCase</span>
     <span class="s0">*    - &quot;m&quot; for multiline</span>
     <span class="s0">*    - &quot;u&quot; for unicode</span>
     <span class="s0">*    - &quot;y&quot; for sticky</span>
     <span class="s0">*</span>
     <span class="s0">* If no flags are set, the value is the empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">readonly flags: string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a Boolean value indicating the state of the sticky flag (y) used with a regular</span>
     <span class="s0">* expression. Default is false. Read-only.</span>
     <span class="s0">*/</span>
    <span class="s1">readonly sticky: boolean;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a Boolean value indicating the state of the Unicode flag (u) used with a regular</span>
     <span class="s0">* expression. Default is false. Read-only.</span>
     <span class="s0">*/</span>
    <span class="s1">readonly unicode: boolean;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">RegExpConstructor {</span>
    <span class="s2">new </span><span class="s1">(pattern: RegExp | string, flags?: string): RegExp;</span>
    <span class="s1">(pattern: RegExp | string, flags?: string): RegExp;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">String {</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point</span>
     <span class="s0">* value of the UTF-16 encoded code point starting at the string element at position pos in</span>
     <span class="s0">* the String resulting from converting this object to a String.</span>
     <span class="s0">* If there is no element at that position, the result is undefined.</span>
     <span class="s0">* If a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.</span>
     <span class="s0">*/</span>
    <span class="s1">codePointAt(pos: number): number | undefined;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if searchString appears as a substring of the result of converting this</span>
     <span class="s0">* object to a String, at one or more positions that are</span>
     <span class="s0">* greater than or equal to position; otherwise, returns false.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">searchString search string</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">position If position is undefined, 0 is assumed, so as to search all of the String.</span>
     <span class="s0">*/</span>
    <span class="s1">includes(searchString: string, position?: number): boolean;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the sequence of elements of searchString converted to a String is the</span>
     <span class="s0">* same as the corresponding elements of this object (converted to a String) starting at</span>
     <span class="s0">* endPosition – length(this). Otherwise returns false.</span>
     <span class="s0">*/</span>
    <span class="s1">endsWith(searchString: string, endPosition?: number): boolean;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the String value result of normalizing the string into the normalization form</span>
     <span class="s0">* named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">form Applicable values: &quot;NFC&quot;, &quot;NFD&quot;, &quot;NFKC&quot;, or &quot;NFKD&quot;, If not specified default</span>
     <span class="s0">* is &quot;NFC&quot;</span>
     <span class="s0">*/</span>
    <span class="s1">normalize(form: </span><span class="s4">&quot;NFC&quot; </span><span class="s1">| </span><span class="s4">&quot;NFD&quot; </span><span class="s1">| </span><span class="s4">&quot;NFKC&quot; </span><span class="s1">| </span><span class="s4">&quot;NFKD&quot;</span><span class="s1">): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the String value result of normalizing the string into the normalization form</span>
     <span class="s0">* named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">form Applicable values: &quot;NFC&quot;, &quot;NFD&quot;, &quot;NFKC&quot;, or &quot;NFKD&quot;, If not specified default</span>
     <span class="s0">* is &quot;NFC&quot;</span>
     <span class="s0">*/</span>
    <span class="s1">normalize(form?: string): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a String value that is made from count copies appended together. If count is 0,</span>
     <span class="s0">* the empty string is returned.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">count number of copies to append</span>
     <span class="s0">*/</span>
    <span class="s1">repeat(count: number): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the sequence of elements of searchString converted to a String is the</span>
     <span class="s0">* same as the corresponding elements of this object (converted to a String) starting at</span>
     <span class="s0">* position. Otherwise returns false.</span>
     <span class="s0">*/</span>
    <span class="s1">startsWith(searchString: string, position?: number): boolean;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns an `&lt;a&gt;` HTML anchor element and sets the name attribute to the text value</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">name</span>
     <span class="s0">*/</span>
    <span class="s1">anchor(name: string): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;big&gt;` HTML element</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">big(): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;blink&gt;` HTML element</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">blink(): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;b&gt;` HTML element</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">bold(): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;tt&gt;` HTML element</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">fixed(): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;font&gt;` HTML element and sets the color attribute value</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">fontcolor(color: string): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;font&gt;` HTML element and sets the size attribute value</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">fontsize(size: number): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;font&gt;` HTML element and sets the size attribute value</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">fontsize(size: string): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns an `&lt;i&gt;` HTML element</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">italics(): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns an `&lt;a&gt;` HTML element and sets the href attribute value</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">link(url: string): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;small&gt;` HTML element</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">small(): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;strike&gt;` HTML element</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">strike(): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;sub&gt;` HTML element</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">sub(): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a `&lt;sup&gt;` HTML element</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">A legacy feature for browser compatibility</span>
     <span class="s0">*/</span>
    <span class="s1">sup(): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">StringConstructor {</span>
    <span class="s0">/**</span>
     <span class="s0">* Return the String value whose elements are, in order, the elements in the List elements.</span>
     <span class="s0">* If length is 0, the empty string is returned.</span>
     <span class="s0">*/</span>
    <span class="s1">fromCodePoint(...codePoints: number[]): string;</span>

    <span class="s0">/**</span>
     <span class="s0">* String.raw is usually used as a tag function of a Tagged Template String. When called as</span>
     <span class="s0">* such, the first argument will be a well formed template call site object and the rest</span>
     <span class="s0">* parameter will contain the substitution values. It can also be called directly, for example,</span>
     <span class="s0">* to interleave strings and values from your own tag function, and in this case the only thing</span>
     <span class="s0">* it needs from the first argument is the raw property.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">template A well-formed template string call site representation.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">substitutions A set of substitution values.</span>
     <span class="s0">*/</span>
    <span class="s1">raw(template: { raw: readonly string[] | ArrayLike&lt;string&gt;; }, ...substitutions: any[]): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Int8Array&lt;TArrayBuffer </span><span class="s2">extends </span><span class="s1">ArrayBufferLike&gt; {</span>
    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Uint8Array&lt;TArrayBuffer </span><span class="s2">extends </span><span class="s1">ArrayBufferLike&gt; {</span>
    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Uint8ClampedArray&lt;TArrayBuffer </span><span class="s2">extends </span><span class="s1">ArrayBufferLike&gt; {</span>
    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Int16Array&lt;TArrayBuffer </span><span class="s2">extends </span><span class="s1">ArrayBufferLike&gt; {</span>
    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Uint16Array&lt;TArrayBuffer </span><span class="s2">extends </span><span class="s1">ArrayBufferLike&gt; {</span>
    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Int32Array&lt;TArrayBuffer </span><span class="s2">extends </span><span class="s1">ArrayBufferLike&gt; {</span>
    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Uint32Array&lt;TArrayBuffer </span><span class="s2">extends </span><span class="s1">ArrayBufferLike&gt; {</span>
    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Float32Array&lt;TArrayBuffer </span><span class="s2">extends </span><span class="s1">ArrayBufferLike&gt; {</span>
    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Float64Array&lt;TArrayBuffer </span><span class="s2">extends </span><span class="s1">ArrayBufferLike&gt; {</span>
    <span class="s1">toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;</span>
<span class="s1">}</span>
</pre>
</body>
</html>