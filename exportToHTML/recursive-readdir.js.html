<html>
<head>
<title>recursive-readdir.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
recursive-readdir.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;recursiveReadDir&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">recursiveReadDir;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_promises = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;fs/promises&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">recursiveReadDir(rootDirectory, options = {}) {</span>
    <span class="s3">// Grab our options.</span>
    <span class="s2">const </span><span class="s1">{ pathnameFilter, ignoreFilter, ignorePartFilter, sortPathnames = </span><span class="s2">true</span><span class="s1">, relativePathnames = </span><span class="s2">true </span><span class="s1">} = options;</span>
    <span class="s3">// The list of pathnames to return.</span>
    <span class="s2">const </span><span class="s1">pathnames = [];</span>
    <span class="s3">/**</span>
   <span class="s3">* Coerces the pathname to be relative if requested.</span>
   <span class="s3">*/ </span><span class="s2">const </span><span class="s1">coerce = relativePathnames ? (pathname)=&gt;pathname.replace(rootDirectory, </span><span class="s0">''</span><span class="s1">) : (pathname)=&gt;pathname;</span>
    <span class="s3">// The queue of directories to scan.</span>
    <span class="s2">let </span><span class="s1">directories = [</span>
        <span class="s1">rootDirectory</span>
    <span class="s1">];</span>
    <span class="s2">while</span><span class="s1">(directories.length &gt; </span><span class="s4">0</span><span class="s1">){</span>
        <span class="s3">// Load all the files in each directory at the same time.</span>
        <span class="s2">const </span><span class="s1">results = </span><span class="s2">await </span><span class="s1">Promise.all(directories.map(async (directory)=&gt;{</span>
            <span class="s2">const </span><span class="s1">result = {</span>
                <span class="s1">directories: [],</span>
                <span class="s1">pathnames: [],</span>
                <span class="s1">links: []</span>
            <span class="s1">};</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">dir = </span><span class="s2">await </span><span class="s1">_promises.default.readdir(directory, {</span>
                    <span class="s1">withFileTypes: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of dir){</span>
                    <span class="s3">// If enabled, ignore the file if it matches the ignore filter.</span>
                    <span class="s2">if </span><span class="s1">(ignorePartFilter &amp;&amp; ignorePartFilter(file.name)) {</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">// Handle each file.</span>
                    <span class="s2">const </span><span class="s1">absolutePathname = _path.default.join(directory, file.name);</span>
                    <span class="s3">// If enabled, ignore the file if it matches the ignore filter.</span>
                    <span class="s2">if </span><span class="s1">(ignoreFilter &amp;&amp; ignoreFilter(absolutePathname)) {</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">// If the file is a directory, then add it to the list of directories,</span>
                    <span class="s3">// they'll be scanned on a later pass.</span>
                    <span class="s2">if </span><span class="s1">(file.isDirectory()) {</span>
                        <span class="s1">result.directories.push(absolutePathname);</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(file.isSymbolicLink()) {</span>
                        <span class="s1">result.links.push(absolutePathname);</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!pathnameFilter || pathnameFilter(absolutePathname)) {</span>
                        <span class="s1">result.pathnames.push(coerce(absolutePathname));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s3">// This can only happen when the underlying directory was removed. If</span>
                <span class="s3">// anything other than this error occurs, re-throw it.</span>
                <span class="s3">// if (err.code !== 'ENOENT') throw err</span>
                <span class="s2">if </span><span class="s1">(err.code !== </span><span class="s0">'ENOENT' </span><span class="s1">|| directory === rootDirectory) </span><span class="s2">throw </span><span class="s1">err;</span>
                <span class="s3">// The error occurred, so abandon reading this directory.</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}));</span>
        <span class="s3">// Empty the directories, we'll fill it later if some of the files are</span>
        <span class="s3">// directories.</span>
        <span class="s1">directories = [];</span>
        <span class="s3">// Keep track of any symbolic links we find, we'll resolve them later.</span>
        <span class="s2">const </span><span class="s1">links = [];</span>
        <span class="s3">// For each result of directory scans...</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">result of results){</span>
            <span class="s3">// If the directory was removed, then skip it.</span>
            <span class="s2">if </span><span class="s1">(!result) </span><span class="s2">continue</span><span class="s1">;</span>
            <span class="s3">// Add any directories to the list of directories to scan.</span>
            <span class="s1">directories.push(...result.directories);</span>
            <span class="s3">// Add any symbolic links to the list of symbolic links to resolve.</span>
            <span class="s1">links.push(...result.links);</span>
            <span class="s3">// Add any file pathnames to the list of pathnames.</span>
            <span class="s1">pathnames.push(...result.pathnames);</span>
        <span class="s1">}</span>
        <span class="s3">// Resolve all the symbolic links we found if any.</span>
        <span class="s2">if </span><span class="s1">(links.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">resolved = </span><span class="s2">await </span><span class="s1">Promise.all(links.map(async (absolutePathname)=&gt;{</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">return await </span><span class="s1">_promises.default.stat(absolutePathname);</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                    <span class="s3">// This can only happen when the underlying link was removed. If</span>
                    <span class="s3">// anything other than this error occurs, re-throw it.</span>
                    <span class="s2">if </span><span class="s1">(err.code !== </span><span class="s0">'ENOENT'</span><span class="s1">) </span><span class="s2">throw </span><span class="s1">err;</span>
                    <span class="s3">// The error occurred, so abandon reading this directory.</span>
                    <span class="s2">return null</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
            <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; links.length; i++){</span>
                <span class="s2">const </span><span class="s1">stats = resolved[i];</span>
                <span class="s3">// If the link was removed, then skip it.</span>
                <span class="s2">if </span><span class="s1">(!stats) </span><span class="s2">continue</span><span class="s1">;</span>
                <span class="s3">// We would have already ignored the file if it matched the ignore</span>
                <span class="s3">// filter, so we don't need to check it again.</span>
                <span class="s2">const </span><span class="s1">absolutePathname = links[i];</span>
                <span class="s2">if </span><span class="s1">(stats.isDirectory()) {</span>
                    <span class="s1">directories.push(absolutePathname);</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!pathnameFilter || pathnameFilter(absolutePathname)) {</span>
                    <span class="s1">pathnames.push(coerce(absolutePathname));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">// Sort the pathnames in place if requested.</span>
    <span class="s2">if </span><span class="s1">(sortPathnames) {</span>
        <span class="s1">pathnames.sort();</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">pathnames;</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=recursive-readdir.js.map</span></pre>
</body>
</html>