<html>
<head>
<title>app.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/build/static-paths/app.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { Params } from '../../server/request/params'</span><span class="s3">\n</span><span class="s1">import type { AppPageModule } from '../../server/route-modules/app-page/module'</span><span class="s3">\n</span><span class="s1">import type { AppSegment } from '../segment-config/app/app-segments'</span><span class="s3">\n</span><span class="s1">import type { PrerenderedRoute, StaticPathsResult } from './types'</span><span class="s3">\n\n</span><span class="s1">import path from 'node:path'</span><span class="s3">\n</span><span class="s1">import { AfterRunner } from '../../server/after/run-with-after'</span><span class="s3">\n</span><span class="s1">import { createWorkStore } from '../../server/async-storage/work-store'</span><span class="s3">\n</span><span class="s1">import { FallbackMode } from '../../lib/fallback'</span><span class="s3">\n</span><span class="s1">import { getRouteMatcher } from '../../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getRouteRegex,</span><span class="s3">\n  </span><span class="s1">type RouteRegex,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/router/utils/route-regex'</span><span class="s3">\n</span><span class="s1">import type { IncrementalCache } from '../../server/lib/incremental-cache'</span><span class="s3">\n</span><span class="s1">import { normalizePathname, encodeParam } from './utils'</span><span class="s3">\n</span><span class="s1">import escapePathDelimiters from '../../shared/lib/router/utils/escape-path-delimiters'</span><span class="s3">\n</span><span class="s1">import { createIncrementalCache } from '../../export/helpers/create-incremental-cache'</span><span class="s3">\n</span><span class="s1">import type { NextConfigComplete } from '../../server/config-shared'</span><span class="s3">\n</span><span class="s1">import type { WorkStore } from '../../server/app-render/work-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Filters out duplicate parameters from a list of parameters.</span><span class="s3">\n </span><span class="s1">* This function uses a Map to efficiently store and retrieve unique parameter combinations.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param routeParamKeys - The keys of the parameters. These should be sorted to ensure consistent key generation.</span><span class="s3">\n </span><span class="s1">* @param routeParams - The list of parameter objects to filter.</span><span class="s3">\n </span><span class="s1">* @returns A new array containing only the unique parameter combinations.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function filterUniqueParams(</span><span class="s3">\n  </span><span class="s1">routeParamKeys: readonly string[],</span><span class="s3">\n  </span><span class="s1">routeParams: readonly Params[]</span><span class="s3">\n</span><span class="s1">): Params[] {</span><span class="s3">\n  </span><span class="s1">// A Map is used to store unique parameter combinations. The key of the Map</span><span class="s3">\n  </span><span class="s1">// is a string representation of the parameter combination, and the value</span><span class="s3">\n  </span><span class="s1">// is the actual `Params` object.</span><span class="s3">\n  </span><span class="s1">const unique = new Map&lt;string, Params&gt;()</span><span class="s3">\n\n  </span><span class="s1">// Iterate over each parameter object in the input array.</span><span class="s3">\n  </span><span class="s1">for (const params of routeParams) {</span><span class="s3">\n    </span><span class="s1">let key = '' // Initialize an empty string to build the unique key for the current `params` object.</span><span class="s3">\n\n    </span><span class="s1">// Iterate through the `routeParamKeys` (which are assumed to be sorted).</span><span class="s3">\n    </span><span class="s1">// This consistent order is crucial for generating a stable and unique key</span><span class="s3">\n    </span><span class="s1">// for each parameter combination.</span><span class="s3">\n    </span><span class="s1">for (const paramKey of routeParamKeys) {</span><span class="s3">\n      </span><span class="s1">const value = params[paramKey]</span><span class="s3">\n\n      </span><span class="s1">// Construct a part of the key using the parameter key and its value.</span><span class="s3">\n      </span><span class="s1">// A type prefix (`A:` for Array, `S:` for String, `U:` for undefined) is added to the value</span><span class="s3">\n      </span><span class="s1">// to prevent collisions. For example, `['a', 'b']` and `'a,b'` would</span><span class="s3">\n      </span><span class="s1">// otherwise generate the same string representation, leading to incorrect</span><span class="s3">\n      </span><span class="s1">// deduplication. This ensures that different types with the same string</span><span class="s3">\n      </span><span class="s1">// representation are treated as distinct.</span><span class="s3">\n      </span><span class="s1">let valuePart: string</span><span class="s3">\n      </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n        </span><span class="s1">valuePart = `A:${value.join(',')}`</span><span class="s3">\n      </span><span class="s1">} else if (value === undefined) {</span><span class="s3">\n        </span><span class="s1">valuePart = `U:undefined`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">valuePart = `S:${value}`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">key += `${paramKey}:${valuePart}|`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the generated key is not already in the `unique` Map, it means this</span><span class="s3">\n    </span><span class="s1">// parameter combination is unique so far. Add it to the Map.</span><span class="s3">\n    </span><span class="s1">if (!unique.has(key)) {</span><span class="s3">\n      </span><span class="s1">unique.set(key, params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert the Map's values (the unique `Params` objects) back into an array</span><span class="s3">\n  </span><span class="s1">// and return it.</span><span class="s3">\n  </span><span class="s1">return Array.from(unique.values())</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates all unique sub-combinations of Route Parameters from a list of Static Parameters.</span><span class="s3">\n </span><span class="s1">* This function creates all possible prefixes of the Route Parameters, which is</span><span class="s3">\n </span><span class="s1">* useful for generating Static Shells that can serve as Fallback Shells for more specific Route Shells.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* When Root Parameters are provided, the function ensures that Static Shells only</span><span class="s3">\n </span><span class="s1">* include complete sets of Root Parameters. This prevents generating invalid Static Shells</span><span class="s3">\n </span><span class="s1">* that are missing required Root Parameters.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Example with Root Parameters ('lang', 'region') and Route Parameters ('lang', 'region', 'slug'):</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Given the following Static Parameters:</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">* [</span><span class="s3">\n </span><span class="s1">*   { lang: 'en', region: 'US', slug: ['home'] },</span><span class="s3">\n </span><span class="s1">*   { lang: 'en', region: 'US', slug: ['about'] },</span><span class="s3">\n </span><span class="s1">*   { lang: 'fr', region: 'CA', slug: ['about'] },</span><span class="s3">\n </span><span class="s1">* ]</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The result will be:</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">* [</span><span class="s3">\n </span><span class="s1">*   { lang: 'en', region: 'US' },  // Complete Root Parameters</span><span class="s3">\n </span><span class="s1">*   { lang: 'en', region: 'US', slug: ['home'] },</span><span class="s3">\n </span><span class="s1">*   { lang: 'en', region: 'US', slug: ['about'] },</span><span class="s3">\n </span><span class="s1">*   { lang: 'fr', region: 'CA' },  // Complete Root Parameters</span><span class="s3">\n </span><span class="s1">*   { lang: 'fr', region: 'CA', slug: ['about'] },</span><span class="s3">\n </span><span class="s1">* ]</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Note that partial combinations like `{ lang: 'en' }` are NOT generated because</span><span class="s3">\n </span><span class="s1">* they don't include the complete set of Root Parameters.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* For routes without Root Parameters (e.g., `/[slug]`), all sub-combinations are generated</span><span class="s3">\n </span><span class="s1">* as before.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param routeParamKeys - The keys of the Route Parameters. These should be sorted</span><span class="s3">\n </span><span class="s1">*   to ensure consistent key generation for the internal Map.</span><span class="s3">\n </span><span class="s1">* @param routeParams - The list of Static Parameters to filter.</span><span class="s3">\n </span><span class="s1">* @param rootParamKeys - The keys of the Root Parameters. When provided, ensures Static Shells</span><span class="s3">\n </span><span class="s1">*   include all Root Parameters.</span><span class="s3">\n </span><span class="s1">* @returns A new array containing all unique sub-combinations of Route Parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function generateAllParamCombinations(</span><span class="s3">\n  </span><span class="s1">routeParamKeys: readonly string[],</span><span class="s3">\n  </span><span class="s1">routeParams: readonly Params[],</span><span class="s3">\n  </span><span class="s1">rootParamKeys: readonly string[]</span><span class="s3">\n</span><span class="s1">): Params[] {</span><span class="s3">\n  </span><span class="s1">// A Map is used to store unique combinations of Route Parameters.</span><span class="s3">\n  </span><span class="s1">// The key of the Map is a string representation of the Route Parameter</span><span class="s3">\n  </span><span class="s1">// combination, and the value is the `Params` object containing only</span><span class="s3">\n  </span><span class="s1">// the Route Parameters.</span><span class="s3">\n  </span><span class="s1">const combinations = new Map&lt;string, Params&gt;()</span><span class="s3">\n\n  </span><span class="s1">// Determine the minimum index where all Root Parameters are included.</span><span class="s3">\n  </span><span class="s1">// This optimization ensures we only generate combinations that include</span><span class="s3">\n  </span><span class="s1">// a complete set of Root Parameters, preventing invalid Static Shells.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// For example, if rootParamKeys = ['lang', 'region'] and routeParamKeys = ['lang', 'region', 'slug']:</span><span class="s3">\n  </span><span class="s1">// - 'lang' is at index 0, 'region' is at index 1</span><span class="s3">\n  </span><span class="s1">// - minIndexForCompleteRootParams = max(0, 1) = 1</span><span class="s3">\n  </span><span class="s1">// - We'll only generate combinations starting from index 1 (which includes both lang and region)</span><span class="s3">\n  </span><span class="s1">let minIndexForCompleteRootParams = -1</span><span class="s3">\n  </span><span class="s1">if (rootParamKeys.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">// Find the index of the last Root Parameter in routeParamKeys.</span><span class="s3">\n    </span><span class="s1">// This tells us the minimum combination length needed to include all Root Parameters.</span><span class="s3">\n    </span><span class="s1">for (const rootParamKey of rootParamKeys) {</span><span class="s3">\n      </span><span class="s1">const index = routeParamKeys.indexOf(rootParamKey)</span><span class="s3">\n      </span><span class="s1">if (index === -1) {</span><span class="s3">\n        </span><span class="s1">// Root Parameter not found in Route Parameters - this shouldn't happen in normal cases</span><span class="s3">\n        </span><span class="s1">// but we handle it gracefully by treating it as if there are no Root Parameters.</span><span class="s3">\n        </span><span class="s1">// This allows the function to fall back to generating all sub-combinations.</span><span class="s3">\n        </span><span class="s1">minIndexForCompleteRootParams = -1</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// Track the highest index among all Root Parameters.</span><span class="s3">\n      </span><span class="s1">// This ensures all Root Parameters are included in any generated combination.</span><span class="s3">\n      </span><span class="s1">minIndexForCompleteRootParams = Math.max(</span><span class="s3">\n        </span><span class="s1">minIndexForCompleteRootParams,</span><span class="s3">\n        </span><span class="s1">index</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Iterate over each Static Parameter object in the input array.</span><span class="s3">\n  </span><span class="s1">// Each params object represents one potential route combination (e.g., { lang: 'en', region: 'US', slug: 'home' })</span><span class="s3">\n  </span><span class="s1">for (const params of routeParams) {</span><span class="s3">\n    </span><span class="s1">// Generate all possible prefix combinations for this Static Parameter set.</span><span class="s3">\n    </span><span class="s1">// For routeParamKeys = ['lang', 'region', 'slug'], we'll generate combinations at:</span><span class="s3">\n    </span><span class="s1">// - i=0: { lang: 'en' }</span><span class="s3">\n    </span><span class="s1">// - i=1: { lang: 'en', region: 'US' }</span><span class="s3">\n    </span><span class="s1">// - i=2: { lang: 'en', region: 'US', slug: 'home' }</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// The iteration order is crucial for generating stable and unique keys</span><span class="s3">\n    </span><span class="s1">// for each Route Parameter combination.</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; routeParamKeys.length; i++) {</span><span class="s3">\n      </span><span class="s1">// Skip generating combinations that don't include all Root Parameters.</span><span class="s3">\n      </span><span class="s1">// This prevents creating invalid Static Shells that are missing required Root Parameters.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// For example, if Root Parameters are ['lang', 'region'] and minIndexForCompleteRootParams = 1:</span><span class="s3">\n      </span><span class="s1">// - Skip i=0 (would only include 'lang', missing 'region')</span><span class="s3">\n      </span><span class="s1">// - Process i=1 and higher (includes both 'lang' and 'region')</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">minIndexForCompleteRootParams &gt;= 0 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">i &lt; minIndexForCompleteRootParams</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Initialize data structures for building this specific combination</span><span class="s3">\n      </span><span class="s1">const combination: Params = {}</span><span class="s3">\n      </span><span class="s1">const keyParts: string[] = []</span><span class="s3">\n      </span><span class="s1">let hasAllRootParams = true</span><span class="s3">\n\n      </span><span class="s1">// Build the sub-combination with parameters from index 0 to i (inclusive).</span><span class="s3">\n      </span><span class="s1">// This creates a prefix of the full parameter set, building up combinations incrementally.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// For example, if routeParamKeys = ['lang', 'region', 'slug'] and i = 1:</span><span class="s3">\n      </span><span class="s1">// - j=0: Add 'lang' parameter</span><span class="s3">\n      </span><span class="s1">// - j=1: Add 'region' parameter</span><span class="s3">\n      </span><span class="s1">// Result: { lang: 'en', region: 'US' }</span><span class="s3">\n      </span><span class="s1">for (let j = 0; j &lt;= i; j++) {</span><span class="s3">\n        </span><span class="s1">const routeKey = routeParamKeys[j]</span><span class="s3">\n\n        </span><span class="s1">// Check if the parameter exists in the original params object and has a defined value.</span><span class="s3">\n        </span><span class="s1">// This handles cases where generateStaticParams doesn't provide all possible parameters,</span><span class="s3">\n        </span><span class="s1">// or where some parameters are optional/undefined.</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!params.hasOwnProperty(routeKey) ||</span><span class="s3">\n          </span><span class="s1">params[routeKey] === undefined</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// If this missing parameter is a Root Parameter, mark the combination as invalid.</span><span class="s3">\n          </span><span class="s1">// Root Parameters are required for Static Shells, so we can't generate partial combinations without them.</span><span class="s3">\n          </span><span class="s1">if (rootParamKeys.includes(routeKey)) {</span><span class="s3">\n            </span><span class="s1">hasAllRootParams = false</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Stop building this combination since we've hit a missing parameter.</span><span class="s3">\n          </span><span class="s1">// This ensures we only generate valid prefix combinations with consecutive parameters.</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const value = params[routeKey]</span><span class="s3">\n        </span><span class="s1">combination[routeKey] = value</span><span class="s3">\n\n        </span><span class="s1">// Construct a unique key part for this parameter to enable deduplication.</span><span class="s3">\n        </span><span class="s1">// We use type prefixes to prevent collisions between different value types</span><span class="s3">\n        </span><span class="s1">// that might have the same string representation.</span><span class="s3">\n        </span><span class="s1">//</span><span class="s3">\n        </span><span class="s1">// Examples:</span><span class="s3">\n        </span><span class="s1">// - Array ['foo', 'bar'] becomes </span><span class="s3">\&quot;</span><span class="s1">A:foo,bar</span><span class="s3">\&quot;\n        </span><span class="s1">// - String </span><span class="s3">\&quot;</span><span class="s1">foo,bar</span><span class="s3">\&quot; </span><span class="s1">becomes </span><span class="s3">\&quot;</span><span class="s1">S:foo,bar</span><span class="s3">\&quot;\n        </span><span class="s1">// - This prevents collisions between ['foo', 'bar'] and </span><span class="s3">\&quot;</span><span class="s1">foo,bar</span><span class="s3">\&quot;\n        </span><span class="s1">let valuePart: string</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n          </span><span class="s1">valuePart = `A:${value.join(',')}`</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">valuePart = `S:${value}`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">keyParts.push(`${routeKey}:${valuePart}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Build the final unique key by joining all parameter parts.</span><span class="s3">\n      </span><span class="s1">// This key is used for deduplication in the combinations Map.</span><span class="s3">\n      </span><span class="s1">// Format: </span><span class="s3">\&quot;</span><span class="s1">lang:S:en|region:S:US|slug:A:home,about</span><span class="s3">\&quot;\n      </span><span class="s1">const currentKey = keyParts.join('|')</span><span class="s3">\n\n      </span><span class="s1">// Only add the combination if it meets our criteria:</span><span class="s3">\n      </span><span class="s1">// 1. hasAllRootParams: Contains all required Root Parameters</span><span class="s3">\n      </span><span class="s1">// 2. !combinations.has(currentKey): Is not a duplicate of an existing combination</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// This ensures we only generate valid, unique parameter combinations for Static Shells.</span><span class="s3">\n      </span><span class="s1">if (hasAllRootParams &amp;&amp; !combinations.has(currentKey)) {</span><span class="s3">\n        </span><span class="s1">combinations.set(currentKey, combination)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert the Map's values back into an array and return the final result.</span><span class="s3">\n  </span><span class="s1">// The Map ensures all combinations are unique, and we return only the</span><span class="s3">\n  </span><span class="s1">// parameter objects themselves, discarding the internal deduplication keys.</span><span class="s3">\n  </span><span class="s1">return Array.from(combinations.values())</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calculates the fallback mode based on the given parameters.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param dynamicParams - Whether dynamic params are enabled.</span><span class="s3">\n </span><span class="s1">* @param fallbackRootParams - The root params that are part of the fallback.</span><span class="s3">\n </span><span class="s1">* @param baseFallbackMode - The base fallback mode to use.</span><span class="s3">\n </span><span class="s1">* @returns The calculated fallback mode.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function calculateFallbackMode(</span><span class="s3">\n  </span><span class="s1">dynamicParams: boolean,</span><span class="s3">\n  </span><span class="s1">fallbackRootParams: readonly string[],</span><span class="s3">\n  </span><span class="s1">baseFallbackMode: FallbackMode | undefined</span><span class="s3">\n</span><span class="s1">): FallbackMode {</span><span class="s3">\n  </span><span class="s1">return dynamicParams</span><span class="s3">\n    </span><span class="s1">? // If the fallback params includes any root params, then we need to</span><span class="s3">\n      </span><span class="s1">// perform a blocking static render.</span><span class="s3">\n      </span><span class="s1">fallbackRootParams.length &gt; 0</span><span class="s3">\n      </span><span class="s1">? FallbackMode.BLOCKING_STATIC_RENDER</span><span class="s3">\n      </span><span class="s1">: baseFallbackMode ?? FallbackMode.NOT_FOUND</span><span class="s3">\n    </span><span class="s1">: FallbackMode.NOT_FOUND</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Validates the parameters to ensure they're accessible and have the correct</span><span class="s3">\n </span><span class="s1">* types.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param page - The page to validate.</span><span class="s3">\n </span><span class="s1">* @param regex - The route regex.</span><span class="s3">\n </span><span class="s1">* @param isRoutePPREnabled - Whether the route has partial prerendering enabled.</span><span class="s3">\n </span><span class="s1">* @param routeParamKeys - The keys of the parameters.</span><span class="s3">\n </span><span class="s1">* @param rootParamKeys - The keys of the root params.</span><span class="s3">\n </span><span class="s1">* @param routeParams - The list of parameters to validate.</span><span class="s3">\n </span><span class="s1">* @returns The list of validated parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function validateParams(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">regex: RouteRegex,</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled: boolean,</span><span class="s3">\n  </span><span class="s1">routeParamKeys: readonly string[],</span><span class="s3">\n  </span><span class="s1">rootParamKeys: readonly string[],</span><span class="s3">\n  </span><span class="s1">routeParams: readonly Params[]</span><span class="s3">\n</span><span class="s1">): Params[] {</span><span class="s3">\n  </span><span class="s1">const valid: Params[] = []</span><span class="s3">\n\n  </span><span class="s1">// Validate that if there are any root params, that the user has provided at</span><span class="s3">\n  </span><span class="s1">// least one value for them only if we're using partial prerendering.</span><span class="s3">\n  </span><span class="s1">if (isRoutePPREnabled &amp;&amp; rootParamKeys.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">routeParams.length === 0 ||</span><span class="s3">\n      </span><span class="s1">rootParamKeys.some((key) =&gt;</span><span class="s3">\n        </span><span class="s1">routeParams.some((params) =&gt; !(key in params))</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (rootParamKeys.length === 1) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`A required root parameter (${rootParamKeys[0]}) was not provided in generateStaticParams for ${page}, please provide at least one value.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Required root params (${rootParamKeys.join(', ')}) were not provided in generateStaticParams for ${page}, please provide at least one value for each.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const params of routeParams) {</span><span class="s3">\n    </span><span class="s1">const item: Params = {}</span><span class="s3">\n\n    </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n      </span><span class="s1">const { repeat, optional } = regex.groups[key]</span><span class="s3">\n\n      </span><span class="s1">let paramValue = params[key]</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">optional &amp;&amp;</span><span class="s3">\n        </span><span class="s1">params.hasOwnProperty(key) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(paramValue === null ||</span><span class="s3">\n          </span><span class="s1">paramValue === undefined ||</span><span class="s3">\n          </span><span class="s1">(paramValue as any) === false)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">paramValue = []</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// A parameter is missing, so the rest of the params are not accessible.</span><span class="s3">\n      </span><span class="s1">// We only support this when the route has partial prerendering enabled.</span><span class="s3">\n      </span><span class="s1">// This will make it so that the remaining params are marked as missing so</span><span class="s3">\n      </span><span class="s1">// we can generate a fallback route for them.</span><span class="s3">\n      </span><span class="s1">if (!paramValue &amp;&amp; isRoutePPREnabled) {</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Perform validation for the parameter based on whether it's a repeat</span><span class="s3">\n      </span><span class="s1">// parameter or not.</span><span class="s3">\n      </span><span class="s1">if (repeat) {</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(paramValue)) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">`A required parameter (${key}) was not provided as an array received ${typeof paramValue} in generateStaticParams for ${page}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (typeof paramValue !== 'string') {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">`A required parameter (${key}) was not provided as a string received ${typeof paramValue} in generateStaticParams for ${page}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">item[key] = paramValue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">valid.push(item)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return valid</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface TrieNode {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The children of the node. Each key is a unique string representation of a parameter value,</span><span class="s3">\n   </span><span class="s1">* and the value is the next TrieNode in the path.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">children: Map&lt;string, TrieNode&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The routes that are associated with this specific parameter combination (node).</span><span class="s3">\n   </span><span class="s1">* These are the routes whose concrete parameters lead to this node in the Trie.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">routes: PrerenderedRoute[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Assigns the throwOnEmptyStaticShell property to each of the prerendered routes.</span><span class="s3">\n </span><span class="s1">* This function uses a Trie data structure to efficiently determine whether each route</span><span class="s3">\n </span><span class="s1">* should throw an error when its static shell is empty.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* A route should not throw on empty static shell if it has child routes in the Trie. For example,</span><span class="s3">\n </span><span class="s1">* if we have two routes, `/blog/first-post` and `/blog/[slug]`, the route for</span><span class="s3">\n </span><span class="s1">* `/blog/[slug]` should not throw because `/blog/first-post` is a more specific concrete route.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param prerenderedRoutes - The prerendered routes.</span><span class="s3">\n </span><span class="s1">* @param routeParamKeys - The keys of the route parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function assignErrorIfEmpty(</span><span class="s3">\n  </span><span class="s1">prerenderedRoutes: readonly PrerenderedRoute[],</span><span class="s3">\n  </span><span class="s1">routeParamKeys: readonly string[]</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// If there are no routes to process, exit early.</span><span class="s3">\n  </span><span class="s1">if (prerenderedRoutes.length === 0) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Initialize the root of the Trie. This node represents the starting point</span><span class="s3">\n  </span><span class="s1">// before any parameters have been considered.</span><span class="s3">\n  </span><span class="s1">const root: TrieNode = { children: new Map(), routes: [] }</span><span class="s3">\n\n  </span><span class="s1">// Phase 1: Build the Trie.</span><span class="s3">\n  </span><span class="s1">// Iterate over each prerendered route and insert it into the Trie.</span><span class="s3">\n  </span><span class="s1">// Each route's concrete parameter values form a path in the Trie.</span><span class="s3">\n  </span><span class="s1">for (const route of prerenderedRoutes) {</span><span class="s3">\n    </span><span class="s1">let currentNode = root // Start building the path from the root for each route.</span><span class="s3">\n\n    </span><span class="s1">// Iterate through the sorted parameter keys. The order of keys is crucial</span><span class="s3">\n    </span><span class="s1">// for ensuring that routes with the same concrete parameters follow the</span><span class="s3">\n    </span><span class="s1">// same path in the Trie, regardless of the original order of properties</span><span class="s3">\n    </span><span class="s1">// in the `params` object.</span><span class="s3">\n    </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n      </span><span class="s1">// Check if the current route actually has a concrete value for this parameter.</span><span class="s3">\n      </span><span class="s1">// If a dynamic segment is not filled (i.e., it's a fallback), it won't have</span><span class="s3">\n      </span><span class="s1">// this property, and we stop building the path for this route at this point.</span><span class="s3">\n      </span><span class="s1">if (route.params.hasOwnProperty(key)) {</span><span class="s3">\n        </span><span class="s1">const value = route.params[key]</span><span class="s3">\n\n        </span><span class="s1">// Generate a unique key for the parameter's value. This is critical</span><span class="s3">\n        </span><span class="s1">// to prevent collisions between different data types that might have</span><span class="s3">\n        </span><span class="s1">// the same string representation (e.g., `['a', 'b']` vs `'a,b'`).</span><span class="s3">\n        </span><span class="s1">// A type prefix (`A:` for Array, `S:` for String, `U:` for undefined)</span><span class="s3">\n        </span><span class="s1">// is added to the value to prevent collisions. This ensures that</span><span class="s3">\n        </span><span class="s1">// different types with the same string representation are treated as</span><span class="s3">\n        </span><span class="s1">// distinct.</span><span class="s3">\n        </span><span class="s1">let valueKey: string</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n          </span><span class="s1">valueKey = `A:${value.join(',')}`</span><span class="s3">\n        </span><span class="s1">} else if (value === undefined) {</span><span class="s3">\n          </span><span class="s1">valueKey = `U:undefined`</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">valueKey = `S:${value}`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Look for a child node corresponding to this `valueKey` from the `currentNode`.</span><span class="s3">\n        </span><span class="s1">let childNode = currentNode.children.get(valueKey)</span><span class="s3">\n        </span><span class="s1">if (!childNode) {</span><span class="s3">\n          </span><span class="s1">// If the child node doesn't exist, create a new one and add it to</span><span class="s3">\n          </span><span class="s1">// the current node's children.</span><span class="s3">\n          </span><span class="s1">childNode = { children: new Map(), routes: [] }</span><span class="s3">\n          </span><span class="s1">currentNode.children.set(valueKey, childNode)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Move deeper into the Trie to the `childNode` for the next parameter.</span><span class="s3">\n        </span><span class="s1">currentNode = childNode</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// After processing all concrete parameters for the route, add the full</span><span class="s3">\n    </span><span class="s1">// `PrerenderedRoute` object to the `routes` array of the `currentNode`.</span><span class="s3">\n    </span><span class="s1">// This node represents the unique concrete parameter combination for this route.</span><span class="s3">\n    </span><span class="s1">currentNode.routes.push(route)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Phase 2: Traverse the Trie to assign the `throwOnEmptyStaticShell` property.</span><span class="s3">\n  </span><span class="s1">// This is done using an iterative Depth-First Search (DFS) approach with an</span><span class="s3">\n  </span><span class="s1">// explicit stack to avoid JavaScript's recursion depth limits (stack overflow)</span><span class="s3">\n  </span><span class="s1">// for very deep routing structures.</span><span class="s3">\n  </span><span class="s1">const stack: TrieNode[] = [root] // Initialize the stack with the root node.</span><span class="s3">\n\n  </span><span class="s1">while (stack.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const node = stack.pop()! // Pop the next node to process from the stack.</span><span class="s3">\n\n    </span><span class="s1">// `hasChildren` indicates if this node has any more specific concrete</span><span class="s3">\n    </span><span class="s1">// parameter combinations branching off from it. If true, it means this</span><span class="s3">\n    </span><span class="s1">// node represents a prefix for other, more specific routes.</span><span class="s3">\n    </span><span class="s1">const hasChildren = node.children.size &gt; 0</span><span class="s3">\n\n    </span><span class="s1">// If the current node has routes associated with it (meaning, routes whose</span><span class="s3">\n    </span><span class="s1">// concrete parameters lead to this node's path in the Trie).</span><span class="s3">\n    </span><span class="s1">if (node.routes.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">// Determine the minimum number of fallback parameters among all routes</span><span class="s3">\n      </span><span class="s1">// that are associated with this current Trie node. This is used to</span><span class="s3">\n      </span><span class="s1">// identify if a route should not throw on empty static shell relative to another route *at the same level*</span><span class="s3">\n      </span><span class="s1">// of concrete parameters, but with fewer fallback parameters.</span><span class="s3">\n      </span><span class="s1">let minFallbacks = Infinity</span><span class="s3">\n      </span><span class="s1">for (const r of node.routes) {</span><span class="s3">\n        </span><span class="s1">// `fallbackRouteParams?.length ?? 0` handles cases where `fallbackRouteParams`</span><span class="s3">\n        </span><span class="s1">// might be `undefined` or `null`, treating them as 0 length.</span><span class="s3">\n        </span><span class="s1">minFallbacks = Math.min(</span><span class="s3">\n          </span><span class="s1">minFallbacks,</span><span class="s3">\n          </span><span class="s1">r.fallbackRouteParams?.length ?? 0</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Now, for each `PrerenderedRoute` associated with this node:</span><span class="s3">\n      </span><span class="s1">for (const route of node.routes) {</span><span class="s3">\n        </span><span class="s1">// A route is ok not to throw on an empty static shell (and thus</span><span class="s3">\n        </span><span class="s1">// `throwOnEmptyStaticShell` should be `false`) if either of the</span><span class="s3">\n        </span><span class="s1">// following conditions is met:</span><span class="s3">\n        </span><span class="s1">// 1. `hasChildren` is true: This node has further concrete parameter children.</span><span class="s3">\n        </span><span class="s1">//    This means the current route is a parent to more specific routes (e.g.,</span><span class="s3">\n        </span><span class="s1">//    `/blog/[slug]` should not throw when concrete routes like `/blog/first-post` exist).</span><span class="s3">\n        </span><span class="s1">// OR</span><span class="s3">\n        </span><span class="s1">// 2. `route.fallbackRouteParams.length &gt; minFallbacks`: This route has</span><span class="s3">\n        </span><span class="s1">//    more fallback parameters than another route at the same Trie node.</span><span class="s3">\n        </span><span class="s1">//    This implies the current route is a more general version that should not throw</span><span class="s3">\n        </span><span class="s1">//    compared to a more specific route that has fewer fallback parameters</span><span class="s3">\n        </span><span class="s1">//    (e.g., `/1234/[...slug]` should not throw relative to `/[id]/[...slug]`).</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">hasChildren ||</span><span class="s3">\n          </span><span class="s1">(route.fallbackRouteParams &amp;&amp;</span><span class="s3">\n            </span><span class="s1">route.fallbackRouteParams.length &gt; minFallbacks)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">route.throwOnEmptyStaticShell = false // Should not throw on empty static shell.</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">route.throwOnEmptyStaticShell = true // Should throw on empty static shell.</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Add all children of the current node to the stack. This ensures that</span><span class="s3">\n    </span><span class="s1">// the traversal continues to explore deeper paths in the Trie.</span><span class="s3">\n    </span><span class="s1">for (const child of node.children.values()) {</span><span class="s3">\n      </span><span class="s1">stack.push(child)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Processes app directory segments to build route parameters from generateStaticParams functions.</span><span class="s3">\n </span><span class="s1">* This function walks through the segments array and calls generateStaticParams for each segment that has it,</span><span class="s3">\n </span><span class="s1">* combining parent parameters with child parameters to build the complete parameter combinations.</span><span class="s3">\n </span><span class="s1">* Uses iterative processing instead of recursion for better performance.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param segments - Array of app directory segments to process</span><span class="s3">\n </span><span class="s1">* @param store - Work store for tracking fetch cache configuration</span><span class="s3">\n </span><span class="s1">* @returns Promise that resolves to an array of all parameter combinations</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function generateRouteStaticParams(</span><span class="s3">\n  </span><span class="s1">segments: Pick&lt;AppSegment, 'config' | 'generateStaticParams'&gt;[],</span><span class="s3">\n  </span><span class="s1">store: Pick&lt;WorkStore, 'fetchCache'&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params[]&gt; {</span><span class="s3">\n  </span><span class="s1">// Early return if no segments to process</span><span class="s3">\n  </span><span class="s1">if (segments.length === 0) return []</span><span class="s3">\n\n  </span><span class="s1">// Use iterative processing with a work queue to avoid recursion overhead</span><span class="s3">\n  </span><span class="s1">interface WorkItem {</span><span class="s3">\n    </span><span class="s1">segmentIndex: number</span><span class="s3">\n    </span><span class="s1">params: Params[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const queue: WorkItem[] = [{ segmentIndex: 0, params: [] }]</span><span class="s3">\n  </span><span class="s1">let currentParams: Params[] = []</span><span class="s3">\n\n  </span><span class="s1">while (queue.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const { segmentIndex, params } = queue.shift()!</span><span class="s3">\n\n    </span><span class="s1">// If we've processed all segments, this is our final result</span><span class="s3">\n    </span><span class="s1">if (segmentIndex &gt;= segments.length) {</span><span class="s3">\n      </span><span class="s1">currentParams = params</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const current = segments[segmentIndex]</span><span class="s3">\n\n    </span><span class="s1">// Skip segments without generateStaticParams and continue to next</span><span class="s3">\n    </span><span class="s1">if (typeof current.generateStaticParams !== 'function') {</span><span class="s3">\n      </span><span class="s1">queue.push({ segmentIndex: segmentIndex + 1, params })</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Configure fetchCache if specified</span><span class="s3">\n    </span><span class="s1">if (current.config?.fetchCache !== undefined) {</span><span class="s3">\n      </span><span class="s1">store.fetchCache = current.config.fetchCache</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const nextParams: Params[] = []</span><span class="s3">\n\n    </span><span class="s1">// If there are parent params, we need to process them.</span><span class="s3">\n    </span><span class="s1">if (params.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">// Process each parent parameter combination</span><span class="s3">\n      </span><span class="s1">for (const parentParams of params) {</span><span class="s3">\n        </span><span class="s1">const result = await current.generateStaticParams({</span><span class="s3">\n          </span><span class="s1">params: parentParams,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">if (result.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">// Merge parent params with each result item</span><span class="s3">\n          </span><span class="s1">for (const item of result) {</span><span class="s3">\n            </span><span class="s1">nextParams.push({ ...parentParams, ...item })</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// No results, just pass through parent params</span><span class="s3">\n          </span><span class="s1">nextParams.push(parentParams)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// No parent params, call generateStaticParams with empty object</span><span class="s3">\n      </span><span class="s1">const result = await current.generateStaticParams({ params: {} })</span><span class="s3">\n      </span><span class="s1">nextParams.push(...result)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Add next segment to work queue</span><span class="s3">\n    </span><span class="s1">queue.push({ segmentIndex: segmentIndex + 1, params: nextParams })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return currentParams</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Builds the static paths for an app using `generateStaticParams`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param params - The parameters for the build.</span><span class="s3">\n </span><span class="s1">* @returns The static paths.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function buildAppStaticPaths({</span><span class="s3">\n  </span><span class="s1">dir,</span><span class="s3">\n  </span><span class="s1">page,</span><span class="s3">\n  </span><span class="s1">distDir,</span><span class="s3">\n  </span><span class="s1">cacheComponents,</span><span class="s3">\n  </span><span class="s1">authInterrupts,</span><span class="s3">\n  </span><span class="s1">segments,</span><span class="s3">\n  </span><span class="s1">isrFlushToDisk,</span><span class="s3">\n  </span><span class="s1">cacheHandler,</span><span class="s3">\n  </span><span class="s1">cacheLifeProfiles,</span><span class="s3">\n  </span><span class="s1">requestHeaders,</span><span class="s3">\n  </span><span class="s1">cacheHandlers,</span><span class="s3">\n  </span><span class="s1">maxMemoryCacheSize,</span><span class="s3">\n  </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n  </span><span class="s1">nextConfigOutput,</span><span class="s3">\n  </span><span class="s1">ComponentMod,</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled = false,</span><span class="s3">\n  </span><span class="s1">buildId,</span><span class="s3">\n  </span><span class="s1">rootParamKeys,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">dir: string</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">cacheComponents: boolean</span><span class="s3">\n  </span><span class="s1">authInterrupts: boolean</span><span class="s3">\n  </span><span class="s1">segments: AppSegment[]</span><span class="s3">\n  </span><span class="s1">distDir: string</span><span class="s3">\n  </span><span class="s1">isrFlushToDisk?: boolean</span><span class="s3">\n  </span><span class="s1">fetchCacheKeyPrefix?: string</span><span class="s3">\n  </span><span class="s1">cacheHandler?: string</span><span class="s3">\n  </span><span class="s1">cacheHandlers?: NextConfigComplete['experimental']['cacheHandlers']</span><span class="s3">\n  </span><span class="s1">cacheLifeProfiles?: {</span><span class="s3">\n    </span><span class="s1">[profile: string]: import('../../server/use-cache/cache-life').CacheLife</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">maxMemoryCacheSize?: number</span><span class="s3">\n  </span><span class="s1">requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n  </span><span class="s1">nextConfigOutput: 'standalone' | 'export' | undefined</span><span class="s3">\n  </span><span class="s1">ComponentMod: AppPageModule</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled: boolean</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">rootParamKeys: readonly string[]</span><span class="s3">\n</span><span class="s1">}): Promise&lt;StaticPathsResult&gt; {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">segments.some((generate) =&gt; generate.config?.dynamicParams === true) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">nextConfigOutput === 'export'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">dynamicParams: true</span><span class="s3">\&quot; </span><span class="s1">cannot be used with </span><span class="s3">\&quot;</span><span class="s1">output: export</span><span class="s3">\&quot;</span><span class="s1">. See more info here: https://nextjs.org/docs/app/building-your-application/deploying/static-exports'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">ComponentMod.patchFetch()</span><span class="s3">\n\n  </span><span class="s1">const incrementalCache = await createIncrementalCache({</span><span class="s3">\n    </span><span class="s1">dir,</span><span class="s3">\n    </span><span class="s1">distDir,</span><span class="s3">\n    </span><span class="s1">cacheHandler,</span><span class="s3">\n    </span><span class="s1">cacheHandlers,</span><span class="s3">\n    </span><span class="s1">requestHeaders,</span><span class="s3">\n    </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n    </span><span class="s1">flushToDisk: isrFlushToDisk,</span><span class="s3">\n    </span><span class="s1">cacheMaxMemorySize: maxMemoryCacheSize,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const regex = getRouteRegex(page)</span><span class="s3">\n  </span><span class="s1">const routeParamKeys = Object.keys(getRouteMatcher(regex)(page) || {})</span><span class="s3">\n\n  </span><span class="s1">const afterRunner = new AfterRunner()</span><span class="s3">\n\n  </span><span class="s1">const store = createWorkStore({</span><span class="s3">\n    </span><span class="s1">page,</span><span class="s3">\n    </span><span class="s1">renderOpts: {</span><span class="s3">\n      </span><span class="s1">incrementalCache,</span><span class="s3">\n      </span><span class="s1">cacheLifeProfiles,</span><span class="s3">\n      </span><span class="s1">supportsDynamicResponse: true,</span><span class="s3">\n      </span><span class="s1">isRevalidate: false,</span><span class="s3">\n      </span><span class="s1">experimental: {</span><span class="s3">\n        </span><span class="s1">cacheComponents,</span><span class="s3">\n        </span><span class="s1">authInterrupts,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">waitUntil: afterRunner.context.waitUntil,</span><span class="s3">\n      </span><span class="s1">onClose: afterRunner.context.onClose,</span><span class="s3">\n      </span><span class="s1">onAfterTaskError: afterRunner.context.onTaskError,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n    </span><span class="s1">previouslyRevalidatedTags: [],</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const routeParams = await ComponentMod.workAsyncStorage.run(store, () =&gt;</span><span class="s3">\n    </span><span class="s1">generateRouteStaticParams(segments, store)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">await afterRunner.executeAfter()</span><span class="s3">\n\n  </span><span class="s1">let lastDynamicSegmentHadGenerateStaticParams = false</span><span class="s3">\n  </span><span class="s1">for (const segment of segments) {</span><span class="s3">\n    </span><span class="s1">// Check to see if there are any missing params for segments that have</span><span class="s3">\n    </span><span class="s1">// dynamicParams set to false.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">segment.param &amp;&amp;</span><span class="s3">\n      </span><span class="s1">segment.isDynamicSegment &amp;&amp;</span><span class="s3">\n      </span><span class="s1">segment.config?.dynamicParams === false</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">for (const params of routeParams) {</span><span class="s3">\n        </span><span class="s1">if (segment.param in params) continue</span><span class="s3">\n\n        </span><span class="s1">const relative = segment.filePath</span><span class="s3">\n          </span><span class="s1">? path.relative(dir, segment.filePath)</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Segment </span><span class="s3">\&quot;</span><span class="s1">${relative}</span><span class="s3">\&quot; </span><span class="s1">exports </span><span class="s3">\&quot;</span><span class="s1">dynamicParams: false</span><span class="s3">\&quot; </span><span class="s1">but the param </span><span class="s3">\&quot;</span><span class="s1">${segment.param}</span><span class="s3">\&quot; </span><span class="s1">is missing from the generated route params.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">segment.isDynamicSegment &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof segment.generateStaticParams !== 'function'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">lastDynamicSegmentHadGenerateStaticParams = false</span><span class="s3">\n    </span><span class="s1">} else if (typeof segment.generateStaticParams === 'function') {</span><span class="s3">\n      </span><span class="s1">lastDynamicSegmentHadGenerateStaticParams = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Determine if all the segments have had their parameters provided.</span><span class="s3">\n  </span><span class="s1">const hadAllParamsGenerated =</span><span class="s3">\n    </span><span class="s1">routeParamKeys.length === 0 ||</span><span class="s3">\n    </span><span class="s1">(routeParams.length &gt; 0 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">routeParams.every((params) =&gt; {</span><span class="s3">\n        </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n          </span><span class="s1">if (key in params) continue</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}))</span><span class="s3">\n\n  </span><span class="s1">// TODO: dynamic params should be allowed to be granular per segment but</span><span class="s3">\n  </span><span class="s1">// we need additional information stored/leveraged in the prerender</span><span class="s3">\n  </span><span class="s1">// manifest to allow this behavior.</span><span class="s3">\n  </span><span class="s1">const dynamicParams = segments.every(</span><span class="s3">\n    </span><span class="s1">(segment) =&gt; segment.config?.dynamicParams !== false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const supportsRoutePreGeneration =</span><span class="s3">\n    </span><span class="s1">hadAllParamsGenerated || process.env.NODE_ENV === 'production'</span><span class="s3">\n\n  </span><span class="s1">const fallbackMode = dynamicParams</span><span class="s3">\n    </span><span class="s1">? supportsRoutePreGeneration</span><span class="s3">\n      </span><span class="s1">? isRoutePPREnabled</span><span class="s3">\n        </span><span class="s1">? FallbackMode.PRERENDER</span><span class="s3">\n        </span><span class="s1">: FallbackMode.BLOCKING_STATIC_RENDER</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n    </span><span class="s1">: FallbackMode.NOT_FOUND</span><span class="s3">\n\n  </span><span class="s1">const prerenderedRoutesByPathname = new Map&lt;string, PrerenderedRoute&gt;()</span><span class="s3">\n\n  </span><span class="s1">// Precompile the regex patterns for the route params.</span><span class="s3">\n  </span><span class="s1">const paramPatterns = new Map&lt;string, string&gt;()</span><span class="s3">\n  </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n    </span><span class="s1">const { repeat, optional } = regex.groups[key]</span><span class="s3">\n    </span><span class="s1">let pattern = `[${repeat ? '...' : ''}${key}]`</span><span class="s3">\n    </span><span class="s1">if (optional) {</span><span class="s3">\n      </span><span class="s1">pattern = `[${pattern}]`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">paramPatterns.set(key, pattern)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert rootParamKeys to Set for O(1) lookup.</span><span class="s3">\n  </span><span class="s1">const rootParamSet = new Set(rootParamKeys)</span><span class="s3">\n\n  </span><span class="s1">if (hadAllParamsGenerated || isRoutePPREnabled) {</span><span class="s3">\n    </span><span class="s1">let paramsToProcess = routeParams</span><span class="s3">\n\n    </span><span class="s1">if (isRoutePPREnabled) {</span><span class="s3">\n      </span><span class="s1">// Discover all unique combinations of the routeParams so we can generate</span><span class="s3">\n      </span><span class="s1">// routes that won't throw on empty static shell for each of them if</span><span class="s3">\n      </span><span class="s1">// they're available.</span><span class="s3">\n      </span><span class="s1">paramsToProcess = generateAllParamCombinations(</span><span class="s3">\n        </span><span class="s1">routeParamKeys,</span><span class="s3">\n        </span><span class="s1">routeParams,</span><span class="s3">\n        </span><span class="s1">rootParamKeys</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// Add the base route, this is the route with all the placeholders as it's</span><span class="s3">\n      </span><span class="s1">// derived from the `page` string.</span><span class="s3">\n      </span><span class="s1">prerenderedRoutesByPathname.set(page, {</span><span class="s3">\n        </span><span class="s1">params: {},</span><span class="s3">\n        </span><span class="s1">pathname: page,</span><span class="s3">\n        </span><span class="s1">encodedPathname: page,</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams: routeParamKeys,</span><span class="s3">\n        </span><span class="s1">fallbackMode: calculateFallbackMode(</span><span class="s3">\n          </span><span class="s1">dynamicParams,</span><span class="s3">\n          </span><span class="s1">rootParamKeys,</span><span class="s3">\n          </span><span class="s1">fallbackMode</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">fallbackRootParams: rootParamKeys,</span><span class="s3">\n        </span><span class="s1">throwOnEmptyStaticShell: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">filterUniqueParams(</span><span class="s3">\n      </span><span class="s1">routeParamKeys,</span><span class="s3">\n      </span><span class="s1">validateParams(</span><span class="s3">\n        </span><span class="s1">page,</span><span class="s3">\n        </span><span class="s1">regex,</span><span class="s3">\n        </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n        </span><span class="s1">routeParamKeys,</span><span class="s3">\n        </span><span class="s1">rootParamKeys,</span><span class="s3">\n        </span><span class="s1">paramsToProcess</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">).forEach((params) =&gt; {</span><span class="s3">\n      </span><span class="s1">let pathname = page</span><span class="s3">\n      </span><span class="s1">let encodedPathname = page</span><span class="s3">\n\n      </span><span class="s1">const fallbackRouteParams: string[] = []</span><span class="s3">\n\n      </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n        </span><span class="s1">const paramValue = params[key]</span><span class="s3">\n\n        </span><span class="s1">if (!paramValue) {</span><span class="s3">\n          </span><span class="s1">if (isRoutePPREnabled) {</span><span class="s3">\n            </span><span class="s1">// Mark remaining params as fallback params.</span><span class="s3">\n            </span><span class="s1">fallbackRouteParams.push(key)</span><span class="s3">\n            </span><span class="s1">for (</span><span class="s3">\n              </span><span class="s1">let i = routeParamKeys.indexOf(key) + 1;</span><span class="s3">\n              </span><span class="s1">i &lt; routeParamKeys.length;</span><span class="s3">\n              </span><span class="s1">i++</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">fallbackRouteParams.push(routeParamKeys[i])</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// This route is not complete, and we aren't performing a partial</span><span class="s3">\n            </span><span class="s1">// prerender, so we should return, skipping this route.</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Use pre-compiled pattern for replacement</span><span class="s3">\n        </span><span class="s1">const pattern = paramPatterns.get(key)!</span><span class="s3">\n        </span><span class="s1">pathname = pathname.replace(</span><span class="s3">\n          </span><span class="s1">pattern,</span><span class="s3">\n          </span><span class="s1">encodeParam(paramValue, (value) =&gt; escapePathDelimiters(value, true))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">encodedPathname = encodedPathname.replace(</span><span class="s3">\n          </span><span class="s1">pattern,</span><span class="s3">\n          </span><span class="s1">encodeParam(paramValue, encodeURIComponent)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const fallbackRootParams: string[] = []</span><span class="s3">\n      </span><span class="s1">for (const param of fallbackRouteParams) {</span><span class="s3">\n        </span><span class="s1">if (rootParamSet.has(param)) {</span><span class="s3">\n          </span><span class="s1">fallbackRootParams.push(param)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">pathname = normalizePathname(pathname)</span><span class="s3">\n\n      </span><span class="s1">prerenderedRoutesByPathname.set(pathname, {</span><span class="s3">\n        </span><span class="s1">params,</span><span class="s3">\n        </span><span class="s1">pathname,</span><span class="s3">\n        </span><span class="s1">encodedPathname: normalizePathname(encodedPathname),</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n        </span><span class="s1">fallbackMode: calculateFallbackMode(</span><span class="s3">\n          </span><span class="s1">dynamicParams,</span><span class="s3">\n          </span><span class="s1">fallbackRootParams,</span><span class="s3">\n          </span><span class="s1">fallbackMode</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">fallbackRootParams,</span><span class="s3">\n        </span><span class="s1">throwOnEmptyStaticShell: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const prerenderedRoutes =</span><span class="s3">\n    </span><span class="s1">prerenderedRoutesByPathname.size &gt; 0 ||</span><span class="s3">\n    </span><span class="s1">lastDynamicSegmentHadGenerateStaticParams</span><span class="s3">\n      </span><span class="s1">? [...prerenderedRoutesByPathname.values()]</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">// Now we have to set the throwOnEmptyStaticShell for each of the routes.</span><span class="s3">\n  </span><span class="s1">if (prerenderedRoutes &amp;&amp; cacheComponents) {</span><span class="s3">\n    </span><span class="s1">assignErrorIfEmpty(prerenderedRoutes, routeParamKeys)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { fallbackMode, prerenderedRoutes }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;assignErrorIfEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;buildAppStaticPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;calculateFallbackMode&quot;</span><span class="s0">,</span><span class="s1">&quot;filterUniqueParams&quot;</span><span class="s0">,</span><span class="s1">&quot;generateAllParamCombinations&quot;</span><span class="s0">,</span><span class="s1">&quot;generateRouteStaticParams&quot;</span><span class="s0">,</span><span class="s1">&quot;routeParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;routeParams&quot;</span><span class="s0">,</span><span class="s1">&quot;unique&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;paramKey&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;valuePart&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;rootParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;combinations&quot;</span><span class="s0">,</span><span class="s1">&quot;minIndexForCompleteRootParams&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;rootParamKey&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;combination&quot;</span><span class="s0">,</span><span class="s1">&quot;keyParts&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAllRootParams&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;currentKey&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRootParams&quot;</span><span class="s0">,</span><span class="s1">&quot;baseFallbackMode&quot;</span><span class="s0">,</span><span class="s1">&quot;FallbackMode&quot;</span><span class="s0">,</span><span class="s1">&quot;BLOCKING_STATIC_RENDER&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_FOUND&quot;</span><span class="s0">,</span><span class="s1">&quot;validateParams&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;regex&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;valid&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;paramValue&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderedRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;root&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;currentNode&quot;</span><span class="s0">,</span><span class="s1">&quot;valueKey&quot;</span><span class="s0">,</span><span class="s1">&quot;childNode&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;hasChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;minFallbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;Infinity&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;throwOnEmptyStaticShell&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;store&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;currentParams&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;generateStaticParams&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;nextParams&quot;</span><span class="s0">,</span><span class="s1">&quot;parentParams&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;authInterrupts&quot;</span><span class="s0">,</span><span class="s1">&quot;isrFlushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheLifeProfiles&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;maxMemoryCacheSize&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCacheKeyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfigOutput&quot;</span><span class="s0">,</span><span class="s1">&quot;ComponentMod&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;generate&quot;</span><span class="s0">,</span><span class="s1">&quot;patchFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;createIncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;flushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheMaxMemorySize&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;afterRunner&quot;</span><span class="s0">,</span><span class="s1">&quot;AfterRunner&quot;</span><span class="s0">,</span><span class="s1">&quot;createWorkStore&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsDynamicResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;onClose&quot;</span><span class="s0">,</span><span class="s1">&quot;onAfterTaskError&quot;</span><span class="s0">,</span><span class="s1">&quot;onTaskError&quot;</span><span class="s0">,</span><span class="s1">&quot;previouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;executeAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;lastDynamicSegmentHadGenerateStaticParams&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;hadAllParamsGenerated&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsRoutePreGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackMode&quot;</span><span class="s0">,</span><span class="s1">&quot;PRERENDER&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderedRoutesByPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;paramPatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;rootParamSet&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsToProcess&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;encodedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeParam&quot;</span><span class="s0">,</span><span class="s1">&quot;escapePathDelimiters&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePathname&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>