<html>
<head>
<title>optimize-hook-destructuring.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
optimize-hook-destructuring.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;default&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">_default;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">// matches any hook-like (the default)</span>
<span class="s2">const </span><span class="s1">isHook = </span><span class="s4">/^use[A-Z]/</span><span class="s1">;</span>
<span class="s3">// matches only built-in hooks provided by React et al</span>
<span class="s2">const </span><span class="s1">isBuiltInHook = </span><span class="s4">/^use(Callback|Context|DebugValue|Effect|ImperativeHandle|LayoutEffect|Memo|Reducer|Ref|State)$/</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">_default({ types: t }) {</span>
    <span class="s2">const </span><span class="s1">visitor = {</span>
        <span class="s1">CallExpression (path, state) {</span>
            <span class="s2">const </span><span class="s1">onlyBuiltIns = state.opts.onlyBuiltIns;</span>
            <span class="s3">// if specified, options.lib is a list of libraries that provide hook functions</span>
            <span class="s2">const </span><span class="s1">libs = state.opts.lib &amp;&amp; (state.opts.lib === </span><span class="s2">true </span><span class="s1">? [</span>
                <span class="s0">'react'</span><span class="s1">,</span>
                <span class="s0">'preact/hooks'</span>
            <span class="s1">] : [].concat(state.opts.lib));</span>
            <span class="s3">// skip function calls that are not the init of a variable declaration:</span>
            <span class="s2">if </span><span class="s1">(!t.isVariableDeclarator(path.parent)) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s3">// skip function calls where the return value is not Array-destructured:</span>
            <span class="s2">if </span><span class="s1">(!t.isArrayPattern(path.parent.id)) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s3">// name of the (hook) function being called:</span>
            <span class="s2">const </span><span class="s1">hookName = path.node.callee.name;</span>
            <span class="s2">if </span><span class="s1">(libs) {</span>
                <span class="s2">const </span><span class="s1">binding = path.scope.getBinding(hookName);</span>
                <span class="s3">// not an import</span>
                <span class="s2">if </span><span class="s1">(!binding || binding.kind !== </span><span class="s0">'module'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">specifier = binding.path.parent.source.value;</span>
                <span class="s3">// not a match</span>
                <span class="s2">if </span><span class="s1">(!libs.some((lib)=&gt;lib === specifier)) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// only match function calls with names that look like a hook</span>
            <span class="s2">if </span><span class="s1">(!(onlyBuiltIns ? isBuiltInHook : isHook).test(hookName)) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s1">path.parent.id = t.objectPattern(path.parent.id.elements.reduce((patterns, element, i)=&gt;{</span>
                <span class="s2">if </span><span class="s1">(element === </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">patterns;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">patterns.concat(t.objectProperty(t.numericLiteral(i), </span><span class="s3">// TODO: fix this</span>
                <span class="s1">element));</span>
            <span class="s1">}, []));</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">name: </span><span class="s0">'optimize-hook-destructuring'</span><span class="s1">,</span>
        <span class="s1">visitor: {</span>
            <span class="s3">// this is a workaround to run before preset-env destroys destructured assignments</span>
            <span class="s1">Program (path, state) {</span>
                <span class="s1">path.traverse(visitor, state);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=optimize-hook-destructuring.js.map</span></pre>
</body>
</html>