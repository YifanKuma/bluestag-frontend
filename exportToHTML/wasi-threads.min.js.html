<html>
<head>
<title>wasi-threads.min.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wasi-threads.min.js</font>
</center></td></tr></table>
<pre><span class="s0">!</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">exports&amp;&amp;</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">module?r(exports):</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">define&amp;&amp;define.amd?define([</span><span class="s2">&quot;exports&quot;</span><span class="s0">],r):r((e=</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">globalThis?globalThis:e||self).wasiThreads={})}(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">r=</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WebAssembly?WebAssembly:</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WXWebAssembly?WXWebAssembly:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,t=</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">process&amp;&amp;</span><span class="s1">null</span><span class="s0">!==process&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">process.versions&amp;&amp;</span><span class="s1">null</span><span class="s0">!==process.versions&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">process.versions.node;</span><span class="s1">function </span><span class="s0">o(e){</span><span class="s1">return</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e.postMessage)?e.postMessage:</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">postMessage?postMessage:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">n(e){</span><span class="s1">return</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">SharedArrayBuffer&amp;&amp;e </span><span class="s1">instanceof </span><span class="s0">SharedArrayBuffer||</span><span class="s2">&quot;[object SharedArrayBuffer]&quot;</span><span class="s0">===Object.prototype.toString.call(e)}</span><span class="s1">function </span><span class="s0">i(e){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e </span><span class="s1">instanceof </span><span class="s0">r.RuntimeError}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">a(e,r){</span><span class="s1">return</span><span class="s0">{__emnapi__:{type:e,payload:r}}}</span><span class="s1">function </span><span class="s0">s(e){</span><span class="s1">if</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!n(e.buffer))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Multithread features require shared wasm memory. Try to compile with `-matomics -mbulk-memory` and use `--import-memory --shared-memory` during linking, then create WebAssembly.Memory with `shared: true` option&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">&quot;undefined&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">SharedArrayBuffer)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Current environment does not support SharedArrayBuffer, threads are not available!&quot;</span><span class="s0">)}</span><span class="s1">var </span><span class="s0">d=</span><span class="s3">0</span><span class="s0">,h=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">function </span><span class="s0">e(e){</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.unusedWorkers=[],</span><span class="s1">this</span><span class="s0">.runningWorkers=[],</span><span class="s1">this</span><span class="s0">.pthreads=Object.create(</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.wasmModule=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.wasmMemory=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.messageEvents=</span><span class="s1">new </span><span class="s0">WeakMap,!e)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;ThreadManager(): options is not provided&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">._childThread=</span><span class="s2">&quot;childThread&quot;</span><span class="s1">in </span><span class="s0">e&amp;&amp;Boolean(e.childThread),</span><span class="s1">this</span><span class="s0">._childThread?(</span><span class="s1">this</span><span class="s0">._onCreateWorker=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._reuseWorker=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._beforeLoad=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">._onCreateWorker=e.onCreateWorker,</span><span class="s1">this</span><span class="s0">._reuseWorker=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;{size:</span><span class="s3">0</span><span class="s0">,strict:!</span><span class="s3">1</span><span class="s0">};</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e){</span><span class="s1">if</span><span class="s0">(!(e&gt;=</span><span class="s3">0</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">RangeError(</span><span class="s2">&quot;reuseWorker: size must be a non-negative integer&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s0">{size:e,strict:!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">var </span><span class="s0">t=</span><span class="s1">null</span><span class="s0">!==(r=Number(e.size))&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r?r:</span><span class="s3">0</span><span class="s0">,o=Boolean(e.strict);</span><span class="s1">if</span><span class="s0">(!(t&gt;</span><span class="s3">0</span><span class="s0">)&amp;&amp;o)</span><span class="s1">throw new </span><span class="s0">RangeError(</span><span class="s2">&quot;reuseWorker: size must be set to positive integer if strict is set to true&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s0">{size:t,strict:o}}(e.reuseWorker),</span><span class="s1">this</span><span class="s0">._beforeLoad=e.beforeLoad),</span><span class="s1">this</span><span class="s0">.printErr=</span><span class="s1">null</span><span class="s0">!==(r=e.printErr)&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r?r:console.error.bind(console)}</span><span class="s1">return </span><span class="s0">Object.defineProperty(e.prototype,</span><span class="s2">&quot;nextWorkerID&quot;</span><span class="s0">,{get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">d},enumerable:!</span><span class="s3">1</span><span class="s0">,configurable:!</span><span class="s3">0</span><span class="s0">}),e.prototype.init=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">._childThread||</span><span class="s1">this</span><span class="s0">.initMainThread()},e.prototype.initMainThread=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.preparePool()},e.prototype.preparePool=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">._reuseWorker&amp;&amp;</span><span class="s1">this</span><span class="s0">._reuseWorker.size)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">._reuseWorker.size;e--;){</span><span class="s1">var </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.allocateUnusedWorker();t&amp;&amp;(r.once(</span><span class="s2">&quot;message&quot;</span><span class="s0">,</span><span class="s1">function</span><span class="s0">(){}),r.unref())}},e.prototype.shouldPreloadWorkers=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">._childThread&amp;&amp;</span><span class="s1">this</span><span class="s0">._reuseWorker&amp;&amp;</span><span class="s1">this</span><span class="s0">._reuseWorker.size&gt;</span><span class="s3">0</span><span class="s0">},e.prototype.loadWasmModuleToAllWorkers=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">,r=Array(</span><span class="s1">this</span><span class="s0">.unusedWorkers.length),o=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">o=n.unusedWorkers[e];t&amp;&amp;o.ref(),r[e]=n.loadWasmModuleToWorker(o).then(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">t&amp;&amp;o.unref(),e},</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">throw </span><span class="s0">t&amp;&amp;o.unref(),e})},n=</span><span class="s1">this</span><span class="s0">,i=</span><span class="s3">0</span><span class="s0">;i&lt;</span><span class="s1">this</span><span class="s0">.unusedWorkers.length;++i)o(i);</span><span class="s1">return </span><span class="s0">Promise.all(r).catch(</span><span class="s1">function</span><span class="s0">(r){</span><span class="s1">throw </span><span class="s0">e.terminateAllThreads(),r})},e.prototype.preloadWorkers=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.shouldPreloadWorkers()?</span><span class="s1">this</span><span class="s0">.loadWasmModuleToAllWorkers():Promise.resolve([])},e.prototype.setup=</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">this</span><span class="s0">.wasmModule=e,</span><span class="s1">this</span><span class="s0">.wasmMemory=r},e.prototype.markId=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e.__emnapi_tid)</span><span class="s1">return </span><span class="s0">e.__emnapi_tid;</span><span class="s1">var </span><span class="s0">r=d+</span><span class="s3">43</span><span class="s0">;</span><span class="s1">return </span><span class="s0">d=(d+</span><span class="s3">1</span><span class="s0">)%</span><span class="s3">536870869</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.pthreads[r]=e,e.__emnapi_tid=r,r},e.prototype.returnWorkerToPool=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">r=e.__emnapi_tid;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r&amp;&amp;</span><span class="s1">delete this</span><span class="s0">.pthreads[r],</span><span class="s1">this</span><span class="s0">.unusedWorkers.push(e),</span><span class="s1">this</span><span class="s0">.runningWorkers.splice(</span><span class="s1">this</span><span class="s0">.runningWorkers.indexOf(e),</span><span class="s3">1</span><span class="s0">),</span><span class="s1">delete </span><span class="s0">e.__emnapi_tid,t&amp;&amp;e.unref()},e.prototype.loadWasmModuleToWorker=</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">var </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.whenLoaded)</span><span class="s1">return </span><span class="s0">e.whenLoaded;</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.printErr,i=</span><span class="s1">this</span><span class="s0">._beforeLoad,d=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.whenLoaded=</span><span class="s1">new </span><span class="s0">Promise(</span><span class="s1">function</span><span class="s0">(h,u){e.onmessage=</span><span class="s1">function</span><span class="s0">(r){!</span><span class="s1">function</span><span class="s0">(r){</span><span class="s1">if</span><span class="s0">(r.__emnapi__){</span><span class="s1">var </span><span class="s0">n=r.__emnapi__.type,i=r.__emnapi__.payload;</span><span class="s2">&quot;loaded&quot;</span><span class="s0">===n?(e.loaded=!</span><span class="s3">0</span><span class="s0">,t&amp;&amp;!e.__emnapi_tid&amp;&amp;e.unref(),h(e)):</span><span class="s2">&quot;cleanup-thread&quot;</span><span class="s0">===n&amp;&amp;i.tid </span><span class="s1">in </span><span class="s0">o.pthreads&amp;&amp;o.cleanThread(e,i.tid)}}(r.data),o.fireMessageEvent(e,r)},e.onerror=</span><span class="s1">function</span><span class="s0">(r){</span><span class="s1">var </span><span class="s0">t=</span><span class="s2">&quot;worker sent an error!&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e.__emnapi_tid&amp;&amp;(t=</span><span class="s2">&quot;worker (tid = &quot;</span><span class="s0">+e.__emnapi_tid+</span><span class="s2">&quot;) sent an error!&quot;</span><span class="s0">),</span><span class="s2">&quot;message&quot;</span><span class="s1">in </span><span class="s0">r){</span><span class="s1">if</span><span class="s0">(n(t+</span><span class="s2">&quot; &quot;</span><span class="s0">+r.message),-</span><span class="s3">1</span><span class="s0">!==r.message.indexOf(</span><span class="s2">&quot;RuntimeError&quot;</span><span class="s0">)||-</span><span class="s3">1</span><span class="s0">!==r.message.indexOf(</span><span class="s2">&quot;unreachable&quot;</span><span class="s0">))</span><span class="s1">try</span><span class="s0">{d.terminateAllThreads()}</span><span class="s1">catch</span><span class="s0">(e){}}</span><span class="s1">else </span><span class="s0">n(t);</span><span class="s1">throw </span><span class="s0">u(r),r},t&amp;&amp;(e.on(</span><span class="s2">&quot;message&quot;</span><span class="s0">,</span><span class="s1">function</span><span class="s0">(r){</span><span class="s1">var </span><span class="s0">t,o;</span><span class="s1">null</span><span class="s0">===(o=(t=e).onmessage)||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o||o.call(t,{data:r})}),e.on(</span><span class="s2">&quot;error&quot;</span><span class="s0">,</span><span class="s1">function</span><span class="s0">(r){</span><span class="s1">var </span><span class="s0">t,o;</span><span class="s1">null</span><span class="s0">===(o=(t=e).onerror)||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o||o.call(t,r)}),e.on(</span><span class="s2">&quot;detachedExit&quot;</span><span class="s0">,</span><span class="s1">function</span><span class="s0">(){})),</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">i&amp;&amp;i(e);</span><span class="s1">try</span><span class="s0">{e.postMessage(a(</span><span class="s2">&quot;load&quot;</span><span class="s0">,{wasmModule:o.wasmModule,wasmMemory:o.wasmMemory,sab:r}))}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">throw </span><span class="s0">s(o.wasmMemory),e}}),e.whenLoaded},e.prototype.allocateUnusedWorker=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">._onCreateWorker;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;`options.onCreateWorker` is not provided&quot;</span><span class="s0">);</span><span class="s1">var </span><span class="s0">r=e({type:</span><span class="s2">&quot;thread&quot;</span><span class="s0">,name:</span><span class="s2">&quot;emnapi-pthread&quot;</span><span class="s0">});</span><span class="s1">return this</span><span class="s0">.unusedWorkers.push(r),r},e.prototype.getNewWorker=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">._reuseWorker){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.unusedWorkers.length){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">._reuseWorker.strict)</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return void</span><span class="s0">(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.printErr)(</span><span class="s2">&quot;Tried to spawn a new thread, but the thread pool is exhausted.</span><span class="s4">\n</span><span class="s2">This might result in a deadlock unless some threads eventually exit or the code explicitly breaks out to the event loop.&quot;</span><span class="s0">);</span><span class="s1">var </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.allocateUnusedWorker();</span><span class="s1">this</span><span class="s0">.loadWasmModuleToWorker(r,e)}</span><span class="s1">return this</span><span class="s0">.unusedWorkers.pop()}</span><span class="s1">var </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">.allocateUnusedWorker();</span><span class="s1">return this</span><span class="s0">.loadWasmModuleToWorker(o,e),</span><span class="s1">this</span><span class="s0">.unusedWorkers.pop()},e.prototype.cleanThread=</span><span class="s1">function</span><span class="s0">(e,r,t){</span><span class="s1">if</span><span class="s0">(!t&amp;&amp;</span><span class="s1">this</span><span class="s0">._reuseWorker)</span><span class="s1">this</span><span class="s0">.returnWorkerToPool(e);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">delete this</span><span class="s0">.pthreads[r];</span><span class="s1">var </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">.runningWorkers.indexOf(e);-</span><span class="s3">1</span><span class="s0">!==o&amp;&amp;</span><span class="s1">this</span><span class="s0">.runningWorkers.splice(o,</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.terminateWorker(e),</span><span class="s1">delete </span><span class="s0">e.__emnapi_tid}},e.prototype.terminateWorker=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">r,t=</span><span class="s1">this</span><span class="s0">,o=e.__emnapi_tid;e.terminate(),</span><span class="s1">null</span><span class="s0">===(r=</span><span class="s1">this</span><span class="s0">.messageEvents.get(e))||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r||r.clear(),</span><span class="s1">this</span><span class="s0">.messageEvents.delete(e),e.onmessage=</span><span class="s1">function</span><span class="s0">(e){e.data.__emnapi__&amp;&amp;(</span><span class="s3">0</span><span class="s0">,t.printErr)(</span><span class="s2">'received &quot;'</span><span class="s0">+e.data.__emnapi__.type+</span><span class="s2">'&quot; command from terminated worker: '</span><span class="s0">+o)}},e.prototype.terminateAllThreads=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;</span><span class="s1">this</span><span class="s0">.runningWorkers.length;++e)</span><span class="s1">this</span><span class="s0">.terminateWorker(</span><span class="s1">this</span><span class="s0">.runningWorkers[e]);</span><span class="s1">for</span><span class="s0">(e=</span><span class="s3">0</span><span class="s0">;e&lt;</span><span class="s1">this</span><span class="s0">.unusedWorkers.length;++e)</span><span class="s1">this</span><span class="s0">.terminateWorker(</span><span class="s1">this</span><span class="s0">.unusedWorkers[e]);</span><span class="s1">this</span><span class="s0">.unusedWorkers=[],</span><span class="s1">this</span><span class="s0">.runningWorkers=[],</span><span class="s1">this</span><span class="s0">.pthreads=Object.create(</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.preparePool()},e.prototype.addMessageEventListener=</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">var </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.messageEvents.get(e);</span><span class="s1">return </span><span class="s0">t||(t=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.messageEvents.set(e,t)),t.add(r),</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">null</span><span class="s0">==t||t.delete(r)}},e.prototype.fireMessageEvent=</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">var </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.messageEvents.get(e);</span><span class="s1">if</span><span class="s0">(t){</span><span class="s1">var </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">.printErr;t.forEach(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">try</span><span class="s0">{e(r)}</span><span class="s1">catch</span><span class="s0">(e){o(e.stack)}})}},e}(),u=Symbol(</span><span class="s2">&quot;kIsProxy&quot;</span><span class="s0">);</span><span class="s1">function </span><span class="s0">c(e,r){</span><span class="s1">if</span><span class="s0">(e[u])</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">var </span><span class="s0">t=e.exports,o=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r=[</span><span class="s2">&quot;apply&quot;</span><span class="s0">,</span><span class="s2">&quot;construct&quot;</span><span class="s0">,</span><span class="s2">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s2">&quot;deleteProperty&quot;</span><span class="s0">,</span><span class="s2">&quot;get&quot;</span><span class="s0">,</span><span class="s2">&quot;getOwnPropertyDescriptor&quot;</span><span class="s0">,</span><span class="s2">&quot;getPrototypeOf&quot;</span><span class="s0">,</span><span class="s2">&quot;has&quot;</span><span class="s0">,</span><span class="s2">&quot;isExtensible&quot;</span><span class="s0">,</span><span class="s2">&quot;ownKeys&quot;</span><span class="s0">,</span><span class="s2">&quot;preventExtensions&quot;</span><span class="s0">,</span><span class="s2">&quot;set&quot;</span><span class="s0">,</span><span class="s2">&quot;setPrototypeOf&quot;</span><span class="s0">],t={},o=</span><span class="s1">function</span><span class="s0">(o){</span><span class="s1">var </span><span class="s0">n=r[o];t[n]=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">r=Array.prototype.slice.call(arguments,</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r.unshift(e),Reflect[n].apply(Reflect,r)}},n=</span><span class="s3">0</span><span class="s0">;n&lt;r.length;n++)o(n);</span><span class="s1">return </span><span class="s0">t}(t),n=</span><span class="s1">function</span><span class="s0">(){},i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s3">0</span><span class="s0">};o.get=</span><span class="s1">function</span><span class="s0">(e,o,a){</span><span class="s1">var </span><span class="s0">s;</span><span class="s1">return</span><span class="s2">&quot;memory&quot;</span><span class="s0">===o?</span><span class="s1">null</span><span class="s0">!==(s=</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r?r():r)&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==s?s:Reflect.get(t,o,a):</span><span class="s2">&quot;_initialize&quot;</span><span class="s0">===o?o </span><span class="s1">in </span><span class="s0">t?n:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:</span><span class="s2">&quot;_start&quot;</span><span class="s0">===o?o </span><span class="s1">in </span><span class="s0">t?i:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:Reflect.get(t,o,a)},o.has=</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">return</span><span class="s2">&quot;memory&quot;</span><span class="s0">===r||Reflect.has(t,r)};</span><span class="s1">var </span><span class="s0">a=</span><span class="s1">new </span><span class="s0">Proxy(Object.create(</span><span class="s1">null</span><span class="s0">),o);</span><span class="s1">return new </span><span class="s0">Proxy(e,{get:</span><span class="s1">function</span><span class="s0">(e,r,t){</span><span class="s1">return</span><span class="s2">&quot;exports&quot;</span><span class="s0">===r?a:r===u||Reflect.get(e,r,t)}})}</span><span class="s1">var </span><span class="s0">l=</span><span class="s1">new </span><span class="s0">WeakMap,f=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">function </span><span class="s0">e(e){</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;WASIThreads(): options is not provided&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!e.wasi)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;WASIThreads(): options.wasi is not provided&quot;</span><span class="s0">);l.set(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">new </span><span class="s0">WeakSet);</span><span class="s1">var </span><span class="s0">d=e.wasi;!</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">var </span><span class="s0">t=l.get(e);</span><span class="s1">if</span><span class="s0">(t.has(r))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">var </span><span class="s0">o=e,n=r.wasiImport;</span><span class="s1">if</span><span class="s0">(n){</span><span class="s1">var </span><span class="s0">a=n.proc_exit;n.proc_exit=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">o.terminateAllThreads(),a.call(</span><span class="s1">this</span><span class="s0">,e)}}</span><span class="s1">if</span><span class="s0">(!o.childThread){</span><span class="s1">var </span><span class="s0">s=r.start;</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">s&amp;&amp;(r.start=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">s.call(</span><span class="s1">this</span><span class="s0">,e)}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">throw </span><span class="s0">i(e)&amp;&amp;o.terminateAllThreads(),e}})}t.add(r)}(</span><span class="s1">this</span><span class="s0">,d),</span><span class="s1">this</span><span class="s0">.wasi=d,</span><span class="s1">this</span><span class="s0">.childThread=</span><span class="s2">&quot;childThread&quot;</span><span class="s1">in </span><span class="s0">e&amp;&amp;Boolean(e.childThread),</span><span class="s1">this</span><span class="s0">.PThread=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;threadManager&quot;</span><span class="s1">in </span><span class="s0">e?</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.threadManager?</span><span class="s1">this</span><span class="s0">.PThread=e.threadManager():</span><span class="s1">this</span><span class="s0">.PThread=e.threadManager:</span><span class="s1">this</span><span class="s0">.childThread||(</span><span class="s1">this</span><span class="s0">.PThread=</span><span class="s1">new </span><span class="s0">h(e),</span><span class="s1">this</span><span class="s0">.PThread.init());</span><span class="s1">var </span><span class="s0">u=!</span><span class="s3">1</span><span class="s0">;</span><span class="s2">&quot;waitThreadStart&quot;</span><span class="s1">in </span><span class="s0">e&amp;&amp;(u=</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.waitThreadStart?e.waitThreadStart:Boolean(e.waitThreadStart));</span><span class="s1">var </span><span class="s0">c=o(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.childThread&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">c)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;options.postMessage is not a function&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.postMessage=c;</span><span class="s1">var </span><span class="s0">f=Boolean(e.wasm64),p=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e.data.__emnapi__){</span><span class="s1">var </span><span class="s0">r=e.data.__emnapi__.type,t=e.data.__emnapi__.payload;</span><span class="s2">&quot;spawn-thread&quot;</span><span class="s0">===r?m(t.startArg,t.errorOrTid):</span><span class="s2">&quot;terminate-all-threads&quot;</span><span class="s0">===r&amp;&amp;n.terminateAllThreads()}},m=</span><span class="s1">function</span><span class="s0">(e,o){</span><span class="s1">var </span><span class="s0">i,d=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==o;</span><span class="s1">try</span><span class="s0">{s(n.wasmMemory)}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===(i=n.PThread)||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===i||i.printErr(e.stack),d){</span><span class="s1">var </span><span class="s0">h=</span><span class="s1">new </span><span class="s0">Int32Array(n.wasmMemory.buffer,o,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return </span><span class="s0">Atomics.store(h,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),Atomics.store(h,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">6</span><span class="s0">),Atomics.notify(h,</span><span class="s3">1</span><span class="s0">),</span><span class="s3">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">-</span><span class="s3">6</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(!d){</span><span class="s1">var </span><span class="s0">l=n.wasmInstance.exports.malloc;</span><span class="s1">if</span><span class="s0">(!(o=f?Number(l(BigInt(</span><span class="s3">8</span><span class="s0">))):l(</span><span class="s3">8</span><span class="s0">)))</span><span class="s1">return</span><span class="s0">-</span><span class="s3">48</span><span class="s0">}</span><span class="s1">var </span><span class="s0">m=n.wasmInstance.exports.free,y=f?</span><span class="s1">function</span><span class="s0">(e){m(BigInt(e))}:m,v=</span><span class="s1">new </span><span class="s0">Int32Array(n.wasmMemory.buffer,o,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(Atomics.store(v,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">),Atomics.store(v,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">),n.childThread){c(a(</span><span class="s2">&quot;spawn-thread&quot;</span><span class="s0">,{startArg:e,errorOrTid:o})),Atomics.wait(v,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">);</span><span class="s1">var </span><span class="s0">w=Atomics.load(v,</span><span class="s3">0</span><span class="s0">),_=Atomics.load(v,</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">d?w:(y(o),w?-_:_)}</span><span class="s1">var </span><span class="s0">g,k,T,W=u||</span><span class="s3">0</span><span class="s0">===u;W&amp;&amp;(g=</span><span class="s1">new </span><span class="s0">Int32Array(</span><span class="s1">new </span><span class="s0">SharedArrayBuffer(</span><span class="s3">8208</span><span class="s0">)),Atomics.store(g,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">));</span><span class="s1">var </span><span class="s0">A=n.PThread;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!(k=A.getNewWorker(g)))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;failed to get new worker&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(A.addMessageEventListener(k,p),T=A.markId(k),t&amp;&amp;k.ref(),k.postMessage(a(</span><span class="s2">&quot;start&quot;</span><span class="s0">,{tid:T,arg:e,sab:g})),W){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">u){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;timed-out&quot;</span><span class="s0">===Atomics.wait(g,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,u)){</span><span class="s1">try</span><span class="s0">{A.cleanThread(k,T,!</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">catch</span><span class="s0">(e){}</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Spawning thread timed out. Please check if the worker is created successfully and if message is handled properly in the worker.&quot;</span><span class="s0">)}}</span><span class="s1">else </span><span class="s0">Atomics.wait(g,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(Atomics.load(g,</span><span class="s3">0</span><span class="s0">)&gt;</span><span class="s3">1</span><span class="s0">){</span><span class="s1">try</span><span class="s0">{A.cleanThread(k,T,!</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">catch</span><span class="s0">(e){}</span><span class="s1">throw function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">t,o,n=</span><span class="s1">new </span><span class="s0">Int32Array(e);</span><span class="s1">if</span><span class="s0">(Atomics.load(n,</span><span class="s3">0</span><span class="s0">)&lt;=</span><span class="s3">1</span><span class="s0">)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">i=Atomics.load(n,</span><span class="s3">1</span><span class="s0">),a=Atomics.load(n,</span><span class="s3">2</span><span class="s0">),s=Atomics.load(n,</span><span class="s3">3</span><span class="s0">),d=</span><span class="s1">new </span><span class="s0">Uint8Array(e),h=d.slice(</span><span class="s3">16</span><span class="s0">,</span><span class="s3">16</span><span class="s0">+i),u=d.slice(</span><span class="s3">16</span><span class="s0">+i,</span><span class="s3">16</span><span class="s0">+i+a),c=d.slice(</span><span class="s3">16</span><span class="s0">+i+a,</span><span class="s3">16</span><span class="s0">+i+a+s),l=(</span><span class="s1">new </span><span class="s0">TextDecoder).decode(h),f=(</span><span class="s1">new </span><span class="s0">TextDecoder).decode(u),p=(</span><span class="s1">new </span><span class="s0">TextDecoder).decode(c),m=</span><span class="s1">new</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!==(t=globalThis[l])&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t?t:</span><span class="s2">&quot;RuntimeError&quot;</span><span class="s0">===l&amp;&amp;</span><span class="s1">null</span><span class="s0">!==(o=r.RuntimeError)&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==o?o:Error)(f);</span><span class="s1">return </span><span class="s0">Object.defineProperty(m,</span><span class="s2">&quot;stack&quot;</span><span class="s0">,{value:p,writable:!</span><span class="s3">0</span><span class="s0">,enumerable:!</span><span class="s3">1</span><span class="s0">,configurable:!</span><span class="s3">0</span><span class="s0">}),m}(g.buffer)}}}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">Atomics.store(v,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),Atomics.store(v,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">6</span><span class="s0">),Atomics.notify(v,</span><span class="s3">1</span><span class="s0">),</span><span class="s1">null</span><span class="s0">==A||A.printErr(e.stack),d?</span><span class="s3">1</span><span class="s0">:(y(o),-</span><span class="s3">6</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">Atomics.store(v,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">),Atomics.store(v,</span><span class="s3">1</span><span class="s0">,T),Atomics.notify(v,</span><span class="s3">1</span><span class="s0">),A.runningWorkers.push(k),W||k.whenLoaded.catch(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">throw delete </span><span class="s0">k.whenLoaded,A.cleanThread(k,T,!</span><span class="s3">0</span><span class="s0">),e}),d?</span><span class="s3">0</span><span class="s0">:(y(o),T)};</span><span class="s1">this</span><span class="s0">.threadSpawn=m}</span><span class="s1">return </span><span class="s0">e.prototype.getImportObject=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">{wasi:{</span><span class="s2">&quot;thread-spawn&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.threadSpawn}}},e.prototype.setup=</span><span class="s1">function</span><span class="s0">(e,r,t){</span><span class="s1">null</span><span class="s0">!=t||(t=e.exports.memory),</span><span class="s1">this</span><span class="s0">.wasmInstance=e,</span><span class="s1">this</span><span class="s0">.wasmMemory=t,</span><span class="s1">this</span><span class="s0">.PThread&amp;&amp;</span><span class="s1">this</span><span class="s0">.PThread.setup(r,t)},e.prototype.preloadWorkers=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.PThread?</span><span class="s1">this</span><span class="s0">.PThread.preloadWorkers():Promise.resolve([])},e.prototype.initialize=</span><span class="s1">function</span><span class="s0">(e,r,t){</span><span class="s1">var </span><span class="s0">o=e.exports;</span><span class="s1">null</span><span class="s0">!=t||(t=o.memory),</span><span class="s1">this</span><span class="s0">.childThread&amp;&amp;(e=c(e,t)),</span><span class="s1">this</span><span class="s0">.setup(e,r,t);</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.wasi;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;_start&quot;</span><span class="s1">in </span><span class="s0">o&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o._start)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.childThread){n.start(e);</span><span class="s1">try</span><span class="s0">{n[p(n,</span><span class="s2">&quot;kStarted&quot;</span><span class="s0">)]=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">catch</span><span class="s0">(e){}}</span><span class="s1">else</span><span class="s0">!</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">var </span><span class="s0">t=p(e,[</span><span class="s2">&quot;kInstance&quot;</span><span class="s0">,</span><span class="s2">&quot;kSetMemory&quot;</span><span class="s0">]),o=t[</span><span class="s3">0</span><span class="s0">],n=t[</span><span class="s3">1</span><span class="s0">];e[o]=r,e[n](r.exports.memory)}(n,e);</span><span class="s1">else </span><span class="s0">n.initialize(e);</span><span class="s1">return </span><span class="s0">e},e.prototype.start=</span><span class="s1">function</span><span class="s0">(e,r,t){</span><span class="s1">var </span><span class="s0">o=e.exports;</span><span class="s1">return null</span><span class="s0">!=t||(t=o.memory),</span><span class="s1">this</span><span class="s0">.childThread&amp;&amp;(e=c(e,t)),</span><span class="s1">this</span><span class="s0">.setup(e,r,t),{exitCode:</span><span class="s1">this</span><span class="s0">.wasi.start(e),instance:e}},e.prototype.terminateAllThreads=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">e;</span><span class="s1">this</span><span class="s0">.childThread?</span><span class="s1">this</span><span class="s0">.postMessage(a(</span><span class="s2">&quot;terminate-all-threads&quot;</span><span class="s0">,{})):</span><span class="s1">null</span><span class="s0">===(e=</span><span class="s1">this</span><span class="s0">.PThread)||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e||e.terminateAllThreads()},e}();</span><span class="s1">function </span><span class="s0">p(e,r){</span><span class="s1">var </span><span class="s0">t=Object.getOwnPropertySymbols(e),o=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return function</span><span class="s0">(r){</span><span class="s1">return </span><span class="s0">r.description?r.description===e:r.toString()===</span><span class="s2">&quot;Symbol(&quot;</span><span class="s0">.concat(e,</span><span class="s2">&quot;)&quot;</span><span class="s0">)}};</span><span class="s1">return </span><span class="s0">Array.isArray(r)?r.map(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">t.filter(o(e))[</span><span class="s3">0</span><span class="s0">]}):t.filter(o(r))[</span><span class="s3">0</span><span class="s0">]}</span><span class="s1">var </span><span class="s0">m=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">function </span><span class="s0">e(e){</span><span class="s1">var </span><span class="s0">r=o(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;options.postMessage is not a function&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.postMessage=r,</span><span class="s1">this</span><span class="s0">.onLoad=</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e.onLoad,</span><span class="s1">this</span><span class="s0">.onError=</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e.onError)?e.onError:</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">throw </span><span class="s0">r},</span><span class="s1">this</span><span class="s0">.instance=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.messagesBeforeLoad=[]}</span><span class="s1">return </span><span class="s0">e.prototype.instantiate=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof this</span><span class="s0">.onLoad)</span><span class="s1">return this</span><span class="s0">.onLoad(e);</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;ThreadMessageHandler.prototype.instantiate is not implemented&quot;</span><span class="s0">)},e.prototype.handle=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">r,t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===(r=</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e.data)||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:r.__emnapi__){</span><span class="s1">var </span><span class="s0">o=e.data.__emnapi__.type,n=e.data.__emnapi__.payload;</span><span class="s1">try</span><span class="s0">{</span><span class="s2">&quot;load&quot;</span><span class="s0">===o?</span><span class="s1">this</span><span class="s0">._load(n):</span><span class="s2">&quot;start&quot;</span><span class="s0">===o&amp;&amp;</span><span class="s1">this</span><span class="s0">.handleAfterLoad(e,</span><span class="s1">function</span><span class="s0">(){t._start(n)})}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.onError(e,o)}}},e.prototype._load=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.instance){</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">try</span><span class="s0">{t=</span><span class="s1">this</span><span class="s0">.instantiate(e)}</span><span class="s1">catch</span><span class="s0">(r){</span><span class="s1">return void this</span><span class="s0">._loaded(r,</span><span class="s1">null</span><span class="s0">,e)}</span><span class="s1">var </span><span class="s0">o=t&amp;&amp;</span><span class="s2">&quot;then&quot;</span><span class="s1">in </span><span class="s0">t?t.then:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o?o.call(t,</span><span class="s1">function</span><span class="s0">(t){r._loaded(</span><span class="s1">null</span><span class="s0">,t,e)},</span><span class="s1">function</span><span class="s0">(t){r._loaded(t,</span><span class="s1">null</span><span class="s0">,e)}):</span><span class="s1">this</span><span class="s0">._loaded(</span><span class="s1">null</span><span class="s0">,t,e)}},e.prototype._start=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.instance.exports.wasi_thread_start;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r){</span><span class="s1">var </span><span class="s0">t=</span><span class="s1">new </span><span class="s0">TypeError(</span><span class="s2">&quot;wasi_thread_start is not exported&quot;</span><span class="s0">);</span><span class="s1">throw </span><span class="s0">y(e.sab,</span><span class="s3">2</span><span class="s0">,t),t}</span><span class="s1">var </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">.postMessage,n=e.tid,i=e.arg;y(e.sab,</span><span class="s3">1</span><span class="s0">);</span><span class="s1">try</span><span class="s0">{r(n,i)}</span><span class="s1">catch</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;unwind&quot;</span><span class="s0">!==t)</span><span class="s1">throw </span><span class="s0">t;</span><span class="s1">return</span><span class="s0">}o(a(</span><span class="s2">&quot;cleanup-thread&quot;</span><span class="s0">,{tid:n}))},e.prototype._loaded=</span><span class="s1">function</span><span class="s0">(e,r,t){</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">throw </span><span class="s0">y(t.sab,</span><span class="s3">2</span><span class="s0">,e),e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==r){</span><span class="s1">var </span><span class="s0">o=</span><span class="s1">new </span><span class="s0">TypeError(</span><span class="s2">&quot;onLoad should return an object&quot;</span><span class="s0">);</span><span class="s1">throw </span><span class="s0">y(t.sab,</span><span class="s3">2</span><span class="s0">,o),o}</span><span class="s1">var </span><span class="s0">n=r.instance;</span><span class="s1">if</span><span class="s0">(!n){</span><span class="s1">var </span><span class="s0">i=</span><span class="s1">new </span><span class="s0">TypeError(</span><span class="s2">'onLoad should return an object which includes &quot;instance&quot;'</span><span class="s0">);</span><span class="s1">throw </span><span class="s0">y(t.sab,</span><span class="s3">2</span><span class="s0">,i),i}</span><span class="s1">this</span><span class="s0">.instance=n,(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.postMessage)(a(</span><span class="s2">&quot;loaded&quot;</span><span class="s0">,{}));</span><span class="s1">var </span><span class="s0">s=</span><span class="s1">this</span><span class="s0">.messagesBeforeLoad;</span><span class="s1">this</span><span class="s0">.messagesBeforeLoad=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">d=</span><span class="s3">0</span><span class="s0">;d&lt;s.length;d++){</span><span class="s1">var </span><span class="s0">h=s[d];</span><span class="s1">this</span><span class="s0">.handle({data:h})}},e.prototype.handleAfterLoad=</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.instance?r.call(</span><span class="s1">this</span><span class="s0">,e):</span><span class="s1">this</span><span class="s0">.messagesBeforeLoad.push(e.data)},e}();</span><span class="s1">function </span><span class="s0">y(e,r,t){e&amp;&amp;(!</span><span class="s1">function</span><span class="s0">(e,r,t){</span><span class="s1">var </span><span class="s0">o=</span><span class="s1">new </span><span class="s0">Int32Array(e);</span><span class="s1">if</span><span class="s0">(Atomics.store(o,</span><span class="s3">0</span><span class="s0">,r),r&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;t){</span><span class="s1">var </span><span class="s0">n=t.name,i=t.message,a=t.stack,s=(</span><span class="s1">new </span><span class="s0">TextEncoder).encode(n),d=(</span><span class="s1">new </span><span class="s0">TextEncoder).encode(i),h=(</span><span class="s1">new </span><span class="s0">TextEncoder).encode(a);Atomics.store(o,</span><span class="s3">1</span><span class="s0">,s.length),Atomics.store(o,</span><span class="s3">2</span><span class="s0">,d.length),Atomics.store(o,</span><span class="s3">3</span><span class="s0">,h.length);</span><span class="s1">var </span><span class="s0">u=</span><span class="s1">new </span><span class="s0">Uint8Array(e);u.set(s,</span><span class="s3">16</span><span class="s0">),u.set(d,</span><span class="s3">16</span><span class="s0">+s.length),u.set(h,</span><span class="s3">16</span><span class="s0">+s.length+d.length)}}(e.buffer,r,t),Atomics.notify(e,</span><span class="s3">0</span><span class="s0">))}e.ThreadManager=h,e.ThreadMessageHandler=m,e.WASIThreads=f,e.createInstanceProxy=c,e.isSharedArrayBuffer=n,e.isTrapError=i});</span>
</pre>
</body>
</html>