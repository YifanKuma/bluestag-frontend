<html>
<head>
<title>flight-client-entry-plugin.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
flight-client-entry-plugin.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;FlightClientEntryPlugin&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">FlightClientEntryPlugin;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_webpack = require(</span><span class="s0">&quot;next/dist/compiled/webpack/webpack&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_querystring = require(</span><span class="s0">&quot;querystring&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_ondemandentryhandler = require(</span><span class="s0">&quot;../../../server/dev/on-demand-entry-handler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;../../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../loaders/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;../utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepathsep = require(</span><span class="s0">&quot;../../../shared/lib/page-path/normalize-path-sep&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_buildcontext = require(</span><span class="s0">&quot;../../build-context&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pagetypes = require(</span><span class="s0">&quot;../../../lib/page-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getmodulebuildinfo = require(</span><span class="s0">&quot;../loaders/get-module-build-info&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nextflightloader = require(</span><span class="s0">&quot;../loaders/next-flight-loader&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isapprouteroute = require(</span><span class="s0">&quot;../../../lib/is-app-route-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ismetadataroute = require(</span><span class="s0">&quot;../../../lib/metadata/is-metadata-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getwebpackbundler = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../../../shared/lib/get-webpack-bundler&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">PLUGIN_NAME = </span><span class="s0">'FlightClientEntryPlugin'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">pluginState = (</span><span class="s4">0</span><span class="s1">, _buildcontext.getProxiedPluginState)({</span>
    <span class="s3">// A map to track &quot;action&quot; -&gt; &quot;list of bundles&quot;.</span>
    <span class="s1">serverActions: {},</span>
    <span class="s1">edgeServerActions: {},</span>
    <span class="s1">serverActionModules: {},</span>
    <span class="s1">edgeServerActionModules: {},</span>
    <span class="s1">ssrModules: {},</span>
    <span class="s1">edgeSsrModules: {},</span>
    <span class="s1">rscModules: {},</span>
    <span class="s1">edgeRscModules: {},</span>
    <span class="s1">injectedClientEntries: {}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">POSSIBLE_SHARED_CONVENTIONS = [</span>
    <span class="s0">'template'</span><span class="s1">,</span>
    <span class="s0">'layout'</span>
<span class="s1">];</span>
<span class="s2">const </span><span class="s1">STANDALONE_BUNDLE_CONVENTION = </span><span class="s0">'global-not-found'</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">deduplicateCSSImportsForEntry(mergedCSSimports) {</span>
    <span class="s3">// If multiple entry module connections are having the same CSS import,</span>
    <span class="s3">// we only need to have one module to keep track of that CSS import.</span>
    <span class="s3">// It is based on the fact that if a page or a layout is rendered in the</span>
    <span class="s3">// given entry, all its parent layouts are always rendered too.</span>
    <span class="s3">// This can avoid duplicate CSS imports in the generated CSS manifest,</span>
    <span class="s3">// for example, if a page and its parent layout are both using the same</span>
    <span class="s3">// CSS import, we only need to have the layout to keep track of that CSS</span>
    <span class="s3">// import.</span>
    <span class="s3">// To achieve this, we need to first collect all the CSS imports from</span>
    <span class="s3">// every connection, and deduplicate them in the order of layers from</span>
    <span class="s3">// top to bottom. The implementation can be generally described as:</span>
    <span class="s3">// - Sort by number of `/` in the request path (the more `/`, the deeper)</span>
    <span class="s3">// - When in the same depth, sort by the filename (template &lt; layout &lt; page and others)</span>
    <span class="s3">// Sort the connections as described above.</span>
    <span class="s2">const </span><span class="s1">sortedCSSImports = Object.entries(mergedCSSimports).sort((a, b)=&gt;{</span>
        <span class="s2">const </span><span class="s1">[aPath] = a;</span>
        <span class="s2">const </span><span class="s1">[bPath] = b;</span>
        <span class="s2">const </span><span class="s1">aDepth = aPath.split(</span><span class="s0">'/'</span><span class="s1">).length;</span>
        <span class="s2">const </span><span class="s1">bDepth = bPath.split(</span><span class="s0">'/'</span><span class="s1">).length;</span>
        <span class="s2">if </span><span class="s1">(aDepth !== bDepth) {</span>
            <span class="s2">return </span><span class="s1">aDepth - bDepth;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">aName = _path.default.parse(aPath).name;</span>
        <span class="s2">const </span><span class="s1">bName = _path.default.parse(bPath).name;</span>
        <span class="s2">const </span><span class="s1">indexA = POSSIBLE_SHARED_CONVENTIONS.indexOf(aName);</span>
        <span class="s2">const </span><span class="s1">indexB = POSSIBLE_SHARED_CONVENTIONS.indexOf(bName);</span>
        <span class="s2">if </span><span class="s1">(indexA === -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(indexB === -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">indexA - indexB;</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">dedupedCSSImports = {};</span>
    <span class="s2">const </span><span class="s1">trackedCSSImports = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[entryFilePath, cssImports] of sortedCSSImports){</span>
        <span class="s2">const </span><span class="s1">entryConventionName = _path.default.parse(entryFilePath).name;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">cssImport of cssImports){</span>
            <span class="s3">// If the CSS import is already tracked, we can skip it.</span>
            <span class="s3">// Or if it's any standalone entry such as `global-not-found`, it won't share any resources with other entry, skip it.</span>
            <span class="s2">if </span><span class="s1">(trackedCSSImports.has(cssImport) &amp;&amp; STANDALONE_BUNDLE_CONVENTION !== entryConventionName) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// Only track CSS imports that are in files that can inherit CSS.</span>
            <span class="s2">if </span><span class="s1">(POSSIBLE_SHARED_CONVENTIONS.includes(entryConventionName)) {</span>
                <span class="s1">trackedCSSImports.add(cssImport);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!dedupedCSSImports[entryFilePath]) {</span>
                <span class="s1">dedupedCSSImports[entryFilePath] = [];</span>
            <span class="s1">}</span>
            <span class="s1">dedupedCSSImports[entryFilePath].push(cssImport);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">dedupedCSSImports;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">FlightClientEntryPlugin {</span>
    <span class="s1">constructor(options){</span>
        <span class="s2">this</span><span class="s1">.dev = options.dev;</span>
        <span class="s2">this</span><span class="s1">.appDir = options.appDir;</span>
        <span class="s2">this</span><span class="s1">.projectDir = _path.default.join(options.appDir, </span><span class="s0">'..'</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.isEdgeServer = options.isEdgeServer;</span>
        <span class="s2">this</span><span class="s1">.assetPrefix = !</span><span class="s2">this</span><span class="s1">.dev &amp;&amp; !</span><span class="s2">this</span><span class="s1">.isEdgeServer ? </span><span class="s0">'../' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.encryptionKey = options.encryptionKey;</span>
        <span class="s2">this</span><span class="s1">.webpackRuntime = </span><span class="s2">this</span><span class="s1">.isEdgeServer ? _constants1.EDGE_RUNTIME_WEBPACK : _constants1.DEFAULT_RUNTIME_WEBPACK;</span>
    <span class="s1">}</span>
    <span class="s1">apply(compiler) {</span>
        <span class="s1">compiler.hooks.finishMake.tapPromise(PLUGIN_NAME, (compilation)=&gt;</span><span class="s2">this</span><span class="s1">.createClientEntries(compiler, compilation));</span>
        <span class="s1">compiler.hooks.afterCompile.tap(PLUGIN_NAME, (compilation)=&gt;{</span>
            <span class="s2">const </span><span class="s1">recordModule = (modId, mod)=&gt;{</span>
                <span class="s2">var </span><span class="s1">_mod_resourceResolveData, _mod_resourceResolveData1;</span>
                <span class="s3">// Match Resource is undefined unless an import is using the inline match resource syntax</span>
                <span class="s3">// https://webpack.js.org/api/loaders/#inline-matchresource</span>
                <span class="s2">const </span><span class="s1">modPath = mod.matchResource || ((_mod_resourceResolveData = mod.resourceResolveData) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _mod_resourceResolveData.path);</span>
                <span class="s2">const </span><span class="s1">modQuery = ((_mod_resourceResolveData1 = mod.resourceResolveData) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _mod_resourceResolveData1.query) || </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s3">// query is already part of mod.resource</span>
                <span class="s3">// so it's only necessary to add it for matchResource or mod.resourceResolveData</span>
                <span class="s2">const </span><span class="s1">modResource = modPath ? modPath.startsWith(_constants1.BARREL_OPTIMIZATION_PREFIX) ? (</span><span class="s4">0</span><span class="s1">, _utils1.formatBarrelOptimizedResource)(mod.resource, modPath) : modPath + modQuery : mod.resource;</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">modId !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; modResource) {</span>
                    <span class="s2">if </span><span class="s1">(mod.layer === _constants.WEBPACK_LAYERS.reactServerComponents) {</span>
                        <span class="s2">const </span><span class="s1">key = _path.default.relative(compiler.context, modResource).replace(</span><span class="s5">/\/next\/dist\/esm\//</span><span class="s1">, </span><span class="s0">'/next/dist/'</span><span class="s1">);</span>
                        <span class="s2">const </span><span class="s1">moduleInfo = {</span>
                            <span class="s1">moduleId: modId,</span>
                            <span class="s1">async: compilation.moduleGraph.isAsync(mod)</span>
                        <span class="s1">};</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isEdgeServer) {</span>
                            <span class="s1">pluginState.edgeRscModules[key] = moduleInfo;</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">pluginState.rscModules[key] = moduleInfo;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(mod.layer !== _constants.WEBPACK_LAYERS.serverSideRendering) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">// Check mod resource to exclude the empty resource module like virtual module created by next-flight-client-entry-loader</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">modId !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; modResource) {</span>
                    <span class="s3">// Note that this isn't that reliable as webpack is still possible to assign</span>
                    <span class="s3">// additional queries to make sure there's no conflict even using the `named`</span>
                    <span class="s3">// module ID strategy.</span>
                    <span class="s2">let </span><span class="s1">ssrNamedModuleId = _path.default.relative(compiler.context, modResource);</span>
                    <span class="s2">if </span><span class="s1">(!ssrNamedModuleId.startsWith(</span><span class="s0">'.'</span><span class="s1">)) {</span>
                        <span class="s3">// TODO use getModuleId instead</span>
                        <span class="s1">ssrNamedModuleId = </span><span class="s0">`./</span><span class="s1">${(</span><span class="s4">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(ssrNamedModuleId)}</span><span class="s0">`</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">moduleInfo = {</span>
                        <span class="s1">moduleId: modId,</span>
                        <span class="s1">async: compilation.moduleGraph.isAsync(mod)</span>
                    <span class="s1">};</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isEdgeServer) {</span>
                        <span class="s1">pluginState.edgeSsrModules[ssrNamedModuleId.replace(</span><span class="s5">/\/next\/dist\/esm\//</span><span class="s1">, </span><span class="s0">'/next/dist/'</span><span class="s1">)] = moduleInfo;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">pluginState.ssrModules[ssrNamedModuleId] = moduleInfo;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils1.traverseModules)(compilation, (mod, _chunk, _chunkGroup, modId)=&gt;{</span>
                <span class="s2">if </span><span class="s1">(modId) recordModule(modId, mod);</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
        <span class="s1">compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=&gt;{</span>
            <span class="s1">compilation.hooks.processAssets.tapPromise({</span>
                <span class="s1">name: PLUGIN_NAME,</span>
                <span class="s1">stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH</span>
            <span class="s1">}, ()=&gt;</span><span class="s2">this</span><span class="s1">.createActionAssets(compilation));</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async createClientEntries(compiler, compilation) {</span>
        <span class="s2">const </span><span class="s1">addClientEntryAndSSRModulesList = [];</span>
        <span class="s2">const </span><span class="s1">createdSSRDependenciesForEntry = {};</span>
        <span class="s2">const </span><span class="s1">addActionEntryList = [];</span>
        <span class="s2">const </span><span class="s1">actionMapsPerEntry = {};</span>
        <span class="s2">const </span><span class="s1">createdActionIds = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s3">// For each SC server compilation entry, we need to create its corresponding</span>
        <span class="s3">// client component entry.</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils1.forEachEntryModule)(compilation, ({ name, entryModule })=&gt;{</span>
            <span class="s2">const </span><span class="s1">internalClientComponentEntryImports = {};</span>
            <span class="s2">const </span><span class="s1">actionEntryImports = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">const </span><span class="s1">clientEntriesToInject = [];</span>
            <span class="s2">const </span><span class="s1">mergedCSSimports = {};</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">connection of (</span><span class="s4">0</span><span class="s1">, _utils1.getModuleReferencesInOrder)(entryModule, compilation.moduleGraph)){</span>
                <span class="s3">// Entry can be any user defined entry files such as layout, page, error, loading, etc.</span>
                <span class="s2">let </span><span class="s1">entryRequest = connection.dependency.request;</span>
                <span class="s2">if </span><span class="s1">(entryRequest.endsWith(_constants.WEBPACK_RESOURCE_QUERIES.metadataRoute)) {</span>
                    <span class="s2">const </span><span class="s1">{ filePath, isDynamicRouteExtension } = getMetadataRouteResource(entryRequest);</span>
                    <span class="s2">if </span><span class="s1">(isDynamicRouteExtension === </span><span class="s0">'1'</span><span class="s1">) {</span>
                        <span class="s1">entryRequest = filePath;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">{ clientComponentImports, actionImports, cssImports } = </span><span class="s2">this</span><span class="s1">.collectComponentInfoFromServerEntryDependency({</span>
                    <span class="s1">entryRequest,</span>
                    <span class="s1">compilation,</span>
                    <span class="s1">resolvedModule: connection.resolvedModule</span>
                <span class="s1">});</span>
                <span class="s1">actionImports.forEach(([dep, actions])=&gt;actionEntryImports.set(dep, actions));</span>
                <span class="s2">const </span><span class="s1">isAbsoluteRequest = _path.default.isAbsolute(entryRequest);</span>
                <span class="s3">// Next.js internals are put into a separate entry.</span>
                <span class="s2">if </span><span class="s1">(!isAbsoluteRequest) {</span>
                    <span class="s1">Object.keys(clientComponentImports).forEach((value)=&gt;internalClientComponentEntryImports[value] = </span><span class="s2">new </span><span class="s1">Set());</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">// TODO-APP: Enable these lines. This ensures no entrypoint is created for layout/page when there are no client components.</span>
                <span class="s3">// Currently disabled because it causes test failures in CI.</span>
                <span class="s3">// if (clientImports.length === 0 &amp;&amp; actionImports.length === 0) {</span>
                <span class="s3">//   continue</span>
                <span class="s3">// }</span>
                <span class="s2">const </span><span class="s1">relativeRequest = isAbsoluteRequest ? _path.default.relative(compilation.options.context, entryRequest) : entryRequest;</span>
                <span class="s3">// Replace file suffix as `.js` will be added.</span>
                <span class="s3">// bundlePath will have app/ prefix but not src/.</span>
                <span class="s3">// e.g. src/app/foo/page.js -&gt; app/foo/page</span>
                <span class="s2">let </span><span class="s1">bundlePath = (</span><span class="s4">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(relativeRequest.replace(</span><span class="s5">/\.[^.\\/]+$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">).replace(</span><span class="s5">/^src[\\/]/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">));</span>
                <span class="s3">// For metadata routes, the entry name can be used as the bundle path,</span>
                <span class="s3">// as it has been normalized already.</span>
                <span class="s3">// e.g.</span>
                <span class="s3">// When `relativeRequest` is 'src/app/sitemap.js',</span>
                <span class="s3">// `appDirRelativeRequest` will be '/sitemap.js'</span>
                <span class="s3">// then `isMetadataEntryFile` will be `true`</span>
                <span class="s2">const </span><span class="s1">appDirRelativeRequest = relativeRequest.replace(</span><span class="s5">/^src[\\/]/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">).replace(</span><span class="s5">/^app[\\/]/</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">isMetadataEntryFile = (</span><span class="s4">0</span><span class="s1">, _ismetadataroute.isMetadataRouteFile)(appDirRelativeRequest, _ismetadataroute.DEFAULT_METADATA_ROUTE_EXTENSIONS, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(isMetadataEntryFile) {</span>
                    <span class="s1">bundlePath = name;</span>
                <span class="s1">}</span>
                <span class="s1">Object.assign(mergedCSSimports, cssImports);</span>
                <span class="s1">clientEntriesToInject.push({</span>
                    <span class="s1">compiler,</span>
                    <span class="s1">compilation,</span>
                    <span class="s1">entryName: name,</span>
                    <span class="s1">clientComponentImports,</span>
                    <span class="s1">bundlePath,</span>
                    <span class="s1">absolutePagePath: entryRequest</span>
                <span class="s1">});</span>
                <span class="s3">// The webpack implementation of writing the client reference manifest relies on all entrypoints writing a page.js even when there is no client components in the page.</span>
                <span class="s3">// It needs the file in order to write the reference manifest for the path in the `.next/server` folder.</span>
                <span class="s3">// TODO-APP: This could be better handled, however Turbopack does not have the same problem as we resolve client components in a single graph.</span>
                <span class="s2">if </span><span class="s1">(name === </span><span class="s0">`app</span><span class="s1">${_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}</span><span class="s0">` </span><span class="s1">&amp;&amp; bundlePath === </span><span class="s0">'app/not-found'</span><span class="s1">) {</span>
                    <span class="s1">clientEntriesToInject.push({</span>
                        <span class="s1">compiler,</span>
                        <span class="s1">compilation,</span>
                        <span class="s1">entryName: name,</span>
                        <span class="s1">clientComponentImports: {},</span>
                        <span class="s1">bundlePath: </span><span class="s0">`app</span><span class="s1">${_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}</span><span class="s0">`</span><span class="s1">,</span>
                        <span class="s1">absolutePagePath: entryRequest</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(name === </span><span class="s0">`app</span><span class="s1">${_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}</span><span class="s0">` </span><span class="s1">&amp;&amp; bundlePath === </span><span class="s0">'app/global-not-found'</span><span class="s1">) {</span>
                    <span class="s1">clientEntriesToInject.push({</span>
                        <span class="s1">compiler,</span>
                        <span class="s1">compilation,</span>
                        <span class="s1">entryName: name,</span>
                        <span class="s1">clientComponentImports,</span>
                        <span class="s1">bundlePath: </span><span class="s0">`app</span><span class="s1">${_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}</span><span class="s0">`</span><span class="s1">,</span>
                        <span class="s1">absolutePagePath: entryRequest</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">// Make sure CSS imports are deduplicated before injecting the client entry</span>
            <span class="s3">// and SSR modules.</span>
            <span class="s2">const </span><span class="s1">dedupedCSSImports = deduplicateCSSImportsForEntry(mergedCSSimports);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">clientEntryToInject of clientEntriesToInject){</span>
                <span class="s2">const </span><span class="s1">injected = </span><span class="s2">this</span><span class="s1">.injectClientEntryAndSSRModules({</span>
                    <span class="s1">...clientEntryToInject,</span>
                    <span class="s1">clientImports: {</span>
                        <span class="s1">...clientEntryToInject.clientComponentImports,</span>
                        <span class="s1">...(dedupedCSSImports[clientEntryToInject.absolutePagePath] || []).reduce((res, curr)=&gt;{</span>
                            <span class="s1">res[curr] = </span><span class="s2">new </span><span class="s1">Set();</span>
                            <span class="s2">return </span><span class="s1">res;</span>
                        <span class="s1">}, {})</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s3">// Track all created SSR dependencies for each entry from the server layer.</span>
                <span class="s2">if </span><span class="s1">(!createdSSRDependenciesForEntry[clientEntryToInject.entryName]) {</span>
                    <span class="s1">createdSSRDependenciesForEntry[clientEntryToInject.entryName] = [];</span>
                <span class="s1">}</span>
                <span class="s1">createdSSRDependenciesForEntry[clientEntryToInject.entryName].push(injected[</span><span class="s4">3</span><span class="s1">]);</span>
                <span class="s1">addClientEntryAndSSRModulesList.push(injected);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">, _isapprouteroute.isAppRouteRoute)(name)) {</span>
                <span class="s3">// Create internal app</span>
                <span class="s1">addClientEntryAndSSRModulesList.push(</span><span class="s2">this</span><span class="s1">.injectClientEntryAndSSRModules({</span>
                    <span class="s1">compiler,</span>
                    <span class="s1">compilation,</span>
                    <span class="s1">entryName: name,</span>
                    <span class="s1">clientImports: {</span>
                        <span class="s1">...internalClientComponentEntryImports</span>
                    <span class="s1">},</span>
                    <span class="s1">bundlePath: _constants1.APP_CLIENT_INTERNALS</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(actionEntryImports.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!actionMapsPerEntry[name]) {</span>
                    <span class="s1">actionMapsPerEntry[name] = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s1">}</span>
                <span class="s1">actionMapsPerEntry[name] = </span><span class="s2">new </span><span class="s1">Map([</span>
                    <span class="s1">...actionMapsPerEntry[name],</span>
                    <span class="s1">...actionEntryImports</span>
                <span class="s1">]);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[name, actionEntryImports] of Object.entries(actionMapsPerEntry)){</span>
            <span class="s1">addActionEntryList.push(</span><span class="s2">this</span><span class="s1">.injectActionEntry({</span>
                <span class="s1">compiler,</span>
                <span class="s1">compilation,</span>
                <span class="s1">actions: actionEntryImports,</span>
                <span class="s1">entryName: name,</span>
                <span class="s1">bundlePath: name,</span>
                <span class="s1">createdActionIds</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
        <span class="s3">// Invalidate in development to trigger recompilation</span>
        <span class="s2">const </span><span class="s1">invalidator = (</span><span class="s4">0</span><span class="s1">, _ondemandentryhandler.getInvalidator)(compiler.outputPath);</span>
        <span class="s3">// Check if any of the entry injections need an invalidation</span>
        <span class="s2">if </span><span class="s1">(invalidator &amp;&amp; addClientEntryAndSSRModulesList.some(([shouldInvalidate])=&gt;shouldInvalidate === </span><span class="s2">true</span><span class="s1">)) {</span>
            <span class="s1">invalidator.invalidate([</span>
                <span class="s1">_constants1.COMPILER_NAMES.client</span>
            <span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s3">// Client compiler is invalidated before awaiting the compilation of the SSR</span>
        <span class="s3">// and RSC client component entries so that the client compiler is running</span>
        <span class="s3">// in parallel to the server compiler.</span>
        <span class="s2">await </span><span class="s1">Promise.all(addClientEntryAndSSRModulesList.flatMap((addClientEntryAndSSRModules)=&gt;[</span>
                <span class="s1">addClientEntryAndSSRModules[</span><span class="s4">1</span><span class="s1">],</span>
                <span class="s1">addClientEntryAndSSRModules[</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">]));</span>
        <span class="s3">// Wait for action entries to be added.</span>
        <span class="s2">await </span><span class="s1">Promise.all(addActionEntryList);</span>
        <span class="s2">const </span><span class="s1">addedClientActionEntryList = [];</span>
        <span class="s2">const </span><span class="s1">actionMapsPerClientEntry = {};</span>
        <span class="s3">// We need to create extra action entries that are created from the</span>
        <span class="s3">// client layer.</span>
        <span class="s3">// Start from each entry's created SSR dependency from our previous step.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[name, ssrEntryDependencies] of Object.entries(createdSSRDependenciesForEntry)){</span>
            <span class="s3">// Collect from all entries, e.g. layout.js, page.js, loading.js, ...</span>
            <span class="s3">// add aggregate them.</span>
            <span class="s2">const </span><span class="s1">actionEntryImports = </span><span class="s2">this</span><span class="s1">.collectClientActionsFromDependencies({</span>
                <span class="s1">compilation,</span>
                <span class="s1">dependencies: ssrEntryDependencies</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(actionEntryImports.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!actionMapsPerClientEntry[name]) {</span>
                    <span class="s1">actionMapsPerClientEntry[name] = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s1">}</span>
                <span class="s1">actionMapsPerClientEntry[name] = </span><span class="s2">new </span><span class="s1">Map([</span>
                    <span class="s1">...actionMapsPerClientEntry[name],</span>
                    <span class="s1">...actionEntryImports</span>
                <span class="s1">]);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[entryName, actionEntryImports] of Object.entries(actionMapsPerClientEntry)){</span>
            <span class="s3">// If an action method is already created in the server layer, we don't</span>
            <span class="s3">// need to create it again in the action layer.</span>
            <span class="s3">// This is to avoid duplicate action instances and make sure the module</span>
            <span class="s3">// state is shared.</span>
            <span class="s2">let </span><span class="s1">remainingClientImportedActions = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">remainingActionEntryImports = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[dep, actions] of actionEntryImports){</span>
                <span class="s2">const </span><span class="s1">remainingActionNames = [];</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">action of actions){</span>
                    <span class="s2">if </span><span class="s1">(!createdActionIds.has(entryName + </span><span class="s0">'@' </span><span class="s1">+ action.id)) {</span>
                        <span class="s1">remainingActionNames.push(action);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(remainingActionNames.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">remainingActionEntryImports.set(dep, remainingActionNames);</span>
                    <span class="s1">remainingClientImportedActions = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(remainingClientImportedActions) {</span>
                <span class="s1">addedClientActionEntryList.push(</span><span class="s2">this</span><span class="s1">.injectActionEntry({</span>
                    <span class="s1">compiler,</span>
                    <span class="s1">compilation,</span>
                    <span class="s1">actions: remainingActionEntryImports,</span>
                    <span class="s1">entryName,</span>
                    <span class="s1">bundlePath: entryName,</span>
                    <span class="s1">fromClient: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">createdActionIds</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">await </span><span class="s1">Promise.all(addedClientActionEntryList);</span>
    <span class="s1">}</span>
    <span class="s1">collectClientActionsFromDependencies({ compilation, dependencies }) {</span>
        <span class="s3">// action file path -&gt; action names</span>
        <span class="s2">const </span><span class="s1">collectedActions = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s3">// Keep track of checked modules to avoid infinite loops with recursive imports.</span>
        <span class="s2">const </span><span class="s1">visitedModule = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">const </span><span class="s1">visitedEntry = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">const </span><span class="s1">collectActions = ({ entryRequest, resolvedModule })=&gt;{</span>
            <span class="s2">const </span><span class="s1">collectActionsInDep = (mod)=&gt;{</span>
                <span class="s2">var </span><span class="s1">_getModuleBuildInfo_rsc;</span>
                <span class="s2">if </span><span class="s1">(!mod) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">modResource = getModuleResource(mod);</span>
                <span class="s2">if </span><span class="s1">(!modResource) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(visitedModule.has(modResource)) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s1">visitedModule.add(modResource);</span>
                <span class="s2">const </span><span class="s1">actionIds = (_getModuleBuildInfo_rsc = (</span><span class="s4">0</span><span class="s1">, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _getModuleBuildInfo_rsc.actionIds;</span>
                <span class="s2">if </span><span class="s1">(actionIds) {</span>
                    <span class="s1">collectedActions.set(modResource, Object.entries(actionIds).map(([id, exportedName])=&gt;({</span>
                            <span class="s1">id,</span>
                            <span class="s1">exportedName,</span>
                            <span class="s1">filename: _path.default.posix.relative(</span><span class="s2">this</span><span class="s1">.projectDir, modResource)</span>
                        <span class="s1">})));</span>
                <span class="s1">}</span>
                <span class="s3">// Collect used exported actions transversely.</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils1.getModuleReferencesInOrder)(mod, compilation.moduleGraph).forEach((connection)=&gt;{</span>
                    <span class="s1">collectActionsInDep(connection.resolvedModule);</span>
                <span class="s1">});</span>
            <span class="s1">};</span>
            <span class="s3">// Don't traverse the module graph anymore once hitting the action layer.</span>
            <span class="s2">if </span><span class="s1">(entryRequest &amp;&amp; !entryRequest.includes(</span><span class="s0">'next-flight-action-entry-loader'</span><span class="s1">)) {</span>
                <span class="s3">// Traverse the module graph to find all client components.</span>
                <span class="s1">collectActionsInDep(resolvedModule);</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryDependency of dependencies){</span>
            <span class="s2">const </span><span class="s1">ssrEntryModule = compilation.moduleGraph.getResolvedModule(entryDependency);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">connection of (</span><span class="s4">0</span><span class="s1">, _utils1.getModuleReferencesInOrder)(ssrEntryModule, compilation.moduleGraph)){</span>
                <span class="s2">const </span><span class="s1">depModule = connection.dependency;</span>
                <span class="s2">const </span><span class="s1">request = depModule.request;</span>
                <span class="s3">// It is possible that the same entry is added multiple times in the</span>
                <span class="s3">// connection graph. We can just skip these to speed up the process.</span>
                <span class="s2">if </span><span class="s1">(visitedEntry.has(request)) </span><span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">visitedEntry.add(request);</span>
                <span class="s1">collectActions({</span>
                    <span class="s1">entryRequest: request,</span>
                    <span class="s1">resolvedModule: connection.resolvedModule</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">collectedActions;</span>
    <span class="s1">}</span>
    <span class="s1">collectComponentInfoFromServerEntryDependency({ entryRequest, compilation, resolvedModule }) {</span>
        <span class="s3">// Keep track of checked modules to avoid infinite loops with recursive imports.</span>
        <span class="s2">const </span><span class="s1">visitedOfClientComponentsTraverse = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s3">// Info to collect.</span>
        <span class="s2">const </span><span class="s1">clientComponentImports = {};</span>
        <span class="s2">const </span><span class="s1">actionImports = [];</span>
        <span class="s2">const </span><span class="s1">CSSImports = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">const </span><span class="s1">filterClientComponents = (mod, importedIdentifiers)=&gt;{</span>
            <span class="s2">var </span><span class="s1">_getModuleBuildInfo_rsc;</span>
            <span class="s2">if </span><span class="s1">(!mod) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">modResource = getModuleResource(mod);</span>
            <span class="s2">if </span><span class="s1">(!modResource) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(visitedOfClientComponentsTraverse.has(modResource)) {</span>
                <span class="s2">if </span><span class="s1">(clientComponentImports[modResource]) {</span>
                    <span class="s1">addClientImport(mod, modResource, clientComponentImports, importedIdentifiers, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">visitedOfClientComponentsTraverse.add(modResource);</span>
            <span class="s2">const </span><span class="s1">actionIds = (_getModuleBuildInfo_rsc = (</span><span class="s4">0</span><span class="s1">, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _getModuleBuildInfo_rsc.actionIds;</span>
            <span class="s2">if </span><span class="s1">(actionIds) {</span>
                <span class="s1">actionImports.push([</span>
                    <span class="s1">modResource,</span>
                    <span class="s1">Object.entries(actionIds).map(([id, exportedName])=&gt;({</span>
                            <span class="s1">id,</span>
                            <span class="s1">exportedName,</span>
                            <span class="s1">filename: _path.default.posix.relative(</span><span class="s2">this</span><span class="s1">.projectDir, modResource)</span>
                        <span class="s1">}))</span>
                <span class="s1">]);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _utils.isCSSMod)(mod)) {</span>
                <span class="s2">const </span><span class="s1">sideEffectFree = mod.factoryMeta &amp;&amp; mod.factoryMeta.sideEffectFree;</span>
                <span class="s2">if </span><span class="s1">(sideEffectFree) {</span>
                    <span class="s2">const </span><span class="s1">unused = !compilation.moduleGraph.getExportsInfo(mod).isModuleUsed(</span><span class="s2">this</span><span class="s1">.webpackRuntime);</span>
                    <span class="s2">if </span><span class="s1">(unused) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">CSSImports.add(modResource);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _utils.isClientComponentEntryModule)(mod)) {</span>
                <span class="s2">if </span><span class="s1">(!clientComponentImports[modResource]) {</span>
                    <span class="s1">clientComponentImports[modResource] = </span><span class="s2">new </span><span class="s1">Set();</span>
                <span class="s1">}</span>
                <span class="s1">addClientImport(mod, modResource, clientComponentImports, importedIdentifiers, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils1.getModuleReferencesInOrder)(mod, compilation.moduleGraph).forEach((connection)=&gt;{</span>
                <span class="s2">var </span><span class="s1">_connection_dependency;</span>
                <span class="s2">let </span><span class="s1">dependencyIds = [];</span>
                <span class="s3">// `ids` are the identifiers that are imported from the dependency,</span>
                <span class="s3">// if it's present, it's an array of strings.</span>
                <span class="s2">if </span><span class="s1">((_connection_dependency = connection.dependency) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _connection_dependency.ids) {</span>
                    <span class="s1">dependencyIds.push(...connection.dependency.ids);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">dependencyIds = [</span>
                        <span class="s0">'*'</span>
                    <span class="s1">];</span>
                <span class="s1">}</span>
                <span class="s1">filterClientComponents(connection.resolvedModule, dependencyIds);</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
        <span class="s3">// Traverse the module graph to find all client components.</span>
        <span class="s1">filterClientComponents(resolvedModule, []);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">clientComponentImports,</span>
            <span class="s1">cssImports: CSSImports.size ? {</span>
                <span class="s1">[entryRequest]: Array.from(CSSImports)</span>
            <span class="s1">} : {},</span>
            <span class="s1">actionImports</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">injectClientEntryAndSSRModules({ compiler, compilation, entryName, clientImports, bundlePath, absolutePagePath }) {</span>
        <span class="s2">const </span><span class="s1">bundler = (</span><span class="s4">0</span><span class="s1">, _getwebpackbundler.default)();</span>
        <span class="s2">let </span><span class="s1">shouldInvalidate = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">modules = Object.keys(clientImports).sort((a, b)=&gt;_utils.regexCSS.test(b) ? </span><span class="s4">1 </span><span class="s1">: a.localeCompare(b)).map((clientImportPath)=&gt;({</span>
                <span class="s1">request: clientImportPath,</span>
                <span class="s1">ids: [</span>
                    <span class="s1">...clientImports[clientImportPath]</span>
                <span class="s1">]</span>
            <span class="s1">}));</span>
        <span class="s3">// For the client entry, we always use the CJS build of Next.js. If the</span>
        <span class="s3">// server is using the ESM build (when using the Edge runtime), we need to</span>
        <span class="s3">// replace them.</span>
        <span class="s2">const </span><span class="s1">clientBrowserLoader = </span><span class="s0">`next-flight-client-entry-loader?</span><span class="s1">${(</span><span class="s4">0</span><span class="s1">, _querystring.stringify)({</span>
            <span class="s1">modules: (</span><span class="s2">this</span><span class="s1">.isEdgeServer ? modules.map(({ request, ids })=&gt;({</span>
                    <span class="s1">request: request.replace(</span><span class="s5">/[\\/]next[\\/]dist[\\/]esm[\\/]/</span><span class="s1">, </span><span class="s0">'/next/dist/'</span><span class="s1">.replace(</span><span class="s5">/\//g</span><span class="s1">, _path.default.sep)),</span>
                    <span class="s1">ids</span>
                <span class="s1">})) : modules).map((x)=&gt;JSON.stringify(x)),</span>
            <span class="s1">server: </span><span class="s2">false</span>
        <span class="s1">})}</span><span class="s0">!`</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">clientServerLoader = </span><span class="s0">`next-flight-client-entry-loader?</span><span class="s1">${(</span><span class="s4">0</span><span class="s1">, _querystring.stringify)({</span>
            <span class="s1">modules: modules.map((x)=&gt;JSON.stringify(x)),</span>
            <span class="s1">server: </span><span class="s2">true</span>
        <span class="s1">})}</span><span class="s0">!`</span><span class="s1">;</span>
        <span class="s3">// Add for the client compilation</span>
        <span class="s3">// Inject the entry to the client compiler.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.dev) {</span>
            <span class="s2">const </span><span class="s1">entries = (</span><span class="s4">0</span><span class="s1">, _ondemandentryhandler.getEntries)(compiler.outputPath);</span>
            <span class="s2">const </span><span class="s1">pageKey = (</span><span class="s4">0</span><span class="s1">, _ondemandentryhandler.getEntryKey)(_constants1.COMPILER_NAMES.client, _pagetypes.PAGE_TYPES.APP, bundlePath);</span>
            <span class="s2">if </span><span class="s1">(!entries[pageKey]) {</span>
                <span class="s1">entries[pageKey] = {</span>
                    <span class="s1">type: _ondemandentryhandler.EntryTypes.CHILD_ENTRY,</span>
                    <span class="s1">parentEntries: </span><span class="s2">new </span><span class="s1">Set([</span>
                        <span class="s1">entryName</span>
                    <span class="s1">]),</span>
                    <span class="s1">absoluteEntryFilePath: absolutePagePath,</span>
                    <span class="s1">bundlePath,</span>
                    <span class="s1">request: clientBrowserLoader,</span>
                    <span class="s1">dispose: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">lastActiveTime: Date.now()</span>
                <span class="s1">};</span>
                <span class="s1">shouldInvalidate = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">entryData = entries[pageKey];</span>
                <span class="s3">// New version of the client loader</span>
                <span class="s2">if </span><span class="s1">(entryData.request !== clientBrowserLoader) {</span>
                    <span class="s1">entryData.request = clientBrowserLoader;</span>
                    <span class="s1">shouldInvalidate = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(entryData.type === _ondemandentryhandler.EntryTypes.CHILD_ENTRY) {</span>
                    <span class="s1">entryData.parentEntries.add(entryName);</span>
                <span class="s1">}</span>
                <span class="s1">entryData.dispose = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">entryData.lastActiveTime = Date.now();</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">pluginState.injectedClientEntries[bundlePath] = clientBrowserLoader;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">clientComponentSSREntryDep = bundler.EntryPlugin.createDependency(clientServerLoader, {</span>
            <span class="s1">name: bundlePath</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">clientComponentRSCEntryDep = bundler.EntryPlugin.createDependency(clientServerLoader, {</span>
            <span class="s1">name: bundlePath</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">shouldInvalidate,</span>
            <span class="s3">// Add the entries to the server compiler for the SSR and RSC layers. The</span>
            <span class="s3">// promises are awaited later using `Promise.all` in order to parallelize</span>
            <span class="s3">// adding the entries.</span>
            <span class="s2">this</span><span class="s1">.addEntry(compilation, compiler.context, clientComponentSSREntryDep, {</span>
                <span class="s1">name: entryName,</span>
                <span class="s1">layer: _constants.WEBPACK_LAYERS.serverSideRendering</span>
            <span class="s1">}),</span>
            <span class="s2">this</span><span class="s1">.addEntry(compilation, compiler.context, clientComponentRSCEntryDep, {</span>
                <span class="s1">name: entryName,</span>
                <span class="s1">layer: _constants.WEBPACK_LAYERS.reactServerComponents</span>
            <span class="s1">}),</span>
            <span class="s1">clientComponentSSREntryDep</span>
        <span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s1">injectActionEntry({ compiler, compilation, actions, entryName, bundlePath, fromClient, createdActionIds }) {</span>
        <span class="s2">const </span><span class="s1">bundler = (</span><span class="s4">0</span><span class="s1">, _getwebpackbundler.default)();</span>
        <span class="s2">const </span><span class="s1">actionsArray = Array.from(actions.entries());</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[, actionsFromModule] of actions){</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ id } of actionsFromModule){</span>
                <span class="s1">createdActionIds.add(entryName + </span><span class="s0">'@' </span><span class="s1">+ id);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(actionsArray.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">Promise.resolve();</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">actionLoader = </span><span class="s0">`next-flight-action-entry-loader?</span><span class="s1">${(</span><span class="s4">0</span><span class="s1">, _querystring.stringify)({</span>
            <span class="s1">actions: JSON.stringify(actionsArray),</span>
            <span class="s1">__client_imported__: fromClient</span>
        <span class="s1">})}</span><span class="s0">!`</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">currentCompilerServerActions = </span><span class="s2">this</span><span class="s1">.isEdgeServer ? pluginState.edgeServerActions : pluginState.serverActions;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[, actionsFromModule] of actionsArray){</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ id, exportedName, filename } of actionsFromModule){</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">currentCompilerServerActions[id] === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
                    <span class="s1">currentCompilerServerActions[id] = {</span>
                        <span class="s1">workers: {},</span>
                        <span class="s1">layer: {},</span>
                        <span class="s1">filename,</span>
                        <span class="s1">exportedName</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
                <span class="s1">currentCompilerServerActions[id].workers[bundlePath] = {</span>
                    <span class="s1">moduleId: </span><span class="s0">''</span><span class="s1">,</span>
                    <span class="s1">async: </span><span class="s2">false</span>
                <span class="s1">};</span>
                <span class="s1">currentCompilerServerActions[id].layer[bundlePath] = fromClient ? _constants.WEBPACK_LAYERS.actionBrowser : _constants.WEBPACK_LAYERS.reactServerComponents;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// Inject the entry to the server compiler</span>
        <span class="s2">const </span><span class="s1">actionEntryDep = bundler.EntryPlugin.createDependency(actionLoader, {</span>
            <span class="s1">name: bundlePath</span>
        <span class="s1">});</span>
        <span class="s2">return this</span><span class="s1">.addEntry(compilation, </span><span class="s3">// Reuse compilation context.</span>
        <span class="s1">compiler.context, actionEntryDep, {</span>
            <span class="s1">name: entryName,</span>
            <span class="s1">layer: fromClient ? _constants.WEBPACK_LAYERS.actionBrowser : _constants.WEBPACK_LAYERS.reactServerComponents</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">addEntry(compilation, context, dependency, options) </span><span class="s3">/* Promise&lt;module&gt; */ </span><span class="s1">{</span>
        <span class="s2">return new </span><span class="s1">Promise((resolve, reject)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s0">'rspack' </span><span class="s2">in </span><span class="s1">compilation.compiler) {</span>
                <span class="s1">compilation.addInclude(context, dependency, options, (err, module)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(err) {</span>
                        <span class="s2">return </span><span class="s1">reject(err);</span>
                    <span class="s1">}</span>
                    <span class="s1">compilation.moduleGraph.getExportsInfo(module).setUsedInUnknownWay(</span><span class="s2">this</span><span class="s1">.isEdgeServer ? _constants1.EDGE_RUNTIME_WEBPACK : _constants1.DEFAULT_RUNTIME_WEBPACK);</span>
                    <span class="s2">return </span><span class="s1">resolve(module);</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">entry = compilation.entries.get(options.name);</span>
                <span class="s1">entry.includeDependencies.push(dependency);</span>
                <span class="s1">compilation.hooks.addEntry.call(entry, options);</span>
                <span class="s1">compilation.addModuleTree({</span>
                    <span class="s1">context,</span>
                    <span class="s1">dependency,</span>
                    <span class="s1">contextInfo: {</span>
                        <span class="s1">issuerLayer: options.layer</span>
                    <span class="s1">}</span>
                <span class="s1">}, (err, module)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(err) {</span>
                        <span class="s1">compilation.hooks.failedEntry.call(dependency, options, err);</span>
                        <span class="s2">return </span><span class="s1">reject(err);</span>
                    <span class="s1">}</span>
                    <span class="s1">compilation.hooks.succeedEntry.call(dependency, options, module);</span>
                    <span class="s1">compilation.moduleGraph.getExportsInfo(module).setUsedInUnknownWay(</span><span class="s2">this</span><span class="s1">.isEdgeServer ? _constants1.EDGE_RUNTIME_WEBPACK : _constants1.DEFAULT_RUNTIME_WEBPACK);</span>
                    <span class="s2">return </span><span class="s1">resolve(module);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async createActionAssets(compilation) {</span>
        <span class="s2">const </span><span class="s1">serverActions = {};</span>
        <span class="s2">const </span><span class="s1">edgeServerActions = {};</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils1.traverseModules)(compilation, (mod, _chunk, chunkGroup, modId)=&gt;{</span>
            <span class="s3">// Go through all action entries and record the module ID for each entry.</span>
            <span class="s2">if </span><span class="s1">(chunkGroup.name &amp;&amp; mod.request &amp;&amp; modId &amp;&amp; </span><span class="s5">/next-flight-action-entry-loader/</span><span class="s1">.test(mod.request)) {</span>
                <span class="s2">const </span><span class="s1">fromClient = </span><span class="s5">/&amp;__client_imported__=true/</span><span class="s1">.test(mod.request);</span>
                <span class="s2">const </span><span class="s1">mapping = </span><span class="s2">this</span><span class="s1">.isEdgeServer ? pluginState.edgeServerActionModules : pluginState.serverActionModules;</span>
                <span class="s2">if </span><span class="s1">(!mapping[chunkGroup.name]) {</span>
                    <span class="s1">mapping[chunkGroup.name] = {};</span>
                <span class="s1">}</span>
                <span class="s1">mapping[chunkGroup.name][fromClient ? </span><span class="s0">'client' </span><span class="s1">: </span><span class="s0">'server'</span><span class="s1">] = {</span>
                    <span class="s1">moduleId: modId,</span>
                    <span class="s1">async: compilation.moduleGraph.isAsync(mod)</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">id </span><span class="s2">in </span><span class="s1">pluginState.serverActions){</span>
            <span class="s2">const </span><span class="s1">action = pluginState.serverActions[id];</span>
            <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">name </span><span class="s2">in </span><span class="s1">action.workers){</span>
                <span class="s2">const </span><span class="s1">modId = pluginState.serverActionModules[name][action.layer[name] === _constants.WEBPACK_LAYERS.actionBrowser ? </span><span class="s0">'client' </span><span class="s1">: </span><span class="s0">'server'</span><span class="s1">];</span>
                <span class="s1">action.workers[name] = modId;</span>
            <span class="s1">}</span>
            <span class="s1">serverActions[id] = action;</span>
        <span class="s1">}</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">id </span><span class="s2">in </span><span class="s1">pluginState.edgeServerActions){</span>
            <span class="s2">const </span><span class="s1">action = pluginState.edgeServerActions[id];</span>
            <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">name </span><span class="s2">in </span><span class="s1">action.workers){</span>
                <span class="s2">const </span><span class="s1">modId = pluginState.edgeServerActionModules[name][action.layer[name] === _constants.WEBPACK_LAYERS.actionBrowser ? </span><span class="s0">'client' </span><span class="s1">: </span><span class="s0">'server'</span><span class="s1">];</span>
                <span class="s1">action.workers[name] = modId;</span>
            <span class="s1">}</span>
            <span class="s1">edgeServerActions[id] = action;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">serverManifest = {</span>
            <span class="s1">node: serverActions,</span>
            <span class="s1">edge: edgeServerActions,</span>
            <span class="s1">encryptionKey: </span><span class="s2">this</span><span class="s1">.encryptionKey</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">edgeServerManifest = {</span>
            <span class="s1">...serverManifest,</span>
            <span class="s1">encryptionKey: </span><span class="s0">'process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY'</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">json = JSON.stringify(serverManifest, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.dev ? </span><span class="s4">2 </span><span class="s1">: undefined);</span>
        <span class="s2">const </span><span class="s1">edgeJson = JSON.stringify(edgeServerManifest, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.dev ? </span><span class="s4">2 </span><span class="s1">: undefined);</span>
        <span class="s1">compilation.emitAsset(</span><span class="s0">`</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.assetPrefix}${_constants1.SERVER_REFERENCE_MANIFEST}</span><span class="s0">.js`</span><span class="s1">, </span><span class="s2">new </span><span class="s1">_webpack.sources.RawSource(</span><span class="s0">`self.__RSC_SERVER_MANIFEST=</span><span class="s1">${JSON.stringify(edgeJson)}</span><span class="s0">`</span><span class="s1">));</span>
        <span class="s1">compilation.emitAsset(</span><span class="s0">`</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.assetPrefix}${_constants1.SERVER_REFERENCE_MANIFEST}</span><span class="s0">.json`</span><span class="s1">, </span><span class="s2">new </span><span class="s1">_webpack.sources.RawSource(json));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addClientImport(mod, modRequest, clientComponentImports, importedIdentifiers, isFirstVisitModule) {</span>
    <span class="s2">var </span><span class="s1">_getModuleBuildInfo_rsc;</span>
    <span class="s2">const </span><span class="s1">clientEntryType = (_getModuleBuildInfo_rsc = (</span><span class="s4">0</span><span class="s1">, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _getModuleBuildInfo_rsc.clientEntryType;</span>
    <span class="s2">const </span><span class="s1">isCjsModule = clientEntryType === </span><span class="s0">'cjs'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">assumedSourceType = (</span><span class="s4">0</span><span class="s1">, _nextflightloader.getAssumedSourceType)(mod, isCjsModule ? </span><span class="s0">'commonjs' </span><span class="s1">: </span><span class="s0">'auto'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">clientImportsSet = clientComponentImports[modRequest];</span>
    <span class="s2">if </span><span class="s1">(importedIdentifiers[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'*'</span><span class="s1">) {</span>
        <span class="s3">// If there's collected import path with named import identifiers,</span>
        <span class="s3">// or there's nothing in collected imports are empty.</span>
        <span class="s3">// we should include the whole module.</span>
        <span class="s2">if </span><span class="s1">(!isFirstVisitModule &amp;&amp; [</span>
            <span class="s1">...clientImportsSet</span>
        <span class="s1">][</span><span class="s4">0</span><span class="s1">] !== </span><span class="s0">'*'</span><span class="s1">) {</span>
            <span class="s1">clientComponentImports[modRequest] = </span><span class="s2">new </span><span class="s1">Set([</span>
                <span class="s0">'*'</span>
            <span class="s1">]);</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">isAutoModuleSourceType = assumedSourceType === </span><span class="s0">'auto'</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(isAutoModuleSourceType) {</span>
            <span class="s1">clientComponentImports[modRequest] = </span><span class="s2">new </span><span class="s1">Set([</span>
                <span class="s0">'*'</span>
            <span class="s1">]);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s3">// If it's not analyzed as named ESM exports, e.g. if it's mixing `export *` with named exports,</span>
            <span class="s3">// We'll include all modules since it's not able to do tree-shaking.</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of importedIdentifiers){</span>
                <span class="s3">// For cjs module default import, we include the whole module since</span>
                <span class="s2">const </span><span class="s1">isCjsDefaultImport = isCjsModule &amp;&amp; name === </span><span class="s0">'default'</span><span class="s1">;</span>
                <span class="s3">// Always include __esModule along with cjs module default export,</span>
                <span class="s3">// to make sure it work with client module proxy from React.</span>
                <span class="s2">if </span><span class="s1">(isCjsDefaultImport) {</span>
                    <span class="s1">clientComponentImports[modRequest].add(</span><span class="s0">'__esModule'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">clientComponentImports[modRequest].add(name);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getModuleResource(mod) {</span>
    <span class="s2">var </span><span class="s1">_mod_resourceResolveData, _mod_resourceResolveData1, _mod_matchResource;</span>
    <span class="s2">const </span><span class="s1">modPath = ((_mod_resourceResolveData = mod.resourceResolveData) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _mod_resourceResolveData.path) || </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">modQuery = ((_mod_resourceResolveData1 = mod.resourceResolveData) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _mod_resourceResolveData1.query) || </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s3">// We have to always use the resolved request here to make sure the</span>
    <span class="s3">// server and client are using the same module path (required by RSC), as</span>
    <span class="s3">// the server compiler and client compiler have different resolve configs.</span>
    <span class="s2">let </span><span class="s1">modResource = modPath + modQuery;</span>
    <span class="s3">// Context modules don't have a resource path, we use the identifier instead.</span>
    <span class="s2">if </span><span class="s1">(mod.constructor.name === </span><span class="s0">'ContextModule'</span><span class="s1">) {</span>
        <span class="s1">modResource = mod.identifier();</span>
    <span class="s1">}</span>
    <span class="s3">// For the barrel optimization, we need to use the match resource instead</span>
    <span class="s3">// because there will be 2 modules for the same file (same resource path)</span>
    <span class="s3">// but they're different modules and can't be deduped via `visitedModule`.</span>
    <span class="s3">// The first module is a virtual re-export module created by the loader.</span>
    <span class="s2">if </span><span class="s1">((_mod_matchResource = mod.matchResource) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _mod_matchResource.startsWith(_constants1.BARREL_OPTIMIZATION_PREFIX)) {</span>
        <span class="s1">modResource = mod.matchResource + </span><span class="s0">':' </span><span class="s1">+ modResource;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mod.resource === </span><span class="s0">`?</span><span class="s1">${_constants.WEBPACK_RESOURCE_QUERIES.metadataRoute}</span><span class="s0">`</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">getMetadataRouteResource(mod.rawRequest).filePath;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">modResource;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getMetadataRouteResource(request) {</span>
    <span class="s3">// e.g. next-metadata-route-loader?filePath=&lt;some-url-encoded-path&gt;&amp;isDynamicRouteExtension=1!?__next_metadata_route__</span>
    <span class="s2">const </span><span class="s1">query = request.split(</span><span class="s0">'!'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">].split(</span><span class="s0">'next-metadata-route-loader?'</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _querystring.parse)(query);</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=flight-client-entry-plugin.js.map</span></pre>
</body>
</html>