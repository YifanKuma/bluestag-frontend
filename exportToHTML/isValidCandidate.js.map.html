<html>
<head>
<title>isValidCandidate.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
isValidCandidate.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;isValidCandidate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_constants&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_util&quot;</span><span class="s0">,</span><span class="s1">&quot;_utf&quot;</span><span class="s0">,</span><span class="s1">&quot;OPENING_PARENS&quot;</span><span class="s0">,</span><span class="s1">&quot;CLOSING_PARENS&quot;</span><span class="s0">,</span><span class="s1">&quot;NON_PARENS&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;LEAD_CLASS&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;PLUS_CHARS&quot;</span><span class="s0">,</span><span class="s1">&quot;LEAD_CLASS_LEADING&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;BRACKET_PAIR_LIMIT&quot;</span><span class="s0">,</span><span class="s1">&quot;limit&quot;</span><span class="s0">,</span><span class="s1">&quot;MATCHING_BRACKETS_ENTIRE&quot;</span><span class="s0">,</span><span class="s1">&quot;PUB_PAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidCandidate&quot;</span><span class="s0">,</span><span class="s1">&quot;candidate&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;leniency&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;previousChar&quot;</span><span class="s0">,</span><span class="s1">&quot;isInvalidPunctuationSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;isLatinLetter&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCharIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;nextChar&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../source/findNumbers/isValidCandidate.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Copy-pasted from `PhoneNumberMatcher.js`.</span><span class="s3">\r\n\r\n</span><span class="s1">import { PLUS_CHARS } from '../constants.js'</span><span class="s3">\r\n</span><span class="s1">import { limit } from './util.js'</span><span class="s3">\r\n\r\n</span><span class="s1">import {</span><span class="s3">\r\n\t</span><span class="s1">isLatinLetter,</span><span class="s3">\r\n\t</span><span class="s1">isInvalidPunctuationSymbol</span><span class="s3">\r\n</span><span class="s1">} from './utf-8.js'</span><span class="s3">\r\n\r\n</span><span class="s1">const OPENING_PARENS = '(</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">uFF08</span><span class="s3">\\</span><span class="s1">uFF3B'</span><span class="s3">\r\n</span><span class="s1">const CLOSING_PARENS = ')</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">uFF09</span><span class="s3">\\</span><span class="s1">uFF3D'</span><span class="s3">\r\n</span><span class="s1">const NON_PARENS = `[^${OPENING_PARENS}${CLOSING_PARENS}]`</span><span class="s3">\r\n\r\n</span><span class="s1">export const LEAD_CLASS = `[${OPENING_PARENS}${PLUS_CHARS}]`</span><span class="s3">\r\n\r\n</span><span class="s1">// Punctuation that may be at the start of a phone number - brackets and plus signs.</span><span class="s3">\r\n</span><span class="s1">const LEAD_CLASS_LEADING = new RegExp('^' + LEAD_CLASS)</span><span class="s3">\r\n\r\n</span><span class="s1">// Limit on the number of pairs of brackets in a phone number.</span><span class="s3">\r\n</span><span class="s1">const BRACKET_PAIR_LIMIT = limit(0, 3)</span><span class="s3">\r\n\r\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Pattern to check that brackets match. Opening brackets should be closed within a phone number.</span><span class="s3">\r\n </span><span class="s1">* This also checks that there is something inside the brackets. Having no brackets at all is also</span><span class="s3">\r\n </span><span class="s1">* fine.</span><span class="s3">\r\n </span><span class="s1">*</span><span class="s3">\r\n </span><span class="s1">* An opening bracket at the beginning may not be closed, but subsequent ones should be.  It's</span><span class="s3">\r\n </span><span class="s1">* also possible that the leading bracket was dropped, so we shouldn't be surprised if we see a</span><span class="s3">\r\n </span><span class="s1">* closing bracket first. We limit the sets of brackets in a phone number to four.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">const MATCHING_BRACKETS_ENTIRE = new RegExp</span><span class="s3">\r\n</span><span class="s1">(</span><span class="s3">\r\n\t</span><span class="s1">'^'</span><span class="s3">\r\n\t</span><span class="s1">+ </span><span class="s3">\&quot;</span><span class="s1">(?:[</span><span class="s3">\&quot; </span><span class="s1">+ OPENING_PARENS + </span><span class="s3">\&quot;</span><span class="s1">])?</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot; </span><span class="s1">+ NON_PARENS + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">+ CLOSING_PARENS + </span><span class="s3">\&quot;</span><span class="s1">])?</span><span class="s3">\&quot;\r\n\t</span><span class="s1">+ NON_PARENS + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;\r\n\t</span><span class="s1">+ </span><span class="s3">\&quot;</span><span class="s1">(?:[</span><span class="s3">\&quot; </span><span class="s1">+ OPENING_PARENS + </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot; </span><span class="s1">+ NON_PARENS + </span><span class="s3">\&quot;</span><span class="s1">+[</span><span class="s3">\&quot; </span><span class="s1">+ CLOSING_PARENS + </span><span class="s3">\&quot;</span><span class="s1">])</span><span class="s3">\&quot; </span><span class="s1">+ BRACKET_PAIR_LIMIT</span><span class="s3">\r\n\t</span><span class="s1">+ NON_PARENS + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;\r\n\t</span><span class="s1">+ '$'</span><span class="s3">\r\n</span><span class="s1">)</span><span class="s3">\r\n\r\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Matches strings that look like publication pages. Example:</span><span class="s3">\r\n </span><span class="s1">* &lt;pre&gt;Computing Complete Answers to Queries in the Presence of Limited Access Patterns.</span><span class="s3">\r\n </span><span class="s1">* Chen Li. VLDB J. 12(3): 211-227 (2003).&lt;/pre&gt;</span><span class="s3">\r\n </span><span class="s1">*</span><span class="s3">\r\n </span><span class="s1">* The string </span><span class="s3">\&quot;</span><span class="s1">211-227 (2003)</span><span class="s3">\&quot; </span><span class="s1">is not a telephone number.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">const PUB_PAGES = /</span><span class="s3">\\</span><span class="s1">d{1,5}-+</span><span class="s3">\\</span><span class="s1">d{1,5}</span><span class="s3">\\</span><span class="s1">s{0,4}</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">d{1,4}/</span><span class="s3">\r\n\r\n</span><span class="s1">export default function isValidCandidate(candidate, offset, text, leniency)</span><span class="s3">\r\n</span><span class="s1">{</span><span class="s3">\r\n\t</span><span class="s1">// Check the candidate doesn't contain any formatting</span><span class="s3">\r\n\t</span><span class="s1">// which would indicate that it really isn't a phone number.</span><span class="s3">\r\n\t</span><span class="s1">if (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {</span><span class="s3">\r\n\t\t</span><span class="s1">return</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// If leniency is set to VALID or stricter, we also want to skip numbers that are surrounded</span><span class="s3">\r\n\t</span><span class="s1">// by Latin alphabetic characters, to skip cases like abc8005001234 or 8005001234def.</span><span class="s3">\r\n\t</span><span class="s1">if (leniency !== 'POSSIBLE')</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">// If the candidate is not at the start of the text,</span><span class="s3">\r\n\t\t</span><span class="s1">// and does not start with phone-number punctuation,</span><span class="s3">\r\n\t\t</span><span class="s1">// check the previous character.</span><span class="s3">\r\n\t\t</span><span class="s1">if (offset &gt; 0 &amp;&amp; !LEAD_CLASS_LEADING.test(candidate))</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">const previousChar = text[offset - 1]</span><span class="s3">\r\n\t\t\t</span><span class="s1">// We return null if it is a latin letter or an invalid punctuation symbol.</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (isInvalidPunctuationSymbol(previousChar) || isLatinLetter(previousChar)) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">const lastCharIndex = offset + candidate.length</span><span class="s3">\r\n\t\t</span><span class="s1">if (lastCharIndex &lt; text.length)</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">const nextChar = text[lastCharIndex]</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (isInvalidPunctuationSymbol(nextChar) || isLatinLetter(nextChar)) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">return true</span><span class="s3">\r\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;AAEA,IAAAA,UAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAEA,IAAAE,IAAA,GAAAF,OAAA;AALA;;AAUA,IAAMG,cAAc,GAAG,kBAAkB;AACzC,IAAMC,cAAc,GAAG,kBAAkB;AACzC,IAAMC,UAAU,QAAAC,MAAA,CAAQH,cAAc,EAAAG,MAAA,CAAGF,cAAc,MAAG;AAEnD,IAAMG,UAAU,GAAAC,OAAA,CAAAD,UAAA,OAAAD,MAAA,CAAOH,cAAc,EAAAG,MAAA,CAAGG,qBAAU,MAAG;;AAE5D;AACA,IAAMC,kBAAkB,GAAG,IAAIC,MAAM,CAAC,GAAG,GAAGJ,UAAU,CAAC;;AAEvD;AACA,IAAMK,kBAAkB,GAAG,IAAAC,WAAK,EAAC,CAAC,EAAE,CAAC,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMC,wBAAwB,GAAG,IAAIH,MAAM,CAE1C,GAAG,GACD,MAAM,GAAGR,cAAc,GAAG,KAAK,GAAG,KAAK,GAAGE,UAAU,GAAG,GAAG,GAAG,GAAG,GAAGD,cAAc,GAAG,KAAK,GACzFC,UAAU,GAAG,GAAG,GAChB,MAAM,GAAGF,cAAc,GAAG,GAAG,GAAGE,UAAU,GAAG,IAAI,GAAGD,cAAc,GAAG,IAAI,GAAGQ,kBAAkB,GAC9FP,UAAU,GAAG,GAAG,GAChB,GACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMU,SAAS,GAAG,kCAAkC;AAErC,SAASC,gBAAgBA,CAACC,SAAS,EAAEC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAC1E;EACC;EACA;EACA,IAAI,CAACN,wBAAwB,CAACO,IAAI,CAACJ,SAAS,CAAC,IAAIF,SAAS,CAACM,IAAI,CAACJ,SAAS,CAAC,EAAE;IAC3E;EACD;;EAEA;EACA;EACA,IAAIG,QAAQ,KAAK,UAAU,EAC3B;IACC;IACA;IACA;IACA,IAAIF,MAAM,GAAG,CAAC,IAAI,CAACR,kBAAkB,CAACW,IAAI,CAACJ,SAAS,CAAC,EACrD;MACC,IAAMK,YAAY,GAAGH,IAAI,CAACD,MAAM,GAAG,CAAC,CAAC;MACrC;MACA,IAAI,IAAAK,+BAA0B,EAACD,YAAY,CAAC,IAAI,IAAAE,kBAAa,EAACF,YAAY,CAAC,EAAE;QAC5E,OAAO,KAAK;MACb;IACD;IAEA,IAAMG,aAAa,GAAGP,MAAM,GAAGD,SAAS,CAACS,MAAM;IAC/C,IAAID,aAAa,GAAGN,IAAI,CAACO,MAAM,EAC/B;MACC,IAAMC,QAAQ,GAAGR,IAAI,CAACM,aAAa,CAAC;MACpC,IAAI,IAAAF,+BAA0B,EAACI,QAAQ,CAAC,IAAI,IAAAH,kBAAa,EAACG,QAAQ,CAAC,EAAE;QACpE,OAAO,KAAK;MACb;IACD;EACD;EAEA,OAAO,IAAI;AACZ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>