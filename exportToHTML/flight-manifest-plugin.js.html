<html>
<head>
<title>flight-manifest-plugin.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
flight-manifest-plugin.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Copyright (c) Facebook, Inc. and its affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/ </span><span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;ClientReferenceManifestPlugin&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">ClientReferenceManifestPlugin;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">_path = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s2">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_webpack = require(</span><span class="s2">&quot;next/dist/compiled/webpack/webpack&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_constants = require(</span><span class="s2">&quot;../../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_buildcontext = require(</span><span class="s2">&quot;../../build-context&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_constants1 = require(</span><span class="s2">&quot;../../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_normalizepagepath = require(</span><span class="s2">&quot;../../../shared/lib/page-path/normalize-page-path&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_deploymentid = require(</span><span class="s2">&quot;../../deployment-id&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_utils = require(</span><span class="s2">&quot;../utils&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_encodeuripath = require(</span><span class="s2">&quot;../../../shared/lib/encode-uri-path&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">WeakMap !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) </span><span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">cacheBabelInterop = </span><span class="s3">new </span><span class="s1">WeakMap();</span>
    <span class="s3">var </span><span class="s1">cacheNodeInterop = </span><span class="s3">new </span><span class="s1">WeakMap();</span>
    <span class="s3">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s3">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s3">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s3">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s3">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(obj === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s3">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s3">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s3">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">obj){</span>
        <span class="s3">if </span><span class="s1">(key !== </span><span class="s2">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s3">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s3">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">pluginState = (</span><span class="s4">0</span><span class="s1">, _buildcontext.getProxiedPluginState)({</span>
    <span class="s1">ssrModules: {},</span>
    <span class="s1">edgeSsrModules: {},</span>
    <span class="s1">rscModules: {},</span>
    <span class="s1">edgeRscModules: {}</span>
<span class="s1">});</span>
<span class="s3">function </span><span class="s1">getAppPathRequiredChunks(chunkGroup, excludedFiles) {</span>
    <span class="s3">const </span><span class="s1">deploymentIdChunkQuery = (</span><span class="s4">0</span><span class="s1">, _deploymentid.getDeploymentIdQueryOrEmptyString)();</span>
    <span class="s3">const </span><span class="s1">chunks = [];</span>
    <span class="s1">chunkGroup.chunks.forEach((chunk)=&gt;{</span>
        <span class="s3">if </span><span class="s1">(_constants.SYSTEM_ENTRYPOINTS.has(chunk.name || </span><span class="s2">''</span><span class="s1">)) {</span>
            <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">// Get the actual chunk file names from the chunk file list.</span>
        <span class="s3">if </span><span class="s1">(chunk.id != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">const </span><span class="s1">chunkId = </span><span class="s2">'' </span><span class="s1">+ chunk.id;</span>
            <span class="s1">chunk.files.forEach((file)=&gt;{</span>
                <span class="s0">// It's possible that a chunk also emits CSS files, that will</span>
                <span class="s0">// be handled separatedly.</span>
                <span class="s3">if </span><span class="s1">(!file.endsWith(</span><span class="s2">'.js'</span><span class="s1">)) </span><span class="s3">return null</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(file.endsWith(</span><span class="s2">'.hot-update.js'</span><span class="s1">)) </span><span class="s3">return null</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(excludedFiles.has(file)) </span><span class="s3">return null</span><span class="s1">;</span>
                <span class="s0">// We encode the file as a URI because our server (and many other services such as S3)</span>
                <span class="s0">// expect to receive reserved characters such as `[` and `]` as encoded. This was</span>
                <span class="s0">// previously done for dynamic chunks by patching the webpack runtime but we want</span>
                <span class="s0">// these filenames to be managed by React's Flight runtime instead and so we need</span>
                <span class="s0">// to implement any special handling of the file name here.</span>
                <span class="s3">return </span><span class="s1">chunks.push(chunkId, (</span><span class="s4">0</span><span class="s1">, _encodeuripath.encodeURIPath)(file) + deploymentIdChunkQuery);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">chunks;</span>
<span class="s1">}</span>
<span class="s0">// Normalize the entry names to their &quot;group names&quot; so a page can easily track</span>
<span class="s0">// all the manifest items it needs from parent groups by looking up the group</span>
<span class="s0">// segments:</span>
<span class="s0">// - app/foo/loading -&gt; app/foo</span>
<span class="s0">// - app/foo/page -&gt; app/foo</span>
<span class="s0">// - app/(group)/@named/foo/page -&gt; app/foo</span>
<span class="s0">// - app/(.)foo/(..)bar/loading -&gt; app/bar</span>
<span class="s0">// - app/[...catchAll]/page -&gt; app</span>
<span class="s0">// - app/foo/@slot/[...catchAll]/page -&gt; app/foo</span>
<span class="s3">function </span><span class="s1">entryNameToGroupName(entryName) {</span>
    <span class="s3">let </span><span class="s1">groupName = entryName.slice(</span><span class="s4">0</span><span class="s1">, entryName.lastIndexOf(</span><span class="s2">'/'</span><span class="s1">))</span><span class="s0">// Remove slots</span>
    <span class="s1">.replace(</span><span class="s5">/\/@[^/]+/g</span><span class="s1">, </span><span class="s2">''</span><span class="s1">)</span><span class="s0">// Remove the group with lookahead to make sure it's not interception route</span>
    <span class="s1">.replace(</span><span class="s5">/\/\([^/]+\)(?=(\/|$))/g</span><span class="s1">, </span><span class="s2">''</span><span class="s1">)</span><span class="s0">// Remove catch-all routes since they should be part of the parent group that the catch-all would apply to.</span>
    <span class="s0">// This is necessary to support parallel routes since multiple page components can be rendered on the same page.</span>
    <span class="s0">// In order to do that, we need to ensure that the manifests are merged together by putting them in the same group.</span>
    <span class="s1">.replace(</span><span class="s5">/\/\[?\[\.\.\.[^\]]*]]?/g</span><span class="s1">, </span><span class="s2">''</span><span class="s1">);</span>
    <span class="s0">// Interception routes</span>
    <span class="s1">groupName = groupName.replace(</span><span class="s5">/^.+\/\(\.\.\.\)/g</span><span class="s1">, </span><span class="s2">'app/'</span><span class="s1">).replace(</span><span class="s5">/\/\(\.\)/g</span><span class="s1">, </span><span class="s2">'/'</span><span class="s1">);</span>
    <span class="s0">// Interception routes (recursive)</span>
    <span class="s3">while</span><span class="s1">(</span><span class="s5">/\/[^/]+\/\(\.\.\)/</span><span class="s1">.test(groupName)){</span>
        <span class="s1">groupName = groupName.replace(</span><span class="s5">/\/[^/]+\/\(\.\.\)/g</span><span class="s1">, </span><span class="s2">'/'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">groupName;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mergeManifest(manifest, manifestToMerge) {</span>
    <span class="s1">Object.assign(manifest.clientModules, manifestToMerge.clientModules);</span>
    <span class="s1">Object.assign(manifest.ssrModuleMapping, manifestToMerge.ssrModuleMapping);</span>
    <span class="s1">Object.assign(manifest.edgeSSRModuleMapping, manifestToMerge.edgeSSRModuleMapping);</span>
    <span class="s1">Object.assign(manifest.entryCSSFiles, manifestToMerge.entryCSSFiles);</span>
    <span class="s1">Object.assign(manifest.rscModuleMapping, manifestToMerge.rscModuleMapping);</span>
    <span class="s1">Object.assign(manifest.edgeRscModuleMapping, manifestToMerge.edgeRscModuleMapping);</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">PLUGIN_NAME = </span><span class="s2">'ClientReferenceManifestPlugin'</span><span class="s1">;</span>
<span class="s3">class </span><span class="s1">ClientReferenceManifestPlugin {</span>
    <span class="s1">constructor(options){</span>
        <span class="s3">this</span><span class="s1">.dev = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">.dev = options.dev;</span>
        <span class="s3">this</span><span class="s1">.appDir = options.appDir;</span>
        <span class="s3">this</span><span class="s1">.appDirBase = _path.default.dirname(</span><span class="s3">this</span><span class="s1">.appDir) + _path.default.sep;</span>
        <span class="s3">this</span><span class="s1">.experimentalInlineCss = options.experimentalInlineCss;</span>
    <span class="s1">}</span>
    <span class="s1">apply(compiler) {</span>
        <span class="s1">compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=&gt;{</span>
            <span class="s1">compilation.hooks.processAssets.tap({</span>
                <span class="s1">name: PLUGIN_NAME,</span>
                <span class="s0">// Have to be in the optimize stage to run after updating the CSS</span>
                <span class="s0">// asset hash via extract mini css plugin.</span>
                <span class="s1">stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ANALYSE</span>
            <span class="s1">}, ()=&gt;</span><span class="s3">this</span><span class="s1">.createAsset(compilation, compiler.context));</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">createAsset(compilation, context) {</span>
        <span class="s3">var </span><span class="s1">_compilation_entrypoints_get;</span>
        <span class="s3">const </span><span class="s1">manifestsPerGroup = </span><span class="s3">new </span><span class="s1">Map();</span>
        <span class="s3">const </span><span class="s1">manifestEntryFiles = [];</span>
        <span class="s3">const </span><span class="s1">configuredCrossOriginLoading = compilation.outputOptions.crossOriginLoading;</span>
        <span class="s3">const </span><span class="s1">crossOriginMode = </span><span class="s3">typeof </span><span class="s1">configuredCrossOriginLoading === </span><span class="s2">'string' </span><span class="s1">? configuredCrossOriginLoading === </span><span class="s2">'use-credentials' </span><span class="s1">? configuredCrossOriginLoading : </span><span class="s2">'' </span><span class="s0">// === 'anonymous'</span>
         <span class="s1">: undefined;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">compilation.outputOptions.publicPath !== </span><span class="s2">'string'</span><span class="s1">) {</span>
            <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">'Expected webpack publicPath to be a string when using App Router. To customize where static assets are loaded from, use the `assetPrefix` option in next.config.js. If you are customizing your webpack config please make sure you are not modifying or removing the publicPath configuration option'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s2">&quot;E136&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s3">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">const </span><span class="s1">prefix = compilation.outputOptions.publicPath || </span><span class="s2">''</span><span class="s1">;</span>
        <span class="s0">// We want to omit any files that will always be loaded on any App Router page</span>
        <span class="s0">// because they will already be loaded by the main entrypoint.</span>
        <span class="s3">const </span><span class="s1">rootMainFiles = </span><span class="s3">new </span><span class="s1">Set();</span>
        <span class="s1">(_compilation_entrypoints_get = compilation.entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP)) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _compilation_entrypoints_get.getFiles().forEach((file)=&gt;{</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s5">/(?&lt;!\.hot-update)\.(js|css)($|\?)/</span><span class="s1">.test(file)) {</span>
                <span class="s1">rootMainFiles.add(file.replace(</span><span class="s5">/\\/g</span><span class="s1">, </span><span class="s2">'/'</span><span class="s1">));</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">[entryName, entrypoint] of compilation.entrypoints){</span>
            <span class="s3">if </span><span class="s1">(entryName === _constants.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP || entryName === _constants.APP_CLIENT_INTERNALS) {</span>
                <span class="s1">entryName = </span><span class="s2">''</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!</span><span class="s5">/^app[\\/]/</span><span class="s1">.test(entryName)) {</span>
                <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">manifest = {</span>
                <span class="s1">moduleLoading: {</span>
                    <span class="s1">prefix,</span>
                    <span class="s1">crossOrigin: crossOriginMode</span>
                <span class="s1">},</span>
                <span class="s1">ssrModuleMapping: {},</span>
                <span class="s1">edgeSSRModuleMapping: {},</span>
                <span class="s1">clientModules: {},</span>
                <span class="s1">entryCSSFiles: {},</span>
                <span class="s1">rscModuleMapping: {},</span>
                <span class="s1">edgeRscModuleMapping: {}</span>
            <span class="s1">};</span>
            <span class="s0">// Absolute path without the extension</span>
            <span class="s3">const </span><span class="s1">chunkEntryName = (</span><span class="s3">this</span><span class="s1">.appDirBase + entryName).replace(</span><span class="s5">/[\\/]/g</span><span class="s1">, _path.default.sep);</span>
            <span class="s1">manifest.entryCSSFiles[chunkEntryName] = entrypoint.getFiles().filter((f)=&gt;!f.startsWith(</span><span class="s2">'static/css/pages/'</span><span class="s1">) &amp;&amp; f.endsWith(</span><span class="s2">'.css'</span><span class="s1">)).map((file)=&gt;{</span>
                <span class="s3">const </span><span class="s1">source = compilation.getAsset(file).source.source();</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.experimentalInlineCss &amp;&amp; </span><span class="s0">// Inline CSS currently does not work properly with HMR, so we only</span>
                <span class="s0">// inline CSS in production.</span>
                <span class="s1">!</span><span class="s3">this</span><span class="s1">.dev) {</span>
                    <span class="s3">return </span><span class="s1">{</span>
                        <span class="s1">inlined: </span><span class="s3">true</span><span class="s1">,</span>
                        <span class="s1">path: file,</span>
                        <span class="s1">content: </span><span class="s3">typeof </span><span class="s1">source === </span><span class="s2">'string' </span><span class="s1">? source : source.toString()</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">{</span>
                    <span class="s1">inlined: </span><span class="s3">false</span><span class="s1">,</span>
                    <span class="s1">path: file</span>
                <span class="s1">};</span>
            <span class="s1">});</span>
            <span class="s3">const </span><span class="s1">requiredChunks = getAppPathRequiredChunks(entrypoint, rootMainFiles);</span>
            <span class="s3">const </span><span class="s1">recordModule = (modId, mod)=&gt;{</span>
                <span class="s3">var </span><span class="s1">_mod_resourceResolveData, _mod_resourceResolveData1, _mod_matchResource;</span>
                <span class="s3">let </span><span class="s1">resource = mod.type === </span><span class="s2">'css/mini-extract' </span><span class="s1">? mod.identifier().slice(mod.identifier().lastIndexOf(</span><span class="s2">'!'</span><span class="s1">) + </span><span class="s4">1</span><span class="s1">) : mod.resource;</span>
                <span class="s3">if </span><span class="s1">(!resource) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">const </span><span class="s1">moduleReferences = manifest.clientModules;</span>
                <span class="s3">const </span><span class="s1">moduleIdMapping = manifest.ssrModuleMapping;</span>
                <span class="s3">const </span><span class="s1">edgeModuleIdMapping = manifest.edgeSSRModuleMapping;</span>
                <span class="s3">const </span><span class="s1">rscIdMapping = manifest.rscModuleMapping;</span>
                <span class="s3">const </span><span class="s1">edgeRscIdMapping = manifest.edgeRscModuleMapping;</span>
                <span class="s0">// Note that this isn't that reliable as webpack is still possible to assign</span>
                <span class="s0">// additional queries to make sure there's no conflict even using the `named`</span>
                <span class="s0">// module ID strategy.</span>
                <span class="s3">let </span><span class="s1">ssrNamedModuleId = (</span><span class="s4">0</span><span class="s1">, _path.relative)(context, ((_mod_resourceResolveData = mod.resourceResolveData) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _mod_resourceResolveData.path) || resource);</span>
                <span class="s3">const </span><span class="s1">rscNamedModuleId = (</span><span class="s4">0</span><span class="s1">, _path.relative)(context, ((_mod_resourceResolveData1 = mod.resourceResolveData) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _mod_resourceResolveData1.path) || resource);</span>
                <span class="s3">if </span><span class="s1">(!ssrNamedModuleId.startsWith(</span><span class="s2">'.'</span><span class="s1">)) ssrNamedModuleId = </span><span class="s2">`./</span><span class="s1">${ssrNamedModuleId.replace(</span><span class="s5">/\\/g</span><span class="s1">, </span><span class="s2">'/'</span><span class="s1">)}</span><span class="s2">`</span><span class="s1">;</span>
                <span class="s0">// The client compiler will always use the CJS Next.js build, so here we</span>
                <span class="s0">// also add the mapping for the ESM build (Edge runtime) to consume.</span>
                <span class="s3">const </span><span class="s1">esmResource = </span><span class="s5">/[\\/]next[\\/]dist[\\/]/</span><span class="s1">.test(resource) ? resource.replace(</span><span class="s5">/[\\/]next[\\/]dist[\\/]/</span><span class="s1">, </span><span class="s2">'/next/dist/esm/'</span><span class="s1">.replace(</span><span class="s5">/\//g</span><span class="s1">, _path.default.sep)) : </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s0">// An extra query param is added to the resource key when it's optimized</span>
                <span class="s0">// through the Barrel Loader. That's because the same file might be created</span>
                <span class="s0">// as multiple modules (depending on what you import from it).</span>
                <span class="s0">// See also: webpack/loaders/next-flight-loader/index.ts.</span>
                <span class="s3">if </span><span class="s1">((_mod_matchResource = mod.matchResource) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _mod_matchResource.startsWith(_constants.BARREL_OPTIMIZATION_PREFIX)) {</span>
                    <span class="s1">ssrNamedModuleId = (</span><span class="s4">0</span><span class="s1">, _utils.formatBarrelOptimizedResource)(ssrNamedModuleId, mod.matchResource);</span>
                    <span class="s1">resource = (</span><span class="s4">0</span><span class="s1">, _utils.formatBarrelOptimizedResource)(resource, mod.matchResource);</span>
                <span class="s1">}</span>
                <span class="s3">function </span><span class="s1">addClientReference() {</span>
                    <span class="s3">var </span><span class="s1">_pluginState_ssrModules_ssrNamedModuleId, _pluginState_edgeSsrModules_ssrNamedModuleId;</span>
                    <span class="s3">const </span><span class="s1">isAsync = Boolean(compilation.moduleGraph.isAsync(mod) || ((_pluginState_ssrModules_ssrNamedModuleId = pluginState.ssrModules[ssrNamedModuleId]) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _pluginState_ssrModules_ssrNamedModuleId.async) || ((_pluginState_edgeSsrModules_ssrNamedModuleId = pluginState.edgeSsrModules[ssrNamedModuleId]) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _pluginState_edgeSsrModules_ssrNamedModuleId.async));</span>
                    <span class="s3">const </span><span class="s1">exportName = resource;</span>
                    <span class="s1">manifest.clientModules[exportName] = {</span>
                        <span class="s1">id: modId,</span>
                        <span class="s1">name: </span><span class="s2">'*'</span><span class="s1">,</span>
                        <span class="s1">chunks: requiredChunks,</span>
                        <span class="s1">async: isAsync</span>
                    <span class="s1">};</span>
                    <span class="s3">if </span><span class="s1">(esmResource) {</span>
                        <span class="s3">const </span><span class="s1">edgeExportName = esmResource;</span>
                        <span class="s1">manifest.clientModules[edgeExportName] = manifest.clientModules[exportName];</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">function </span><span class="s1">addSSRIdMapping() {</span>
                    <span class="s3">const </span><span class="s1">exportName = resource;</span>
                    <span class="s3">const </span><span class="s1">moduleInfo = pluginState.ssrModules[ssrNamedModuleId];</span>
                    <span class="s3">if </span><span class="s1">(moduleInfo) {</span>
                        <span class="s1">moduleIdMapping[modId] = moduleIdMapping[modId] || {};</span>
                        <span class="s1">moduleIdMapping[modId][</span><span class="s2">'*'</span><span class="s1">] = {</span>
                            <span class="s1">...manifest.clientModules[exportName],</span>
                            <span class="s0">// During SSR, we don't have external chunks to load on the server</span>
                            <span class="s0">// side with our architecture of Webpack / Turbopack. We can keep</span>
                            <span class="s0">// this field empty to save some bytes.</span>
                            <span class="s1">chunks: [],</span>
                            <span class="s1">id: moduleInfo.moduleId,</span>
                            <span class="s1">async: moduleInfo.async</span>
                        <span class="s1">};</span>
                    <span class="s1">}</span>
                    <span class="s3">const </span><span class="s1">edgeModuleInfo = pluginState.edgeSsrModules[ssrNamedModuleId];</span>
                    <span class="s3">if </span><span class="s1">(edgeModuleInfo) {</span>
                        <span class="s1">edgeModuleIdMapping[modId] = edgeModuleIdMapping[modId] || {};</span>
                        <span class="s1">edgeModuleIdMapping[modId][</span><span class="s2">'*'</span><span class="s1">] = {</span>
                            <span class="s1">...manifest.clientModules[exportName],</span>
                            <span class="s0">// During SSR, we don't have external chunks to load on the server</span>
                            <span class="s0">// side with our architecture of Webpack / Turbopack. We can keep</span>
                            <span class="s0">// this field empty to save some bytes.</span>
                            <span class="s1">chunks: [],</span>
                            <span class="s1">id: edgeModuleInfo.moduleId,</span>
                            <span class="s1">async: edgeModuleInfo.async</span>
                        <span class="s1">};</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">function </span><span class="s1">addRSCIdMapping() {</span>
                    <span class="s3">const </span><span class="s1">exportName = resource;</span>
                    <span class="s3">const </span><span class="s1">moduleInfo = pluginState.rscModules[rscNamedModuleId];</span>
                    <span class="s3">if </span><span class="s1">(moduleInfo) {</span>
                        <span class="s1">rscIdMapping[modId] = rscIdMapping[modId] || {};</span>
                        <span class="s1">rscIdMapping[modId][</span><span class="s2">'*'</span><span class="s1">] = {</span>
                            <span class="s1">...manifest.clientModules[exportName],</span>
                            <span class="s0">// During SSR, we don't have external chunks to load on the server</span>
                            <span class="s0">// side with our architecture of Webpack / Turbopack. We can keep</span>
                            <span class="s0">// this field empty to save some bytes.</span>
                            <span class="s1">chunks: [],</span>
                            <span class="s1">id: moduleInfo.moduleId,</span>
                            <span class="s1">async: moduleInfo.async</span>
                        <span class="s1">};</span>
                    <span class="s1">}</span>
                    <span class="s3">const </span><span class="s1">edgeModuleInfo = pluginState.ssrModules[rscNamedModuleId];</span>
                    <span class="s3">if </span><span class="s1">(edgeModuleInfo) {</span>
                        <span class="s1">edgeRscIdMapping[modId] = edgeRscIdMapping[modId] || {};</span>
                        <span class="s1">edgeRscIdMapping[modId][</span><span class="s2">'*'</span><span class="s1">] = {</span>
                            <span class="s1">...manifest.clientModules[exportName],</span>
                            <span class="s0">// During SSR, we don't have external chunks to load on the server</span>
                            <span class="s0">// side with our architecture of Webpack / Turbopack. We can keep</span>
                            <span class="s0">// this field empty to save some bytes.</span>
                            <span class="s1">chunks: [],</span>
                            <span class="s1">id: edgeModuleInfo.moduleId,</span>
                            <span class="s1">async: edgeModuleInfo.async</span>
                        <span class="s1">};</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">addClientReference();</span>
                <span class="s1">addSSRIdMapping();</span>
                <span class="s1">addRSCIdMapping();</span>
                <span class="s1">manifest.clientModules = moduleReferences;</span>
                <span class="s1">manifest.ssrModuleMapping = moduleIdMapping;</span>
                <span class="s1">manifest.edgeSSRModuleMapping = edgeModuleIdMapping;</span>
                <span class="s1">manifest.rscModuleMapping = rscIdMapping;</span>
                <span class="s1">manifest.edgeRscModuleMapping = edgeRscIdMapping;</span>
            <span class="s1">};</span>
            <span class="s3">const </span><span class="s1">checkedChunkGroups = </span><span class="s3">new </span><span class="s1">Set();</span>
            <span class="s3">const </span><span class="s1">checkedChunks = </span><span class="s3">new </span><span class="s1">Set();</span>
            <span class="s3">function </span><span class="s1">recordChunkGroup(chunkGroup) {</span>
                <span class="s0">// Ensure recursion is stopped if we've already checked this chunk group.</span>
                <span class="s3">if </span><span class="s1">(checkedChunkGroups.has(chunkGroup)) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s1">checkedChunkGroups.add(chunkGroup);</span>
                <span class="s0">// Only apply following logic to client module requests from client entry,</span>
                <span class="s0">// or if the module is marked as client module. That's because other</span>
                <span class="s0">// client modules don't need to be in the manifest at all as they're</span>
                <span class="s0">// never be referenced by the server/client boundary.</span>
                <span class="s0">// This saves a lot of bytes in the manifest.</span>
                <span class="s1">chunkGroup.chunks.forEach((chunk)=&gt;{</span>
                    <span class="s0">// Ensure recursion is stopped if we've already checked this chunk.</span>
                    <span class="s3">if </span><span class="s1">(checkedChunks.has(chunk)) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">checkedChunks.add(chunk);</span>
                    <span class="s3">const </span><span class="s1">entryMods = compilation.chunkGraph.getChunkEntryModulesIterable(chunk);</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">mod of entryMods){</span>
                        <span class="s3">if </span><span class="s1">(mod.layer !== _constants1.WEBPACK_LAYERS.appPagesBrowser) </span><span class="s3">continue</span><span class="s1">;</span>
                        <span class="s3">const </span><span class="s1">request = mod.request;</span>
                        <span class="s3">if </span><span class="s1">(!request || !request.includes(</span><span class="s2">'next-flight-client-entry-loader.js?'</span><span class="s1">)) {</span>
                            <span class="s3">continue</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s3">const </span><span class="s1">connections = (</span><span class="s4">0</span><span class="s1">, _utils.getModuleReferencesInOrder)(mod, compilation.moduleGraph);</span>
                        <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">connection of connections){</span>
                            <span class="s3">const </span><span class="s1">dependency = connection.dependency;</span>
                            <span class="s3">if </span><span class="s1">(!dependency) </span><span class="s3">continue</span><span class="s1">;</span>
                            <span class="s3">const </span><span class="s1">clientEntryMod = compilation.moduleGraph.getResolvedModule(dependency);</span>
                            <span class="s3">const </span><span class="s1">modId = compilation.chunkGraph.getModuleId(clientEntryMod);</span>
                            <span class="s3">if </span><span class="s1">(modId !== </span><span class="s3">null</span><span class="s1">) {</span>
                                <span class="s1">recordModule(modId, clientEntryMod);</span>
                            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                                <span class="s3">var </span><span class="s1">_connection_module;</span>
                                <span class="s0">// If this is a concatenation, register each child to the parent ID.</span>
                                <span class="s3">if </span><span class="s1">(((_connection_module = connection.module) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _connection_module.constructor.name) === </span><span class="s2">'ConcatenatedModule'</span><span class="s1">) {</span>
                                    <span class="s3">const </span><span class="s1">concatenatedMod = connection.module;</span>
                                    <span class="s3">const </span><span class="s1">concatenatedModId = compilation.chunkGraph.getModuleId(concatenatedMod);</span>
                                    <span class="s3">if </span><span class="s1">(concatenatedModId) {</span>
                                        <span class="s1">recordModule(concatenatedModId, clientEntryMod);</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s0">// Walk through all children chunk groups too.</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">child of chunkGroup.childrenIterable){</span>
                    <span class="s1">recordChunkGroup(child);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">recordChunkGroup(entrypoint);</span>
            <span class="s0">// A page's entry name can have extensions. For example, these are both valid:</span>
            <span class="s0">// - app/foo/page</span>
            <span class="s0">// - app/foo/page.page</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s5">/\/page(\.[^/]+)?$/</span><span class="s1">.test(entryName)) {</span>
                <span class="s1">manifestEntryFiles.push(entryName.replace(</span><span class="s5">/\/page(\.[^/]+)?$/</span><span class="s1">, </span><span class="s2">'/page'</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">// We also need to create manifests for route handler entrypoints to</span>
            <span class="s0">// enable `'use cache'`.</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s5">/\/route$/</span><span class="s1">.test(entryName)) {</span>
                <span class="s1">manifestEntryFiles.push(entryName);</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">groupName = entryNameToGroupName(entryName);</span>
            <span class="s3">if </span><span class="s1">(!manifestsPerGroup.has(groupName)) {</span>
                <span class="s1">manifestsPerGroup.set(groupName, []);</span>
            <span class="s1">}</span>
            <span class="s1">manifestsPerGroup.get(groupName).push(manifest);</span>
        <span class="s1">}</span>
        <span class="s0">// Generate per-page manifests.</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">pageName of manifestEntryFiles){</span>
            <span class="s3">const </span><span class="s1">mergedManifest = {</span>
                <span class="s1">moduleLoading: {</span>
                    <span class="s1">prefix,</span>
                    <span class="s1">crossOrigin: crossOriginMode</span>
                <span class="s1">},</span>
                <span class="s1">ssrModuleMapping: {},</span>
                <span class="s1">edgeSSRModuleMapping: {},</span>
                <span class="s1">clientModules: {},</span>
                <span class="s1">entryCSSFiles: {},</span>
                <span class="s1">rscModuleMapping: {},</span>
                <span class="s1">edgeRscModuleMapping: {}</span>
            <span class="s1">};</span>
            <span class="s3">const </span><span class="s1">segments = [</span>
                <span class="s1">...entryNameToGroupName(pageName).split(</span><span class="s2">'/'</span><span class="s1">),</span>
                <span class="s2">'page'</span>
            <span class="s1">];</span>
            <span class="s3">let </span><span class="s1">group = </span><span class="s2">''</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">segment of segments){</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">manifest of manifestsPerGroup.get(group) || []){</span>
                    <span class="s1">mergeManifest(mergedManifest, manifest);</span>
                <span class="s1">}</span>
                <span class="s1">group += (group ? </span><span class="s2">'/' </span><span class="s1">: </span><span class="s2">''</span><span class="s1">) + segment;</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">json = JSON.stringify(mergedManifest);</span>
            <span class="s3">const </span><span class="s1">pagePath = pageName.replace(</span><span class="s5">/%5F/g</span><span class="s1">, </span><span class="s2">'_'</span><span class="s1">);</span>
            <span class="s3">const </span><span class="s1">pageBundlePath = (</span><span class="s4">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(pagePath.slice(</span><span class="s2">'app'</span><span class="s1">.length));</span>
            <span class="s1">compilation.emitAsset(</span><span class="s2">'server/app' </span><span class="s1">+ pageBundlePath + </span><span class="s2">'_' </span><span class="s1">+ _constants.CLIENT_REFERENCE_MANIFEST + </span><span class="s2">'.js'</span><span class="s1">, </span><span class="s3">new </span><span class="s1">_webpack.sources.RawSource(</span><span class="s2">`globalThis.__RSC_MANIFEST=(globalThis.__RSC_MANIFEST||{});globalThis.__RSC_MANIFEST[</span><span class="s1">${JSON.stringify(pagePath.slice(</span><span class="s2">'app'</span><span class="s1">.length))}</span><span class="s2">]=</span><span class="s1">${json}</span><span class="s2">`</span><span class="s1">));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">//# sourceMappingURL=flight-manifest-plugin.js.map</span></pre>
</body>
</html>