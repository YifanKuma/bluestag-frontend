<html>
<head>
<title>dedupe-fetch.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dedupe-fetch.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/lib/dedupe-fetch.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Based on https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">import * as React from 'react'</span><span class="s3">\n</span><span class="s1">import { cloneResponse } from './clone-response'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">const simpleCacheKey = '[</span><span class="s3">\&quot;</span><span class="s1">GET</span><span class="s3">\&quot;</span><span class="s1">,[],null,</span><span class="s3">\&quot;</span><span class="s1">follow</span><span class="s3">\&quot;</span><span class="s1">,null,null,null,null]' // generateCacheKey(new Request('https://blank'));</span><span class="s3">\n\n</span><span class="s1">function generateCacheKey(request: Request): string {</span><span class="s3">\n  </span><span class="s1">// We pick the fields that goes into the key used to dedupe requests.</span><span class="s3">\n  </span><span class="s1">// We don't include the `cache` field, because we end up using whatever</span><span class="s3">\n  </span><span class="s1">// caching resulted from the first request.</span><span class="s3">\n  </span><span class="s1">// Notably we currently don't consider non-standard (or future) options.</span><span class="s3">\n  </span><span class="s1">// This might not be safe. TODO: warn for non-standard extensions differing.</span><span class="s3">\n  </span><span class="s1">// IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.</span><span class="s3">\n  </span><span class="s1">return JSON.stringify([</span><span class="s3">\n    </span><span class="s1">request.method,</span><span class="s3">\n    </span><span class="s1">Array.from(request.headers.entries()),</span><span class="s3">\n    </span><span class="s1">request.mode,</span><span class="s3">\n    </span><span class="s1">request.redirect,</span><span class="s3">\n    </span><span class="s1">request.credentials,</span><span class="s3">\n    </span><span class="s1">request.referrer,</span><span class="s3">\n    </span><span class="s1">request.referrerPolicy,</span><span class="s3">\n    </span><span class="s1">request.integrity,</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type CacheEntry = [</span><span class="s3">\n  </span><span class="s1">key: string,</span><span class="s3">\n  </span><span class="s1">promise: Promise&lt;Response&gt;,</span><span class="s3">\n  </span><span class="s1">response: Response | null,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export function createDedupeFetch(originalFetch: typeof fetch) {</span><span class="s3">\n  </span><span class="s1">const getCacheEntries = React.cache(</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars -- url is the cache key</span><span class="s3">\n    </span><span class="s1">(url: string): CacheEntry[] =&gt; []</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return function dedupeFetch(</span><span class="s3">\n    </span><span class="s1">resource: URL | RequestInfo,</span><span class="s3">\n    </span><span class="s1">options?: RequestInit</span><span class="s3">\n  </span><span class="s1">): Promise&lt;Response&gt; {</span><span class="s3">\n    </span><span class="s1">if (options &amp;&amp; options.signal) {</span><span class="s3">\n      </span><span class="s1">// If we're passed a signal, then we assume that</span><span class="s3">\n      </span><span class="s1">// someone else controls the lifetime of this object and opts out of</span><span class="s3">\n      </span><span class="s1">// caching. It's effectively the opt-out mechanism.</span><span class="s3">\n      </span><span class="s1">// Ideally we should be able to check this on the Request but</span><span class="s3">\n      </span><span class="s1">// it always gets initialized with its own signal so we don't</span><span class="s3">\n      </span><span class="s1">// know if it's supposed to override - unless we also override the</span><span class="s3">\n      </span><span class="s1">// Request constructor.</span><span class="s3">\n      </span><span class="s1">return originalFetch(resource, options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Normalize the Request</span><span class="s3">\n    </span><span class="s1">let url: string</span><span class="s3">\n    </span><span class="s1">let cacheKey: string</span><span class="s3">\n    </span><span class="s1">if (typeof resource === 'string' &amp;&amp; !options) {</span><span class="s3">\n      </span><span class="s1">// Fast path.</span><span class="s3">\n      </span><span class="s1">cacheKey = simpleCacheKey</span><span class="s3">\n      </span><span class="s1">url = resource</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Normalize the request.</span><span class="s3">\n      </span><span class="s1">// if resource is not a string or a URL (its an instance of Request)</span><span class="s3">\n      </span><span class="s1">// then do not instantiate a new Request but instead</span><span class="s3">\n      </span><span class="s1">// reuse the request as to not disturb the body in the event it's a ReadableStream.</span><span class="s3">\n      </span><span class="s1">const request =</span><span class="s3">\n        </span><span class="s1">typeof resource === 'string' || resource instanceof URL</span><span class="s3">\n          </span><span class="s1">? new Request(resource, options)</span><span class="s3">\n          </span><span class="s1">: resource</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(request.method !== 'GET' &amp;&amp; request.method !== 'HEAD') ||</span><span class="s3">\n        </span><span class="s1">request.keepalive</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// We currently don't dedupe requests that might have side-effects. Those</span><span class="s3">\n        </span><span class="s1">// have to be explicitly cached. We assume that the request doesn't have a</span><span class="s3">\n        </span><span class="s1">// body if it's GET or HEAD.</span><span class="s3">\n        </span><span class="s1">// keepalive gets treated the same as if you passed a custom cache signal.</span><span class="s3">\n        </span><span class="s1">return originalFetch(resource, options)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">cacheKey = generateCacheKey(request)</span><span class="s3">\n      </span><span class="s1">url = request.url</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const cacheEntries = getCacheEntries(url)</span><span class="s3">\n    </span><span class="s1">for (let i = 0, j = cacheEntries.length; i &lt; j; i += 1) {</span><span class="s3">\n      </span><span class="s1">const [key, promise] = cacheEntries[i]</span><span class="s3">\n      </span><span class="s1">if (key === cacheKey) {</span><span class="s3">\n        </span><span class="s1">return promise.then(() =&gt; {</span><span class="s3">\n          </span><span class="s1">const response = cacheEntries[i][2]</span><span class="s3">\n          </span><span class="s1">if (!response) throw new InvariantError('No cached response')</span><span class="s3">\n\n          </span><span class="s1">// We're cloning the response using this utility because there exists</span><span class="s3">\n          </span><span class="s1">// a bug in the undici library around response cloning. See the</span><span class="s3">\n          </span><span class="s1">// following pull request for more details:</span><span class="s3">\n          </span><span class="s1">// https://github.com/vercel/next.js/pull/73274</span><span class="s3">\n          </span><span class="s1">const [cloned1, cloned2] = cloneResponse(response)</span><span class="s3">\n          </span><span class="s1">cacheEntries[i][2] = cloned2</span><span class="s3">\n          </span><span class="s1">return cloned1</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We pass the original arguments here in case normalizing the Request</span><span class="s3">\n    </span><span class="s1">// doesn't include all the options in this environment.</span><span class="s3">\n    </span><span class="s1">const promise = originalFetch(resource, options)</span><span class="s3">\n    </span><span class="s1">const entry: CacheEntry = [cacheKey, promise, null]</span><span class="s3">\n    </span><span class="s1">cacheEntries.push(entry)</span><span class="s3">\n\n    </span><span class="s1">return promise.then((response) =&gt; {</span><span class="s3">\n      </span><span class="s1">// We're cloning the response using this utility because there exists</span><span class="s3">\n      </span><span class="s1">// a bug in the undici library around response cloning. See the</span><span class="s3">\n      </span><span class="s1">// following pull request for more details:</span><span class="s3">\n      </span><span class="s1">// https://github.com/vercel/next.js/pull/73274</span><span class="s3">\n      </span><span class="s1">const [cloned1, cloned2] = cloneResponse(response)</span><span class="s3">\n      </span><span class="s1">entry[2] = cloned2</span><span class="s3">\n      </span><span class="s1">return cloned1</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createDedupeFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;simpleCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;credentials&quot;</span><span class="s0">,</span><span class="s1">&quot;referrer&quot;</span><span class="s0">,</span><span class="s1">&quot;referrerPolicy&quot;</span><span class="s0">,</span><span class="s1">&quot;integrity&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;dedupeFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;resource&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;Request&quot;</span><span class="s0">,</span><span class="s1">&quot;keepalive&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;cloned1&quot;</span><span class="s0">,</span><span class="s1">&quot;cloned2&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>