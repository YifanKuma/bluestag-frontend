<html>
<head>
<title>route-module.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
route-module.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;RouteModule&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">RouteModule;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_url = require(</span><span class="s0">&quot;../../lib/url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizelocalepath = require(</span><span class="s0">&quot;../../shared/lib/i18n/normalize-locale-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../../shared/lib/router/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removepathprefix = require(</span><span class="s0">&quot;../../shared/lib/router/utils/remove-path-prefix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_serverutils = require(</span><span class="s0">&quot;../server-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_detectdomainlocale = require(</span><span class="s0">&quot;../../shared/lib/i18n/detect-domain-locale&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_gethostname = require(</span><span class="s0">&quot;../../shared/lib/get-hostname&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apiutils = require(</span><span class="s0">&quot;../api-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizedatapath = require(</span><span class="s0">&quot;../../shared/lib/page-path/normalize-data-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pathhasprefix = require(</span><span class="s0">&quot;../../shared/lib/router/utils/path-has-prefix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requestmeta = require(</span><span class="s0">&quot;../request-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepagepath = require(</span><span class="s0">&quot;../../shared/lib/page-path/normalize-page-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ismetadataroute = require(</span><span class="s0">&quot;../../lib/metadata/is-metadata-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_incrementalcache = require(</span><span class="s0">&quot;../lib/incremental-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_handlers = require(</span><span class="s0">&quot;../use-cache/handlers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_interopdefault = require(</span><span class="s0">&quot;../app-render/interop-default&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_responsecache = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../response-cache&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerservercontext = require(</span><span class="s0">&quot;../lib/router-utils/router-server-context&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_decodepathparams = require(</span><span class="s0">&quot;../lib/router-utils/decode-path-params&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removetrailingslash = require(</span><span class="s0">&quot;../../shared/lib/router/utils/remove-trailing-slash&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_generateinterceptionroutesrewrites = require(</span><span class="s0">&quot;../../lib/generate-interception-routes-rewrites&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">dynamicImportEsmDefault = (id)=&gt;</span><span class="s2">import</span><span class="s1">(</span><span class="s3">/* webpackIgnore: true */ /* turbopackIgnore: true */ </span><span class="s1">id).then((mod)=&gt;mod.default || mod);</span>
<span class="s2">class </span><span class="s1">RouteModule {</span>
    <span class="s1">constructor({ userland, definition, distDir, relativeProjectDir }){</span>
        <span class="s2">this</span><span class="s1">.userland = userland;</span>
        <span class="s2">this</span><span class="s1">.definition = definition;</span>
        <span class="s2">this</span><span class="s1">.isDev = process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.distDir = distDir;</span>
        <span class="s2">this</span><span class="s1">.relativeProjectDir = relativeProjectDir;</span>
    <span class="s1">}</span>
    <span class="s1">async instrumentationOnRequestError(req, ...args) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_RUNTIME === </span><span class="s0">'edge'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">{ getEdgeInstrumentationModule } = </span><span class="s2">await import</span><span class="s1">(</span><span class="s0">'../web/globals'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">instrumentation = </span><span class="s2">await </span><span class="s1">getEdgeInstrumentationModule();</span>
            <span class="s2">if </span><span class="s1">(instrumentation) {</span>
                <span class="s2">await </span><span class="s1">(instrumentation.onRequestError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: instrumentation.onRequestError.call(instrumentation, ...args));</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">{ join } = require(</span><span class="s0">'node:path'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">absoluteProjectDir = join(process.cwd(), (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'relativeProjectDir'</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.relativeProjectDir);</span>
            <span class="s2">const </span><span class="s1">{ instrumentationOnRequestError } = </span><span class="s2">await import</span><span class="s1">(</span><span class="s0">'../lib/router-utils/instrumentation-globals.external.js'</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">instrumentationOnRequestError(absoluteProjectDir, </span><span class="s2">this</span><span class="s1">.distDir, ...args);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">loadManifests(srcPage, projectDir) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_RUNTIME === </span><span class="s0">'edge'</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">_self___RSC_MANIFEST;</span>
            <span class="s2">const </span><span class="s1">{ getEdgePreviewProps } = require(</span><span class="s0">'../web/get-edge-preview-props'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">maybeJSONParse = (str)=&gt;str ? JSON.parse(str) : undefined;</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">buildId: process.env.__NEXT_BUILD_ID || </span><span class="s0">''</span><span class="s1">,</span>
                <span class="s1">buildManifest: self.__BUILD_MANIFEST,</span>
                <span class="s1">fallbackBuildManifest: {},</span>
                <span class="s1">reactLoadableManifest: maybeJSONParse(self.__REACT_LOADABLE_MANIFEST),</span>
                <span class="s1">nextFontManifest: maybeJSONParse(self.__NEXT_FONT_MANIFEST),</span>
                <span class="s1">prerenderManifest: {</span>
                    <span class="s1">routes: {},</span>
                    <span class="s1">dynamicRoutes: {},</span>
                    <span class="s1">notFoundRoutes: [],</span>
                    <span class="s1">version: </span><span class="s4">4</span><span class="s1">,</span>
                    <span class="s1">preview: getEdgePreviewProps()</span>
                <span class="s1">},</span>
                <span class="s1">routesManifest: {</span>
                    <span class="s1">version: </span><span class="s4">4</span><span class="s1">,</span>
                    <span class="s1">caseSensitive: Boolean(process.env.__NEXT_CASE_SENSITIVE_ROUTES),</span>
                    <span class="s1">basePath: process.env.__NEXT_BASE_PATH || </span><span class="s0">''</span><span class="s1">,</span>
                    <span class="s1">rewrites: process.env.__NEXT_REWRITES || {</span>
                        <span class="s1">beforeFiles: [],</span>
                        <span class="s1">afterFiles: [],</span>
                        <span class="s1">fallback: []</span>
                    <span class="s1">},</span>
                    <span class="s1">redirects: [],</span>
                    <span class="s1">headers: [],</span>
                    <span class="s1">i18n: process.env.__NEXT_I18N_CONFIG || undefined,</span>
                    <span class="s1">skipMiddlewareUrlNormalize: Boolean(process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE)</span>
                <span class="s1">},</span>
                <span class="s1">serverFilesManifest: {</span>
                    <span class="s1">config: globalThis.nextConfig || {}</span>
                <span class="s1">},</span>
                <span class="s1">clientReferenceManifest: (_self___RSC_MANIFEST = self.__RSC_MANIFEST) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _self___RSC_MANIFEST[srcPage],</span>
                <span class="s1">serverActionsManifest: maybeJSONParse(self.__RSC_SERVER_MANIFEST),</span>
                <span class="s1">subresourceIntegrityManifest: maybeJSONParse(self.__SUBRESOURCE_INTEGRITY_MANIFEST),</span>
                <span class="s1">dynamicCssManifest: maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST),</span>
                <span class="s1">interceptionRoutePatterns: (maybeJSONParse(self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST) ?? []).map((rewrite)=&gt;</span><span class="s2">new </span><span class="s1">RegExp(rewrite.regex))</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s1">_clientReferenceManifest___RSC_MANIFEST;</span>
            <span class="s2">if </span><span class="s1">(!projectDir) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: projectDir is required for node runtime'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E718&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ loadManifestFromRelativePath } = require(</span><span class="s0">'../load-manifest.external'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">normalizedPagePath = (</span><span class="s4">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(srcPage);</span>
            <span class="s2">const </span><span class="s1">[routesManifest, prerenderManifest, buildManifest, fallbackBuildManifest, reactLoadableManifest, nextFontManifest, clientReferenceManifest, serverActionsManifest, subresourceIntegrityManifest, serverFilesManifest, buildId, dynamicCssManifest] = [</span>
                <span class="s1">loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: _constants.ROUTES_MANIFEST,</span>
                    <span class="s1">shouldCache: !</span><span class="s2">this</span><span class="s1">.isDev</span>
                <span class="s1">}),</span>
                <span class="s1">loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: _constants.PRERENDER_MANIFEST,</span>
                    <span class="s1">shouldCache: !</span><span class="s2">this</span><span class="s1">.isDev</span>
                <span class="s1">}),</span>
                <span class="s1">loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: _constants.BUILD_MANIFEST,</span>
                    <span class="s1">shouldCache: !</span><span class="s2">this</span><span class="s1">.isDev</span>
                <span class="s1">}),</span>
                <span class="s1">srcPage === </span><span class="s0">'/_error' </span><span class="s1">? loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: </span><span class="s0">`fallback-</span><span class="s1">${_constants.BUILD_MANIFEST}</span><span class="s0">`</span><span class="s1">,</span>
                    <span class="s1">shouldCache: !</span><span class="s2">this</span><span class="s1">.isDev,</span>
                    <span class="s1">handleMissing: </span><span class="s2">true</span>
                <span class="s1">}) : {},</span>
                <span class="s1">loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: process.env.TURBOPACK ? </span><span class="s0">`server/</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.isAppRouter ? </span><span class="s0">'app' </span><span class="s1">: </span><span class="s0">'pages'</span><span class="s1">}${normalizedPagePath}</span><span class="s0">/</span><span class="s1">${_constants.REACT_LOADABLE_MANIFEST}</span><span class="s0">` </span><span class="s1">: _constants.REACT_LOADABLE_MANIFEST,</span>
                    <span class="s1">handleMissing: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">shouldCache: !</span><span class="s2">this</span><span class="s1">.isDev</span>
                <span class="s1">}),</span>
                <span class="s1">loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: </span><span class="s0">`server/</span><span class="s1">${_constants.NEXT_FONT_MANIFEST}</span><span class="s0">.json`</span><span class="s1">,</span>
                    <span class="s1">shouldCache: !</span><span class="s2">this</span><span class="s1">.isDev</span>
                <span class="s1">}),</span>
                <span class="s2">this</span><span class="s1">.isAppRouter &amp;&amp; !(</span><span class="s4">0</span><span class="s1">, _ismetadataroute.isStaticMetadataRoute)(srcPage) ? loadManifestFromRelativePath({</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">useEval: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">handleMissing: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">manifest: </span><span class="s0">`server/app</span><span class="s1">${srcPage.replace(</span><span class="s5">/%5F/g</span><span class="s1">, </span><span class="s0">'_'</span><span class="s1">) + </span><span class="s0">'_' </span><span class="s1">+ _constants.CLIENT_REFERENCE_MANIFEST}</span><span class="s0">.js`</span><span class="s1">,</span>
                    <span class="s1">shouldCache: !</span><span class="s2">this</span><span class="s1">.isDev</span>
                <span class="s1">}) : undefined,</span>
                <span class="s2">this</span><span class="s1">.isAppRouter ? loadManifestFromRelativePath({</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">manifest: </span><span class="s0">`server/</span><span class="s1">${_constants.SERVER_REFERENCE_MANIFEST}</span><span class="s0">.json`</span><span class="s1">,</span>
                    <span class="s1">handleMissing: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">shouldCache: !</span><span class="s2">this</span><span class="s1">.isDev</span>
                <span class="s1">}) : {},</span>
                <span class="s1">loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: </span><span class="s0">`server/</span><span class="s1">${_constants.SUBRESOURCE_INTEGRITY_MANIFEST}</span><span class="s0">.json`</span><span class="s1">,</span>
                    <span class="s1">handleMissing: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">shouldCache: !</span><span class="s2">this</span><span class="s1">.isDev</span>
                <span class="s1">}),</span>
                <span class="s2">this</span><span class="s1">.isDev ? {} : loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: _constants.SERVER_FILES_MANIFEST</span>
                <span class="s1">}),</span>
                <span class="s2">this</span><span class="s1">.isDev ? </span><span class="s0">'development' </span><span class="s1">: loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: _constants.BUILD_ID_FILE,</span>
                    <span class="s1">skipParse: </span><span class="s2">true</span>
                <span class="s1">}),</span>
                <span class="s1">loadManifestFromRelativePath({</span>
                    <span class="s1">projectDir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">manifest: _constants.DYNAMIC_CSS_MANIFEST,</span>
                    <span class="s1">handleMissing: </span><span class="s2">true</span>
                <span class="s1">})</span>
            <span class="s1">];</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">buildId,</span>
                <span class="s1">buildManifest,</span>
                <span class="s1">fallbackBuildManifest,</span>
                <span class="s1">routesManifest,</span>
                <span class="s1">nextFontManifest,</span>
                <span class="s1">prerenderManifest,</span>
                <span class="s1">serverFilesManifest,</span>
                <span class="s1">reactLoadableManifest,</span>
                <span class="s1">clientReferenceManifest: clientReferenceManifest == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_clientReferenceManifest___RSC_MANIFEST = clientReferenceManifest.__RSC_MANIFEST) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _clientReferenceManifest___RSC_MANIFEST[srcPage.replace(</span><span class="s5">/%5F/g</span><span class="s1">, </span><span class="s0">'_'</span><span class="s1">)],</span>
                <span class="s1">serverActionsManifest,</span>
                <span class="s1">subresourceIntegrityManifest,</span>
                <span class="s1">dynamicCssManifest,</span>
                <span class="s1">interceptionRoutePatterns: routesManifest.rewrites.beforeFiles.filter(_generateinterceptionroutesrewrites.isInterceptionRouteRewrite).map((rewrite)=&gt;</span><span class="s2">new </span><span class="s1">RegExp(rewrite.regex))</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async loadCustomCacheHandlers(req, nextConfig) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_RUNTIME !== </span><span class="s0">'edge'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">{ cacheHandlers } = nextConfig.experimental;</span>
            <span class="s2">if </span><span class="s1">(!cacheHandlers) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s3">// If we've already initialized the cache handlers interface, don't do it</span>
            <span class="s3">// again.</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">, _handlers.initializeCacheHandlers)()) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[kind, handler] of Object.entries(cacheHandlers)){</span>
                <span class="s2">if </span><span class="s1">(!handler) </span><span class="s2">continue</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">{ formatDynamicImportPath } = require(</span><span class="s0">'../../lib/format-dynamic-import-path'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">{ join } = require(</span><span class="s0">'node:path'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">absoluteProjectDir = join(process.cwd(), (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'relativeProjectDir'</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.relativeProjectDir);</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _handlers.setCacheHandler)(kind, (</span><span class="s4">0</span><span class="s1">, _interopdefault.interopDefault)(</span><span class="s2">await </span><span class="s1">dynamicImportEsmDefault(formatDynamicImportPath(</span><span class="s0">`</span><span class="s1">${absoluteProjectDir}</span><span class="s0">/</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.distDir}</span><span class="s0">`</span><span class="s1">, handler))));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async getIncrementalCache(req, nextConfig, prerenderManifest) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_RUNTIME === </span><span class="s0">'edge'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">globalThis.__incrementalCache;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">let </span><span class="s1">CacheHandler;</span>
            <span class="s2">const </span><span class="s1">{ cacheHandler } = nextConfig;</span>
            <span class="s2">if </span><span class="s1">(cacheHandler) {</span>
                <span class="s2">const </span><span class="s1">{ formatDynamicImportPath } = require(</span><span class="s0">'../../lib/format-dynamic-import-path'</span><span class="s1">);</span>
                <span class="s1">CacheHandler = (</span><span class="s4">0</span><span class="s1">, _interopdefault.interopDefault)(</span><span class="s2">await </span><span class="s1">dynamicImportEsmDefault(formatDynamicImportPath(</span><span class="s2">this</span><span class="s1">.distDir, cacheHandler)));</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ join } = require(</span><span class="s0">'node:path'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">projectDir = join(process.cwd(), (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'relativeProjectDir'</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.relativeProjectDir);</span>
            <span class="s2">await this</span><span class="s1">.loadCustomCacheHandlers(req, nextConfig);</span>
            <span class="s3">// incremental-cache is request specific</span>
            <span class="s3">// although can have shared caches in module scope</span>
            <span class="s3">// per-cache handler</span>
            <span class="s2">return new </span><span class="s1">_incrementalcache.IncrementalCache({</span>
                <span class="s1">fs: require(</span><span class="s0">'../lib/node-fs-methods'</span><span class="s1">).nodeFs,</span>
                <span class="s1">dev: </span><span class="s2">this</span><span class="s1">.isDev,</span>
                <span class="s1">requestHeaders: req.headers,</span>
                <span class="s1">allowedRevalidateHeaderKeys: nextConfig.experimental.allowedRevalidateHeaderKeys,</span>
                <span class="s1">minimalMode: (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'minimalMode'</span><span class="s1">),</span>
                <span class="s1">serverDistDir: </span><span class="s0">`</span><span class="s1">${projectDir}</span><span class="s0">/</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.distDir}</span><span class="s0">/server`</span><span class="s1">,</span>
                <span class="s1">fetchCacheKeyPrefix: nextConfig.experimental.fetchCacheKeyPrefix,</span>
                <span class="s1">maxMemoryCacheSize: nextConfig.cacheMaxMemorySize,</span>
                <span class="s1">flushToDisk: nextConfig.experimental.isrFlushToDisk,</span>
                <span class="s1">getPrerenderManifest: ()=&gt;prerenderManifest,</span>
                <span class="s1">CurCacheHandler: CacheHandler</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async onRequestError(req, err, errorContext, routerServerContext) {</span>
        <span class="s2">if </span><span class="s1">(routerServerContext == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: routerServerContext.logErrorWithOriginalStack) {</span>
            <span class="s1">routerServerContext.logErrorWithOriginalStack(err, </span><span class="s0">'app-dir'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">console.error(err);</span>
        <span class="s1">}</span>
        <span class="s2">await this</span><span class="s1">.instrumentationOnRequestError(req, err, {</span>
            <span class="s1">path: req.url || </span><span class="s0">'/'</span><span class="s1">,</span>
            <span class="s1">headers: req.headers,</span>
            <span class="s1">method: req.method || </span><span class="s0">'GET'</span>
        <span class="s1">}, errorContext);</span>
    <span class="s1">}</span>
    <span class="s1">async prepare(req, res, { srcPage, multiZoneDraftMode }) {</span>
        <span class="s2">var </span><span class="s1">_routerServerGlobal_RouterServerContextSymbol;</span>
        <span class="s2">let </span><span class="s1">absoluteProjectDir;</span>
        <span class="s3">// edge runtime handles loading instrumentation at the edge adapter level</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_RUNTIME !== </span><span class="s0">'edge'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">{ join, relative } = require(</span><span class="s0">'node:path'</span><span class="s1">);</span>
            <span class="s1">absoluteProjectDir = join(process.cwd(), (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'relativeProjectDir'</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.relativeProjectDir);</span>
            <span class="s2">const </span><span class="s1">absoluteDistDir = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'distDir'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(absoluteDistDir) {</span>
                <span class="s2">this</span><span class="s1">.distDir = relative(absoluteProjectDir, absoluteDistDir);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ ensureInstrumentationRegistered } = </span><span class="s2">await import</span><span class="s1">(</span><span class="s0">'../lib/router-utils/instrumentation-globals.external.js'</span><span class="s1">);</span>
            <span class="s3">// ensure instrumentation is registered and pass</span>
            <span class="s3">// onRequestError below</span>
            <span class="s1">ensureInstrumentationRegistered(absoluteProjectDir, </span><span class="s2">this</span><span class="s1">.distDir);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">manifests = </span><span class="s2">await this</span><span class="s1">.loadManifests(srcPage, absoluteProjectDir);</span>
        <span class="s2">const </span><span class="s1">{ routesManifest, prerenderManifest, serverFilesManifest } = manifests;</span>
        <span class="s2">const </span><span class="s1">{ basePath, i18n, rewrites } = routesManifest;</span>
        <span class="s2">if </span><span class="s1">(basePath) {</span>
            <span class="s1">req.url = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(req.url || </span><span class="s0">'/'</span><span class="s1">, basePath);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">parsedUrl = (</span><span class="s4">0</span><span class="s1">, _url.parseReqUrl)(req.url || </span><span class="s0">'/'</span><span class="s1">);</span>
        <span class="s3">// if we couldn't parse the URL we can't continue</span>
        <span class="s2">if </span><span class="s1">(!parsedUrl) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">isNextDataRequest = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _pathhasprefix.pathHasPrefix)(parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">, </span><span class="s0">'/_next/data'</span><span class="s1">)) {</span>
            <span class="s1">isNextDataRequest = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">parsedUrl.pathname = (</span><span class="s4">0</span><span class="s1">, _normalizedatapath.normalizeDataPath)(parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">originalPathname = parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">originalQuery = {</span>
            <span class="s1">...parsedUrl.query</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">pageIsDynamic = (</span><span class="s4">0</span><span class="s1">, _utils.isDynamicRoute)(srcPage);</span>
        <span class="s2">let </span><span class="s1">localeResult;</span>
        <span class="s2">let </span><span class="s1">detectedLocale;</span>
        <span class="s2">if </span><span class="s1">(i18n) {</span>
            <span class="s1">localeResult = (</span><span class="s4">0</span><span class="s1">, _normalizelocalepath.normalizeLocalePath)(parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">, i18n.locales);</span>
            <span class="s2">if </span><span class="s1">(localeResult.detectedLocale) {</span>
                <span class="s1">req.url = </span><span class="s0">`</span><span class="s1">${localeResult.pathname}${parsedUrl.search}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s1">originalPathname = localeResult.pathname;</span>
                <span class="s2">if </span><span class="s1">(!detectedLocale) {</span>
                    <span class="s1">detectedLocale = localeResult.detectedLocale;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">serverUtils = (</span><span class="s4">0</span><span class="s1">, _serverutils.getServerUtils)({</span>
            <span class="s1">page: srcPage,</span>
            <span class="s1">i18n,</span>
            <span class="s1">basePath,</span>
            <span class="s1">rewrites,</span>
            <span class="s1">pageIsDynamic,</span>
            <span class="s1">trailingSlash: process.env.__NEXT_TRAILING_SLASH,</span>
            <span class="s1">caseSensitive: Boolean(routesManifest.caseSensitive)</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">domainLocale = (</span><span class="s4">0</span><span class="s1">, _detectdomainlocale.detectDomainLocale)(i18n == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: i18n.domains, (</span><span class="s4">0</span><span class="s1">, _gethostname.getHostname)(parsedUrl, req.headers), detectedLocale);</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isLocaleDomain'</span><span class="s1">, Boolean(domainLocale));</span>
        <span class="s2">const </span><span class="s1">defaultLocale = (domainLocale == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: domainLocale.defaultLocale) || (i18n == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: i18n.defaultLocale);</span>
        <span class="s3">// Ensure parsedUrl.pathname includes locale before processing</span>
        <span class="s3">// rewrites or they won't match correctly.</span>
        <span class="s2">if </span><span class="s1">(defaultLocale &amp;&amp; !detectedLocale) {</span>
            <span class="s1">parsedUrl.pathname = </span><span class="s0">`/</span><span class="s1">${defaultLocale}${parsedUrl.pathname === </span><span class="s0">'/' </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: parsedUrl.pathname}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">locale = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">) || detectedLocale || defaultLocale;</span>
        <span class="s2">const </span><span class="s1">rewriteParamKeys = Object.keys(serverUtils.handleRewrites(req, parsedUrl));</span>
        <span class="s3">// after processing rewrites we want to remove locale</span>
        <span class="s3">// from parsedUrl pathname</span>
        <span class="s2">if </span><span class="s1">(i18n) {</span>
            <span class="s1">parsedUrl.pathname = (</span><span class="s4">0</span><span class="s1">, _normalizelocalepath.normalizeLocalePath)(parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">, i18n.locales).pathname;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">params = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'params'</span><span class="s1">);</span>
        <span class="s3">// attempt parsing from pathname</span>
        <span class="s2">if </span><span class="s1">(!params &amp;&amp; serverUtils.dynamicRouteMatcher) {</span>
            <span class="s2">const </span><span class="s1">paramsMatch = serverUtils.dynamicRouteMatcher((</span><span class="s4">0</span><span class="s1">, _normalizedatapath.normalizeDataPath)((localeResult == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: localeResult.pathname) || parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">));</span>
            <span class="s2">const </span><span class="s1">paramsResult = serverUtils.normalizeDynamicRouteParams(paramsMatch || {}, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(paramsResult.hasValidParams) {</span>
                <span class="s1">params = paramsResult.params;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// Local &quot;next start&quot; expects the routing parsed query values</span>
        <span class="s3">// to not be present in the URL although when deployed proxies</span>
        <span class="s3">// will add query values from resolving the routes to pass to function.</span>
        <span class="s3">// TODO: do we want to change expectations for &quot;next start&quot;</span>
        <span class="s3">// to include these query values in the URL which affects asPath</span>
        <span class="s3">// but would match deployed behavior, e.g. a rewrite from middleware</span>
        <span class="s3">// that adds a query param would be in asPath as query but locally</span>
        <span class="s3">// it won't be in the asPath but still available in the query object</span>
        <span class="s2">const </span><span class="s1">query = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'query'</span><span class="s1">) || {</span>
            <span class="s1">...parsedUrl.query</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">routeParamKeys = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">const </span><span class="s1">combinedParamKeys = [];</span>
        <span class="s3">// we don't include rewriteParamKeys in the combinedParamKeys</span>
        <span class="s3">// for app router since the searchParams is populated from the</span>
        <span class="s3">// URL so we don't want to strip the rewrite params from the URL</span>
        <span class="s3">// so that searchParams can include them</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isAppRouter) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of [</span>
                <span class="s1">...rewriteParamKeys,</span>
                <span class="s1">...Object.keys(serverUtils.defaultRouteMatches || {})</span>
            <span class="s1">]){</span>
                <span class="s3">// We only want to filter rewrite param keys from the URL</span>
                <span class="s3">// if they are matches from the URL e.g. the key/value matches</span>
                <span class="s3">// before and after applying the rewrites /:path for /hello and</span>
                <span class="s3">// { path: 'hello' } but not for { path: 'another' } and /hello</span>
                <span class="s3">// TODO: we should prefix rewrite param keys the same as we do</span>
                <span class="s3">// for dynamic routes so we can identify them properly</span>
                <span class="s2">const </span><span class="s1">originalValue = Array.isArray(originalQuery[key]) ? originalQuery[key].join(</span><span class="s0">''</span><span class="s1">) : originalQuery[key];</span>
                <span class="s2">const </span><span class="s1">queryValue = Array.isArray(query[key]) ? query[key].join(</span><span class="s0">''</span><span class="s1">) : query[key];</span>
                <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">originalQuery) || originalValue === queryValue) {</span>
                    <span class="s1">combinedParamKeys.push(key);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">serverUtils.normalizeCdnUrl(req, combinedParamKeys);</span>
        <span class="s1">serverUtils.normalizeQueryParams(query, routeParamKeys);</span>
        <span class="s1">serverUtils.filterInternalQuery(originalQuery, combinedParamKeys);</span>
        <span class="s2">if </span><span class="s1">(pageIsDynamic) {</span>
            <span class="s2">const </span><span class="s1">queryResult = serverUtils.normalizeDynamicRouteParams(query, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">paramsResult = serverUtils.normalizeDynamicRouteParams(params || {}, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">paramsToInterpolate = paramsResult.hasValidParams &amp;&amp; params ? params : queryResult.hasValidParams ? query : {};</span>
            <span class="s1">req.url = serverUtils.interpolateDynamicPath(req.url || </span><span class="s0">'/'</span><span class="s1">, paramsToInterpolate);</span>
            <span class="s1">parsedUrl.pathname = serverUtils.interpolateDynamicPath(parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">, paramsToInterpolate);</span>
            <span class="s1">originalPathname = serverUtils.interpolateDynamicPath(originalPathname, paramsToInterpolate);</span>
            <span class="s3">// try pulling from query if valid</span>
            <span class="s2">if </span><span class="s1">(!params) {</span>
                <span class="s2">if </span><span class="s1">(queryResult.hasValidParams) {</span>
                    <span class="s1">params = Object.assign({}, queryResult.params);</span>
                    <span class="s3">// If we pulled from query remove it so it's</span>
                    <span class="s3">// only in params</span>
                    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">serverUtils.defaultRouteMatches){</span>
                        <span class="s2">delete </span><span class="s1">query[key];</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s3">// use final params from URL matching</span>
                    <span class="s2">const </span><span class="s1">paramsMatch = serverUtils.dynamicRouteMatcher == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: serverUtils.dynamicRouteMatcher.call(serverUtils, (</span><span class="s4">0</span><span class="s1">, _normalizedatapath.normalizeDataPath)((localeResult == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: localeResult.pathname) || parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">));</span>
                    <span class="s3">// we don't normalize these as they are allowed to be</span>
                    <span class="s3">// the literal slug matches here e.g. /blog/[slug]</span>
                    <span class="s3">// actually being requested</span>
                    <span class="s2">if </span><span class="s1">(paramsMatch) {</span>
                        <span class="s1">params = Object.assign({}, paramsMatch);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// Remove any normalized params from the query if they</span>
        <span class="s3">// weren't present as non-prefixed query key e.g.</span>
        <span class="s3">// ?search=1&amp;nxtPsearch=hello we don't delete search</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of routeParamKeys){</span>
            <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">originalQuery)) {</span>
                <span class="s2">delete </span><span class="s1">query[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ isOnDemandRevalidate, revalidateOnlyGenerated } = (</span><span class="s4">0</span><span class="s1">, _apiutils.checkIsOnDemandRevalidate)(req, prerenderManifest.preview);</span>
        <span class="s2">let </span><span class="s1">isDraftMode = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">previewData;</span>
        <span class="s3">// preview data relies on non-edge utils</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_RUNTIME !== </span><span class="s0">'edge' </span><span class="s1">&amp;&amp; res) {</span>
            <span class="s2">const </span><span class="s1">{ tryGetPreviewData } = require(</span><span class="s0">'../api-utils/node/try-get-preview-data'</span><span class="s1">);</span>
            <span class="s1">previewData = tryGetPreviewData(req, res, prerenderManifest.preview, Boolean(multiZoneDraftMode));</span>
            <span class="s1">isDraftMode = previewData !== </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">relativeProjectDir = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'relativeProjectDir'</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.relativeProjectDir;</span>
        <span class="s2">const </span><span class="s1">routerServerContext = (_routerServerGlobal_RouterServerContextSymbol = _routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _routerServerGlobal_RouterServerContextSymbol[relativeProjectDir];</span>
        <span class="s2">const </span><span class="s1">nextConfig = (routerServerContext == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: routerServerContext.nextConfig) || serverFilesManifest.config;</span>
        <span class="s2">const </span><span class="s1">normalizedSrcPage = (</span><span class="s4">0</span><span class="s1">, _apppaths.normalizeAppPath)(srcPage);</span>
        <span class="s2">let </span><span class="s1">resolvedPathname = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'rewroteURL'</span><span class="s1">) || normalizedSrcPage;</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _utils.isDynamicRoute)(resolvedPathname) &amp;&amp; params) {</span>
            <span class="s1">resolvedPathname = serverUtils.interpolateDynamicPath(resolvedPathname, params);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(resolvedPathname === </span><span class="s0">'/index'</span><span class="s1">) {</span>
            <span class="s1">resolvedPathname = </span><span class="s0">'/'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">resolvedPathname = (</span><span class="s4">0</span><span class="s1">, _decodepathparams.decodePathParams)(resolvedPathname);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_) {}</span>
        <span class="s1">resolvedPathname = (</span><span class="s4">0</span><span class="s1">, _removetrailingslash.removeTrailingSlash)(resolvedPathname);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">query,</span>
            <span class="s1">originalQuery,</span>
            <span class="s1">originalPathname,</span>
            <span class="s1">params,</span>
            <span class="s1">parsedUrl,</span>
            <span class="s1">locale,</span>
            <span class="s1">isNextDataRequest,</span>
            <span class="s1">locales: i18n == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: i18n.locales,</span>
            <span class="s1">defaultLocale,</span>
            <span class="s1">isDraftMode,</span>
            <span class="s1">previewData,</span>
            <span class="s1">pageIsDynamic,</span>
            <span class="s1">resolvedPathname,</span>
            <span class="s1">isOnDemandRevalidate,</span>
            <span class="s1">revalidateOnlyGenerated,</span>
            <span class="s1">...manifests,</span>
            <span class="s1">serverActionsManifest: manifests.serverActionsManifest,</span>
            <span class="s1">clientReferenceManifest: manifests.clientReferenceManifest,</span>
            <span class="s1">nextConfig,</span>
            <span class="s1">routerServerContext</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">getResponseCache(req) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.responseCache) {</span>
            <span class="s2">const </span><span class="s1">minimalMode = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'minimalMode'</span><span class="s1">) ?? </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.responseCache = </span><span class="s2">new </span><span class="s1">_responsecache.default(minimalMode);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.responseCache;</span>
    <span class="s1">}</span>
    <span class="s1">async handleResponse({ req, nextConfig, cacheKey, routeKind, isFallback, prerenderManifest, isRoutePPREnabled, isOnDemandRevalidate, revalidateOnlyGenerated, responseGenerator, waitUntil }) {</span>
        <span class="s2">const </span><span class="s1">responseCache = </span><span class="s2">this</span><span class="s1">.getResponseCache(req);</span>
        <span class="s2">const </span><span class="s1">cacheEntry = </span><span class="s2">await </span><span class="s1">responseCache.get(cacheKey, responseGenerator, {</span>
            <span class="s1">routeKind,</span>
            <span class="s1">isFallback,</span>
            <span class="s1">isRoutePPREnabled,</span>
            <span class="s1">isOnDemandRevalidate,</span>
            <span class="s1">isPrefetch: req.headers.purpose === </span><span class="s0">'prefetch'</span><span class="s1">,</span>
            <span class="s1">incrementalCache: </span><span class="s2">await this</span><span class="s1">.getIncrementalCache(req, nextConfig, prerenderManifest),</span>
            <span class="s1">waitUntil</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(!cacheEntry) {</span>
            <span class="s2">if </span><span class="s1">(cacheKey &amp;&amp; </span><span class="s3">// revalidate only generated can bail even if cacheKey is provided</span>
            <span class="s1">!(isOnDemandRevalidate &amp;&amp; revalidateOnlyGenerated)) {</span>
                <span class="s3">// A cache entry might not be generated if a response is written</span>
                <span class="s3">// in `getInitialProps` or `getServerSideProps`, but those shouldn't</span>
                <span class="s3">// have a cache key. If we do have a cache key but we don't end up</span>
                <span class="s3">// with a cache entry, then either Next.js or the application has a</span>
                <span class="s3">// bug that needs fixing.</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant: cache entry required but not generated'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E62&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">cacheEntry;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=route-module.js.map</span></pre>
</body>
</html>