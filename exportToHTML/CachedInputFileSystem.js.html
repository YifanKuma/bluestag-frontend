<html>
<head>
<title>CachedInputFileSystem.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
CachedInputFileSystem.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
    MIT License http://www.opensource.org/licenses/mit-license.php 
    Author Tobias Koppers @sokra 
*/</span>

<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s0">// eslint-disable-next-line n/prefer-global/process</span>
<span class="s3">const </span><span class="s1">{ nextTick } = require(</span><span class="s2">&quot;process&quot;</span><span class="s1">);</span>

<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{import(&quot;./Resolver&quot;).FileSystem} FileSystem */</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{import(&quot;./Resolver&quot;).PathLike} PathLike */</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{import(&quot;./Resolver&quot;).PathOrFileDescriptor} PathOrFileDescriptor */</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{import(&quot;./Resolver&quot;).SyncFileSystem} SyncFileSystem */</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{FileSystem &amp; SyncFileSystem} BaseFileSystem */</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@template </span><span class="s0">T</span>
 <span class="s0">* </span><span class="s4">@typedef </span><span class="s0">{import(&quot;./Resolver&quot;).FileSystemCallback&lt;T&gt;} FileSystemCallback&lt;T&gt;</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} path path</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{string} dirname</span>
 <span class="s0">*/</span>
<span class="s3">const </span><span class="s1">dirname = (path) =&gt; {</span>
	<span class="s3">let </span><span class="s1">idx = path.length - </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s3">while </span><span class="s1">(idx &gt;= </span><span class="s5">0</span><span class="s1">) {</span>
		<span class="s3">const </span><span class="s1">char = path.charCodeAt(idx);</span>
		<span class="s0">// slash or backslash</span>
		<span class="s3">if </span><span class="s1">(char === </span><span class="s5">47 </span><span class="s1">|| char === </span><span class="s5">92</span><span class="s1">) </span><span class="s3">break</span><span class="s1">;</span>
		<span class="s1">idx--;</span>
	<span class="s1">}</span>
	<span class="s3">if </span><span class="s1">(idx &lt; </span><span class="s5">0</span><span class="s1">) </span><span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
	<span class="s3">return </span><span class="s1">path.slice(</span><span class="s5">0</span><span class="s1">, idx);</span>
<span class="s1">};</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@template </span><span class="s0">T</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{FileSystemCallback&lt;T&gt;[]} callbacks callbacks</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{Error | null} err error</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{T} result result</span>
 <span class="s0">*/</span>
<span class="s3">const </span><span class="s1">runCallbacks = (callbacks, err, result) =&gt; {</span>
	<span class="s3">if </span><span class="s1">(callbacks.length === </span><span class="s5">1</span><span class="s1">) {</span>
		<span class="s1">callbacks[</span><span class="s5">0</span><span class="s1">](err, result);</span>
		<span class="s1">callbacks.length = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s3">return</span><span class="s1">;</span>
	<span class="s1">}</span>
	<span class="s3">let </span><span class="s1">error;</span>
	<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">callback of callbacks) {</span>
		<span class="s3">try </span><span class="s1">{</span>
			<span class="s1">callback(err, result);</span>
		<span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
			<span class="s3">if </span><span class="s1">(!error) error = err;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">callbacks.length = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(error) </span><span class="s3">throw </span><span class="s1">error;</span>
<span class="s1">};</span>

<span class="s0">// eslint-disable-next-line jsdoc/no-restricted-syntax</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{Function} EXPECTED_FUNCTION */</span>
<span class="s0">// eslint-disable-next-line jsdoc/no-restricted-syntax</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{any} EXPECTED_ANY */</span>

<span class="s3">class </span><span class="s1">OperationMergerBackend {</span>
	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_FUNCTION | undefined} provider async method in filesystem</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_FUNCTION | undefined} syncProvider sync method in filesystem</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{BaseFileSystem} providerContext call context for the provider methods</span>
	 <span class="s0">*/</span>
	<span class="s1">constructor(provider, syncProvider, providerContext) {</span>
		<span class="s3">this</span><span class="s1">._provider = provider;</span>
		<span class="s3">this</span><span class="s1">._syncProvider = syncProvider;</span>
		<span class="s3">this</span><span class="s1">._providerContext = providerContext;</span>
		<span class="s3">this</span><span class="s1">._activeAsyncOperations = </span><span class="s3">new </span><span class="s1">Map();</span>

		<span class="s3">this</span><span class="s1">.provide = </span><span class="s3">this</span><span class="s1">._provider</span>
			<span class="s1">? </span><span class="s0">// Comment to align jsdoc</span>
				<span class="s0">/**</span>
				 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{PathLike | PathOrFileDescriptor} path path</span>
				 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{object | FileSystemCallback&lt;EXPECTED_ANY&gt; | undefined} options options</span>
				 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{FileSystemCallback&lt;EXPECTED_ANY&gt;=} callback callback</span>
				 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{EXPECTED_ANY} result</span>
				 <span class="s0">*/</span>
				<span class="s1">(path, options, callback) =&gt; {</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
						<span class="s1">callback =</span>
							<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{FileSystemCallback&lt;EXPECTED_ANY&gt;} */</span>
							<span class="s1">(options);</span>
						<span class="s1">options = undefined;</span>
					<span class="s1">}</span>
					<span class="s3">if </span><span class="s1">(</span>
						<span class="s3">typeof </span><span class="s1">path !== </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp;</span>
						<span class="s1">!Buffer.isBuffer(path) &amp;&amp;</span>
						<span class="s1">!(path </span><span class="s3">instanceof </span><span class="s1">URL) &amp;&amp;</span>
						<span class="s3">typeof </span><span class="s1">path !== </span><span class="s2">&quot;number&quot;</span>
					<span class="s1">) {</span>
						<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{EXPECTED_FUNCTION} */</span>
						<span class="s1">(callback)(</span>
							<span class="s3">new </span><span class="s1">TypeError(</span><span class="s2">&quot;path must be a string, Buffer, URL or number&quot;</span><span class="s1">),</span>
						<span class="s1">);</span>
						<span class="s3">return</span><span class="s1">;</span>
					<span class="s1">}</span>
					<span class="s3">if </span><span class="s1">(options) {</span>
						<span class="s3">return </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{EXPECTED_FUNCTION} */ </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._provider).call(</span>
							<span class="s3">this</span><span class="s1">._providerContext,</span>
							<span class="s1">path,</span>
							<span class="s1">options,</span>
							<span class="s1">callback,</span>
						<span class="s1">);</span>
					<span class="s1">}</span>
					<span class="s3">let </span><span class="s1">callbacks = </span><span class="s3">this</span><span class="s1">._activeAsyncOperations.get(path);</span>
					<span class="s3">if </span><span class="s1">(callbacks) {</span>
						<span class="s1">callbacks.push(callback);</span>
						<span class="s3">return</span><span class="s1">;</span>
					<span class="s1">}</span>
					<span class="s3">this</span><span class="s1">._activeAsyncOperations.set(path, (callbacks = [callback]));</span>
					<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{EXPECTED_FUNCTION} */</span>
					<span class="s1">(provider)(</span>
						<span class="s1">path,</span>
						<span class="s0">/**</span>
						 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{Error} err error</span>
						 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_ANY} result result</span>
						 <span class="s0">*/</span>
						<span class="s1">(err, result) =&gt; {</span>
							<span class="s3">this</span><span class="s1">._activeAsyncOperations.delete(path);</span>
							<span class="s1">runCallbacks(callbacks, err, result);</span>
						<span class="s1">},</span>
					<span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
		<span class="s3">this</span><span class="s1">.provideSync = </span><span class="s3">this</span><span class="s1">._syncProvider</span>
			<span class="s1">? </span><span class="s0">// Comment to align jsdoc</span>
				<span class="s0">/**</span>
				 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{PathLike | PathOrFileDescriptor} path path</span>
				 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{object=} options options</span>
				 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{EXPECTED_ANY} result</span>
				 <span class="s0">*/</span>
				<span class="s1">(path, options) =&gt;</span>
					<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{EXPECTED_FUNCTION} */ </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._syncProvider).call(</span>
						<span class="s3">this</span><span class="s1">._providerContext,</span>
						<span class="s1">path,</span>
						<span class="s1">options,</span>
					<span class="s1">)</span>
			<span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">purge() {}</span>

	<span class="s1">purgeParent() {}</span>
<span class="s1">}</span>

<span class="s0">/* 
 
IDLE: 
    insert data: goto SYNC 
 
SYNC: 
    before provide: run ticks 
    event loop tick: goto ASYNC_ACTIVE 
 
ASYNC: 
    timeout: run tick, goto ASYNC_PASSIVE 
 
ASYNC_PASSIVE: 
    before provide: run ticks 
 
IDLE --[insert data]--&gt; SYNC --[event loop tick]--&gt; ASYNC_ACTIVE --[interval tick]-&gt; ASYNC_PASSIVE 
                                                          ^                             | 
                                                          +---------[insert data]-------+ 
*/</span>

<span class="s3">const </span><span class="s1">STORAGE_MODE_IDLE = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">STORAGE_MODE_SYNC = </span><span class="s5">1</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">STORAGE_MODE_ASYNC = </span><span class="s5">2</span><span class="s1">;</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@callback </span><span class="s0">Provide</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{PathLike | PathOrFileDescriptor} path path</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_ANY} options options</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{FileSystemCallback&lt;EXPECTED_ANY&gt;} callback callback</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>

<span class="s3">class </span><span class="s1">CacheBackend {</span>
	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{number} duration max cache duration of items</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_FUNCTION | undefined} provider async method</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_FUNCTION | undefined} syncProvider sync method</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{BaseFileSystem} providerContext call context for the provider methods</span>
	 <span class="s0">*/</span>
	<span class="s1">constructor(duration, provider, syncProvider, providerContext) {</span>
		<span class="s3">this</span><span class="s1">._duration = duration;</span>
		<span class="s3">this</span><span class="s1">._provider = provider;</span>
		<span class="s3">this</span><span class="s1">._syncProvider = syncProvider;</span>
		<span class="s3">this</span><span class="s1">._providerContext = providerContext;</span>
		<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{Map&lt;string, FileSystemCallback&lt;EXPECTED_ANY&gt;[]&gt;} */</span>
		<span class="s3">this</span><span class="s1">._activeAsyncOperations = </span><span class="s3">new </span><span class="s1">Map();</span>
		<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{Map&lt;string, { err: Error | null, result?: EXPECTED_ANY, level: Set&lt;string&gt; }&gt;} */</span>
		<span class="s3">this</span><span class="s1">._data = </span><span class="s3">new </span><span class="s1">Map();</span>
		<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{Set&lt;string&gt;[]} */</span>
		<span class="s3">this</span><span class="s1">._levels = [];</span>
		<span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; </span><span class="s5">10</span><span class="s1">; i++) </span><span class="s3">this</span><span class="s1">._levels.push(</span><span class="s3">new </span><span class="s1">Set());</span>
		<span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s5">5000</span><span class="s1">; i &lt; duration; i += </span><span class="s5">500</span><span class="s1">) </span><span class="s3">this</span><span class="s1">._levels.push(</span><span class="s3">new </span><span class="s1">Set());</span>
		<span class="s3">this</span><span class="s1">._currentLevel = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s3">this</span><span class="s1">._tickInterval = Math.floor(duration / </span><span class="s3">this</span><span class="s1">._levels.length);</span>
		<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */</span>
		<span class="s3">this</span><span class="s1">._mode = STORAGE_MODE_IDLE;</span>

		<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{NodeJS.Timeout | undefined} */</span>
		<span class="s3">this</span><span class="s1">._timeout = undefined;</span>
		<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{number | undefined} */</span>
		<span class="s3">this</span><span class="s1">._nextDecay = undefined;</span>

		<span class="s0">// eslint-disable-next-line no-warning-comments</span>
		<span class="s0">// @ts-ignore</span>
		<span class="s3">this</span><span class="s1">.provide = provider ? </span><span class="s3">this</span><span class="s1">.provide.bind(</span><span class="s3">this</span><span class="s1">) : </span><span class="s3">null</span><span class="s1">;</span>
		<span class="s0">// eslint-disable-next-line no-warning-comments</span>
		<span class="s0">// @ts-ignore</span>
		<span class="s3">this</span><span class="s1">.provideSync = syncProvider ? </span><span class="s3">this</span><span class="s1">.provideSync.bind(</span><span class="s3">this</span><span class="s1">) : </span><span class="s3">null</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{PathLike | PathOrFileDescriptor} path path</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_ANY} options options</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{FileSystemCallback&lt;EXPECTED_ANY&gt;} callback callback</span>
	 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s1">provide(path, options, callback) {</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
			<span class="s1">callback = options;</span>
			<span class="s1">options = undefined;</span>
		<span class="s1">}</span>
		<span class="s3">if </span><span class="s1">(</span>
			<span class="s3">typeof </span><span class="s1">path !== </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp;</span>
			<span class="s1">!Buffer.isBuffer(path) &amp;&amp;</span>
			<span class="s1">!(path </span><span class="s3">instanceof </span><span class="s1">URL) &amp;&amp;</span>
			<span class="s3">typeof </span><span class="s1">path !== </span><span class="s2">&quot;number&quot;</span>
		<span class="s1">) {</span>
			<span class="s1">callback(</span><span class="s3">new </span><span class="s1">TypeError(</span><span class="s2">&quot;path must be a string, Buffer, URL or number&quot;</span><span class="s1">));</span>
			<span class="s3">return</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s3">const </span><span class="s1">strPath = </span><span class="s3">typeof </span><span class="s1">path !== </span><span class="s2">&quot;string&quot; </span><span class="s1">? path.toString() : path;</span>
		<span class="s3">if </span><span class="s1">(options) {</span>
			<span class="s3">return </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{EXPECTED_FUNCTION} */ </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._provider).call(</span>
				<span class="s3">this</span><span class="s1">._providerContext,</span>
				<span class="s1">path,</span>
				<span class="s1">options,</span>
				<span class="s1">callback,</span>
			<span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s0">// When in sync mode we can move to async mode</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._mode === STORAGE_MODE_SYNC) {</span>
			<span class="s3">this</span><span class="s1">._enterAsyncMode();</span>
		<span class="s1">}</span>

		<span class="s0">// Check in cache</span>
		<span class="s3">const </span><span class="s1">cacheEntry = </span><span class="s3">this</span><span class="s1">._data.get(strPath);</span>
		<span class="s3">if </span><span class="s1">(cacheEntry !== undefined) {</span>
			<span class="s3">if </span><span class="s1">(cacheEntry.err) </span><span class="s3">return </span><span class="s1">nextTick(callback, cacheEntry.err);</span>
			<span class="s3">return </span><span class="s1">nextTick(callback, </span><span class="s3">null</span><span class="s1">, cacheEntry.result);</span>
		<span class="s1">}</span>

		<span class="s0">// Check if there is already the same operation running</span>
		<span class="s3">let </span><span class="s1">callbacks = </span><span class="s3">this</span><span class="s1">._activeAsyncOperations.get(strPath);</span>
		<span class="s3">if </span><span class="s1">(callbacks !== undefined) {</span>
			<span class="s1">callbacks.push(callback);</span>
			<span class="s3">return</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s3">this</span><span class="s1">._activeAsyncOperations.set(strPath, (callbacks = [callback]));</span>

		<span class="s0">// Run the operation</span>
		<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{EXPECTED_FUNCTION} */</span>
		<span class="s1">(</span><span class="s3">this</span><span class="s1">._provider).call(</span>
			<span class="s3">this</span><span class="s1">._providerContext,</span>
			<span class="s1">path,</span>
			<span class="s0">/**</span>
			 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{Error | null} err error</span>
			 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_ANY=} result result</span>
			 <span class="s0">*/</span>
			<span class="s1">(err, result) =&gt; {</span>
				<span class="s3">this</span><span class="s1">._activeAsyncOperations.delete(strPath);</span>
				<span class="s3">this</span><span class="s1">._storeResult(strPath, err, result);</span>

				<span class="s0">// Enter async mode if not yet done</span>
				<span class="s3">this</span><span class="s1">._enterAsyncMode();</span>

				<span class="s1">runCallbacks(</span>
					<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{FileSystemCallback&lt;EXPECTED_ANY&gt;[]} */ </span><span class="s1">(callbacks),</span>
					<span class="s1">err,</span>
					<span class="s1">result,</span>
				<span class="s1">);</span>
			<span class="s1">},</span>
		<span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{PathLike | PathOrFileDescriptor} path path</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_ANY} options options</span>
	 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{EXPECTED_ANY} result</span>
	 <span class="s0">*/</span>
	<span class="s1">provideSync(path, options) {</span>
		<span class="s3">if </span><span class="s1">(</span>
			<span class="s3">typeof </span><span class="s1">path !== </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp;</span>
			<span class="s1">!Buffer.isBuffer(path) &amp;&amp;</span>
			<span class="s1">!(path </span><span class="s3">instanceof </span><span class="s1">URL) &amp;&amp;</span>
			<span class="s3">typeof </span><span class="s1">path !== </span><span class="s2">&quot;number&quot;</span>
		<span class="s1">) {</span>
			<span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;path must be a string&quot;</span><span class="s1">);</span>
		<span class="s1">}</span>
		<span class="s3">const </span><span class="s1">strPath = </span><span class="s3">typeof </span><span class="s1">path !== </span><span class="s2">&quot;string&quot; </span><span class="s1">? path.toString() : path;</span>
		<span class="s3">if </span><span class="s1">(options) {</span>
			<span class="s3">return </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{EXPECTED_FUNCTION} */ </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._syncProvider).call(</span>
				<span class="s3">this</span><span class="s1">._providerContext,</span>
				<span class="s1">path,</span>
				<span class="s1">options,</span>
			<span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s0">// In sync mode we may have to decay some cache items</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._mode === STORAGE_MODE_SYNC) {</span>
			<span class="s3">this</span><span class="s1">._runDecays();</span>
		<span class="s1">}</span>

		<span class="s0">// Check in cache</span>
		<span class="s3">const </span><span class="s1">cacheEntry = </span><span class="s3">this</span><span class="s1">._data.get(strPath);</span>
		<span class="s3">if </span><span class="s1">(cacheEntry !== undefined) {</span>
			<span class="s3">if </span><span class="s1">(cacheEntry.err) </span><span class="s3">throw </span><span class="s1">cacheEntry.err;</span>
			<span class="s3">return </span><span class="s1">cacheEntry.result;</span>
		<span class="s1">}</span>

		<span class="s0">// Get all active async operations</span>
		<span class="s0">// This sync operation will also complete them</span>
		<span class="s3">const </span><span class="s1">callbacks = </span><span class="s3">this</span><span class="s1">._activeAsyncOperations.get(strPath);</span>
		<span class="s3">this</span><span class="s1">._activeAsyncOperations.delete(strPath);</span>

		<span class="s0">// Run the operation</span>
		<span class="s0">// When in idle mode, we will enter sync mode</span>
		<span class="s3">let </span><span class="s1">result;</span>
		<span class="s3">try </span><span class="s1">{</span>
			<span class="s1">result = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{EXPECTED_FUNCTION} */ </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._syncProvider).call(</span>
				<span class="s3">this</span><span class="s1">._providerContext,</span>
				<span class="s1">path,</span>
			<span class="s1">);</span>
		<span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
			<span class="s3">this</span><span class="s1">._storeResult(strPath, </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{Error} */ </span><span class="s1">(err), undefined);</span>
			<span class="s3">this</span><span class="s1">._enterSyncModeWhenIdle();</span>
			<span class="s3">if </span><span class="s1">(callbacks) {</span>
				<span class="s1">runCallbacks(callbacks, </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{Error} */ </span><span class="s1">(err), undefined);</span>
			<span class="s1">}</span>
			<span class="s3">throw </span><span class="s1">err;</span>
		<span class="s1">}</span>
		<span class="s3">this</span><span class="s1">._storeResult(strPath, </span><span class="s3">null</span><span class="s1">, result);</span>
		<span class="s3">this</span><span class="s1">._enterSyncModeWhenIdle();</span>
		<span class="s3">if </span><span class="s1">(callbacks) {</span>
			<span class="s1">runCallbacks(callbacks, </span><span class="s3">null</span><span class="s1">, result);</span>
		<span class="s1">}</span>
		<span class="s3">return </span><span class="s1">result;</span>
	<span class="s1">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{(string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set&lt;string | URL | Buffer | number&gt;)=} what what to purge</span>
	 <span class="s0">*/</span>
	<span class="s1">purge(what) {</span>
		<span class="s3">if </span><span class="s1">(!what) {</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._mode !== STORAGE_MODE_IDLE) {</span>
				<span class="s3">this</span><span class="s1">._data.clear();</span>
				<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">level of </span><span class="s3">this</span><span class="s1">._levels) {</span>
					<span class="s1">level.clear();</span>
				<span class="s1">}</span>
				<span class="s3">this</span><span class="s1">._enterIdleMode();</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
			<span class="s3">typeof </span><span class="s1">what === </span><span class="s2">&quot;string&quot; </span><span class="s1">||</span>
			<span class="s1">Buffer.isBuffer(what) ||</span>
			<span class="s1">what </span><span class="s3">instanceof </span><span class="s1">URL ||</span>
			<span class="s3">typeof </span><span class="s1">what === </span><span class="s2">&quot;number&quot;</span>
		<span class="s1">) {</span>
			<span class="s3">const </span><span class="s1">strWhat = </span><span class="s3">typeof </span><span class="s1">what !== </span><span class="s2">&quot;string&quot; </span><span class="s1">? what.toString() : what;</span>
			<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">[key, data] of </span><span class="s3">this</span><span class="s1">._data) {</span>
				<span class="s3">if </span><span class="s1">(key.startsWith(strWhat)) {</span>
					<span class="s3">this</span><span class="s1">._data.delete(key);</span>
					<span class="s1">data.level.delete(key);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._data.size === </span><span class="s5">0</span><span class="s1">) {</span>
				<span class="s3">this</span><span class="s1">._enterIdleMode();</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
			<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">[key, data] of </span><span class="s3">this</span><span class="s1">._data) {</span>
				<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">item of what) {</span>
					<span class="s3">const </span><span class="s1">strItem = </span><span class="s3">typeof </span><span class="s1">item !== </span><span class="s2">&quot;string&quot; </span><span class="s1">? item.toString() : item;</span>
					<span class="s3">if </span><span class="s1">(key.startsWith(strItem)) {</span>
						<span class="s3">this</span><span class="s1">._data.delete(key);</span>
						<span class="s1">data.level.delete(key);</span>
						<span class="s3">break</span><span class="s1">;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._data.size === </span><span class="s5">0</span><span class="s1">) {</span>
				<span class="s3">this</span><span class="s1">._enterIdleMode();</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{(string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set&lt;string | URL | Buffer | number&gt;)=} what what to purge</span>
	 <span class="s0">*/</span>
	<span class="s1">purgeParent(what) {</span>
		<span class="s3">if </span><span class="s1">(!what) {</span>
			<span class="s3">this</span><span class="s1">.purge();</span>
		<span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
			<span class="s3">typeof </span><span class="s1">what === </span><span class="s2">&quot;string&quot; </span><span class="s1">||</span>
			<span class="s1">Buffer.isBuffer(what) ||</span>
			<span class="s1">what </span><span class="s3">instanceof </span><span class="s1">URL ||</span>
			<span class="s3">typeof </span><span class="s1">what === </span><span class="s2">&quot;number&quot;</span>
		<span class="s1">) {</span>
			<span class="s3">const </span><span class="s1">strWhat = </span><span class="s3">typeof </span><span class="s1">what !== </span><span class="s2">&quot;string&quot; </span><span class="s1">? what.toString() : what;</span>
			<span class="s3">this</span><span class="s1">.purge(dirname(strWhat));</span>
		<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
			<span class="s3">const </span><span class="s1">set = </span><span class="s3">new </span><span class="s1">Set();</span>
			<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">item of what) {</span>
				<span class="s3">const </span><span class="s1">strItem = </span><span class="s3">typeof </span><span class="s1">item !== </span><span class="s2">&quot;string&quot; </span><span class="s1">? item.toString() : item;</span>
				<span class="s1">set.add(dirname(strItem));</span>
			<span class="s1">}</span>
			<span class="s3">this</span><span class="s1">.purge(set);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} path path</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{Error | null} err error</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{EXPECTED_ANY} result result</span>
	 <span class="s0">*/</span>
	<span class="s1">_storeResult(path, err, result) {</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._data.has(path)) </span><span class="s3">return</span><span class="s1">;</span>
		<span class="s3">const </span><span class="s1">level = </span><span class="s3">this</span><span class="s1">._levels[</span><span class="s3">this</span><span class="s1">._currentLevel];</span>
		<span class="s3">this</span><span class="s1">._data.set(path, { err, result, level });</span>
		<span class="s1">level.add(path);</span>
	<span class="s1">}</span>

	<span class="s1">_decayLevel() {</span>
		<span class="s3">const </span><span class="s1">nextLevel = (</span><span class="s3">this</span><span class="s1">._currentLevel + </span><span class="s5">1</span><span class="s1">) % </span><span class="s3">this</span><span class="s1">._levels.length;</span>
		<span class="s3">const </span><span class="s1">decay = </span><span class="s3">this</span><span class="s1">._levels[nextLevel];</span>
		<span class="s3">this</span><span class="s1">._currentLevel = nextLevel;</span>
		<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">item of decay) {</span>
			<span class="s3">this</span><span class="s1">._data.delete(item);</span>
		<span class="s1">}</span>
		<span class="s1">decay.clear();</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._data.size === </span><span class="s5">0</span><span class="s1">) {</span>
			<span class="s3">this</span><span class="s1">._enterIdleMode();</span>
		<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
			<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{number} */</span>
			<span class="s1">(</span><span class="s3">this</span><span class="s1">._nextDecay) += </span><span class="s3">this</span><span class="s1">._tickInterval;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">_runDecays() {</span>
		<span class="s3">while </span><span class="s1">(</span>
			<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{number} */ </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._nextDecay) &lt;= Date.now() &amp;&amp;</span>
			<span class="s3">this</span><span class="s1">._mode !== STORAGE_MODE_IDLE</span>
		<span class="s1">) {</span>
			<span class="s3">this</span><span class="s1">._decayLevel();</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">_enterAsyncMode() {</span>
		<span class="s3">let </span><span class="s1">timeout = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s3">switch </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._mode) {</span>
			<span class="s3">case </span><span class="s1">STORAGE_MODE_ASYNC:</span>
				<span class="s3">return</span><span class="s1">;</span>
			<span class="s3">case </span><span class="s1">STORAGE_MODE_IDLE:</span>
				<span class="s3">this</span><span class="s1">._nextDecay = Date.now() + </span><span class="s3">this</span><span class="s1">._tickInterval;</span>
				<span class="s1">timeout = </span><span class="s3">this</span><span class="s1">._tickInterval;</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s3">case </span><span class="s1">STORAGE_MODE_SYNC:</span>
				<span class="s3">this</span><span class="s1">._runDecays();</span>
				<span class="s0">// _runDecays may change the mode</span>
				<span class="s3">if </span><span class="s1">(</span>
					<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */</span>
					<span class="s1">(</span><span class="s3">this</span><span class="s1">._mode) === STORAGE_MODE_IDLE</span>
				<span class="s1">) {</span>
					<span class="s3">return</span><span class="s1">;</span>
				<span class="s1">}</span>
				<span class="s1">timeout = Math.max(</span>
					<span class="s5">0</span><span class="s1">,</span>
					<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{number} */ </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._nextDecay) - Date.now(),</span>
				<span class="s1">);</span>
				<span class="s3">break</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s3">this</span><span class="s1">._mode = STORAGE_MODE_ASYNC;</span>
		<span class="s3">const </span><span class="s1">ref = setTimeout(() =&gt; {</span>
			<span class="s3">this</span><span class="s1">._mode = STORAGE_MODE_SYNC;</span>
			<span class="s3">this</span><span class="s1">._runDecays();</span>
		<span class="s1">}, timeout);</span>
		<span class="s3">if </span><span class="s1">(ref.unref) ref.unref();</span>
		<span class="s3">this</span><span class="s1">._timeout = ref;</span>
	<span class="s1">}</span>

	<span class="s1">_enterSyncModeWhenIdle() {</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._mode === STORAGE_MODE_IDLE) {</span>
			<span class="s3">this</span><span class="s1">._mode = STORAGE_MODE_SYNC;</span>
			<span class="s3">this</span><span class="s1">._nextDecay = Date.now() + </span><span class="s3">this</span><span class="s1">._tickInterval;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">_enterIdleMode() {</span>
		<span class="s3">this</span><span class="s1">._mode = STORAGE_MODE_IDLE;</span>
		<span class="s3">this</span><span class="s1">._nextDecay = undefined;</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._timeout) clearTimeout(</span><span class="s3">this</span><span class="s1">._timeout);</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@template </span><span class="s0">{EXPECTED_FUNCTION} Provider</span>
 <span class="s0">* </span><span class="s4">@template </span><span class="s0">{EXPECTED_FUNCTION} AsyncProvider</span>
 <span class="s0">* </span><span class="s4">@template </span><span class="s0">FileSystem</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{number} duration duration in ms files are cached</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{Provider | undefined} provider provider</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{AsyncProvider | undefined} syncProvider sync provider</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{BaseFileSystem} providerContext provider context</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{OperationMergerBackend | CacheBackend} backend</span>
 <span class="s0">*/</span>
<span class="s3">const </span><span class="s1">createBackend = (duration, provider, syncProvider, providerContext) =&gt; {</span>
	<span class="s3">if </span><span class="s1">(duration &gt; </span><span class="s5">0</span><span class="s1">) {</span>
		<span class="s3">return new </span><span class="s1">CacheBackend(duration, provider, syncProvider, providerContext);</span>
	<span class="s1">}</span>
	<span class="s3">return new </span><span class="s1">OperationMergerBackend(provider, syncProvider, providerContext);</span>
<span class="s1">};</span>

<span class="s1">module.exports = </span><span class="s3">class </span><span class="s1">CachedInputFileSystem {</span>
	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{BaseFileSystem} fileSystem file system</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{number} duration duration in ms files are cached</span>
	 <span class="s0">*/</span>
	<span class="s1">constructor(fileSystem, duration) {</span>
		<span class="s3">this</span><span class="s1">.fileSystem = fileSystem;</span>

		<span class="s3">this</span><span class="s1">._lstatBackend = createBackend(</span>
			<span class="s1">duration,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.lstat,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.lstatSync,</span>
			<span class="s3">this</span><span class="s1">.fileSystem,</span>
		<span class="s1">);</span>
		<span class="s3">const </span><span class="s1">lstat = </span><span class="s3">this</span><span class="s1">._lstatBackend.provide;</span>
		<span class="s3">this</span><span class="s1">.lstat = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{FileSystem[&quot;lstat&quot;]} */ </span><span class="s1">(lstat);</span>
		<span class="s3">const </span><span class="s1">lstatSync = </span><span class="s3">this</span><span class="s1">._lstatBackend.provideSync;</span>
		<span class="s3">this</span><span class="s1">.lstatSync = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{SyncFileSystem[&quot;lstatSync&quot;]} */ </span><span class="s1">(lstatSync);</span>

		<span class="s3">this</span><span class="s1">._statBackend = createBackend(</span>
			<span class="s1">duration,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.stat,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.statSync,</span>
			<span class="s3">this</span><span class="s1">.fileSystem,</span>
		<span class="s1">);</span>
		<span class="s3">const </span><span class="s1">stat = </span><span class="s3">this</span><span class="s1">._statBackend.provide;</span>
		<span class="s3">this</span><span class="s1">.stat = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{FileSystem[&quot;stat&quot;]} */ </span><span class="s1">(stat);</span>
		<span class="s3">const </span><span class="s1">statSync = </span><span class="s3">this</span><span class="s1">._statBackend.provideSync;</span>
		<span class="s3">this</span><span class="s1">.statSync = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{SyncFileSystem[&quot;statSync&quot;]} */ </span><span class="s1">(statSync);</span>

		<span class="s3">this</span><span class="s1">._readdirBackend = createBackend(</span>
			<span class="s1">duration,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.readdir,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.readdirSync,</span>
			<span class="s3">this</span><span class="s1">.fileSystem,</span>
		<span class="s1">);</span>
		<span class="s3">const </span><span class="s1">readdir = </span><span class="s3">this</span><span class="s1">._readdirBackend.provide;</span>
		<span class="s3">this</span><span class="s1">.readdir = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{FileSystem[&quot;readdir&quot;]} */ </span><span class="s1">(readdir);</span>
		<span class="s3">const </span><span class="s1">readdirSync = </span><span class="s3">this</span><span class="s1">._readdirBackend.provideSync;</span>
		<span class="s3">this</span><span class="s1">.readdirSync = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{SyncFileSystem[&quot;readdirSync&quot;]} */ </span><span class="s1">(</span>
			<span class="s1">readdirSync</span>
		<span class="s1">);</span>

		<span class="s3">this</span><span class="s1">._readFileBackend = createBackend(</span>
			<span class="s1">duration,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.readFile,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.readFileSync,</span>
			<span class="s3">this</span><span class="s1">.fileSystem,</span>
		<span class="s1">);</span>
		<span class="s3">const </span><span class="s1">readFile = </span><span class="s3">this</span><span class="s1">._readFileBackend.provide;</span>
		<span class="s3">this</span><span class="s1">.readFile = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{FileSystem[&quot;readFile&quot;]} */ </span><span class="s1">(readFile);</span>
		<span class="s3">const </span><span class="s1">readFileSync = </span><span class="s3">this</span><span class="s1">._readFileBackend.provideSync;</span>
		<span class="s3">this</span><span class="s1">.readFileSync = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{SyncFileSystem[&quot;readFileSync&quot;]} */ </span><span class="s1">(</span>
			<span class="s1">readFileSync</span>
		<span class="s1">);</span>

		<span class="s3">this</span><span class="s1">._readJsonBackend = createBackend(</span>
			<span class="s1">duration,</span>
			<span class="s0">// prettier-ignore</span>
			<span class="s3">this</span><span class="s1">.fileSystem.readJson ||</span>
				<span class="s1">(</span><span class="s3">this</span><span class="s1">.readFile &amp;&amp;</span>
					<span class="s1">(</span>
						<span class="s0">/**</span>
						 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} path path</span>
						 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{FileSystemCallback&lt;EXPECTED_ANY&gt;} callback callback</span>
						 <span class="s0">*/</span>
						<span class="s1">(path, callback) =&gt; {</span>
							<span class="s3">this</span><span class="s1">.readFile(path, (err, buffer) =&gt; {</span>
								<span class="s3">if </span><span class="s1">(err) </span><span class="s3">return </span><span class="s1">callback(err);</span>
								<span class="s3">if </span><span class="s1">(!buffer || buffer.length === </span><span class="s5">0</span><span class="s1">)</span>
									<span class="s1">{</span><span class="s3">return </span><span class="s1">callback(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">&quot;No file content&quot;</span><span class="s1">));}</span>
								<span class="s3">let </span><span class="s1">data;</span>
								<span class="s3">try </span><span class="s1">{</span>
									<span class="s1">data = JSON.parse(buffer.toString(</span><span class="s2">&quot;utf8&quot;</span><span class="s1">));</span>
								<span class="s1">} </span><span class="s3">catch </span><span class="s1">(err_) {</span>
									<span class="s3">return </span><span class="s1">callback(</span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{Error} */ </span><span class="s1">(err_));</span>
								<span class="s1">}</span>
								<span class="s1">callback(</span><span class="s3">null</span><span class="s1">, data);</span>
							<span class="s1">});</span>
						<span class="s1">})</span>
				<span class="s1">),</span>
			<span class="s0">// prettier-ignore</span>
			<span class="s3">this</span><span class="s1">.fileSystem.readJsonSync ||</span>
				<span class="s1">(</span><span class="s3">this</span><span class="s1">.readFileSync &amp;&amp;</span>
					<span class="s1">(</span>
						<span class="s0">/**</span>
						 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} path path</span>
						 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{EXPECTED_ANY} result</span>
						 <span class="s0">*/</span>
						<span class="s1">(path) =&gt; {</span>
							<span class="s3">const </span><span class="s1">buffer = </span><span class="s3">this</span><span class="s1">.readFileSync(path);</span>
							<span class="s3">const </span><span class="s1">data = JSON.parse(buffer.toString(</span><span class="s2">&quot;utf8&quot;</span><span class="s1">));</span>
							<span class="s3">return </span><span class="s1">data;</span>
						<span class="s1">}</span>
				 <span class="s1">)),</span>
			<span class="s3">this</span><span class="s1">.fileSystem,</span>
		<span class="s1">);</span>
		<span class="s3">const </span><span class="s1">readJson = </span><span class="s3">this</span><span class="s1">._readJsonBackend.provide;</span>
		<span class="s3">this</span><span class="s1">.readJson = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{FileSystem[&quot;readJson&quot;]} */ </span><span class="s1">(readJson);</span>
		<span class="s3">const </span><span class="s1">readJsonSync = </span><span class="s3">this</span><span class="s1">._readJsonBackend.provideSync;</span>
		<span class="s3">this</span><span class="s1">.readJsonSync = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{SyncFileSystem[&quot;readJsonSync&quot;]} */ </span><span class="s1">(</span>
			<span class="s1">readJsonSync</span>
		<span class="s1">);</span>

		<span class="s3">this</span><span class="s1">._readlinkBackend = createBackend(</span>
			<span class="s1">duration,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.readlink,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.readlinkSync,</span>
			<span class="s3">this</span><span class="s1">.fileSystem,</span>
		<span class="s1">);</span>
		<span class="s3">const </span><span class="s1">readlink = </span><span class="s3">this</span><span class="s1">._readlinkBackend.provide;</span>
		<span class="s3">this</span><span class="s1">.readlink = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{FileSystem[&quot;readlink&quot;]} */ </span><span class="s1">(readlink);</span>
		<span class="s3">const </span><span class="s1">readlinkSync = </span><span class="s3">this</span><span class="s1">._readlinkBackend.provideSync;</span>
		<span class="s3">this</span><span class="s1">.readlinkSync = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{SyncFileSystem[&quot;readlinkSync&quot;]} */ </span><span class="s1">(</span>
			<span class="s1">readlinkSync</span>
		<span class="s1">);</span>

		<span class="s3">this</span><span class="s1">._realpathBackend = createBackend(</span>
			<span class="s1">duration,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.realpath,</span>
			<span class="s3">this</span><span class="s1">.fileSystem.realpathSync,</span>
			<span class="s3">this</span><span class="s1">.fileSystem,</span>
		<span class="s1">);</span>
		<span class="s3">const </span><span class="s1">realpath = </span><span class="s3">this</span><span class="s1">._realpathBackend.provide;</span>
		<span class="s3">this</span><span class="s1">.realpath = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{FileSystem[&quot;realpath&quot;]} */ </span><span class="s1">(realpath);</span>
		<span class="s3">const </span><span class="s1">realpathSync = </span><span class="s3">this</span><span class="s1">._realpathBackend.provideSync;</span>
		<span class="s3">this</span><span class="s1">.realpathSync = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{SyncFileSystem[&quot;realpathSync&quot;]} */ </span><span class="s1">(</span>
			<span class="s1">realpathSync</span>
		<span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{(string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set&lt;string | URL | Buffer | number&gt;)=} what what to purge</span>
	 <span class="s0">*/</span>
	<span class="s1">purge(what) {</span>
		<span class="s3">this</span><span class="s1">._statBackend.purge(what);</span>
		<span class="s3">this</span><span class="s1">._lstatBackend.purge(what);</span>
		<span class="s3">this</span><span class="s1">._readdirBackend.purgeParent(what);</span>
		<span class="s3">this</span><span class="s1">._readFileBackend.purge(what);</span>
		<span class="s3">this</span><span class="s1">._readlinkBackend.purge(what);</span>
		<span class="s3">this</span><span class="s1">._readJsonBackend.purge(what);</span>
		<span class="s3">this</span><span class="s1">._realpathBackend.purge(what);</span>
	<span class="s1">}</span>
<span class="s1">};</span>
</pre>
</body>
</html>