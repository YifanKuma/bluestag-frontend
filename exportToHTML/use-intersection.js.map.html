<html>
<head>
<title>use-intersection.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
use-intersection.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/client/use-intersection.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { useCallback, useEffect, useRef, useState } from 'react'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">requestIdleCallback,</span><span class="s3">\n  </span><span class="s1">cancelIdleCallback,</span><span class="s3">\n</span><span class="s1">} from './request-idle-callback'</span><span class="s3">\n\n</span><span class="s1">type UseIntersectionObserverInit = Pick&lt;</span><span class="s3">\n  </span><span class="s1">IntersectionObserverInit,</span><span class="s3">\n  </span><span class="s1">'rootMargin' | 'root'</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">type UseIntersection = { disabled?: boolean } &amp; UseIntersectionObserverInit &amp; {</span><span class="s3">\n    </span><span class="s1">rootRef?: React.RefObject&lt;HTMLElement | null&gt; | null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">type ObserveCallback = (isVisible: boolean) =&gt; void</span><span class="s3">\n</span><span class="s1">type Identifier = {</span><span class="s3">\n  </span><span class="s1">root: Element | Document | null</span><span class="s3">\n  </span><span class="s1">margin: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">type Observer = {</span><span class="s3">\n  </span><span class="s1">id: Identifier</span><span class="s3">\n  </span><span class="s1">observer: IntersectionObserver</span><span class="s3">\n  </span><span class="s1">elements: Map&lt;Element, ObserveCallback&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const hasIntersectionObserver = typeof IntersectionObserver === 'function'</span><span class="s3">\n\n</span><span class="s1">const observers = new Map&lt;Identifier, Observer&gt;()</span><span class="s3">\n</span><span class="s1">const idList: Identifier[] = []</span><span class="s3">\n\n</span><span class="s1">function createObserver(options: UseIntersectionObserverInit): Observer {</span><span class="s3">\n  </span><span class="s1">const id = {</span><span class="s3">\n    </span><span class="s1">root: options.root || null,</span><span class="s3">\n    </span><span class="s1">margin: options.rootMargin || '',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const existing = idList.find(</span><span class="s3">\n    </span><span class="s1">(obj) =&gt; obj.root === id.root &amp;&amp; obj.margin === id.margin</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">let instance: Observer | undefined</span><span class="s3">\n\n  </span><span class="s1">if (existing) {</span><span class="s3">\n    </span><span class="s1">instance = observers.get(existing)</span><span class="s3">\n    </span><span class="s1">if (instance) {</span><span class="s3">\n      </span><span class="s1">return instance</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const elements = new Map&lt;Element, ObserveCallback&gt;()</span><span class="s3">\n  </span><span class="s1">const observer = new IntersectionObserver((entries) =&gt; {</span><span class="s3">\n    </span><span class="s1">entries.forEach((entry) =&gt; {</span><span class="s3">\n      </span><span class="s1">const callback = elements.get(entry.target)</span><span class="s3">\n      </span><span class="s1">const isVisible = entry.isIntersecting || entry.intersectionRatio &gt; 0</span><span class="s3">\n      </span><span class="s1">if (callback &amp;&amp; isVisible) {</span><span class="s3">\n        </span><span class="s1">callback(isVisible)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}, options)</span><span class="s3">\n  </span><span class="s1">instance = {</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">observer,</span><span class="s3">\n    </span><span class="s1">elements,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">idList.push(id)</span><span class="s3">\n  </span><span class="s1">observers.set(id, instance)</span><span class="s3">\n  </span><span class="s1">return instance</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function observe(</span><span class="s3">\n  </span><span class="s1">element: Element,</span><span class="s3">\n  </span><span class="s1">callback: ObserveCallback,</span><span class="s3">\n  </span><span class="s1">options: UseIntersectionObserverInit</span><span class="s3">\n</span><span class="s1">): () =&gt; void {</span><span class="s3">\n  </span><span class="s1">const { id, observer, elements } = createObserver(options)</span><span class="s3">\n  </span><span class="s1">elements.set(element, callback)</span><span class="s3">\n\n  </span><span class="s1">observer.observe(element)</span><span class="s3">\n  </span><span class="s1">return function unobserve(): void {</span><span class="s3">\n    </span><span class="s1">elements.delete(element)</span><span class="s3">\n    </span><span class="s1">observer.unobserve(element)</span><span class="s3">\n\n    </span><span class="s1">// Destroy observer when there's nothing left to watch:</span><span class="s3">\n    </span><span class="s1">if (elements.size === 0) {</span><span class="s3">\n      </span><span class="s1">observer.disconnect()</span><span class="s3">\n      </span><span class="s1">observers.delete(id)</span><span class="s3">\n      </span><span class="s1">const index = idList.findIndex(</span><span class="s3">\n        </span><span class="s1">(obj) =&gt; obj.root === id.root &amp;&amp; obj.margin === id.margin</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (index &gt; -1) {</span><span class="s3">\n        </span><span class="s1">idList.splice(index, 1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function useIntersection&lt;T extends Element&gt;({</span><span class="s3">\n  </span><span class="s1">rootRef,</span><span class="s3">\n  </span><span class="s1">rootMargin,</span><span class="s3">\n  </span><span class="s1">disabled,</span><span class="s3">\n</span><span class="s1">}: UseIntersection): [(element: T | null) =&gt; void, boolean, () =&gt; void] {</span><span class="s3">\n  </span><span class="s1">const isDisabled: boolean = disabled || !hasIntersectionObserver</span><span class="s3">\n\n  </span><span class="s1">const [visible, setVisible] = useState(false)</span><span class="s3">\n  </span><span class="s1">const elementRef = useRef&lt;T | null&gt;(null)</span><span class="s3">\n  </span><span class="s1">const setElement = useCallback((element: T | null) =&gt; {</span><span class="s3">\n    </span><span class="s1">elementRef.current = element</span><span class="s3">\n  </span><span class="s1">}, [])</span><span class="s3">\n\n  </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n    </span><span class="s1">if (hasIntersectionObserver) {</span><span class="s3">\n      </span><span class="s1">if (isDisabled || visible) return</span><span class="s3">\n\n      </span><span class="s1">const element = elementRef.current</span><span class="s3">\n      </span><span class="s1">if (element &amp;&amp; element.tagName) {</span><span class="s3">\n        </span><span class="s1">const unobserve = observe(</span><span class="s3">\n          </span><span class="s1">element,</span><span class="s3">\n          </span><span class="s1">(isVisible) =&gt; isVisible &amp;&amp; setVisible(isVisible),</span><span class="s3">\n          </span><span class="s1">{ root: rootRef?.current, rootMargin }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">return unobserve</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (!visible) {</span><span class="s3">\n        </span><span class="s1">const idleCallback = requestIdleCallback(() =&gt; setVisible(true))</span><span class="s3">\n        </span><span class="s1">return () =&gt; cancelIdleCallback(idleCallback)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line react-hooks/exhaustive-deps</span><span class="s3">\n  </span><span class="s1">}, [isDisabled, rootMargin, rootRef, visible, elementRef.current])</span><span class="s3">\n\n  </span><span class="s1">const resetVisible = useCallback(() =&gt; {</span><span class="s3">\n    </span><span class="s1">setVisible(false)</span><span class="s3">\n  </span><span class="s1">}, [])</span><span class="s3">\n\n  </span><span class="s1">return [setElement, visible, resetVisible]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;useIntersection&quot;</span><span class="s0">,</span><span class="s1">&quot;hasIntersectionObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;IntersectionObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;observers&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;idList&quot;</span><span class="s0">,</span><span class="s1">&quot;createObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;root&quot;</span><span class="s0">,</span><span class="s1">&quot;margin&quot;</span><span class="s0">,</span><span class="s1">&quot;rootMargin&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;elements&quot;</span><span class="s0">,</span><span class="s1">&quot;observer&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;isVisible&quot;</span><span class="s0">,</span><span class="s1">&quot;isIntersecting&quot;</span><span class="s0">,</span><span class="s1">&quot;intersectionRatio&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;observe&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;unobserve&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;disconnect&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;findIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;rootRef&quot;</span><span class="s0">,</span><span class="s1">&quot;disabled&quot;</span><span class="s0">,</span><span class="s1">&quot;isDisabled&quot;</span><span class="s0">,</span><span class="s1">&quot;visible&quot;</span><span class="s0">,</span><span class="s1">&quot;setVisible&quot;</span><span class="s0">,</span><span class="s1">&quot;useState&quot;</span><span class="s0">,</span><span class="s1">&quot;elementRef&quot;</span><span class="s0">,</span><span class="s1">&quot;useRef&quot;</span><span class="s0">,</span><span class="s1">&quot;setElement&quot;</span><span class="s0">,</span><span class="s1">&quot;useCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;useEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;tagName&quot;</span><span class="s0">,</span><span class="s1">&quot;idleCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;requestIdleCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelIdleCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;resetVisible&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>