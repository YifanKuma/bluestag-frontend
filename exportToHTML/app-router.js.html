<html>
<head>
<title>app-router.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app-router.js</font>
</center></td></tr></table>
<pre><span class="s0">'use client'</span><span class="s1">;</span>
<span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">createEmptyCacheNode: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createPrefetchURL: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">isExternalURL: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">createEmptyCacheNode: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createEmptyCacheNode;</span>
    <span class="s1">},</span>
    <span class="s1">createPrefetchURL: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createPrefetchURL;</span>
    <span class="s1">},</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">AppRouter;</span>
    <span class="s1">},</span>
    <span class="s1">isExternalURL: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">isExternalURL;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_interop_require_default = require(</span><span class="s0">&quot;@swc/helpers/_/_interop_require_default&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_interop_require_wildcard = require(</span><span class="s0">&quot;@swc/helpers/_/_interop_require_wildcard&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_jsxruntime = require(</span><span class="s0">&quot;react/jsx-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_react = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard._(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_approutercontextsharedruntime = require(</span><span class="s0">&quot;../../shared/lib/app-router-context.shared-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerreducertypes = require(</span><span class="s0">&quot;./router-reducer/router-reducer-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createhreffromurl = require(</span><span class="s0">&quot;./router-reducer/create-href-from-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hooksclientcontextsharedruntime = require(</span><span class="s0">&quot;../../shared/lib/hooks-client-context.shared-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_useactionqueue = require(</span><span class="s0">&quot;./use-action-queue&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isbot = require(</span><span class="s0">&quot;../../shared/lib/router/utils/is-bot&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_addbasepath = require(</span><span class="s0">&quot;../add-base-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterannouncer = require(</span><span class="s0">&quot;./app-router-announcer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirectboundary = require(</span><span class="s0">&quot;./redirect-boundary&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_findheadincache = require(</span><span class="s0">&quot;./router-reducer/reducers/find-head-in-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_unresolvedthenable = require(</span><span class="s0">&quot;./unresolved-thenable&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removebasepath = require(</span><span class="s0">&quot;../remove-base-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hasbasepath = require(</span><span class="s0">&quot;../has-base-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_computechangedpath = require(</span><span class="s0">&quot;./router-reducer/compute-changed-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_navfailurehandler = require(</span><span class="s0">&quot;./nav-failure-handler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterinstance = require(</span><span class="s0">&quot;./app-router-instance&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirect = require(</span><span class="s0">&quot;./redirect&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirecterror = require(</span><span class="s0">&quot;./redirect-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_links = require(</span><span class="s0">&quot;./links&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_rooterrorboundary = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default._(require(</span><span class="s0">&quot;./errors/root-error-boundary&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_globalerror = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default._(require(</span><span class="s0">&quot;./builtin/global-error&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_boundarycomponents = require(</span><span class="s0">&quot;../../lib/framework/boundary-components&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">globalMutable = {};</span>
<span class="s2">function </span><span class="s1">isExternalURL(url) {</span>
    <span class="s2">return </span><span class="s1">url.origin !== window.location.origin;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPrefetchURL(href) {</span>
    <span class="s4">// Don't prefetch for bots as they don't navigate.</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isbot.isBot)(window.navigator.userAgent)) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">url;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">url = </span><span class="s2">new </span><span class="s1">URL((</span><span class="s3">0</span><span class="s1">, _addbasepath.addBasePath)(href), window.location.href);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_) {</span>
        <span class="s4">// TODO: Does this need to throw or can we just console.error instead? Does</span>
        <span class="s4">// anyone rely on this throwing? (Seems unlikely.)</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;Cannot prefetch '&quot; </span><span class="s1">+ href + </span><span class="s0">&quot;' because it cannot be converted to a URL.&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E234&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">// Don't prefetch during development (improves compilation performance)</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// External urls can't be prefetched in the same way.</span>
    <span class="s2">if </span><span class="s1">(isExternalURL(url)) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">url;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">HistoryUpdater(param) {</span>
    <span class="s2">let </span><span class="s1">{ appRouterState } = param;</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useInsertionEffect)(()=&gt;{</span>
        <span class="s2">if </span><span class="s1">(process.env.__NEXT_APP_NAV_FAIL_HANDLING) {</span>
            <span class="s4">// clear pending URL as navigation is no longer</span>
            <span class="s4">// in flight</span>
            <span class="s1">window.next.__pendingUrl = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ tree, pushRef, canonicalUrl } = appRouterState;</span>
        <span class="s2">const </span><span class="s1">historyState = {</span>
            <span class="s1">...pushRef.preserveCustomHistoryState ? window.history.state : {},</span>
            <span class="s4">// Identifier is shortened intentionally.</span>
            <span class="s4">// __NA is used to identify if the history entry can be handled by the app-router.</span>
            <span class="s4">// __N is used to identify if the history entry can be handled by the old router.</span>
            <span class="s1">__NA: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">__PRIVATE_NEXTJS_INTERNALS_TREE: tree</span>
        <span class="s1">};</span>
        <span class="s2">if </span><span class="s1">(pushRef.pendingPush &amp;&amp; </span><span class="s4">// Skip pushing an additional history entry if the canonicalUrl is the same as the current url.</span>
        <span class="s4">// This mirrors the browser behavior for normal navigation.</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _createhreffromurl.createHrefFromUrl)(</span><span class="s2">new </span><span class="s1">URL(window.location.href)) !== canonicalUrl) {</span>
            <span class="s4">// This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.</span>
            <span class="s1">pushRef.pendingPush = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">window.history.pushState(historyState, </span><span class="s0">''</span><span class="s1">, canonicalUrl);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">window.history.replaceState(historyState, </span><span class="s0">''</span><span class="s1">, canonicalUrl);</span>
        <span class="s1">}</span>
    <span class="s1">}, [</span>
        <span class="s1">appRouterState</span>
    <span class="s1">]);</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useEffect)(()=&gt;{</span>
        <span class="s4">// The Next-Url and the base tree may affect the result of a prefetch</span>
        <span class="s4">// task. Re-prefetch all visible links with the updated values. In most</span>
        <span class="s4">// cases, this will not result in any new network requests, only if</span>
        <span class="s4">// the prefetch result actually varies on one of these inputs.</span>
        <span class="s2">if </span><span class="s1">(process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _links.pingVisibleLinks)(appRouterState.nextUrl, appRouterState.tree);</span>
        <span class="s1">}</span>
    <span class="s1">}, [</span>
        <span class="s1">appRouterState.nextUrl,</span>
        <span class="s1">appRouterState.tree</span>
    <span class="s1">]);</span>
    <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createEmptyCacheNode() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">lazyData: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">rsc: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">prefetchRsc: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">head: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">prefetchHead: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">parallelRoutes: </span><span class="s2">new </span><span class="s1">Map(),</span>
        <span class="s1">loading: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">navigatedAt: -</span><span class="s3">1</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">copyNextJsInternalHistoryState(data) {</span>
    <span class="s2">if </span><span class="s1">(data == </span><span class="s2">null</span><span class="s1">) data = {};</span>
    <span class="s2">const </span><span class="s1">currentState = window.history.state;</span>
    <span class="s2">const </span><span class="s1">__NA = currentState == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: currentState.__NA;</span>
    <span class="s2">if </span><span class="s1">(__NA) {</span>
        <span class="s1">data.__NA = __NA;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">__PRIVATE_NEXTJS_INTERNALS_TREE = currentState == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;</span>
    <span class="s2">if </span><span class="s1">(__PRIVATE_NEXTJS_INTERNALS_TREE) {</span>
        <span class="s1">data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">Head(param) {</span>
    <span class="s2">let </span><span class="s1">{ headCacheNode } = param;</span>
    <span class="s4">// If this segment has a `prefetchHead`, it's the statically prefetched data.</span>
    <span class="s4">// We should use that on initial render instead of `head`. Then we'll switch</span>
    <span class="s4">// to `head` when the dynamic response streams in.</span>
    <span class="s2">const </span><span class="s1">head = headCacheNode !== </span><span class="s2">null </span><span class="s1">? headCacheNode.head : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">prefetchHead = headCacheNode !== </span><span class="s2">null </span><span class="s1">? headCacheNode.prefetchHead : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">// If no prefetch data is available, then we go straight to rendering `head`.</span>
    <span class="s2">const </span><span class="s1">resolvedPrefetchRsc = prefetchHead !== </span><span class="s2">null </span><span class="s1">? prefetchHead : head;</span>
    <span class="s4">// We use `useDeferredValue` to handle switching between the prefetched and</span>
    <span class="s4">// final values. The second argument is returned on initial render, then it</span>
    <span class="s4">// re-renders with the first argument.</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useDeferredValue)(head, resolvedPrefetchRsc);</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* The global router that wraps the application components.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">Router(param) {</span>
    <span class="s2">let </span><span class="s1">{ actionQueue, assetPrefix, globalError } = param;</span>
    <span class="s2">const </span><span class="s1">state = (</span><span class="s3">0</span><span class="s1">, _useactionqueue.useActionQueue)(actionQueue);</span>
    <span class="s2">const </span><span class="s1">{ canonicalUrl } = state;</span>
    <span class="s4">// Add memoized pathname/query for useSearchParams and usePathname.</span>
    <span class="s2">const </span><span class="s1">{ searchParams, pathname } = (</span><span class="s3">0</span><span class="s1">, _react.useMemo)(()=&gt;{</span>
        <span class="s2">const </span><span class="s1">url = </span><span class="s2">new </span><span class="s1">URL(canonicalUrl, </span><span class="s2">typeof </span><span class="s1">window === </span><span class="s0">'undefined' </span><span class="s1">? </span><span class="s0">'http://n' </span><span class="s1">: window.location.href);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s4">// This is turned into a readonly class in `useSearchParams`</span>
            <span class="s1">searchParams: url.searchParams,</span>
            <span class="s1">pathname: (</span><span class="s3">0</span><span class="s1">, _hasbasepath.hasBasePath)(url.pathname) ? (</span><span class="s3">0</span><span class="s1">, _removebasepath.removeBasePath)(url.pathname) : url.pathname</span>
        <span class="s1">};</span>
    <span class="s1">}, [</span>
        <span class="s1">canonicalUrl</span>
    <span class="s1">]);</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production'</span><span class="s1">) {</span>
        <span class="s4">// eslint-disable-next-line react-hooks/rules-of-hooks</span>
        <span class="s2">const </span><span class="s1">{ cache, prefetchCache, tree } = state;</span>
        <span class="s4">// This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes</span>
        <span class="s4">// eslint-disable-next-line react-hooks/rules-of-hooks</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useEffect)(()=&gt;{</span>
            <span class="s4">// Add `window.nd` for debugging purposes.</span>
            <span class="s4">// This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.</span>
            <span class="s4">// @ts-ignore this is for debugging</span>
            <span class="s1">window.nd = {</span>
                <span class="s1">router: _approuterinstance.publicAppRouterInstance,</span>
                <span class="s1">cache,</span>
                <span class="s1">prefetchCache,</span>
                <span class="s1">tree</span>
            <span class="s1">};</span>
        <span class="s1">}, [</span>
            <span class="s1">cache,</span>
            <span class="s1">prefetchCache,</span>
            <span class="s1">tree</span>
        <span class="s1">]);</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useEffect)(()=&gt;{</span>
        <span class="s4">// If the app is restored from bfcache, it's possible that</span>
        <span class="s4">// pushRef.mpaNavigation is true, which would mean that any re-render of this component</span>
        <span class="s4">// would trigger the mpa navigation logic again from the lines below.</span>
        <span class="s4">// This will restore the router to the initial state in the event that the app is restored from bfcache.</span>
        <span class="s2">function </span><span class="s1">handlePageShow(event) {</span>
            <span class="s2">var </span><span class="s1">_window_history_state;</span>
            <span class="s2">if </span><span class="s1">(!event.persisted || !((_window_history_state = window.history.state) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.</span>
            <span class="s4">// This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value</span>
            <span class="s4">// of the last MPA navigation.</span>
            <span class="s1">globalMutable.pendingMpaPath = undefined;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _useactionqueue.dispatchAppRouterAction)({</span>
                <span class="s1">type: _routerreducertypes.ACTION_RESTORE,</span>
                <span class="s1">url: </span><span class="s2">new </span><span class="s1">URL(window.location.href),</span>
                <span class="s1">tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">window.addEventListener(</span><span class="s0">'pageshow'</span><span class="s1">, handlePageShow);</span>
        <span class="s2">return </span><span class="s1">()=&gt;{</span>
            <span class="s1">window.removeEventListener(</span><span class="s0">'pageshow'</span><span class="s1">, handlePageShow);</span>
        <span class="s1">};</span>
    <span class="s1">}, []);</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useEffect)(()=&gt;{</span>
        <span class="s4">// Ensure that any redirect errors that bubble up outside of the RedirectBoundary</span>
        <span class="s4">// are caught and handled by the router.</span>
        <span class="s2">function </span><span class="s1">handleUnhandledRedirect(event) {</span>
            <span class="s2">const </span><span class="s1">error = </span><span class="s0">'reason' </span><span class="s2">in </span><span class="s1">event ? event.reason : event.error;</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _redirecterror.isRedirectError)(error)) {</span>
                <span class="s1">event.preventDefault();</span>
                <span class="s2">const </span><span class="s1">url = (</span><span class="s3">0</span><span class="s1">, _redirect.getURLFromRedirectError)(error);</span>
                <span class="s2">const </span><span class="s1">redirectType = (</span><span class="s3">0</span><span class="s1">, _redirect.getRedirectTypeFromError)(error);</span>
                <span class="s4">// TODO: This should access the router methods directly, rather than</span>
                <span class="s4">// go through the public interface.</span>
                <span class="s2">if </span><span class="s1">(redirectType === _redirecterror.RedirectType.push) {</span>
                    <span class="s1">_approuterinstance.publicAppRouterInstance.push(url, {});</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">_approuterinstance.publicAppRouterInstance.replace(url, {});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">window.addEventListener(</span><span class="s0">'error'</span><span class="s1">, handleUnhandledRedirect);</span>
        <span class="s1">window.addEventListener(</span><span class="s0">'unhandledrejection'</span><span class="s1">, handleUnhandledRedirect);</span>
        <span class="s2">return </span><span class="s1">()=&gt;{</span>
            <span class="s1">window.removeEventListener(</span><span class="s0">'error'</span><span class="s1">, handleUnhandledRedirect);</span>
            <span class="s1">window.removeEventListener(</span><span class="s0">'unhandledrejection'</span><span class="s1">, handleUnhandledRedirect);</span>
        <span class="s1">};</span>
    <span class="s1">}, []);</span>
    <span class="s4">// When mpaNavigation flag is set do a hard navigation to the new url.</span>
    <span class="s4">// Infinitely suspend because we don't actually want to rerender any child</span>
    <span class="s4">// components with the new URL and any entangled state updates shouldn't</span>
    <span class="s4">// commit either (eg: useTransition isPending should stay true until the page</span>
    <span class="s4">// unloads).</span>
    <span class="s4">//</span>
    <span class="s4">// This is a side effect in render. Don't try this at home, kids. It's</span>
    <span class="s4">// probably safe because we know this is a singleton component and it's never</span>
    <span class="s4">// in &lt;Offscreen&gt;. At least I hope so. (It will run twice in dev strict mode,</span>
    <span class="s4">// but that's... fine?)</span>
    <span class="s2">const </span><span class="s1">{ pushRef } = state;</span>
    <span class="s2">if </span><span class="s1">(pushRef.mpaNavigation) {</span>
        <span class="s4">// if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL</span>
        <span class="s2">if </span><span class="s1">(globalMutable.pendingMpaPath !== canonicalUrl) {</span>
            <span class="s2">const </span><span class="s1">location = window.location;</span>
            <span class="s2">if </span><span class="s1">(pushRef.pendingPush) {</span>
                <span class="s1">location.assign(canonicalUrl);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">location.replace(canonicalUrl);</span>
            <span class="s1">}</span>
            <span class="s1">globalMutable.pendingMpaPath = canonicalUrl;</span>
        <span class="s1">}</span>
        <span class="s4">// TODO-APP: Should we listen to navigateerror here to catch failed</span>
        <span class="s4">// navigations somehow? And should we call window.stop() if a SPA navigation</span>
        <span class="s4">// should interrupt an MPA one?</span>
        <span class="s4">// NOTE: This is intentionally using `throw` instead of `use` because we're</span>
        <span class="s4">// inside an externally mutable condition (pushRef.mpaNavigation), which</span>
        <span class="s4">// violates the rules of hooks.</span>
        <span class="s2">throw </span><span class="s1">_unresolvedthenable.unresolvedThenable;</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useEffect)(()=&gt;{</span>
        <span class="s2">const </span><span class="s1">originalPushState = window.history.pushState.bind(window.history);</span>
        <span class="s2">const </span><span class="s1">originalReplaceState = window.history.replaceState.bind(window.history);</span>
        <span class="s4">// Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.</span>
        <span class="s2">const </span><span class="s1">applyUrlFromHistoryPushReplace = (url)=&gt;{</span>
            <span class="s2">var </span><span class="s1">_window_history_state;</span>
            <span class="s2">const </span><span class="s1">href = window.location.href;</span>
            <span class="s2">const </span><span class="s1">tree = (_window_history_state = window.history.state) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.startTransition)(()=&gt;{</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _useactionqueue.dispatchAppRouterAction)({</span>
                    <span class="s1">type: _routerreducertypes.ACTION_RESTORE,</span>
                    <span class="s1">url: </span><span class="s2">new </span><span class="s1">URL(url != </span><span class="s2">null </span><span class="s1">? url : href, href),</span>
                    <span class="s1">tree</span>
                <span class="s1">});</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
        <span class="s4">/**</span>
     <span class="s4">* Patch pushState to ensure external changes to the history are reflected in the Next.js Router.</span>
     <span class="s4">* Ensures Next.js internal history state is copied to the new history entry.</span>
     <span class="s4">* Ensures usePathname and useSearchParams hold the newly provided url.</span>
     <span class="s4">*/ </span><span class="s1">window.history.pushState = </span><span class="s2">function </span><span class="s1">pushState(data, _unused, url) {</span>
            <span class="s4">// Avoid a loop when Next.js internals trigger pushState/replaceState</span>
            <span class="s2">if </span><span class="s1">((data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: data.__NA) || (data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: data._N)) {</span>
                <span class="s2">return </span><span class="s1">originalPushState(data, _unused, url);</span>
            <span class="s1">}</span>
            <span class="s1">data = copyNextJsInternalHistoryState(data);</span>
            <span class="s2">if </span><span class="s1">(url) {</span>
                <span class="s1">applyUrlFromHistoryPushReplace(url);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">originalPushState(data, _unused, url);</span>
        <span class="s1">};</span>
        <span class="s4">/**</span>
     <span class="s4">* Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.</span>
     <span class="s4">* Ensures Next.js internal history state is copied to the new history entry.</span>
     <span class="s4">* Ensures usePathname and useSearchParams hold the newly provided url.</span>
     <span class="s4">*/ </span><span class="s1">window.history.replaceState = </span><span class="s2">function </span><span class="s1">replaceState(data, _unused, url) {</span>
            <span class="s4">// Avoid a loop when Next.js internals trigger pushState/replaceState</span>
            <span class="s2">if </span><span class="s1">((data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: data.__NA) || (data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: data._N)) {</span>
                <span class="s2">return </span><span class="s1">originalReplaceState(data, _unused, url);</span>
            <span class="s1">}</span>
            <span class="s1">data = copyNextJsInternalHistoryState(data);</span>
            <span class="s2">if </span><span class="s1">(url) {</span>
                <span class="s1">applyUrlFromHistoryPushReplace(url);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">originalReplaceState(data, _unused, url);</span>
        <span class="s1">};</span>
        <span class="s4">/**</span>
     <span class="s4">* Handle popstate event, this is used to handle back/forward in the browser.</span>
     <span class="s4">* By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.</span>
     <span class="s4">* That case can happen when the old router injected the history entry.</span>
     <span class="s4">*/ </span><span class="s2">const </span><span class="s1">onPopState = (event)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(!event.state) {</span>
                <span class="s4">// TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// This case happens when the history entry was pushed by the `pages` router.</span>
            <span class="s2">if </span><span class="s1">(!event.state.__NA) {</span>
                <span class="s1">window.location.reload();</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously</span>
            <span class="s4">// Without startTransition works if the cache is there for this path</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.startTransition)(()=&gt;{</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
        <span class="s4">// Register popstate event to call onPopstate.</span>
        <span class="s1">window.addEventListener(</span><span class="s0">'popstate'</span><span class="s1">, onPopState);</span>
        <span class="s2">return </span><span class="s1">()=&gt;{</span>
            <span class="s1">window.history.pushState = originalPushState;</span>
            <span class="s1">window.history.replaceState = originalReplaceState;</span>
            <span class="s1">window.removeEventListener(</span><span class="s0">'popstate'</span><span class="s1">, onPopState);</span>
        <span class="s1">};</span>
    <span class="s1">}, []);</span>
    <span class="s2">const </span><span class="s1">{ cache, tree, nextUrl, focusAndScrollRef } = state;</span>
    <span class="s2">const </span><span class="s1">matchingHead = (</span><span class="s3">0</span><span class="s1">, _react.useMemo)(()=&gt;{</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _findheadincache.findHeadInCache)(cache, tree[</span><span class="s3">1</span><span class="s1">]);</span>
    <span class="s1">}, [</span>
        <span class="s1">cache,</span>
        <span class="s1">tree</span>
    <span class="s1">]);</span>
    <span class="s4">// Add memoized pathParams for useParams.</span>
    <span class="s2">const </span><span class="s1">pathParams = (</span><span class="s3">0</span><span class="s1">, _react.useMemo)(()=&gt;{</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _computechangedpath.getSelectedParams)(tree);</span>
    <span class="s1">}, [</span>
        <span class="s1">tree</span>
    <span class="s1">]);</span>
    <span class="s2">const </span><span class="s1">layoutRouterContext = (</span><span class="s3">0</span><span class="s1">, _react.useMemo)(()=&gt;{</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">parentTree: tree,</span>
            <span class="s1">parentCacheNode: cache,</span>
            <span class="s1">parentSegmentPath: </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s4">// Root node always has `url`</span>
            <span class="s4">// Provided in AppTreeContext to ensure it can be overwritten in layout-router</span>
            <span class="s1">url: canonicalUrl</span>
        <span class="s1">};</span>
    <span class="s1">}, [</span>
        <span class="s1">tree,</span>
        <span class="s1">cache,</span>
        <span class="s1">canonicalUrl</span>
    <span class="s1">]);</span>
    <span class="s2">const </span><span class="s1">globalLayoutRouterContext = (</span><span class="s3">0</span><span class="s1">, _react.useMemo)(()=&gt;{</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">tree,</span>
            <span class="s1">focusAndScrollRef,</span>
            <span class="s1">nextUrl</span>
        <span class="s1">};</span>
    <span class="s1">}, [</span>
        <span class="s1">tree,</span>
        <span class="s1">focusAndScrollRef,</span>
        <span class="s1">nextUrl</span>
    <span class="s1">]);</span>
    <span class="s2">let </span><span class="s1">head;</span>
    <span class="s2">if </span><span class="s1">(matchingHead !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s4">// The head is wrapped in an extra component so we can use</span>
        <span class="s4">// `useDeferredValue` to swap between the prefetched and final versions of</span>
        <span class="s4">// the head. (This is what LayoutRouter does for segment data, too.)</span>
        <span class="s4">//</span>
        <span class="s4">// The `key` is used to remount the component whenever the head moves to</span>
        <span class="s4">// a different segment.</span>
        <span class="s2">const </span><span class="s1">[headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead;</span>
        <span class="s1">head = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(Head, {</span>
            <span class="s1">headCacheNode: headCacheNode</span>
        <span class="s1">}, </span><span class="s4">// Necessary for PPR: omit search params from the key to match prerendered keys</span>
        <span class="s2">typeof </span><span class="s1">window === </span><span class="s0">'undefined' </span><span class="s1">? headKeyWithoutSearchParams : headKey);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">head = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">content = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {</span>
        <span class="s1">children: [</span>
            <span class="s1">head,</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_boundarycomponents.RootLayoutBoundary, {</span>
                <span class="s1">children: cache.rsc</span>
            <span class="s1">}),</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {</span>
                <span class="s1">tree: tree</span>
            <span class="s1">})</span>
        <span class="s1">]</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production'</span><span class="s1">) {</span>
        <span class="s4">// In development, we apply few error boundaries and hot-reloader:</span>
        <span class="s4">// - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout</span>
        <span class="s4">// - HotReloader:</span>
        <span class="s4">//  - hot-reload the app when the code changes</span>
        <span class="s4">//  - render dev overlay</span>
        <span class="s4">//  - catch runtime errors and display global-error when necessary</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s0">'undefined'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">{ DevRootHTTPAccessFallbackBoundary } = require(</span><span class="s0">'./dev-root-http-access-fallback-boundary'</span><span class="s1">);</span>
            <span class="s1">content = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {</span>
                <span class="s1">children: content</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">HotReloader = require(</span><span class="s0">'../dev/hot-reloader/app/hot-reloader-app'</span><span class="s1">).default;</span>
        <span class="s1">content = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(HotReloader, {</span>
            <span class="s1">assetPrefix: assetPrefix,</span>
            <span class="s1">globalError: globalError,</span>
            <span class="s1">children: content</span>
        <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">content = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_rooterrorboundary.default, {</span>
            <span class="s1">errorComponent: globalError[</span><span class="s3">0</span><span class="s1">],</span>
            <span class="s1">errorStyles: globalError[</span><span class="s3">1</span><span class="s1">],</span>
            <span class="s1">children: content</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
        <span class="s1">children: [</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(HistoryUpdater, {</span>
                <span class="s1">appRouterState: state</span>
            <span class="s1">}),</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(RuntimeStyles, {}),</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {</span>
                <span class="s1">value: pathParams,</span>
                <span class="s1">children: </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {</span>
                    <span class="s1">value: pathname,</span>
                    <span class="s1">children: </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {</span>
                        <span class="s1">value: searchParams,</span>
                        <span class="s1">children: </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {</span>
                            <span class="s1">value: globalLayoutRouterContext,</span>
                            <span class="s1">children: </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {</span>
                                <span class="s1">value: _approuterinstance.publicAppRouterInstance,</span>
                                <span class="s1">children: </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {</span>
                                    <span class="s1">value: layoutRouterContext,</span>
                                    <span class="s1">children: content</span>
                                <span class="s1">})</span>
                            <span class="s1">})</span>
                        <span class="s1">})</span>
                    <span class="s1">})</span>
                <span class="s1">})</span>
            <span class="s1">})</span>
        <span class="s1">]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">AppRouter(param) {</span>
    <span class="s2">let </span><span class="s1">{ actionQueue, globalErrorState, assetPrefix } = param;</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _navfailurehandler.useNavFailureHandler)();</span>
    <span class="s2">const </span><span class="s1">router = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(Router, {</span>
        <span class="s1">actionQueue: actionQueue,</span>
        <span class="s1">assetPrefix: assetPrefix,</span>
        <span class="s1">globalError: globalErrorState</span>
    <span class="s1">});</span>
    <span class="s4">// At the very top level, use the default GlobalError component as the final fallback.</span>
    <span class="s4">// When the app router itself fails, which means the framework itself fails, we show the default error.</span>
    <span class="s2">return </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(_rooterrorboundary.default, {</span>
        <span class="s1">errorComponent: _globalerror.default,</span>
        <span class="s1">children: router</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">runtimeStyles = </span><span class="s2">new </span><span class="s1">Set();</span>
<span class="s2">let </span><span class="s1">runtimeStyleChanged = </span><span class="s2">new </span><span class="s1">Set();</span>
<span class="s1">globalThis._N_E_STYLE_LOAD = </span><span class="s2">function</span><span class="s1">(href) {</span>
    <span class="s2">let </span><span class="s1">len = runtimeStyles.size;</span>
    <span class="s1">runtimeStyles.add(href);</span>
    <span class="s2">if </span><span class="s1">(runtimeStyles.size !== len) {</span>
        <span class="s1">runtimeStyleChanged.forEach((cb)=&gt;cb());</span>
    <span class="s1">}</span>
    <span class="s4">// TODO figure out how to get a promise here</span>
    <span class="s4">// But maybe it's not necessary as react would block rendering until it's loaded</span>
    <span class="s2">return </span><span class="s1">Promise.resolve();</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">RuntimeStyles() {</span>
    <span class="s2">const </span><span class="s1">[, forceUpdate] = _react.default.useState(</span><span class="s3">0</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">renderedStylesSize = runtimeStyles.size;</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useEffect)(()=&gt;{</span>
        <span class="s2">const </span><span class="s1">changed = ()=&gt;forceUpdate((c)=&gt;c + </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">runtimeStyleChanged.add(changed);</span>
        <span class="s2">if </span><span class="s1">(renderedStylesSize !== runtimeStyles.size) {</span>
            <span class="s1">changed();</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">()=&gt;{</span>
            <span class="s1">runtimeStyleChanged.delete(changed);</span>
        <span class="s1">};</span>
    <span class="s1">}, [</span>
        <span class="s1">renderedStylesSize,</span>
        <span class="s1">forceUpdate</span>
    <span class="s1">]);</span>
    <span class="s2">const </span><span class="s1">dplId = process.env.NEXT_DEPLOYMENT_ID ? </span><span class="s0">&quot;?dpl=&quot; </span><span class="s1">+ process.env.NEXT_DEPLOYMENT_ID : </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">...runtimeStyles</span>
    <span class="s1">].map((href, i)=&gt;</span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(</span><span class="s0">&quot;link&quot;</span><span class="s1">, {</span>
            <span class="s1">rel: </span><span class="s0">&quot;stylesheet&quot;</span><span class="s1">,</span>
            <span class="s1">href: </span><span class="s0">&quot;&quot; </span><span class="s1">+ href + dplId,</span>
            <span class="s4">// @ts-ignore</span>
            <span class="s1">precedence: </span><span class="s0">&quot;next&quot;</span>
        <span class="s1">}, i));</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=app-router.js.map</span></pre>
</body>
</html>