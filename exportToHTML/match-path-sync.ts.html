<html>
<head>
<title>match-path-sync.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
match-path-sync.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">* as path from </span><span class="s2">&quot;path&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">* as Filesystem from </span><span class="s2">&quot;./filesystem&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">* as MappingEntry from </span><span class="s2">&quot;./mapping-entry&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">* as TryPath from </span><span class="s2">&quot;./try-path&quot;</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Function that can match a path</span>
 <span class="s3">*/</span>
<span class="s0">export interface </span><span class="s1">MatchPath {</span>
  <span class="s1">(</span>
    <span class="s1">requestedModule: string,</span>
    <span class="s1">readJson?: Filesystem.ReadJsonSync,</span>
    <span class="s1">fileExists?: (name: string) =&gt; boolean,</span>
    <span class="s1">extensions?: ReadonlyArray&lt;string&gt;</span>
  <span class="s1">): string | undefined;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Creates a function that can resolve paths according to tsconfig paths property.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">absoluteBaseUrl Absolute version of baseUrl as specified in tsconfig.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">paths The paths as specified in tsconfig.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">mainFields A list of package.json field names to try when resolving module files.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">addMatchAll Add a match-all &quot;*&quot; rule if none is present</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">a function that can resolve paths.</span>
 <span class="s3">*/</span>
<span class="s0">export function </span><span class="s1">createMatchPath(</span>
  <span class="s1">absoluteBaseUrl: string,</span>
  <span class="s1">paths: { [key: string]: Array&lt;string&gt; },</span>
  <span class="s1">mainFields: string[] = [</span><span class="s2">&quot;main&quot;</span><span class="s1">],</span>
  <span class="s1">addMatchAll: boolean = </span><span class="s0">true</span>
<span class="s1">): MatchPath {</span>
  <span class="s0">const </span><span class="s1">absolutePaths = MappingEntry.getAbsoluteMappingEntries(</span>
    <span class="s1">absoluteBaseUrl,</span>
    <span class="s1">paths,</span>
    <span class="s1">addMatchAll</span>
  <span class="s1">);</span>

  <span class="s0">return </span><span class="s1">(</span>
    <span class="s1">requestedModule: string,</span>
    <span class="s1">readJson?: Filesystem.ReadJsonSync,</span>
    <span class="s1">fileExists?: Filesystem.FileExistsSync,</span>
    <span class="s1">extensions?: Array&lt;string&gt;</span>
  <span class="s1">) =&gt;</span>
    <span class="s1">matchFromAbsolutePaths(</span>
      <span class="s1">absolutePaths,</span>
      <span class="s1">requestedModule,</span>
      <span class="s1">readJson,</span>
      <span class="s1">fileExists,</span>
      <span class="s1">extensions,</span>
      <span class="s1">mainFields</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Finds a path from tsconfig that matches a module load request.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">absolutePathMappings The paths to try as specified in tsconfig but resolved to absolute form.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">requestedModule The required module name.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">readJson Function that can read json from a path (useful for testing).</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">fileExists Function that checks for existence of a file at a path (useful for testing).</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">extensions File extensions to probe for (useful for testing).</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">mainFields A list of package.json field names to try when resolving module files.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">the found path, or undefined if no path was found.</span>
 <span class="s3">*/</span>
<span class="s0">export function </span><span class="s1">matchFromAbsolutePaths(</span>
  <span class="s1">absolutePathMappings: ReadonlyArray&lt;MappingEntry.MappingEntry&gt;,</span>
  <span class="s1">requestedModule: string,</span>
  <span class="s1">readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,</span>
  <span class="s1">fileExists: Filesystem.FileExistsSync = Filesystem.fileExistsSync,</span>
  <span class="s1">extensions: Array&lt;string&gt; = Object.keys(require.extensions),</span>
  <span class="s1">mainFields: string[] = [</span><span class="s2">&quot;main&quot;</span><span class="s1">]</span>
<span class="s1">): string | undefined {</span>
  <span class="s0">const </span><span class="s1">tryPaths = TryPath.getPathsToTry(</span>
    <span class="s1">extensions,</span>
    <span class="s1">absolutePathMappings,</span>
    <span class="s1">requestedModule</span>
  <span class="s1">);</span>

  <span class="s0">if </span><span class="s1">(!tryPaths) {</span>
    <span class="s0">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">findFirstExistingPath(tryPaths, readJson, fileExists, mainFields);</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">findFirstExistingMainFieldMappedFile(</span>
  <span class="s1">packageJson: Filesystem.PackageJson,</span>
  <span class="s1">mainFields: string[],</span>
  <span class="s1">packageJsonPath: string,</span>
  <span class="s1">fileExists: Filesystem.FileExistsSync</span>
<span class="s1">): string | undefined {</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">index = </span><span class="s5">0</span><span class="s1">; index &lt; mainFields.length; index++) {</span>
    <span class="s0">const </span><span class="s1">mainFieldName = mainFields[index];</span>
    <span class="s0">const </span><span class="s1">candidateMapping = packageJson[mainFieldName];</span>
    <span class="s0">if </span><span class="s1">(candidateMapping &amp;&amp; </span><span class="s0">typeof </span><span class="s1">candidateMapping === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
      <span class="s0">const </span><span class="s1">candidateFilePath = path.join(</span>
        <span class="s1">path.dirname(packageJsonPath),</span>
        <span class="s1">candidateMapping</span>
      <span class="s1">);</span>
      <span class="s0">if </span><span class="s1">(fileExists(candidateFilePath)) {</span>
        <span class="s0">return </span><span class="s1">candidateFilePath;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">findFirstExistingPath(</span>
  <span class="s1">tryPaths: ReadonlyArray&lt;TryPath.TryPath&gt;,</span>
  <span class="s1">readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,</span>
  <span class="s1">fileExists: Filesystem.FileExistsSync,</span>
  <span class="s1">mainFields: string[] = [</span><span class="s2">&quot;main&quot;</span><span class="s1">]</span>
<span class="s1">): string | undefined {</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">tryPath of tryPaths) {</span>
    <span class="s0">if </span><span class="s1">(</span>
      <span class="s1">tryPath.type === </span><span class="s2">&quot;file&quot; </span><span class="s1">||</span>
      <span class="s1">tryPath.type === </span><span class="s2">&quot;extension&quot; </span><span class="s1">||</span>
      <span class="s1">tryPath.type === </span><span class="s2">&quot;index&quot;</span>
    <span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(fileExists(tryPath.path)) {</span>
        <span class="s0">return </span><span class="s1">TryPath.getStrippedPath(tryPath);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(tryPath.type === </span><span class="s2">&quot;package&quot;</span><span class="s1">) {</span>
      <span class="s0">const </span><span class="s1">packageJson: Filesystem.PackageJson = readJson(tryPath.path);</span>
      <span class="s0">if </span><span class="s1">(packageJson) {</span>
        <span class="s0">const </span><span class="s1">mainFieldMappedFile = findFirstExistingMainFieldMappedFile(</span>
          <span class="s1">packageJson,</span>
          <span class="s1">mainFields,</span>
          <span class="s1">tryPath.path,</span>
          <span class="s1">fileExists</span>
        <span class="s1">);</span>
        <span class="s0">if </span><span class="s1">(mainFieldMappedFile) {</span>
          <span class="s0">return </span><span class="s1">mainFieldMappedFile;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">TryPath.exhaustiveTypeException(tryPath.type);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>
</pre>
</body>
</html>