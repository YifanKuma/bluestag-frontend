<html>
<head>
<title>web-on-close.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
web-on-close.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/web/web-on-close.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/** Monitor when the consumer finishes reading the response body.</span><span class="s3">\n</span><span class="s1">that's as close as we can get to `res.on('close')` using web APIs.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function trackBodyConsumed(</span><span class="s3">\n  </span><span class="s1">body: string | ReadableStream,</span><span class="s3">\n  </span><span class="s1">onEnd: () =&gt; void</span><span class="s3">\n</span><span class="s1">): BodyInit {</span><span class="s3">\n  </span><span class="s1">if (typeof body === 'string') {</span><span class="s3">\n    </span><span class="s1">const generator = async function* generate() {</span><span class="s3">\n      </span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n      </span><span class="s1">yield encoder.encode(body)</span><span class="s3">\n      </span><span class="s1">onEnd()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error BodyInit typings doesn't seem to include AsyncIterables even though it's supported in practice</span><span class="s3">\n    </span><span class="s1">return generator()</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return trackStreamConsumed(body, onEnd)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function trackStreamConsumed&lt;TChunk&gt;(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;TChunk&gt;,</span><span class="s3">\n  </span><span class="s1">onEnd: () =&gt; void</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;TChunk&gt; {</span><span class="s3">\n  </span><span class="s1">// NOTE: This function must handle `stream` being aborted or cancelled,</span><span class="s3">\n  </span><span class="s1">// so it can't just be this:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   return stream.pipeThrough(new TransformStream({ flush() { onEnd() } }))</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// because that doesn't handle cancellations.</span><span class="s3">\n  </span><span class="s1">// (and cancellation handling via `Transformer.cancel` is only available in node &gt;20)</span><span class="s3">\n  </span><span class="s1">const dest = new TransformStream()</span><span class="s3">\n  </span><span class="s1">const runOnEnd = () =&gt; onEnd()</span><span class="s3">\n  </span><span class="s1">stream.pipeTo(dest.writable).then(runOnEnd, runOnEnd)</span><span class="s3">\n  </span><span class="s1">return dest.readable</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class CloseController {</span><span class="s3">\n  </span><span class="s1">private target = new EventTarget()</span><span class="s3">\n  </span><span class="s1">listeners = 0</span><span class="s3">\n  </span><span class="s1">isClosed = false</span><span class="s3">\n\n  </span><span class="s1">onClose(callback: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">if (this.isClosed) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Cannot subscribe to a closed CloseController')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.target.addEventListener('close', callback)</span><span class="s3">\n    </span><span class="s1">this.listeners++</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">dispatchClose() {</span><span class="s3">\n    </span><span class="s1">if (this.isClosed) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Cannot close a CloseController multiple times')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.listeners &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.target.dispatchEvent(new Event('close'))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.isClosed = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;CloseController&quot;</span><span class="s0">,</span><span class="s1">&quot;trackBodyConsumed&quot;</span><span class="s0">,</span><span class="s1">&quot;trackStreamConsumed&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;onEnd&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;generate&quot;</span><span class="s0">,</span><span class="s1">&quot;encoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;dest&quot;</span><span class="s0">,</span><span class="s1">&quot;TransformStream&quot;</span><span class="s0">,</span><span class="s1">&quot;runOnEnd&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeTo&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;onClose&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;isClosed&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;listeners&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchClose&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;Event&quot;</span><span class="s0">,</span><span class="s1">&quot;EventTarget&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;AAEA;;;;;;;;;;;;;;;;IAmCaA,eAAe;eAAfA;;IAlCGC,iBAAiB;eAAjBA;;IAiBAC,mBAAmB;eAAnBA;;;AAjBT,SAASD,kBACdE,IAA6B,EAC7BC,KAAiB;IAEjB,IAAI,OAAOD,SAAS,UAAU;QAC5B,MAAME,YAAY,gBAAgBC;YAChC,MAAMC,UAAU,IAAIC;YACpB,MAAMD,QAAQE,MAAM,CAACN;YACrBC;QACF;QACA,kHAAkH;QAClH,OAAOC;IACT,OAAO;QACL,OAAOH,oBAAoBC,MAAMC;IACnC;AACF;AAEO,SAASF,oBACdQ,MAA8B,EAC9BN,KAAiB;IAEjB,uEAAuE;IACvE,4BAA4B;IAC5B,EAAE;IACF,4EAA4E;IAC5E,EAAE;IACF,6CAA6C;IAC7C,qFAAqF;IACrF,MAAMO,OAAO,IAAIC;IACjB,MAAMC,WAAW,IAAMT;IACvBM,OAAOI,MAAM,CAACH,KAAKI,QAAQ,EAAEC,IAAI,CAACH,UAAUA;IAC5C,OAAOF,KAAKM,QAAQ;AACtB;AAEO,MAAMjB;IAKXkB,QAAQC,QAAoB,EAAE;QAC5B,IAAI,IAAI,CAACC,QAAQ,EAAE;YACjB,MAAM,qBAAyD,CAAzD,IAAIC,MAAM,iDAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAAwD;QAChE;QAEA,IAAI,CAACC,MAAM,CAACC,gBAAgB,CAAC,SAASJ;QACtC,IAAI,CAACK,SAAS;IAChB;IAEAC,gBAAgB;QACd,IAAI,IAAI,CAACL,QAAQ,EAAE;YACjB,MAAM,qBAA0D,CAA1D,IAAIC,MAAM,kDAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAAyD;QACjE;QACA,IAAI,IAAI,CAACG,SAAS,GAAG,GAAG;YACtB,IAAI,CAACF,MAAM,CAACI,aAAa,CAAC,IAAIC,MAAM;QACtC;QACA,IAAI,CAACP,QAAQ,GAAG;IAClB;;aArBQE,SAAS,IAAIM;aACrBJ,YAAY;aACZJ,WAAW;;AAoBb&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>