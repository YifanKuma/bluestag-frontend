<html>
<head>
<title>forward-logs.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
forward-logs.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/next-devtools/userspace/app/forward-logs.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { configure } from 'next/dist/compiled/safe-stable-stringify'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getOwnerStack,</span><span class="s3">\n  </span><span class="s1">setOwnerStackIfAvailable,</span><span class="s3">\n</span><span class="s1">} from './errors/stitched-error'</span><span class="s3">\n</span><span class="s1">import { getErrorSource } from '../../../shared/lib/error-source'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getTerminalLoggingConfig,</span><span class="s3">\n  </span><span class="s1">getIsTerminalLoggingEnabled,</span><span class="s3">\n</span><span class="s1">} from './terminal-logging-config'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type ConsoleEntry,</span><span class="s3">\n  </span><span class="s1">type ConsoleErrorEntry,</span><span class="s3">\n  </span><span class="s1">type FormattedErrorEntry,</span><span class="s3">\n  </span><span class="s1">type ClientLogEntry,</span><span class="s3">\n  </span><span class="s1">type LogMethod,</span><span class="s3">\n  </span><span class="s1">patchConsoleMethod,</span><span class="s3">\n  </span><span class="s1">UNDEFINED_MARKER,</span><span class="s3">\n</span><span class="s1">} from '../../shared/forward-logs-shared'</span><span class="s3">\n\n</span><span class="s1">const terminalLoggingConfig = getTerminalLoggingConfig()</span><span class="s3">\n</span><span class="s1">export const PROMISE_MARKER = 'Promise {}'</span><span class="s3">\n</span><span class="s1">export const UNAVAILABLE_MARKER = '[Unable to view]'</span><span class="s3">\n\n</span><span class="s1">const maximumDepth =</span><span class="s3">\n  </span><span class="s1">typeof terminalLoggingConfig === 'object' &amp;&amp; terminalLoggingConfig.depthLimit</span><span class="s3">\n    </span><span class="s1">? terminalLoggingConfig.depthLimit</span><span class="s3">\n    </span><span class="s1">: 5</span><span class="s3">\n</span><span class="s1">const maximumBreadth =</span><span class="s3">\n  </span><span class="s1">typeof terminalLoggingConfig === 'object' &amp;&amp; terminalLoggingConfig.edgeLimit</span><span class="s3">\n    </span><span class="s1">? terminalLoggingConfig.edgeLimit</span><span class="s3">\n    </span><span class="s1">: 100</span><span class="s3">\n\n</span><span class="s1">const stringify = configure({</span><span class="s3">\n  </span><span class="s1">maximumDepth,</span><span class="s3">\n  </span><span class="s1">maximumBreadth,</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">export const isTerminalLoggingEnabled = getIsTerminalLoggingEnabled()</span><span class="s3">\n\n</span><span class="s1">const methods: Array&lt;LogMethod&gt; = [</span><span class="s3">\n  </span><span class="s1">'log',</span><span class="s3">\n  </span><span class="s1">'info',</span><span class="s3">\n  </span><span class="s1">'warn',</span><span class="s3">\n  </span><span class="s1">'debug',</span><span class="s3">\n  </span><span class="s1">'table',</span><span class="s3">\n  </span><span class="s1">'assert',</span><span class="s3">\n  </span><span class="s1">'dir',</span><span class="s3">\n  </span><span class="s1">'dirxml',</span><span class="s3">\n  </span><span class="s1">'group',</span><span class="s3">\n  </span><span class="s1">'groupCollapsed',</span><span class="s3">\n  </span><span class="s1">'groupEnd',</span><span class="s3">\n  </span><span class="s1">'trace',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* allows us to:</span><span class="s3">\n </span><span class="s1">* - revive the undefined log in the server as it would look in the browser</span><span class="s3">\n </span><span class="s1">* - not read/attempt to serialize promises (next will console error if you do that, and will cause this program to infinitely recurse)</span><span class="s3">\n </span><span class="s1">* - if we read a proxy that throws (no way to detect if something is a proxy), explain to the user we can't read this data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function preLogSerializationClone&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">value: T,</span><span class="s3">\n  </span><span class="s1">seen = new WeakMap()</span><span class="s3">\n</span><span class="s1">): any {</span><span class="s3">\n  </span><span class="s1">if (value === undefined) return UNDEFINED_MARKER</span><span class="s3">\n  </span><span class="s1">if (value === null || typeof value !== 'object') return value</span><span class="s3">\n  </span><span class="s1">if (seen.has(value as object)) return seen.get(value as object)</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">Object.keys(value as object)</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return UNAVAILABLE_MARKER</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">if (typeof (value as any).then === 'function') return PROMISE_MARKER</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return UNAVAILABLE_MARKER</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">const out: any[] = []</span><span class="s3">\n    </span><span class="s1">seen.set(value, out)</span><span class="s3">\n    </span><span class="s1">for (const item of value) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">out.push(preLogSerializationClone(item, seen))</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">out.push(UNAVAILABLE_MARKER)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return out</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const proto = Object.getPrototypeOf(value)</span><span class="s3">\n  </span><span class="s1">if (proto === Object.prototype || proto === null) {</span><span class="s3">\n    </span><span class="s1">const out: Record&lt;string, unknown&gt; = {}</span><span class="s3">\n    </span><span class="s1">seen.set(value as object, out)</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(value as object)) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">out[key] = preLogSerializationClone((value as any)[key], seen)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">out[key] = UNAVAILABLE_MARKER</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return out</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return Object.prototype.toString.call(value)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// only safe if passed safeClone data</span><span class="s3">\n</span><span class="s1">export const logStringify = (data: unknown): string =&gt; {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const result = stringify(data)</span><span class="s3">\n    </span><span class="s1">return result ?? `</span><span class="s3">\&quot;</span><span class="s1">${UNAVAILABLE_MARKER}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return `</span><span class="s3">\&quot;</span><span class="s1">${UNAVAILABLE_MARKER}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const afterThisFrame = (cb: () =&gt; void) =&gt; {</span><span class="s3">\n  </span><span class="s1">let timeout: ReturnType&lt;typeof setTimeout&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const rafId = requestAnimationFrame(() =&gt; {</span><span class="s3">\n    </span><span class="s1">timeout = setTimeout(() =&gt; {</span><span class="s3">\n      </span><span class="s1">cb()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return () =&gt; {</span><span class="s3">\n    </span><span class="s1">cancelAnimationFrame(rafId)</span><span class="s3">\n    </span><span class="s1">clearTimeout(timeout)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let isPatched = false</span><span class="s3">\n\n</span><span class="s1">const serializeEntries = (entries: Array&lt;ClientLogEntry&gt;) =&gt;</span><span class="s3">\n  </span><span class="s1">entries.map((clientEntry) =&gt; {</span><span class="s3">\n    </span><span class="s1">switch (clientEntry.kind) {</span><span class="s3">\n      </span><span class="s1">case 'any-logged-error':</span><span class="s3">\n      </span><span class="s1">case 'console': {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">...clientEntry,</span><span class="s3">\n          </span><span class="s1">args: clientEntry.args.map(stringifyUserArg),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'formatted-error': {</span><span class="s3">\n        </span><span class="s1">return clientEntry</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">return null!</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">export const logQueue: {</span><span class="s3">\n  </span><span class="s1">entries: Array&lt;ClientLogEntry&gt;</span><span class="s3">\n  </span><span class="s1">onSocketReady: (socket: WebSocket) =&gt; void</span><span class="s3">\n  </span><span class="s1">flushScheduled: boolean</span><span class="s3">\n  </span><span class="s1">socket: WebSocket | null</span><span class="s3">\n  </span><span class="s1">cancelFlush: (() =&gt; void) | null</span><span class="s3">\n  </span><span class="s1">sourceType?: 'server' | 'edge-server'</span><span class="s3">\n  </span><span class="s1">router: 'app' | 'pages' | null</span><span class="s3">\n  </span><span class="s1">scheduleLogSend: (entry: ClientLogEntry) =&gt; void</span><span class="s3">\n</span><span class="s1">} = {</span><span class="s3">\n  </span><span class="s1">entries: [],</span><span class="s3">\n  </span><span class="s1">flushScheduled: false,</span><span class="s3">\n  </span><span class="s1">cancelFlush: null,</span><span class="s3">\n  </span><span class="s1">socket: null,</span><span class="s3">\n  </span><span class="s1">sourceType: undefined,</span><span class="s3">\n  </span><span class="s1">router: null,</span><span class="s3">\n  </span><span class="s1">scheduleLogSend: (entry: ClientLogEntry) =&gt; {</span><span class="s3">\n    </span><span class="s1">logQueue.entries.push(entry)</span><span class="s3">\n    </span><span class="s1">if (logQueue.flushScheduled) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// safe to deref and use in setTimeout closure since we cancel on new socket</span><span class="s3">\n    </span><span class="s1">const socket = logQueue.socket</span><span class="s3">\n    </span><span class="s1">if (!socket) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// we probably dont need this</span><span class="s3">\n    </span><span class="s1">logQueue.flushScheduled = true</span><span class="s3">\n\n    </span><span class="s1">// non blocking log flush, runs at most once per frame</span><span class="s3">\n    </span><span class="s1">logQueue.cancelFlush = afterThisFrame(() =&gt; {</span><span class="s3">\n      </span><span class="s1">logQueue.flushScheduled = false</span><span class="s3">\n\n      </span><span class="s1">// just incase</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const payload = JSON.stringify({</span><span class="s3">\n          </span><span class="s1">event: 'browser-logs',</span><span class="s3">\n          </span><span class="s1">entries: serializeEntries(logQueue.entries),</span><span class="s3">\n          </span><span class="s1">router: logQueue.router,</span><span class="s3">\n          </span><span class="s1">// needed for source mapping, we just assign the sourceType from the last error for the whole batch</span><span class="s3">\n          </span><span class="s1">sourceType: logQueue.sourceType,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">socket.send(payload)</span><span class="s3">\n        </span><span class="s1">logQueue.entries = []</span><span class="s3">\n        </span><span class="s1">logQueue.sourceType = undefined</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// error (make sure u don't infinite loop)</span><span class="s3">\n        </span><span class="s1">/* noop */</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">onSocketReady: (socket: WebSocket) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (socket.readyState !== WebSocket.OPEN) {</span><span class="s3">\n      </span><span class="s1">// invariant</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// incase an existing timeout was going to run with a stale socket</span><span class="s3">\n    </span><span class="s1">logQueue.cancelFlush?.()</span><span class="s3">\n    </span><span class="s1">logQueue.socket = socket</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const payload = JSON.stringify({</span><span class="s3">\n        </span><span class="s1">event: 'browser-logs',</span><span class="s3">\n        </span><span class="s1">entries: serializeEntries(logQueue.entries),</span><span class="s3">\n        </span><span class="s1">router: logQueue.router,</span><span class="s3">\n        </span><span class="s1">sourceType: logQueue.sourceType,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">socket.send(payload)</span><span class="s3">\n      </span><span class="s1">logQueue.entries = []</span><span class="s3">\n      </span><span class="s1">logQueue.sourceType = undefined</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n      </span><span class="s1">/** noop just incase */</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const stringifyUserArg = (</span><span class="s3">\n  </span><span class="s1">arg:</span><span class="s3">\n    </span><span class="s1">| {</span><span class="s3">\n        </span><span class="s1">kind: 'arg'</span><span class="s3">\n        </span><span class="s1">data: unknown</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">| {</span><span class="s3">\n        </span><span class="s1">kind: 'formatted-error-arg'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (arg.kind !== 'arg') {</span><span class="s3">\n    </span><span class="s1">return arg</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...arg,</span><span class="s3">\n    </span><span class="s1">data: logStringify(arg.data),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const createErrorArg = (error: Error) =&gt; {</span><span class="s3">\n  </span><span class="s1">const stack = stackWithOwners(error)</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">kind: 'formatted-error-arg' as const,</span><span class="s3">\n    </span><span class="s1">prefix: error.message ? `${error.name}: ${error.message}` : `${error.name}`,</span><span class="s3">\n    </span><span class="s1">stack,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const createLogEntry = (level: LogMethod, args: any[]) =&gt; {</span><span class="s3">\n  </span><span class="s1">// do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers</span><span class="s3">\n  </span><span class="s1">// error capture stack trace maybe</span><span class="s3">\n  </span><span class="s1">const stack = stackWithOwners(new Error())</span><span class="s3">\n  </span><span class="s1">const stackLines = stack?.split('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n  </span><span class="s1">const cleanStack = stackLines?.slice(3).join('</span><span class="s3">\\</span><span class="s1">n') // this is probably ignored anyways</span><span class="s3">\n  </span><span class="s1">const entry: ConsoleEntry&lt;unknown&gt; = {</span><span class="s3">\n    </span><span class="s1">kind: 'console',</span><span class="s3">\n    </span><span class="s1">consoleMethodStack: cleanStack ?? null, // depending on browser we might not have stack</span><span class="s3">\n    </span><span class="s1">method: level,</span><span class="s3">\n    </span><span class="s1">args: args.map((arg) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (arg instanceof Error) {</span><span class="s3">\n        </span><span class="s1">return createErrorArg(arg)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">kind: 'arg',</span><span class="s3">\n        </span><span class="s1">data: preLogSerializationClone(arg),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">logQueue.scheduleLogSend(entry)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const forwardErrorLog = (args: any[]) =&gt; {</span><span class="s3">\n  </span><span class="s1">const errorObjects = args.filter((arg) =&gt; arg instanceof Error)</span><span class="s3">\n  </span><span class="s1">const first = errorObjects.at(0)</span><span class="s3">\n  </span><span class="s1">if (first) {</span><span class="s3">\n    </span><span class="s1">const source = getErrorSource(first)</span><span class="s3">\n    </span><span class="s1">if (source) {</span><span class="s3">\n      </span><span class="s1">logQueue.sourceType = source</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* browser shows stack regardless of type of data passed to console.error, so we should do the same</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const stack = stackWithOwners(new Error())</span><span class="s3">\n  </span><span class="s1">const stackLines = stack?.split('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n  </span><span class="s1">const cleanStack = stackLines?.slice(3).join('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n\n  </span><span class="s1">const entry: ConsoleErrorEntry&lt;unknown&gt; = {</span><span class="s3">\n    </span><span class="s1">kind: 'any-logged-error',</span><span class="s3">\n    </span><span class="s1">method: 'error',</span><span class="s3">\n    </span><span class="s1">consoleErrorStack: cleanStack ?? '',</span><span class="s3">\n    </span><span class="s1">args: args.map((arg) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (arg instanceof Error) {</span><span class="s3">\n        </span><span class="s1">return createErrorArg(arg)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">kind: 'arg',</span><span class="s3">\n        </span><span class="s1">data: preLogSerializationClone(arg),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">logQueue.scheduleLogSend(entry)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const createUncaughtErrorEntry = (</span><span class="s3">\n  </span><span class="s1">errorName: string,</span><span class="s3">\n  </span><span class="s1">errorMessage: string,</span><span class="s3">\n  </span><span class="s1">fullStack: string</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">const entry: FormattedErrorEntry = {</span><span class="s3">\n    </span><span class="s1">kind: 'formatted-error',</span><span class="s3">\n    </span><span class="s1">prefix: `Uncaught ${errorName}: ${errorMessage}`,</span><span class="s3">\n    </span><span class="s1">stack: fullStack,</span><span class="s3">\n    </span><span class="s1">method: 'error',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">logQueue.scheduleLogSend(entry)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const stackWithOwners = (error: Error) =&gt; {</span><span class="s3">\n  </span><span class="s1">let ownerStack = ''</span><span class="s3">\n  </span><span class="s1">setOwnerStackIfAvailable(error)</span><span class="s3">\n  </span><span class="s1">ownerStack = getOwnerStack(error) || ''</span><span class="s3">\n  </span><span class="s1">const stack = (error.stack || '') + ownerStack</span><span class="s3">\n  </span><span class="s1">return stack</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function logUnhandledRejection(reason: unknown) {</span><span class="s3">\n  </span><span class="s1">if (reason instanceof Error) {</span><span class="s3">\n    </span><span class="s1">createUnhandledRejectionErrorEntry(reason, stackWithOwners(reason))</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">createUnhandledRejectionNonErrorEntry(reason)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const createUnhandledRejectionErrorEntry = (</span><span class="s3">\n  </span><span class="s1">error: Error,</span><span class="s3">\n  </span><span class="s1">fullStack: string</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">const source = getErrorSource(error)</span><span class="s3">\n  </span><span class="s1">if (source) {</span><span class="s3">\n    </span><span class="s1">logQueue.sourceType = source</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const entry: ClientLogEntry = {</span><span class="s3">\n    </span><span class="s1">kind: 'formatted-error',</span><span class="s3">\n    </span><span class="s1">prefix: `тип unhandledRejection: ${error.name}: ${error.message}`,</span><span class="s3">\n    </span><span class="s1">stack: fullStack,</span><span class="s3">\n    </span><span class="s1">method: 'error',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">logQueue.scheduleLogSend(entry)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const createUnhandledRejectionNonErrorEntry = (reason: unknown) =&gt; {</span><span class="s3">\n  </span><span class="s1">const entry: ClientLogEntry = {</span><span class="s3">\n    </span><span class="s1">kind: 'any-logged-error',</span><span class="s3">\n    </span><span class="s1">// we can't access the stack since the event is dispatched async and creating an inline error would be meaningless</span><span class="s3">\n    </span><span class="s1">consoleErrorStack: '',</span><span class="s3">\n    </span><span class="s1">method: 'error',</span><span class="s3">\n    </span><span class="s1">args: [</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">kind: 'arg',</span><span class="s3">\n        </span><span class="s1">data: `тип unhandledRejection:`,</span><span class="s3">\n        </span><span class="s1">isRejectionMessage: true,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">kind: 'arg',</span><span class="s3">\n        </span><span class="s1">data: preLogSerializationClone(reason),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">logQueue.scheduleLogSend(entry)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const isHMR = (args: any[]) =&gt; {</span><span class="s3">\n  </span><span class="s1">const firstArg = args[0]</span><span class="s3">\n  </span><span class="s1">if (typeof firstArg !== 'string') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (firstArg.startsWith('[Fast Refresh]')) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (firstArg.startsWith('[HMR]')) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const isIgnoredLog = (args: any[]) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (args.length &lt; 3) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const [format, styles, label] = args</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof format !== 'string' ||</span><span class="s3">\n    </span><span class="s1">typeof styles !== 'string' ||</span><span class="s3">\n    </span><span class="s1">typeof label !== 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// kinda hacky, we should define a common format for these strings so we can safely ignore</span><span class="s3">\n  </span><span class="s1">return format.startsWith('%c%s%c') &amp;&amp; styles.includes('background:')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function forwardUnhandledError(error: Error) {</span><span class="s3">\n  </span><span class="s1">createUncaughtErrorEntry(error.name, error.message, stackWithOwners(error))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// TODO: this router check is brittle, we need to update based on the current router the user is using</span><span class="s3">\n</span><span class="s1">export const initializeDebugLogForwarding = (router: 'app' | 'pages'): void =&gt; {</span><span class="s3">\n  </span><span class="s1">// probably don't need this</span><span class="s3">\n  </span><span class="s1">if (isPatched) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// TODO(rob): why does this break rendering on server, important to know incase the same bug appears in browser</span><span class="s3">\n  </span><span class="s1">if (typeof window === 'undefined') {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// better to be safe than sorry</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">methods.forEach((method) =&gt;</span><span class="s3">\n      </span><span class="s1">patchConsoleMethod(method, (_, ...args) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (isHMR(args)) {</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isIgnoredLog(args)) {</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">createLogEntry(method, args)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} catch {}</span><span class="s3">\n  </span><span class="s1">logQueue.router = router</span><span class="s3">\n  </span><span class="s1">isPatched = true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;PROMISE_MARKER&quot;</span><span class="s0">,</span><span class="s1">&quot;UNAVAILABLE_MARKER&quot;</span><span class="s0">,</span><span class="s1">&quot;forwardErrorLog&quot;</span><span class="s0">,</span><span class="s1">&quot;forwardUnhandledError&quot;</span><span class="s0">,</span><span class="s1">&quot;initializeDebugLogForwarding&quot;</span><span class="s0">,</span><span class="s1">&quot;isTerminalLoggingEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;logQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;logStringify&quot;</span><span class="s0">,</span><span class="s1">&quot;logUnhandledRejection&quot;</span><span class="s0">,</span><span class="s1">&quot;preLogSerializationClone&quot;</span><span class="s0">,</span><span class="s1">&quot;terminalLoggingConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;getTerminalLoggingConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;maximumDepth&quot;</span><span class="s0">,</span><span class="s1">&quot;depthLimit&quot;</span><span class="s0">,</span><span class="s1">&quot;maximumBreadth&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeLimit&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;configure&quot;</span><span class="s0">,</span><span class="s1">&quot;getIsTerminalLoggingEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;methods&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;seen&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;UNDEFINED_MARKER&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;out&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;proto&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrototypeOf&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;afterThisFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;timeout&quot;</span><span class="s0">,</span><span class="s1">&quot;rafId&quot;</span><span class="s0">,</span><span class="s1">&quot;requestAnimationFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelAnimationFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;clearTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;isPatched&quot;</span><span class="s0">,</span><span class="s1">&quot;serializeEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;clientEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyUserArg&quot;</span><span class="s0">,</span><span class="s1">&quot;flushScheduled&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelFlush&quot;</span><span class="s0">,</span><span class="s1">&quot;socket&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleLogSend&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;send&quot;</span><span class="s0">,</span><span class="s1">&quot;onSocketReady&quot;</span><span class="s0">,</span><span class="s1">&quot;readyState&quot;</span><span class="s0">,</span><span class="s1">&quot;WebSocket&quot;</span><span class="s0">,</span><span class="s1">&quot;OPEN&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;createErrorArg&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;stackWithOwners&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;createLogEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;level&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;stackLines&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanStack&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;consoleMethodStack&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;errorObjects&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;first&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;getErrorSource&quot;</span><span class="s0">,</span><span class="s1">&quot;consoleErrorStack&quot;</span><span class="s0">,</span><span class="s1">&quot;createUncaughtErrorEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;errorName&quot;</span><span class="s0">,</span><span class="s1">&quot;errorMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;fullStack&quot;</span><span class="s0">,</span><span class="s1">&quot;ownerStack&quot;</span><span class="s0">,</span><span class="s1">&quot;setOwnerStackIfAvailable&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnerStack&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnhandledRejectionErrorEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnhandledRejectionNonErrorEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isRejectionMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;isHMR&quot;</span><span class="s0">,</span><span class="s1">&quot;firstArg&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;isIgnoredLog&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">,</span><span class="s1">&quot;styles&quot;</span><span class="s0">,</span><span class="s1">&quot;label&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;patchConsoleMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>