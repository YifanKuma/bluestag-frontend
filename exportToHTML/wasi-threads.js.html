<html>
<head>
<title>wasi-threads.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wasi-threads.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
    <span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined' </span><span class="s0">? factory(exports) :</span>
    <span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s0">], factory) :</span>
    <span class="s0">(global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self, factory(global.wasiThreads = {}));</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(exports) {</span>
    <span class="s1">var </span><span class="s0">_WebAssembly = </span><span class="s1">typeof </span><span class="s0">WebAssembly !== </span><span class="s2">'undefined'</span>
        <span class="s0">? WebAssembly</span>
        <span class="s0">: </span><span class="s1">typeof </span><span class="s0">WXWebAssembly !== </span><span class="s2">'undefined'</span>
            <span class="s0">? WXWebAssembly</span>
            <span class="s0">: undefined;</span>
    <span class="s1">var </span><span class="s0">ENVIRONMENT_IS_NODE = </span><span class="s1">typeof </span><span class="s0">process === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; process !== </span><span class="s1">null </span><span class="s0">&amp;&amp;</span>
        <span class="s1">typeof </span><span class="s0">process.versions === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; process.versions !== </span><span class="s1">null </span><span class="s0">&amp;&amp;</span>
        <span class="s1">typeof </span><span class="s0">process.versions.node === </span><span class="s2">'string'</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">getPostMessage(options) {</span>
        <span class="s1">return typeof </span><span class="s0">(options === </span><span class="s1">null </span><span class="s0">|| options === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: options.postMessage) === </span><span class="s2">'function'</span>
            <span class="s0">? options.postMessage</span>
            <span class="s0">: </span><span class="s1">typeof </span><span class="s0">postMessage === </span><span class="s2">'function'</span>
                <span class="s0">? postMessage</span>
                <span class="s0">: undefined;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">serizeErrorToBuffer(sab, code, error) {</span>
        <span class="s1">var </span><span class="s0">i32array = </span><span class="s1">new </span><span class="s0">Int32Array(sab);</span>
        <span class="s0">Atomics.store(i32array, </span><span class="s3">0</span><span class="s0">, code);</span>
        <span class="s1">if </span><span class="s0">(code &gt; </span><span class="s3">1 </span><span class="s0">&amp;&amp; error) {</span>
            <span class="s1">var </span><span class="s0">name_1 = error.name;</span>
            <span class="s1">var </span><span class="s0">message = error.message;</span>
            <span class="s1">var </span><span class="s0">stack = error.stack;</span>
            <span class="s1">var </span><span class="s0">nameBuffer = </span><span class="s1">new </span><span class="s0">TextEncoder().encode(name_1);</span>
            <span class="s1">var </span><span class="s0">messageBuffer = </span><span class="s1">new </span><span class="s0">TextEncoder().encode(message);</span>
            <span class="s1">var </span><span class="s0">stackBuffer = </span><span class="s1">new </span><span class="s0">TextEncoder().encode(stack);</span>
            <span class="s0">Atomics.store(i32array, </span><span class="s3">1</span><span class="s0">, nameBuffer.length);</span>
            <span class="s0">Atomics.store(i32array, </span><span class="s3">2</span><span class="s0">, messageBuffer.length);</span>
            <span class="s0">Atomics.store(i32array, </span><span class="s3">3</span><span class="s0">, stackBuffer.length);</span>
            <span class="s1">var </span><span class="s0">buffer = </span><span class="s1">new </span><span class="s0">Uint8Array(sab);</span>
            <span class="s0">buffer.set(nameBuffer, </span><span class="s3">16</span><span class="s0">);</span>
            <span class="s0">buffer.set(messageBuffer, </span><span class="s3">16 </span><span class="s0">+ nameBuffer.length);</span>
            <span class="s0">buffer.set(stackBuffer, </span><span class="s3">16 </span><span class="s0">+ nameBuffer.length + messageBuffer.length);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">deserizeErrorFromBuffer(sab) {</span>
        <span class="s1">var </span><span class="s0">_a, _b;</span>
        <span class="s1">var </span><span class="s0">i32array = </span><span class="s1">new </span><span class="s0">Int32Array(sab);</span>
        <span class="s1">var </span><span class="s0">status = Atomics.load(i32array, </span><span class="s3">0</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(status &lt;= </span><span class="s3">1</span><span class="s0">) {</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">nameLength = Atomics.load(i32array, </span><span class="s3">1</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">messageLength = Atomics.load(i32array, </span><span class="s3">2</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">stackLength = Atomics.load(i32array, </span><span class="s3">3</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">buffer = </span><span class="s1">new </span><span class="s0">Uint8Array(sab);</span>
        <span class="s1">var </span><span class="s0">nameBuffer = buffer.slice(</span><span class="s3">16</span><span class="s0">, </span><span class="s3">16 </span><span class="s0">+ nameLength);</span>
        <span class="s1">var </span><span class="s0">messageBuffer = buffer.slice(</span><span class="s3">16 </span><span class="s0">+ nameLength, </span><span class="s3">16 </span><span class="s0">+ nameLength + messageLength);</span>
        <span class="s1">var </span><span class="s0">stackBuffer = buffer.slice(</span><span class="s3">16 </span><span class="s0">+ nameLength + messageLength, </span><span class="s3">16 </span><span class="s0">+ nameLength + messageLength + stackLength);</span>
        <span class="s1">var </span><span class="s0">name = </span><span class="s1">new </span><span class="s0">TextDecoder().decode(nameBuffer);</span>
        <span class="s1">var </span><span class="s0">message = </span><span class="s1">new </span><span class="s0">TextDecoder().decode(messageBuffer);</span>
        <span class="s1">var </span><span class="s0">stack = </span><span class="s1">new </span><span class="s0">TextDecoder().decode(stackBuffer);</span>
        <span class="s1">var </span><span class="s0">ErrorConstructor = (_a = globalThis[name]) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _a !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? _a : (name === </span><span class="s2">'RuntimeError' </span><span class="s0">? ((_b = _WebAssembly.RuntimeError) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _b !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? _b : Error) : Error);</span>
        <span class="s1">var </span><span class="s0">error = </span><span class="s1">new </span><span class="s0">ErrorConstructor(message);</span>
        <span class="s0">Object.defineProperty(error, </span><span class="s2">'stack'</span><span class="s0">, {</span>
            <span class="s0">value: stack,</span>
            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s4">/** </span><span class="s5">@public </span><span class="s4">*/</span>
    <span class="s1">function </span><span class="s0">isSharedArrayBuffer(value) {</span>
        <span class="s1">return </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">SharedArrayBuffer === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; value </span><span class="s1">instanceof </span><span class="s0">SharedArrayBuffer) ||</span>
            <span class="s0">(Object.prototype.toString.call(value) === </span><span class="s2">'[object SharedArrayBuffer]'</span><span class="s0">));</span>
    <span class="s0">}</span>
    <span class="s4">/** </span><span class="s5">@public </span><span class="s4">*/</span>
    <span class="s1">function </span><span class="s0">isTrapError(e) {</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">e </span><span class="s1">instanceof </span><span class="s0">_WebAssembly.RuntimeError;</span>
        <span class="s0">}</span>
        <span class="s1">catch </span><span class="s0">(_) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">createMessage(type, payload) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">__emnapi__: {</span>
                <span class="s0">type: type,</span>
                <span class="s0">payload: payload</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">WASI_THREADS_MAX_TID = </span><span class="s3">0x1FFFFFFF</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">checkSharedWasmMemory(wasmMemory) {</span>
        <span class="s1">if </span><span class="s0">(wasmMemory) {</span>
            <span class="s1">if </span><span class="s0">(!isSharedArrayBuffer(wasmMemory.buffer)) {</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Multithread features require shared wasm memory. ' </span><span class="s0">+</span>
                    <span class="s2">'Try to compile with `-matomics -mbulk-memory` and use `--import-memory --shared-memory` during linking, ' </span><span class="s0">+</span>
                    <span class="s2">'then create WebAssembly.Memory with `shared: true` option'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">SharedArrayBuffer === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Current environment does not support SharedArrayBuffer, threads are not available!'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getReuseWorker(value) {</span>
        <span class="s1">var </span><span class="s0">_a;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">'boolean'</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">value ? { size: </span><span class="s3">0</span><span class="s0">, strict: </span><span class="s1">false </span><span class="s0">} : </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">'number'</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(!(value &gt;= </span><span class="s3">0</span><span class="s0">)) {</span>
                <span class="s1">throw new </span><span class="s0">RangeError(</span><span class="s2">'reuseWorker: size must be a non-negative integer'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">{ size: value, strict: </span><span class="s1">false </span><span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!value) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">size = (_a = Number(value.size)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _a !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? _a : </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">strict = Boolean(value.strict);</span>
        <span class="s1">if </span><span class="s0">(!(size &gt; </span><span class="s3">0</span><span class="s0">) &amp;&amp; strict) {</span>
            <span class="s1">throw new </span><span class="s0">RangeError(</span><span class="s2">'reuseWorker: size must be set to positive integer if strict is set to true'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{ size: size, strict: strict };</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">nextWorkerID = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s4">/** </span><span class="s5">@public </span><span class="s4">*/</span>
    <span class="s1">var </span><span class="s0">ThreadManager = </span><span class="s4">/*#__PURE__*/ </span><span class="s0">(</span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">function </span><span class="s0">ThreadManager(options) {</span>
            <span class="s1">var </span><span class="s0">_a;</span>
            <span class="s1">this</span><span class="s0">.unusedWorkers = [];</span>
            <span class="s1">this</span><span class="s0">.runningWorkers = [];</span>
            <span class="s1">this</span><span class="s0">.pthreads = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.wasmModule = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.wasmMemory = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.messageEvents = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
            <span class="s1">if </span><span class="s0">(!options) {</span>
                <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'ThreadManager(): options is not provided'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">'childThread' </span><span class="s1">in </span><span class="s0">options) {</span>
                <span class="s1">this</span><span class="s0">._childThread = Boolean(options.childThread);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">._childThread = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._childThread) {</span>
                <span class="s1">this</span><span class="s0">._onCreateWorker = undefined;</span>
                <span class="s1">this</span><span class="s0">._reuseWorker = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">._beforeLoad = undefined;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">._onCreateWorker = options.onCreateWorker;</span>
                <span class="s1">this</span><span class="s0">._reuseWorker = getReuseWorker(options.reuseWorker);</span>
                <span class="s1">this</span><span class="s0">._beforeLoad = options.beforeLoad;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.printErr = (_a = options.printErr) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _a !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? _a : console.error.bind(console);</span>
        <span class="s0">}</span>
        <span class="s0">Object.defineProperty(ThreadManager.prototype, </span><span class="s2">&quot;nextWorkerID&quot;</span><span class="s0">, {</span>
            <span class="s0">get: </span><span class="s1">function </span><span class="s0">() { </span><span class="s1">return </span><span class="s0">nextWorkerID; },</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
        <span class="s0">ThreadManager.prototype.init = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._childThread) {</span>
                <span class="s1">this</span><span class="s0">.initMainThread();</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.initMainThread = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.preparePool();</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.preparePool = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._reuseWorker) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._reuseWorker.size) {</span>
                    <span class="s1">var </span><span class="s0">pthreadPoolSize = </span><span class="s1">this</span><span class="s0">._reuseWorker.size;</span>
                    <span class="s1">while </span><span class="s0">(pthreadPoolSize--) {</span>
                        <span class="s1">var </span><span class="s0">worker = </span><span class="s1">this</span><span class="s0">.allocateUnusedWorker();</span>
                        <span class="s1">if </span><span class="s0">(ENVIRONMENT_IS_NODE) {</span>
                            <span class="s4">// https://github.com/nodejs/node/issues/53036</span>
                            <span class="s0">worker.once(</span><span class="s2">'message'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() { });</span>
                            <span class="s0">worker.unref();</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.shouldPreloadWorkers = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">._childThread &amp;&amp; </span><span class="s1">this</span><span class="s0">._reuseWorker &amp;&amp; </span><span class="s1">this</span><span class="s0">._reuseWorker.size &gt; </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.loadWasmModuleToAllWorkers = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">_this_1 = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">promises = Array(</span><span class="s1">this</span><span class="s0">.unusedWorkers.length);</span>
            <span class="s1">var </span><span class="s0">_loop_1 = </span><span class="s1">function </span><span class="s0">(i) {</span>
                <span class="s1">var </span><span class="s0">worker = this_1.unusedWorkers[i];</span>
                <span class="s1">if </span><span class="s0">(ENVIRONMENT_IS_NODE)</span>
                    <span class="s0">worker.ref();</span>
                <span class="s0">promises[i] = this_1.loadWasmModuleToWorker(worker).then(</span><span class="s1">function </span><span class="s0">(w) {</span>
                    <span class="s1">if </span><span class="s0">(ENVIRONMENT_IS_NODE)</span>
                        <span class="s0">worker.unref();</span>
                    <span class="s1">return </span><span class="s0">w;</span>
                <span class="s0">}, </span><span class="s1">function </span><span class="s0">(e) {</span>
                    <span class="s1">if </span><span class="s0">(ENVIRONMENT_IS_NODE)</span>
                        <span class="s0">worker.unref();</span>
                    <span class="s1">throw </span><span class="s0">e;</span>
                <span class="s0">});</span>
            <span class="s0">};</span>
            <span class="s1">var </span><span class="s0">this_1 = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.unusedWorkers.length; ++i) {</span>
                <span class="s0">_loop_1(i);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Promise.all(promises).catch(</span><span class="s1">function </span><span class="s0">(err) {</span>
                <span class="s0">_this_1.terminateAllThreads();</span>
                <span class="s1">throw </span><span class="s0">err;</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.preloadWorkers = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldPreloadWorkers()) {</span>
                <span class="s1">return this</span><span class="s0">.loadWasmModuleToAllWorkers();</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Promise.resolve([]);</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.setup = </span><span class="s1">function </span><span class="s0">(wasmModule, wasmMemory) {</span>
            <span class="s1">this</span><span class="s0">.wasmModule = wasmModule;</span>
            <span class="s1">this</span><span class="s0">.wasmMemory = wasmMemory;</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.markId = </span><span class="s1">function </span><span class="s0">(worker) {</span>
            <span class="s1">if </span><span class="s0">(worker.__emnapi_tid)</span>
                <span class="s1">return </span><span class="s0">worker.__emnapi_tid;</span>
            <span class="s1">var </span><span class="s0">tid = nextWorkerID + </span><span class="s3">43</span><span class="s0">;</span>
            <span class="s0">nextWorkerID = (nextWorkerID + </span><span class="s3">1</span><span class="s0">) % (WASI_THREADS_MAX_TID - </span><span class="s3">42</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.pthreads[tid] = worker;</span>
            <span class="s0">worker.__emnapi_tid = tid;</span>
            <span class="s1">return </span><span class="s0">tid;</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.returnWorkerToPool = </span><span class="s1">function </span><span class="s0">(worker) {</span>
            <span class="s1">var </span><span class="s0">tid = worker.__emnapi_tid;</span>
            <span class="s1">if </span><span class="s0">(tid !== undefined) {</span>
                <span class="s1">delete this</span><span class="s0">.pthreads[tid];</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.unusedWorkers.push(worker);</span>
            <span class="s1">this</span><span class="s0">.runningWorkers.splice(</span><span class="s1">this</span><span class="s0">.runningWorkers.indexOf(worker), </span><span class="s3">1</span><span class="s0">);</span>
            <span class="s1">delete </span><span class="s0">worker.__emnapi_tid;</span>
            <span class="s1">if </span><span class="s0">(ENVIRONMENT_IS_NODE) {</span>
                <span class="s0">worker.unref();</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.loadWasmModuleToWorker = </span><span class="s1">function </span><span class="s0">(worker, sab) {</span>
            <span class="s1">var </span><span class="s0">_this_1 = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(worker.whenLoaded)</span>
                <span class="s1">return </span><span class="s0">worker.whenLoaded;</span>
            <span class="s1">var </span><span class="s0">err = </span><span class="s1">this</span><span class="s0">.printErr;</span>
            <span class="s1">var </span><span class="s0">beforeLoad = </span><span class="s1">this</span><span class="s0">._beforeLoad;</span>
            <span class="s4">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
            <span class="s1">var </span><span class="s0">_this = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s0">worker.whenLoaded = </span><span class="s1">new </span><span class="s0">Promise(</span><span class="s1">function </span><span class="s0">(resolve, reject) {</span>
                <span class="s1">var </span><span class="s0">handleError = </span><span class="s1">function </span><span class="s0">(e) {</span>
                    <span class="s1">var </span><span class="s0">message = </span><span class="s2">'worker sent an error!'</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(worker.__emnapi_tid !== undefined) {</span>
                        <span class="s0">message = </span><span class="s2">'worker (tid = ' </span><span class="s0">+ worker.__emnapi_tid + </span><span class="s2">') sent an error!'</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s2">'message' </span><span class="s1">in </span><span class="s0">e) {</span>
                        <span class="s0">err(message + </span><span class="s2">' ' </span><span class="s0">+ e.message);</span>
                        <span class="s1">if </span><span class="s0">(e.message.indexOf(</span><span class="s2">'RuntimeError'</span><span class="s0">) !== -</span><span class="s3">1 </span><span class="s0">|| e.message.indexOf(</span><span class="s2">'unreachable'</span><span class="s0">) !== -</span><span class="s3">1</span><span class="s0">) {</span>
                            <span class="s1">try </span><span class="s0">{</span>
                                <span class="s0">_this.terminateAllThreads();</span>
                            <span class="s0">}</span>
                            <span class="s1">catch </span><span class="s0">(_) { }</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">err(message);</span>
                    <span class="s0">}</span>
                    <span class="s0">reject(e);</span>
                    <span class="s1">throw </span><span class="s0">e;</span>
                <span class="s0">};</span>
                <span class="s1">var </span><span class="s0">handleMessage = </span><span class="s1">function </span><span class="s0">(data) {</span>
                    <span class="s1">if </span><span class="s0">(data.__emnapi__) {</span>
                        <span class="s1">var </span><span class="s0">type = data.__emnapi__.type;</span>
                        <span class="s1">var </span><span class="s0">payload = data.__emnapi__.payload;</span>
                        <span class="s1">if </span><span class="s0">(type === </span><span class="s2">'loaded'</span><span class="s0">) {</span>
                            <span class="s0">worker.loaded = </span><span class="s1">true</span><span class="s0">;</span>
                            <span class="s1">if </span><span class="s0">(ENVIRONMENT_IS_NODE &amp;&amp; !worker.__emnapi_tid) {</span>
                                <span class="s0">worker.unref();</span>
                            <span class="s0">}</span>
                            <span class="s0">resolve(worker);</span>
                            <span class="s4">// if (payload.err) {</span>
                            <span class="s4">//   err('failed to load in child thread: ' + (payload.err.message || payload.err))</span>
                            <span class="s4">// }</span>
                        <span class="s0">}</span>
                        <span class="s1">else if </span><span class="s0">(type === </span><span class="s2">'cleanup-thread'</span><span class="s0">) {</span>
                            <span class="s1">if </span><span class="s0">(payload.tid </span><span class="s1">in </span><span class="s0">_this_1.pthreads) {</span>
                                <span class="s0">_this_1.cleanThread(worker, payload.tid);</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">};</span>
                <span class="s0">worker.onmessage = </span><span class="s1">function </span><span class="s0">(e) {</span>
                    <span class="s0">handleMessage(e.data);</span>
                    <span class="s0">_this_1.fireMessageEvent(worker, e);</span>
                <span class="s0">};</span>
                <span class="s0">worker.onerror = handleError;</span>
                <span class="s1">if </span><span class="s0">(ENVIRONMENT_IS_NODE) {</span>
                    <span class="s0">worker.on(</span><span class="s2">'message'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(data) {</span>
                        <span class="s1">var </span><span class="s0">_a, _b;</span>
                        <span class="s0">(_b = (_a = worker).onmessage) === </span><span class="s1">null </span><span class="s0">|| _b === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: _b.call(_a, {</span>
                            <span class="s0">data: data</span>
                        <span class="s0">});</span>
                    <span class="s0">});</span>
                    <span class="s0">worker.on(</span><span class="s2">'error'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(e) {</span>
                        <span class="s1">var </span><span class="s0">_a, _b;</span>
                        <span class="s0">(_b = (_a = worker).onerror) === </span><span class="s1">null </span><span class="s0">|| _b === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: _b.call(_a, e);</span>
                    <span class="s0">});</span>
                    <span class="s0">worker.on(</span><span class="s2">'detachedExit'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() { });</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">beforeLoad === </span><span class="s2">'function'</span><span class="s0">) {</span>
                    <span class="s0">beforeLoad(worker);</span>
                <span class="s0">}</span>
                <span class="s1">try </span><span class="s0">{</span>
                    <span class="s0">worker.postMessage(createMessage(</span><span class="s2">'load'</span><span class="s0">, {</span>
                        <span class="s0">wasmModule: _this_1.wasmModule,</span>
                        <span class="s0">wasmMemory: _this_1.wasmMemory,</span>
                        <span class="s0">sab: sab</span>
                    <span class="s0">}));</span>
                <span class="s0">}</span>
                <span class="s1">catch </span><span class="s0">(err) {</span>
                    <span class="s0">checkSharedWasmMemory(_this_1.wasmMemory);</span>
                    <span class="s1">throw </span><span class="s0">err;</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s1">return </span><span class="s0">worker.whenLoaded;</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.allocateUnusedWorker = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">_onCreateWorker = </span><span class="s1">this</span><span class="s0">._onCreateWorker;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">_onCreateWorker !== </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'`options.onCreateWorker` is not provided'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">worker = _onCreateWorker({ type: </span><span class="s2">'thread'</span><span class="s0">, name: </span><span class="s2">'emnapi-pthread' </span><span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.unusedWorkers.push(worker);</span>
            <span class="s1">return </span><span class="s0">worker;</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.getNewWorker = </span><span class="s1">function </span><span class="s0">(sab) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._reuseWorker) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.unusedWorkers.length === </span><span class="s3">0</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._reuseWorker.strict) {</span>
                        <span class="s1">if </span><span class="s0">(!ENVIRONMENT_IS_NODE) {</span>
                            <span class="s1">var </span><span class="s0">err = </span><span class="s1">this</span><span class="s0">.printErr;</span>
                            <span class="s0">err(</span><span class="s2">'Tried to spawn a new thread, but the thread pool is exhausted.</span><span class="s6">\n</span><span class="s2">' </span><span class="s0">+</span>
                                <span class="s2">'This might result in a deadlock unless some threads eventually exit or the code explicitly breaks out to the event loop.'</span><span class="s0">);</span>
                            <span class="s1">return</span><span class="s0">;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">var </span><span class="s0">worker_1 = </span><span class="s1">this</span><span class="s0">.allocateUnusedWorker();</span>
                    <span class="s4">// eslint-disable-next-line @typescript-eslint/no-floating-promises</span>
                    <span class="s1">this</span><span class="s0">.loadWasmModuleToWorker(worker_1, sab);</span>
                <span class="s0">}</span>
                <span class="s1">return this</span><span class="s0">.unusedWorkers.pop();</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">worker = </span><span class="s1">this</span><span class="s0">.allocateUnusedWorker();</span>
            <span class="s4">// eslint-disable-next-line @typescript-eslint/no-floating-promises</span>
            <span class="s1">this</span><span class="s0">.loadWasmModuleToWorker(worker, sab);</span>
            <span class="s1">return this</span><span class="s0">.unusedWorkers.pop();</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.cleanThread = </span><span class="s1">function </span><span class="s0">(worker, tid, force) {</span>
            <span class="s1">if </span><span class="s0">(!force &amp;&amp; </span><span class="s1">this</span><span class="s0">._reuseWorker) {</span>
                <span class="s1">this</span><span class="s0">.returnWorkerToPool(worker);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">delete this</span><span class="s0">.pthreads[tid];</span>
                <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">.runningWorkers.indexOf(worker);</span>
                <span class="s1">if </span><span class="s0">(index !== -</span><span class="s3">1</span><span class="s0">) {</span>
                    <span class="s1">this</span><span class="s0">.runningWorkers.splice(index, </span><span class="s3">1</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.terminateWorker(worker);</span>
                <span class="s1">delete </span><span class="s0">worker.__emnapi_tid;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.terminateWorker = </span><span class="s1">function </span><span class="s0">(worker) {</span>
            <span class="s1">var </span><span class="s0">_this_1 = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">_a;</span>
            <span class="s1">var </span><span class="s0">tid = worker.__emnapi_tid;</span>
            <span class="s4">// eslint-disable-next-line @typescript-eslint/no-floating-promises</span>
            <span class="s0">worker.terminate();</span>
            <span class="s0">(_a = </span><span class="s1">this</span><span class="s0">.messageEvents.get(worker)) === </span><span class="s1">null </span><span class="s0">|| _a === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: _a.clear();</span>
            <span class="s1">this</span><span class="s0">.messageEvents.delete(worker);</span>
            <span class="s0">worker.onmessage = </span><span class="s1">function </span><span class="s0">(e) {</span>
                <span class="s1">if </span><span class="s0">(e.data.__emnapi__) {</span>
                    <span class="s1">var </span><span class="s0">err = _this_1.printErr;</span>
                    <span class="s0">err(</span><span class="s2">'received &quot;' </span><span class="s0">+ e.data.__emnapi__.type + </span><span class="s2">'&quot; command from terminated worker: ' </span><span class="s0">+ tid);</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.terminateAllThreads = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.runningWorkers.length; ++i) {</span>
                <span class="s1">this</span><span class="s0">.terminateWorker(</span><span class="s1">this</span><span class="s0">.runningWorkers[i]);</span>
            <span class="s0">}</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.unusedWorkers.length; ++i) {</span>
                <span class="s1">this</span><span class="s0">.terminateWorker(</span><span class="s1">this</span><span class="s0">.unusedWorkers[i]);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.unusedWorkers = [];</span>
            <span class="s1">this</span><span class="s0">.runningWorkers = [];</span>
            <span class="s1">this</span><span class="s0">.pthreads = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.preparePool();</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.addMessageEventListener = </span><span class="s1">function </span><span class="s0">(worker, onMessage) {</span>
            <span class="s1">var </span><span class="s0">listeners = </span><span class="s1">this</span><span class="s0">.messageEvents.get(worker);</span>
            <span class="s1">if </span><span class="s0">(!listeners) {</span>
                <span class="s0">listeners = </span><span class="s1">new </span><span class="s0">Set();</span>
                <span class="s1">this</span><span class="s0">.messageEvents.set(worker, listeners);</span>
            <span class="s0">}</span>
            <span class="s0">listeners.add(onMessage);</span>
            <span class="s1">return function </span><span class="s0">() {</span>
                <span class="s0">listeners === </span><span class="s1">null </span><span class="s0">|| listeners === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: listeners.delete(onMessage);</span>
            <span class="s0">};</span>
        <span class="s0">};</span>
        <span class="s0">ThreadManager.prototype.fireMessageEvent = </span><span class="s1">function </span><span class="s0">(worker, e) {</span>
            <span class="s1">var </span><span class="s0">listeners = </span><span class="s1">this</span><span class="s0">.messageEvents.get(worker);</span>
            <span class="s1">if </span><span class="s0">(!listeners)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">err = </span><span class="s1">this</span><span class="s0">.printErr;</span>
            <span class="s0">listeners.forEach(</span><span class="s1">function </span><span class="s0">(listener) {</span>
                <span class="s1">try </span><span class="s0">{</span>
                    <span class="s0">listener(e);</span>
                <span class="s0">}</span>
                <span class="s1">catch </span><span class="s0">(e) {</span>
                    <span class="s0">err(e.stack);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">ThreadManager;</span>
    <span class="s0">}());</span>

    <span class="s1">var </span><span class="s0">kIsProxy = Symbol(</span><span class="s2">'kIsProxy'</span><span class="s0">);</span>
    <span class="s4">/** </span><span class="s5">@public </span><span class="s4">*/</span>
    <span class="s1">function </span><span class="s0">createInstanceProxy(instance, memory) {</span>
        <span class="s1">if </span><span class="s0">(instance[kIsProxy])</span>
            <span class="s1">return </span><span class="s0">instance;</span>
        <span class="s4">// https://github.com/nodejs/help/issues/4102</span>
        <span class="s1">var </span><span class="s0">originalExports = instance.exports;</span>
        <span class="s1">var </span><span class="s0">createHandler = </span><span class="s1">function </span><span class="s0">(target) {</span>
            <span class="s1">var </span><span class="s0">handlers = [</span>
                <span class="s2">'apply'</span><span class="s0">,</span>
                <span class="s2">'construct'</span><span class="s0">,</span>
                <span class="s2">'defineProperty'</span><span class="s0">,</span>
                <span class="s2">'deleteProperty'</span><span class="s0">,</span>
                <span class="s2">'get'</span><span class="s0">,</span>
                <span class="s2">'getOwnPropertyDescriptor'</span><span class="s0">,</span>
                <span class="s2">'getPrototypeOf'</span><span class="s0">,</span>
                <span class="s2">'has'</span><span class="s0">,</span>
                <span class="s2">'isExtensible'</span><span class="s0">,</span>
                <span class="s2">'ownKeys'</span><span class="s0">,</span>
                <span class="s2">'preventExtensions'</span><span class="s0">,</span>
                <span class="s2">'set'</span><span class="s0">,</span>
                <span class="s2">'setPrototypeOf'</span>
            <span class="s0">];</span>
            <span class="s1">var </span><span class="s0">handler = {};</span>
            <span class="s1">var </span><span class="s0">_loop_1 = </span><span class="s1">function </span><span class="s0">(i) {</span>
                <span class="s1">var </span><span class="s0">name_1 = handlers[i];</span>
                <span class="s0">handler[name_1] = </span><span class="s1">function </span><span class="s0">() {</span>
                    <span class="s1">var </span><span class="s0">args = Array.prototype.slice.call(arguments, </span><span class="s3">1</span><span class="s0">);</span>
                    <span class="s0">args.unshift(target);</span>
                    <span class="s1">return </span><span class="s0">Reflect[name_1].apply(Reflect, args);</span>
                <span class="s0">};</span>
            <span class="s0">};</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; handlers.length; i++) {</span>
                <span class="s0">_loop_1(i);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">handler;</span>
        <span class="s0">};</span>
        <span class="s1">var </span><span class="s0">handler = createHandler(originalExports);</span>
        <span class="s1">var </span><span class="s0">_initialize = </span><span class="s1">function </span><span class="s0">() { };</span>
        <span class="s1">var </span><span class="s0">_start = </span><span class="s1">function </span><span class="s0">() { </span><span class="s1">return </span><span class="s3">0</span><span class="s0">; };</span>
        <span class="s0">handler.get = </span><span class="s1">function </span><span class="s0">(_target, p, receiver) {</span>
            <span class="s1">var </span><span class="s0">_a;</span>
            <span class="s1">if </span><span class="s0">(p === </span><span class="s2">'memory'</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">(_a = (</span><span class="s1">typeof </span><span class="s0">memory === </span><span class="s2">'function' </span><span class="s0">? memory() : memory)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _a !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? _a : Reflect.get(originalExports, p, receiver);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(p === </span><span class="s2">'_initialize'</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">p </span><span class="s1">in </span><span class="s0">originalExports ? _initialize : undefined;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(p === </span><span class="s2">'_start'</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">p </span><span class="s1">in </span><span class="s0">originalExports ? _start : undefined;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Reflect.get(originalExports, p, receiver);</span>
        <span class="s0">};</span>
        <span class="s0">handler.has = </span><span class="s1">function </span><span class="s0">(_target, p) {</span>
            <span class="s1">if </span><span class="s0">(p === </span><span class="s2">'memory'</span><span class="s0">)</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">Reflect.has(originalExports, p);</span>
        <span class="s0">};</span>
        <span class="s1">var </span><span class="s0">exportsProxy = </span><span class="s1">new </span><span class="s0">Proxy(Object.create(</span><span class="s1">null</span><span class="s0">), handler);</span>
        <span class="s1">return new </span><span class="s0">Proxy(instance, {</span>
            <span class="s0">get: </span><span class="s1">function </span><span class="s0">(target, p, receiver) {</span>
                <span class="s1">if </span><span class="s0">(p === </span><span class="s2">'exports'</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s0">exportsProxy;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(p === kIsProxy) {</span>
                    <span class="s1">return true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">Reflect.get(target, p, receiver);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">patchedWasiInstances = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s4">/** </span><span class="s5">@public </span><span class="s4">*/</span>
    <span class="s1">var </span><span class="s0">WASIThreads = </span><span class="s4">/*#__PURE__*/ </span><span class="s0">(</span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">function </span><span class="s0">WASIThreads(options) {</span>
            <span class="s1">var </span><span class="s0">_this_1 = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!options) {</span>
                <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'WASIThreads(): options is not provided'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!options.wasi) {</span>
                <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'WASIThreads(): options.wasi is not provided'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">patchedWasiInstances.set(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">new </span><span class="s0">WeakSet());</span>
            <span class="s1">var </span><span class="s0">wasi = options.wasi;</span>
            <span class="s0">patchWasiInstance(</span><span class="s1">this</span><span class="s0">, wasi);</span>
            <span class="s1">this</span><span class="s0">.wasi = wasi;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">'childThread' </span><span class="s1">in </span><span class="s0">options) {</span>
                <span class="s1">this</span><span class="s0">.childThread = Boolean(options.childThread);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.childThread = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.PThread = undefined;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">'threadManager' </span><span class="s1">in </span><span class="s0">options) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">options.threadManager === </span><span class="s2">'function'</span><span class="s0">) {</span>
                    <span class="s1">this</span><span class="s0">.PThread = options.threadManager();</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">this</span><span class="s0">.PThread = options.threadManager;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.childThread) {</span>
                    <span class="s1">this</span><span class="s0">.PThread = </span><span class="s1">new </span><span class="s0">ThreadManager(options);</span>
                    <span class="s1">this</span><span class="s0">.PThread.init();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">waitThreadStart = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">'waitThreadStart' </span><span class="s1">in </span><span class="s0">options) {</span>
                <span class="s0">waitThreadStart = </span><span class="s1">typeof </span><span class="s0">options.waitThreadStart === </span><span class="s2">'number' </span><span class="s0">? options.waitThreadStart : Boolean(options.waitThreadStart);</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">postMessage = getPostMessage(options);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.childThread &amp;&amp; </span><span class="s1">typeof </span><span class="s0">postMessage !== </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'options.postMessage is not a function'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.postMessage = postMessage;</span>
            <span class="s1">var </span><span class="s0">wasm64 = Boolean(options.wasm64);</span>
            <span class="s1">var </span><span class="s0">onMessage = </span><span class="s1">function </span><span class="s0">(e) {</span>
                <span class="s1">if </span><span class="s0">(e.data.__emnapi__) {</span>
                    <span class="s1">var </span><span class="s0">type = e.data.__emnapi__.type;</span>
                    <span class="s1">var </span><span class="s0">payload = e.data.__emnapi__.payload;</span>
                    <span class="s1">if </span><span class="s0">(type === </span><span class="s2">'spawn-thread'</span><span class="s0">) {</span>
                        <span class="s0">threadSpawn(payload.startArg, payload.errorOrTid);</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(type === </span><span class="s2">'terminate-all-threads'</span><span class="s0">) {</span>
                        <span class="s0">_this_1.terminateAllThreads();</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s1">var </span><span class="s0">threadSpawn = </span><span class="s1">function </span><span class="s0">(startArg, errorOrTid) {</span>
                <span class="s1">var </span><span class="s0">_a;</span>
                <span class="s1">var </span><span class="s0">EAGAIN = </span><span class="s3">6</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">isNewABI = errorOrTid !== undefined;</span>
                <span class="s1">try </span><span class="s0">{</span>
                    <span class="s0">checkSharedWasmMemory(_this_1.wasmMemory);</span>
                <span class="s0">}</span>
                <span class="s1">catch </span><span class="s0">(err) {</span>
                    <span class="s0">(_a = _this_1.PThread) === </span><span class="s1">null </span><span class="s0">|| _a === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: _a.printErr(err.stack);</span>
                    <span class="s1">if </span><span class="s0">(isNewABI) {</span>
                        <span class="s1">var </span><span class="s0">struct_1 = </span><span class="s1">new </span><span class="s0">Int32Array(_this_1.wasmMemory.buffer, errorOrTid, </span><span class="s3">2</span><span class="s0">);</span>
                        <span class="s0">Atomics.store(struct_1, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">);</span>
                        <span class="s0">Atomics.store(struct_1, </span><span class="s3">1</span><span class="s0">, EAGAIN);</span>
                        <span class="s0">Atomics.notify(struct_1, </span><span class="s3">1</span><span class="s0">);</span>
                        <span class="s1">return </span><span class="s3">1</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">return </span><span class="s0">-EAGAIN;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(!isNewABI) {</span>
                    <span class="s1">var </span><span class="s0">malloc = _this_1.wasmInstance.exports.malloc;</span>
                    <span class="s0">errorOrTid = wasm64 ? Number(malloc(BigInt(</span><span class="s3">8</span><span class="s0">))) : malloc(</span><span class="s3">8</span><span class="s0">);</span>
                    <span class="s1">if </span><span class="s0">(!errorOrTid) {</span>
                        <span class="s1">return </span><span class="s0">-</span><span class="s3">48</span><span class="s0">; </span><span class="s4">/* ENOMEM */</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">var </span><span class="s0">_free = _this_1.wasmInstance.exports.free;</span>
                <span class="s1">var </span><span class="s0">free = wasm64 ? </span><span class="s1">function </span><span class="s0">(ptr) { _free(BigInt(ptr)); } : _free;</span>
                <span class="s1">var </span><span class="s0">struct = </span><span class="s1">new </span><span class="s0">Int32Array(_this_1.wasmMemory.buffer, errorOrTid, </span><span class="s3">2</span><span class="s0">);</span>
                <span class="s0">Atomics.store(struct, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">);</span>
                <span class="s0">Atomics.store(struct, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(_this_1.childThread) {</span>
                    <span class="s0">postMessage(createMessage(</span><span class="s2">'spawn-thread'</span><span class="s0">, {</span>
                        <span class="s0">startArg: startArg,</span>
                        <span class="s0">errorOrTid: errorOrTid</span>
                    <span class="s0">}));</span>
                    <span class="s0">Atomics.wait(struct, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">);</span>
                    <span class="s1">var </span><span class="s0">isError = Atomics.load(struct, </span><span class="s3">0</span><span class="s0">);</span>
                    <span class="s1">var </span><span class="s0">result = Atomics.load(struct, </span><span class="s3">1</span><span class="s0">);</span>
                    <span class="s1">if </span><span class="s0">(isNewABI) {</span>
                        <span class="s1">return </span><span class="s0">isError;</span>
                    <span class="s0">}</span>
                    <span class="s0">free(errorOrTid);</span>
                    <span class="s1">return </span><span class="s0">isError ? -result : result;</span>
                <span class="s0">}</span>
                <span class="s1">var </span><span class="s0">shouldWait = waitThreadStart || (waitThreadStart === </span><span class="s3">0</span><span class="s0">);</span>
                <span class="s1">var </span><span class="s0">sab;</span>
                <span class="s1">if </span><span class="s0">(shouldWait) {</span>
                    <span class="s0">sab = </span><span class="s1">new </span><span class="s0">Int32Array(</span><span class="s1">new </span><span class="s0">SharedArrayBuffer(</span><span class="s3">16 </span><span class="s0">+ </span><span class="s3">8192</span><span class="s0">));</span>
                    <span class="s0">Atomics.store(sab, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">var </span><span class="s0">worker;</span>
                <span class="s1">var </span><span class="s0">tid;</span>
                <span class="s1">var </span><span class="s0">PThread = _this_1.PThread;</span>
                <span class="s1">try </span><span class="s0">{</span>
                    <span class="s0">worker = PThread.getNewWorker(sab);</span>
                    <span class="s1">if </span><span class="s0">(!worker) {</span>
                        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'failed to get new worker'</span><span class="s0">);</span>
                    <span class="s0">}</span>
                    <span class="s0">PThread.addMessageEventListener(worker, onMessage);</span>
                    <span class="s0">tid = PThread.markId(worker);</span>
                    <span class="s1">if </span><span class="s0">(ENVIRONMENT_IS_NODE) {</span>
                        <span class="s0">worker.ref();</span>
                    <span class="s0">}</span>
                    <span class="s0">worker.postMessage(createMessage(</span><span class="s2">'start'</span><span class="s0">, {</span>
                        <span class="s0">tid: tid,</span>
                        <span class="s0">arg: startArg,</span>
                        <span class="s0">sab: sab</span>
                    <span class="s0">}));</span>
                    <span class="s1">if </span><span class="s0">(shouldWait) {</span>
                        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">waitThreadStart === </span><span class="s2">'number'</span><span class="s0">) {</span>
                            <span class="s1">var </span><span class="s0">waitResult = Atomics.wait(sab, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, waitThreadStart);</span>
                            <span class="s1">if </span><span class="s0">(waitResult === </span><span class="s2">'timed-out'</span><span class="s0">) {</span>
                                <span class="s1">try </span><span class="s0">{</span>
                                    <span class="s0">PThread.cleanThread(worker, tid, </span><span class="s1">true</span><span class="s0">);</span>
                                <span class="s0">}</span>
                                <span class="s1">catch </span><span class="s0">(_) { }</span>
                                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Spawning thread timed out. Please check if the worker is created successfully and if message is handled properly in the worker.'</span><span class="s0">);</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                        <span class="s1">else </span><span class="s0">{</span>
                            <span class="s0">Atomics.wait(sab, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">);</span>
                        <span class="s0">}</span>
                        <span class="s1">var </span><span class="s0">r = Atomics.load(sab, </span><span class="s3">0</span><span class="s0">);</span>
                        <span class="s1">if </span><span class="s0">(r &gt; </span><span class="s3">1</span><span class="s0">) {</span>
                            <span class="s1">try </span><span class="s0">{</span>
                                <span class="s0">PThread.cleanThread(worker, tid, </span><span class="s1">true</span><span class="s0">);</span>
                            <span class="s0">}</span>
                            <span class="s1">catch </span><span class="s0">(_) { }</span>
                            <span class="s1">throw </span><span class="s0">deserizeErrorFromBuffer(sab.buffer);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">catch </span><span class="s0">(e) {</span>
                    <span class="s0">Atomics.store(struct, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">);</span>
                    <span class="s0">Atomics.store(struct, </span><span class="s3">1</span><span class="s0">, EAGAIN);</span>
                    <span class="s0">Atomics.notify(struct, </span><span class="s3">1</span><span class="s0">);</span>
                    <span class="s0">PThread === </span><span class="s1">null </span><span class="s0">|| PThread === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: PThread.printErr(e.stack);</span>
                    <span class="s1">if </span><span class="s0">(isNewABI) {</span>
                        <span class="s1">return </span><span class="s3">1</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s0">free(errorOrTid);</span>
                    <span class="s1">return </span><span class="s0">-EAGAIN;</span>
                <span class="s0">}</span>
                <span class="s0">Atomics.store(struct, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">);</span>
                <span class="s0">Atomics.store(struct, </span><span class="s3">1</span><span class="s0">, tid);</span>
                <span class="s0">Atomics.notify(struct, </span><span class="s3">1</span><span class="s0">);</span>
                <span class="s0">PThread.runningWorkers.push(worker);</span>
                <span class="s1">if </span><span class="s0">(!shouldWait) {</span>
                    <span class="s0">worker.whenLoaded.catch(</span><span class="s1">function </span><span class="s0">(err) {</span>
                        <span class="s1">delete </span><span class="s0">worker.whenLoaded;</span>
                        <span class="s0">PThread.cleanThread(worker, tid, </span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s1">throw </span><span class="s0">err;</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(isNewABI) {</span>
                    <span class="s1">return </span><span class="s3">0</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">free(errorOrTid);</span>
                <span class="s1">return </span><span class="s0">tid;</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.threadSpawn = threadSpawn;</span>
        <span class="s0">}</span>
        <span class="s0">WASIThreads.prototype.getImportObject = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">wasi: {</span>
                    <span class="s2">'thread-spawn'</span><span class="s0">: </span><span class="s1">this</span><span class="s0">.threadSpawn</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
        <span class="s0">};</span>
        <span class="s0">WASIThreads.prototype.setup = </span><span class="s1">function </span><span class="s0">(wasmInstance, wasmModule, wasmMemory) {</span>
            <span class="s0">wasmMemory !== </span><span class="s1">null </span><span class="s0">&amp;&amp; wasmMemory !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? wasmMemory : (wasmMemory = wasmInstance.exports.memory);</span>
            <span class="s1">this</span><span class="s0">.wasmInstance = wasmInstance;</span>
            <span class="s1">this</span><span class="s0">.wasmMemory = wasmMemory;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.PThread) {</span>
                <span class="s1">this</span><span class="s0">.PThread.setup(wasmModule, wasmMemory);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">WASIThreads.prototype.preloadWorkers = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.PThread) {</span>
                <span class="s1">return this</span><span class="s0">.PThread.preloadWorkers();</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">Promise.resolve([]);</span>
        <span class="s0">};</span>
        <span class="s4">/**</span>
         <span class="s4">* It's ok to call this method to a WASI command module.</span>
         <span class="s4">*</span>
         <span class="s4">* in child thread, must call this method instead of {</span><span class="s5">@link </span><span class="s4">WASIThreads.start} even if it's a WASI command module</span>
         <span class="s4">*</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">A proxied WebAssembly instance if in child thread, other wise the original instance</span>
         <span class="s4">*/</span>
        <span class="s0">WASIThreads.prototype.initialize = </span><span class="s1">function </span><span class="s0">(instance, module, memory) {</span>
            <span class="s1">var </span><span class="s0">exports = instance.exports;</span>
            <span class="s0">memory !== </span><span class="s1">null </span><span class="s0">&amp;&amp; memory !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? memory : (memory = exports.memory);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.childThread) {</span>
                <span class="s0">instance = createInstanceProxy(instance, memory);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.setup(instance, module, memory);</span>
            <span class="s1">var </span><span class="s0">wasi = </span><span class="s1">this</span><span class="s0">.wasi;</span>
            <span class="s1">if </span><span class="s0">((</span><span class="s2">'_start' </span><span class="s1">in </span><span class="s0">exports) &amp;&amp; (</span><span class="s1">typeof </span><span class="s0">exports._start === </span><span class="s2">'function'</span><span class="s0">)) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.childThread) {</span>
                    <span class="s0">wasi.start(instance);</span>
                    <span class="s1">try </span><span class="s0">{</span>
                        <span class="s1">var </span><span class="s0">kStarted = getWasiSymbol(wasi, </span><span class="s2">'kStarted'</span><span class="s0">);</span>
                        <span class="s0">wasi[kStarted] = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">catch </span><span class="s0">(_) { }</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">setupInstance(wasi, instance);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">wasi.initialize(instance);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">instance;</span>
        <span class="s0">};</span>
        <span class="s4">/**</span>
         <span class="s4">* Equivalent to calling {</span><span class="s5">@link </span><span class="s4">WASIThreads.initialize} and then calling {</span><span class="s5">@link </span><span class="s4">WASIInstance.start}</span>
         <span class="s4">* ```js</span>
         <span class="s4">* this.initialize(instance, module, memory)</span>
         <span class="s4">* this.wasi.start(instance)</span>
         <span class="s4">* ```</span>
         <span class="s4">*/</span>
        <span class="s0">WASIThreads.prototype.start = </span><span class="s1">function </span><span class="s0">(instance, module, memory) {</span>
            <span class="s1">var </span><span class="s0">exports = instance.exports;</span>
            <span class="s0">memory !== </span><span class="s1">null </span><span class="s0">&amp;&amp; memory !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? memory : (memory = exports.memory);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.childThread) {</span>
                <span class="s0">instance = createInstanceProxy(instance, memory);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.setup(instance, module, memory);</span>
            <span class="s1">var </span><span class="s0">exitCode = </span><span class="s1">this</span><span class="s0">.wasi.start(instance);</span>
            <span class="s1">return </span><span class="s0">{ exitCode: exitCode, instance: instance };</span>
        <span class="s0">};</span>
        <span class="s0">WASIThreads.prototype.terminateAllThreads = </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">_a;</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.childThread) {</span>
                <span class="s0">(_a = </span><span class="s1">this</span><span class="s0">.PThread) === </span><span class="s1">null </span><span class="s0">|| _a === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: _a.terminateAllThreads();</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.postMessage(createMessage(</span><span class="s2">'terminate-all-threads'</span><span class="s0">, {}));</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">WASIThreads;</span>
    <span class="s0">}());</span>
    <span class="s1">function </span><span class="s0">patchWasiInstance(wasiThreads, wasi) {</span>
        <span class="s1">var </span><span class="s0">patched = patchedWasiInstances.get(wasiThreads);</span>
        <span class="s1">if </span><span class="s0">(patched.has(wasi)) {</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">_this = wasiThreads;</span>
        <span class="s1">var </span><span class="s0">wasiImport = wasi.wasiImport;</span>
        <span class="s1">if </span><span class="s0">(wasiImport) {</span>
            <span class="s1">var </span><span class="s0">proc_exit_1 = wasiImport.proc_exit;</span>
            <span class="s0">wasiImport.proc_exit = </span><span class="s1">function </span><span class="s0">(code) {</span>
                <span class="s0">_this.terminateAllThreads();</span>
                <span class="s1">return </span><span class="s0">proc_exit_1.call(</span><span class="s1">this</span><span class="s0">, code);</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!_this.childThread) {</span>
            <span class="s1">var </span><span class="s0">start_1 = wasi.start;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">start_1 === </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s0">wasi.start = </span><span class="s1">function </span><span class="s0">(instance) {</span>
                    <span class="s1">try </span><span class="s0">{</span>
                        <span class="s1">return </span><span class="s0">start_1.call(</span><span class="s1">this</span><span class="s0">, instance);</span>
                    <span class="s0">}</span>
                    <span class="s1">catch </span><span class="s0">(err) {</span>
                        <span class="s1">if </span><span class="s0">(isTrapError(err)) {</span>
                            <span class="s0">_this.terminateAllThreads();</span>
                        <span class="s0">}</span>
                        <span class="s1">throw </span><span class="s0">err;</span>
                    <span class="s0">}</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">patched.add(wasi);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getWasiSymbol(wasi, description) {</span>
        <span class="s1">var </span><span class="s0">symbols = Object.getOwnPropertySymbols(wasi);</span>
        <span class="s1">var </span><span class="s0">selectDescription = </span><span class="s1">function </span><span class="s0">(description) { </span><span class="s1">return function </span><span class="s0">(s) {</span>
            <span class="s1">if </span><span class="s0">(s.description) {</span>
                <span class="s1">return </span><span class="s0">s.description === description;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">s.toString() === </span><span class="s2">&quot;Symbol(&quot;</span><span class="s0">.concat(description, </span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s0">}; };</span>
        <span class="s1">if </span><span class="s0">(Array.isArray(description)) {</span>
            <span class="s1">return </span><span class="s0">description.map(</span><span class="s1">function </span><span class="s0">(d) { </span><span class="s1">return </span><span class="s0">symbols.filter(selectDescription(d))[</span><span class="s3">0</span><span class="s0">]; });</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">symbols.filter(selectDescription(description))[</span><span class="s3">0</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">setupInstance(wasi, instance) {</span>
        <span class="s1">var </span><span class="s0">_a = getWasiSymbol(wasi, [</span><span class="s2">'kInstance'</span><span class="s0">, </span><span class="s2">'kSetMemory'</span><span class="s0">]), kInstance = _a[</span><span class="s3">0</span><span class="s0">], kSetMemory = _a[</span><span class="s3">1</span><span class="s0">];</span>
        <span class="s0">wasi[kInstance] = instance;</span>
        <span class="s0">wasi[kSetMemory](instance.exports.memory);</span>
    <span class="s0">}</span>

    <span class="s4">/** </span><span class="s5">@public </span><span class="s4">*/</span>
    <span class="s1">var </span><span class="s0">ThreadMessageHandler = </span><span class="s4">/*#__PURE__*/ </span><span class="s0">(</span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">function </span><span class="s0">ThreadMessageHandler(options) {</span>
            <span class="s1">var </span><span class="s0">postMsg = getPostMessage(options);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">postMsg !== </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'options.postMessage is not a function'</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.postMessage = postMsg;</span>
            <span class="s1">this</span><span class="s0">.onLoad = options === </span><span class="s1">null </span><span class="s0">|| options === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: options.onLoad;</span>
            <span class="s1">this</span><span class="s0">.onError = </span><span class="s1">typeof </span><span class="s0">(options === </span><span class="s1">null </span><span class="s0">|| options === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: options.onError) === </span><span class="s2">'function' </span><span class="s0">? options.onError : </span><span class="s1">function </span><span class="s0">(_type, err) { </span><span class="s1">throw </span><span class="s0">err; };</span>
            <span class="s1">this</span><span class="s0">.instance = undefined;</span>
            <span class="s4">// this.module = undefined</span>
            <span class="s1">this</span><span class="s0">.messagesBeforeLoad = [];</span>
        <span class="s0">}</span>
        <span class="s4">/** </span><span class="s5">@virtual </span><span class="s4">*/</span>
        <span class="s0">ThreadMessageHandler.prototype.instantiate = </span><span class="s1">function </span><span class="s0">(data) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof this</span><span class="s0">.onLoad === </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s1">return this</span><span class="s0">.onLoad(data);</span>
            <span class="s0">}</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'ThreadMessageHandler.prototype.instantiate is not implemented'</span><span class="s0">);</span>
        <span class="s0">};</span>
        <span class="s4">/** </span><span class="s5">@virtual </span><span class="s4">*/</span>
        <span class="s0">ThreadMessageHandler.prototype.handle = </span><span class="s1">function </span><span class="s0">(e) {</span>
            <span class="s1">var </span><span class="s0">_this = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">_a;</span>
            <span class="s1">if </span><span class="s0">((_a = e === </span><span class="s1">null </span><span class="s0">|| e === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: e.data) === </span><span class="s1">null </span><span class="s0">|| _a === </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">: _a.__emnapi__) {</span>
                <span class="s1">var </span><span class="s0">type = e.data.__emnapi__.type;</span>
                <span class="s1">var </span><span class="s0">payload_1 = e.data.__emnapi__.payload;</span>
                <span class="s1">try </span><span class="s0">{</span>
                    <span class="s1">if </span><span class="s0">(type === </span><span class="s2">'load'</span><span class="s0">) {</span>
                        <span class="s1">this</span><span class="s0">._load(payload_1);</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(type === </span><span class="s2">'start'</span><span class="s0">) {</span>
                        <span class="s1">this</span><span class="s0">.handleAfterLoad(e, </span><span class="s1">function </span><span class="s0">() {</span>
                            <span class="s0">_this._start(payload_1);</span>
                        <span class="s0">});</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">catch </span><span class="s0">(err) {</span>
                    <span class="s1">this</span><span class="s0">.onError(err, type);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">ThreadMessageHandler.prototype._load = </span><span class="s1">function </span><span class="s0">(payload) {</span>
            <span class="s1">var </span><span class="s0">_this = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.instance !== undefined)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">source;</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">source = </span><span class="s1">this</span><span class="s0">.instantiate(payload);</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(err) {</span>
                <span class="s1">this</span><span class="s0">._loaded(err, </span><span class="s1">null</span><span class="s0">, payload);</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">then = source &amp;&amp; </span><span class="s2">'then' </span><span class="s1">in </span><span class="s0">source ? source.then : undefined;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">then === </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s4">// eslint-disable-next-line @typescript-eslint/no-floating-promises</span>
                <span class="s0">then.call(source, </span><span class="s1">function </span><span class="s0">(source) { _this._loaded(</span><span class="s1">null</span><span class="s0">, source, payload); }, </span><span class="s1">function </span><span class="s0">(err) { _this._loaded(err, </span><span class="s1">null</span><span class="s0">, payload); });</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">._loaded(</span><span class="s1">null</span><span class="s0">, source, payload);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">ThreadMessageHandler.prototype._start = </span><span class="s1">function </span><span class="s0">(payload) {</span>
            <span class="s1">var </span><span class="s0">wasi_thread_start = </span><span class="s1">this</span><span class="s0">.instance.exports.wasi_thread_start;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">wasi_thread_start !== </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">err = </span><span class="s1">new </span><span class="s0">TypeError(</span><span class="s2">'wasi_thread_start is not exported'</span><span class="s0">);</span>
                <span class="s0">notifyPthreadCreateResult(payload.sab, </span><span class="s3">2</span><span class="s0">, err);</span>
                <span class="s1">throw </span><span class="s0">err;</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">postMessage = </span><span class="s1">this</span><span class="s0">.postMessage;</span>
            <span class="s1">var </span><span class="s0">tid = payload.tid;</span>
            <span class="s1">var </span><span class="s0">startArg = payload.arg;</span>
            <span class="s0">notifyPthreadCreateResult(payload.sab, </span><span class="s3">1</span><span class="s0">);</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">wasi_thread_start(tid, startArg);</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(err) {</span>
                <span class="s1">if </span><span class="s0">(err !== </span><span class="s2">'unwind'</span><span class="s0">) {</span>
                    <span class="s1">throw </span><span class="s0">err;</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">postMessage(createMessage(</span><span class="s2">'cleanup-thread'</span><span class="s0">, { tid: tid }));</span>
        <span class="s0">};</span>
        <span class="s0">ThreadMessageHandler.prototype._loaded = </span><span class="s1">function </span><span class="s0">(err, source, payload) {</span>
            <span class="s1">if </span><span class="s0">(err) {</span>
                <span class="s0">notifyPthreadCreateResult(payload.sab, </span><span class="s3">2</span><span class="s0">, err);</span>
                <span class="s1">throw </span><span class="s0">err;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(source == </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">err_1 = </span><span class="s1">new </span><span class="s0">TypeError(</span><span class="s2">'onLoad should return an object'</span><span class="s0">);</span>
                <span class="s0">notifyPthreadCreateResult(payload.sab, </span><span class="s3">2</span><span class="s0">, err_1);</span>
                <span class="s1">throw </span><span class="s0">err_1;</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">instance = source.instance;</span>
            <span class="s1">if </span><span class="s0">(!instance) {</span>
                <span class="s1">var </span><span class="s0">err_2 = </span><span class="s1">new </span><span class="s0">TypeError(</span><span class="s2">'onLoad should return an object which includes &quot;instance&quot;'</span><span class="s0">);</span>
                <span class="s0">notifyPthreadCreateResult(payload.sab, </span><span class="s3">2</span><span class="s0">, err_2);</span>
                <span class="s1">throw </span><span class="s0">err_2;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.instance = instance;</span>
            <span class="s1">var </span><span class="s0">postMessage = </span><span class="s1">this</span><span class="s0">.postMessage;</span>
            <span class="s0">postMessage(createMessage(</span><span class="s2">'loaded'</span><span class="s0">, {}));</span>
            <span class="s1">var </span><span class="s0">messages = </span><span class="s1">this</span><span class="s0">.messagesBeforeLoad;</span>
            <span class="s1">this</span><span class="s0">.messagesBeforeLoad = [];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; messages.length; i++) {</span>
                <span class="s1">var </span><span class="s0">data = messages[i];</span>
                <span class="s1">this</span><span class="s0">.handle({ data: data });</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">ThreadMessageHandler.prototype.handleAfterLoad = </span><span class="s1">function </span><span class="s0">(e, f) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.instance !== undefined) {</span>
                <span class="s0">f.call(</span><span class="s1">this</span><span class="s0">, e);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.messagesBeforeLoad.push(e.data);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">ThreadMessageHandler;</span>
    <span class="s0">}());</span>
    <span class="s1">function </span><span class="s0">notifyPthreadCreateResult(sab, result, error) {</span>
        <span class="s1">if </span><span class="s0">(sab) {</span>
            <span class="s0">serizeErrorToBuffer(sab.buffer, result, error);</span>
            <span class="s0">Atomics.notify(sab, </span><span class="s3">0</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">exports.ThreadManager = ThreadManager;</span>
    <span class="s0">exports.ThreadMessageHandler = ThreadMessageHandler;</span>
    <span class="s0">exports.WASIThreads = WASIThreads;</span>
    <span class="s0">exports.createInstanceProxy = createInstanceProxy;</span>
    <span class="s0">exports.isSharedArrayBuffer = isSharedArrayBuffer;</span>
    <span class="s0">exports.isTrapError = isTrapError;</span>

<span class="s0">}));</span>
</pre>
</body>
</html>