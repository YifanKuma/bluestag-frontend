<html>
<head>
<title>app-route-experimental.runtime.prod.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app-route-experimental.runtime.prod.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;app-route-experimental.runtime.prod.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://next/./dist/compiled/@edge-runtime/cookies/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/cookie/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/p-queue/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/path-to-regexp/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/react-experimental/cjs/react.production.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/react-experimental/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/string-hash/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/format-dynamic-import-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/node/try-get-preview-data.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/crypto-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/node-fs-methods.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/headers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/reflect.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/isomorphic/path.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/modern-browserslist-target.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/superstruct/index.cjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/compat_get_default_export&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/create_fake_namespace_object&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/define_property_getters&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/has_own_property&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/make_namespace_object&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/clone-response.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/picocolors.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/i18n/normalize-locale-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/ensure-leading-slash.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/app-paths.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/segment.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/interception-routes.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/is-dynamic.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/path-has-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/remove-path-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/escape-regexp.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/remove-trailing-slash.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/get-dynamic-param.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-regex.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/route-pattern-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-match-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/querystring.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/prepare-destination.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/decode-query-path-parameter.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/format-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/types.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/app-router-headers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/generate-interception-routes-rewrites.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/server-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/i18n/detect-domain-locale.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/get-hostname.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-data-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/request-meta.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-page-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/metadata/is-metadata-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/detached-promise.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/batcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/scheduler.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/types.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/stream-utils/node-web-streams-helper.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/stream-utils/encoded-tags.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-path-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-path-suffix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/next-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/get-next-pathname-info.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/format-next-pathname-info.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-locale.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/request.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/next-request.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/trace/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/client-component-renderer-logger.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/pipe-readable.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/invariant-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/render-result.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-kind.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/multi-file-writer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/incremental-cache/file-system-cache.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/to-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/incremental-cache/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/use-cache/handlers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/interop-default.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/router-utils/router-server-context.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/route-module.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-app-route-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-path-sep.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/path-match.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/get-cookie-parser.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/router-reducer/compute-changed-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/parse-and-validate-flight-router-state.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-relative-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/router-utils/decode-path-params.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/escape-path-delimiters.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/request-cookies.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/async-storage/draft-mode-provider.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/async-storage/request-store.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/revalidation-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/async-local-storage.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/after/after-context.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/is-thenable.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/lazy-result.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/http.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/implicit-tags.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/hooks-server-context.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/static-generation-bailout.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/dynamic-rendering-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/dynamic-rendering.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/patch-fetch.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/lru-cache.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/build/output/log.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/app-route/helpers/auto-implement-methods.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/http-access-fallback/http-access-fallback.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/redirect-status-code.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/redirect-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/prospective-render-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/create-error-handler.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/lazy-dynamic/bailout-to-csr.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/is-next-router-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/react-large-shell-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/app-router-context.shared-runtime.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/cache-signal.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/utils/reflect-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/create-deduped-by-callsite-server-error-logger.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/request/params.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/redirect.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/app-route/module.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/app-route/helpers/is-static-gen-enabled.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/dedupe-fetch.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/app-route/helpers/parsed-url-query-to-params.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/server-action-request-meta.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/async-storage/work-store.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/app-route/helpers/get-pathname-from-absolute-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/app-route/helpers/clean-url.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var __defProp = Object.defineProperty;</span><span class="s3">\n</span><span class="s1">var __getOwnPropDesc = Object.getOwnPropertyDescriptor;</span><span class="s3">\n</span><span class="s1">var __getOwnPropNames = Object.getOwnPropertyNames;</span><span class="s3">\n</span><span class="s1">var __hasOwnProp = Object.prototype.hasOwnProperty;</span><span class="s3">\n</span><span class="s1">var __export = (target, all) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (var name in all)</span><span class="s3">\n    </span><span class="s1">__defProp(target, name, { get: all[name], enumerable: true });</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var __copyProps = (to, from, except, desc) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (from &amp;&amp; typeof from === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| typeof from === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (let key of __getOwnPropNames(from))</span><span class="s3">\n      </span><span class="s1">if (!__hasOwnProp.call(to, key) &amp;&amp; key !== except)</span><span class="s3">\n        </span><span class="s1">__defProp(to, key, { get: () =&gt; from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return to;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var __toCommonJS = (mod) =&gt; __copyProps(__defProp({}, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true }), mod);</span><span class="s3">\n\n</span><span class="s1">// src/index.ts</span><span class="s3">\n</span><span class="s1">var src_exports = {};</span><span class="s3">\n</span><span class="s1">__export(src_exports, {</span><span class="s3">\n  </span><span class="s1">RequestCookies: () =&gt; RequestCookies,</span><span class="s3">\n  </span><span class="s1">ResponseCookies: () =&gt; ResponseCookies,</span><span class="s3">\n  </span><span class="s1">parseCookie: () =&gt; parseCookie,</span><span class="s3">\n  </span><span class="s1">parseSetCookie: () =&gt; parseSetCookie,</span><span class="s3">\n  </span><span class="s1">stringifyCookie: () =&gt; stringifyCookie</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">module.exports = __toCommonJS(src_exports);</span><span class="s3">\n\n</span><span class="s1">// src/serialize.ts</span><span class="s3">\n</span><span class="s1">function stringifyCookie(c) {</span><span class="s3">\n  </span><span class="s1">var _a;</span><span class="s3">\n  </span><span class="s1">const attrs = [</span><span class="s3">\n    \&quot;</span><span class="s1">path</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.path &amp;&amp; `Path=${c.path}`,</span><span class="s3">\n    \&quot;</span><span class="s1">expires</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; (c.expires || c.expires === 0) &amp;&amp; `Expires=${(typeof c.expires === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? new Date(c.expires) : c.expires).toUTCString()}`,</span><span class="s3">\n    \&quot;</span><span class="s1">maxAge</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; typeof c.maxAge === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; `Max-Age=${c.maxAge}`,</span><span class="s3">\n    \&quot;</span><span class="s1">domain</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.domain &amp;&amp; `Domain=${c.domain}`,</span><span class="s3">\n    \&quot;</span><span class="s1">secure</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.secure &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">Secure</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">httpOnly</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.httpOnly &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">HttpOnly</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">sameSite</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.sameSite &amp;&amp; `SameSite=${c.sameSite}`,</span><span class="s3">\n    \&quot;</span><span class="s1">partitioned</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.partitioned &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">Partitioned</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">priority</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.priority &amp;&amp; `Priority=${c.priority}`</span><span class="s3">\n  </span><span class="s1">].filter(Boolean);</span><span class="s3">\n  </span><span class="s1">const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : </span><span class="s3">\&quot;\&quot;</span><span class="s1">)}`;</span><span class="s3">\n  </span><span class="s1">return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseCookie(cookie) {</span><span class="s3">\n  </span><span class="s1">const map = /* @__PURE__ */ new Map();</span><span class="s3">\n  </span><span class="s1">for (const pair of cookie.split(/; */)) {</span><span class="s3">\n    </span><span class="s1">if (!pair)</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">const splitAt = pair.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (splitAt === -1) {</span><span class="s3">\n      </span><span class="s1">map.set(pair, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">map.set(key, decodeURIComponent(value != null ? value : </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return map;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseSetCookie(setCookie) {</span><span class="s3">\n  </span><span class="s1">if (!setCookie) {</span><span class="s3">\n    </span><span class="s1">return void 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const [[name, value], ...attributes] = parseCookie(setCookie);</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">domain,</span><span class="s3">\n    </span><span class="s1">expires,</span><span class="s3">\n    </span><span class="s1">httponly,</span><span class="s3">\n    </span><span class="s1">maxage,</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">samesite,</span><span class="s3">\n    </span><span class="s1">secure,</span><span class="s3">\n    </span><span class="s1">partitioned,</span><span class="s3">\n    </span><span class="s1">priority</span><span class="s3">\n  </span><span class="s1">} = Object.fromEntries(</span><span class="s3">\n    </span><span class="s1">attributes.map(([key, value2]) =&gt; [</span><span class="s3">\n      </span><span class="s1">key.toLowerCase().replace(/-/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">value2</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const cookie = {</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">value: decodeURIComponent(value),</span><span class="s3">\n    </span><span class="s1">domain,</span><span class="s3">\n    </span><span class="s1">...expires &amp;&amp; { expires: new Date(expires) },</span><span class="s3">\n    </span><span class="s1">...httponly &amp;&amp; { httpOnly: true },</span><span class="s3">\n    </span><span class="s1">...typeof maxage === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; { maxAge: Number(maxage) },</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">...samesite &amp;&amp; { sameSite: parseSameSite(samesite) },</span><span class="s3">\n    </span><span class="s1">...secure &amp;&amp; { secure: true },</span><span class="s3">\n    </span><span class="s1">...priority &amp;&amp; { priority: parsePriority(priority) },</span><span class="s3">\n    </span><span class="s1">...partitioned &amp;&amp; { partitioned: true }</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return compact(cookie);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function compact(t) {</span><span class="s3">\n  </span><span class="s1">const newT = {};</span><span class="s3">\n  </span><span class="s1">for (const key in t) {</span><span class="s3">\n    </span><span class="s1">if (t[key]) {</span><span class="s3">\n      </span><span class="s1">newT[key] = t[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newT;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var SAME_SITE = [</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">lax</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">function parseSameSite(string) {</span><span class="s3">\n  </span><span class="s1">string = string.toLowerCase();</span><span class="s3">\n  </span><span class="s1">return SAME_SITE.includes(string) ? string : void 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var PRIORITY = [</span><span class="s3">\&quot;</span><span class="s1">low</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">medium</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">high</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">function parsePriority(string) {</span><span class="s3">\n  </span><span class="s1">string = string.toLowerCase();</span><span class="s3">\n  </span><span class="s1">return PRIORITY.includes(string) ? string : void 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function splitCookiesString(cookiesString) {</span><span class="s3">\n  </span><span class="s1">if (!cookiesString)</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">var cookiesStrings = [];</span><span class="s3">\n  </span><span class="s1">var pos = 0;</span><span class="s3">\n  </span><span class="s1">var start;</span><span class="s3">\n  </span><span class="s1">var ch;</span><span class="s3">\n  </span><span class="s1">var lastComma;</span><span class="s3">\n  </span><span class="s1">var nextStart;</span><span class="s3">\n  </span><span class="s1">var cookiesSeparatorFound;</span><span class="s3">\n  </span><span class="s1">function skipWhitespace() {</span><span class="s3">\n    </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(cookiesString.charAt(pos))) {</span><span class="s3">\n      </span><span class="s1">pos += 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos &lt; cookiesString.length;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function notSpecialChar() {</span><span class="s3">\n    </span><span class="s1">ch = cookiesString.charAt(pos);</span><span class="s3">\n    </span><span class="s1">return ch !== </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ch !== </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ch !== </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (pos &lt; cookiesString.length) {</span><span class="s3">\n    </span><span class="s1">start = pos;</span><span class="s3">\n    </span><span class="s1">cookiesSeparatorFound = false;</span><span class="s3">\n    </span><span class="s1">while (skipWhitespace()) {</span><span class="s3">\n      </span><span class="s1">ch = cookiesString.charAt(pos);</span><span class="s3">\n      </span><span class="s1">if (ch === </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">lastComma = pos;</span><span class="s3">\n        </span><span class="s1">pos += 1;</span><span class="s3">\n        </span><span class="s1">skipWhitespace();</span><span class="s3">\n        </span><span class="s1">nextStart = pos;</span><span class="s3">\n        </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; notSpecialChar()) {</span><span class="s3">\n          </span><span class="s1">pos += 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (pos &lt; cookiesString.length &amp;&amp; cookiesString.charAt(pos) === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">cookiesSeparatorFound = true;</span><span class="s3">\n          </span><span class="s1">pos = nextStart;</span><span class="s3">\n          </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, lastComma));</span><span class="s3">\n          </span><span class="s1">start = pos;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">pos = lastComma + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pos += 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!cookiesSeparatorFound || pos &gt;= cookiesString.length) {</span><span class="s3">\n      </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, cookiesString.length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cookiesStrings;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// src/request-cookies.ts</span><span class="s3">\n</span><span class="s1">var RequestCookies = class {</span><span class="s3">\n  </span><span class="s1">constructor(requestHeaders) {</span><span class="s3">\n    </span><span class="s1">/** @internal */</span><span class="s3">\n    </span><span class="s1">this._parsed = /* @__PURE__ */ new Map();</span><span class="s3">\n    </span><span class="s1">this._headers = requestHeaders;</span><span class="s3">\n    </span><span class="s1">const header = requestHeaders.get(</span><span class="s3">\&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (header) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseCookie(header);</span><span class="s3">\n      </span><span class="s1">for (const [name, value] of parsed) {</span><span class="s3">\n        </span><span class="s1">this._parsed.set(name, { name, value });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[Symbol.iterator]() {</span><span class="s3">\n    </span><span class="s1">return this._parsed[Symbol.iterator]();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The amount of cookies received from the client</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get size() {</span><span class="s3">\n    </span><span class="s1">return this._parsed.size;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">get(...args) {</span><span class="s3">\n    </span><span class="s1">const name = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : args[0].name;</span><span class="s3">\n    </span><span class="s1">return this._parsed.get(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">getAll(...args) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const all = Array.from(this._parsed);</span><span class="s3">\n    </span><span class="s1">if (!args.length) {</span><span class="s3">\n      </span><span class="s1">return all.map(([_, value]) =&gt; value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const name = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : (_a = args[0]) == null ? void 0 : _a.name;</span><span class="s3">\n    </span><span class="s1">return all.filter(([n]) =&gt; n === name).map(([_, value]) =&gt; value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">has(name) {</span><span class="s3">\n    </span><span class="s1">return this._parsed.has(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">set(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">map.set(name, { name, value });</span><span class="s3">\n    </span><span class="s1">this._headers.set(</span><span class="s3">\n      \&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">Array.from(map).map(([_, value2]) =&gt; stringifyCookie(value2)).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Delete the cookies matching the passed name or names in the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete(names) {</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">const result = !Array.isArray(names) ? map.delete(names) : names.map((name) =&gt; map.delete(name));</span><span class="s3">\n    </span><span class="s1">this._headers.set(</span><span class="s3">\n      \&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">Array.from(map).map(([_, value]) =&gt; stringifyCookie(value)).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Delete all the cookies in the cookies in the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clear() {</span><span class="s3">\n    </span><span class="s1">this.delete(Array.from(this._parsed.keys()));</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Format the cookies in the request as a string for logging</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">edge-runtime.inspect.custom</span><span class="s3">\&quot;</span><span class="s1">)]() {</span><span class="s3">\n    </span><span class="s1">return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return [...this._parsed.values()].map((v) =&gt; `${v.name}=${encodeURIComponent(v.value)}`).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/response-cookies.ts</span><span class="s3">\n</span><span class="s1">var ResponseCookies = class {</span><span class="s3">\n  </span><span class="s1">constructor(responseHeaders) {</span><span class="s3">\n    </span><span class="s1">/** @internal */</span><span class="s3">\n    </span><span class="s1">this._parsed = /* @__PURE__ */ new Map();</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n    </span><span class="s1">this._headers = responseHeaders;</span><span class="s3">\n    </span><span class="s1">const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">)) != null ? _c : [];</span><span class="s3">\n    </span><span class="s1">const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);</span><span class="s3">\n    </span><span class="s1">for (const cookieString of cookieStrings) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseSetCookie(cookieString);</span><span class="s3">\n      </span><span class="s1">if (parsed)</span><span class="s3">\n        </span><span class="s1">this._parsed.set(parsed.name, parsed);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get(...args) {</span><span class="s3">\n    </span><span class="s1">const key = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : args[0].name;</span><span class="s3">\n    </span><span class="s1">return this._parsed.get(key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getAll(...args) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const all = Array.from(this._parsed.values());</span><span class="s3">\n    </span><span class="s1">if (!args.length) {</span><span class="s3">\n      </span><span class="s1">return all;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const key = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : (_a = args[0]) == null ? void 0 : _a.name;</span><span class="s3">\n    </span><span class="s1">return all.filter((c) =&gt; c.name === key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">has(name) {</span><span class="s3">\n    </span><span class="s1">return this._parsed.has(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">set(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">map.set(name, normalizeCookie({ name, value, ...cookie }));</span><span class="s3">\n    </span><span class="s1">replace(map, this._headers);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, options] = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? [args[0]] : [args[0].name, args[0]];</span><span class="s3">\n    </span><span class="s1">return this.set({ ...options, name, value: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, expires: /* @__PURE__ */ new Date(0) });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">edge-runtime.inspect.custom</span><span class="s3">\&quot;</span><span class="s1">)]() {</span><span class="s3">\n    </span><span class="s1">return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return [...this._parsed.values()].map(stringifyCookie).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function replace(bag, headers) {</span><span class="s3">\n  </span><span class="s1">headers.delete(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">for (const [, value] of bag) {</span><span class="s3">\n    </span><span class="s1">const serialized = stringifyCookie(value);</span><span class="s3">\n    </span><span class="s1">headers.append(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">, serialized);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function normalizeCookie(cookie = { name: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, value: </span><span class="s3">\&quot;\&quot; </span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">if (typeof cookie.expires === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">cookie.expires = new Date(cookie.expires);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (cookie.maxAge) {</span><span class="s3">\n    </span><span class="s1">cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (cookie.path === null || cookie.path === void 0) {</span><span class="s3">\n    </span><span class="s1">cookie.path = </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cookie;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Annotate the CommonJS export names for ESM import in node:</span><span class="s3">\n</span><span class="s1">0 &amp;&amp; (module.exports = {</span><span class="s3">\n  </span><span class="s1">RequestCookies,</span><span class="s3">\n  </span><span class="s1">ResponseCookies,</span><span class="s3">\n  </span><span class="s1">parseCookie,</span><span class="s3">\n  </span><span class="s1">parseSetCookie,</span><span class="s3">\n  </span><span class="s1">stringifyCookie</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var e={};(()=&gt;{var r=e;</span><span class="s3">\n</span><span class="s1">/*!</span><span class="s3">\n </span><span class="s1">* cookie</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2012-2014 Roman Shtylman</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2015 Douglas Christopher Wilson</span><span class="s3">\n </span><span class="s1">* MIT Licensed</span><span class="s3">\n </span><span class="s1">*/r.parse=parse;r.serialize=serialize;var i=decodeURIComponent;var t=encodeURIComponent;var a=/; */;var n=/^[</span><span class="s3">\\</span><span class="s1">u0009</span><span class="s3">\\</span><span class="s1">u0020-</span><span class="s3">\\</span><span class="s1">u007e</span><span class="s3">\\</span><span class="s1">u0080-</span><span class="s3">\\</span><span class="s1">u00ff]+$/;function parse(e,r){if(typeof e!==</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument str must be a string</span><span class="s3">\&quot;</span><span class="s1">)}var t={};var n=r||{};var o=e.split(a);var s=n.decode||i;for(var p=0;p&lt;o.length;p++){var f=o[p];var u=f.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);if(u&lt;0){continue}var v=f.substr(0,u).trim();var c=f.substr(++u,f.length).trim();if('</span><span class="s3">\&quot;</span><span class="s1">'==c[0]){c=c.slice(1,-1)}if(undefined==t[v]){t[v]=tryDecode(c,s)}}return t}function serialize(e,r,i){var a=i||{};var o=a.encode||t;if(typeof o!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option encode is invalid</span><span class="s3">\&quot;</span><span class="s1">)}if(!n.test(e)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument name is invalid</span><span class="s3">\&quot;</span><span class="s1">)}var s=o(r);if(s&amp;&amp;!n.test(s)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument val is invalid</span><span class="s3">\&quot;</span><span class="s1">)}var p=e+</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">+s;if(null!=a.maxAge){var f=a.maxAge-0;if(isNaN(f)||!isFinite(f)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option maxAge is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Max-Age=</span><span class="s3">\&quot;</span><span class="s1">+Math.floor(f)}if(a.domain){if(!n.test(a.domain)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option domain is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Domain=</span><span class="s3">\&quot;</span><span class="s1">+a.domain}if(a.path){if(!n.test(a.path)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option path is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Path=</span><span class="s3">\&quot;</span><span class="s1">+a.path}if(a.expires){if(typeof a.expires.toUTCString!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option expires is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Expires=</span><span class="s3">\&quot;</span><span class="s1">+a.expires.toUTCString()}if(a.httpOnly){p+=</span><span class="s3">\&quot;</span><span class="s1">; HttpOnly</span><span class="s3">\&quot;</span><span class="s1">}if(a.secure){p+=</span><span class="s3">\&quot;</span><span class="s1">; Secure</span><span class="s3">\&quot;</span><span class="s1">}if(a.sameSite){var u=typeof a.sameSite===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?a.sameSite.toLowerCase():a.sameSite;switch(u){case true:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">lax</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Lax</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=None</span><span class="s3">\&quot;</span><span class="s1">;break;default:throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option sameSite is invalid</span><span class="s3">\&quot;</span><span class="s1">)}}return p}function tryDecode(e,r){try{return r(e)}catch(r){return e}}})();module.exports=e})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;var e={993:e=&gt;{var t=Object.prototype.hasOwnProperty,n=</span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">;function Events(){}if(Object.create){Events.prototype=Object.create(null);if(!(new Events).__proto__)n=false}function EE(e,t,n){this.fn=e;this.context=t;this.once=n||false}function addListener(e,t,r,i,s){if(typeof r!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">The listener must be a function</span><span class="s3">\&quot;</span><span class="s1">)}var o=new EE(r,i||e,s),u=n?n+t:t;if(!e._events[u])e._events[u]=o,e._eventsCount++;else if(!e._events[u].fn)e._events[u].push(o);else e._events[u]=[e._events[u],o];return e}function clearEvent(e,t){if(--e._eventsCount===0)e._events=new Events;else delete e._events[t]}function EventEmitter(){this._events=new Events;this._eventsCount=0}EventEmitter.prototype.eventNames=function eventNames(){var e=[],r,i;if(this._eventsCount===0)return e;for(i in r=this._events){if(t.call(r,i))e.push(n?i.slice(1):i)}if(Object.getOwnPropertySymbols){return e.concat(Object.getOwnPropertySymbols(r))}return e};EventEmitter.prototype.listeners=function listeners(e){var t=n?n+e:e,r=this._events[t];if(!r)return[];if(r.fn)return[r.fn];for(var i=0,s=r.length,o=new Array(s);i&lt;s;i++){o[i]=r[i].fn}return o};EventEmitter.prototype.listenerCount=function listenerCount(e){var t=n?n+e:e,r=this._events[t];if(!r)return 0;if(r.fn)return 1;return r.length};EventEmitter.prototype.emit=function emit(e,t,r,i,s,o){var u=n?n+e:e;if(!this._events[u])return false;var a=this._events[u],l=arguments.length,c,h;if(a.fn){if(a.once)this.removeListener(e,a.fn,undefined,true);switch(l){case 1:return a.fn.call(a.context),true;case 2:return a.fn.call(a.context,t),true;case 3:return a.fn.call(a.context,t,r),true;case 4:return a.fn.call(a.context,t,r,i),true;case 5:return a.fn.call(a.context,t,r,i,s),true;case 6:return a.fn.call(a.context,t,r,i,s,o),true}for(h=1,c=new Array(l-1);h&lt;l;h++){c[h-1]=arguments[h]}a.fn.apply(a.context,c)}else{var _=a.length,f;for(h=0;h&lt;_;h++){if(a[h].once)this.removeListener(e,a[h].fn,undefined,true);switch(l){case 1:a[h].fn.call(a[h].context);break;case 2:a[h].fn.call(a[h].context,t);break;case 3:a[h].fn.call(a[h].context,t,r);break;case 4:a[h].fn.call(a[h].context,t,r,i);break;default:if(!c)for(f=1,c=new Array(l-1);f&lt;l;f++){c[f-1]=arguments[f]}a[h].fn.apply(a[h].context,c)}}}return true};EventEmitter.prototype.on=function on(e,t,n){return addListener(this,e,t,n,false)};EventEmitter.prototype.once=function once(e,t,n){return addListener(this,e,t,n,true)};EventEmitter.prototype.removeListener=function removeListener(e,t,r,i){var s=n?n+e:e;if(!this._events[s])return this;if(!t){clearEvent(this,s);return this}var o=this._events[s];if(o.fn){if(o.fn===t&amp;&amp;(!i||o.once)&amp;&amp;(!r||o.context===r)){clearEvent(this,s)}}else{for(var u=0,a=[],l=o.length;u&lt;l;u++){if(o[u].fn!==t||i&amp;&amp;!o[u].once||r&amp;&amp;o[u].context!==r){a.push(o[u])}}if(a.length)this._events[s]=a.length===1?a[0]:a;else clearEvent(this,s)}return this};EventEmitter.prototype.removeAllListeners=function removeAllListeners(e){var t;if(e){t=n?n+e:e;if(this._events[t])clearEvent(this,t)}else{this._events=new Events;this._eventsCount=0}return this};EventEmitter.prototype.off=EventEmitter.prototype.removeListener;EventEmitter.prototype.addListener=EventEmitter.prototype.on;EventEmitter.prefixed=n;EventEmitter.EventEmitter=EventEmitter;if(true){e.exports=EventEmitter}},213:e=&gt;{e.exports=(e,t)=&gt;{t=t||(()=&gt;{});return e.then((e=&gt;new Promise((e=&gt;{e(t())})).then((()=&gt;e))),(e=&gt;new Promise((e=&gt;{e(t())})).then((()=&gt;{throw e}))))}},574:(e,t)=&gt;{Object.defineProperty(t,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});function lowerBound(e,t,n){let r=0;let i=e.length;while(i&gt;0){const s=i/2|0;let o=r+s;if(n(e[o],t)&lt;=0){r=++o;i-=s+1}else{i=s}}return r}t[</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">]=lowerBound},821:(e,t,n)=&gt;{Object.defineProperty(t,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});const r=n(574);class PriorityQueue{constructor(){this._queue=[]}enqueue(e,t){t=Object.assign({priority:0},t);const n={priority:t.priority,run:e};if(this.size&amp;&amp;this._queue[this.size-1].priority&gt;=t.priority){this._queue.push(n);return}const i=r.default(this._queue,n,((e,t)=&gt;t.priority-e.priority));this._queue.splice(i,0,n)}dequeue(){const e=this._queue.shift();return e===null||e===void 0?void 0:e.run}filter(e){return this._queue.filter((t=&gt;t.priority===e.priority)).map((e=&gt;e.run))}get size(){return this._queue.length}}t[</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">]=PriorityQueue},816:(e,t,n)=&gt;{const r=n(213);class TimeoutError extends Error{constructor(e){super(e);this.name=</span><span class="s3">\&quot;</span><span class="s1">TimeoutError</span><span class="s3">\&quot;</span><span class="s1">}}const pTimeout=(e,t,n)=&gt;new Promise(((i,s)=&gt;{if(typeof t!==</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||t&lt;0){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Expected `milliseconds` to be a positive number</span><span class="s3">\&quot;</span><span class="s1">)}if(t===Infinity){i(e);return}const o=setTimeout((()=&gt;{if(typeof n===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){try{i(n())}catch(e){s(e)}return}const r=typeof n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?n:`Promise timed out after ${t} milliseconds`;const o=n instanceof Error?n:new TimeoutError(r);if(typeof e.cancel===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){e.cancel()}s(o)}),t);r(e.then(i,s),(()=&gt;{clearTimeout(o)}))}));e.exports=pTimeout;e.exports[</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">]=pTimeout;e.exports.TimeoutError=TimeoutError}};var t={};function __nccwpck_require__(n){var r=t[n];if(r!==undefined){return r.exports}var i=t[n]={exports:{}};var s=true;try{e[n](i,i.exports,__nccwpck_require__);s=false}finally{if(s)delete t[n]}return i.exports}if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var n={};(()=&gt;{var e=n;Object.defineProperty(e,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});const t=__nccwpck_require__(993);const r=__nccwpck_require__(816);const i=__nccwpck_require__(821);const empty=()=&gt;{};const s=new r.TimeoutError;class PQueue extends t{constructor(e){var t,n,r,s;super();this._intervalCount=0;this._intervalEnd=0;this._pendingCount=0;this._resolveEmpty=empty;this._resolveIdle=empty;e=Object.assign({carryoverConcurrencyCount:false,intervalCap:Infinity,interval:0,concurrency:Infinity,autoStart:true,queueClass:i.default},e);if(!(typeof e.intervalCap===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;e.intervalCap&gt;=1)){throw new TypeError(`Expected </span><span class="s3">\\</span><span class="s1">`intervalCap</span><span class="s3">\\</span><span class="s1">` to be a number from 1 and up, got </span><span class="s3">\\</span><span class="s1">`${(n=(t=e.intervalCap)===null||t===void 0?void 0:t.toString())!==null&amp;&amp;n!==void 0?n:</span><span class="s3">\&quot;\&quot;</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">` (${typeof e.intervalCap})`)}if(e.interval===undefined||!(Number.isFinite(e.interval)&amp;&amp;e.interval&gt;=0)){throw new TypeError(`Expected </span><span class="s3">\\</span><span class="s1">`interval</span><span class="s3">\\</span><span class="s1">` to be a finite number &gt;= 0, got </span><span class="s3">\\</span><span class="s1">`${(s=(r=e.interval)===null||r===void 0?void 0:r.toString())!==null&amp;&amp;s!==void 0?s:</span><span class="s3">\&quot;\&quot;</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">` (${typeof e.interval})`)}this._carryoverConcurrencyCount=e.carryoverConcurrencyCount;this._isIntervalIgnored=e.intervalCap===Infinity||e.interval===0;this._intervalCap=e.intervalCap;this._interval=e.interval;this._queue=new e.queueClass;this._queueClass=e.queueClass;this.concurrency=e.concurrency;this._timeout=e.timeout;this._throwOnTimeout=e.throwOnTimeout===true;this._isPaused=e.autoStart===false}get _doesIntervalAllowAnother(){return this._isIntervalIgnored||this._intervalCount&lt;this._intervalCap}get _doesConcurrentAllowAnother(){return this._pendingCount&lt;this._concurrency}_next(){this._pendingCount--;this._tryToStartAnother();this.emit(</span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">)}_resolvePromises(){this._resolveEmpty();this._resolveEmpty=empty;if(this._pendingCount===0){this._resolveIdle();this._resolveIdle=empty;this.emit(</span><span class="s3">\&quot;</span><span class="s1">idle</span><span class="s3">\&quot;</span><span class="s1">)}}_onResumeInterval(){this._onInterval();this._initializeIntervalIfNeeded();this._timeoutId=undefined}_isIntervalPaused(){const e=Date.now();if(this._intervalId===undefined){const t=this._intervalEnd-e;if(t&lt;0){this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0}else{if(this._timeoutId===undefined){this._timeoutId=setTimeout((()=&gt;{this._onResumeInterval()}),t)}return true}}return false}_tryToStartAnother(){if(this._queue.size===0){if(this._intervalId){clearInterval(this._intervalId)}this._intervalId=undefined;this._resolvePromises();return false}if(!this._isPaused){const e=!this._isIntervalPaused();if(this._doesIntervalAllowAnother&amp;&amp;this._doesConcurrentAllowAnother){const t=this._queue.dequeue();if(!t){return false}this.emit(</span><span class="s3">\&quot;</span><span class="s1">active</span><span class="s3">\&quot;</span><span class="s1">);t();if(e){this._initializeIntervalIfNeeded()}return true}}return false}_initializeIntervalIfNeeded(){if(this._isIntervalIgnored||this._intervalId!==undefined){return}this._intervalId=setInterval((()=&gt;{this._onInterval()}),this._interval);this._intervalEnd=Date.now()+this._interval}_onInterval(){if(this._intervalCount===0&amp;&amp;this._pendingCount===0&amp;&amp;this._intervalId){clearInterval(this._intervalId);this._intervalId=undefined}this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0;this._processQueue()}_processQueue(){while(this._tryToStartAnother()){}}get concurrency(){return this._concurrency}set concurrency(e){if(!(typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;e&gt;=1)){throw new TypeError(`Expected </span><span class="s3">\\</span><span class="s1">`concurrency</span><span class="s3">\\</span><span class="s1">` to be a number from 1 and up, got </span><span class="s3">\\</span><span class="s1">`${e}</span><span class="s3">\\</span><span class="s1">` (${typeof e})`)}this._concurrency=e;this._processQueue()}async add(e,t={}){return new Promise(((n,i)=&gt;{const run=async()=&gt;{this._pendingCount++;this._intervalCount++;try{const o=this._timeout===undefined&amp;&amp;t.timeout===undefined?e():r.default(Promise.resolve(e()),t.timeout===undefined?this._timeout:t.timeout,(()=&gt;{if(t.throwOnTimeout===undefined?this._throwOnTimeout:t.throwOnTimeout){i(s)}return undefined}));n(await o)}catch(e){i(e)}this._next()};this._queue.enqueue(run,t);this._tryToStartAnother();this.emit(</span><span class="s3">\&quot;</span><span class="s1">add</span><span class="s3">\&quot;</span><span class="s1">)}))}async addAll(e,t){return Promise.all(e.map((async e=&gt;this.add(e,t))))}start(){if(!this._isPaused){return this}this._isPaused=false;this._processQueue();return this}pause(){this._isPaused=true}clear(){this._queue=new this._queueClass}async onEmpty(){if(this._queue.size===0){return}return new Promise((e=&gt;{const t=this._resolveEmpty;this._resolveEmpty=()=&gt;{t();e()}}))}async onIdle(){if(this._pendingCount===0&amp;&amp;this._queue.size===0){return}return new Promise((e=&gt;{const t=this._resolveIdle;this._resolveIdle=()=&gt;{t();e()}}))}get size(){return this._queue.size}sizeBy(e){return this._queue.filter(e).length}get pending(){return this._pendingCount}get isPaused(){return this._isPaused}get timeout(){return this._timeout}set timeout(e){this._timeout=e}}e[</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">]=PQueue})();module.exports=n})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var e={};(()=&gt;{var n=e;Object.defineProperty(n,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});n.pathToRegexp=n.tokensToRegexp=n.regexpToFunction=n.match=n.tokensToFunction=n.compile=n.parse=void 0;function lexer(e){var n=[];var r=0;while(r&lt;e.length){var t=e[r];if(t===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||t===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||t===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">,index:r++,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">OPEN</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">CLOSE</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">){var a=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var i=r+1;while(i&lt;e.length){var o=e.charCodeAt(i);if(o&gt;=48&amp;&amp;o&lt;=57||o&gt;=65&amp;&amp;o&lt;=90||o&gt;=97&amp;&amp;o&lt;=122||o===95){a+=e[i++];continue}break}if(!a)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Missing parameter name at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));n.push({type:</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:a});r=i;continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">){var c=1;var f=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var i=r+1;if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError('Pattern cannot start with </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">at '.concat(i))}while(i&lt;e.length){if(e[i]===</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">){f+=e[i++]+e[i++];continue}if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">){c--;if(c===0){i++;break}}else if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">){c++;if(e[i+1]!==</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Capturing groups are not allowed at </span><span class="s3">\&quot;</span><span class="s1">.concat(i))}}f+=e[i++]}if(c)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Unbalanced pattern at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));if(!f)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Missing pattern at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));n.push({type:</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:f});r=i;continue}n.push({type:</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]})}n.push({type:</span><span class="s3">\&quot;</span><span class="s1">END</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:</span><span class="s3">\&quot;\&quot;</span><span class="s1">});return n}function parse(e,n){if(n===void 0){n={}}var r=lexer(e);var t=n.prefixes,a=t===void 0?</span><span class="s3">\&quot;</span><span class="s1">./</span><span class="s3">\&quot;</span><span class="s1">:t,i=n.delimiter,o=i===void 0?</span><span class="s3">\&quot;</span><span class="s1">/#?</span><span class="s3">\&quot;</span><span class="s1">:i;var c=[];var f=0;var u=0;var p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var tryConsume=function(e){if(u&lt;r.length&amp;&amp;r[u].type===e)return r[u++].value};var mustConsume=function(e){var n=tryConsume(e);if(n!==undefined)return n;var t=r[u],a=t.type,i=t.index;throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Unexpected </span><span class="s3">\&quot;</span><span class="s1">.concat(a,</span><span class="s3">\&quot; </span><span class="s1">at </span><span class="s3">\&quot;</span><span class="s1">).concat(i,</span><span class="s3">\&quot;</span><span class="s1">, expected </span><span class="s3">\&quot;</span><span class="s1">).concat(e))};var consumeText=function(){var e=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var n;while(n=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">)||tryConsume(</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">)){e+=n}return e};var isSafe=function(e){for(var n=0,r=o;n&lt;r.length;n++){var t=r[n];if(e.indexOf(t)&gt;-1)return true}return false};var safePattern=function(e){var n=c[c.length-1];var r=e||(n&amp;&amp;typeof n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?n:</span><span class="s3">\&quot;\&quot;</span><span class="s1">);if(n&amp;&amp;!r){throw new TypeError('Must have text between two parameters, missing text after </span><span class="s3">\&quot;</span><span class="s1">'.concat(n.name,'</span><span class="s3">\&quot;</span><span class="s1">'))}if(!r||isSafe(r))return</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(o),</span><span class="s3">\&quot;</span><span class="s1">]+?</span><span class="s3">\&quot;</span><span class="s1">);return</span><span class="s3">\&quot;</span><span class="s1">(?:(?!</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(r),</span><span class="s3">\&quot;</span><span class="s1">)[^</span><span class="s3">\&quot;</span><span class="s1">).concat(escapeString(o),</span><span class="s3">\&quot;</span><span class="s1">])+?</span><span class="s3">\&quot;</span><span class="s1">)};while(u&lt;r.length){var v=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">);var s=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">);var d=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">);if(s||d){var g=v||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;if(a.indexOf(g)===-1){p+=g;g=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}if(p){c.push(p);p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}c.push({name:s||f++,prefix:g,suffix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,pattern:d||safePattern(g),modifier:tryConsume(</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">});continue}var x=v||tryConsume(</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">);if(x){p+=x;continue}if(p){c.push(p);p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}var h=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">OPEN</span><span class="s3">\&quot;</span><span class="s1">);if(h){var g=consumeText();var l=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var m=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var T=consumeText();mustConsume(</span><span class="s3">\&quot;</span><span class="s1">CLOSE</span><span class="s3">\&quot;</span><span class="s1">);c.push({name:l||(m?f++:</span><span class="s3">\&quot;\&quot;</span><span class="s1">),pattern:l&amp;&amp;!m?safePattern(g):m,prefix:g,suffix:T,modifier:tryConsume(</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">});continue}mustConsume(</span><span class="s3">\&quot;</span><span class="s1">END</span><span class="s3">\&quot;</span><span class="s1">)}return c}n.parse=parse;function compile(e,n){return tokensToFunction(parse(e,n),n)}n.compile=compile;function tokensToFunction(e,n){if(n===void 0){n={}}var r=flags(n);var t=n.encode,a=t===void 0?function(e){return e}:t,i=n.validate,o=i===void 0?true:i;var c=e.map((function(e){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">){return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(e.pattern,</span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">),r)}}));return function(n){var r=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(var t=0;t&lt;e.length;t++){var i=e[t];if(typeof i===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){r+=i;continue}var f=n?n[i.name]:undefined;var u=i.modifier===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">||i.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">;var p=i.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||i.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">;if(Array.isArray(f)){if(!p){throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to not repeat, but got an array'))}if(f.length===0){if(u)continue;throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to not be empty'))}for(var v=0;v&lt;f.length;v++){var s=a(f[v],i);if(o&amp;&amp;!c[t].test(s)){throw new TypeError('Expected all </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to match </span><span class="s3">\&quot;</span><span class="s1">').concat(i.pattern,'</span><span class="s3">\&quot;</span><span class="s1">, but got </span><span class="s3">\&quot;</span><span class="s1">').concat(s,'</span><span class="s3">\&quot;</span><span class="s1">'))}r+=i.prefix+s+i.suffix}continue}if(typeof f===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||typeof f===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">){var s=a(String(f),i);if(o&amp;&amp;!c[t].test(s)){throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to match </span><span class="s3">\&quot;</span><span class="s1">').concat(i.pattern,'</span><span class="s3">\&quot;</span><span class="s1">, but got </span><span class="s3">\&quot;</span><span class="s1">').concat(s,'</span><span class="s3">\&quot;</span><span class="s1">'))}r+=i.prefix+s+i.suffix;continue}if(u)continue;var d=p?</span><span class="s3">\&quot;</span><span class="s1">an array</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">a string</span><span class="s3">\&quot;</span><span class="s1">;throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to be ').concat(d))}return r}}n.tokensToFunction=tokensToFunction;function match(e,n){var r=[];var t=pathToRegexp(e,r,n);return regexpToFunction(t,r,n)}n.match=match;function regexpToFunction(e,n,r){if(r===void 0){r={}}var t=r.decode,a=t===void 0?function(e){return e}:t;return function(r){var t=e.exec(r);if(!t)return false;var i=t[0],o=t.index;var c=Object.create(null);var _loop_1=function(e){if(t[e]===undefined)return</span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">;var r=n[e-1];if(r.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||r.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">){c[r.name]=t[e].split(r.prefix+r.suffix).map((function(e){return a(e,r)}))}else{c[r.name]=a(t[e],r)}};for(var f=1;f&lt;t.length;f++){_loop_1(f)}return{path:i,index:o,params:c}}}n.regexpToFunction=regexpToFunction;function escapeString(e){return e.replace(/([.+*?=^!:${}()[</span><span class="s3">\\</span><span class="s1">]|/</span><span class="s3">\\\\</span><span class="s1">])/g,</span><span class="s3">\&quot;\\\\</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)}function flags(e){return e&amp;&amp;e.sensitive?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">}function regexpToRegexp(e,n){if(!n)return e;var r=/</span><span class="s3">\\</span><span class="s1">((?:</span><span class="s3">\\</span><span class="s1">?&lt;(.*?)&gt;)?(?!</span><span class="s3">\\</span><span class="s1">?)/g;var t=0;var a=r.exec(e.source);while(a){n.push({name:a[1]||t++,prefix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,suffix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,modifier:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,pattern:</span><span class="s3">\&quot;\&quot;</span><span class="s1">});a=r.exec(e.source)}return e}function arrayToRegexp(e,n,r){var t=e.map((function(e){return pathToRegexp(e,n,r).source}));return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(t.join(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">),flags(r))}function stringToRegexp(e,n,r){return tokensToRegexp(parse(e,r),n,r)}function tokensToRegexp(e,n,r){if(r===void 0){r={}}var t=r.strict,a=t===void 0?false:t,i=r.start,o=i===void 0?true:i,c=r.end,f=c===void 0?true:c,u=r.encode,p=u===void 0?function(e){return e}:u,v=r.delimiter,s=v===void 0?</span><span class="s3">\&quot;</span><span class="s1">/#?</span><span class="s3">\&quot;</span><span class="s1">:v,d=r.endsWith,g=d===void 0?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:d;var x=</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(g),</span><span class="s3">\&quot;</span><span class="s1">]|$</span><span class="s3">\&quot;</span><span class="s1">);var h=</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(s),</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);var l=o?</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(var m=0,T=e;m&lt;T.length;m++){var E=T[m];if(typeof E===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){l+=escapeString(p(E))}else{var w=escapeString(p(E.prefix));var y=escapeString(p(E.suffix));if(E.pattern){if(n)n.push(E);if(w||y){if(E.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){var R=E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;\&quot;</span><span class="s1">;l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w,</span><span class="s3">\&quot;</span><span class="s1">((?:</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)(?:</span><span class="s3">\&quot;</span><span class="s1">).concat(y).concat(w,</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">))*)</span><span class="s3">\&quot;</span><span class="s1">).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(R)}else{l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w,</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}else{if(E.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError('Can not repeat </span><span class="s3">\&quot;</span><span class="s1">'.concat(E.name,'</span><span class="s3">\&quot; </span><span class="s1">without a prefix and suffix'))}l+=</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">.concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}else{l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}}if(f){if(!a)l+=</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);l+=!r.endsWith?</span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">.concat(x,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)}else{var A=e[e.length-1];var _=typeof A===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?h.indexOf(A[A.length-1])&gt;-1:A===undefined;if(!a){l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">).concat(x,</span><span class="s3">\&quot;</span><span class="s1">))?</span><span class="s3">\&quot;</span><span class="s1">)}if(!_){l+=</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">).concat(x,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)}}return new RegExp(l,flags(r))}n.tokensToRegexp=tokensToRegexp;function pathToRegexp(e,n,r){if(e instanceof RegExp)return regexpToRegexp(e,n);if(Array.isArray(e))return arrayToRegexp(e,n,r);return stringToRegexp(e,n,r)}n.pathToRegexp=pathToRegexp})();module.exports=e})();&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* @license React</span><span class="s3">\n </span><span class="s1">* react.production.js</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Copyright (c) Meta Platforms, Inc. and affiliates.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This source code is licensed under the MIT license found in the</span><span class="s3">\n </span><span class="s1">* LICENSE file in the root directory of this source tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var REACT_ELEMENT_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.transitional.element</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_PORTAL_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.portal</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_FRAGMENT_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.fragment</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_STRICT_MODE_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.strict_mode</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_PROFILER_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.profiler</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_CONSUMER_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.consumer</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_CONTEXT_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.context</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_FORWARD_REF_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.forward_ref</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_SUSPENSE_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.suspense</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.suspense_list</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_MEMO_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.memo</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_LAZY_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.lazy</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_ACTIVITY_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.activity</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_POSTPONE_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.postpone</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_VIEW_TRANSITION_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.view_transition</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span><span class="s3">\n</span><span class="s1">function getIteratorFn(maybeIterable) {</span><span class="s3">\n  </span><span class="s1">if (null === maybeIterable || </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">!== typeof maybeIterable) return null;</span><span class="s3">\n  </span><span class="s1">maybeIterable =</span><span class="s3">\n    </span><span class="s1">(MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span><span class="s3">\n    </span><span class="s1">maybeIterable[</span><span class="s3">\&quot;</span><span class="s1">@@iterator</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof maybeIterable ? maybeIterable : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var ReactNoopUpdateQueue = {</span><span class="s3">\n    </span><span class="s1">isMounted: function () {</span><span class="s3">\n      </span><span class="s1">return !1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">enqueueForceUpdate: function () {},</span><span class="s3">\n    </span><span class="s1">enqueueReplaceState: function () {},</span><span class="s3">\n    </span><span class="s1">enqueueSetState: function () {}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">assign = Object.assign,</span><span class="s3">\n  </span><span class="s1">emptyObject = {};</span><span class="s3">\n</span><span class="s1">function Component(props, context, updater) {</span><span class="s3">\n  </span><span class="s1">this.props = props;</span><span class="s3">\n  </span><span class="s1">this.context = context;</span><span class="s3">\n  </span><span class="s1">this.refs = emptyObject;</span><span class="s3">\n  </span><span class="s1">this.updater = updater || ReactNoopUpdateQueue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Component.prototype.isReactComponent = {};</span><span class="s3">\n</span><span class="s1">Component.prototype.setState = function (partialState, callback) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">!== typeof partialState &amp;&amp;</span><span class="s3">\n    \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">!== typeof partialState &amp;&amp;</span><span class="s3">\n    </span><span class="s1">null != partialState</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">throw Error(</span><span class="s3">\n      \&quot;</span><span class="s1">takes an object of state variables to update or a function which returns an object of state variables.</span><span class="s3">\&quot;\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.updater.enqueueSetState(this, partialState, callback, </span><span class="s3">\&quot;</span><span class="s1">setState</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">Component.prototype.forceUpdate = function (callback) {</span><span class="s3">\n  </span><span class="s1">this.updater.enqueueForceUpdate(this, callback, </span><span class="s3">\&quot;</span><span class="s1">forceUpdate</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function ComponentDummy() {}</span><span class="s3">\n</span><span class="s1">ComponentDummy.prototype = Component.prototype;</span><span class="s3">\n</span><span class="s1">function PureComponent(props, context, updater) {</span><span class="s3">\n  </span><span class="s1">this.props = props;</span><span class="s3">\n  </span><span class="s1">this.context = context;</span><span class="s3">\n  </span><span class="s1">this.refs = emptyObject;</span><span class="s3">\n  </span><span class="s1">this.updater = updater || ReactNoopUpdateQueue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());</span><span class="s3">\n</span><span class="s1">pureComponentPrototype.constructor = PureComponent;</span><span class="s3">\n</span><span class="s1">assign(pureComponentPrototype, Component.prototype);</span><span class="s3">\n</span><span class="s1">pureComponentPrototype.isPureReactComponent = !0;</span><span class="s3">\n</span><span class="s1">var isArrayImpl = Array.isArray;</span><span class="s3">\n</span><span class="s1">function noop() {}</span><span class="s3">\n</span><span class="s1">var ReactSharedInternals = { H: null, A: null, T: null, S: null, G: null },</span><span class="s3">\n  </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty;</span><span class="s3">\n</span><span class="s1">function ReactElement(type, key, props) {</span><span class="s3">\n  </span><span class="s1">var refProp = props.ref;</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_ELEMENT_TYPE,</span><span class="s3">\n    </span><span class="s1">type: type,</span><span class="s3">\n    </span><span class="s1">key: key,</span><span class="s3">\n    </span><span class="s1">ref: void 0 !== refProp ? refProp : null,</span><span class="s3">\n    </span><span class="s1">props: props</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cloneAndReplaceKey(oldElement, newKey) {</span><span class="s3">\n  </span><span class="s1">return ReactElement(oldElement.type, newKey, oldElement.props);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isValidElement(object) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof object &amp;&amp;</span><span class="s3">\n    </span><span class="s1">null !== object &amp;&amp;</span><span class="s3">\n    </span><span class="s1">object.$$typeof === REACT_ELEMENT_TYPE</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function escape(key) {</span><span class="s3">\n  </span><span class="s1">var escaperLookup = { </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">=0</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">=2</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    \&quot;</span><span class="s1">$</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    </span><span class="s1">key.replace(/[=:]/g, function (match) {</span><span class="s3">\n      </span><span class="s1">return escaperLookup[match];</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var userProvidedKeyEscapeRegex = /</span><span class="s3">\\</span><span class="s1">/+/g;</span><span class="s3">\n</span><span class="s1">function getElementKey(element, index) {</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof element &amp;&amp; null !== element &amp;&amp; null != element.key</span><span class="s3">\n    </span><span class="s1">? escape(</span><span class="s3">\&quot;\&quot; </span><span class="s1">+ element.key)</span><span class="s3">\n    </span><span class="s1">: index.toString(36);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveThenable(thenable) {</span><span class="s3">\n  </span><span class="s1">switch (thenable.status) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">fulfilled</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return thenable.value;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">rejected</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">throw thenable.reason;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">switch (</span><span class="s3">\n        </span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">=== typeof thenable.status</span><span class="s3">\n          </span><span class="s1">? thenable.then(noop, noop)</span><span class="s3">\n          </span><span class="s1">: ((thenable.status = </span><span class="s3">\&quot;</span><span class="s1">pending</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">thenable.then(</span><span class="s3">\n              </span><span class="s1">function (fulfilledValue) {</span><span class="s3">\n                \&quot;</span><span class="s1">pending</span><span class="s3">\&quot; </span><span class="s1">=== thenable.status &amp;&amp;</span><span class="s3">\n                  </span><span class="s1">((thenable.status = </span><span class="s3">\&quot;</span><span class="s1">fulfilled</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">(thenable.value = fulfilledValue));</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">function (error) {</span><span class="s3">\n                \&quot;</span><span class="s1">pending</span><span class="s3">\&quot; </span><span class="s1">=== thenable.status &amp;&amp;</span><span class="s3">\n                  </span><span class="s1">((thenable.status = </span><span class="s3">\&quot;</span><span class="s1">rejected</span><span class="s3">\&quot;</span><span class="s1">), (thenable.reason = error));</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">)),</span><span class="s3">\n        </span><span class="s1">thenable.status)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">fulfilled</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">return thenable.value;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">rejected</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">throw thenable.reason;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw thenable;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {</span><span class="s3">\n  </span><span class="s1">var type = typeof children;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">=== type || </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">=== type) children = null;</span><span class="s3">\n  </span><span class="s1">var invokeCallback = !1;</span><span class="s3">\n  </span><span class="s1">if (null === children) invokeCallback = !0;</span><span class="s3">\n  </span><span class="s1">else</span><span class="s3">\n    </span><span class="s1">switch (type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">invokeCallback = !0;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">switch (children.$$typeof) {</span><span class="s3">\n          </span><span class="s1">case REACT_ELEMENT_TYPE:</span><span class="s3">\n          </span><span class="s1">case REACT_PORTAL_TYPE:</span><span class="s3">\n            </span><span class="s1">invokeCallback = !0;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case REACT_LAZY_TYPE:</span><span class="s3">\n            </span><span class="s1">return (</span><span class="s3">\n              </span><span class="s1">(invokeCallback = children._init),</span><span class="s3">\n              </span><span class="s1">mapIntoArray(</span><span class="s3">\n                </span><span class="s1">invokeCallback(children._payload),</span><span class="s3">\n                </span><span class="s1">array,</span><span class="s3">\n                </span><span class="s1">escapedPrefix,</span><span class="s3">\n                </span><span class="s1">nameSoFar,</span><span class="s3">\n                </span><span class="s1">callback</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (invokeCallback)</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">(callback = callback(children)),</span><span class="s3">\n      </span><span class="s1">(invokeCallback =</span><span class="s3">\n        \&quot;\&quot; </span><span class="s1">=== nameSoFar ? </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ getElementKey(children, 0) : nameSoFar),</span><span class="s3">\n      </span><span class="s1">isArrayImpl(callback)</span><span class="s3">\n        </span><span class="s1">? ((escapedPrefix = </span><span class="s3">\&quot;\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">null != invokeCallback &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(escapedPrefix =</span><span class="s3">\n              </span><span class="s1">invokeCallback.replace(userProvidedKeyEscapeRegex, </span><span class="s3">\&quot;</span><span class="s1">$&amp;/</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">mapIntoArray(callback, array, escapedPrefix, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, function (c) {</span><span class="s3">\n            </span><span class="s1">return c;</span><span class="s3">\n          </span><span class="s1">}))</span><span class="s3">\n        </span><span class="s1">: null != callback &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(isValidElement(callback) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(callback = cloneAndReplaceKey(</span><span class="s3">\n              </span><span class="s1">callback,</span><span class="s3">\n              </span><span class="s1">escapedPrefix +</span><span class="s3">\n                </span><span class="s1">(null == callback.key ||</span><span class="s3">\n                </span><span class="s1">(children &amp;&amp; children.key === callback.key)</span><span class="s3">\n                  </span><span class="s1">? </span><span class="s3">\&quot;\&quot;\n                  </span><span class="s1">: (</span><span class="s3">\&quot;\&quot; </span><span class="s1">+ callback.key).replace(</span><span class="s3">\n                      </span><span class="s1">userProvidedKeyEscapeRegex,</span><span class="s3">\n                      \&quot;</span><span class="s1">$&amp;/</span><span class="s3">\&quot;\n                    </span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) +</span><span class="s3">\n                </span><span class="s1">invokeCallback</span><span class="s3">\n            </span><span class="s1">)),</span><span class="s3">\n          </span><span class="s1">array.push(callback)),</span><span class="s3">\n      </span><span class="s1">1</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">invokeCallback = 0;</span><span class="s3">\n  </span><span class="s1">var nextNamePrefix = </span><span class="s3">\&quot;\&quot; </span><span class="s1">=== nameSoFar ? </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">: nameSoFar + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">if (isArrayImpl(children))</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; children.length; i++)</span><span class="s3">\n      </span><span class="s1">(nameSoFar = children[i]),</span><span class="s3">\n        </span><span class="s1">(type = nextNamePrefix + getElementKey(nameSoFar, i)),</span><span class="s3">\n        </span><span class="s1">(invokeCallback += mapIntoArray(</span><span class="s3">\n          </span><span class="s1">nameSoFar,</span><span class="s3">\n          </span><span class="s1">array,</span><span class="s3">\n          </span><span class="s1">escapedPrefix,</span><span class="s3">\n          </span><span class="s1">type,</span><span class="s3">\n          </span><span class="s1">callback</span><span class="s3">\n        </span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">else if (((i = getIteratorFn(children)), </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof i))</span><span class="s3">\n    </span><span class="s1">for (</span><span class="s3">\n      </span><span class="s1">children = i.call(children), i = 0;</span><span class="s3">\n      </span><span class="s1">!(nameSoFar = children.next()).done;</span><span class="s3">\n\n    </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">(nameSoFar = nameSoFar.value),</span><span class="s3">\n        </span><span class="s1">(type = nextNamePrefix + getElementKey(nameSoFar, i++)),</span><span class="s3">\n        </span><span class="s1">(invokeCallback += mapIntoArray(</span><span class="s3">\n          </span><span class="s1">nameSoFar,</span><span class="s3">\n          </span><span class="s1">array,</span><span class="s3">\n          </span><span class="s1">escapedPrefix,</span><span class="s3">\n          </span><span class="s1">type,</span><span class="s3">\n          </span><span class="s1">callback</span><span class="s3">\n        </span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">else if (</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== type) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof children.then)</span><span class="s3">\n      </span><span class="s1">return mapIntoArray(</span><span class="s3">\n        </span><span class="s1">resolveThenable(children),</span><span class="s3">\n        </span><span class="s1">array,</span><span class="s3">\n        </span><span class="s1">escapedPrefix,</span><span class="s3">\n        </span><span class="s1">nameSoFar,</span><span class="s3">\n        </span><span class="s1">callback</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">array = String(children);</span><span class="s3">\n    </span><span class="s1">throw Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Objects are not valid as a React child (found: </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        </span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">[object Object]</span><span class="s3">\&quot; </span><span class="s1">=== array</span><span class="s3">\n          </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">object with keys {</span><span class="s3">\&quot; </span><span class="s1">+ Object.keys(children).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;\n          </span><span class="s1">: array) +</span><span class="s3">\n        \&quot;</span><span class="s1">). If you meant to render a collection of children, use an array instead.</span><span class="s3">\&quot;\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return invokeCallback;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mapChildren(children, func, context) {</span><span class="s3">\n  </span><span class="s1">if (null == children) return children;</span><span class="s3">\n  </span><span class="s1">var result = [],</span><span class="s3">\n    </span><span class="s1">count = 0;</span><span class="s3">\n  </span><span class="s1">mapIntoArray(children, result, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, function (child) {</span><span class="s3">\n    </span><span class="s1">return func.call(context, child, count++);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function lazyInitializer(payload) {</span><span class="s3">\n  </span><span class="s1">if (-1 === payload._status) {</span><span class="s3">\n    </span><span class="s1">var ctor = payload._result;</span><span class="s3">\n    </span><span class="s1">ctor = ctor();</span><span class="s3">\n    </span><span class="s1">ctor.then(</span><span class="s3">\n      </span><span class="s1">function (moduleObject) {</span><span class="s3">\n        </span><span class="s1">if (0 === payload._status || -1 === payload._status)</span><span class="s3">\n          </span><span class="s1">(payload._status = 1), (payload._result = moduleObject);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">function (error) {</span><span class="s3">\n        </span><span class="s1">if (0 === payload._status || -1 === payload._status)</span><span class="s3">\n          </span><span class="s1">(payload._status = 2), (payload._result = error);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">-1 === payload._status &amp;&amp; ((payload._status = 0), (payload._result = ctor));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (1 === payload._status) return payload._result.default;</span><span class="s3">\n  </span><span class="s1">throw payload._result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function useOptimistic(passthrough, reducer) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useOptimistic(passthrough, reducer);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var reportGlobalError =</span><span class="s3">\n  \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof reportError</span><span class="s3">\n    </span><span class="s1">? reportError</span><span class="s3">\n    </span><span class="s1">: function (error) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof window &amp;&amp;</span><span class="s3">\n          \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof window.ErrorEvent</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">var event = new window.ErrorEvent(</span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n            </span><span class="s1">bubbles: !0,</span><span class="s3">\n            </span><span class="s1">cancelable: !0,</span><span class="s3">\n            </span><span class="s1">message:</span><span class="s3">\n              \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof error &amp;&amp;</span><span class="s3">\n              </span><span class="s1">null !== error &amp;&amp;</span><span class="s3">\n              \&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">=== typeof error.message</span><span class="s3">\n                </span><span class="s1">? String(error.message)</span><span class="s3">\n                </span><span class="s1">: String(error),</span><span class="s3">\n            </span><span class="s1">error: error</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">if (!window.dispatchEvent(event)) return;</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof process &amp;&amp;</span><span class="s3">\n          \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof process.emit</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">process.emit(</span><span class="s3">\&quot;</span><span class="s1">uncaughtException</span><span class="s3">\&quot;</span><span class="s1">, error);</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">console.error(error);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function startTransition(scope) {</span><span class="s3">\n  </span><span class="s1">var prevTransition = ReactSharedInternals.T,</span><span class="s3">\n    </span><span class="s1">currentTransition = {};</span><span class="s3">\n  </span><span class="s1">currentTransition.types =</span><span class="s3">\n    </span><span class="s1">null !== prevTransition ? prevTransition.types : null;</span><span class="s3">\n  </span><span class="s1">currentTransition.gesture = null;</span><span class="s3">\n  </span><span class="s1">ReactSharedInternals.T = currentTransition;</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">var returnValue = scope(),</span><span class="s3">\n      </span><span class="s1">onStartTransitionFinish = ReactSharedInternals.S;</span><span class="s3">\n    </span><span class="s1">null !== onStartTransitionFinish &amp;&amp;</span><span class="s3">\n      </span><span class="s1">onStartTransitionFinish(currentTransition, returnValue);</span><span class="s3">\n    \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof returnValue &amp;&amp;</span><span class="s3">\n      </span><span class="s1">null !== returnValue &amp;&amp;</span><span class="s3">\n      \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof returnValue.then &amp;&amp;</span><span class="s3">\n      </span><span class="s1">returnValue.then(noop, reportGlobalError);</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">reportGlobalError(error);</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">null !== prevTransition &amp;&amp;</span><span class="s3">\n      </span><span class="s1">null !== currentTransition.types &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(prevTransition.types = currentTransition.types),</span><span class="s3">\n      </span><span class="s1">(ReactSharedInternals.T = prevTransition);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addTransitionType(type) {</span><span class="s3">\n  </span><span class="s1">var transition = ReactSharedInternals.T;</span><span class="s3">\n  </span><span class="s1">if (null !== transition) {</span><span class="s3">\n    </span><span class="s1">var transitionTypes = transition.types;</span><span class="s3">\n    </span><span class="s1">null === transitionTypes</span><span class="s3">\n      </span><span class="s1">? (transition.types = [type])</span><span class="s3">\n      </span><span class="s1">: -1 === transitionTypes.indexOf(type) &amp;&amp; transitionTypes.push(type);</span><span class="s3">\n  </span><span class="s1">} else startTransition(addTransitionType.bind(null, type));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.Children = {</span><span class="s3">\n  </span><span class="s1">map: mapChildren,</span><span class="s3">\n  </span><span class="s1">forEach: function (children, forEachFunc, forEachContext) {</span><span class="s3">\n    </span><span class="s1">mapChildren(</span><span class="s3">\n      </span><span class="s1">children,</span><span class="s3">\n      </span><span class="s1">function () {</span><span class="s3">\n        </span><span class="s1">forEachFunc.apply(this, arguments);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">forEachContext</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">count: function (children) {</span><span class="s3">\n    </span><span class="s1">var n = 0;</span><span class="s3">\n    </span><span class="s1">mapChildren(children, function () {</span><span class="s3">\n      </span><span class="s1">n++;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return n;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">toArray: function (children) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">mapChildren(children, function (child) {</span><span class="s3">\n        </span><span class="s1">return child;</span><span class="s3">\n      </span><span class="s1">}) || []</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">only: function (children) {</span><span class="s3">\n    </span><span class="s1">if (!isValidElement(children))</span><span class="s3">\n      </span><span class="s1">throw Error(</span><span class="s3">\n        \&quot;</span><span class="s1">React.Children.only expected to receive a single React element child.</span><span class="s3">\&quot;\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return children;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.Component = Component;</span><span class="s3">\n</span><span class="s1">exports.Fragment = REACT_FRAGMENT_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Profiler = REACT_PROFILER_TYPE;</span><span class="s3">\n</span><span class="s1">exports.PureComponent = PureComponent;</span><span class="s3">\n</span><span class="s1">exports.StrictMode = REACT_STRICT_MODE_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Suspense = REACT_SUSPENSE_TYPE;</span><span class="s3">\n</span><span class="s1">exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =</span><span class="s3">\n  </span><span class="s1">ReactSharedInternals;</span><span class="s3">\n</span><span class="s1">exports.__COMPILER_RUNTIME = {</span><span class="s3">\n  </span><span class="s1">__proto__: null,</span><span class="s3">\n  </span><span class="s1">c: function (size) {</span><span class="s3">\n    </span><span class="s1">return ReactSharedInternals.H.useMemoCache(size);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.cache = function (fn) {</span><span class="s3">\n  </span><span class="s1">return function () {</span><span class="s3">\n    </span><span class="s1">return fn.apply(null, arguments);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.cacheSignal = function () {</span><span class="s3">\n  </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.cloneElement = function (element, config, children) {</span><span class="s3">\n  </span><span class="s1">if (null === element || void 0 === element)</span><span class="s3">\n    </span><span class="s1">throw Error(</span><span class="s3">\n      \&quot;</span><span class="s1">The argument must be a React element, but you passed </span><span class="s3">\&quot; </span><span class="s1">+ element + </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">var props = assign({}, element.props),</span><span class="s3">\n    </span><span class="s1">key = element.key;</span><span class="s3">\n  </span><span class="s1">if (null != config)</span><span class="s3">\n    </span><span class="s1">for (propName in (void 0 !== config.key &amp;&amp; (key = </span><span class="s3">\&quot;\&quot; </span><span class="s1">+ config.key), config))</span><span class="s3">\n      </span><span class="s1">!hasOwnProperty.call(config, propName) ||</span><span class="s3">\n        \&quot;</span><span class="s1">key</span><span class="s3">\&quot; </span><span class="s1">=== propName ||</span><span class="s3">\n        \&quot;</span><span class="s1">__self</span><span class="s3">\&quot; </span><span class="s1">=== propName ||</span><span class="s3">\n        \&quot;</span><span class="s1">__source</span><span class="s3">\&quot; </span><span class="s1">=== propName ||</span><span class="s3">\n        </span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">ref</span><span class="s3">\&quot; </span><span class="s1">=== propName &amp;&amp; void 0 === config.ref) ||</span><span class="s3">\n        </span><span class="s1">(props[propName] = config[propName]);</span><span class="s3">\n  </span><span class="s1">var propName = arguments.length - 2;</span><span class="s3">\n  </span><span class="s1">if (1 === propName) props.children = children;</span><span class="s3">\n  </span><span class="s1">else if (1 &lt; propName) {</span><span class="s3">\n    </span><span class="s1">for (var childArray = Array(propName), i = 0; i &lt; propName; i++)</span><span class="s3">\n      </span><span class="s1">childArray[i] = arguments[i + 2];</span><span class="s3">\n    </span><span class="s1">props.children = childArray;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ReactElement(element.type, key, props);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.createContext = function (defaultValue) {</span><span class="s3">\n  </span><span class="s1">defaultValue = {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_CONTEXT_TYPE,</span><span class="s3">\n    </span><span class="s1">_currentValue: defaultValue,</span><span class="s3">\n    </span><span class="s1">_currentValue2: defaultValue,</span><span class="s3">\n    </span><span class="s1">_threadCount: 0,</span><span class="s3">\n    </span><span class="s1">Provider: null,</span><span class="s3">\n    </span><span class="s1">Consumer: null</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">defaultValue.Provider = defaultValue;</span><span class="s3">\n  </span><span class="s1">defaultValue.Consumer = {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_CONSUMER_TYPE,</span><span class="s3">\n    </span><span class="s1">_context: defaultValue</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return defaultValue;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.createElement = function (type, config, children) {</span><span class="s3">\n  </span><span class="s1">var propName,</span><span class="s3">\n    </span><span class="s1">props = {},</span><span class="s3">\n    </span><span class="s1">key = null;</span><span class="s3">\n  </span><span class="s1">if (null != config)</span><span class="s3">\n    </span><span class="s1">for (propName in (void 0 !== config.key &amp;&amp; (key = </span><span class="s3">\&quot;\&quot; </span><span class="s1">+ config.key), config))</span><span class="s3">\n      </span><span class="s1">hasOwnProperty.call(config, propName) &amp;&amp;</span><span class="s3">\n        \&quot;</span><span class="s1">key</span><span class="s3">\&quot; </span><span class="s1">!== propName &amp;&amp;</span><span class="s3">\n        \&quot;</span><span class="s1">__self</span><span class="s3">\&quot; </span><span class="s1">!== propName &amp;&amp;</span><span class="s3">\n        \&quot;</span><span class="s1">__source</span><span class="s3">\&quot; </span><span class="s1">!== propName &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(props[propName] = config[propName]);</span><span class="s3">\n  </span><span class="s1">var childrenLength = arguments.length - 2;</span><span class="s3">\n  </span><span class="s1">if (1 === childrenLength) props.children = children;</span><span class="s3">\n  </span><span class="s1">else if (1 &lt; childrenLength) {</span><span class="s3">\n    </span><span class="s1">for (var childArray = Array(childrenLength), i = 0; i &lt; childrenLength; i++)</span><span class="s3">\n      </span><span class="s1">childArray[i] = arguments[i + 2];</span><span class="s3">\n    </span><span class="s1">props.children = childArray;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (type &amp;&amp; type.defaultProps)</span><span class="s3">\n    </span><span class="s1">for (propName in ((childrenLength = type.defaultProps), childrenLength))</span><span class="s3">\n      </span><span class="s1">void 0 === props[propName] &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(props[propName] = childrenLength[propName]);</span><span class="s3">\n  </span><span class="s1">return ReactElement(type, key, props);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.createRef = function () {</span><span class="s3">\n  </span><span class="s1">return { current: null };</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.experimental_useEffectEvent = function (callback) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useEffectEvent(callback);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.experimental_useOptimistic = function (passthrough, reducer) {</span><span class="s3">\n  </span><span class="s1">return useOptimistic(passthrough, reducer);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.forwardRef = function (render) {</span><span class="s3">\n  </span><span class="s1">return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isValidElement = isValidElement;</span><span class="s3">\n</span><span class="s1">exports.lazy = function (ctor) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_LAZY_TYPE,</span><span class="s3">\n    </span><span class="s1">_payload: { _status: -1, _result: ctor },</span><span class="s3">\n    </span><span class="s1">_init: lazyInitializer</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.memo = function (type, compare) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">$$typeof: REACT_MEMO_TYPE,</span><span class="s3">\n    </span><span class="s1">type: type,</span><span class="s3">\n    </span><span class="s1">compare: void 0 === compare ? null : compare</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.startTransition = startTransition;</span><span class="s3">\n</span><span class="s1">exports.unstable_Activity = REACT_ACTIVITY_TYPE;</span><span class="s3">\n</span><span class="s1">exports.unstable_SuspenseList = REACT_SUSPENSE_LIST_TYPE;</span><span class="s3">\n</span><span class="s1">exports.unstable_ViewTransition = REACT_VIEW_TRANSITION_TYPE;</span><span class="s3">\n</span><span class="s1">exports.unstable_addTransitionType = addTransitionType;</span><span class="s3">\n</span><span class="s1">exports.unstable_getCacheForType = function (resourceType) {</span><span class="s3">\n  </span><span class="s1">var dispatcher = ReactSharedInternals.A;</span><span class="s3">\n  </span><span class="s1">return dispatcher ? dispatcher.getCacheForType(resourceType) : resourceType();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.unstable_postpone = function (reason) {</span><span class="s3">\n  </span><span class="s1">reason = Error(reason);</span><span class="s3">\n  </span><span class="s1">reason.$$typeof = REACT_POSTPONE_TYPE;</span><span class="s3">\n  </span><span class="s1">throw reason;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.unstable_startGestureTransition = function (provider, scope, options) {</span><span class="s3">\n  </span><span class="s1">if (null == provider)</span><span class="s3">\n    </span><span class="s1">throw Error(</span><span class="s3">\n      \&quot;</span><span class="s1">A Timeline is required as the first argument to startGestureTransition.</span><span class="s3">\&quot;\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">var prevTransition = ReactSharedInternals.T,</span><span class="s3">\n    </span><span class="s1">currentTransition = { types: null };</span><span class="s3">\n  </span><span class="s1">currentTransition.gesture = provider;</span><span class="s3">\n  </span><span class="s1">ReactSharedInternals.T = currentTransition;</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">scope();</span><span class="s3">\n    </span><span class="s1">var onStartGestureTransitionFinish = ReactSharedInternals.G;</span><span class="s3">\n    </span><span class="s1">if (null !== onStartGestureTransitionFinish)</span><span class="s3">\n      </span><span class="s1">return onStartGestureTransitionFinish(</span><span class="s3">\n        </span><span class="s1">currentTransition,</span><span class="s3">\n        </span><span class="s1">provider,</span><span class="s3">\n        </span><span class="s1">options</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">reportGlobalError(error);</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">ReactSharedInternals.T = prevTransition;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return noop;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.unstable_useCacheRefresh = function () {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useCacheRefresh();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.use = function (usable) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.use(usable);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useActionState = function (action, initialState, permalink) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useActionState(action, initialState, permalink);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useCallback = function (callback, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useCallback(callback, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useContext = function (Context) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useContext(Context);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useDebugValue = function () {};</span><span class="s3">\n</span><span class="s1">exports.useDeferredValue = function (value, initialValue) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useDeferredValue(value, initialValue);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useEffect = function (create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useEffect(create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useId = function () {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useId();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useImperativeHandle = function (ref, create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useInsertionEffect = function (create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useInsertionEffect(create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useLayoutEffect = function (create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useLayoutEffect(create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useMemo = function (create, deps) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useMemo(create, deps);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useOptimistic = useOptimistic;</span><span class="s3">\n</span><span class="s1">exports.useReducer = function (reducer, initialArg, init) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useReducer(reducer, initialArg, init);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useRef = function (initialValue) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useRef(initialValue);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useState = function (initialState) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useState(initialState);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useSyncExternalStore = function (</span><span class="s3">\n  </span><span class="s1">subscribe,</span><span class="s3">\n  </span><span class="s1">getSnapshot,</span><span class="s3">\n  </span><span class="s1">getServerSnapshot</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useSyncExternalStore(</span><span class="s3">\n    </span><span class="s1">subscribe,</span><span class="s3">\n    </span><span class="s1">getSnapshot,</span><span class="s3">\n    </span><span class="s1">getServerSnapshot</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.useTransition = function () {</span><span class="s3">\n  </span><span class="s1">return ReactSharedInternals.H.useTransition();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.version = </span><span class="s3">\&quot;</span><span class="s1">19.2.0-experimental-0bdb9206-20250818</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n  </span><span class="s1">module.exports = require('./cjs/react.production.js');</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">module.exports = require('./cjs/react.development.js');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;var e={328:e=&gt;{function hash(e){var r=5381,_=e.length;while(_){r=r*33^e.charCodeAt(--_)}return r&gt;&gt;&gt;0}e.exports=hash}};var r={};function __nccwpck_require__(_){var a=r[_];if(a!==undefined){return a.exports}var t=r[_]={exports:{}};var i=true;try{e[_](t,t.exports,__nccwpck_require__);i=false}finally{if(i)delete r[_]}return t.exports}if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var _=__nccwpck_require__(328);module.exports=_})();&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ServerRuntime } from '../types'</span><span class="s3">\n\n</span><span class="s1">export const TEXT_PLAIN_CONTENT_TYPE_HEADER = 'text/plain'</span><span class="s3">\n</span><span class="s1">export const HTML_CONTENT_TYPE_HEADER = 'text/html; charset=utf-8'</span><span class="s3">\n</span><span class="s1">export const JSON_CONTENT_TYPE_HEADER = 'application/json; charset=utf-8'</span><span class="s3">\n</span><span class="s1">export const NEXT_QUERY_PARAM_PREFIX = 'nxtP'</span><span class="s3">\n</span><span class="s1">export const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI'</span><span class="s3">\n\n</span><span class="s1">export const MATCHED_PATH_HEADER = 'x-matched-path'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER =</span><span class="s3">\n  </span><span class="s1">'x-prerender-revalidate-if-generated'</span><span class="s3">\n\n</span><span class="s1">export const RSC_PREFETCH_SUFFIX = '.prefetch.rsc'</span><span class="s3">\n</span><span class="s1">export const RSC_SEGMENTS_DIR_SUFFIX = '.segments'</span><span class="s3">\n</span><span class="s1">export const RSC_SEGMENT_SUFFIX = '.segment.rsc'</span><span class="s3">\n</span><span class="s1">export const RSC_SUFFIX = '.rsc'</span><span class="s3">\n</span><span class="s1">export const ACTION_SUFFIX = '.action'</span><span class="s3">\n</span><span class="s1">export const NEXT_DATA_SUFFIX = '.json'</span><span class="s3">\n</span><span class="s1">export const NEXT_META_SUFFIX = '.meta'</span><span class="s3">\n</span><span class="s1">export const NEXT_BODY_SUFFIX = '.body'</span><span class="s3">\n\n</span><span class="s1">export const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags'</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags'</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER =</span><span class="s3">\n  </span><span class="s1">'x-next-revalidate-tag-token'</span><span class="s3">\n\n</span><span class="s1">export const NEXT_RESUME_HEADER = 'next-resume'</span><span class="s3">\n\n</span><span class="s1">// if these change make sure we update the related</span><span class="s3">\n</span><span class="s1">// documentation as well</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_TAG_MAX_ITEMS = 128</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_TAG_MAX_LENGTH = 256</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_'</span><span class="s3">\n\n</span><span class="s1">// in seconds</span><span class="s3">\n</span><span class="s1">export const CACHE_ONE_YEAR = 31536000</span><span class="s3">\n\n</span><span class="s1">// in seconds, represents revalidate=false. I.e. never revaliate.</span><span class="s3">\n</span><span class="s1">// We use this value since it can be represented as a V8 SMI for optimal performance.</span><span class="s3">\n</span><span class="s1">// It can also be serialized as JSON if it ever leaks accidentally as an actual value.</span><span class="s3">\n</span><span class="s1">export const INFINITE_CACHE = 0xfffffffe</span><span class="s3">\n\n</span><span class="s1">// Patterns to detect middleware files</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_FILENAME = 'middleware'</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`</span><span class="s3">\n\n</span><span class="s1">// Pattern to detect instrumentation hooks file</span><span class="s3">\n</span><span class="s1">export const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation'</span><span class="s3">\n\n</span><span class="s1">// Because on Windows absolute paths in the generated code can break because of numbers, eg 1 in the path,</span><span class="s3">\n</span><span class="s1">// we have to use a private alias</span><span class="s3">\n</span><span class="s1">export const PAGES_DIR_ALIAS = 'private-next-pages'</span><span class="s3">\n</span><span class="s1">export const DOT_NEXT_ALIAS = 'private-dot-next'</span><span class="s3">\n</span><span class="s1">export const ROOT_DIR_ALIAS = 'private-next-root-dir'</span><span class="s3">\n</span><span class="s1">export const APP_DIR_ALIAS = 'private-next-app-dir'</span><span class="s3">\n</span><span class="s1">export const RSC_MOD_REF_PROXY_ALIAS = 'private-next-rsc-mod-ref-proxy'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference'</span><span class="s3">\n</span><span class="s1">export const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper'</span><span class="s3">\n</span><span class="s1">export const RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS =</span><span class="s3">\n  </span><span class="s1">'private-next-rsc-track-dynamic-import'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_CLIENT_WRAPPER_ALIAS =</span><span class="s3">\n  </span><span class="s1">'private-next-rsc-action-client-wrapper'</span><span class="s3">\n\n</span><span class="s1">export const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`</span><span class="s3">\n\n</span><span class="s1">export const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`</span><span class="s3">\n\n</span><span class="s1">export const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_EXPORT_ERROR = `pages with </span><span class="s3">\\</span><span class="s1">`getServerSideProps</span><span class="s3">\\</span><span class="s1">` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`</span><span class="s3">\n\n</span><span class="s1">export const GSP_NO_RETURNED_VALUE =</span><span class="s3">\n  </span><span class="s1">'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?'</span><span class="s3">\n</span><span class="s1">export const GSSP_NO_RETURNED_VALUE =</span><span class="s3">\n  </span><span class="s1">'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?'</span><span class="s3">\n\n</span><span class="s1">export const UNSTABLE_REVALIDATE_RENAME_ERROR =</span><span class="s3">\n  </span><span class="s1">'The `unstable_revalidate` property is available for general use.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n  </span><span class="s1">'Please use `revalidate` instead.'</span><span class="s3">\n\n</span><span class="s1">export const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`</span><span class="s3">\n\n</span><span class="s1">export const NON_STANDARD_NODE_ENV = `You are using a non-standard </span><span class="s3">\&quot;</span><span class="s1">NODE_ENV</span><span class="s3">\&quot; </span><span class="s1">value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`</span><span class="s3">\n\n</span><span class="s1">export const SSG_FALLBACK_EXPORT_ERROR = `Pages with </span><span class="s3">\\</span><span class="s1">`fallback</span><span class="s3">\\</span><span class="s1">` enabled in </span><span class="s3">\\</span><span class="s1">`getStaticPaths</span><span class="s3">\\</span><span class="s1">` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`</span><span class="s3">\n\n</span><span class="s1">export const ESLINT_DEFAULT_DIRS = ['app', 'pages', 'components', 'lib', 'src']</span><span class="s3">\n\n</span><span class="s1">export const SERVER_RUNTIME: Record&lt;string, ServerRuntime&gt; = {</span><span class="s3">\n  </span><span class="s1">edge: 'edge',</span><span class="s3">\n  </span><span class="s1">experimentalEdge: 'experimental-edge',</span><span class="s3">\n  </span><span class="s1">nodejs: 'nodejs',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The names of the webpack layers. These layers are the primitives for the</span><span class="s3">\n </span><span class="s1">* webpack chunks.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const WEBPACK_LAYERS_NAMES = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the shared code between the client and server bundles.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">shared: 'shared',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for server-only runtime and picking up `react-server` export conditions.</span><span class="s3">\n   </span><span class="s1">* Including app router RSC pages and app router custom routes and metadata routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">reactServerComponents: 'rsc',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Server Side Rendering layer for app (ssr).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">serverSideRendering: 'ssr',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for actions.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">actionBrowser: 'action-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Node.js bundle layer for the API routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apiNode: 'api-node',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Edge Lite bundle layer for the API routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apiEdge: 'api-edge',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the middleware code.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middleware: 'middleware',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the instrumentation hooks.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">instrument: 'instrument',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for assets on the edge.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">edgeAsset: 'edge-asset',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for App directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">appPagesBrowser: 'app-pages-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirBrowser: 'pages-dir-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Edge Lite bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirEdge: 'pages-dir-edge',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Node.js bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirNode: 'pages-dir-node',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export type WebpackLayerName =</span><span class="s3">\n  </span><span class="s1">(typeof WEBPACK_LAYERS_NAMES)[keyof typeof WEBPACK_LAYERS_NAMES]</span><span class="s3">\n\n</span><span class="s1">const WEBPACK_LAYERS = {</span><span class="s3">\n  </span><span class="s1">...WEBPACK_LAYERS_NAMES,</span><span class="s3">\n  </span><span class="s1">GROUP: {</span><span class="s3">\n    </span><span class="s1">builtinReact: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">serverOnly: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.instrument,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.middleware,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">neutralTarget: [</span><span class="s3">\n      </span><span class="s1">// pages api</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.apiNode,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.apiEdge,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">clientOnly: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">bundled: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.shared,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.instrument,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.middleware,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">appPages: [</span><span class="s3">\n      </span><span class="s1">// app router pages and layouts</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const WEBPACK_RESOURCE_QUERIES = {</span><span class="s3">\n  </span><span class="s1">edgeSSREntry: '__next_edge_ssr_entry__',</span><span class="s3">\n  </span><span class="s1">metadata: '__next_metadata__',</span><span class="s3">\n  </span><span class="s1">metadataRoute: '__next_metadata_route__',</span><span class="s3">\n  </span><span class="s1">metadataImageMeta: '__next_metadata_image_meta__',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { WEBPACK_LAYERS, WEBPACK_RESOURCE_QUERIES }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from 'path'</span><span class="s3">\n</span><span class="s1">import { pathToFileURL } from 'url'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The path for a dynamic route must be URLs with a valid scheme.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* When an absolute Windows path is passed to it, it interprets the beginning of the path as a protocol (`C:`).</span><span class="s3">\n </span><span class="s1">* Therefore, it is important to always construct a complete path.</span><span class="s3">\n </span><span class="s1">* @param dir File directory</span><span class="s3">\n </span><span class="s1">* @param filePath Absolute or relative path</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const formatDynamicImportPath = (dir: string, filePath: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">const absoluteFilePath = path.isAbsolute(filePath)</span><span class="s3">\n    </span><span class="s1">? filePath</span><span class="s3">\n    </span><span class="s1">: path.join(dir, filePath)</span><span class="s3">\n  </span><span class="s1">const formattedFilePath = pathToFileURL(absoluteFilePath).toString()</span><span class="s3">\n\n  </span><span class="s1">return formattedFilePath</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { CookieSerializeOptions } from 'next/dist/compiled/cookie'</span><span class="s3">\n</span><span class="s1">import type { NextApiResponse } from '../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">import { HeadersAdapter } from '../web/spec-extension/adapters/headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_HEADER,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NodeSpan } from '../lib/trace/constants'</span><span class="s3">\n\n</span><span class="s1">export type NextApiRequestCookies = Partial&lt;{ [key: string]: string }&gt;</span><span class="s3">\n</span><span class="s1">export type NextApiRequestQuery = Partial&lt;{ [key: string]: string | string[] }&gt;</span><span class="s3">\n\n</span><span class="s1">export type __ApiPreviewProps = {</span><span class="s3">\n  </span><span class="s1">previewModeId: string</span><span class="s3">\n  </span><span class="s1">previewModeEncryptionKey: string</span><span class="s3">\n  </span><span class="s1">previewModeSigningKey: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function wrapApiHandler&lt;T extends (...args: any[]) =&gt; any&gt;(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">handler: T</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">return ((...args) =&gt; {</span><span class="s3">\n    </span><span class="s1">getTracer().setRootSpanAttribute('next.route', page)</span><span class="s3">\n    </span><span class="s1">// Call API route method</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">NodeSpan.runHandler,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">spanName: `executing api route (pages) ${page}`,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">() =&gt; handler(...args)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param statusCode `HTTP` status code of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sendStatusCode(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusCode: number</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">res.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param [statusOrUrl] `HTTP` status code of redirect</span><span class="s3">\n </span><span class="s1">* @param url URL of redirect</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function redirect(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusOrUrl: string | number,</span><span class="s3">\n  </span><span class="s1">url?: string</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof statusOrUrl === 'string') {</span><span class="s3">\n    </span><span class="s1">url = statusOrUrl</span><span class="s3">\n    </span><span class="s1">statusOrUrl = 307</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">res.writeHead(statusOrUrl, { Location: url })</span><span class="s3">\n  </span><span class="s1">res.write(url)</span><span class="s3">\n  </span><span class="s1">res.end()</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function checkIsOnDemandRevalidate(</span><span class="s3">\n  </span><span class="s1">req: Request | IncomingMessage | BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">isOnDemandRevalidate: boolean</span><span class="s3">\n  </span><span class="s1">revalidateOnlyGenerated: boolean</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const headers = HeadersAdapter.from(req.headers)</span><span class="s3">\n\n  </span><span class="s1">const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)</span><span class="s3">\n  </span><span class="s1">const isOnDemandRevalidate = previewModeId === previewProps.previewModeId</span><span class="s3">\n\n  </span><span class="s1">const revalidateOnlyGenerated = headers.has(</span><span class="s3">\n    </span><span class="s1">PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return { isOnDemandRevalidate, revalidateOnlyGenerated }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`</span><span class="s3">\n</span><span class="s1">export const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`</span><span class="s3">\n\n</span><span class="s1">export const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024</span><span class="s3">\n\n</span><span class="s1">export const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)</span><span class="s3">\n</span><span class="s1">export const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)</span><span class="s3">\n\n</span><span class="s1">export function clearPreviewData&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">path?: string</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (SYMBOL_CLEARED_COOKIES in res) {</span><span class="s3">\n    </span><span class="s1">return res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { serialize } =</span><span class="s3">\n    </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n  </span><span class="s1">const previous = res.getHeader('Set-Cookie')</span><span class="s3">\n  </span><span class="s1">res.setHeader(`Set-Cookie`, [</span><span class="s3">\n    </span><span class="s1">...(typeof previous === 'string'</span><span class="s3">\n      </span><span class="s1">? [previous]</span><span class="s3">\n      </span><span class="s1">: Array.isArray(previous)</span><span class="s3">\n        </span><span class="s1">? previous</span><span class="s3">\n        </span><span class="s1">: []),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {</span><span class="s3">\n      </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n      </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n      </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n      </span><span class="s1">expires: new Date(0),</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_DATA, '', {</span><span class="s3">\n      </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n      </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n      </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n      </span><span class="s1">expires: new Date(0),</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {</span><span class="s3">\n    </span><span class="s1">value: true,</span><span class="s3">\n    </span><span class="s1">enumerable: false,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Custom error class</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ApiError extends Error {</span><span class="s3">\n  </span><span class="s1">readonly statusCode: number</span><span class="s3">\n\n  </span><span class="s1">constructor(statusCode: number, message: string) {</span><span class="s3">\n    </span><span class="s1">super(message)</span><span class="s3">\n    </span><span class="s1">this.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sends error in `response`</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param statusCode of response</span><span class="s3">\n </span><span class="s1">* @param message of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sendError(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusCode: number,</span><span class="s3">\n  </span><span class="s1">message: string</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">res.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">res.statusMessage = message</span><span class="s3">\n  </span><span class="s1">res.end(message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface LazyProps {</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Execute getter function only if its needed</span><span class="s3">\n </span><span class="s1">* @param LazyProps `req` and `params` for lazyProp</span><span class="s3">\n </span><span class="s1">* @param prop name of property</span><span class="s3">\n </span><span class="s1">* @param getter function to get data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setLazyProp&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">{ req }: LazyProps,</span><span class="s3">\n  </span><span class="s1">prop: string,</span><span class="s3">\n  </span><span class="s1">getter: () =&gt; T</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const opts = { configurable: true, enumerable: true }</span><span class="s3">\n  </span><span class="s1">const optsReset = { ...opts, writable: true }</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(req, prop, {</span><span class="s3">\n    </span><span class="s1">...opts,</span><span class="s3">\n    </span><span class="s1">get: () =&gt; {</span><span class="s3">\n      </span><span class="s1">const value = getter()</span><span class="s3">\n      </span><span class="s1">// we set the property on the object to avoid recalculating it</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(req, prop, { ...optsReset, value })</span><span class="s3">\n      </span><span class="s1">return value</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set: (value) =&gt; {</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(req, prop, { ...optsReset, value })</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { NextApiResponse } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { checkIsOnDemandRevalidate } from '../.'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../.'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest, BaseNextResponse } from '../../base-http'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../../types'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">clearPreviewData,</span><span class="s3">\n  </span><span class="s1">COOKIE_NAME_PRERENDER_BYPASS,</span><span class="s3">\n  </span><span class="s1">COOKIE_NAME_PRERENDER_DATA,</span><span class="s3">\n  </span><span class="s1">SYMBOL_PREVIEW_DATA,</span><span class="s3">\n</span><span class="s1">} from '../index'</span><span class="s3">\n</span><span class="s1">import { RequestCookies } from '../../web/spec-extension/cookies'</span><span class="s3">\n</span><span class="s1">import { HeadersAdapter } from '../../web/spec-extension/adapters/headers'</span><span class="s3">\n\n</span><span class="s1">export function tryGetPreviewData(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage | BaseNextRequest | Request,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse | BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">options: __ApiPreviewProps,</span><span class="s3">\n  </span><span class="s1">multiZoneDraftMode: boolean</span><span class="s3">\n</span><span class="s1">): PreviewData {</span><span class="s3">\n  </span><span class="s1">// if an On-Demand revalidation is being done preview mode</span><span class="s3">\n  </span><span class="s1">// is disabled</span><span class="s3">\n  </span><span class="s1">if (options &amp;&amp; checkIsOnDemandRevalidate(req, options).isOnDemandRevalidate) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Read cached preview data if present</span><span class="s3">\n  </span><span class="s1">// TODO: use request metadata instead of a symbol</span><span class="s3">\n  </span><span class="s1">if (SYMBOL_PREVIEW_DATA in req) {</span><span class="s3">\n    </span><span class="s1">return (req as any)[SYMBOL_PREVIEW_DATA] as any</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const headers = HeadersAdapter.from(req.headers)</span><span class="s3">\n  </span><span class="s1">const cookies = new RequestCookies(headers)</span><span class="s3">\n\n  </span><span class="s1">const previewModeId = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value</span><span class="s3">\n  </span><span class="s1">const tokenPreviewData = cookies.get(COOKIE_NAME_PRERENDER_DATA)?.value</span><span class="s3">\n\n  </span><span class="s1">// Case: preview mode cookie set but data cookie is not set</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">previewModeId &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!tokenPreviewData &amp;&amp;</span><span class="s3">\n    </span><span class="s1">previewModeId === options.previewModeId</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// This is </span><span class="s3">\&quot;</span><span class="s1">Draft Mode</span><span class="s3">\&quot; </span><span class="s1">which doesn't use</span><span class="s3">\n    </span><span class="s1">// previewData, so we return an empty object</span><span class="s3">\n    </span><span class="s1">// for backwards compat with </span><span class="s3">\&quot;</span><span class="s1">Preview Mode</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n    </span><span class="s1">const data = {}</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(req, SYMBOL_PREVIEW_DATA, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">enumerable: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return data</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: neither cookie is set.</span><span class="s3">\n  </span><span class="s1">if (!previewModeId &amp;&amp; !tokenPreviewData) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: one cookie is set, but not the other.</span><span class="s3">\n  </span><span class="s1">if (!previewModeId || !tokenPreviewData) {</span><span class="s3">\n    </span><span class="s1">if (!multiZoneDraftMode) {</span><span class="s3">\n      </span><span class="s1">clearPreviewData(res as NextApiResponse)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: preview session is for an old build.</span><span class="s3">\n  </span><span class="s1">if (previewModeId !== options.previewModeId) {</span><span class="s3">\n    </span><span class="s1">if (!multiZoneDraftMode) {</span><span class="s3">\n      </span><span class="s1">clearPreviewData(res as NextApiResponse)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let encryptedPreviewData: {</span><span class="s3">\n    </span><span class="s1">data: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const jsonwebtoken =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/jsonwebtoken') as typeof import('next/dist/compiled/jsonwebtoken')</span><span class="s3">\n    </span><span class="s1">encryptedPreviewData = jsonwebtoken.verify(</span><span class="s3">\n      </span><span class="s1">tokenPreviewData,</span><span class="s3">\n      </span><span class="s1">options.previewModeSigningKey</span><span class="s3">\n    </span><span class="s1">) as typeof encryptedPreviewData</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">// TODO: warn</span><span class="s3">\n    </span><span class="s1">clearPreviewData(res as NextApiResponse)</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { decryptWithSecret } =</span><span class="s3">\n    </span><span class="s1">require('../../crypto-utils') as typeof import('../../crypto-utils')</span><span class="s3">\n  </span><span class="s1">const decryptedPreviewData = decryptWithSecret(</span><span class="s3">\n    </span><span class="s1">Buffer.from(options.previewModeEncryptionKey),</span><span class="s3">\n    </span><span class="s1">encryptedPreviewData.data</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// TODO: strict runtime type checking</span><span class="s3">\n    </span><span class="s1">const data = JSON.parse(decryptedPreviewData)</span><span class="s3">\n    </span><span class="s1">// Cache lookup</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(req, SYMBOL_PREVIEW_DATA, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">enumerable: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return data</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import crypto from 'crypto'</span><span class="s3">\n\n</span><span class="s1">// Background:</span><span class="s3">\n</span><span class="s1">// https://security.stackexchange.com/questions/184305/why-would-i-ever-use-aes-256-cbc-if-aes-256-gcm-is-more-secure</span><span class="s3">\n\n</span><span class="s1">const CIPHER_ALGORITHM = `aes-256-gcm`,</span><span class="s3">\n  </span><span class="s1">CIPHER_KEY_LENGTH = 32, // https://stackoverflow.com/a/28307668/4397028</span><span class="s3">\n  </span><span class="s1">CIPHER_IV_LENGTH = 16, // https://stackoverflow.com/a/28307668/4397028</span><span class="s3">\n  </span><span class="s1">CIPHER_TAG_LENGTH = 16,</span><span class="s3">\n  </span><span class="s1">CIPHER_SALT_LENGTH = 64</span><span class="s3">\n\n</span><span class="s1">const PBKDF2_ITERATIONS = 100_000 // https://support.1password.com/pbkdf2/</span><span class="s3">\n\n</span><span class="s1">export function encryptWithSecret(secret: Buffer, data: string): string {</span><span class="s3">\n  </span><span class="s1">const iv = crypto.randomBytes(CIPHER_IV_LENGTH)</span><span class="s3">\n  </span><span class="s1">const salt = crypto.randomBytes(CIPHER_SALT_LENGTH)</span><span class="s3">\n\n  </span><span class="s1">// https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest</span><span class="s3">\n  </span><span class="s1">const key = crypto.pbkdf2Sync(</span><span class="s3">\n    </span><span class="s1">secret,</span><span class="s3">\n    </span><span class="s1">salt,</span><span class="s3">\n    </span><span class="s1">PBKDF2_ITERATIONS,</span><span class="s3">\n    </span><span class="s1">CIPHER_KEY_LENGTH,</span><span class="s3">\n    </span><span class="s1">`sha512`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const cipher = crypto.createCipheriv(CIPHER_ALGORITHM, key, iv)</span><span class="s3">\n  </span><span class="s1">const encrypted = Buffer.concat([cipher.update(data, `utf8`), cipher.final()])</span><span class="s3">\n\n  </span><span class="s1">// https://nodejs.org/api/crypto.html#crypto_cipher_getauthtag</span><span class="s3">\n  </span><span class="s1">const tag = cipher.getAuthTag()</span><span class="s3">\n\n  </span><span class="s1">return Buffer.concat([</span><span class="s3">\n    </span><span class="s1">// Data as required by:</span><span class="s3">\n    </span><span class="s1">// Salt for Key: https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest</span><span class="s3">\n    </span><span class="s1">// IV: https://nodejs.org/api/crypto.html#crypto_class_decipher</span><span class="s3">\n    </span><span class="s1">// Tag: https://nodejs.org/api/crypto.html#crypto_decipher_setauthtag_buffer</span><span class="s3">\n    </span><span class="s1">salt,</span><span class="s3">\n    </span><span class="s1">iv,</span><span class="s3">\n    </span><span class="s1">tag,</span><span class="s3">\n    </span><span class="s1">encrypted,</span><span class="s3">\n  </span><span class="s1">]).toString(`hex`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function decryptWithSecret(</span><span class="s3">\n  </span><span class="s1">secret: Buffer,</span><span class="s3">\n  </span><span class="s1">encryptedData: string</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const buffer = Buffer.from(encryptedData, `hex`)</span><span class="s3">\n\n  </span><span class="s1">const salt = buffer.slice(0, CIPHER_SALT_LENGTH)</span><span class="s3">\n  </span><span class="s1">const iv = buffer.slice(</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH,</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const tag = buffer.slice(</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH,</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const encrypted = buffer.slice(</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest</span><span class="s3">\n  </span><span class="s1">const key = crypto.pbkdf2Sync(</span><span class="s3">\n    </span><span class="s1">secret,</span><span class="s3">\n    </span><span class="s1">salt,</span><span class="s3">\n    </span><span class="s1">PBKDF2_ITERATIONS,</span><span class="s3">\n    </span><span class="s1">CIPHER_KEY_LENGTH,</span><span class="s3">\n    </span><span class="s1">`sha512`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const decipher = crypto.createDecipheriv(CIPHER_ALGORITHM, key, iv)</span><span class="s3">\n  </span><span class="s1">decipher.setAuthTag(tag)</span><span class="s3">\n\n  </span><span class="s1">return decipher.update(encrypted) + decipher.final(`utf8`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { CacheFs } from '../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">import fs from 'fs'</span><span class="s3">\n\n</span><span class="s1">export const nodeFs: CacheFs = {</span><span class="s3">\n  </span><span class="s1">existsSync: fs.existsSync,</span><span class="s3">\n  </span><span class="s1">readFile: fs.promises.readFile,</span><span class="s3">\n  </span><span class="s1">readFileSync: fs.readFileSync,</span><span class="s3">\n  </span><span class="s1">writeFile: (f, d) =&gt; fs.promises.writeFile(f, d),</span><span class="s3">\n  </span><span class="s1">mkdir: (dir) =&gt; fs.promises.mkdir(dir, { recursive: true }),</span><span class="s3">\n  </span><span class="s1">stat: (f) =&gt; fs.promises.stat(f),</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingHttpHeaders } from 'http'</span><span class="s3">\n\n</span><span class="s1">import { ReflectAdapter } from './reflect'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ReadonlyHeadersError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static callable() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyHeadersError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReadonlyHeaders = Headers &amp; {</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">append(...args: any[]): void</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">set(...args: any[]): void</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">delete(...args: any[]): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class HeadersAdapter extends Headers {</span><span class="s3">\n  </span><span class="s1">private readonly headers: IncomingHttpHeaders</span><span class="s3">\n\n  </span><span class="s1">constructor(headers: IncomingHttpHeaders) {</span><span class="s3">\n    </span><span class="s1">// We've already overridden the methods that would be called, so we're just</span><span class="s3">\n    </span><span class="s1">// calling the super constructor to ensure that the instanceof check works.</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n\n    </span><span class="s1">this.headers = new Proxy(headers, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">// Because this is just an object, we expect that all </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">operations</span><span class="s3">\n        </span><span class="s1">// are for properties. If it's a </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">for a symbol, we'll just return</span><span class="s3">\n        </span><span class="s1">// the symbol.</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') {</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return undefined.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, return the value.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, original, receiver)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">set(target, prop, value, receiver) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') {</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.set(target, prop, value, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, use the prop as the key.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.set(target, original ?? prop, value, receiver)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">has(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return false.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return false</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, return true.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.has(target, original)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">deleteProperty(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol')</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.deleteProperty(target, prop)</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return true.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return true</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, delete the property.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.deleteProperty(target, original)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Seals a Headers instance to prevent modification by throwing an error when</span><span class="s3">\n   </span><span class="s1">* any mutating method is called.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static seal(headers: Headers): ReadonlyHeaders {</span><span class="s3">\n    </span><span class="s1">return new Proxy&lt;ReadonlyHeaders&gt;(headers, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">switch (prop) {</span><span class="s3">\n          </span><span class="s1">case 'append':</span><span class="s3">\n          </span><span class="s1">case 'delete':</span><span class="s3">\n          </span><span class="s1">case 'set':</span><span class="s3">\n            </span><span class="s1">return ReadonlyHeadersError.callable</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Merges a header value into a string. This stores multiple values as an</span><span class="s3">\n   </span><span class="s1">* array, so we need to merge them into a string.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param value a header value</span><span class="s3">\n   </span><span class="s1">* @returns a merged header value (a string)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private merge(value: string | string[]): string {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) return value.join(', ')</span><span class="s3">\n\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a Headers instance from a plain object or a Headers instance.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param headers a plain object or a Headers instance</span><span class="s3">\n   </span><span class="s1">* @returns a headers instance</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static from(headers: IncomingHttpHeaders | Headers): Headers {</span><span class="s3">\n    </span><span class="s1">if (headers instanceof Headers) return headers</span><span class="s3">\n\n    </span><span class="s1">return new HeadersAdapter(headers)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public append(name: string, value: string): void {</span><span class="s3">\n    </span><span class="s1">const existing = this.headers[name]</span><span class="s3">\n    </span><span class="s1">if (typeof existing === 'string') {</span><span class="s3">\n      </span><span class="s1">this.headers[name] = [existing, value]</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(existing)) {</span><span class="s3">\n      </span><span class="s1">existing.push(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.headers[name] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public delete(name: string): void {</span><span class="s3">\n    </span><span class="s1">delete this.headers[name]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get(name: string): string | null {</span><span class="s3">\n    </span><span class="s1">const value = this.headers[name]</span><span class="s3">\n    </span><span class="s1">if (typeof value !== 'undefined') return this.merge(value)</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public has(name: string): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.headers[name] !== 'undefined'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set(name: string, value: string): void {</span><span class="s3">\n    </span><span class="s1">this.headers[name] = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public forEach(</span><span class="s3">\n    </span><span class="s1">callbackfn: (value: string, name: string, parent: Headers) =&gt; void,</span><span class="s3">\n    </span><span class="s1">thisArg?: any</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">for (const [name, value] of this.entries()) {</span><span class="s3">\n      </span><span class="s1">callbackfn.call(thisArg, value, name, this)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *entries(): HeadersIterator&lt;[string, string]&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">const name = key.toLowerCase()</span><span class="s3">\n      </span><span class="s1">// We assert here that this is a string because we got it from the</span><span class="s3">\n      </span><span class="s1">// Object.keys() call above.</span><span class="s3">\n      </span><span class="s1">const value = this.get(name) as string</span><span class="s3">\n\n      </span><span class="s1">yield [name, value] as [string, string]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *keys(): HeadersIterator&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">const name = key.toLowerCase()</span><span class="s3">\n      </span><span class="s1">yield name</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *values(): HeadersIterator&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">// We assert here that this is a string because we got it from the</span><span class="s3">\n      </span><span class="s1">// Object.keys() call above.</span><span class="s3">\n      </span><span class="s1">const value = this.get(key) as string</span><span class="s3">\n\n      </span><span class="s1">yield value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public [Symbol.iterator](): HeadersIterator&lt;[string, string]&gt; {</span><span class="s3">\n    </span><span class="s1">return this.entries()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class ReflectAdapter {</span><span class="s3">\n  </span><span class="s1">static get&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">receiver: unknown</span><span class="s3">\n  </span><span class="s1">): any {</span><span class="s3">\n    </span><span class="s1">const value = Reflect.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'function') {</span><span class="s3">\n      </span><span class="s1">return value.bind(target)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static set&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">value: any,</span><span class="s3">\n    </span><span class="s1">receiver: any</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.set(target, prop, value, receiver)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static has&lt;T extends object&gt;(target: T, prop: string | symbol): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.has(target, prop)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static deleteProperty&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.deleteProperty(target, prop)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This module is for next.js server internal usage of path module.</span><span class="s3">\n </span><span class="s1">* It will use native path module for nodejs runtime.</span><span class="s3">\n </span><span class="s1">* It will use path-browserify polyfill for edge runtime.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let path</span><span class="s3">\n\n</span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n  </span><span class="s1">path = require('next/dist/compiled/path-browserify')</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">path = require('path')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = path</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Note: This file is JS because it's used by the taskfile-swc.js file, which is JS.</span><span class="s3">\n</span><span class="s1">// Keep file changes in sync with the corresponding `.d.ts` files.</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* These are the browser versions that support all of the following:</span><span class="s3">\n </span><span class="s1">* static import: https://caniuse.com/es6-module</span><span class="s3">\n </span><span class="s1">* dynamic import: https://caniuse.com/es6-module-dynamic-import</span><span class="s3">\n </span><span class="s1">* import.meta: https://caniuse.com/mdn-javascript_operators_import_meta</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MODERN_BROWSERSLIST_TARGET = [</span><span class="s3">\n  </span><span class="s1">'chrome 64',</span><span class="s3">\n  </span><span class="s1">'edge 79',</span><span class="s3">\n  </span><span class="s1">'firefox 67',</span><span class="s3">\n  </span><span class="s1">'opera 51',</span><span class="s3">\n  </span><span class="s1">'safari 12',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">module.exports = MODERN_BROWSERSLIST_TARGET</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{var e={318:function(e,t){(function(e,n){true?n(t):0})(this,(function(e){</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;class StructError extends TypeError{constructor(e,t){let n;const{message:r,explanation:i,...c}=e;const{path:o}=e;const a=o.length===0?r:`At path: ${o.join(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)} -- ${r}`;super(i??a);if(i!=null)this.cause=a;Object.assign(this,c);this.name=this.constructor.name;this.failures=()=&gt;n??(n=[e,...t()])}}function isIterable(e){return isObject(e)&amp;&amp;typeof e[Symbol.iterator]===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">}function isObject(e){return typeof e===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;e!=null}function isPlainObject(e){if(Object.prototype.toString.call(e)!==</span><span class="s3">\&quot;</span><span class="s1">[object Object]</span><span class="s3">\&quot;</span><span class="s1">){return false}const t=Object.getPrototypeOf(e);return t===null||t===Object.prototype}function print(e){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot;</span><span class="s1">){return e.toString()}return typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?JSON.stringify(e):`${e}`}function shiftIterator(e){const{done:t,value:n}=e.next();return t?undefined:n}function toFailure(e,t,n,r){if(e===true){return}else if(e===false){e={}}else if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){e={message:e}}const{path:i,branch:c}=t;const{type:o}=n;const{refinement:a,message:s=`Expected a value of type </span><span class="s3">\\</span><span class="s1">`${o}</span><span class="s3">\\</span><span class="s1">`${a?` with refinement </span><span class="s3">\\</span><span class="s1">`${a}</span><span class="s3">\\</span><span class="s1">``:</span><span class="s3">\&quot;\&quot;</span><span class="s1">}, but received: </span><span class="s3">\\</span><span class="s1">`${print(r)}</span><span class="s3">\\</span><span class="s1">``}=e;return{value:r,type:o,refinement:a,key:i[i.length-1],path:i,branch:c,...e,message:s}}function*toFailures(e,t,n,r){if(!isIterable(e)){e=[e]}for(const i of e){const e=toFailure(i,t,n,r);if(e){yield e}}}function*run(e,t,n={}){const{path:r=[],branch:i=[e],coerce:c=false,mask:o=false}=n;const a={path:r,branch:i};if(c){e=t.coercer(e,a);if(o&amp;&amp;t.type!==</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;isObject(t.schema)&amp;&amp;isObject(e)&amp;&amp;!Array.isArray(e)){for(const n in e){if(t.schema[n]===undefined){delete e[n]}}}}let s=</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">;for(const r of t.validator(e,a)){r.explanation=n.message;s=</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">;yield[r,undefined]}for(let[u,f,l]of t.entries(e,a)){const t=run(f,l,{path:u===undefined?r:[...r,u],branch:u===undefined?i:[...i,f],coerce:c,mask:o,message:n.message});for(const n of t){if(n[0]){s=n[0].refinement!=null?</span><span class="s3">\&quot;</span><span class="s1">not_refined</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">;yield[n[0],undefined]}else if(c){f=n[1];if(u===undefined){e=f}else if(e instanceof Map){e.set(u,f)}else if(e instanceof Set){e.add(f)}else if(isObject(e)){if(f!==undefined||u in e)e[u]=f}}}}if(s!==</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">){for(const r of t.refiner(e,a)){r.explanation=n.message;s=</span><span class="s3">\&quot;</span><span class="s1">not_refined</span><span class="s3">\&quot;</span><span class="s1">;yield[r,undefined]}}if(s===</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">){yield[undefined,e]}}class Struct{constructor(e){const{type:t,schema:n,validator:r,refiner:i,coercer:c=(e=&gt;e),entries:o=function*(){}}=e;this.type=t;this.schema=n;this.entries=o;this.coercer=c;if(r){this.validator=(e,t)=&gt;{const n=r(e,t);return toFailures(n,t,this,e)}}else{this.validator=()=&gt;[]}if(i){this.refiner=(e,t)=&gt;{const n=i(e,t);return toFailures(n,t,this,e)}}else{this.refiner=()=&gt;[]}}assert(e,t){return assert(e,this,t)}create(e,t){return create(e,this,t)}is(e){return is(e,this)}mask(e,t){return mask(e,this,t)}validate(e,t={}){return validate(e,this,t)}}function assert(e,t,n){const r=validate(e,t,{message:n});if(r[0]){throw r[0]}}function create(e,t,n){const r=validate(e,t,{coerce:true,message:n});if(r[0]){throw r[0]}else{return r[1]}}function mask(e,t,n){const r=validate(e,t,{coerce:true,mask:true,message:n});if(r[0]){throw r[0]}else{return r[1]}}function is(e,t){const n=validate(e,t);return!n[0]}function validate(e,t,n={}){const r=run(e,t,n);const i=shiftIterator(r);if(i[0]){const e=new StructError(i[0],(function*(){for(const e of r){if(e[0]){yield e[0]}}}));return[e,undefined]}else{const e=i[1];return[undefined,e]}}function assign(...e){const t=e[0].type===</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">;const n=e.map((e=&gt;e.schema));const r=Object.assign({},...n);return t?type(r):object(r)}function define(e,t){return new Struct({type:e,schema:null,validator:t})}function deprecated(e,t){return new Struct({...e,refiner:(t,n)=&gt;t===undefined||e.refiner(t,n),validator(n,r){if(n===undefined){return true}else{t(n,r);return e.validator(n,r)}}})}function dynamic(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">dynamic</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t,n){const r=e(t,n);yield*r.entries(t,n)},validator(t,n){const r=e(t,n);return r.validator(t,n)},coercer(t,n){const r=e(t,n);return r.coercer(t,n)},refiner(t,n){const r=e(t,n);return r.refiner(t,n)}})}function lazy(e){let t;return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">lazy</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n,r){t??(t=e());yield*t.entries(n,r)},validator(n,r){t??(t=e());return t.validator(n,r)},coercer(n,r){t??(t=e());return t.coercer(n,r)},refiner(n,r){t??(t=e());return t.refiner(n,r)}})}function omit(e,t){const{schema:n}=e;const r={...n};for(const e of t){delete r[e]}switch(e.type){case</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:return type(r);default:return object(r)}}function partial(e){const t=e instanceof Struct?{...e.schema}:{...e};for(const e in t){t[e]=optional(t[e])}return object(t)}function pick(e,t){const{schema:n}=e;const r={};for(const e of t){r[e]=n[e]}return object(r)}function struct(e,t){console.warn(</span><span class="s3">\&quot;</span><span class="s1">superstruct@0.11 - The `struct` helper has been renamed to `define`.</span><span class="s3">\&quot;</span><span class="s1">);return define(e,t)}function any(){return define(</span><span class="s3">\&quot;</span><span class="s1">any</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;true))}function array(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,schema:e,*entries(t){if(e&amp;&amp;Array.isArray(t)){for(const[n,r]of t.entries()){yield[n,r,e]}}},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${print(e)}`}})}function bigint(){return define(</span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">))}function boolean(){return define(</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">))}function date(){return define(</span><span class="s3">\&quot;</span><span class="s1">date</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;e instanceof Date&amp;&amp;!isNaN(e.getTime())||`Expected a valid </span><span class="s3">\\</span><span class="s1">`Date</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`))}function enums(e){const t={};const n=e.map((e=&gt;print(e))).join();for(const n of e){t[n]=n}return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">enums</span><span class="s3">\&quot;</span><span class="s1">,schema:t,validator(t){return e.includes(t)||`Expected one of </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(t)}`}})}function func(){return define(</span><span class="s3">\&quot;</span><span class="s1">func</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">||`Expected a function, but received: ${print(e)}`))}function instance(e){return define(</span><span class="s3">\&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;t instanceof e||`Expected a </span><span class="s3">\\</span><span class="s1">`${e.name}</span><span class="s3">\\</span><span class="s1">` instance, but received: ${print(t)}`))}function integer(){return define(</span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;!isNaN(e)&amp;&amp;Number.isInteger(e)||`Expected an integer, but received: ${print(e)}`))}function intersection(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">intersection</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t,n){for(const r of e){yield*r.entries(t,n)}},*validator(t,n){for(const r of e){yield*r.validator(t,n)}},*refiner(t,n){for(const r of e){yield*r.refiner(t,n)}}})}function literal(e){const t=print(e);const n=typeof e;return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">literal</span><span class="s3">\&quot;</span><span class="s1">,schema:n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||n===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||n===</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">?e:null,validator(n){return n===e||`Expected the literal </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(n)}`}})}function map(e,t){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">map</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(e&amp;&amp;t&amp;&amp;n instanceof Map){for(const[r,i]of n.entries()){yield[r,r,e];yield[r,i,t]}}},coercer(e){return e instanceof Map?new Map(e):e},validator(e){return e instanceof Map||`Expected a </span><span class="s3">\\</span><span class="s1">`Map</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`}})}function never(){return define(</span><span class="s3">\&quot;</span><span class="s1">never</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;false))}function nullable(e){return new Struct({...e,validator:(t,n)=&gt;t===null||e.validator(t,n),refiner:(t,n)=&gt;t===null||e.refiner(t,n)})}function number(){return define(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;!isNaN(e)||`Expected a number, but received: ${print(e)}`))}function object(e){const t=e?Object.keys(e):[];const n=never();return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,schema:e?e:null,*entries(r){if(e&amp;&amp;isObject(r)){const i=new Set(Object.keys(r));for(const n of t){i.delete(n);yield[n,r[n],e[n]]}for(const e of i){yield[e,r[e],n]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`},coercer(e){return isObject(e)?{...e}:e}})}function optional(e){return new Struct({...e,validator:(t,n)=&gt;t===undefined||e.validator(t,n),refiner:(t,n)=&gt;t===undefined||e.refiner(t,n)})}function record(e,t){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">record</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(isObject(n)){for(const r in n){const i=n[r];yield[r,r,e];yield[r,i,t]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`}})}function regexp(){return define(</span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;e instanceof RegExp))}function set(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t){if(e&amp;&amp;t instanceof Set){for(const n of t){yield[n,n,e]}}},coercer(e){return e instanceof Set?new Set(e):e},validator(e){return e instanceof Set||`Expected a </span><span class="s3">\\</span><span class="s1">`Set</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`}})}function string(){return define(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||`Expected a string, but received: ${print(e)}`))}function tuple(e){const t=never();return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">tuple</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(Array.isArray(n)){const r=Math.max(e.length,n.length);for(let i=0;i&lt;r;i++){yield[i,n[i],e[i]||t]}}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${print(e)}`}})}function type(e){const t=Object.keys(e);return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">,schema:e,*entries(n){if(isObject(n)){for(const r of t){yield[r,n[r],e[r]]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`},coercer(e){return isObject(e)?{...e}:e}})}function union(e){const t=e.map((e=&gt;e.type)).join(</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">);return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">union</span><span class="s3">\&quot;</span><span class="s1">,schema:null,coercer(t){for(const n of e){const[e,r]=n.validate(t,{coerce:true});if(!e){return r}}return t},validator(n,r){const i=[];for(const t of e){const[...e]=run(n,t,r);const[c]=e;if(!c[0]){return[]}else{for(const[t]of e){if(t){i.push(t)}}}}return[`Expected the value to satisfy a union of </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(n)}`,...i]}})}function unknown(){return define(</span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;true))}function coerce(e,t,n){return new Struct({...e,coercer:(r,i)=&gt;is(r,t)?e.coercer(n(r,i),i):e.coercer(r,i)})}function defaulted(e,t,n={}){return coerce(e,unknown(),(e=&gt;{const r=typeof t===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">?t():t;if(e===undefined){return r}if(!n.strict&amp;&amp;isPlainObject(e)&amp;&amp;isPlainObject(r)){const t={...e};let n=false;for(const e in r){if(t[e]===undefined){t[e]=r[e];n=true}}if(n){return t}}return e}))}function trimmed(e){return coerce(e,string(),(e=&gt;e.trim()))}function empty(e){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">empty</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;{const n=getSize(t);return n===0||`Expected an empty ${e.type} but received one with a size of </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``}))}function getSize(e){if(e instanceof Map||e instanceof Set){return e.size}else{return e.length}}function max(e,t,n={}){const{exclusive:r}=n;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">max</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;r?n&lt;t:n&lt;=t||`Expected a ${e.type} less than ${r?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">or equal to </span><span class="s3">\&quot;</span><span class="s1">}${t} but received </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``))}function min(e,t,n={}){const{exclusive:r}=n;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">min</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;r?n&gt;t:n&gt;=t||`Expected a ${e.type} greater than ${r?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">or equal to </span><span class="s3">\&quot;</span><span class="s1">}${t} but received </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``))}function nonempty(e){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">nonempty</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;{const n=getSize(t);return n&gt;0||`Expected a nonempty ${e.type} but received an empty one`}))}function pattern(e,t){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;t.test(n)||`Expected a ${e.type} matching </span><span class="s3">\\</span><span class="s1">`/${t.source}/</span><span class="s3">\\</span><span class="s1">` but received </span><span class="s3">\&quot;</span><span class="s1">${n}</span><span class="s3">\&quot;</span><span class="s1">`))}function size(e,t,n=t){const r=`Expected a ${e.type}`;const i=t===n?`of </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">``:`between </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">` and </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;{if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||e instanceof Date){return t&lt;=e&amp;&amp;e&lt;=n||`${r} ${i} but received </span><span class="s3">\\</span><span class="s1">`${e}</span><span class="s3">\\</span><span class="s1">``}else if(e instanceof Map||e instanceof Set){const{size:c}=e;return t&lt;=c&amp;&amp;c&lt;=n||`${r} with a size ${i} but received one with a size of </span><span class="s3">\\</span><span class="s1">`${c}</span><span class="s3">\\</span><span class="s1">``}else{const{length:c}=e;return t&lt;=c&amp;&amp;c&lt;=n||`${r} with a length ${i} but received one with a length of </span><span class="s3">\\</span><span class="s1">`${c}</span><span class="s3">\\</span><span class="s1">``}}))}function refine(e,t,n){return new Struct({...e,*refiner(r,i){yield*e.refiner(r,i);const c=n(r,i);const o=toFailures(c,i,e,r);for(const e of o){yield{...e,refinement:t}}}})}e.Struct=Struct;e.StructError=StructError;e.any=any;e.array=array;e.assert=assert;e.assign=assign;e.bigint=bigint;e.boolean=boolean;e.coerce=coerce;e.create=create;e.date=date;e.defaulted=defaulted;e.define=define;e.deprecated=deprecated;e.dynamic=dynamic;e.empty=empty;e.enums=enums;e.func=func;e.instance=instance;e.integer=integer;e.intersection=intersection;e.is=is;e.lazy=lazy;e.literal=literal;e.map=map;e.mask=mask;e.max=max;e.min=min;e.never=never;e.nonempty=nonempty;e.nullable=nullable;e.number=number;e.object=object;e.omit=omit;e.optional=optional;e.partial=partial;e.pattern=pattern;e.pick=pick;e.record=record;e.refine=refine;e.regexp=regexp;e.set=set;e.size=size;e.string=string;e.struct=struct;e.trimmed=trimmed;e.tuple=tuple;e.type=type;e.union=union;e.unknown=unknown;e.validate=validate}))}};if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var t={};e[318](0,t);module.exports=t})();&quot;</span><span class="s0">,</span><span class="s1">&quot;// getDefaultExport function for compatibility with non-ESM modules</span><span class="s3">\n</span><span class="s1">__webpack_require__.n = (module) =&gt; {</span><span class="s3">\n\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n\t\t</span><span class="s1">() =&gt; (module['default']) :</span><span class="s3">\n\t\t</span><span class="s1">() =&gt; (module);</span><span class="s3">\n\t</span><span class="s1">__webpack_require__.d(getter, { a: getter });</span><span class="s3">\n\t</span><span class="s1">return getter;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var getProto = Object.getPrototypeOf ? (obj) =&gt; (Object.getPrototypeOf(obj)) : (obj) =&gt; (obj.__proto__);</span><span class="s3">\n</span><span class="s1">var leafPrototypes;</span><span class="s3">\n</span><span class="s1">// create a fake namespace object</span><span class="s3">\n</span><span class="s1">// mode &amp; 1: value is a module id, require it</span><span class="s3">\n</span><span class="s1">// mode &amp; 2: merge all properties of value into the ns</span><span class="s3">\n</span><span class="s1">// mode &amp; 4: return value when already ns object</span><span class="s3">\n</span><span class="s1">// mode &amp; 16: return value when it's Promise-like</span><span class="s3">\n</span><span class="s1">// mode &amp; 8|1: behave like require</span><span class="s3">\n</span><span class="s1">__webpack_require__.t = function(value, mode) {</span><span class="s3">\n\t</span><span class="s1">if(mode &amp; 1) value = this(value);</span><span class="s3">\n\t</span><span class="s1">if(mode &amp; 8) return value;</span><span class="s3">\n\t</span><span class="s1">if(typeof value === 'object' &amp;&amp; value) {</span><span class="s3">\n\t\t</span><span class="s1">if((mode &amp; 4) &amp;&amp; value.__esModule) return value;</span><span class="s3">\n\t\t</span><span class="s1">if((mode &amp; 16) &amp;&amp; typeof value.then === 'function') return value;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">var ns = Object.create(null);</span><span class="s3">\n  </span><span class="s1">__webpack_require__.r(ns);</span><span class="s3">\n\t</span><span class="s1">var def = {};</span><span class="s3">\n\t</span><span class="s1">leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];</span><span class="s3">\n\t</span><span class="s1">for(var current = mode &amp; 2 &amp;&amp; value; typeof current == 'object' &amp;&amp; !~leafPrototypes.indexOf(current); current = getProto(current)) {</span><span class="s3">\n\t\t</span><span class="s1">Object.getOwnPropertyNames(current).forEach((key) =&gt; { def[key] = () =&gt; (value[key]) });</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">def['default'] = () =&gt; (value);</span><span class="s3">\n\t</span><span class="s1">__webpack_require__.d(ns, def);</span><span class="s3">\n\t</span><span class="s1">return ns;</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__.d = (exports, definition) =&gt; {</span><span class="s3">\n\t</span><span class="s1">for(var key in definition) {</span><span class="s3">\n        </span><span class="s1">if(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) {</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__.o = (obj, prop) =&gt; (Object.prototype.hasOwnProperty.call(obj, prop))&quot;</span><span class="s0">,</span><span class="s1">&quot;// define __esModule on exports</span><span class="s3">\n</span><span class="s1">__webpack_require__.r = (exports) =&gt; {</span><span class="s3">\n\t</span><span class="s1">if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {</span><span class="s3">\n\t\t</span><span class="s1">Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">Object.defineProperty(exports, '__esModule', { value: true });</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;const noop = () =&gt; {}</span><span class="s3">\n\n</span><span class="s1">let registry: FinalizationRegistry&lt;WeakRef&lt;ReadableStream&gt;&gt; | undefined</span><span class="s3">\n\n</span><span class="s1">if (globalThis.FinalizationRegistry) {</span><span class="s3">\n  </span><span class="s1">registry = new FinalizationRegistry((weakRef: WeakRef&lt;ReadableStream&gt;) =&gt; {</span><span class="s3">\n    </span><span class="s1">const stream = weakRef.deref()</span><span class="s3">\n    </span><span class="s1">if (stream &amp;&amp; !stream.locked) {</span><span class="s3">\n      </span><span class="s1">stream.cancel('Response object has been garbage collected').then(noop)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Clones a response by teeing the body so we can return two independent</span><span class="s3">\n </span><span class="s1">* ReadableStreams from it. This avoids the bug in the undici library around</span><span class="s3">\n </span><span class="s1">* response cloning.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* After cloning, the original response's body will be consumed and closed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @see https://github.com/vercel/next.js/pull/73274</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param original - The original response to clone.</span><span class="s3">\n </span><span class="s1">* @returns A tuple containing two independent clones of the original response.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function cloneResponse(original: Response): [Response, Response] {</span><span class="s3">\n  </span><span class="s1">// If the response has no body, then we can just return the original response</span><span class="s3">\n  </span><span class="s1">// twice because it's immutable.</span><span class="s3">\n  </span><span class="s1">if (!original.body) {</span><span class="s3">\n    </span><span class="s1">return [original, original]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const [body1, body2] = original.body.tee()</span><span class="s3">\n\n  </span><span class="s1">const cloned1 = new Response(body1, {</span><span class="s3">\n    </span><span class="s1">status: original.status,</span><span class="s3">\n    </span><span class="s1">statusText: original.statusText,</span><span class="s3">\n    </span><span class="s1">headers: original.headers,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(cloned1, 'url', {</span><span class="s3">\n    </span><span class="s1">value: original.url,</span><span class="s3">\n    </span><span class="s1">// How the original response.url behaves</span><span class="s3">\n    </span><span class="s1">configurable: true,</span><span class="s3">\n    </span><span class="s1">enumerable: true,</span><span class="s3">\n    </span><span class="s1">writable: false,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// The Fetch Standard allows users to skip consuming the response body by</span><span class="s3">\n  </span><span class="s1">// relying on garbage collection to release connection resources.</span><span class="s3">\n  </span><span class="s1">// https://github.com/nodejs/undici?tab=readme-ov-file#garbage-collection</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// To cancel the stream you then need to cancel both resulting branches.</span><span class="s3">\n  </span><span class="s1">// Teeing a stream will generally lock it for the duration, preventing other</span><span class="s3">\n  </span><span class="s1">// readers from locking it.</span><span class="s3">\n  </span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/tee</span><span class="s3">\n\n  </span><span class="s1">// cloned2 is stored in a react cache and cloned for subsequent requests.</span><span class="s3">\n  </span><span class="s1">// It is the original request, and is is garbage collected by a</span><span class="s3">\n  </span><span class="s1">// FinalizationRegistry in Undici, but since we're tee-ing the stream</span><span class="s3">\n  </span><span class="s1">// ourselves, we need to cancel clone1's stream (the response returned from</span><span class="s3">\n  </span><span class="s1">// our dedupe fetch) when clone1 is reclaimed, otherwise we leak memory.</span><span class="s3">\n  </span><span class="s1">if (registry &amp;&amp; cloned1.body) {</span><span class="s3">\n    </span><span class="s1">registry.register(cloned1, new WeakRef(cloned1.body))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const cloned2 = new Response(body2, {</span><span class="s3">\n    </span><span class="s1">status: original.status,</span><span class="s3">\n    </span><span class="s1">statusText: original.statusText,</span><span class="s3">\n    </span><span class="s1">headers: original.headers,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(cloned2, 'url', {</span><span class="s3">\n    </span><span class="s1">value: original.url,</span><span class="s3">\n    </span><span class="s1">// How the original response.url behaves</span><span class="s3">\n    </span><span class="s1">configurable: true,</span><span class="s3">\n    </span><span class="s1">enumerable: true,</span><span class="s3">\n    </span><span class="s1">writable: false,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return [cloned1, cloned2]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// ISC License</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) 2021 Alexey Raspopov, Kostiantyn Denysov, Anton Verinov</span><span class="s3">\n\n</span><span class="s1">// Permission to use, copy, modify, and/or distribute this software for any</span><span class="s3">\n</span><span class="s1">// purpose with or without fee is hereby granted, provided that the above</span><span class="s3">\n</span><span class="s1">// copyright notice and this permission notice appear in all copies.</span><span class="s3">\n\n</span><span class="s1">// THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot; </span><span class="s1">AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span><span class="s3">\n</span><span class="s1">// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span><span class="s3">\n</span><span class="s1">// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span><span class="s3">\n</span><span class="s1">// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span><span class="s3">\n</span><span class="s1">// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span><span class="s3">\n</span><span class="s1">// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span><span class="s3">\n</span><span class="s1">// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// https://github.com/alexeyraspopov/picocolors/blob/b6261487e7b81aaab2440e397a356732cad9e342/picocolors.js#L1</span><span class="s3">\n\n</span><span class="s1">const { env, stdout } = globalThis?.process ?? {}</span><span class="s3">\n\n</span><span class="s1">const enabled =</span><span class="s3">\n  </span><span class="s1">env &amp;&amp;</span><span class="s3">\n  </span><span class="s1">!env.NO_COLOR &amp;&amp;</span><span class="s3">\n  </span><span class="s1">(env.FORCE_COLOR || (stdout?.isTTY &amp;&amp; !env.CI &amp;&amp; env.TERM !== 'dumb'))</span><span class="s3">\n\n</span><span class="s1">const replaceClose = (</span><span class="s3">\n  </span><span class="s1">str: string,</span><span class="s3">\n  </span><span class="s1">close: string,</span><span class="s3">\n  </span><span class="s1">replace: string,</span><span class="s3">\n  </span><span class="s1">index: number</span><span class="s3">\n</span><span class="s1">): string =&gt; {</span><span class="s3">\n  </span><span class="s1">const start = str.substring(0, index) + replace</span><span class="s3">\n  </span><span class="s1">const end = str.substring(index + close.length)</span><span class="s3">\n  </span><span class="s1">const nextIndex = end.indexOf(close)</span><span class="s3">\n  </span><span class="s1">return ~nextIndex</span><span class="s3">\n    </span><span class="s1">? start + replaceClose(end, close, replace, nextIndex)</span><span class="s3">\n    </span><span class="s1">: start + end</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const formatter = (open: string, close: string, replace = open) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!enabled) return String</span><span class="s3">\n  </span><span class="s1">return (input: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const string = '' + input</span><span class="s3">\n    </span><span class="s1">const index = string.indexOf(close, open.length)</span><span class="s3">\n    </span><span class="s1">return ~index</span><span class="s3">\n      </span><span class="s1">? open + replaceClose(string, close, replace, index) + close</span><span class="s3">\n      </span><span class="s1">: open + string + close</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const reset = enabled ? (s: string) =&gt; `</span><span class="s3">\\</span><span class="s1">x1b[0m${s}</span><span class="s3">\\</span><span class="s1">x1b[0m` : String</span><span class="s3">\n</span><span class="s1">export const bold = formatter('</span><span class="s3">\\</span><span class="s1">x1b[1m', '</span><span class="s3">\\</span><span class="s1">x1b[22m', '</span><span class="s3">\\</span><span class="s1">x1b[22m</span><span class="s3">\\</span><span class="s1">x1b[1m')</span><span class="s3">\n</span><span class="s1">export const dim = formatter('</span><span class="s3">\\</span><span class="s1">x1b[2m', '</span><span class="s3">\\</span><span class="s1">x1b[22m', '</span><span class="s3">\\</span><span class="s1">x1b[22m</span><span class="s3">\\</span><span class="s1">x1b[2m')</span><span class="s3">\n</span><span class="s1">export const italic = formatter('</span><span class="s3">\\</span><span class="s1">x1b[3m', '</span><span class="s3">\\</span><span class="s1">x1b[23m')</span><span class="s3">\n</span><span class="s1">export const underline = formatter('</span><span class="s3">\\</span><span class="s1">x1b[4m', '</span><span class="s3">\\</span><span class="s1">x1b[24m')</span><span class="s3">\n</span><span class="s1">export const inverse = formatter('</span><span class="s3">\\</span><span class="s1">x1b[7m', '</span><span class="s3">\\</span><span class="s1">x1b[27m')</span><span class="s3">\n</span><span class="s1">export const hidden = formatter('</span><span class="s3">\\</span><span class="s1">x1b[8m', '</span><span class="s3">\\</span><span class="s1">x1b[28m')</span><span class="s3">\n</span><span class="s1">export const strikethrough = formatter('</span><span class="s3">\\</span><span class="s1">x1b[9m', '</span><span class="s3">\\</span><span class="s1">x1b[29m')</span><span class="s3">\n</span><span class="s1">export const black = formatter('</span><span class="s3">\\</span><span class="s1">x1b[30m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const red = formatter('</span><span class="s3">\\</span><span class="s1">x1b[31m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const green = formatter('</span><span class="s3">\\</span><span class="s1">x1b[32m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const yellow = formatter('</span><span class="s3">\\</span><span class="s1">x1b[33m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const blue = formatter('</span><span class="s3">\\</span><span class="s1">x1b[34m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const magenta = formatter('</span><span class="s3">\\</span><span class="s1">x1b[35m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const purple = formatter('</span><span class="s3">\\</span><span class="s1">x1b[38;2;173;127;168m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const cyan = formatter('</span><span class="s3">\\</span><span class="s1">x1b[36m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const white = formatter('</span><span class="s3">\\</span><span class="s1">x1b[37m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const gray = formatter('</span><span class="s3">\\</span><span class="s1">x1b[90m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const bgBlack = formatter('</span><span class="s3">\\</span><span class="s1">x1b[40m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgRed = formatter('</span><span class="s3">\\</span><span class="s1">x1b[41m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgGreen = formatter('</span><span class="s3">\\</span><span class="s1">x1b[42m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgYellow = formatter('</span><span class="s3">\\</span><span class="s1">x1b[43m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgBlue = formatter('</span><span class="s3">\\</span><span class="s1">x1b[44m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgMagenta = formatter('</span><span class="s3">\\</span><span class="s1">x1b[45m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgCyan = formatter('</span><span class="s3">\\</span><span class="s1">x1b[46m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgWhite = formatter('</span><span class="s3">\\</span><span class="s1">x1b[47m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import MODERN_BROWSERSLIST_TARGET from './modern-browserslist-target'</span><span class="s3">\n\n</span><span class="s1">export { MODERN_BROWSERSLIST_TARGET }</span><span class="s3">\n\n</span><span class="s1">export type ValueOf&lt;T&gt; = Required&lt;T&gt;[keyof T]</span><span class="s3">\n\n</span><span class="s1">export const COMPILER_NAMES = {</span><span class="s3">\n  </span><span class="s1">client: 'client',</span><span class="s3">\n  </span><span class="s1">server: 'server',</span><span class="s3">\n  </span><span class="s1">edgeServer: 'edge-server',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export type CompilerNameValues = ValueOf&lt;typeof COMPILER_NAMES&gt;</span><span class="s3">\n\n</span><span class="s1">export enum AdapterOutputType {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES` represents all the React pages that are under `pages/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES_API` represents all the API routes under `pages/api/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES_API = 'PAGES_API',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_PAGE` represents all the React pages that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `page.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `route.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PRERENDER` represents an ISR enabled route that might</span><span class="s3">\n   </span><span class="s1">* have a seeded cache entry or fallback generated during build</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PRERENDER = 'PRERENDER',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `STATIC_FILE` represents a static file (ie /_next/static)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">STATIC_FILE = 'STATIC_FILE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `MIDDLEWARE` represents the middleware output if present</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">MIDDLEWARE = 'MIDDLEWARE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const COMPILER_INDEXES: {</span><span class="s3">\n  </span><span class="s1">[compilerKey in CompilerNameValues]: number</span><span class="s3">\n</span><span class="s1">} = {</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.client]: 0,</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.server]: 1,</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.edgeServer]: 2,</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export const UNDERSCORE_NOT_FOUND_ROUTE = '/_not-found'</span><span class="s3">\n</span><span class="s1">export const UNDERSCORE_NOT_FOUND_ROUTE_ENTRY = `${UNDERSCORE_NOT_FOUND_ROUTE}/page`</span><span class="s3">\n</span><span class="s1">export const PHASE_EXPORT = 'phase-export'</span><span class="s3">\n</span><span class="s1">export const PHASE_PRODUCTION_BUILD = 'phase-production-build'</span><span class="s3">\n</span><span class="s1">export const PHASE_PRODUCTION_SERVER = 'phase-production-server'</span><span class="s3">\n</span><span class="s1">export const PHASE_DEVELOPMENT_SERVER = 'phase-development-server'</span><span class="s3">\n</span><span class="s1">export const PHASE_TEST = 'phase-test'</span><span class="s3">\n</span><span class="s1">export const PHASE_INFO = 'phase-info'</span><span class="s3">\n</span><span class="s1">export const PAGES_MANIFEST = 'pages-manifest.json'</span><span class="s3">\n</span><span class="s1">export const WEBPACK_STATS = 'webpack-stats.json'</span><span class="s3">\n</span><span class="s1">export const APP_PATHS_MANIFEST = 'app-paths-manifest.json'</span><span class="s3">\n</span><span class="s1">export const APP_PATH_ROUTES_MANIFEST = 'app-path-routes-manifest.json'</span><span class="s3">\n</span><span class="s1">export const BUILD_MANIFEST = 'build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const APP_BUILD_MANIFEST = 'app-build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const FUNCTIONS_CONFIG_MANIFEST = 'functions-config-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SUBRESOURCE_INTEGRITY_MANIFEST = 'subresource-integrity-manifest'</span><span class="s3">\n</span><span class="s1">export const NEXT_FONT_MANIFEST = 'next-font-manifest'</span><span class="s3">\n</span><span class="s1">export const EXPORT_MARKER = 'export-marker.json'</span><span class="s3">\n</span><span class="s1">export const EXPORT_DETAIL = 'export-detail.json'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_MANIFEST = 'prerender-manifest.json'</span><span class="s3">\n</span><span class="s1">export const ROUTES_MANIFEST = 'routes-manifest.json'</span><span class="s3">\n</span><span class="s1">export const IMAGES_MANIFEST = 'images-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SERVER_FILES_MANIFEST = 'required-server-files.json'</span><span class="s3">\n</span><span class="s1">export const DEV_CLIENT_PAGES_MANIFEST = '_devPagesManifest.json'</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_MANIFEST = 'middleware-manifest.json'</span><span class="s3">\n</span><span class="s1">export const TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'_clientMiddlewareManifest.json'</span><span class="s3">\n</span><span class="s1">export const TURBOPACK_CLIENT_BUILD_MANIFEST = 'client-build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const DEV_CLIENT_MIDDLEWARE_MANIFEST = '_devMiddlewareManifest.json'</span><span class="s3">\n</span><span class="s1">export const REACT_LOADABLE_MANIFEST = 'react-loadable-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SERVER_DIRECTORY = 'server'</span><span class="s3">\n</span><span class="s1">export const CONFIG_FILES = [</span><span class="s3">\n  </span><span class="s1">'next.config.js',</span><span class="s3">\n  </span><span class="s1">'next.config.mjs',</span><span class="s3">\n  </span><span class="s1">'next.config.ts',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">export const BUILD_ID_FILE = 'BUILD_ID'</span><span class="s3">\n</span><span class="s1">export const BLOCKED_PAGES = ['/_document', '/_app', '/_error']</span><span class="s3">\n</span><span class="s1">export const CLIENT_PUBLIC_FILES_PATH = 'public'</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_PATH = 'static'</span><span class="s3">\n</span><span class="s1">export const STRING_LITERAL_DROP_BUNDLE = '__NEXT_DROP_CLIENT_FILE__'</span><span class="s3">\n</span><span class="s1">export const NEXT_BUILTIN_DOCUMENT = '__NEXT_BUILTIN_DOCUMENT__'</span><span class="s3">\n</span><span class="s1">export const BARREL_OPTIMIZATION_PREFIX = '__barrel_optimize__'</span><span class="s3">\n\n</span><span class="s1">// server/[entry]/page_client-reference-manifest.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_REFERENCE_MANIFEST = 'client-reference-manifest'</span><span class="s3">\n</span><span class="s1">// server/server-reference-manifest</span><span class="s3">\n</span><span class="s1">export const SERVER_REFERENCE_MANIFEST = 'server-reference-manifest'</span><span class="s3">\n</span><span class="s1">// server/middleware-build-manifest.js</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_BUILD_MANIFEST = 'middleware-build-manifest'</span><span class="s3">\n</span><span class="s1">// server/middleware-react-loadable-manifest.js</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_REACT_LOADABLE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'middleware-react-loadable-manifest'</span><span class="s3">\n</span><span class="s1">// server/interception-route-rewrite-manifest.js</span><span class="s3">\n</span><span class="s1">export const INTERCEPTION_ROUTE_REWRITE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'interception-route-rewrite-manifest'</span><span class="s3">\n</span><span class="s1">// server/dynamic-css-manifest.js</span><span class="s3">\n</span><span class="s1">export const DYNAMIC_CSS_MANIFEST = 'dynamic-css-manifest'</span><span class="s3">\n\n</span><span class="s1">// static/runtime/main.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_MAIN = `main`</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_MAIN_APP = `${CLIENT_STATIC_FILES_RUNTIME_MAIN}-app`</span><span class="s3">\n</span><span class="s1">// next internal client components chunk for layouts</span><span class="s3">\n</span><span class="s1">export const APP_CLIENT_INTERNALS = 'app-pages-internals'</span><span class="s3">\n</span><span class="s1">// static/runtime/react-refresh.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH = `react-refresh`</span><span class="s3">\n</span><span class="s1">// static/runtime/amp.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_AMP = `amp`</span><span class="s3">\n</span><span class="s1">// static/runtime/webpack.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_WEBPACK = `webpack`</span><span class="s3">\n</span><span class="s1">// static/runtime/polyfills.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_POLYFILLS = 'polyfills'</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL = Symbol(</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_POLYFILLS</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const DEFAULT_RUNTIME_WEBPACK = 'webpack-runtime'</span><span class="s3">\n</span><span class="s1">export const EDGE_RUNTIME_WEBPACK = 'edge-runtime-webpack'</span><span class="s3">\n</span><span class="s1">export const STATIC_PROPS_ID = '__N_SSG'</span><span class="s3">\n</span><span class="s1">export const SERVER_PROPS_ID = '__N_SSP'</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SERIF_FONT = {</span><span class="s3">\n  </span><span class="s1">name: 'Times New Roman',</span><span class="s3">\n  </span><span class="s1">xAvgCharWidth: 821,</span><span class="s3">\n  </span><span class="s1">azAvgWidth: 854.3953488372093,</span><span class="s3">\n  </span><span class="s1">unitsPerEm: 2048,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SANS_SERIF_FONT = {</span><span class="s3">\n  </span><span class="s1">name: 'Arial',</span><span class="s3">\n  </span><span class="s1">xAvgCharWidth: 904,</span><span class="s3">\n  </span><span class="s1">azAvgWidth: 934.5116279069767,</span><span class="s3">\n  </span><span class="s1">unitsPerEm: 2048,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const STATIC_STATUS_PAGES = ['/500']</span><span class="s3">\n</span><span class="s1">export const TRACE_OUTPUT_VERSION = 1</span><span class="s3">\n</span><span class="s1">// in `MB`</span><span class="s3">\n</span><span class="s1">export const TURBO_TRACE_DEFAULT_MEMORY_LIMIT = 6000</span><span class="s3">\n\n</span><span class="s1">export const RSC_MODULE_TYPES = {</span><span class="s3">\n  </span><span class="s1">client: 'client',</span><span class="s3">\n  </span><span class="s1">server: 'server',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">// comparing</span><span class="s3">\n</span><span class="s1">// https://nextjs.org/docs/api-reference/edge-runtime</span><span class="s3">\n</span><span class="s1">// with</span><span class="s3">\n</span><span class="s1">// https://nodejs.org/docs/latest/api/globals.html</span><span class="s3">\n</span><span class="s1">export const EDGE_UNSUPPORTED_NODE_APIS = [</span><span class="s3">\n  </span><span class="s1">'clearImmediate',</span><span class="s3">\n  </span><span class="s1">'setImmediate',</span><span class="s3">\n  </span><span class="s1">'BroadcastChannel',</span><span class="s3">\n  </span><span class="s1">'ByteLengthQueuingStrategy',</span><span class="s3">\n  </span><span class="s1">'CompressionStream',</span><span class="s3">\n  </span><span class="s1">'CountQueuingStrategy',</span><span class="s3">\n  </span><span class="s1">'DecompressionStream',</span><span class="s3">\n  </span><span class="s1">'DomException',</span><span class="s3">\n  </span><span class="s1">'MessageChannel',</span><span class="s3">\n  </span><span class="s1">'MessageEvent',</span><span class="s3">\n  </span><span class="s1">'MessagePort',</span><span class="s3">\n  </span><span class="s1">'ReadableByteStreamController',</span><span class="s3">\n  </span><span class="s1">'ReadableStreamBYOBRequest',</span><span class="s3">\n  </span><span class="s1">'ReadableStreamDefaultController',</span><span class="s3">\n  </span><span class="s1">'TransformStreamDefaultController',</span><span class="s3">\n  </span><span class="s1">'WritableStreamDefaultController',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export const SYSTEM_ENTRYPOINTS = new Set&lt;string&gt;([</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_MAIN,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_AMP,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_MAIN_APP,</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">const DUMMY_ORIGIN = 'http://n'</span><span class="s3">\n\n</span><span class="s1">export function isFullStringUrl(url: string) {</span><span class="s3">\n  </span><span class="s1">return /https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//.test(url)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseUrl(url: string): URL | undefined {</span><span class="s3">\n  </span><span class="s1">let parsed: URL | undefined = undefined</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">parsed = new URL(url, DUMMY_ORIGIN)</span><span class="s3">\n  </span><span class="s1">} catch {}</span><span class="s3">\n  </span><span class="s1">return parsed</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseReqUrl(url: string): UrlWithParsedQuery | undefined {</span><span class="s3">\n  </span><span class="s1">const parsedUrl: URL | undefined = parseUrl(url)</span><span class="s3">\n\n  </span><span class="s1">if (!parsedUrl) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const query: Record&lt;string, string | string[]&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const key of parsedUrl.searchParams.keys()) {</span><span class="s3">\n    </span><span class="s1">const values = parsedUrl.searchParams.getAll(key)</span><span class="s3">\n    </span><span class="s1">query[key] = values.length &gt; 1 ? values : values[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const legacyUrl: UrlWithParsedQuery = {</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">hash: parsedUrl.hash,</span><span class="s3">\n    </span><span class="s1">search: parsedUrl.search,</span><span class="s3">\n    </span><span class="s1">path: parsedUrl.pathname,</span><span class="s3">\n    </span><span class="s1">pathname: parsedUrl.pathname,</span><span class="s3">\n    </span><span class="s1">href: `${parsedUrl.pathname}${parsedUrl.search}${parsedUrl.hash}`,</span><span class="s3">\n    </span><span class="s1">host: '',</span><span class="s3">\n    </span><span class="s1">hostname: '',</span><span class="s3">\n    </span><span class="s1">auth: '',</span><span class="s3">\n    </span><span class="s1">protocol: '',</span><span class="s3">\n    </span><span class="s1">slashes: null,</span><span class="s3">\n    </span><span class="s1">port: '',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return legacyUrl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stripNextRscUnionQuery(relativeUrl: string): string {</span><span class="s3">\n  </span><span class="s1">const urlInstance = new URL(relativeUrl, DUMMY_ORIGIN)</span><span class="s3">\n  </span><span class="s1">urlInstance.searchParams.delete(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n\n  </span><span class="s1">return urlInstance.pathname + urlInstance.search</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export interface PathLocale {</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache of lowercased locales for each list of locales. This is stored as a</span><span class="s3">\n </span><span class="s1">* WeakMap so if the locales are garbage collected, the cache entry will be</span><span class="s3">\n </span><span class="s1">* removed as well.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cache = new WeakMap&lt;readonly string[], readonly string[]&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* For a pathname that may include a locale from a list of locales, it</span><span class="s3">\n </span><span class="s1">* removes the locale from the pathname returning it alongside with the</span><span class="s3">\n </span><span class="s1">* detected locale.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pathname A pathname that may include a locale.</span><span class="s3">\n </span><span class="s1">* @param locales A list of locales.</span><span class="s3">\n </span><span class="s1">* @returns The detected locale and pathname without locale</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeLocalePath(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n</span><span class="s1">): PathLocale {</span><span class="s3">\n  </span><span class="s1">// If locales is undefined, return the pathname as is.</span><span class="s3">\n  </span><span class="s1">if (!locales) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// Get the cached lowercased locales or create a new cache entry.</span><span class="s3">\n  </span><span class="s1">let lowercasedLocales = cache.get(locales)</span><span class="s3">\n  </span><span class="s1">if (!lowercasedLocales) {</span><span class="s3">\n    </span><span class="s1">lowercasedLocales = locales.map((locale) =&gt; locale.toLowerCase())</span><span class="s3">\n    </span><span class="s1">cache.set(locales, lowercasedLocales)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let detectedLocale: string | undefined</span><span class="s3">\n\n  </span><span class="s1">// The first segment will be empty, because it has a leading `/`. If</span><span class="s3">\n  </span><span class="s1">// there is no further segment, there is no locale (or it's the default).</span><span class="s3">\n  </span><span class="s1">const segments = pathname.split('/', 2)</span><span class="s3">\n\n  </span><span class="s1">// If there's no second segment (ie, the pathname is just `/`), there's no</span><span class="s3">\n  </span><span class="s1">// locale.</span><span class="s3">\n  </span><span class="s1">if (!segments[1]) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// The second segment will contain the locale part if any.</span><span class="s3">\n  </span><span class="s1">const segment = segments[1].toLowerCase()</span><span class="s3">\n\n  </span><span class="s1">// See if the segment matches one of the locales. If it doesn't, there is</span><span class="s3">\n  </span><span class="s1">// no locale (or it's the default).</span><span class="s3">\n  </span><span class="s1">const index = lowercasedLocales.indexOf(segment)</span><span class="s3">\n  </span><span class="s1">if (index &lt; 0) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// Return the case-sensitive locale.</span><span class="s3">\n  </span><span class="s1">detectedLocale = locales[index]</span><span class="s3">\n\n  </span><span class="s1">// Remove the `/${locale}` part of the pathname.</span><span class="s3">\n  </span><span class="s1">pathname = pathname.slice(detectedLocale.length + 1) || '/'</span><span class="s3">\n\n  </span><span class="s1">return { pathname, detectedLocale }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* For a given page path, this function ensures that there is a leading slash.</span><span class="s3">\n </span><span class="s1">* If there is not a leading slash, one is added, otherwise it is noop.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function ensureLeadingSlash(path: string) {</span><span class="s3">\n  </span><span class="s1">return path.startsWith('/') ? path : `/${path}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { isGroupSegment } from '../../segment'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes an app route so it represents the actual request path. Essentially</span><span class="s3">\n </span><span class="s1">* performing the following transformations:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/user/[id]/page` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/account/page` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/user/[id]/page` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/account/page` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/page` to `/`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/user/[id]/route` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/account/route` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/user/[id]/route` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/account/route` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/route` to `/`</span><span class="s3">\n </span><span class="s1">* - `/` to `/`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param route the app route to normalize</span><span class="s3">\n </span><span class="s1">* @returns the normalized pathname</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeAppPath(route: string) {</span><span class="s3">\n  </span><span class="s1">return ensureLeadingSlash(</span><span class="s3">\n    </span><span class="s1">route.split('/').reduce((pathname, segment, index, segments) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Empty segments are ignored.</span><span class="s3">\n      </span><span class="s1">if (!segment) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Groups are ignored.</span><span class="s3">\n      </span><span class="s1">if (isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Parallel segments are ignored.</span><span class="s3">\n      </span><span class="s1">if (segment[0] === '@') {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// The last segment (if it's a leaf) should be ignored.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(segment === 'page' || segment === 'route') &amp;&amp;</span><span class="s3">\n        </span><span class="s1">index === segments.length - 1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${pathname}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips the `.rsc` extension if it's in the pathname.</span><span class="s3">\n </span><span class="s1">* Since this function is used on full urls it checks `?` for searchParams handling.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeRscURL(url: string) {</span><span class="s3">\n  </span><span class="s1">return url.replace(</span><span class="s3">\n    </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.rsc($|</span><span class="s3">\\</span><span class="s1">?)/,</span><span class="s3">\n    </span><span class="s1">// $1 ensures `?` is preserved</span><span class="s3">\n    </span><span class="s1">'$1'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Segment } from '../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">export function isGroupSegment(segment: string) {</span><span class="s3">\n  </span><span class="s1">// Use array[0] for performant purpose</span><span class="s3">\n  </span><span class="s1">return segment[0] === '(' &amp;&amp; segment.endsWith(')')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isParallelRouteSegment(segment: string) {</span><span class="s3">\n  </span><span class="s1">return segment.startsWith('@') &amp;&amp; segment !== '@children'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function addSearchParamsIfPageSegment(</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">searchParams: Record&lt;string, string | string[] | undefined&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)</span><span class="s3">\n\n  </span><span class="s1">if (isPageSegment) {</span><span class="s3">\n    </span><span class="s1">const stringifiedQuery = JSON.stringify(searchParams)</span><span class="s3">\n    </span><span class="s1">return stringifiedQuery !== '{}'</span><span class="s3">\n      </span><span class="s1">? PAGE_SEGMENT_KEY + '?' + stringifiedQuery</span><span class="s3">\n      </span><span class="s1">: PAGE_SEGMENT_KEY</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const PAGE_SEGMENT_KEY = '__PAGE__'</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SEGMENT_KEY = '__DEFAULT__'</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizeAppPath } from './app-paths'</span><span class="s3">\n\n</span><span class="s1">// order matters here, the first match will be used</span><span class="s3">\n</span><span class="s1">export const INTERCEPTION_ROUTE_MARKERS = [</span><span class="s3">\n  </span><span class="s1">'(..)(..)',</span><span class="s3">\n  </span><span class="s1">'(.)',</span><span class="s3">\n  </span><span class="s1">'(..)',</span><span class="s3">\n  </span><span class="s1">'(...)',</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteAppPath(path: string): boolean {</span><span class="s3">\n  </span><span class="s1">// TODO-APP: add more serious validation</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">path</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n      </span><span class="s1">.find((segment) =&gt;</span><span class="s3">\n        </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n      </span><span class="s1">) !== undefined</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractInterceptionRouteInformation(path: string) {</span><span class="s3">\n  </span><span class="s1">let interceptingRoute: string | undefined,</span><span class="s3">\n    </span><span class="s1">marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,</span><span class="s3">\n    </span><span class="s1">interceptedRoute: string | undefined</span><span class="s3">\n\n  </span><span class="s1">for (const segment of path.split('/')) {</span><span class="s3">\n    </span><span class="s1">marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n    </span><span class="s1">if (marker) {</span><span class="s3">\n      </span><span class="s1">;[interceptingRoute, interceptedRoute] = path.split(marker, 2)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!interceptingRoute || !marker || !interceptedRoute) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid interception route: ${path}. Must be in the format /&lt;intercepting route&gt;/(..|...|..)(..)/&lt;intercepted route&gt;`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -&gt; /feed</span><span class="s3">\n\n  </span><span class="s1">switch (marker) {</span><span class="s3">\n    </span><span class="s1">case '(.)':</span><span class="s3">\n      </span><span class="s1">// (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = `/${interceptedRoute}`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = interceptingRoute + '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)':</span><span class="s3">\n      </span><span class="s1">// (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">interceptedRoute = interceptingRoute</span><span class="s3">\n        </span><span class="s1">.split('/')</span><span class="s3">\n        </span><span class="s1">.slice(0, -1)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(...)':</span><span class="s3">\n      </span><span class="s1">// (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route</span><span class="s3">\n      </span><span class="s1">interceptedRoute = '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)(..)':</span><span class="s3">\n      </span><span class="s1">// (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route</span><span class="s3">\n\n      </span><span class="s1">const splitInterceptingRoute = interceptingRoute.split('/')</span><span class="s3">\n      </span><span class="s1">if (splitInterceptingRoute.length &lt;= 2) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">interceptedRoute = splitInterceptingRoute</span><span class="s3">\n        </span><span class="s1">.slice(0, -2)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: unexpected marker')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { interceptingRoute, interceptedRoute }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from './interception-routes'</span><span class="s3">\n\n</span><span class="s1">// Identify /.*[param].*/ in route string</span><span class="s3">\n</span><span class="s1">const TEST_ROUTE = /</span><span class="s3">\\</span><span class="s1">/[^/]*</span><span class="s3">\\</span><span class="s1">[[^/]+</span><span class="s3">\\</span><span class="s1">][^/]*(?=</span><span class="s3">\\</span><span class="s1">/|$)/</span><span class="s3">\n\n</span><span class="s1">// Identify /[param]/ in route string</span><span class="s3">\n</span><span class="s1">const TEST_STRICT_ROUTE = /</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">[[^/]+</span><span class="s3">\\</span><span class="s1">](?=</span><span class="s3">\\</span><span class="s1">/|$)/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if a route is dynamic.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param route - The route to check.</span><span class="s3">\n </span><span class="s1">* @param strict - Whether to use strict mode which prohibits segments with prefixes/suffixes (default: true).</span><span class="s3">\n </span><span class="s1">* @returns Whether the route is dynamic.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isDynamicRoute(route: string, strict: boolean = true): boolean {</span><span class="s3">\n  </span><span class="s1">if (isInterceptionRouteAppPath(route)) {</span><span class="s3">\n    </span><span class="s1">route = extractInterceptionRouteInformation(route).interceptedRoute</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (strict) {</span><span class="s3">\n    </span><span class="s1">return TEST_STRICT_ROUTE.test(route)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return TEST_ROUTE.test(route)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Given a path this function will find the pathname, query and hash and return</span><span class="s3">\n </span><span class="s1">* them. This is useful to parse full paths on the client side.</span><span class="s3">\n </span><span class="s1">* @param path A path to parse e.g. /foo/bar?id=1#hash</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parsePath(path: string) {</span><span class="s3">\n  </span><span class="s1">const hashIndex = path.indexOf('#')</span><span class="s3">\n  </span><span class="s1">const queryIndex = path.indexOf('?')</span><span class="s3">\n  </span><span class="s1">const hasQuery = queryIndex &gt; -1 &amp;&amp; (hashIndex &lt; 0 || queryIndex &lt; hashIndex)</span><span class="s3">\n\n  </span><span class="s1">if (hasQuery || hashIndex &gt; -1) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),</span><span class="s3">\n      </span><span class="s1">query: hasQuery</span><span class="s3">\n        </span><span class="s1">? path.substring(queryIndex, hashIndex &gt; -1 ? hashIndex : undefined)</span><span class="s3">\n        </span><span class="s1">: '',</span><span class="s3">\n      </span><span class="s1">hash: hashIndex &gt; -1 ? path.slice(hashIndex) : '',</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { pathname: path, query: '', hash: '' }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a given path starts with a given prefix. It ensures it matches</span><span class="s3">\n </span><span class="s1">* exactly without containing extra chars. e.g. prefix /docs should replace</span><span class="s3">\n </span><span class="s1">* for /docs, /docs/, /docs/a but not /docsss</span><span class="s3">\n </span><span class="s1">* @param path The path to check.</span><span class="s3">\n </span><span class="s1">* @param prefix The prefix to check against.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function pathHasPrefix(path: string, prefix: string) {</span><span class="s3">\n  </span><span class="s1">if (typeof path !== 'string') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return pathname === prefix || pathname.startsWith(prefix + '/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a path and a prefix it will remove the prefix when it exists in the</span><span class="s3">\n </span><span class="s1">* given path. It ensures it matches exactly without containing extra chars</span><span class="s3">\n </span><span class="s1">* and if the prefix is not there it will be noop.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param path The path to remove the prefix from.</span><span class="s3">\n </span><span class="s1">* @param prefix The prefix to be removed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removePathPrefix(path: string, prefix: string): string {</span><span class="s3">\n  </span><span class="s1">// If the path doesn't start with the prefix we can return it as is. This</span><span class="s3">\n  </span><span class="s1">// protects us from situations where the prefix is a substring of the path</span><span class="s3">\n  </span><span class="s1">// prefix such as:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// For prefix: /blog</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   /blog -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blog/ -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blog/1 -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blogging -&gt; false</span><span class="s3">\n  </span><span class="s1">//   /blogging/ -&gt; false</span><span class="s3">\n  </span><span class="s1">//   /blogging/1 -&gt; false</span><span class="s3">\n  </span><span class="s1">if (!pathHasPrefix(path, prefix)) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Remove the prefix from the path via slicing.</span><span class="s3">\n  </span><span class="s1">const withoutPrefix = path.slice(prefix.length)</span><span class="s3">\n\n  </span><span class="s1">// If the path without the prefix starts with a `/` we can return it as is.</span><span class="s3">\n  </span><span class="s1">if (withoutPrefix.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">return withoutPrefix</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If the path without the prefix doesn't start with a `/` we need to add it</span><span class="s3">\n  </span><span class="s1">// back to the path to make sure it's a valid path.</span><span class="s3">\n  </span><span class="s1">return `/${withoutPrefix}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// regexp is based on https://github.com/sindresorhus/escape-string-regexp</span><span class="s3">\n</span><span class="s1">const reHasRegExp = /[|</span><span class="s3">\\\\</span><span class="s1">{}()[</span><span class="s3">\\</span><span class="s1">]^$+*?.-]/</span><span class="s3">\n</span><span class="s1">const reReplaceRegExp = /[|</span><span class="s3">\\\\</span><span class="s1">{}()[</span><span class="s3">\\</span><span class="s1">]^$+*?.-]/g</span><span class="s3">\n\n</span><span class="s1">export function escapeStringRegexp(str: string) {</span><span class="s3">\n  </span><span class="s1">// see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23</span><span class="s3">\n  </span><span class="s1">if (reHasRegExp.test(str)) {</span><span class="s3">\n    </span><span class="s1">return str.replace(reReplaceRegExp, '</span><span class="s3">\\\\</span><span class="s1">$&amp;')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return str</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Removes the trailing slash for a given route or page path. Preserves the</span><span class="s3">\n </span><span class="s1">* root page. Examples:</span><span class="s3">\n </span><span class="s1">*   - `/foo/bar/` -&gt; `/foo/bar`</span><span class="s3">\n </span><span class="s1">*   - `/foo/bar` -&gt; `/foo/bar`</span><span class="s3">\n </span><span class="s1">*   - `/` -&gt; `/`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removeTrailingSlash(route: string) {</span><span class="s3">\n  </span><span class="s1">return route.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '') || '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { DynamicParam } from '../../../../server/app-render/app-render'</span><span class="s3">\n</span><span class="s1">import type { DynamicParamTypesShort } from '../../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { FallbackRouteParams } from '../../../../server/request/fallback-params'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Shared logic on client and server for creating a dynamic param value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This code needs to be shared with the client so it can extract dynamic route</span><span class="s3">\n </span><span class="s1">* params from the URL without a server request.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Because everything in this module is sent to the client, we should aim to</span><span class="s3">\n </span><span class="s1">* keep this code as simple as possible. The special case handling for catchall</span><span class="s3">\n </span><span class="s1">* and optional is, alas, unfortunate.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getDynamicParam(</span><span class="s3">\n  </span><span class="s1">params: { [key: string]: any },</span><span class="s3">\n  </span><span class="s1">segmentKey: string,</span><span class="s3">\n  </span><span class="s1">dynamicParamType: DynamicParamTypesShort,</span><span class="s3">\n  </span><span class="s1">pagePath: string,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">): DynamicParam {</span><span class="s3">\n  </span><span class="s1">let value = params[segmentKey]</span><span class="s3">\n\n  </span><span class="s1">if (fallbackRouteParams &amp;&amp; fallbackRouteParams.has(segmentKey)) {</span><span class="s3">\n    </span><span class="s1">value = fallbackRouteParams.get(segmentKey)</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">value = value.map((i) =&gt; encodeURIComponent(i))</span><span class="s3">\n  </span><span class="s1">} else if (typeof value === 'string') {</span><span class="s3">\n    </span><span class="s1">value = encodeURIComponent(value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!value) {</span><span class="s3">\n    </span><span class="s1">const isCatchall = dynamicParamType === 'c'</span><span class="s3">\n    </span><span class="s1">const isOptionalCatchall = dynamicParamType === 'oc'</span><span class="s3">\n\n    </span><span class="s1">if (isCatchall || isOptionalCatchall) {</span><span class="s3">\n      </span><span class="s1">// handle the case where an optional catchall does not have a value,</span><span class="s3">\n      </span><span class="s1">// e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`</span><span class="s3">\n      </span><span class="s1">if (isOptionalCatchall) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">param: segmentKey,</span><span class="s3">\n          </span><span class="s1">value: null,</span><span class="s3">\n          </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n          </span><span class="s1">treeSegment: [segmentKey, '', dynamicParamType],</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// handle the case where a catchall or optional catchall does not have a value,</span><span class="s3">\n      </span><span class="s1">// e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched</span><span class="s3">\n      </span><span class="s1">value = pagePath</span><span class="s3">\n        </span><span class="s1">.split('/')</span><span class="s3">\n        </span><span class="s1">// remove the first empty string</span><span class="s3">\n        </span><span class="s1">.slice(1)</span><span class="s3">\n        </span><span class="s1">// replace any dynamic params with the actual values</span><span class="s3">\n        </span><span class="s1">.flatMap((pathSegment) =&gt; {</span><span class="s3">\n          </span><span class="s1">const param = parseParameter(pathSegment)</span><span class="s3">\n          </span><span class="s1">// if the segment matches a param, return the param value</span><span class="s3">\n          </span><span class="s1">// otherwise, it's a static segment, so just return that</span><span class="s3">\n          </span><span class="s1">return params[param.key] ?? param.key</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">param: segmentKey,</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n        </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n        </span><span class="s1">// This value always has to be a string.</span><span class="s3">\n        </span><span class="s1">treeSegment: [segmentKey, value.join('/'), dynamicParamType],</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">param: segmentKey,</span><span class="s3">\n    </span><span class="s1">// The value that is passed to user code.</span><span class="s3">\n    </span><span class="s1">value: value,</span><span class="s3">\n    </span><span class="s1">// The value that is rendered in the router tree.</span><span class="s3">\n    </span><span class="s1">treeSegment: [</span><span class="s3">\n      </span><span class="s1">segmentKey,</span><span class="s3">\n      </span><span class="s1">Array.isArray(value) ? value.join('/') : value,</span><span class="s3">\n      </span><span class="s1">dynamicParamType,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Regular expression pattern used to match route parameters.</span><span class="s3">\n </span><span class="s1">* Matches both single parameters and parameter groups.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false</span><span class="s3">\n </span><span class="s1">*   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true</span><span class="s3">\n </span><span class="s1">*   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const PARAMETER_PATTERN = /^([^[]*)</span><span class="s3">\\</span><span class="s1">[((?:</span><span class="s3">\\</span><span class="s1">[[^</span><span class="s3">\\</span><span class="s1">]]*</span><span class="s3">\\</span><span class="s1">])|[^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">](.*)$/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses a given parameter from a route to a data structure that can be used</span><span class="s3">\n </span><span class="s1">* to generate the parametrized route.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[[...slug]]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `[[foo]]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `[bar]` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `fizz` -&gt; `{ key: 'fizz', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">* @param param - The parameter to parse.</span><span class="s3">\n </span><span class="s1">* @returns The parsed parameter as a data structure.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseParameter(param: string) {</span><span class="s3">\n  </span><span class="s1">const match = param.match(PARAMETER_PATTERN)</span><span class="s3">\n\n  </span><span class="s1">if (!match) {</span><span class="s3">\n    </span><span class="s1">return parseMatchedParameter(param)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return parseMatchedParameter(match[2])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used</span><span class="s3">\n </span><span class="s1">* to generate the parametrized route.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `...slug` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `[foo]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `bar` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">* @param param - The matched parameter to parse.</span><span class="s3">\n </span><span class="s1">* @returns The parsed parameter as a data structure.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseMatchedParameter(param: string) {</span><span class="s3">\n  </span><span class="s1">const optional = param.startsWith('[') &amp;&amp; param.endsWith(']')</span><span class="s3">\n  </span><span class="s1">if (optional) {</span><span class="s3">\n    </span><span class="s1">param = param.slice(1, -1)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const repeat = param.startsWith('...')</span><span class="s3">\n  </span><span class="s1">if (repeat) {</span><span class="s3">\n    </span><span class="s1">param = param.slice(3)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return { key: param, repeat, optional }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from './remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { PARAMETER_PATTERN, parseMatchedParameter } from './get-dynamic-param'</span><span class="s3">\n\n</span><span class="s1">export interface Group {</span><span class="s3">\n  </span><span class="s1">pos: number</span><span class="s3">\n  </span><span class="s1">repeat: boolean</span><span class="s3">\n  </span><span class="s1">optional: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RouteRegex {</span><span class="s3">\n  </span><span class="s1">groups: { [groupName: string]: Group }</span><span class="s3">\n  </span><span class="s1">re: RegExp</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetNamedRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n   </span><span class="s1">* or NEXT_QUERY_PARAM_PREFIX. This is only relevant when creating the</span><span class="s3">\n   </span><span class="s1">* routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the suffix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to backtrack duplicate keys. This is only relevant when creating</span><span class="s3">\n   </span><span class="s1">* the routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include extra parts in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">* of adding this option.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const groups: { [groupName: string]: Group } = {}</span><span class="s3">\n  </span><span class="s1">let groupIndex = 1</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const markerMatch = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (markerMatch &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(markerMatch)}([^/]+?)`)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, repeat, optional } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">parameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* From a normalized route this function generates a regular expression and</span><span class="s3">\n </span><span class="s1">* a corresponding groups object intended to be used to store matching groups</span><span class="s3">\n </span><span class="s1">* from the regular expression.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">includeSuffix = false,</span><span class="s3">\n    </span><span class="s1">includePrefix = false,</span><span class="s3">\n    </span><span class="s1">excludeOptionalTrailingSlash = false,</span><span class="s3">\n  </span><span class="s1">}: GetRouteRegexOptions = {}</span><span class="s3">\n</span><span class="s1">): RouteRegex {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute, groups } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">includeSuffix,</span><span class="s3">\n    </span><span class="s1">includePrefix</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let re = parameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">re += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">re: new RegExp(`^${re}$`),</span><span class="s3">\n    </span><span class="s1">groups: groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Builds a function to generate a minimal routeKey using only a-z and minimal</span><span class="s3">\n </span><span class="s1">* number of characters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildGetSafeRouteKey() {</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n\n  </span><span class="s1">return () =&gt; {</span><span class="s3">\n    </span><span class="s1">let routeKey = ''</span><span class="s3">\n    </span><span class="s1">let j = ++i</span><span class="s3">\n    </span><span class="s1">while (j &gt; 0) {</span><span class="s3">\n      </span><span class="s1">routeKey += String.fromCharCode(97 + ((j - 1) % 26))</span><span class="s3">\n      </span><span class="s1">j = Math.floor((j - 1) / 26)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return routeKey</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getSafeKeyFromSegment({</span><span class="s3">\n  </span><span class="s1">interceptionMarker,</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n  </span><span class="s1">segment,</span><span class="s3">\n  </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">keyPrefix,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">interceptionMarker?: string</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey: () =&gt; string</span><span class="s3">\n  </span><span class="s1">segment: string</span><span class="s3">\n  </span><span class="s1">routeKeys: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">keyPrefix?: string</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(segment)</span><span class="s3">\n\n  </span><span class="s1">// replace any non-word characters since they can break</span><span class="s3">\n  </span><span class="s1">// the named regex</span><span class="s3">\n  </span><span class="s1">let cleanedKey = key.replace(/</span><span class="s3">\\</span><span class="s1">W/g, '')</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = `${keyPrefix}${cleanedKey}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let invalidKey = false</span><span class="s3">\n\n  </span><span class="s1">// check if the key is still invalid and fallback to using a known</span><span class="s3">\n  </span><span class="s1">// safe key</span><span class="s3">\n  </span><span class="s1">if (cleanedKey.length === 0 || cleanedKey.length &gt; 30) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (invalidKey) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = getSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const duplicateKey = cleanedKey in routeKeys</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = `${keyPrefix}${key}`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = key</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if the segment has an interception marker, make sure that's part of the regex pattern</span><span class="s3">\n  </span><span class="s1">// this is to ensure that the route with the interception marker doesn't incorrectly match</span><span class="s3">\n  </span><span class="s1">// the non-intercepted route (ie /app/(.)[username] should not match /app/[username])</span><span class="s3">\n  </span><span class="s1">const interceptionPrefix = interceptionMarker</span><span class="s3">\n    </span><span class="s1">? escapeStringRegexp(interceptionMarker)</span><span class="s3">\n    </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">let pattern: string</span><span class="s3">\n  </span><span class="s1">if (duplicateKey &amp;&amp; backreferenceDuplicateKeys) {</span><span class="s3">\n    </span><span class="s1">// Use a backreference to the key to ensure that the key is the same value</span><span class="s3">\n    </span><span class="s1">// in each of the placeholders.</span><span class="s3">\n    </span><span class="s1">pattern = `</span><span class="s3">\\\\</span><span class="s1">k&lt;${cleanedKey}&gt;`</span><span class="s3">\n  </span><span class="s1">} else if (repeat) {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;.+?)`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;[^/]+?)`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return optional</span><span class="s3">\n    </span><span class="s1">? `(?:/${interceptionPrefix}${pattern})?`</span><span class="s3">\n    </span><span class="s1">: `/${interceptionPrefix}${pattern}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getNamedParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const getSafeRouteKey = buildGetSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">const routeKeys: { [named: string]: string } = {}</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const hasInterceptionMarker = INTERCEPTION_ROUTE_MARKERS.some((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (hasInterceptionMarker &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's an interception marker, add it to the segments.</span><span class="s3">\n      </span><span class="s1">segments.push(</span><span class="s3">\n        </span><span class="s1">getSafeKeyFromSegment({</span><span class="s3">\n          </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n          </span><span class="s1">interceptionMarker: paramMatches[1],</span><span class="s3">\n          </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n          </span><span class="s1">routeKeys,</span><span class="s3">\n          </span><span class="s1">keyPrefix: prefixRouteKeys</span><span class="s3">\n            </span><span class="s1">? NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n            </span><span class="s1">: undefined,</span><span class="s3">\n          </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's a prefix, add it to the segments if it's enabled.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = getSafeKeyFromSegment({</span><span class="s3">\n        </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n        </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n        </span><span class="s1">routeKeys,</span><span class="s3">\n        </span><span class="s1">keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,</span><span class="s3">\n        </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedParameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function extends `getRouteRegex` generating also a named regexp where</span><span class="s3">\n </span><span class="s1">* each group is named along with a routeKeys object that indexes the assigned</span><span class="s3">\n </span><span class="s1">* named group with its corresponding key. When the routeKeys need to be</span><span class="s3">\n </span><span class="s1">* prefixed to uniquely identify internally the </span><span class="s3">\&quot;</span><span class="s1">prefixRouteKey</span><span class="s3">\&quot; </span><span class="s1">arg should</span><span class="s3">\n </span><span class="s1">* be </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot; </span><span class="s1">currently this is only the case when creating the routes-manifest</span><span class="s3">\n </span><span class="s1">* during the build</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: GetNamedRouteRegexOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const result = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">options.prefixRouteKeys,</span><span class="s3">\n    </span><span class="s1">options.includeSuffix ?? false,</span><span class="s3">\n    </span><span class="s1">options.includePrefix ?? false,</span><span class="s3">\n    </span><span class="s1">options.backreferenceDuplicateKeys ?? false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let namedRegex = result.namedParameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!options.excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">namedRegex += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...getRouteRegex(normalizedRoute, options),</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedRegex}$`,</span><span class="s3">\n    </span><span class="s1">routeKeys: result.routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a named regexp.</span><span class="s3">\n </span><span class="s1">* This is intended to be using for build time only.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedMiddlewareRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">catchAll?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const { catchAll = true } = options</span><span class="s3">\n  </span><span class="s1">if (parameterizedRoute === '/') {</span><span class="s3">\n    </span><span class="s1">let catchAllRegex = catchAll ? '.*' : ''</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">namedRegex: `^/${catchAllRegex}$`,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { namedParameterizedRoute } = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : ''</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { HtmlProps } from './html-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { ComponentType, JSX } from 'react'</span><span class="s3">\n</span><span class="s1">import type { DomainLocale } from '../../server/config'</span><span class="s3">\n</span><span class="s1">import type { Env } from '@next/env'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { NextRouter } from './router/router'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../types'</span><span class="s3">\n</span><span class="s1">import type { COMPILER_NAMES } from './constants'</span><span class="s3">\n</span><span class="s1">import type fs from 'fs'</span><span class="s3">\n\n</span><span class="s1">export type NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">Context extends BaseContext = NextPageContext,</span><span class="s3">\n  </span><span class="s1">InitialProps = {},</span><span class="s3">\n  </span><span class="s1">Props = {},</span><span class="s3">\n</span><span class="s1">&gt; = ComponentType&lt;Props&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.</span><span class="s3">\n   </span><span class="s1">* Make sure to return plain `Object` without using `Date`, `Map`, `Set`.</span><span class="s3">\n   </span><span class="s1">* @param context Context of `page`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getInitialProps?(context: Context): InitialProps | Promise&lt;InitialProps&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentType = NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">DocumentContext,</span><span class="s3">\n  </span><span class="s1">DocumentInitialProps,</span><span class="s3">\n  </span><span class="s1">DocumentProps</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppType&lt;P = {}&gt; = NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">AppContextType,</span><span class="s3">\n  </span><span class="s1">P,</span><span class="s3">\n  </span><span class="s1">AppPropsType&lt;any, P&gt;</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppTreeType = ComponentType&lt;</span><span class="s3">\n  </span><span class="s1">AppInitialProps &amp; { [name: string]: any }</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.</span><span class="s3">\n </span><span class="s1">* https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const</span><span class="s3">\n</span><span class="s1">export type NextWebVitalsMetric = {</span><span class="s3">\n  </span><span class="s1">id: string</span><span class="s3">\n  </span><span class="s1">startTime: number</span><span class="s3">\n  </span><span class="s1">value: number</span><span class="s3">\n  </span><span class="s1">attribution?: { [key: string]: unknown }</span><span class="s3">\n</span><span class="s1">} &amp; (</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">label: 'web-vital'</span><span class="s3">\n      </span><span class="s1">name: (typeof WEB_VITALS)[number]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">label: 'custom'</span><span class="s3">\n      </span><span class="s1">name:</span><span class="s3">\n        </span><span class="s1">| 'Next.js-hydration'</span><span class="s3">\n        </span><span class="s1">| 'Next.js-route-change-to-render'</span><span class="s3">\n        </span><span class="s1">| 'Next.js-render'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export type Enhancer&lt;C&gt; = (Component: C) =&gt; C</span><span class="s3">\n\n</span><span class="s1">export type ComponentsEnhancer =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">enhanceApp?: Enhancer&lt;AppType&gt;</span><span class="s3">\n      </span><span class="s1">enhanceComponent?: Enhancer&lt;NextComponentType&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| Enhancer&lt;NextComponentType&gt;</span><span class="s3">\n\n</span><span class="s1">export type RenderPageResult = {</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">head?: Array&lt;JSX.Element | null&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderPage = (</span><span class="s3">\n  </span><span class="s1">options?: ComponentsEnhancer</span><span class="s3">\n</span><span class="s1">) =&gt; DocumentInitialProps | Promise&lt;DocumentInitialProps&gt;</span><span class="s3">\n\n</span><span class="s1">export type BaseContext = {</span><span class="s3">\n  </span><span class="s1">res?: ServerResponse</span><span class="s3">\n  </span><span class="s1">[k: string]: any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NEXT_DATA = {</span><span class="s3">\n  </span><span class="s1">props: Record&lt;string, any&gt;</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">runtimeConfig?: { [key: string]: any }</span><span class="s3">\n  </span><span class="s1">nextExport?: boolean</span><span class="s3">\n  </span><span class="s1">autoExport?: boolean</span><span class="s3">\n  </span><span class="s1">isFallback?: boolean</span><span class="s3">\n  </span><span class="s1">isExperimentalCompile?: boolean</span><span class="s3">\n  </span><span class="s1">dynamicIds?: (string | number)[]</span><span class="s3">\n  </span><span class="s1">err?: Error &amp; {</span><span class="s3">\n    </span><span class="s1">statusCode?: number</span><span class="s3">\n    </span><span class="s1">source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">gsp?: boolean</span><span class="s3">\n  </span><span class="s1">gssp?: boolean</span><span class="s3">\n  </span><span class="s1">customServer?: boolean</span><span class="s3">\n  </span><span class="s1">gip?: boolean</span><span class="s3">\n  </span><span class="s1">appGip?: boolean</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">domainLocales?: readonly DomainLocale[]</span><span class="s3">\n  </span><span class="s1">scriptLoader?: any[]</span><span class="s3">\n  </span><span class="s1">isPreview?: boolean</span><span class="s3">\n  </span><span class="s1">notFoundSrcPage?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* `Next` context</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NextPageContext {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Error object if encountered during rendering</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">err?: (Error &amp; { statusCode?: number }) | null</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `HTTP` request object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">req?: IncomingMessage</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `HTTP` response object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">res?: ServerResponse</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Path section of `URL`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Query string section of `URL` parsed as an object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `String` of the actual path including query.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">asPath?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The currently active locale</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* All configured locales</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The configured default locale</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `Component` the tree of the App to use if needing to render separately</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">AppTree: AppTreeType</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppContextType&lt;Router extends NextRouter = NextRouter&gt; = {</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType&lt;NextPageContext&gt;</span><span class="s3">\n  </span><span class="s1">AppTree: AppTreeType</span><span class="s3">\n  </span><span class="s1">ctx: NextPageContext</span><span class="s3">\n  </span><span class="s1">router: Router</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppInitialProps&lt;PageProps = any&gt; = {</span><span class="s3">\n  </span><span class="s1">pageProps: PageProps</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppPropsType&lt;</span><span class="s3">\n  </span><span class="s1">Router extends NextRouter = NextRouter,</span><span class="s3">\n  </span><span class="s1">PageProps = {},</span><span class="s3">\n</span><span class="s1">&gt; = AppInitialProps&lt;PageProps&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType&lt;NextPageContext, any, any&gt;</span><span class="s3">\n  </span><span class="s1">router: Router</span><span class="s3">\n  </span><span class="s1">__N_SSG?: boolean</span><span class="s3">\n  </span><span class="s1">__N_SSP?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentContext = NextPageContext &amp; {</span><span class="s3">\n  </span><span class="s1">renderPage: RenderPage</span><span class="s3">\n  </span><span class="s1">defaultGetInitialProps(</span><span class="s3">\n    </span><span class="s1">ctx: DocumentContext,</span><span class="s3">\n    </span><span class="s1">options?: { nonce?: string }</span><span class="s3">\n  </span><span class="s1">): Promise&lt;DocumentInitialProps&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentInitialProps = RenderPageResult &amp; {</span><span class="s3">\n  </span><span class="s1">styles?: React.ReactElement[] | Iterable&lt;React.ReactNode&gt; | JSX.Element</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentProps = DocumentInitialProps &amp; HtmlProps</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route request</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NextApiRequest extends IncomingMessage {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object of `query` values from url</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: Partial&lt;{</span><span class="s3">\n    </span><span class="s1">[key: string]: string | string[]</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object of `cookies` from header</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cookies: Partial&lt;{</span><span class="s3">\n    </span><span class="s1">[key: string]: string</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n\n  </span><span class="s1">body: any</span><span class="s3">\n\n  </span><span class="s1">env: Env</span><span class="s3">\n\n  </span><span class="s1">draftMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">preview?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Preview data set on the request, if any</span><span class="s3">\n   </span><span class="s1">* */</span><span class="s3">\n  </span><span class="s1">previewData?: PreviewData</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Send body of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type Send&lt;T&gt; = (body: T) =&gt; void</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NextApiResponse&lt;Data = any&gt; = ServerResponse &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Send data `any` data in response</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">send: Send&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Send data `json` data in response</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">json: Send&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">status: (statusCode: number) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">redirect(url: string): NextApiResponse&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">redirect(status: number, url: string): NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set draft mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setDraftMode: (options: { enable: boolean }) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set preview data for Next.js' prerender mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setPreviewData: (</span><span class="s3">\n    </span><span class="s1">data: object | string,</span><span class="s3">\n    </span><span class="s1">options?: {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Specifies the number (in seconds) for the preview session to last for.</span><span class="s3">\n       </span><span class="s1">* The given number will be converted to an integer by rounding down.</span><span class="s3">\n       </span><span class="s1">* By default, no maximum age is set and the preview session finishes</span><span class="s3">\n       </span><span class="s1">* when the client shuts down (browser is closed).</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">maxAge?: number</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Specifies the path for the preview session to work under. By default,</span><span class="s3">\n       </span><span class="s1">* the path is considered the </span><span class="s3">\&quot;</span><span class="s1">default path</span><span class="s3">\&quot;</span><span class="s1">, i.e., any pages under </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">path?: string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Clear preview data for Next.js' prerender mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clearPreviewData: (options?: { path?: string }) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Revalidate a specific page and regenerate it using On-Demand Incremental</span><span class="s3">\n   </span><span class="s1">* Static Regeneration.</span><span class="s3">\n   </span><span class="s1">* The path should be an actual path, not a rewritten path. E.g. for</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">/blog/[slug]</span><span class="s3">\&quot; </span><span class="s1">this should be </span><span class="s3">\&quot;</span><span class="s1">/blog/post-1</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n   </span><span class="s1">* @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">revalidate: (</span><span class="s3">\n    </span><span class="s1">urlPath: string,</span><span class="s3">\n    </span><span class="s1">opts?: {</span><span class="s3">\n      </span><span class="s1">unstable_onlyGenerated?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route handler</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NextApiHandler&lt;T = any&gt; = (</span><span class="s3">\n  </span><span class="s1">req: NextApiRequest,</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; unknown | Promise&lt;unknown&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utils</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function execOnce&lt;T extends (...args: any[]) =&gt; ReturnType&lt;T&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">fn: T</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">let used = false</span><span class="s3">\n  </span><span class="s1">let result: ReturnType&lt;T&gt;</span><span class="s3">\n\n  </span><span class="s1">return ((...args: any[]) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!used) {</span><span class="s3">\n      </span><span class="s1">used = true</span><span class="s3">\n      </span><span class="s1">result = fn(...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1</span><span class="s3">\n</span><span class="s1">// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3</span><span class="s3">\n</span><span class="s1">const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z</span><span class="s3">\\</span><span class="s1">d+</span><span class="s3">\\</span><span class="s1">-.]*?:/</span><span class="s3">\n</span><span class="s1">export const isAbsoluteUrl = (url: string) =&gt; ABSOLUTE_URL_REGEX.test(url)</span><span class="s3">\n\n</span><span class="s1">export function getLocationOrigin() {</span><span class="s3">\n  </span><span class="s1">const { protocol, hostname, port } = window.location</span><span class="s3">\n  </span><span class="s1">return `${protocol}//${hostname}${port ? ':' + port : ''}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getURL() {</span><span class="s3">\n  </span><span class="s1">const { href } = window.location</span><span class="s3">\n  </span><span class="s1">const origin = getLocationOrigin()</span><span class="s3">\n  </span><span class="s1">return href.substring(origin.length)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getDisplayName&lt;P&gt;(Component: ComponentType&lt;P&gt;) {</span><span class="s3">\n  </span><span class="s1">return typeof Component === 'string'</span><span class="s3">\n    </span><span class="s1">? Component</span><span class="s3">\n    </span><span class="s1">: Component.displayName || Component.name || 'Unknown'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isResSent(res: ServerResponse) {</span><span class="s3">\n  </span><span class="s1">return res.finished || res.headersSent</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeRepeatedSlashes(url: string) {</span><span class="s3">\n  </span><span class="s1">const urlParts = url.split('?')</span><span class="s3">\n  </span><span class="s1">const urlNoQuery = urlParts[0]</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">urlNoQuery</span><span class="s3">\n      </span><span class="s1">// first we replace any non-encoded backslashes with forward</span><span class="s3">\n      </span><span class="s1">// then normalize repeated forward slashes</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/+/g, '/') +</span><span class="s3">\n    </span><span class="s1">(urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function loadGetInitialProps&lt;</span><span class="s3">\n  </span><span class="s1">C extends BaseContext,</span><span class="s3">\n  </span><span class="s1">IP = {},</span><span class="s3">\n  </span><span class="s1">P = {},</span><span class="s3">\n</span><span class="s1">&gt;(App: NextComponentType&lt;C, IP, P&gt;, ctx: C): Promise&lt;IP&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">if (App.prototype?.getInitialProps) {</span><span class="s3">\n      </span><span class="s1">const message = `</span><span class="s3">\&quot;</span><span class="s1">${getDisplayName(</span><span class="s3">\n        </span><span class="s1">App</span><span class="s3">\n      </span><span class="s1">)}.getInitialProps()</span><span class="s3">\&quot; </span><span class="s1">is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`</span><span class="s3">\n      </span><span class="s1">throw new Error(message)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// when called from _app `ctx` is nested in `ctx`</span><span class="s3">\n  </span><span class="s1">const res = ctx.res || (ctx.ctx &amp;&amp; ctx.ctx.res)</span><span class="s3">\n\n  </span><span class="s1">if (!App.getInitialProps) {</span><span class="s3">\n    </span><span class="s1">if (ctx.ctx &amp;&amp; ctx.Component) {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore pageProps default</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {} as IP</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const props = await App.getInitialProps(ctx)</span><span class="s3">\n\n  </span><span class="s1">if (res &amp;&amp; isResSent(res)) {</span><span class="s3">\n    </span><span class="s1">return props</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!props) {</span><span class="s3">\n    </span><span class="s1">const message = `</span><span class="s3">\&quot;</span><span class="s1">${getDisplayName(</span><span class="s3">\n      </span><span class="s1">App</span><span class="s3">\n    </span><span class="s1">)}.getInitialProps()</span><span class="s3">\&quot; </span><span class="s1">should resolve to an object. But found </span><span class="s3">\&quot;</span><span class="s1">${props}</span><span class="s3">\&quot; </span><span class="s1">instead.`</span><span class="s3">\n    </span><span class="s1">throw new Error(message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">if (Object.keys(props).length === 0 &amp;&amp; !ctx.ctx) {</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">`${getDisplayName(</span><span class="s3">\n          </span><span class="s1">App</span><span class="s3">\n        </span><span class="s1">)} returned an empty object from </span><span class="s3">\\</span><span class="s1">`getInitialProps</span><span class="s3">\\</span><span class="s1">`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return props</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const SP = typeof performance !== 'undefined'</span><span class="s3">\n</span><span class="s1">export const ST =</span><span class="s3">\n  </span><span class="s1">SP &amp;&amp;</span><span class="s3">\n  </span><span class="s1">(['mark', 'measure', 'getEntriesByName'] as const).every(</span><span class="s3">\n    </span><span class="s1">(method) =&gt; typeof performance[method] === 'function'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export class DecodeError extends Error {}</span><span class="s3">\n</span><span class="s1">export class NormalizeError extends Error {}</span><span class="s3">\n</span><span class="s1">export class PageNotFoundError extends Error {</span><span class="s3">\n  </span><span class="s1">code: string</span><span class="s3">\n\n  </span><span class="s1">constructor(page: string) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.code = 'ENOENT'</span><span class="s3">\n    </span><span class="s1">this.name = 'PageNotFoundError'</span><span class="s3">\n    </span><span class="s1">this.message = `Cannot find module for page: ${page}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MissingStaticPage extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(page: string, message: string) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.message = `Failed to load static file for page: ${page} ${message}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MiddlewareNotFoundError extends Error {</span><span class="s3">\n  </span><span class="s1">code: string</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.code = 'ENOENT'</span><span class="s3">\n    </span><span class="s1">this.message = `Cannot find the middleware module`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CacheFs {</span><span class="s3">\n  </span><span class="s1">existsSync: typeof fs.existsSync</span><span class="s3">\n  </span><span class="s1">readFile: typeof fs.promises.readFile</span><span class="s3">\n  </span><span class="s1">readFileSync: typeof fs.readFileSync</span><span class="s3">\n  </span><span class="s1">writeFile(f: string, d: any): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">mkdir(dir: string): Promise&lt;void | string&gt;</span><span class="s3">\n  </span><span class="s1">stat(f: string): Promise&lt;{ mtime: Date }&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stringifyError(error: Error) {</span><span class="s3">\n  </span><span class="s1">return JSON.stringify({ message: error.message, stack: error.stack })</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Token } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Route pattern normalization utilities for path-to-regexp compatibility.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* path-to-regexp 6.3.0+ introduced stricter validation that rejects certain</span><span class="s3">\n </span><span class="s1">* patterns commonly used in Next.js interception routes. This module provides</span><span class="s3">\n </span><span class="s1">* normalization functions to make Next.js route patterns compatible with the</span><span class="s3">\n </span><span class="s1">* updated library while preserving all functionality.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Internal separator used to normalize adjacent parameter patterns.</span><span class="s3">\n </span><span class="s1">* This unique marker is inserted between adjacent parameters and stripped out</span><span class="s3">\n </span><span class="s1">* during parameter extraction to avoid conflicts with real URL content.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const PARAM_SEPARATOR = '_NEXTSEP_'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Detects if a route pattern needs normalization for path-to-regexp compatibility.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hasAdjacentParameterIssues(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">if (typeof route !== 'string') return false</span><span class="s3">\n\n  </span><span class="s1">// Check for interception route markers followed immediately by parameters</span><span class="s3">\n  </span><span class="s1">// Pattern: /(.):param, /(..):param, /(...):param, /(.)(.):param etc.</span><span class="s3">\n  </span><span class="s1">// These patterns cause </span><span class="s3">\&quot;</span><span class="s1">Must have text between two parameters</span><span class="s3">\&quot; </span><span class="s1">errors</span><span class="s3">\n  </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">.{1,3}</span><span class="s3">\\</span><span class="s1">):[^/</span><span class="s3">\\</span><span class="s1">s]+/.test(route)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check for basic adjacent parameters without separators</span><span class="s3">\n  </span><span class="s1">// Pattern: :param1:param2 (but not :param* or other URL patterns)</span><span class="s3">\n  </span><span class="s1">if (/:[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z_][a-zA-Z0-9_]*/.test(route)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes route patterns that have adjacent parameters without text between them.</span><span class="s3">\n </span><span class="s1">* Inserts a unique separator that can be safely stripped out later.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeAdjacentParameters(route: string): string {</span><span class="s3">\n  </span><span class="s1">let normalized = route</span><span class="s3">\n\n  </span><span class="s1">// Handle interception route patterns: (.):param -&gt; (.)_NEXTSEP_:param</span><span class="s3">\n  </span><span class="s1">normalized = normalized.replace(</span><span class="s3">\n    </span><span class="s1">/(</span><span class="s3">\\</span><span class="s1">([^)]*</span><span class="s3">\\</span><span class="s1">)):([^/</span><span class="s3">\\</span><span class="s1">s]+)/g,</span><span class="s3">\n    </span><span class="s1">`$1${PARAM_SEPARATOR}:$2`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Handle other adjacent parameter patterns: :param1:param2 -&gt; :param1_NEXTSEP_:param2</span><span class="s3">\n  </span><span class="s1">normalized = normalized.replace(/:([^:/</span><span class="s3">\\</span><span class="s1">s)]+)(?=:)/g, `:$1${PARAM_SEPARATOR}`)</span><span class="s3">\n\n  </span><span class="s1">return normalized</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes tokens that have repeating modifiers (* or +) but empty prefix and suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* path-to-regexp 6.3.0+ introduced validation that throws:</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">Can not repeat without prefix/suffix</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This occurs when a token has modifier: '*' or '+' with both prefix: '' and suffix: ''</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeTokensForRegexp(tokens: Token[]): Token[] {</span><span class="s3">\n  </span><span class="s1">return tokens.map((token) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Token union type: Token = string | TokenObject</span><span class="s3">\n    </span><span class="s1">// Literal path segments are strings, parameters/wildcards are objects</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">typeof token === 'object' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">token !== null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Not all token objects have 'modifier' property (e.g., simple text tokens)</span><span class="s3">\n      </span><span class="s1">'modifier' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Only repeating modifiers (* or +) cause the validation error</span><span class="s3">\n      </span><span class="s1">// Other modifiers like '?' (optional) are fine</span><span class="s3">\n      </span><span class="s1">(token.modifier === '*' || token.modifier === '+') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Token objects can have different shapes depending on route pattern</span><span class="s3">\n      </span><span class="s1">'prefix' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">'suffix' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Both prefix and suffix must be empty strings</span><span class="s3">\n      </span><span class="s1">// This is what causes the validation error in path-to-regexp</span><span class="s3">\n      </span><span class="s1">token.prefix === '' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">token.suffix === ''</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Add minimal prefix to satisfy path-to-regexp validation</span><span class="s3">\n      </span><span class="s1">// We use '/' as it's the most common path delimiter and won't break route matching</span><span class="s3">\n      </span><span class="s1">// The prefix gets used in regex generation but doesn't affect parameter extraction</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">...token,</span><span class="s3">\n        </span><span class="s1">prefix: '/',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return token</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips normalization separators from extracted route parameters.</span><span class="s3">\n </span><span class="s1">* Used by both server and client code to clean up parameters after route matching.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function stripParameterSeparators(</span><span class="s3">\n  </span><span class="s1">params: Record&lt;string, any&gt;</span><span class="s3">\n</span><span class="s1">): Record&lt;string, any&gt; {</span><span class="s3">\n  </span><span class="s1">const cleaned: Record&lt;string, any&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const [key, value] of Object.entries(params)) {</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">// Remove the separator if it appears at the start of parameter values</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">// Handle array parameters (from repeated route segments)</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value.map((item) =&gt;</span><span class="s3">\n        </span><span class="s1">typeof item === 'string'</span><span class="s3">\n          </span><span class="s1">? item.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')</span><span class="s3">\n          </span><span class="s1">: item</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return cleaned</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Client-safe utilities for route matching that don't import server-side</span><span class="s3">\n </span><span class="s1">* utilities to avoid bundling issues with Turbopack</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Key,</span><span class="s3">\n  </span><span class="s1">TokensToRegexpOptions,</span><span class="s3">\n  </span><span class="s1">ParseOptions,</span><span class="s3">\n  </span><span class="s1">TokensToFunctionOptions,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">pathToRegexp,</span><span class="s3">\n  </span><span class="s1">compile,</span><span class="s3">\n  </span><span class="s1">regexpToFunction,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">hasAdjacentParameterIssues,</span><span class="s3">\n  </span><span class="s1">normalizeAdjacentParameters,</span><span class="s3">\n  </span><span class="s1">stripParameterSeparators,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/route-pattern-normalizer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around pathToRegexp that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* This includes both </span><span class="s3">\&quot;</span><span class="s1">Can not repeat without prefix/suffix</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">Must have text between parameters</span><span class="s3">\&quot; </span><span class="s1">errors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safePathToRegexp(</span><span class="s3">\n  </span><span class="s1">route: string | RegExp | Array&lt;string | RegExp&gt;,</span><span class="s3">\n  </span><span class="s1">keys?: Key[],</span><span class="s3">\n  </span><span class="s1">options?: TokensToRegexpOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">): RegExp {</span><span class="s3">\n  </span><span class="s1">if (typeof route !== 'string') {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(route, keys, options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(routeToUse, keys, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return pathToRegexp(normalizedRoute, keys, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around compile that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* No server-side error reporting to avoid bundling issues.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeCompile(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">options?: TokensToFunctionOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return compile(routeToUse, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return compile(normalizedRoute, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around regexpToFunction that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRegexpToFunction&lt;</span><span class="s3">\n  </span><span class="s1">T extends Record&lt;string, any&gt; = Record&lt;string, any&gt;,</span><span class="s3">\n</span><span class="s1">&gt;(regexp: RegExp, keys?: Key[]): (pathname: string) =&gt; { params: T } | false {</span><span class="s3">\n  </span><span class="s1">const originalMatcher = regexpToFunction&lt;T&gt;(regexp, keys || [])</span><span class="s3">\n\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = originalMatcher(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">...result,</span><span class="s3">\n      </span><span class="s1">params: stripParameterSeparators(result.params as any) as T,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Safe wrapper for route matcher functions that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">* This is client-safe and doesn't import path-to-regexp.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRouteMatcher&lt;T extends Record&lt;string, any&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">matcherFn: (pathname: string) =&gt; false | T</span><span class="s3">\n</span><span class="s1">): (pathname: string) =&gt; false | T {</span><span class="s3">\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = matcherFn(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return stripParameterSeparators(result) as T</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Group } from './route-regex'</span><span class="s3">\n</span><span class="s1">import { DecodeError } from '../../utils'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { safeRouteMatcher } from './route-match-utils'</span><span class="s3">\n\n</span><span class="s1">export interface RouteMatchFn {</span><span class="s3">\n  </span><span class="s1">(pathname: string): false | Params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RouteMatcherOptions = {</span><span class="s3">\n  </span><span class="s1">// We only use the exec method of the RegExp object. This helps us avoid using</span><span class="s3">\n  </span><span class="s1">// type assertions that the passed in properties are of the correct type.</span><span class="s3">\n  </span><span class="s1">re: Pick&lt;RegExp, 'exec'&gt;</span><span class="s3">\n  </span><span class="s1">groups: Record&lt;string, Group&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRouteMatcher({</span><span class="s3">\n  </span><span class="s1">re,</span><span class="s3">\n  </span><span class="s1">groups,</span><span class="s3">\n</span><span class="s1">}: RouteMatcherOptions): RouteMatchFn {</span><span class="s3">\n  </span><span class="s1">const rawMatcher = (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const routeMatch = re.exec(pathname)</span><span class="s3">\n    </span><span class="s1">if (!routeMatch) return false</span><span class="s3">\n\n    </span><span class="s1">const decode = (param: string) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return decodeURIComponent(param)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">throw new DecodeError('failed to decode param')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const params: Params = {}</span><span class="s3">\n    </span><span class="s1">for (const [key, group] of Object.entries(groups)) {</span><span class="s3">\n      </span><span class="s1">const match = routeMatch[group.pos]</span><span class="s3">\n      </span><span class="s1">if (match !== undefined) {</span><span class="s3">\n        </span><span class="s1">if (group.repeat) {</span><span class="s3">\n          </span><span class="s1">params[key] = match.split('/').map((entry) =&gt; decode(entry))</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params[key] = decode(match)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Wrap with safe matcher to handle parameter cleaning</span><span class="s3">\n  </span><span class="s1">return safeRouteMatcher(rawMatcher)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">export function searchParamsToUrlQuery(</span><span class="s3">\n  </span><span class="s1">searchParams: URLSearchParams</span><span class="s3">\n</span><span class="s1">): ParsedUrlQuery {</span><span class="s3">\n  </span><span class="s1">const query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of searchParams.entries()) {</span><span class="s3">\n    </span><span class="s1">const existing = query[key]</span><span class="s3">\n    </span><span class="s1">if (typeof existing === 'undefined') {</span><span class="s3">\n      </span><span class="s1">query[key] = value</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(existing)) {</span><span class="s3">\n      </span><span class="s1">existing.push(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">query[key] = [existing, value]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return query</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function stringifyUrlQueryParam(param: unknown): string {</span><span class="s3">\n  </span><span class="s1">if (typeof param === 'string') {</span><span class="s3">\n    </span><span class="s1">return param</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(typeof param === 'number' &amp;&amp; !isNaN(param)) ||</span><span class="s3">\n    </span><span class="s1">typeof param === 'boolean'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return String(param)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function urlQueryToSearchParams(query: ParsedUrlQuery): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">const searchParams = new URLSearchParams()</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">for (const item of value) {</span><span class="s3">\n        </span><span class="s1">searchParams.append(key, stringifyUrlQueryParam(item))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">searchParams.set(key, stringifyUrlQueryParam(value))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return searchParams</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assign(</span><span class="s3">\n  </span><span class="s1">target: URLSearchParams,</span><span class="s3">\n  </span><span class="s1">...searchParamsList: URLSearchParams[]</span><span class="s3">\n</span><span class="s1">): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">for (const searchParams of searchParamsList) {</span><span class="s3">\n    </span><span class="s1">for (const key of searchParams.keys()) {</span><span class="s3">\n      </span><span class="s1">target.delete(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [key, value] of searchParams.entries()) {</span><span class="s3">\n      </span><span class="s1">target.append(key, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return target</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { Key } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import type { NextParsedUrlQuery } from '../../../../server/request-meta'</span><span class="s3">\n</span><span class="s1">import type { RouteHas } from '../../../../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../../../../server/base-http'</span><span class="s3">\n\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { parseUrl } from './parse-url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">INTERCEPTION_ROUTE_MARKERS,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { getCookieParser } from '../../../../server/api-utils/get-cookie-parser'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp, safeCompile } from './route-match-utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensure only a-zA-Z are used for param names for proper interpolating</span><span class="s3">\n </span><span class="s1">* with path-to-regexp</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getSafeParamName(paramName: string) {</span><span class="s3">\n  </span><span class="s1">let newParamName = ''</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; paramName.length; i++) {</span><span class="s3">\n    </span><span class="s1">const charCode = paramName.charCodeAt(i)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 64 &amp;&amp; charCode &lt; 91) || // A-Z</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 96 &amp;&amp; charCode &lt; 123) // a-z</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">newParamName += paramName[i]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newParamName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function escapeSegment(str: string, segmentName: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(</span><span class="s3">\n    </span><span class="s1">new RegExp(`:${escapeStringRegexp(segmentName)}`, 'g'),</span><span class="s3">\n    </span><span class="s1">`__ESC_COLON_${segmentName}`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function unescapeSegments(str: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(/__ESC_COLON_/gi, ':')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function matchHas(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">query: Params,</span><span class="s3">\n  </span><span class="s1">has: RouteHas[] = [],</span><span class="s3">\n  </span><span class="s1">missing: RouteHas[] = []</span><span class="s3">\n</span><span class="s1">): false | Params {</span><span class="s3">\n  </span><span class="s1">const params: Params = {}</span><span class="s3">\n\n  </span><span class="s1">const hasMatch = (hasItem: RouteHas) =&gt; {</span><span class="s3">\n    </span><span class="s1">let value</span><span class="s3">\n    </span><span class="s1">let key = hasItem.key</span><span class="s3">\n\n    </span><span class="s1">switch (hasItem.type) {</span><span class="s3">\n      </span><span class="s1">case 'header': {</span><span class="s3">\n        </span><span class="s1">key = key!.toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = req.headers[key] as string</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'cookie': {</span><span class="s3">\n        </span><span class="s1">if ('cookies' in req) {</span><span class="s3">\n          </span><span class="s1">value = req.cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const cookies = getCookieParser(req.headers)()</span><span class="s3">\n          </span><span class="s1">value = cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'query': {</span><span class="s3">\n        </span><span class="s1">value = query[key!]</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'host': {</span><span class="s3">\n        </span><span class="s1">const { host } = req?.headers || {}</span><span class="s3">\n        </span><span class="s1">// remove port from host if present</span><span class="s3">\n        </span><span class="s1">const hostname = host?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = hostname</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!hasItem.value &amp;&amp; value) {</span><span class="s3">\n      </span><span class="s1">params[getSafeParamName(key!)] = value</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">const matcher = new RegExp(`^${hasItem.value}$`)</span><span class="s3">\n      </span><span class="s1">const matches = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.slice(-1)[0].match(matcher)</span><span class="s3">\n        </span><span class="s1">: value.match(matcher)</span><span class="s3">\n\n      </span><span class="s1">if (matches) {</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(matches)) {</span><span class="s3">\n          </span><span class="s1">if (matches.groups) {</span><span class="s3">\n            </span><span class="s1">Object.keys(matches.groups).forEach((groupKey) =&gt; {</span><span class="s3">\n              </span><span class="s1">params[groupKey] = matches.groups![groupKey]</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">} else if (hasItem.type === 'host' &amp;&amp; matches[0]) {</span><span class="s3">\n            </span><span class="s1">params.host = matches[0]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const allMatch =</span><span class="s3">\n    </span><span class="s1">has.every((item) =&gt; hasMatch(item)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!missing.some((item) =&gt; hasMatch(item))</span><span class="s3">\n\n  </span><span class="s1">if (allMatch) {</span><span class="s3">\n    </span><span class="s1">return params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function compileNonPath(value: string, params: Params): string {</span><span class="s3">\n  </span><span class="s1">if (!value.includes(':')) {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(params)) {</span><span class="s3">\n    </span><span class="s1">if (value.includes(`:${key}`)) {</span><span class="s3">\n      </span><span class="s1">value = value</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">*`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_ASTERISKS`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">?`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_QUESTION`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}(?!</span><span class="s3">\\\\</span><span class="s1">w)`, 'g'),</span><span class="s3">\n          </span><span class="s1">`--ESCAPED_PARAM_COLON${key}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = value</span><span class="s3">\n    </span><span class="s1">.replace(/(:|</span><span class="s3">\\</span><span class="s1">*|</span><span class="s3">\\</span><span class="s1">?|</span><span class="s3">\\</span><span class="s1">+|</span><span class="s3">\\</span><span class="s1">(|</span><span class="s3">\\</span><span class="s1">)|</span><span class="s3">\\</span><span class="s1">{|</span><span class="s3">\\</span><span class="s1">})/g, '</span><span class="s3">\\\\</span><span class="s1">$1')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_PLUS/g, '+')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_COLON/g, ':')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_QUESTION/g, '?')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')</span><span class="s3">\n\n  </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n  </span><span class="s1">// correctly</span><span class="s3">\n  </span><span class="s1">return safeCompile(`/${value}`, { validate: false })(params).slice(1)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseDestination(args: {</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Readonly&lt;Params&gt;</span><span class="s3">\n  </span><span class="s1">query: Readonly&lt;NextParsedUrlQuery&gt;</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let escaped = args.destination</span><span class="s3">\n  </span><span class="s1">for (const param of Object.keys({ ...args.params, ...args.query })) {</span><span class="s3">\n    </span><span class="s1">if (!param) continue</span><span class="s3">\n\n    </span><span class="s1">escaped = escapeSegment(escaped, param)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsed = parseUrl(escaped)</span><span class="s3">\n\n  </span><span class="s1">let pathname = parsed.pathname</span><span class="s3">\n  </span><span class="s1">if (pathname) {</span><span class="s3">\n    </span><span class="s1">pathname = unescapeSegments(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let href = parsed.href</span><span class="s3">\n  </span><span class="s1">if (href) {</span><span class="s3">\n    </span><span class="s1">href = unescapeSegments(href)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hostname = parsed.hostname</span><span class="s3">\n  </span><span class="s1">if (hostname) {</span><span class="s3">\n    </span><span class="s1">hostname = unescapeSegments(hostname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hash = parsed.hash</span><span class="s3">\n  </span><span class="s1">if (hash) {</span><span class="s3">\n    </span><span class="s1">hash = unescapeSegments(hash)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let search = parsed.search</span><span class="s3">\n  </span><span class="s1">if (search) {</span><span class="s3">\n    </span><span class="s1">search = unescapeSegments(search)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...parsed,</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">hostname,</span><span class="s3">\n    </span><span class="s1">href,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">search,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function prepareDestination(args: {</span><span class="s3">\n  </span><span class="s1">appendParamsToQuery: boolean</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Params</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const parsedDestination = parseDestination(args)</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">hostname: destHostname,</span><span class="s3">\n    </span><span class="s1">query: destQuery,</span><span class="s3">\n    </span><span class="s1">search: destSearch,</span><span class="s3">\n  </span><span class="s1">} = parsedDestination</span><span class="s3">\n\n  </span><span class="s1">// The following code assumes that the pathname here includes the hash if it's</span><span class="s3">\n  </span><span class="s1">// present.</span><span class="s3">\n  </span><span class="s1">let destPath = parsedDestination.pathname</span><span class="s3">\n  </span><span class="s1">if (parsedDestination.hash) {</span><span class="s3">\n    </span><span class="s1">destPath = `${destPath}${parsedDestination.hash}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destParams: (string | number)[] = []</span><span class="s3">\n\n  </span><span class="s1">const destPathParamKeys: Key[] = []</span><span class="s3">\n  </span><span class="s1">safePathToRegexp(destPath, destPathParamKeys)</span><span class="s3">\n  </span><span class="s1">for (const key of destPathParamKeys) {</span><span class="s3">\n    </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">const destHostnameParamKeys: Key[] = []</span><span class="s3">\n    </span><span class="s1">safePathToRegexp(destHostname, destHostnameParamKeys)</span><span class="s3">\n    </span><span class="s1">for (const key of destHostnameParamKeys) {</span><span class="s3">\n      </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destPathCompiler = safeCompile(</span><span class="s3">\n    </span><span class="s1">destPath,</span><span class="s3">\n    </span><span class="s1">// we don't validate while compiling the destination since we should</span><span class="s3">\n    </span><span class="s1">// have already validated before we got to this point and validating</span><span class="s3">\n    </span><span class="s1">// breaks compiling destinations with named pattern params from the source</span><span class="s3">\n    </span><span class="s1">// e.g. /something:hello(.*) -&gt; /another/:hello is broken with validation</span><span class="s3">\n    </span><span class="s1">// since compile validation is meant for reversing and not for inserting</span><span class="s3">\n    </span><span class="s1">// params from a separate path-regex into another</span><span class="s3">\n    </span><span class="s1">{ validate: false }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let destHostnameCompiler</span><span class="s3">\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">destHostnameCompiler = safeCompile(destHostname, { validate: false })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// update any params in query values</span><span class="s3">\n  </span><span class="s1">for (const [key, strOrArray] of Object.entries(destQuery)) {</span><span class="s3">\n    </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n    </span><span class="s1">// correctly</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(strOrArray)) {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = strOrArray.map((value) =&gt;</span><span class="s3">\n        </span><span class="s1">compileNonPath(unescapeSegments(value), args.params)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (typeof strOrArray === 'string') {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add path params to query if it's not a redirect and not</span><span class="s3">\n  </span><span class="s1">// already defined in destination query or path</span><span class="s3">\n  </span><span class="s1">let paramKeys = Object.keys(args.params).filter(</span><span class="s3">\n    </span><span class="s1">(name) =&gt; name !== 'nextInternalLocale'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">args.appendParamsToQuery &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!paramKeys.some((key) =&gt; destParams.includes(key))</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const key of paramKeys) {</span><span class="s3">\n      </span><span class="s1">if (!(key in destQuery)) {</span><span class="s3">\n        </span><span class="s1">destQuery[key] = args.params[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let newUrl</span><span class="s3">\n\n  </span><span class="s1">// The compiler also that the interception route marker is an unnamed param, hence '0',</span><span class="s3">\n  </span><span class="s1">// so we need to add it to the params object.</span><span class="s3">\n  </span><span class="s1">if (isInterceptionRouteAppPath(destPath)) {</span><span class="s3">\n    </span><span class="s1">for (const segment of destPath.split('/')) {</span><span class="s3">\n      </span><span class="s1">const marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n        </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (marker) {</span><span class="s3">\n        </span><span class="s1">if (marker === '(..)(..)') {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = '(..)'</span><span class="s3">\n          </span><span class="s1">args.params['1'] = '(..)'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = marker</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">newUrl = destPathCompiler(args.params)</span><span class="s3">\n\n    </span><span class="s1">const [pathname, hash] = newUrl.split('#', 2)</span><span class="s3">\n    </span><span class="s1">if (destHostnameCompiler) {</span><span class="s3">\n      </span><span class="s1">parsedDestination.hostname = destHostnameCompiler(args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parsedDestination.pathname = pathname</span><span class="s3">\n    </span><span class="s1">parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`</span><span class="s3">\n    </span><span class="s1">parsedDestination.search = destSearch</span><span class="s3">\n      </span><span class="s1">? compileNonPath(destSearch, args.params)</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">if (err.message.match(/Expected .*? to not repeat, but got an array/)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`To use a multi-match in the destination you must add </span><span class="s3">\\</span><span class="s1">`*</span><span class="s3">\\</span><span class="s1">` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Query merge order lowest priority to highest</span><span class="s3">\n  </span><span class="s1">// 1. initial URL query values</span><span class="s3">\n  </span><span class="s1">// 2. path segment values</span><span class="s3">\n  </span><span class="s1">// 3. destination specified query values</span><span class="s3">\n  </span><span class="s1">parsedDestination.query = {</span><span class="s3">\n    </span><span class="s1">...args.query,</span><span class="s3">\n    </span><span class="s1">...parsedDestination.query,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">newUrl,</span><span class="s3">\n    </span><span class="s1">destQuery,</span><span class="s3">\n    </span><span class="s1">parsedDestination,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Node.js IncomingHttpHeaders object to a Headers object. Any</span><span class="s3">\n </span><span class="s1">* headers with multiple values will be joined with a comma and space. Any</span><span class="s3">\n </span><span class="s1">* headers that have an undefined value will be ignored and others will be</span><span class="s3">\n </span><span class="s1">* coerced to strings.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param nodeHeaders the headers object to convert</span><span class="s3">\n </span><span class="s1">* @returns the converted headers object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function fromNodeOutgoingHttpHeaders(</span><span class="s3">\n  </span><span class="s1">nodeHeaders: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">): Headers {</span><span class="s3">\n  </span><span class="s1">const headers = new Headers()</span><span class="s3">\n  </span><span class="s1">for (let [key, value] of Object.entries(nodeHeaders)) {</span><span class="s3">\n    </span><span class="s1">const values = Array.isArray(value) ? value : [value]</span><span class="s3">\n    </span><span class="s1">for (let v of values) {</span><span class="s3">\n      </span><span class="s1">if (typeof v === 'undefined') continue</span><span class="s3">\n      </span><span class="s1">if (typeof v === 'number') {</span><span class="s3">\n        </span><span class="s1">v = v.toString()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">headers.append(key, v)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return headers</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n  </span><span class="s1">Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas</span><span class="s3">\n  </span><span class="s1">that are within a single set-cookie field-value, such as in the Expires portion.</span><span class="s3">\n  </span><span class="s1">This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2</span><span class="s3">\n  </span><span class="s1">Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128</span><span class="s3">\n  </span><span class="s1">React Native's fetch does this for *every* header, including set-cookie.</span><span class="s3">\n  \n  </span><span class="s1">Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25</span><span class="s3">\n  </span><span class="s1">Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function splitCookiesString(cookiesString: string) {</span><span class="s3">\n  </span><span class="s1">var cookiesStrings = []</span><span class="s3">\n  </span><span class="s1">var pos = 0</span><span class="s3">\n  </span><span class="s1">var start</span><span class="s3">\n  </span><span class="s1">var ch</span><span class="s3">\n  </span><span class="s1">var lastComma</span><span class="s3">\n  </span><span class="s1">var nextStart</span><span class="s3">\n  </span><span class="s1">var cookiesSeparatorFound</span><span class="s3">\n\n  </span><span class="s1">function skipWhitespace() {</span><span class="s3">\n    </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(cookiesString.charAt(pos))) {</span><span class="s3">\n      </span><span class="s1">pos += 1</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos &lt; cookiesString.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function notSpecialChar() {</span><span class="s3">\n    </span><span class="s1">ch = cookiesString.charAt(pos)</span><span class="s3">\n\n    </span><span class="s1">return ch !== '=' &amp;&amp; ch !== ';' &amp;&amp; ch !== ','</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (pos &lt; cookiesString.length) {</span><span class="s3">\n    </span><span class="s1">start = pos</span><span class="s3">\n    </span><span class="s1">cookiesSeparatorFound = false</span><span class="s3">\n\n    </span><span class="s1">while (skipWhitespace()) {</span><span class="s3">\n      </span><span class="s1">ch = cookiesString.charAt(pos)</span><span class="s3">\n      </span><span class="s1">if (ch === ',') {</span><span class="s3">\n        </span><span class="s1">// ',' is a cookie separator if we have later first '=', not ';' or ','</span><span class="s3">\n        </span><span class="s1">lastComma = pos</span><span class="s3">\n        </span><span class="s1">pos += 1</span><span class="s3">\n\n        </span><span class="s1">skipWhitespace()</span><span class="s3">\n        </span><span class="s1">nextStart = pos</span><span class="s3">\n\n        </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; notSpecialChar()) {</span><span class="s3">\n          </span><span class="s1">pos += 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// currently special character</span><span class="s3">\n        </span><span class="s1">if (pos &lt; cookiesString.length &amp;&amp; cookiesString.charAt(pos) === '=') {</span><span class="s3">\n          </span><span class="s1">// we found cookies separator</span><span class="s3">\n          </span><span class="s1">cookiesSeparatorFound = true</span><span class="s3">\n          </span><span class="s1">// pos is inside the next cookie, so back up and return it.</span><span class="s3">\n          </span><span class="s1">pos = nextStart</span><span class="s3">\n          </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, lastComma))</span><span class="s3">\n          </span><span class="s1">start = pos</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// in param ',' or param separator ';',</span><span class="s3">\n          </span><span class="s1">// we continue from that comma</span><span class="s3">\n          </span><span class="s1">pos = lastComma + 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pos += 1</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!cookiesSeparatorFound || pos &gt;= cookiesString.length) {</span><span class="s3">\n      </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, cookiesString.length))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return cookiesStrings</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Headers object to a Node.js OutgoingHttpHeaders object. This is</span><span class="s3">\n </span><span class="s1">* required to support the set-cookie header, which may have multiple values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param headers the headers object to convert</span><span class="s3">\n </span><span class="s1">* @returns the converted headers object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function toNodeOutgoingHttpHeaders(</span><span class="s3">\n  </span><span class="s1">headers: Headers</span><span class="s3">\n</span><span class="s1">): OutgoingHttpHeaders {</span><span class="s3">\n  </span><span class="s1">const nodeHeaders: OutgoingHttpHeaders = {}</span><span class="s3">\n  </span><span class="s1">const cookies: string[] = []</span><span class="s3">\n  </span><span class="s1">if (headers) {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of headers.entries()) {</span><span class="s3">\n      </span><span class="s1">if (key.toLowerCase() === 'set-cookie') {</span><span class="s3">\n        </span><span class="s1">// We may have gotten a comma joined string of cookies, or multiple</span><span class="s3">\n        </span><span class="s1">// set-cookie headers. We need to merge them into one header array</span><span class="s3">\n        </span><span class="s1">// to represent all the cookies.</span><span class="s3">\n        </span><span class="s1">cookies.push(...splitCookiesString(value))</span><span class="s3">\n        </span><span class="s1">nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">nodeHeaders[key] = value</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return nodeHeaders</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Validate the correctness of a user-provided URL.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function validateURL(url: string | URL): string {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return String(new URL(String(url)))</span><span class="s3">\n  </span><span class="s1">} catch (error: any) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`URL is malformed </span><span class="s3">\&quot;</span><span class="s1">${String(</span><span class="s3">\n        </span><span class="s1">url</span><span class="s3">\n      </span><span class="s1">)}</span><span class="s3">\&quot;</span><span class="s1">. Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`,</span><span class="s3">\n      </span><span class="s1">{ cause: error }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes `nxtP` and `nxtI` query param values to remove the prefix.</span><span class="s3">\n </span><span class="s1">* This function does not mutate the input key.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeNextQueryParam(key: string): null | string {</span><span class="s3">\n  </span><span class="s1">const prefixes = [NEXT_QUERY_PARAM_PREFIX, NEXT_INTERCEPTION_MARKER_PREFIX]</span><span class="s3">\n  </span><span class="s1">for (const prefix of prefixes) {</span><span class="s3">\n    </span><span class="s1">if (key !== prefix &amp;&amp; key.startsWith(prefix)) {</span><span class="s3">\n      </span><span class="s1">return key.substring(prefix.length)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Decodes a query path parameter.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param value - The value to decode.</span><span class="s3">\n </span><span class="s1">* @returns The decoded value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function decodeQueryPathParameter(value: string) {</span><span class="s3">\n  </span><span class="s1">// When deployed to Vercel, the value may be encoded, so this attempts to</span><span class="s3">\n  </span><span class="s1">// decode it and returns the original value if it fails.</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return decodeURIComponent(value)</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Format function modified from nodejs</span><span class="s3">\n</span><span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span><span class="s3">\n</span><span class="s1">// copy of this software and associated documentation files (the</span><span class="s3">\n</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Software</span><span class="s3">\&quot;</span><span class="s1">), to deal in the Software without restriction, including</span><span class="s3">\n</span><span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span><span class="s3">\n</span><span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span><span class="s3">\n</span><span class="s1">// persons to whom the Software is furnished to do so, subject to the</span><span class="s3">\n</span><span class="s1">// following conditions:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The above copyright notice and this permission notice shall be included</span><span class="s3">\n</span><span class="s1">// in all copies or substantial portions of the Software.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot;</span><span class="s1">, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span><span class="s3">\n</span><span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span><span class="s3">\n</span><span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span><span class="s3">\n</span><span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span><span class="s3">\n</span><span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span><span class="s3">\n</span><span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span><span class="s3">\n</span><span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span><span class="s3">\n\n</span><span class="s1">import type { UrlObject } from 'url'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import * as querystring from './querystring'</span><span class="s3">\n\n</span><span class="s1">const slashedProtocols = /https?|ftp|gopher|file/</span><span class="s3">\n\n</span><span class="s1">export function formatUrl(urlObj: UrlObject) {</span><span class="s3">\n  </span><span class="s1">let { auth, hostname } = urlObj</span><span class="s3">\n  </span><span class="s1">let protocol = urlObj.protocol || ''</span><span class="s3">\n  </span><span class="s1">let pathname = urlObj.pathname || ''</span><span class="s3">\n  </span><span class="s1">let hash = urlObj.hash || ''</span><span class="s3">\n  </span><span class="s1">let query = urlObj.query || ''</span><span class="s3">\n  </span><span class="s1">let host: string | false = false</span><span class="s3">\n\n  </span><span class="s1">auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : ''</span><span class="s3">\n\n  </span><span class="s1">if (urlObj.host) {</span><span class="s3">\n    </span><span class="s1">host = auth + urlObj.host</span><span class="s3">\n  </span><span class="s1">} else if (hostname) {</span><span class="s3">\n    </span><span class="s1">host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname)</span><span class="s3">\n    </span><span class="s1">if (urlObj.port) {</span><span class="s3">\n      </span><span class="s1">host += ':' + urlObj.port</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (query &amp;&amp; typeof query === 'object') {</span><span class="s3">\n    </span><span class="s1">query = String(querystring.urlQueryToSearchParams(query as ParsedUrlQuery))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let search = urlObj.search || (query &amp;&amp; `?${query}`) || ''</span><span class="s3">\n\n  </span><span class="s1">if (protocol &amp;&amp; !protocol.endsWith(':')) protocol += ':'</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">urlObj.slashes ||</span><span class="s3">\n    </span><span class="s1">((!protocol || slashedProtocols.test(protocol)) &amp;&amp; host !== false)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">host = '//' + (host || '')</span><span class="s3">\n    </span><span class="s1">if (pathname &amp;&amp; pathname[0] !== '/') pathname = '/' + pathname</span><span class="s3">\n  </span><span class="s1">} else if (!host) {</span><span class="s3">\n    </span><span class="s1">host = ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (hash &amp;&amp; hash[0] !== '#') hash = '#' + hash</span><span class="s3">\n  </span><span class="s1">if (search &amp;&amp; search[0] !== '?') search = '?' + search</span><span class="s3">\n\n  </span><span class="s1">pathname = pathname.replace(/[?#]/g, encodeURIComponent)</span><span class="s3">\n  </span><span class="s1">search = search.replace('#', '%23')</span><span class="s3">\n\n  </span><span class="s1">return `${protocol}${host}${pathname}${search}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const urlObjectKeys = [</span><span class="s3">\n  </span><span class="s1">'auth',</span><span class="s3">\n  </span><span class="s1">'hash',</span><span class="s3">\n  </span><span class="s1">'host',</span><span class="s3">\n  </span><span class="s1">'hostname',</span><span class="s3">\n  </span><span class="s1">'href',</span><span class="s3">\n  </span><span class="s1">'path',</span><span class="s3">\n  </span><span class="s1">'pathname',</span><span class="s3">\n  </span><span class="s1">'port',</span><span class="s3">\n  </span><span class="s1">'protocol',</span><span class="s3">\n  </span><span class="s1">'query',</span><span class="s3">\n  </span><span class="s1">'search',</span><span class="s3">\n  </span><span class="s1">'slashes',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export function formatWithValidation(url: UrlObject): string {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">if (url !== null &amp;&amp; typeof url === 'object') {</span><span class="s3">\n      </span><span class="s1">Object.keys(url).forEach((key) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!urlObjectKeys.includes(key)) {</span><span class="s3">\n          </span><span class="s1">console.warn(</span><span class="s3">\n            </span><span class="s1">`Unknown key passed via urlObject into url.format: ${key}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return formatUrl(url)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { LoadComponentsReturnType } from '../load-components'</span><span class="s3">\n</span><span class="s1">import type { ServerRuntime, SizeLimit } from '../../types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ExperimentalConfig,</span><span class="s3">\n  </span><span class="s1">NextConfigComplete,</span><span class="s3">\n</span><span class="s1">} from '../../server/config-shared'</span><span class="s3">\n</span><span class="s1">import type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { AppPageModule } from '../route-modules/app-page/module'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HeadData,</span><span class="s3">\n  </span><span class="s1">LoadingModuleData,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../api-utils'</span><span class="s3">\n\n</span><span class="s1">import s from 'next/dist/compiled/superstruct'</span><span class="s3">\n</span><span class="s1">import type { RequestLifecycleOpts } from '../base-server'</span><span class="s3">\n</span><span class="s1">import type { InstrumentationOnRequestError } from '../instrumentation/types'</span><span class="s3">\n</span><span class="s1">import type { NextRequestHint } from '../web/adapter'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'</span><span class="s3">\n\n</span><span class="s1">export type DynamicParamTypes =</span><span class="s3">\n  </span><span class="s1">| 'catchall'</span><span class="s3">\n  </span><span class="s1">| 'catchall-intercepted'</span><span class="s3">\n  </span><span class="s1">| 'optional-catchall'</span><span class="s3">\n  </span><span class="s1">| 'dynamic'</span><span class="s3">\n  </span><span class="s1">| 'dynamic-intercepted'</span><span class="s3">\n\n</span><span class="s1">const dynamicParamTypesSchema = s.enums(['c', 'ci', 'oc', 'd', 'di'])</span><span class="s3">\n\n</span><span class="s1">export type DynamicParamTypesShort = s.Infer&lt;typeof dynamicParamTypesSchema&gt;</span><span class="s3">\n\n</span><span class="s1">const segmentSchema = s.union([</span><span class="s3">\n  </span><span class="s1">s.string(),</span><span class="s3">\n\n  </span><span class="s1">s.tuple([</span><span class="s3">\n    </span><span class="s1">// Param name</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">// Param cache key (almost the same as the value, but arrays are</span><span class="s3">\n    </span><span class="s1">// concatenated into strings)</span><span class="s3">\n    </span><span class="s1">// TODO: We should change this to just be the value. Currently we convert</span><span class="s3">\n    </span><span class="s1">// it back to a value when passing to useParams. It only needs to be</span><span class="s3">\n    </span><span class="s1">// a string when converted to a a cache key, but that doesn't mean we</span><span class="s3">\n    </span><span class="s1">// need to store it as that representation.</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">// Dynamic param type</span><span class="s3">\n    </span><span class="s1">dynamicParamTypesSchema,</span><span class="s3">\n  </span><span class="s1">]),</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">export type Segment = s.Infer&lt;typeof segmentSchema&gt;</span><span class="s3">\n\n</span><span class="s1">// unfortunately the tuple is not understood well by Describe so we have to</span><span class="s3">\n</span><span class="s1">// use any here. This does not have any impact on the runtime type since the validation</span><span class="s3">\n</span><span class="s1">// does work correctly.</span><span class="s3">\n</span><span class="s1">export const flightRouterStateSchema: s.Describe&lt;any&gt; = s.tuple([</span><span class="s3">\n  </span><span class="s1">segmentSchema,</span><span class="s3">\n  </span><span class="s1">s.record(</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">s.lazy(() =&gt; flightRouterStateSchema)</span><span class="s3">\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">s.optional(s.nullable(s.string())),</span><span class="s3">\n  </span><span class="s1">s.optional(</span><span class="s3">\n    </span><span class="s1">s.nullable(</span><span class="s3">\n      </span><span class="s1">s.union([</span><span class="s3">\n        </span><span class="s1">s.literal('refetch'),</span><span class="s3">\n        </span><span class="s1">s.literal('refresh'),</span><span class="s3">\n        </span><span class="s1">s.literal('inside-shared-layout'),</span><span class="s3">\n        </span><span class="s1">s.literal('metadata-only'),</span><span class="s3">\n      </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">s.optional(s.boolean()),</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Router state</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightRouterState = [</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },</span><span class="s3">\n  </span><span class="s1">url?: string | null,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">refetch</span><span class="s3">\&quot;</span><span class="s1">, despite being similarly named, have different</span><span class="s3">\n   </span><span class="s1">* semantics:</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">refetch</span><span class="s3">\&quot; </span><span class="s1">is used during a request to inform the server where rendering</span><span class="s3">\n   </span><span class="s1">*   should start from.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot; </span><span class="s1">is used by the client to mark that a segment should re-fetch the</span><span class="s3">\n   </span><span class="s1">*   data from the server for the current segment. It uses the </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">property</span><span class="s3">\n   </span><span class="s1">*   above to determine where to fetch from.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">inside-shared-layout</span><span class="s3">\&quot; </span><span class="s1">is used during a prefetch request to inform the</span><span class="s3">\n   </span><span class="s1">*   server that even if the segment matches, it should be treated as if it's</span><span class="s3">\n   </span><span class="s1">*   within the </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">part of a navigation  inside the shared layout. If</span><span class="s3">\n   </span><span class="s1">*   the segment doesn't match, then it has no effect, since it would be</span><span class="s3">\n   </span><span class="s1">*   treated as new regardless. If it does match, though, the server does not</span><span class="s3">\n   </span><span class="s1">*   need to render it, because the client already has it.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">metadata-only</span><span class="s3">\&quot; </span><span class="s1">instructs the server to skip rendering the segments and</span><span class="s3">\n   </span><span class="s1">*   only send the head data.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   A bit confusing, but that's because it has only one extremely narrow use</span><span class="s3">\n   </span><span class="s1">*   case  during a non-PPR prefetch, the server uses it to find the first</span><span class="s3">\n   </span><span class="s1">*   loading boundary beneath a shared layout.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   TODO: We should rethink the protocol for dynamic requests. It might not</span><span class="s3">\n   </span><span class="s1">*   make sense for the client to send a FlightRouterState, since this type is</span><span class="s3">\n   </span><span class="s1">*   overloaded with concerns.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">refresh?:</span><span class="s3">\n    </span><span class="s1">| 'refetch'</span><span class="s3">\n    </span><span class="s1">| 'refresh'</span><span class="s3">\n    </span><span class="s1">| 'inside-shared-layout'</span><span class="s3">\n    </span><span class="s1">| 'metadata-only'</span><span class="s3">\n    </span><span class="s1">| null,</span><span class="s3">\n  </span><span class="s1">isRootLayout?: boolean,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Only present when responding to a tree prefetch request. Indicates whether</span><span class="s3">\n   </span><span class="s1">* there is a loading boundary somewhere in the tree. The client cache uses</span><span class="s3">\n   </span><span class="s1">* this to determine if it can skip the data prefetch request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasLoadingBoundary?: HasLoadingBoundary,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export const enum HasLoadingBoundary {</span><span class="s3">\n  </span><span class="s1">// There is a loading boundary in this particular segment</span><span class="s3">\n  </span><span class="s1">SegmentHasLoadingBoundary = 1,</span><span class="s3">\n  </span><span class="s1">// There is a loading boundary somewhere in the subtree (but not in</span><span class="s3">\n  </span><span class="s1">// this segment)</span><span class="s3">\n  </span><span class="s1">SubtreeHasLoadingBoundary = 2,</span><span class="s3">\n  </span><span class="s1">// There is no loading boundary in this segment or any of its descendants</span><span class="s3">\n  </span><span class="s1">SubtreeHasNoLoadingBoundary = 3,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Individual Flight response path</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightSegmentPath =</span><span class="s3">\n  </span><span class="s1">// Uses `any` as repeating pattern can't be typed.</span><span class="s3">\n  </span><span class="s1">| any[]</span><span class="s3">\n  </span><span class="s1">// Looks somewhat like this</span><span class="s3">\n  </span><span class="s1">| [</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Represents a tree of segments and the Flight data (i.e. React nodes) that</span><span class="s3">\n </span><span class="s1">* correspond to each one. The tree is isomorphic to the FlightRouterState;</span><span class="s3">\n </span><span class="s1">* however in the future we want to be able to fetch arbitrary partial segments</span><span class="s3">\n </span><span class="s1">* without having to fetch all its children. So this response format will</span><span class="s3">\n </span><span class="s1">* likely change.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type CacheNodeSeedData = [</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">node: React.ReactNode | null,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: {</span><span class="s3">\n    </span><span class="s1">[parallelRouterKey: string]: CacheNodeSeedData | null</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;,</span><span class="s3">\n  </span><span class="s1">isPartial: boolean,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type FlightDataSegment = [</span><span class="s3">\n  </span><span class="s1">/* segment of the rendered slice: */ Segment,</span><span class="s3">\n  </span><span class="s1">/* treePatch */ FlightRouterState,</span><span class="s3">\n  </span><span class="s1">/* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component</span><span class="s3">\n  </span><span class="s1">/* head: viewport */ HeadData,</span><span class="s3">\n  </span><span class="s1">/* isHeadPartial */ boolean,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type FlightDataPath =</span><span class="s3">\n  </span><span class="s1">// Uses `any` as repeating pattern can't be typed.</span><span class="s3">\n  </span><span class="s1">| any[]</span><span class="s3">\n  </span><span class="s1">// Looks somewhat like this</span><span class="s3">\n  </span><span class="s1">| [</span><span class="s3">\n      </span><span class="s1">// Holds full path to the segment.</span><span class="s3">\n      </span><span class="s1">...FlightSegmentPath[],</span><span class="s3">\n      </span><span class="s1">...FlightDataSegment,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Flight response data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightData = Array&lt;FlightDataPath&gt; | string</span><span class="s3">\n\n</span><span class="s1">export type ActionResult = Promise&lt;any&gt;</span><span class="s3">\n\n</span><span class="s1">export type ServerOnInstrumentationRequestError = (</span><span class="s3">\n  </span><span class="s1">error: unknown,</span><span class="s3">\n  </span><span class="s1">// The request could be middleware, node server or web server request,</span><span class="s3">\n  </span><span class="s1">// we normalized them into an aligned format to `onRequestError` API later.</span><span class="s3">\n  </span><span class="s1">request: NextRequestHint | BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">errorContext: Parameters&lt;InstrumentationOnRequestError&gt;[2]</span><span class="s3">\n</span><span class="s1">) =&gt; void | Promise&lt;void&gt;</span><span class="s3">\n\n</span><span class="s1">export interface RenderOptsPartial {</span><span class="s3">\n  </span><span class="s1">dir?: string</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps | undefined</span><span class="s3">\n  </span><span class="s1">err?: Error | null</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">trailingSlash: boolean</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest?: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">supportsDynamicResponse: boolean</span><span class="s3">\n  </span><span class="s1">runtime?: ServerRuntime</span><span class="s3">\n  </span><span class="s1">serverComponents?: boolean</span><span class="s3">\n  </span><span class="s1">enableTainting?: boolean</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined</span><span class="s3">\n  </span><span class="s1">nextFontManifest?: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n  </span><span class="s1">botType?: 'dom' | 'html' | undefined</span><span class="s3">\n  </span><span class="s1">serveStreamingMetadata?: boolean</span><span class="s3">\n  </span><span class="s1">incrementalCache?: import('../lib/incremental-cache').IncrementalCache</span><span class="s3">\n  </span><span class="s1">cacheLifeProfiles?: {</span><span class="s3">\n    </span><span class="s1">[profile: string]: import('../use-cache/cache-life').CacheLife</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction?: boolean</span><span class="s3">\n  </span><span class="s1">setIsrStatus?: (key: string, value: boolean | null) =&gt; void</span><span class="s3">\n  </span><span class="s1">isRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">nextExport?: boolean</span><span class="s3">\n  </span><span class="s1">nextConfigOutput?: 'standalone' | 'export'</span><span class="s3">\n  </span><span class="s1">onInstrumentationRequestError?: ServerOnInstrumentationRequestError</span><span class="s3">\n  </span><span class="s1">isDraftMode?: boolean</span><span class="s3">\n  </span><span class="s1">deploymentId?: string</span><span class="s3">\n  </span><span class="s1">onUpdateCookies?: (cookies: string[]) =&gt; void</span><span class="s3">\n  </span><span class="s1">loadConfig?: (</span><span class="s3">\n    </span><span class="s1">phase: string,</span><span class="s3">\n    </span><span class="s1">dir: string,</span><span class="s3">\n    </span><span class="s1">customConfig?: object | null,</span><span class="s3">\n    </span><span class="s1">rawConfig?: boolean,</span><span class="s3">\n    </span><span class="s1">silent?: boolean</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;NextConfigComplete&gt;</span><span class="s3">\n  </span><span class="s1">serverActions?: {</span><span class="s3">\n    </span><span class="s1">bodySizeLimit?: SizeLimit</span><span class="s3">\n    </span><span class="s1">allowedOrigins?: string[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n  </span><span class="s1">htmlLimitedBots: string | undefined</span><span class="s3">\n  </span><span class="s1">experimental: {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When true, it indicates that the current page supports partial</span><span class="s3">\n     </span><span class="s1">* prerendering.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">expireTime: number | undefined</span><span class="s3">\n    </span><span class="s1">staleTimes: ExperimentalConfig['staleTimes'] | undefined</span><span class="s3">\n    </span><span class="s1">clientTraceMetadata: string[] | undefined</span><span class="s3">\n    </span><span class="s1">cacheComponents: boolean</span><span class="s3">\n    </span><span class="s1">clientSegmentCache: boolean | 'client-only'</span><span class="s3">\n    </span><span class="s1">clientParamParsing: boolean</span><span class="s3">\n    </span><span class="s1">dynamicOnHover: boolean</span><span class="s3">\n    </span><span class="s1">inlineCss: boolean</span><span class="s3">\n    </span><span class="s1">authInterrupts: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Should wait for react stream allReady to resolve all suspense boundaries,</span><span class="s3">\n   </span><span class="s1">* in order to perform a full page render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">shouldWaitOnAllReady?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A prefilled resume data cache. This was either generated for this page</span><span class="s3">\n   </span><span class="s1">* during dev warmup, or when a page with defined params was previously</span><span class="s3">\n   </span><span class="s1">* prerendered, and now its matching optional fallback shell is prerendered.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, the page will be rendered using the static rendering to detect</span><span class="s3">\n   </span><span class="s1">* any dynamic API's that would have stopped the page from being fully</span><span class="s3">\n   </span><span class="s1">* statically generated.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isDebugDynamicAccesses?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is true when:</span><span class="s3">\n   </span><span class="s1">* - source maps are generated</span><span class="s3">\n   </span><span class="s1">* - source maps are applied</span><span class="s3">\n   </span><span class="s1">* - minification is disabled</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasReadableErrorStacks?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The maximum length of the headers that are emitted by React and added to</span><span class="s3">\n   </span><span class="s1">* the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">reactMaxHeadersLength: number | undefined</span><span class="s3">\n\n  </span><span class="s1">isStaticGeneration?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, the page is prerendered as a fallback shell, while allowing any</span><span class="s3">\n   </span><span class="s1">* dynamic accesses to result in an empty shell. This is the case when there</span><span class="s3">\n   </span><span class="s1">* are also routes prerendered with a more complete set of params.</span><span class="s3">\n   </span><span class="s1">* Prerendering those routes would catch any invalid dynamic accesses.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">allowEmptyStaticShell?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* next config experimental.devtoolSegmentExplorer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">devtoolSegmentExplorer?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderOpts = LoadComponentsReturnType&lt;AppPageModule&gt; &amp;</span><span class="s3">\n  </span><span class="s1">RenderOptsPartial &amp;</span><span class="s3">\n  </span><span class="s1">RequestLifecycleOpts</span><span class="s3">\n\n</span><span class="s1">export type PreloadCallbacks = (() =&gt; void)[]</span><span class="s3">\n\n</span><span class="s1">export type InitialRSCPayload = {</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** assetPrefix */</span><span class="s3">\n  </span><span class="s1">p: string</span><span class="s3">\n  </span><span class="s1">/** initialCanonicalUrlParts */</span><span class="s3">\n  </span><span class="s1">c: string[]</span><span class="s3">\n  </span><span class="s1">/** couldBeIntercepted */</span><span class="s3">\n  </span><span class="s1">i: boolean</span><span class="s3">\n  </span><span class="s1">/** initialFlightData */</span><span class="s3">\n  </span><span class="s1">f: FlightDataPath[]</span><span class="s3">\n  </span><span class="s1">/** missingSlots */</span><span class="s3">\n  </span><span class="s1">m: Set&lt;string&gt; | undefined</span><span class="s3">\n  </span><span class="s1">/** GlobalError */</span><span class="s3">\n  </span><span class="s1">G: [React.ComponentType&lt;any&gt;, React.ReactNode | undefined]</span><span class="s3">\n  </span><span class="s1">/** postponed */</span><span class="s3">\n  </span><span class="s1">s: boolean</span><span class="s3">\n  </span><span class="s1">/** prerendered */</span><span class="s3">\n  </span><span class="s1">S: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Response from `createFromFetch` for normal rendering</span><span class="s3">\n</span><span class="s1">export type NavigationFlightResponse = {</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** flightData */</span><span class="s3">\n  </span><span class="s1">f: FlightData</span><span class="s3">\n  </span><span class="s1">/** prerendered */</span><span class="s3">\n  </span><span class="s1">S: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Response from `createFromFetch` for server actions. Action's flight data can be null</span><span class="s3">\n</span><span class="s1">export type ActionFlightResponse = {</span><span class="s3">\n  </span><span class="s1">/** actionResult */</span><span class="s3">\n  </span><span class="s1">a: ActionResult</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** flightData */</span><span class="s3">\n  </span><span class="s1">f: FlightData</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RSCPayload =</span><span class="s3">\n  </span><span class="s1">| InitialRSCPayload</span><span class="s3">\n  </span><span class="s1">| NavigationFlightResponse</span><span class="s3">\n  </span><span class="s1">| ActionFlightResponse</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const RSC_HEADER = 'rsc' as const</span><span class="s3">\n</span><span class="s1">export const ACTION_HEADER = 'next-action' as const</span><span class="s3">\n</span><span class="s1">// TODO: Instead of sending the full router state, we only need to send the</span><span class="s3">\n</span><span class="s1">// segment path. Saves bytes. Then we could also use this field for segment</span><span class="s3">\n</span><span class="s1">// prefetches, which also need to specify a particular segment.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const</span><span class="s3">\n</span><span class="s1">// This contains the path to the segment being prefetched.</span><span class="s3">\n</span><span class="s1">// TODO: If we change next-router-state-tree to be a segment path, we can use</span><span class="s3">\n</span><span class="s1">// that instead. Then next-router-prefetch and next-router-segment-prefetch can</span><span class="s3">\n</span><span class="s1">// be merged into a single enum.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =</span><span class="s3">\n  </span><span class="s1">'next-router-segment-prefetch' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_URL = 'next-url' as const</span><span class="s3">\n</span><span class="s1">export const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const</span><span class="s3">\n\n</span><span class="s1">export const FLIGHT_HEADERS = [</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_HMR_REFRESH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_RSC_UNION_QUERY = '_rsc' as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { NEXT_URL } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Rewrite } from './load-custom-routes'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp } from '../shared/lib/router/utils/route-match-utils'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)</span><span class="s3">\n</span><span class="s1">function toPathToRegexpPath(path: string): string {</span><span class="s3">\n  </span><span class="s1">return path.replace(/</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">[?([^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">]?/g, (_, capture) =&gt; {</span><span class="s3">\n    </span><span class="s1">// path-to-regexp only supports word characters, so we replace any non-word characters with underscores</span><span class="s3">\n    </span><span class="s1">const paramName = capture.replace(/</span><span class="s3">\\</span><span class="s1">W+/g, '_')</span><span class="s3">\n\n    </span><span class="s1">// handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])</span><span class="s3">\n    </span><span class="s1">if (capture.startsWith('...')) {</span><span class="s3">\n      </span><span class="s1">return `:${capture.slice(3)}*`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ':' + paramName</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateInterceptionRoutesRewrites(</span><span class="s3">\n  </span><span class="s1">appPaths: string[],</span><span class="s3">\n  </span><span class="s1">basePath = ''</span><span class="s3">\n</span><span class="s1">): Rewrite[] {</span><span class="s3">\n  </span><span class="s1">const rewrites: Rewrite[] = []</span><span class="s3">\n\n  </span><span class="s1">for (const appPath of appPaths) {</span><span class="s3">\n    </span><span class="s1">if (isInterceptionRouteAppPath(appPath)) {</span><span class="s3">\n      </span><span class="s1">const { interceptingRoute, interceptedRoute } =</span><span class="s3">\n        </span><span class="s1">extractInterceptionRouteInformation(appPath)</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptingRoute = `${</span><span class="s3">\n        </span><span class="s1">interceptingRoute !== '/' ? toPathToRegexpPath(interceptingRoute) : ''</span><span class="s3">\n      </span><span class="s1">}/(.*)?`</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute)</span><span class="s3">\n      </span><span class="s1">const normalizedAppPath = toPathToRegexpPath(appPath)</span><span class="s3">\n\n      </span><span class="s1">// pathToRegexp returns a regex that matches the path, but we need to</span><span class="s3">\n      </span><span class="s1">// convert it to a string that can be used in a header value</span><span class="s3">\n      </span><span class="s1">// to the format that Next/the proxy expects</span><span class="s3">\n      </span><span class="s1">let interceptingRouteRegex = safePathToRegexp(normalizedInterceptingRoute)</span><span class="s3">\n        </span><span class="s1">.toString()</span><span class="s3">\n        </span><span class="s1">.slice(2, -3)</span><span class="s3">\n\n      </span><span class="s1">rewrites.push({</span><span class="s3">\n        </span><span class="s1">source: `${basePath}${normalizedInterceptedRoute}`,</span><span class="s3">\n        </span><span class="s1">destination: `${basePath}${normalizedAppPath}`,</span><span class="s3">\n        </span><span class="s1">has: [</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">type: 'header',</span><span class="s3">\n            </span><span class="s1">key: NEXT_URL,</span><span class="s3">\n            </span><span class="s1">value: interceptingRouteRegex,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">],</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return rewrites</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteRewrite(route: DeepReadonly&lt;Rewrite&gt;) {</span><span class="s3">\n  </span><span class="s1">// When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.</span><span class="s3">\n  </span><span class="s1">return route.has?.[0]?.key === NEXT_URL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Rewrite } from '../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { RouteMatchFn } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import type { NextConfig } from './config'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n\n</span><span class="s1">import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { getPathMatch } from '../shared/lib/router/utils/path-match'</span><span class="s3">\n</span><span class="s1">import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'</span><span class="s3">\n</span><span class="s1">import { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">matchHas,</span><span class="s3">\n  </span><span class="s1">prepareDestination,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/prepare-destination'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { normalizeRscURL } from '../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATED_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import { normalizeNextQueryParam } from './web/utils'</span><span class="s3">\n</span><span class="s1">import type { IncomingHttpHeaders, IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import { parseReqUrl } from '../lib/url'</span><span class="s3">\n</span><span class="s1">import { formatUrl } from '../shared/lib/router/utils/format-url'</span><span class="s3">\n</span><span class="s1">import { parseAndValidateFlightRouterState } from './app-render/parse-and-validate-flight-router-state'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites'</span><span class="s3">\n</span><span class="s1">import { NEXT_ROUTER_STATE_TREE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { getSelectedParams } from '../client/components/router-reducer/compute-changed-path'</span><span class="s3">\n\n</span><span class="s1">function filterInternalQuery(</span><span class="s3">\n  </span><span class="s1">query: Record&lt;string, undefined | string | string[]&gt;,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n  </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n  </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n  </span><span class="s1">for (const key in query) {</span><span class="s3">\n    </span><span class="s1">const isNextQueryPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_QUERY_PARAM_PREFIX &amp;&amp; key.startsWith(NEXT_QUERY_PARAM_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">const isNextInterceptionMarkerPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_INTERCEPTION_MARKER_PREFIX &amp;&amp;</span><span class="s3">\n      </span><span class="s1">key.startsWith(NEXT_INTERCEPTION_MARKER_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isNextQueryPrefix ||</span><span class="s3">\n      </span><span class="s1">isNextInterceptionMarkerPrefix ||</span><span class="s3">\n      </span><span class="s1">paramKeys.includes(key)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeCdnUrl(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// make sure to normalize req.url from CDNs to strip dynamic and rewrite</span><span class="s3">\n  </span><span class="s1">// params from the query which are added during routing</span><span class="s3">\n  </span><span class="s1">const _parsedUrl = parseReqUrl(req.url!)</span><span class="s3">\n\n  </span><span class="s1">// we can't normalize if we can't parse</span><span class="s3">\n  </span><span class="s1">if (!_parsedUrl) {</span><span class="s3">\n    </span><span class="s1">return req.url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">delete (_parsedUrl as any).search</span><span class="s3">\n  </span><span class="s1">filterInternalQuery(_parsedUrl.query, paramKeys)</span><span class="s3">\n\n  </span><span class="s1">req.url = formatUrl(_parsedUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function interpolateDynamicPath(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">params: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex?: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!defaultRouteRegex) return pathname</span><span class="s3">\n\n  </span><span class="s1">for (const param of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">const { optional, repeat } = defaultRouteRegex.groups[param]</span><span class="s3">\n    </span><span class="s1">let builtParam = `[${repeat ? '...' : ''}${param}]`</span><span class="s3">\n\n    </span><span class="s1">if (optional) {</span><span class="s3">\n      </span><span class="s1">builtParam = `[${builtParam}]`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let paramValue: string</span><span class="s3">\n    </span><span class="s1">const value = params[param]</span><span class="s3">\n\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">paramValue = value.map((v) =&gt; v &amp;&amp; encodeURIComponent(v)).join('/')</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">paramValue = encodeURIComponent(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">paramValue = ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (paramValue || optional) {</span><span class="s3">\n      </span><span class="s1">pathname = pathname.replaceAll(builtParam, paramValue)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeDynamicRouteParams(</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt;,</span><span class="s3">\n  </span><span class="s1">defaultRouteMatches: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let hasValidParams = true</span><span class="s3">\n  </span><span class="s1">let params: ParsedUrlQuery = {}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">let value: string | string[] | undefined = query[key]</span><span class="s3">\n\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">value = normalizeRscURL(value)</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">value = value.map(normalizeRscURL)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the value matches the default value we can't rely</span><span class="s3">\n    </span><span class="s1">// on the parsed params, this is used to signal if we need</span><span class="s3">\n    </span><span class="s1">// to parse x-now-route-matches or not</span><span class="s3">\n    </span><span class="s1">const defaultValue = defaultRouteMatches![key]</span><span class="s3">\n    </span><span class="s1">const isOptional = defaultRouteRegex!.groups[key].optional</span><span class="s3">\n\n    </span><span class="s1">const isDefaultValue = Array.isArray(defaultValue)</span><span class="s3">\n      </span><span class="s1">? defaultValue.some((defaultVal) =&gt; {</span><span class="s3">\n          </span><span class="s1">return Array.isArray(value)</span><span class="s3">\n            </span><span class="s1">? value.some((val) =&gt; val.includes(defaultVal))</span><span class="s3">\n            </span><span class="s1">: value?.includes(defaultVal)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">: value?.includes(defaultValue as string)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isDefaultValue ||</span><span class="s3">\n      </span><span class="s1">(typeof value === 'undefined' &amp;&amp; !(isOptional &amp;&amp; ignoreMissingOptional))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// non-provided optional values should be undefined so normalize</span><span class="s3">\n    </span><span class="s1">// them to undefined</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isOptional &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!value ||</span><span class="s3">\n        </span><span class="s1">(Array.isArray(value) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">value.length === 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// fallback optional catch-all SSG pages have</span><span class="s3">\n          </span><span class="s1">// [[...paramName]] for the root path on Vercel</span><span class="s3">\n          </span><span class="s1">(value[0] === 'index' || value[0] === `[[...${key}]]`)))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = undefined</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// query values from the proxy aren't already split into arrays</span><span class="s3">\n    </span><span class="s1">// so make sure to normalize catch-all values</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">value &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof value === 'string' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">defaultRouteRegex!.groups[key].repeat</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = value.split('/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (value) {</span><span class="s3">\n      </span><span class="s1">params[key] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">hasValidParams,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getServerUtils({</span><span class="s3">\n  </span><span class="s1">page,</span><span class="s3">\n  </span><span class="s1">i18n,</span><span class="s3">\n  </span><span class="s1">basePath,</span><span class="s3">\n  </span><span class="s1">rewrites,</span><span class="s3">\n  </span><span class="s1">pageIsDynamic,</span><span class="s3">\n  </span><span class="s1">trailingSlash,</span><span class="s3">\n  </span><span class="s1">caseSensitive,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">i18n?: NextConfig['i18n']</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">rewrites: DeepReadonly&lt;{</span><span class="s3">\n    </span><span class="s1">fallback?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">afterFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">beforeFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n  </span><span class="s1">pageIsDynamic: boolean</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">caseSensitive: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n  </span><span class="s1">let dynamicRouteMatcher: RouteMatchFn | undefined</span><span class="s3">\n  </span><span class="s1">let defaultRouteMatches: ParsedUrlQuery | undefined</span><span class="s3">\n\n  </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex = getNamedRouteRegex(page, {</span><span class="s3">\n      </span><span class="s1">prefixRouteKeys: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleRewrites(</span><span class="s3">\n    </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const rewriteParams: Record&lt;string, string&gt; = {}</span><span class="s3">\n    </span><span class="s1">let fsPathname = parsedUrl.pathname</span><span class="s3">\n\n    </span><span class="s1">const matchesPage = () =&gt; {</span><span class="s3">\n      </span><span class="s1">const fsPathnameNoSlash = removeTrailingSlash(fsPathname || '')</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">fsPathnameNoSlash === removeTrailingSlash(page) ||</span><span class="s3">\n        </span><span class="s1">dynamicRouteMatcher?.(fsPathnameNoSlash)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const checkRewrite = (rewrite: DeepReadonly&lt;Rewrite&gt;): boolean =&gt; {</span><span class="s3">\n      </span><span class="s1">const matcher = getPathMatch(</span><span class="s3">\n        </span><span class="s1">rewrite.source + (trailingSlash ? '(/)?' : ''),</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">removeUnnamedParams: true,</span><span class="s3">\n          </span><span class="s1">strict: true,</span><span class="s3">\n          </span><span class="s1">sensitive: !!caseSensitive,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (!parsedUrl.pathname) return false</span><span class="s3">\n\n      </span><span class="s1">let params = matcher(parsedUrl.pathname)</span><span class="s3">\n\n      </span><span class="s1">if ((rewrite.has || rewrite.missing) &amp;&amp; params) {</span><span class="s3">\n        </span><span class="s1">const hasParams = matchHas(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">parsedUrl.query,</span><span class="s3">\n          </span><span class="s1">rewrite.has as Rewrite['has'],</span><span class="s3">\n          </span><span class="s1">rewrite.missing as Rewrite['missing']</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (hasParams) {</span><span class="s3">\n          </span><span class="s1">Object.assign(params, hasParams)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (params) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">// An interception rewrite might reference a dynamic param for a route the user</span><span class="s3">\n          </span><span class="s1">// is currently on, which wouldn't be extractable from the matched route params.</span><span class="s3">\n          </span><span class="s1">// This attempts to extract the dynamic params from the provided router state.</span><span class="s3">\n          </span><span class="s1">if (isInterceptionRouteRewrite(rewrite as Rewrite)) {</span><span class="s3">\n            </span><span class="s1">const stateHeader = req.headers[NEXT_ROUTER_STATE_TREE_HEADER]</span><span class="s3">\n\n            </span><span class="s1">if (stateHeader) {</span><span class="s3">\n              </span><span class="s1">params = {</span><span class="s3">\n                </span><span class="s1">...getSelectedParams(</span><span class="s3">\n                  </span><span class="s1">parseAndValidateFlightRouterState(stateHeader)</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">...params,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">// this is a no-op -- we couldn't extract dynamic params from the provided router state,</span><span class="s3">\n          </span><span class="s1">// so we'll just use the params from the route matcher</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const { parsedDestination, destQuery } = prepareDestination({</span><span class="s3">\n          </span><span class="s1">appendParamsToQuery: true,</span><span class="s3">\n          </span><span class="s1">destination: rewrite.destination,</span><span class="s3">\n          </span><span class="s1">params: params,</span><span class="s3">\n          </span><span class="s1">query: parsedUrl.query,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">// if the rewrite destination is external break rewrite chain</span><span class="s3">\n        </span><span class="s1">if (parsedDestination.protocol) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">Object.assign(rewriteParams, destQuery, params)</span><span class="s3">\n        </span><span class="s1">Object.assign(parsedUrl.query, parsedDestination.query)</span><span class="s3">\n        </span><span class="s1">delete (parsedDestination as any).query</span><span class="s3">\n\n        </span><span class="s1">// for each property in parsedUrl.query, if the value is parametrized (eg :foo), look up the value</span><span class="s3">\n        </span><span class="s1">// in rewriteParams and replace the parametrized value with the actual value</span><span class="s3">\n        </span><span class="s1">// this is used when the rewrite destination does not contain the original source param</span><span class="s3">\n        </span><span class="s1">// and so the value is still parametrized and needs to be replaced with the actual rewrite param</span><span class="s3">\n        </span><span class="s1">Object.entries(parsedUrl.query).forEach(([key, value]) =&gt; {</span><span class="s3">\n          </span><span class="s1">if (value &amp;&amp; typeof value === 'string' &amp;&amp; value.startsWith(':')) {</span><span class="s3">\n            </span><span class="s1">const paramName = value.slice(1)</span><span class="s3">\n            </span><span class="s1">const actualValue = rewriteParams[paramName]</span><span class="s3">\n            </span><span class="s1">if (actualValue) {</span><span class="s3">\n              </span><span class="s1">parsedUrl.query[key] = actualValue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">Object.assign(parsedUrl, parsedDestination)</span><span class="s3">\n\n        </span><span class="s1">fsPathname = parsedUrl.pathname</span><span class="s3">\n        </span><span class="s1">if (!fsPathname) return false</span><span class="s3">\n\n        </span><span class="s1">if (basePath) {</span><span class="s3">\n          </span><span class="s1">fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (i18n) {</span><span class="s3">\n          </span><span class="s1">const result = normalizeLocalePath(fsPathname, i18n.locales)</span><span class="s3">\n          </span><span class="s1">fsPathname = result.pathname</span><span class="s3">\n          </span><span class="s1">parsedUrl.query.nextInternalLocale =</span><span class="s3">\n            </span><span class="s1">result.detectedLocale || params.nextInternalLocale</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (fsPathname === page) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (pageIsDynamic &amp;&amp; dynamicRouteMatcher) {</span><span class="s3">\n          </span><span class="s1">const dynamicParams = dynamicRouteMatcher(fsPathname)</span><span class="s3">\n          </span><span class="s1">if (dynamicParams) {</span><span class="s3">\n            </span><span class="s1">parsedUrl.query = {</span><span class="s3">\n              </span><span class="s1">...parsedUrl.query,</span><span class="s3">\n              </span><span class="s1">...dynamicParams,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const rewrite of rewrites.beforeFiles || []) {</span><span class="s3">\n      </span><span class="s1">checkRewrite(rewrite)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (fsPathname !== page) {</span><span class="s3">\n      </span><span class="s1">let finished = false</span><span class="s3">\n\n      </span><span class="s1">for (const rewrite of rewrites.afterFiles || []) {</span><span class="s3">\n        </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n        </span><span class="s1">if (finished) break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!finished &amp;&amp; !matchesPage()) {</span><span class="s3">\n        </span><span class="s1">for (const rewrite of rewrites.fallback || []) {</span><span class="s3">\n          </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n          </span><span class="s1">if (finished) break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return rewriteParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function getParamsFromRouteMatches(routeMatchesHeader: string) {</span><span class="s3">\n    </span><span class="s1">// If we don't have a default route regex, we can't get params from route</span><span class="s3">\n    </span><span class="s1">// matches</span><span class="s3">\n    </span><span class="s1">if (!defaultRouteRegex) return null</span><span class="s3">\n\n    </span><span class="s1">const { groups, routeKeys } = defaultRouteRegex</span><span class="s3">\n\n    </span><span class="s1">const matcher = getRouteMatcher({</span><span class="s3">\n      </span><span class="s1">re: {</span><span class="s3">\n        </span><span class="s1">// Simulate a RegExp match from the </span><span class="s3">\\</span><span class="s1">`req.url</span><span class="s3">\\</span><span class="s1">` input</span><span class="s3">\n        </span><span class="s1">exec: (str: string) =&gt; {</span><span class="s3">\n          </span><span class="s1">// Normalize all the prefixed query params.</span><span class="s3">\n          </span><span class="s1">const obj: Record&lt;string, string&gt; = Object.fromEntries(</span><span class="s3">\n            </span><span class="s1">new URLSearchParams(str)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">for (const [key, value] of Object.entries(obj)) {</span><span class="s3">\n            </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n            </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n            </span><span class="s1">obj[normalizedKey] = value</span><span class="s3">\n            </span><span class="s1">delete obj[key]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Use all the named route keys.</span><span class="s3">\n          </span><span class="s1">const result = {} as RegExpExecArray</span><span class="s3">\n          </span><span class="s1">for (const keyName of Object.keys(routeKeys)) {</span><span class="s3">\n            </span><span class="s1">const paramName = routeKeys[keyName]</span><span class="s3">\n\n            </span><span class="s1">// If this param name is not a valid parameter name, then skip it.</span><span class="s3">\n            </span><span class="s1">if (!paramName) continue</span><span class="s3">\n\n            </span><span class="s1">const group = groups[paramName]</span><span class="s3">\n            </span><span class="s1">const value = obj[keyName]</span><span class="s3">\n\n            </span><span class="s1">// When we're missing a required param, we can't match the route.</span><span class="s3">\n            </span><span class="s1">if (!group.optional &amp;&amp; !value) return null</span><span class="s3">\n\n            </span><span class="s1">result[group.pos] = value</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return result</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">groups,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const routeMatches = matcher(routeMatchesHeader)</span><span class="s3">\n    </span><span class="s1">if (!routeMatches) return null</span><span class="s3">\n\n    </span><span class="s1">return routeMatches</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function normalizeQueryParams(</span><span class="s3">\n    </span><span class="s1">query: Record&lt;string, string | string[] | undefined&gt;,</span><span class="s3">\n    </span><span class="s1">routeParamKeys: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n    </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n    </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n    </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n      </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n      </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n      </span><span class="s1">// Remove the prefixed key from the query params because we want</span><span class="s3">\n      </span><span class="s1">// to consume it for the dynamic route matcher.</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n      </span><span class="s1">routeParamKeys.add(normalizedKey)</span><span class="s3">\n\n      </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n\n      </span><span class="s1">query[normalizedKey] = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.map((v) =&gt; decodeQueryPathParameter(v))</span><span class="s3">\n        </span><span class="s1">: decodeQueryPathParameter(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">handleRewrites,</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher,</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n    </span><span class="s1">normalizeQueryParams,</span><span class="s3">\n    </span><span class="s1">getParamsFromRouteMatches,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Normalize dynamic route params.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param query - The query params to normalize.</span><span class="s3">\n     </span><span class="s1">* @param ignoreMissingOptional - Whether to ignore missing optional params.</span><span class="s3">\n     </span><span class="s1">* @returns The normalized params and whether they are valid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">normalizeDynamicRouteParams: (</span><span class="s3">\n      </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n      </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n    </span><span class="s1">) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!defaultRouteRegex || !defaultRouteMatches) {</span><span class="s3">\n        </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">query,</span><span class="s3">\n        </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n        </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n        </span><span class="s1">ignoreMissingOptional</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">normalizeCdnUrl: (</span><span class="s3">\n      </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n      </span><span class="s1">paramKeys: string[]</span><span class="s3">\n    </span><span class="s1">) =&gt; normalizeCdnUrl(req, paramKeys),</span><span class="s3">\n\n    </span><span class="s1">interpolateDynamicPath: (</span><span class="s3">\n      </span><span class="s1">pathname: string,</span><span class="s3">\n      </span><span class="s1">params: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; interpolateDynamicPath(pathname, params, defaultRouteRegex),</span><span class="s3">\n\n    </span><span class="s1">filterInternalQuery: (query: ParsedUrlQuery, paramKeys: string[]) =&gt;</span><span class="s3">\n      </span><span class="s1">filterInternalQuery(query, paramKeys),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getPreviouslyRevalidatedTags(</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">previewModeId: string | undefined</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">return typeof headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">headers[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === previewModeId</span><span class="s3">\n    </span><span class="s1">? headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')</span><span class="s3">\n    </span><span class="s1">: []</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { DomainLocale } from '../../../server/config-shared'</span><span class="s3">\n\n</span><span class="s1">export function detectDomainLocale(</span><span class="s3">\n  </span><span class="s1">domainItems?: readonly DomainLocale[],</span><span class="s3">\n  </span><span class="s1">hostname?: string,</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!domainItems) return</span><span class="s3">\n\n  </span><span class="s1">if (detectedLocale) {</span><span class="s3">\n    </span><span class="s1">detectedLocale = detectedLocale.toLowerCase()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const item of domainItems) {</span><span class="s3">\n    </span><span class="s1">// remove port if present</span><span class="s3">\n    </span><span class="s1">const domainHostname = item.domain?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">hostname === domainHostname ||</span><span class="s3">\n      </span><span class="s1">detectedLocale === item.defaultLocale.toLowerCase() ||</span><span class="s3">\n      </span><span class="s1">item.locales?.some((locale) =&gt; locale.toLowerCase() === detectedLocale)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return item</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes an object with a hostname property (like a parsed URL) and some</span><span class="s3">\n </span><span class="s1">* headers that may contain Host and returns the preferred hostname.</span><span class="s3">\n </span><span class="s1">* @param parsed An object containing a hostname property.</span><span class="s3">\n </span><span class="s1">* @param headers A dictionary with headers containing a `host`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getHostname(</span><span class="s3">\n  </span><span class="s1">parsed: { hostname?: string | null },</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">// Get the hostname from the headers if it exists, otherwise use the parsed</span><span class="s3">\n  </span><span class="s1">// hostname.</span><span class="s3">\n  </span><span class="s1">let hostname: string</span><span class="s3">\n  </span><span class="s1">if (headers?.host &amp;&amp; !Array.isArray(headers.host)) {</span><span class="s3">\n    </span><span class="s1">hostname = headers.host.toString().split(':', 1)[0]</span><span class="s3">\n  </span><span class="s1">} else if (parsed.hostname) {</span><span class="s3">\n    </span><span class="s1">hostname = parsed.hostname</span><span class="s3">\n  </span><span class="s1">} else return</span><span class="s3">\n\n  </span><span class="s1">return hostname.toLowerCase()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { pathHasPrefix } from '../router/utils/path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* strip _next/data/&lt;build-id&gt;/ prefix and .json suffix</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeDataPath(pathname: string) {</span><span class="s3">\n  </span><span class="s1">if (!pathHasPrefix(pathname || '/', '/_next/data')) {</span><span class="s3">\n    </span><span class="s1">return pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">pathname = pathname</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">/data</span><span class="s3">\\</span><span class="s1">/[^/]{1,}/, '')</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">.json$/, '')</span><span class="s3">\n\n  </span><span class="s1">if (pathname === '/index') {</span><span class="s3">\n    </span><span class="s1">return '/'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* eslint-disable no-redeclare */</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { CloneableBody } from './body-streams'</span><span class="s3">\n</span><span class="s1">import type { RouteMatch } from './route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import type { ServerComponentsHmrCache } from './response-cache'</span><span class="s3">\n</span><span class="s1">import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'</span><span class="s3">\n\n</span><span class="s1">// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules</span><span class="s3">\n</span><span class="s1">export const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')</span><span class="s3">\n\n</span><span class="s1">export type NextIncomingMessage = (BaseNextRequest | IncomingMessage) &amp; {</span><span class="s3">\n  </span><span class="s1">[NEXT_REQUEST_META]?: RequestMeta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RequestMeta {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initQuery?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The URL that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The protocol that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initProtocol?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The body that was read from the request. This is used to allow the body to</span><span class="s3">\n   </span><span class="s1">* be read multiple times.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clonableBody?: CloneableBody</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request matched a locale domain that was configured in the</span><span class="s3">\n   </span><span class="s1">* next.config.js file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isLocaleDomain?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information stripped from the pathname</span><span class="s3">\n   </span><span class="s1">* part of the URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">didStripLocale?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If the request had it's URL rewritten, this is the URL it was rewritten to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rewroteURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cookies that were added by middleware and were added to the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareCookie?: string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The match on the request for a given route.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">match?: RouteMatch</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The incremental cache to use for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">incrementalCache?: any</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The server components HMR cache, only for dev.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache?: ServerComponentsHmrCache</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Equals the segment path that was used for the prefetch RSC request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">segmentPrefetchRSCRequest?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the prefetch flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isPrefetchRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A search param set by the Next.js client when performing RSC requests.</span><span class="s3">\n   </span><span class="s1">* Because some CDNs do not vary their cache entries on our custom headers,</span><span class="s3">\n   </span><span class="s1">* this search param represents a hash of the header values. For any cached</span><span class="s3">\n   </span><span class="s1">* RSC request, we should verify that the hash matches before responding.</span><span class="s3">\n   </span><span class="s1">* Otherwise this can lead to cache poisoning.</span><span class="s3">\n   </span><span class="s1">* TODO: Consider not using custom request headers at all, and instead encode</span><span class="s3">\n   </span><span class="s1">* everything into the search param.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cacheBustingSearchParam?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the `/_next/data` route using the pages</span><span class="s3">\n   </span><span class="s1">* router.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isNextDataReq?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Postponed state to use for resumption. If present it's assumed that the</span><span class="s3">\n   </span><span class="s1">* request is for a page that has postponed (there are no guarantees that the</span><span class="s3">\n   </span><span class="s1">* page actually has postponed though as it would incur an additional cache</span><span class="s3">\n   </span><span class="s1">* lookup).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If provided, this will be called when a response cache entry was generated</span><span class="s3">\n   </span><span class="s1">* or looked up in the cache.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">onCacheEntry?: (</span><span class="s3">\n    </span><span class="s1">cacheEntry: any,</span><span class="s3">\n    </span><span class="s1">requestMeta: any</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;boolean | void&gt; | boolean | void</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The previous revalidate before rendering 404 page for notFound: true</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">notFoundRevalidate?: number | false</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the original source page that returned a 404.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">developmentNotFoundSourcePage?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The path we routed to and should be invoked</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokePath?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The specific page output we should be matching</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeOutput?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The status we are invoking the request with from routing</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeStatus?: number</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The routing error we are invoking with</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeError?: Error</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query parsed for the invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeQuery?: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is a middleware invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareInvoke?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request should render the fallback shell or not.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderFallbackShell?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is for the custom error page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">customErrorRender?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to bubble up the NoFallbackError to the caller when a 404 is</span><span class="s3">\n   </span><span class="s1">* returned.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">bubbleNoFallback?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information inferred from the default</span><span class="s3">\n   </span><span class="s1">* locale.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">localeInferredFromDefault?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The default locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The relative project dir the server is running in from project root</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">relativeProjectDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The dist directory the server is currently using</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">distDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The params after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The AMP validator to use in development</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ampValidator?: (html: string, pathname: string) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* ErrorOverlay component to use in development for pages router</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PagesErrorDebug?: PagesDevOverlayBridgeType</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether server is in minimal mode (this will be replaced with more</span><span class="s3">\n   </span><span class="s1">* specific flags in future)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* DEV only: The fallback params that should be used when validating prerenders during dev</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">devValidatingFallbackParams?: Map&lt;string, string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the request metadata. If no key is provided, the entire metadata object</span><span class="s3">\n </span><span class="s1">* is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to get the metadata from</span><span class="s3">\n </span><span class="s1">* @param key the key to get from the metadata (optional)</span><span class="s3">\n </span><span class="s1">* @returns the value for the key or the entire metadata object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRequestMeta(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: undefined</span><span class="s3">\n</span><span class="s1">): RequestMeta</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">): RequestMeta[K]</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: K</span><span class="s3">\n</span><span class="s1">): RequestMeta | RequestMeta[K] {</span><span class="s3">\n  </span><span class="s1">const meta = req[NEXT_REQUEST_META] || {}</span><span class="s3">\n  </span><span class="s1">return typeof key === 'string' ? meta[key] : meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to set the metadata on</span><span class="s3">\n </span><span class="s1">* @param meta the metadata to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {</span><span class="s3">\n  </span><span class="s1">req[NEXT_REQUEST_META] = meta</span><span class="s3">\n  </span><span class="s1">return meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds a value to the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to set</span><span class="s3">\n </span><span class="s1">* @param value the value to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K,</span><span class="s3">\n  </span><span class="s1">value: RequestMeta[K]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">meta[key] = value</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes a key from the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to remove</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removeRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">delete meta[key]</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type NextQueryMetadata = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `_rsc` query parameter used for cache busting to ensure that the RSC</span><span class="s3">\n   </span><span class="s1">* requests do not get cached by the browser explicitly.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[NEXT_RSC_UNION_QUERY]?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NextParsedUrlQuery = ParsedUrlQuery &amp;</span><span class="s3">\n  </span><span class="s1">NextQueryMetadata &amp; {</span><span class="s3">\n    </span><span class="s1">amp?: '1'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface NextUrlWithParsedQuery extends UrlWithParsedQuery {</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ensureLeadingSlash } from './ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../router/utils'</span><span class="s3">\n</span><span class="s1">import { NormalizeError } from '../utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes a page and transforms it into its file counterpart ensuring that the</span><span class="s3">\n </span><span class="s1">* output is normalized. Note this function is not idempotent because a page</span><span class="s3">\n </span><span class="s1">* `/index` can be referencing `/index/index.js` and `/index/index` could be</span><span class="s3">\n </span><span class="s1">* referencing `/index/index/index.js`. Examples:</span><span class="s3">\n </span><span class="s1">*  - `/` -&gt; `/index`</span><span class="s3">\n </span><span class="s1">*  - `/index/foo` -&gt; `/index/index/foo`</span><span class="s3">\n </span><span class="s1">*  - `/index` -&gt; `/index/index`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizePagePath(page: string): string {</span><span class="s3">\n  </span><span class="s1">const normalized =</span><span class="s3">\n    </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">/index(</span><span class="s3">\\</span><span class="s1">/|$)/.test(page) &amp;&amp; !isDynamicRoute(page)</span><span class="s3">\n      </span><span class="s1">? `/index${page}`</span><span class="s3">\n      </span><span class="s1">: page === '/'</span><span class="s3">\n        </span><span class="s1">? '/index'</span><span class="s3">\n        </span><span class="s1">: ensureLeadingSlash(page)</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n    </span><span class="s1">const { posix } = require('path') as typeof import('path')</span><span class="s3">\n    </span><span class="s1">const resolvedPage = posix.normalize(normalized)</span><span class="s3">\n    </span><span class="s1">if (resolvedPage !== normalized) {</span><span class="s3">\n      </span><span class="s1">throw new NormalizeError(</span><span class="s3">\n        </span><span class="s1">`Requested and resolved page mismatch: ${normalized} ${resolvedPage}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalized</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PageExtensions } from '../../build/page-extensions-type'</span><span class="s3">\n</span><span class="s1">import { normalizePathSep } from '../../shared/lib/page-path/normalize-path-sep'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { isAppRouteRoute } from '../is-app-route-route'</span><span class="s3">\n\n</span><span class="s1">export const STATIC_METADATA_IMAGES = {</span><span class="s3">\n  </span><span class="s1">icon: {</span><span class="s3">\n    </span><span class="s1">filename: 'icon',</span><span class="s3">\n    </span><span class="s1">extensions: ['ico', 'jpg', 'jpeg', 'png', 'svg'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">apple: {</span><span class="s3">\n    </span><span class="s1">filename: 'apple-icon',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">favicon: {</span><span class="s3">\n    </span><span class="s1">filename: 'favicon',</span><span class="s3">\n    </span><span class="s1">extensions: ['ico'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">openGraph: {</span><span class="s3">\n    </span><span class="s1">filename: 'opengraph-image',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png', 'gif'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">twitter: {</span><span class="s3">\n    </span><span class="s1">filename: 'twitter-image',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png', 'gif'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">// Match routes that are metadata routes, e.g. /sitemap.xml, /favicon.&lt;ext&gt;, /&lt;icon&gt;.&lt;ext&gt;, etc.</span><span class="s3">\n</span><span class="s1">// TODO-METADATA: support more metadata routes with more extensions</span><span class="s3">\n</span><span class="s1">export const DEFAULT_METADATA_ROUTE_EXTENSIONS = ['js', 'jsx', 'ts', 'tsx']</span><span class="s3">\n\n</span><span class="s1">// Match the file extension with the dynamic multi-routes extensions</span><span class="s3">\n</span><span class="s1">// e.g. ([xml, js], null) -&gt; can match `/sitemap.xml/route`, `sitemap.js/route`</span><span class="s3">\n</span><span class="s1">// e.g. ([png], [ts]) -&gt; can match `/opengrapg-image.png`, `/opengraph-image.ts`</span><span class="s3">\n</span><span class="s1">export const getExtensionRegexString = (</span><span class="s3">\n  </span><span class="s1">staticExtensions: readonly string[],</span><span class="s3">\n  </span><span class="s1">dynamicExtensions: readonly string[] | null</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">// If there's no possible multi dynamic routes, will not match any &lt;name&gt;[].&lt;ext&gt; files</span><span class="s3">\n  </span><span class="s1">if (!dynamicExtensions || dynamicExtensions.length === 0) {</span><span class="s3">\n    </span><span class="s1">return `(</span><span class="s3">\\\\</span><span class="s1">.(?:${staticExtensions.join('|')}))`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return `(?:</span><span class="s3">\\\\</span><span class="s1">.(${staticExtensions.join('|')})|(</span><span class="s3">\\\\</span><span class="s1">.(${dynamicExtensions.join('|')})))`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine if the file is a metadata route file entry</span><span class="s3">\n </span><span class="s1">* @param appDirRelativePath the relative file path to app/</span><span class="s3">\n </span><span class="s1">* @param pageExtensions the js extensions, such as ['js', 'jsx', 'ts', 'tsx']</span><span class="s3">\n </span><span class="s1">* @param strictlyMatchExtensions if it's true, match the file with page extension, otherwise match the file with default corresponding extension</span><span class="s3">\n </span><span class="s1">* @returns if the file is a metadata route file</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataRouteFile(</span><span class="s3">\n  </span><span class="s1">appDirRelativePath: string,</span><span class="s3">\n  </span><span class="s1">pageExtensions: PageExtensions,</span><span class="s3">\n  </span><span class="s1">strictlyMatchExtensions: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// End with the extension or optional to have the extension</span><span class="s3">\n  </span><span class="s1">// When strictlyMatchExtensions is true, it's used for match file path;</span><span class="s3">\n  </span><span class="s1">// When strictlyMatchExtensions, the dynamic extension is skipped but</span><span class="s3">\n  </span><span class="s1">// static extension is kept, which is usually used for matching route path.</span><span class="s3">\n  </span><span class="s1">const trailingMatcher = (strictlyMatchExtensions ? '' : '?') + '$'</span><span class="s3">\n  </span><span class="s1">// Match the optional variants like /opengraph-image2, /icon-a102f4.png, etc.</span><span class="s3">\n  </span><span class="s1">const variantsMatcher = '</span><span class="s3">\\\\</span><span class="s1">d?'</span><span class="s3">\n  </span><span class="s1">// The -</span><span class="s3">\\</span><span class="s1">w{6} is the suffix that normalized from group routes;</span><span class="s3">\n  </span><span class="s1">const groupSuffix = strictlyMatchExtensions ? '' : '(-</span><span class="s3">\\\\</span><span class="s1">w{6})?'</span><span class="s3">\n\n  </span><span class="s1">const suffixMatcher = `${variantsMatcher}${groupSuffix}`</span><span class="s3">\n\n  </span><span class="s1">const metadataRouteFilesRegex = [</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]robots${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">pageExtensions.concat('txt'),</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]manifest${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">pageExtensions.concat('webmanifest', 'json'),</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]favicon</span><span class="s3">\\\\</span><span class="s1">.ico$`),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]sitemap${getExtensionRegexString(['xml'], pageExtensions)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.icon.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.icon.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.apple.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.apple.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.openGraph.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.openGraph.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.twitter.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.twitter.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">const normalizedAppDirRelativePath = normalizePathSep(appDirRelativePath)</span><span class="s3">\n  </span><span class="s1">const matched = metadataRouteFilesRegex.some((r) =&gt;</span><span class="s3">\n    </span><span class="s1">r.test(normalizedAppDirRelativePath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Check if the route is a static metadata route, with /route suffix</span><span class="s3">\n</span><span class="s1">// e.g. /favicon.ico/route, /icon.png/route, etc.</span><span class="s3">\n</span><span class="s1">// But skip the text routes like robots.txt since they might also be dynamic.</span><span class="s3">\n</span><span class="s1">// Checking route path is not enough to determine if text routes is dynamic.</span><span class="s3">\n</span><span class="s1">export function isStaticMetadataRoute(route: string) {</span><span class="s3">\n  </span><span class="s1">// extract ext with regex</span><span class="s3">\n  </span><span class="s1">const pathname = route.replace(/</span><span class="s3">\\</span><span class="s1">/route$/, '')</span><span class="s3">\n\n  </span><span class="s1">const matched =</span><span class="s3">\n    </span><span class="s1">isAppRouteRoute(route) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isMetadataRouteFile(pathname, [], true) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// These routes can either be built by static or dynamic entrypoints,</span><span class="s3">\n    </span><span class="s1">// so we assume they're dynamic</span><span class="s3">\n    </span><span class="s1">pathname !== '/robots.txt' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">pathname !== '/manifest.webmanifest' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!pathname.endsWith('/sitemap.xml')</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine if a page or pathname is a metadata page.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The input is a page or pathname, which can be with or without page suffix /foo/page or /foo.</span><span class="s3">\n </span><span class="s1">* But it will not contain the /route suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* .e.g</span><span class="s3">\n </span><span class="s1">* /robots -&gt; true</span><span class="s3">\n </span><span class="s1">* /sitemap -&gt; true</span><span class="s3">\n </span><span class="s1">* /foo -&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataPage(page: string) {</span><span class="s3">\n  </span><span class="s1">const matched = !isAppRouteRoute(page) &amp;&amp; isMetadataRouteFile(page, [], false)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Determine if a Next.js route is a metadata route.</span><span class="s3">\n </span><span class="s1">* `route` will has a route suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* e.g.</span><span class="s3">\n </span><span class="s1">* /app/robots/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /robots/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /sitemap/[__metadata_id__]/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /app/sitemap/page -&gt; false</span><span class="s3">\n </span><span class="s1">* /icon-a102f4/route -&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataRoute(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">let page = normalizeAppPath(route)</span><span class="s3">\n    </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">/?app</span><span class="s3">\\</span><span class="s1">//, '')</span><span class="s3">\n    </span><span class="s1">// Remove the dynamic route id</span><span class="s3">\n    </span><span class="s1">.replace('/[__metadata_id__]', '')</span><span class="s3">\n    </span><span class="s1">// Remove the /route suffix</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/route$/, '')</span><span class="s3">\n\n  </span><span class="s1">if (page[0] !== '/') page = '/' + page</span><span class="s3">\n\n  </span><span class="s1">const matched = isAppRouteRoute(route) &amp;&amp; isMetadataRouteFile(page, [], false)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A `Promise.withResolvers` implementation that exposes the `resolve` and</span><span class="s3">\n </span><span class="s1">* `reject` functions on a `Promise`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @see https://tc39.es/proposal-promise-with-resolvers/</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class DetachedPromise&lt;T = any&gt; {</span><span class="s3">\n  </span><span class="s1">public readonly resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n  </span><span class="s1">public readonly reject: (reason: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">public readonly promise: Promise&lt;T&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">let resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">let reject: (reason: any) =&gt; void</span><span class="s3">\n\n    </span><span class="s1">// Create the promise and assign the resolvers to the object.</span><span class="s3">\n    </span><span class="s1">this.promise = new Promise&lt;T&gt;((res, rej) =&gt; {</span><span class="s3">\n      </span><span class="s1">resolve = res</span><span class="s3">\n      </span><span class="s1">reject = rej</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// We know that resolvers is defined because the Promise constructor runs</span><span class="s3">\n    </span><span class="s1">// synchronously.</span><span class="s3">\n    </span><span class="s1">this.resolve = resolve!</span><span class="s3">\n    </span><span class="s1">this.reject = reject!</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { SchedulerFn } from './scheduler'</span><span class="s3">\n\n</span><span class="s1">import { DetachedPromise } from './detached-promise'</span><span class="s3">\n\n</span><span class="s1">type CacheKeyFn&lt;K, C extends string | number | null&gt; = (</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">) =&gt; PromiseLike&lt;C&gt; | C</span><span class="s3">\n\n</span><span class="s1">type BatcherOptions&lt;K, C extends string | number | null&gt; = {</span><span class="s3">\n  </span><span class="s1">cacheKeyFn?: CacheKeyFn&lt;K, C&gt;</span><span class="s3">\n  </span><span class="s1">schedulerFn?: SchedulerFn&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type WorkFn&lt;V, C&gt; = (</span><span class="s3">\n  </span><span class="s1">key: C,</span><span class="s3">\n  </span><span class="s1">resolve: (value: V | PromiseLike&lt;V&gt;) =&gt; void</span><span class="s3">\n</span><span class="s1">) =&gt; Promise&lt;V&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A wrapper for a function that will only allow one call to the function to</span><span class="s3">\n </span><span class="s1">* execute at a time.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Batcher&lt;K, V, C extends string | number | null&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly pending = new Map&lt;C, Promise&lt;V&gt;&gt;()</span><span class="s3">\n\n  </span><span class="s1">protected constructor(</span><span class="s3">\n    </span><span class="s1">private readonly cacheKeyFn?: CacheKeyFn&lt;K, C&gt;,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A function that will be called to schedule the wrapped function to be</span><span class="s3">\n     </span><span class="s1">* executed. This defaults to a function that will execute the function</span><span class="s3">\n     </span><span class="s1">* immediately.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">private readonly schedulerFn: SchedulerFn&lt;void&gt; = (fn) =&gt; fn()</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a new instance of PendingWrapper. If the key extends a string or</span><span class="s3">\n   </span><span class="s1">* number, the key will be used as the cache key. If the key is an object, a</span><span class="s3">\n   </span><span class="s1">* cache key function must be provided.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static create&lt;K extends string | number | null, V&gt;(</span><span class="s3">\n    </span><span class="s1">options?: BatcherOptions&lt;K, K&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, K&gt;</span><span class="s3">\n  </span><span class="s1">public static create&lt;K, V, C extends string | number | null&gt;(</span><span class="s3">\n    </span><span class="s1">options: BatcherOptions&lt;K, C&gt; &amp;</span><span class="s3">\n      </span><span class="s1">Required&lt;Pick&lt;BatcherOptions&lt;K, C&gt;, 'cacheKeyFn'&gt;&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, C&gt;</span><span class="s3">\n  </span><span class="s1">public static create&lt;K, V, C extends string | number | null&gt;(</span><span class="s3">\n    </span><span class="s1">options?: BatcherOptions&lt;K, C&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, C&gt; {</span><span class="s3">\n    </span><span class="s1">return new Batcher&lt;K, V, C&gt;(options?.cacheKeyFn, options?.schedulerFn)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Wraps a function in a promise that will be resolved or rejected only once</span><span class="s3">\n   </span><span class="s1">* for a given key. This will allow multiple calls to the function to be</span><span class="s3">\n   </span><span class="s1">* made, but only one will be executed at a time. The result of the first</span><span class="s3">\n   </span><span class="s1">* call will be returned to all callers.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param key the key to use for the cache</span><span class="s3">\n   </span><span class="s1">* @param fn the function to wrap</span><span class="s3">\n   </span><span class="s1">* @returns a promise that resolves to the result of the function</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async batch(key: K, fn: WorkFn&lt;V, C&gt;): Promise&lt;V&gt; {</span><span class="s3">\n    </span><span class="s1">const cacheKey = (this.cacheKeyFn ? await this.cacheKeyFn(key) : key) as C</span><span class="s3">\n    </span><span class="s1">if (cacheKey === null) {</span><span class="s3">\n      </span><span class="s1">return fn(cacheKey, Promise.resolve)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const pending = this.pending.get(cacheKey)</span><span class="s3">\n    </span><span class="s1">if (pending) return pending</span><span class="s3">\n\n    </span><span class="s1">const { promise, resolve, reject } = new DetachedPromise&lt;V&gt;()</span><span class="s3">\n    </span><span class="s1">this.pending.set(cacheKey, promise)</span><span class="s3">\n\n    </span><span class="s1">this.schedulerFn(async () =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const result = await fn(cacheKey, resolve)</span><span class="s3">\n\n        </span><span class="s1">// Resolving a promise multiple times is a no-op, so we can safely</span><span class="s3">\n        </span><span class="s1">// resolve all pending promises with the same result.</span><span class="s3">\n        </span><span class="s1">resolve(result)</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">reject(err)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">this.pending.delete(cacheKey)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">return promise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export type ScheduledFn&lt;T = void&gt; = () =&gt; T | PromiseLike&lt;T&gt;</span><span class="s3">\n</span><span class="s1">export type SchedulerFn&lt;T = void&gt; = (cb: ScheduledFn&lt;T&gt;) =&gt; void</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Schedules a function to be called on the next tick after the other promises</span><span class="s3">\n </span><span class="s1">* have been resolved.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cb the function to schedule</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const scheduleOnNextTick = (cb: ScheduledFn&lt;void&gt;) =&gt; {</span><span class="s3">\n  </span><span class="s1">// We use Promise.resolve().then() here so that the operation is scheduled at</span><span class="s3">\n  </span><span class="s1">// the end of the promise job queue, we then add it to the next process tick</span><span class="s3">\n  </span><span class="s1">// to ensure it's evaluated afterwards.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">Promise.resolve().then(() =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">setTimeout(cb, 0)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">process.nextTick(cb)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Schedules a function to be called using `setImmediate` or `setTimeout` if</span><span class="s3">\n </span><span class="s1">* `setImmediate` is not available (like in the Edge runtime).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cb the function to schedule</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const scheduleImmediate = (cb: ScheduledFn&lt;void&gt;): void =&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">setTimeout(cb, 0)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">setImmediate(cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* returns a promise than resolves in a future task. There is no guarantee that the task it resolves in</span><span class="s3">\n </span><span class="s1">* will be the next task but if you await it you can at least be sure that the current task is over and</span><span class="s3">\n </span><span class="s1">* most usefully that the entire microtask queue of the current task has been emptied.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function atLeastOneTask() {</span><span class="s3">\n  </span><span class="s1">return new Promise&lt;void&gt;((resolve) =&gt; scheduleImmediate(resolve))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This utility function is extracted to make it easier to find places where we are doing</span><span class="s3">\n </span><span class="s1">* specific timing tricks to try to schedule work after React has rendered. This is especially</span><span class="s3">\n </span><span class="s1">* important at the moment because Next.js uses the edge builds of React which use setTimeout to</span><span class="s3">\n </span><span class="s1">* schedule work when you might expect that something like setImmediate would do the trick.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Long term we should switch to the node versions of React rendering when possible and then</span><span class="s3">\n </span><span class="s1">* update this to use setImmediate rather than setTimeout</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function waitAtLeastOneReactRenderTask(): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">return new Promise((r) =&gt; setTimeout(r, 0))</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return new Promise((r) =&gt; setImmediate(r))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type RenderResult from '../render-result'</span><span class="s3">\n</span><span class="s1">import type { CacheControl, Revalidate } from '../lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export interface ResponseCacheBase {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">key: string | null,</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator,</span><span class="s3">\n    </span><span class="s1">context: {</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n      </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n      </span><span class="s1">incrementalCache: IncrementalCache</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* This is a hint to the cache to help it determine what kind of route</span><span class="s3">\n       </span><span class="s1">* this is so it knows where to look up the cache entry from. If not</span><span class="s3">\n       </span><span class="s1">* provided it will test the filesystem to check.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">isFallback?: boolean</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// The server components HMR cache might store other data as well in the future,</span><span class="s3">\n</span><span class="s1">// at which point this should be refactored to a discriminated union type.</span><span class="s3">\n</span><span class="s1">export interface ServerComponentsHmrCache {</span><span class="s3">\n  </span><span class="s1">get(key: string): CachedFetchData | undefined</span><span class="s3">\n  </span><span class="s1">set(key: string, data: CachedFetchData): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type CachedFetchData = {</span><span class="s3">\n  </span><span class="s1">headers: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">body: string</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">status?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const enum CachedRouteKind {</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">FETCH = 'FETCH',</span><span class="s3">\n  </span><span class="s1">REDIRECT = 'REDIRECT',</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedFetchValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.FETCH</span><span class="s3">\n  </span><span class="s1">data: CachedFetchData</span><span class="s3">\n  </span><span class="s1">// tags are only present with file-system-cache</span><span class="s3">\n  </span><span class="s1">// fetch cache stores tags outside of cache entry</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">revalidate: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedRedirectValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.REDIRECT</span><span class="s3">\n  </span><span class="s1">props: Object</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedAppPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_PAGE</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">html: RenderResult</span><span class="s3">\n  </span><span class="s1">rscData: Buffer | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">postponed: string | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">segmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.PAGES</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">html: RenderResult</span><span class="s3">\n  </span><span class="s1">pageData: Object</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedRouteValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_ROUTE</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">body: Buffer</span><span class="s3">\n  </span><span class="s1">status: number</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedImageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.IMAGE</span><span class="s3">\n  </span><span class="s1">etag: string</span><span class="s3">\n  </span><span class="s1">upstreamEtag: string</span><span class="s3">\n  </span><span class="s1">buffer: Buffer</span><span class="s3">\n  </span><span class="s1">extension: string</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n  </span><span class="s1">isStale?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCachedAppPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_PAGE</span><span class="s3">\n  </span><span class="s1">// this needs to be a string since the cache expects to store</span><span class="s3">\n  </span><span class="s1">// the string value</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">rscData: Buffer | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">postponed: string | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">segmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCachedPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.PAGES</span><span class="s3">\n  </span><span class="s1">// this needs to be a string since the cache expects to store</span><span class="s3">\n  </span><span class="s1">// the string value</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">pageData: Object</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalResponseCacheEntry {</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* timestamp in milliseconds to revalidate after</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">revalidateAfter?: Revalidate</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `-1` here dictates a blocking revalidate should be used</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n  </span><span class="s1">value: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalFetchCacheEntry {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `-1` here dictates a blocking revalidate should be used</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">value: CachedFetchValue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type IncrementalCacheEntry =</span><span class="s3">\n  </span><span class="s1">| IncrementalResponseCacheEntry</span><span class="s3">\n  </span><span class="s1">| IncrementalFetchCacheEntry</span><span class="s3">\n\n</span><span class="s1">export type IncrementalCacheValue =</span><span class="s3">\n  </span><span class="s1">| CachedRedirectValue</span><span class="s3">\n  </span><span class="s1">| IncrementalCachedPageValue</span><span class="s3">\n  </span><span class="s1">| IncrementalCachedAppPageValue</span><span class="s3">\n  </span><span class="s1">| CachedImageValue</span><span class="s3">\n  </span><span class="s1">| CachedFetchValue</span><span class="s3">\n  </span><span class="s1">| CachedRouteValue</span><span class="s3">\n\n</span><span class="s1">export type ResponseCacheValue =</span><span class="s3">\n  </span><span class="s1">| CachedRedirectValue</span><span class="s3">\n  </span><span class="s1">| CachedPageValue</span><span class="s3">\n  </span><span class="s1">| CachedAppPageValue</span><span class="s3">\n  </span><span class="s1">| CachedImageValue</span><span class="s3">\n  </span><span class="s1">| CachedRouteValue</span><span class="s3">\n\n</span><span class="s1">export type ResponseCacheEntry = {</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">value: ResponseCacheValue | null</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param hasResolved whether the responseGenerator has resolved it's promise</span><span class="s3">\n </span><span class="s1">* @param previousCacheEntry the previous cache entry if it exists or the current</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type ResponseGenerator = (state: {</span><span class="s3">\n  </span><span class="s1">hasResolved: boolean</span><span class="s3">\n  </span><span class="s1">previousCacheEntry?: IncrementalResponseCacheEntry | null</span><span class="s3">\n  </span><span class="s1">isRevalidating?: boolean</span><span class="s3">\n  </span><span class="s1">span?: any</span><span class="s3">\n</span><span class="s1">}) =&gt; Promise&lt;ResponseCacheEntry | null&gt;</span><span class="s3">\n\n</span><span class="s1">export const enum IncrementalCacheKind {</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">FETCH = 'FETCH',</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface GetIncrementalFetchCacheContext {</span><span class="s3">\n  </span><span class="s1">kind: IncrementalCacheKind.FETCH</span><span class="s3">\n  </span><span class="s1">revalidate?: Revalidate</span><span class="s3">\n  </span><span class="s1">fetchUrl?: string</span><span class="s3">\n  </span><span class="s1">fetchIdx?: number</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">softTags?: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface GetIncrementalResponseCacheContext {</span><span class="s3">\n  </span><span class="s1">kind: Exclude&lt;IncrementalCacheKind, IncrementalCacheKind.FETCH&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isFallback: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface SetIncrementalFetchCacheContext {</span><span class="s3">\n  </span><span class="s1">fetchCache: true</span><span class="s3">\n  </span><span class="s1">fetchUrl?: string</span><span class="s3">\n  </span><span class="s1">fetchIdx?: number</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">isImplicitBuildTimeCache?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface SetIncrementalResponseCacheContext {</span><span class="s3">\n  </span><span class="s1">fetchCache?: false</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isFallback?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalResponseCache {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCache extends IncrementalResponseCache {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalFetchCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: CachedFetchValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ReactDOMServerReadableStream } from 'react-dom/server'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { AppRenderSpan } from '../lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../lib/detached-promise'</span><span class="s3">\n</span><span class="s1">import { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import { ENCODED_TAGS } from './encoded-tags'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">indexOfUint8Array,</span><span class="s3">\n  </span><span class="s1">isEquivalentUint8Arrays,</span><span class="s3">\n  </span><span class="s1">removeFromUint8Array,</span><span class="s3">\n</span><span class="s1">} from './uint8array-helpers'</span><span class="s3">\n</span><span class="s1">import { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'</span><span class="s3">\n</span><span class="s1">import { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'</span><span class="s3">\n\n</span><span class="s1">function voidCatch() {</span><span class="s3">\n  </span><span class="s1">// this catcher is designed to be used with pipeTo where we expect the underlying</span><span class="s3">\n  </span><span class="s1">// pipe implementation to forward errors but we don't want the pipeTo promise to reject</span><span class="s3">\n  </span><span class="s1">// and be unhandled</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We can share the same encoder instance everywhere</span><span class="s3">\n</span><span class="s1">// Notably we cannot do the same for TextDecoder because it is stateful</span><span class="s3">\n</span><span class="s1">// when handling streaming data</span><span class="s3">\n</span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n\n</span><span class="s1">export function chainStreams&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">...streams: ReadableStream&lt;T&gt;[]</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">// If we have no streams, return an empty stream. This behavior is</span><span class="s3">\n  </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n  </span><span class="s1">if (streams.length === 0) {</span><span class="s3">\n    </span><span class="s1">return new ReadableStream&lt;T&gt;({</span><span class="s3">\n      </span><span class="s1">start(controller) {</span><span class="s3">\n        </span><span class="s1">controller.close()</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we only have 1 stream we fast path it by returning just this stream</span><span class="s3">\n  </span><span class="s1">if (streams.length === 1) {</span><span class="s3">\n    </span><span class="s1">return streams[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { readable, writable } = new TransformStream()</span><span class="s3">\n\n  </span><span class="s1">// We always initiate pipeTo immediately. We know we have at least 2 streams</span><span class="s3">\n  </span><span class="s1">// so we need to avoid closing the writable when this one finishes.</span><span class="s3">\n  </span><span class="s1">let promise = streams[0].pipeTo(writable, { preventClose: true })</span><span class="s3">\n\n  </span><span class="s1">let i = 1</span><span class="s3">\n  </span><span class="s1">for (; i &lt; streams.length - 1; i++) {</span><span class="s3">\n    </span><span class="s1">const nextStream = streams[i]</span><span class="s3">\n    </span><span class="s1">promise = promise.then(() =&gt;</span><span class="s3">\n      </span><span class="s1">nextStream.pipeTo(writable, { preventClose: true })</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We can omit the length check because we halted before the last stream and there</span><span class="s3">\n  </span><span class="s1">// is at least two streams so the lastStream here will always be defined</span><span class="s3">\n  </span><span class="s1">const lastStream = streams[i]</span><span class="s3">\n  </span><span class="s1">promise = promise.then(() =&gt; lastStream.pipeTo(writable))</span><span class="s3">\n\n  </span><span class="s1">// Catch any errors from the streams and ignore them, they will be handled</span><span class="s3">\n  </span><span class="s1">// by whatever is consuming the readable stream.</span><span class="s3">\n  </span><span class="s1">promise.catch(voidCatch)</span><span class="s3">\n\n  </span><span class="s1">return readable</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function streamFromString(str: string): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(encoder.encode(str))</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function streamFromBuffer(chunk: Buffer): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function streamToBuffer(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;Buffer&gt; {</span><span class="s3">\n  </span><span class="s1">const reader = stream.getReader()</span><span class="s3">\n  </span><span class="s1">const chunks: Uint8Array[] = []</span><span class="s3">\n\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n    </span><span class="s1">if (done) {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">chunks.push(value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return Buffer.concat(chunks)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function streamToString(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n</span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n  </span><span class="s1">const decoder = new TextDecoder('utf-8', { fatal: true })</span><span class="s3">\n  </span><span class="s1">let string = ''</span><span class="s3">\n\n  </span><span class="s1">for await (const chunk of stream) {</span><span class="s3">\n    </span><span class="s1">if (signal?.aborted) {</span><span class="s3">\n      </span><span class="s1">return string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">string += decoder.decode(chunk, { stream: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">string += decoder.decode()</span><span class="s3">\n\n  </span><span class="s1">return string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createBufferedTransformStream(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">let bufferedChunks: Array&lt;Uint8Array&gt; = []</span><span class="s3">\n  </span><span class="s1">let bufferByteLength: number = 0</span><span class="s3">\n  </span><span class="s1">let pending: DetachedPromise&lt;void&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const flush = (controller: TransformStreamDefaultController) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If we already have a pending flush, then return early.</span><span class="s3">\n    </span><span class="s1">if (pending) return</span><span class="s3">\n\n    </span><span class="s1">const detached = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">pending = detached</span><span class="s3">\n\n    </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const chunk = new Uint8Array(bufferByteLength)</span><span class="s3">\n        </span><span class="s1">let copiedBytes = 0</span><span class="s3">\n\n        </span><span class="s1">for (let i = 0; i &lt; bufferedChunks.length; i++) {</span><span class="s3">\n          </span><span class="s1">const bufferedChunk = bufferedChunks[i]</span><span class="s3">\n          </span><span class="s1">chunk.set(bufferedChunk, copiedBytes)</span><span class="s3">\n          </span><span class="s1">copiedBytes += bufferedChunk.byteLength</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// We just wrote all the buffered chunks so we need to reset the bufferedChunks array</span><span class="s3">\n        </span><span class="s1">// and our bufferByteLength to prepare for the next round of buffered chunks</span><span class="s3">\n        </span><span class="s1">bufferedChunks.length = 0</span><span class="s3">\n        </span><span class="s1">bufferByteLength = 0</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// If an error occurs while enqueuing it can't be due to this</span><span class="s3">\n        </span><span class="s1">// transformers fault. It's likely due to the controller being</span><span class="s3">\n        </span><span class="s1">// errored due to the stream being cancelled.</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">pending = undefined</span><span class="s3">\n        </span><span class="s1">detached.resolve()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// Combine the previous buffer with the new chunk.</span><span class="s3">\n      </span><span class="s1">bufferedChunks.push(chunk)</span><span class="s3">\n      </span><span class="s1">bufferByteLength += chunk.byteLength</span><span class="s3">\n\n      </span><span class="s1">// Flush the buffer to the controller.</span><span class="s3">\n      </span><span class="s1">flush(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush() {</span><span class="s3">\n      </span><span class="s1">if (!pending) return</span><span class="s3">\n\n      </span><span class="s1">return pending.promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPrefetchCommentStream(</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean,</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">// Insert an extra comment at the beginning of the HTML document. This must</span><span class="s3">\n  </span><span class="s1">// come after the DOCTYPE, which is inserted by React.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// The first chunk sent by React will contain the doctype. After that, we can</span><span class="s3">\n  </span><span class="s1">// pass through the rest of the chunks as-is.</span><span class="s3">\n  </span><span class="s1">let didTransformFirstChunk = false</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">if (isBuildTimePrerendering &amp;&amp; !didTransformFirstChunk) {</span><span class="s3">\n        </span><span class="s1">didTransformFirstChunk = true</span><span class="s3">\n        </span><span class="s1">const decoder = new TextDecoder('utf-8', { fatal: true })</span><span class="s3">\n        </span><span class="s1">const chunkStr = decoder.decode(chunk, {</span><span class="s3">\n          </span><span class="s1">stream: true,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)</span><span class="s3">\n        </span><span class="s1">controller.enqueue(encoder.encode(updatedChunkStr))</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function renderToInitialFizzStream({</span><span class="s3">\n  </span><span class="s1">ReactDOMServer,</span><span class="s3">\n  </span><span class="s1">element,</span><span class="s3">\n  </span><span class="s1">streamOptions,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">ReactDOMServer: {</span><span class="s3">\n    </span><span class="s1">renderToReadableStream: typeof import('react-dom/server').renderToReadableStream</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">element: React.ReactElement</span><span class="s3">\n  </span><span class="s1">streamOptions?: Parameters&lt;typeof ReactDOMServer.renderToReadableStream&gt;[1]</span><span class="s3">\n</span><span class="s1">}): Promise&lt;ReactDOMServerReadableStream&gt; {</span><span class="s3">\n  </span><span class="s1">return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =&gt;</span><span class="s3">\n    </span><span class="s1">ReactDOMServer.renderToReadableStream(element, streamOptions)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createMetadataTransformStream(</span><span class="s3">\n  </span><span class="s1">insert: () =&gt; Promise&lt;string&gt; | string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let chunkIndex = -1</span><span class="s3">\n  </span><span class="s1">let isMarkRemoved = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">let iconMarkIndex = -1</span><span class="s3">\n      </span><span class="s1">let closedHeadIndex = -1</span><span class="s3">\n      </span><span class="s1">chunkIndex++</span><span class="s3">\n\n      </span><span class="s1">if (isMarkRemoved) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">let iconMarkLength = 0</span><span class="s3">\n      </span><span class="s1">// Only search for the closed head tag once</span><span class="s3">\n      </span><span class="s1">if (iconMarkIndex === -1) {</span><span class="s3">\n        </span><span class="s1">iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)</span><span class="s3">\n        </span><span class="s1">if (iconMarkIndex === -1) {</span><span class="s3">\n          </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// When we found the `&lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">nxt-icon</span><span class="s3">\&quot;</span><span class="s1">` tag prefix, we will remove it from the chunk.</span><span class="s3">\n          </span><span class="s1">// Its close tag could either be `/&gt;` or `&gt;`, checking the next char to ensure we cover both cases.</span><span class="s3">\n          </span><span class="s1">iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length</span><span class="s3">\n          </span><span class="s1">// Check if next char is /, this is for xml mode.</span><span class="s3">\n          </span><span class="s1">if (chunk[iconMarkIndex + iconMarkLength] === 47) {</span><span class="s3">\n            </span><span class="s1">iconMarkLength += 2</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The last char is `&gt;`</span><span class="s3">\n            </span><span class="s1">iconMarkLength++</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check if icon mark is inside &lt;head&gt; tag in the first chunk.</span><span class="s3">\n      </span><span class="s1">if (chunkIndex === 0) {</span><span class="s3">\n        </span><span class="s1">closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)</span><span class="s3">\n        </span><span class="s1">if (iconMarkIndex !== -1) {</span><span class="s3">\n          </span><span class="s1">// The mark icon is located in the 1st chunk before the head tag.</span><span class="s3">\n          </span><span class="s1">// We do not need to insert the script tag in this case because it's in the head.</span><span class="s3">\n          </span><span class="s1">// Just remove the icon mark from the chunk.</span><span class="s3">\n          </span><span class="s1">if (iconMarkIndex &lt; closedHeadIndex) {</span><span class="s3">\n            </span><span class="s1">const replaced = new Uint8Array(chunk.length - iconMarkLength)</span><span class="s3">\n\n            </span><span class="s1">// Remove the icon mark from the chunk.</span><span class="s3">\n            </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n            </span><span class="s1">replaced.set(</span><span class="s3">\n              </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n              </span><span class="s1">iconMarkIndex</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">chunk = replaced</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The icon mark is after the head tag, replace and insert the script tag at that position.</span><span class="s3">\n            </span><span class="s1">const insertion = await insert()</span><span class="s3">\n            </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n            </span><span class="s1">const insertionLength = encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">const replaced = new Uint8Array(</span><span class="s3">\n              </span><span class="s1">chunk.length - iconMarkLength + insertionLength</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n            </span><span class="s1">replaced.set(encodedInsertion, iconMarkIndex)</span><span class="s3">\n            </span><span class="s1">replaced.set(</span><span class="s3">\n              </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n              </span><span class="s1">iconMarkIndex + insertionLength</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">chunk = replaced</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">isMarkRemoved = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If there's no icon mark located, it will be handled later when if present in the following chunks.</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// When it's appeared in the following chunks, we'll need to</span><span class="s3">\n        </span><span class="s1">// remove the mark and then insert the script tag at that position.</span><span class="s3">\n        </span><span class="s1">const insertion = await insert()</span><span class="s3">\n        </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n        </span><span class="s1">const insertionLength = encodedInsertion.length</span><span class="s3">\n        </span><span class="s1">// Replace the icon mark with the hoist script or empty string.</span><span class="s3">\n        </span><span class="s1">const replaced = new Uint8Array(</span><span class="s3">\n          </span><span class="s1">chunk.length - iconMarkLength + insertionLength</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">// Set the first part of the chunk, before the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n        </span><span class="s1">// Set the insertion after the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(encodedInsertion, iconMarkIndex)</span><span class="s3">\n\n        </span><span class="s1">// Set the rest of the chunk after the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(</span><span class="s3">\n          </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n          </span><span class="s1">iconMarkIndex + insertionLength</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">chunk = replaced</span><span class="s3">\n        </span><span class="s1">isMarkRemoved = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createHeadInsertionTransformStream(</span><span class="s3">\n  </span><span class="s1">insert: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let inserted = false</span><span class="s3">\n\n  </span><span class="s1">// We need to track if this transform saw any bytes because if it didn't</span><span class="s3">\n  </span><span class="s1">// we won't want to insert any server HTML at all</span><span class="s3">\n  </span><span class="s1">let hasBytes = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">hasBytes = true</span><span class="s3">\n\n      </span><span class="s1">const insertion = await insert()</span><span class="s3">\n      </span><span class="s1">if (inserted) {</span><span class="s3">\n        </span><span class="s1">if (insertion) {</span><span class="s3">\n          </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n          </span><span class="s1">controller.enqueue(encodedInsertion)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.</span><span class="s3">\n        </span><span class="s1">const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)</span><span class="s3">\n        </span><span class="s1">// In fully static rendering or non PPR rendering cases:</span><span class="s3">\n        </span><span class="s1">// `/head&gt;` will always be found in the chunk in first chunk rendering.</span><span class="s3">\n        </span><span class="s1">if (index !== -1) {</span><span class="s3">\n          </span><span class="s1">if (insertion) {</span><span class="s3">\n            </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n            </span><span class="s1">// Get the total count of the bytes in the chunk and the insertion</span><span class="s3">\n            </span><span class="s1">// e.g.</span><span class="s3">\n            </span><span class="s1">// chunk = &lt;head&gt;&lt;meta charset=</span><span class="s3">\&quot;</span><span class="s1">utf-8</span><span class="s3">\&quot;</span><span class="s1">&gt;&lt;/head&gt;</span><span class="s3">\n            </span><span class="s1">// insertion = &lt;script&gt;...&lt;/script&gt;</span><span class="s3">\n            </span><span class="s1">// output = &lt;head&gt;&lt;meta charset=</span><span class="s3">\&quot;</span><span class="s1">utf-8</span><span class="s3">\&quot;</span><span class="s1">&gt; [ &lt;script&gt;...&lt;/script&gt; ] &lt;/head&gt;</span><span class="s3">\n            </span><span class="s1">const insertedHeadContent = new Uint8Array(</span><span class="s3">\n              </span><span class="s1">chunk.length + encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">// Append the first part of the chunk, before the head tag</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(chunk.slice(0, index))</span><span class="s3">\n            </span><span class="s1">// Append the server inserted content</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(encodedInsertion, index)</span><span class="s3">\n            </span><span class="s1">// Append the rest of the chunk</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(</span><span class="s3">\n              </span><span class="s1">chunk.slice(index),</span><span class="s3">\n              </span><span class="s1">index + encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">controller.enqueue(insertedHeadContent)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">inserted = true</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// This will happens in PPR rendering during next start, when the page is partially rendered.</span><span class="s3">\n          </span><span class="s1">// When the page resumes, the head tag will be found in the middle of the chunk.</span><span class="s3">\n          </span><span class="s1">// Where we just need to append the insertion and chunk to the current stream.</span><span class="s3">\n          </span><span class="s1">// e.g.</span><span class="s3">\n          </span><span class="s1">// PPR-static: &lt;head&gt;...&lt;/head&gt;&lt;body&gt; [ resume content ] &lt;/body&gt;</span><span class="s3">\n          </span><span class="s1">// PPR-resume: [ insertion ] [ rest content ]</span><span class="s3">\n          </span><span class="s1">if (insertion) {</span><span class="s3">\n            </span><span class="s1">controller.enqueue(encoder.encode(insertion))</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">inserted = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">async flush(controller) {</span><span class="s3">\n      </span><span class="s1">// Check before closing if there's anything remaining to insert.</span><span class="s3">\n      </span><span class="s1">if (hasBytes) {</span><span class="s3">\n        </span><span class="s1">const insertion = await insert()</span><span class="s3">\n        </span><span class="s1">if (insertion) {</span><span class="s3">\n          </span><span class="s1">controller.enqueue(encoder.encode(insertion))</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Suffix after main body content - scripts before &lt;/body&gt;,</span><span class="s3">\n</span><span class="s1">// but wait for the major chunks to be enqueued.</span><span class="s3">\n</span><span class="s1">function createDeferredSuffixStream(</span><span class="s3">\n  </span><span class="s1">suffix: string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let flushed = false</span><span class="s3">\n  </span><span class="s1">let pending: DetachedPromise&lt;void&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const flush = (controller: TransformStreamDefaultController) =&gt; {</span><span class="s3">\n    </span><span class="s1">const detached = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">pending = detached</span><span class="s3">\n\n    </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(encoder.encode(suffix))</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// If an error occurs while enqueuing it can't be due to this</span><span class="s3">\n        </span><span class="s1">// transformers fault. It's likely due to the controller being</span><span class="s3">\n        </span><span class="s1">// errored due to the stream being cancelled.</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">pending = undefined</span><span class="s3">\n        </span><span class="s1">detached.resolve()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n\n      </span><span class="s1">// If we've already flushed, we're done.</span><span class="s3">\n      </span><span class="s1">if (flushed) return</span><span class="s3">\n\n      </span><span class="s1">// Schedule the flush to happen.</span><span class="s3">\n      </span><span class="s1">flushed = true</span><span class="s3">\n      </span><span class="s1">flush(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">if (pending) return pending.promise</span><span class="s3">\n      </span><span class="s1">if (flushed) return</span><span class="s3">\n\n      </span><span class="s1">// Flush now.</span><span class="s3">\n      </span><span class="s1">controller.enqueue(encoder.encode(suffix))</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createFlightDataInjectionTransformStream(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">delayDataUntilFirstHtmlChunk: boolean</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let htmlStreamFinished = false</span><span class="s3">\n\n  </span><span class="s1">let pull: Promise&lt;void&gt; | null = null</span><span class="s3">\n  </span><span class="s1">let donePulling = false</span><span class="s3">\n\n  </span><span class="s1">function startOrContinuePulling(</span><span class="s3">\n    </span><span class="s1">controller: TransformStreamDefaultController</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!pull) {</span><span class="s3">\n      </span><span class="s1">pull = startPulling(controller)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pull</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async function startPulling(controller: TransformStreamDefaultController) {</span><span class="s3">\n    </span><span class="s1">const reader = stream.getReader()</span><span class="s3">\n\n    </span><span class="s1">if (delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n      </span><span class="s1">// NOTE: streaming flush</span><span class="s3">\n      </span><span class="s1">// We are buffering here for the inlined data stream because the</span><span class="s3">\n      </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">shell</span><span class="s3">\&quot; </span><span class="s1">stream might be chunkenized again by the underlying stream</span><span class="s3">\n      </span><span class="s1">// implementation, e.g. with a specific high-water mark. To ensure it's</span><span class="s3">\n      </span><span class="s1">// the safe timing to pipe the data stream, this extra tick is</span><span class="s3">\n      </span><span class="s1">// necessary.</span><span class="s3">\n\n      </span><span class="s1">// We don't start reading until we've left the current Task to ensure</span><span class="s3">\n      </span><span class="s1">// that it's inserted after flushing the shell. Note that this implementation</span><span class="s3">\n      </span><span class="s1">// might get stale if impl details of Fizz change in the future.</span><span class="s3">\n      </span><span class="s1">await atLeastOneTask()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n        </span><span class="s1">if (done) {</span><span class="s3">\n          </span><span class="s1">donePulling = true</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// We want to prioritize HTML over RSC data.</span><span class="s3">\n        </span><span class="s1">// The SSR render is based on the same RSC stream, so when we get a new RSC chunk,</span><span class="s3">\n        </span><span class="s1">// we're likely to produce an HTML chunk as well, so give it a chance to flush first.</span><span class="s3">\n        </span><span class="s1">if (!delayDataUntilFirstHtmlChunk &amp;&amp; !htmlStreamFinished) {</span><span class="s3">\n          </span><span class="s1">await atLeastOneTask()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">controller.enqueue(value)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">controller.error(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">if (!delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n        </span><span class="s1">startOrContinuePulling(controller)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n\n      </span><span class="s1">// Start the streaming if it hasn't already been started yet.</span><span class="s3">\n      </span><span class="s1">if (delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n        </span><span class="s1">startOrContinuePulling(controller)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">htmlStreamFinished = true</span><span class="s3">\n      </span><span class="s1">if (donePulling) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return startOrContinuePulling(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const CLOSE_TAG = '&lt;/body&gt;&lt;/html&gt;'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This transform stream moves the suffix to the end of the stream, so results</span><span class="s3">\n </span><span class="s1">* like `&lt;/body&gt;&lt;/html&gt;&lt;script&gt;...&lt;/script&gt;` will be transformed to</span><span class="s3">\n </span><span class="s1">* `&lt;script&gt;...&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createMoveSuffixStream(): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let foundSuffix = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">if (foundSuffix) {</span><span class="s3">\n        </span><span class="s1">return controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)</span><span class="s3">\n      </span><span class="s1">if (index &gt; -1) {</span><span class="s3">\n        </span><span class="s1">foundSuffix = true</span><span class="s3">\n\n        </span><span class="s1">// If the whole chunk is the suffix, then don't write anything, it will</span><span class="s3">\n        </span><span class="s1">// be written in the flush.</span><span class="s3">\n        </span><span class="s1">if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Write out the part before the suffix.</span><span class="s3">\n        </span><span class="s1">const before = chunk.slice(0, index)</span><span class="s3">\n        </span><span class="s1">controller.enqueue(before)</span><span class="s3">\n\n        </span><span class="s1">// In the case where the suffix is in the middle of the chunk, we need</span><span class="s3">\n        </span><span class="s1">// to split the chunk into two parts.</span><span class="s3">\n        </span><span class="s1">if (chunk.length &gt; ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {</span><span class="s3">\n          </span><span class="s1">// Write out the part after the suffix.</span><span class="s3">\n          </span><span class="s1">const after = chunk.slice(</span><span class="s3">\n            </span><span class="s1">index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">controller.enqueue(after)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">// Even if we didn't find the suffix, the HTML is not valid if we don't</span><span class="s3">\n      </span><span class="s1">// add it, so insert it at the end.</span><span class="s3">\n      </span><span class="s1">controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createStripDocumentClosingTagsTransform(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// We rely on the assumption that chunks will never break across a code unit.</span><span class="s3">\n      </span><span class="s1">// This is reasonable because we currently concat all of React's output from a single</span><span class="s3">\n      </span><span class="s1">// flush into one chunk before streaming it forward which means the chunk will represent</span><span class="s3">\n      </span><span class="s1">// a single coherent utf-8 string. This is not safe to use if we change our streaming to no</span><span class="s3">\n      </span><span class="s1">// longer do this large buffered chunk</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// the entire chunk is the closing tags; return without enqueueing anything.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We assume these tags will go at together at the end of the document and that</span><span class="s3">\n      </span><span class="s1">// they won't appear anywhere else in the document. This is not really a safe assumption</span><span class="s3">\n      </span><span class="s1">// but until we revamp our streaming infra this is a performant way to string the tags</span><span class="s3">\n      </span><span class="s1">chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)</span><span class="s3">\n      </span><span class="s1">chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Checks if the root layout is missing the html or body tags</span><span class="s3">\n </span><span class="s1">* and if so, it will inject a script tag to throw an error in the browser, showing the user</span><span class="s3">\n </span><span class="s1">* the error message in the error overlay.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createRootLayoutValidatorStream(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">let foundHtml = false</span><span class="s3">\n  </span><span class="s1">let foundBody = false</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// Peek into the streamed chunk to see if the tags are present.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!foundHtml &amp;&amp;</span><span class="s3">\n        </span><span class="s1">indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) &gt; -1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">foundHtml = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!foundBody &amp;&amp;</span><span class="s3">\n        </span><span class="s1">indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) &gt; -1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">foundBody = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">const missingTags: ('html' | 'body')[] = []</span><span class="s3">\n      </span><span class="s1">if (!foundHtml) missingTags.push('html')</span><span class="s3">\n      </span><span class="s1">if (!foundBody) missingTags.push('body')</span><span class="s3">\n\n      </span><span class="s1">if (!missingTags.length) return</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(</span><span class="s3">\n        </span><span class="s1">encoder.encode(</span><span class="s3">\n          </span><span class="s1">`&lt;html id=</span><span class="s3">\&quot;</span><span class="s1">__next_error__</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\n            </span><span class="s1">&lt;template</span><span class="s3">\n              </span><span class="s1">data-next-error-message=</span><span class="s3">\&quot;</span><span class="s1">Missing ${missingTags</span><span class="s3">\n                </span><span class="s1">.map((c) =&gt; `&lt;${c}&gt;`)</span><span class="s3">\n                </span><span class="s1">.join(</span><span class="s3">\n                  </span><span class="s1">missingTags.length &gt; 1 ? ' and ' : ''</span><span class="s3">\n                </span><span class="s1">)} tags in the root layout.</span><span class="s3">\\</span><span class="s1">nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags</span><span class="s3">\&quot;\n              </span><span class="s1">data-next-error-digest=</span><span class="s3">\&quot;</span><span class="s1">${MISSING_ROOT_TAGS_ERROR}</span><span class="s3">\&quot;\n              </span><span class="s1">data-next-error-stack=</span><span class="s3">\&quot;\&quot;\n            </span><span class="s1">&gt;&lt;/template&gt;</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function chainTransformers&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">readable: ReadableStream&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">transformers: ReadonlyArray&lt;TransformStream&lt;T, T&gt; | null&gt;</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">let stream = readable</span><span class="s3">\n  </span><span class="s1">for (const transformer of transformers) {</span><span class="s3">\n    </span><span class="s1">if (!transformer) continue</span><span class="s3">\n\n    </span><span class="s1">stream = stream.pipeThrough(transformer)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return stream</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ContinueStreamOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt; | undefined</span><span class="s3">\n  </span><span class="s1">isStaticGeneration: boolean</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">validateRootLayout?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Suffix to inject after the buffered data, but before the close tags.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">suffix?: string | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueFizzStream(</span><span class="s3">\n  </span><span class="s1">renderStream: ReactDOMServerReadableStream,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">suffix,</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">isStaticGeneration,</span><span class="s3">\n    </span><span class="s1">isBuildTimePrerendering,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n    </span><span class="s1">validateRootLayout,</span><span class="s3">\n  </span><span class="s1">}: ContinueStreamOptions</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadableStream&lt;Uint8Array&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">// Suffix itself might contain close tags at the end, so we need to split it.</span><span class="s3">\n  </span><span class="s1">const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null</span><span class="s3">\n\n  </span><span class="s1">// If we're generating static HTML we need to wait for it to resolve before continuing.</span><span class="s3">\n  </span><span class="s1">if (isStaticGeneration) {</span><span class="s3">\n    </span><span class="s1">await renderStream.allReady</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return chainTransformers(renderStream, [</span><span class="s3">\n    </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n    </span><span class="s1">createBufferedTransformStream(),</span><span class="s3">\n\n    </span><span class="s1">// Add build id comment to start of the HTML document (in export mode)</span><span class="s3">\n    </span><span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId),</span><span class="s3">\n\n    </span><span class="s1">// Transform metadata</span><span class="s3">\n    </span><span class="s1">createMetadataTransformStream(getServerInsertedMetadata),</span><span class="s3">\n\n    </span><span class="s1">// Insert suffix content</span><span class="s3">\n    </span><span class="s1">suffixUnclosed != null &amp;&amp; suffixUnclosed.length &gt; 0</span><span class="s3">\n      </span><span class="s1">? createDeferredSuffixStream(suffixUnclosed)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n\n    </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n    </span><span class="s1">inlinedDataStream</span><span class="s3">\n      </span><span class="s1">? createFlightDataInjectionTransformStream(inlinedDataStream, true)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n\n    </span><span class="s1">// Validate the root layout for missing html or body tags</span><span class="s3">\n    </span><span class="s1">validateRootLayout ? createRootLayoutValidatorStream() : null,</span><span class="s3">\n\n    </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n    </span><span class="s1">createMoveSuffixStream(),</span><span class="s3">\n\n    </span><span class="s1">// Special head insertions</span><span class="s3">\n    </span><span class="s1">// TODO-APP: Insert server side html to end of head in app layout rendering, to avoid</span><span class="s3">\n    </span><span class="s1">// hydration errors. Remove this once it's ready to be handled by react itself.</span><span class="s3">\n    </span><span class="s1">createHeadInsertionTransformStream(getServerInsertedHTML),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueDynamicPrerenderOptions = {</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueDynamicPrerender(</span><span class="s3">\n  </span><span class="s1">prerenderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n  </span><span class="s1">}: ContinueDynamicPrerenderOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prerenderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createStripDocumentClosingTagsTransform())</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueStaticPrerenderOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueStaticPrerender(</span><span class="s3">\n  </span><span class="s1">prerenderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n    </span><span class="s1">isBuildTimePrerendering,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n  </span><span class="s1">}: ContinueStaticPrerenderOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prerenderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">// Add build id comment to start of the HTML document (in export mode)</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n      </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createFlightDataInjectionTransformStream(inlinedDataStream, true)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMoveSuffixStream())</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueResumeOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">delayDataUntilFirstHtmlChunk: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueDynamicHTMLResume(</span><span class="s3">\n  </span><span class="s1">renderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">delayDataUntilFirstHtmlChunk,</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n  </span><span class="s1">}: ContinueResumeOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">renderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n      </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createFlightDataInjectionTransformStream(</span><span class="s3">\n          </span><span class="s1">inlinedDataStream,</span><span class="s3">\n          </span><span class="s1">delayDataUntilFirstHtmlChunk</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMoveSuffixStream())</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createDocumentClosingStream(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return streamFromString(CLOSE_TAG)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const ENCODED_TAGS = {</span><span class="s3">\n  </span><span class="s1">// opening tags do not have the closing `&gt;` since they can contain other attributes such as `&lt;body className=''&gt;`</span><span class="s3">\n  </span><span class="s1">OPENING: {</span><span class="s3">\n    </span><span class="s1">// &lt;html</span><span class="s3">\n    </span><span class="s1">HTML: new Uint8Array([60, 104, 116, 109, 108]),</span><span class="s3">\n    </span><span class="s1">// &lt;body</span><span class="s3">\n    </span><span class="s1">BODY: new Uint8Array([60, 98, 111, 100, 121]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">CLOSED: {</span><span class="s3">\n    </span><span class="s1">// &lt;/head&gt;</span><span class="s3">\n    </span><span class="s1">HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/body&gt;</span><span class="s3">\n    </span><span class="s1">BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/html&gt;</span><span class="s3">\n    </span><span class="s1">HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/body&gt;&lt;/html&gt;</span><span class="s3">\n    </span><span class="s1">BODY_AND_HTML: new Uint8Array([</span><span class="s3">\n      </span><span class="s1">60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">META: {</span><span class="s3">\n    </span><span class="s1">// Only the match the prefix cause the suffix can be different wether it's xml compatible or not </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">/&gt;</span><span class="s3">\&quot;\n    </span><span class="s1">// &lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">nxt-icon</span><span class="s3">\&quot;\n    </span><span class="s1">// This is a special mark that will be replaced by the icon insertion script tag.</span><span class="s3">\n    </span><span class="s1">ICON_MARK: new Uint8Array([</span><span class="s3">\n      </span><span class="s1">60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,</span><span class="s3">\n      </span><span class="s1">116, 45, 105, 99, 111, 110, 194, 187, 34,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds the provided prefix to the given path. It first ensures that the path</span><span class="s3">\n </span><span class="s1">* is indeed starting with a slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addPathPrefix(path: string, prefix?: string) {</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/') || !prefix) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname, query, hash } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return `${prefix}${pathname}${query}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Similarly to `addPathPrefix`, this function adds a suffix at the end on the</span><span class="s3">\n </span><span class="s1">* provided path. It also works only for paths ensuring the argument starts</span><span class="s3">\n </span><span class="s1">* with a slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addPathSuffix(path: string, suffix?: string) {</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/') || !suffix) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname, query, hash } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return `${pathname}${suffix}${query}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type { DomainLocale, I18NConfig } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../lib/i18n-provider'</span><span class="s3">\n\n</span><span class="s1">import { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale'</span><span class="s3">\n</span><span class="s1">import { formatNextPathnameInfo } from '../../shared/lib/router/utils/format-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import { getNextPathnameInfo } from '../../shared/lib/router/utils/get-next-pathname-info'</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">base?: string | URL</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">forceLocale?: boolean</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: I18NConfig | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">i18nProvider?: I18NProvider</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const REGEX_LOCALHOST_HOSTNAME =</span><span class="s3">\n  </span><span class="s1">/(?!^https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/)(127(?:</span><span class="s3">\\</span><span class="s1">.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|</span><span class="s3">\\</span><span class="s1">[::1</span><span class="s3">\\</span><span class="s1">]|localhost)/</span><span class="s3">\n\n</span><span class="s1">function parseURL(url: string | URL, base?: string | URL) {</span><span class="s3">\n  </span><span class="s1">return new URL(</span><span class="s3">\n    </span><span class="s1">String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'),</span><span class="s3">\n    </span><span class="s1">base &amp;&amp; String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const Internal = Symbol('NextURLInternal')</span><span class="s3">\n\n</span><span class="s1">export class NextURL {</span><span class="s3">\n  </span><span class="s1">private [Internal]: {</span><span class="s3">\n    </span><span class="s1">basePath: string</span><span class="s3">\n    </span><span class="s1">buildId?: string</span><span class="s3">\n    </span><span class="s1">flightSearchParameters?: Record&lt;string, string&gt;</span><span class="s3">\n    </span><span class="s1">defaultLocale?: string</span><span class="s3">\n    </span><span class="s1">domainLocale?: DomainLocale</span><span class="s3">\n    </span><span class="s1">locale?: string</span><span class="s3">\n    </span><span class="s1">options: Options</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n    </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(input: string | URL, base?: string | URL, opts?: Options)</span><span class="s3">\n  </span><span class="s1">constructor(input: string | URL, opts?: Options)</span><span class="s3">\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">input: string | URL,</span><span class="s3">\n    </span><span class="s1">baseOrOpts?: string | URL | Options,</span><span class="s3">\n    </span><span class="s1">opts?: Options</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let base: undefined | string | URL</span><span class="s3">\n    </span><span class="s1">let options: Options</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(typeof baseOrOpts === 'object' &amp;&amp; 'pathname' in baseOrOpts) ||</span><span class="s3">\n      </span><span class="s1">typeof baseOrOpts === 'string'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">base = baseOrOpts</span><span class="s3">\n      </span><span class="s1">options = opts || {}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">options = opts || baseOrOpts || {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[Internal] = {</span><span class="s3">\n      </span><span class="s1">url: parseURL(input, base ?? options.base),</span><span class="s3">\n      </span><span class="s1">options: options,</span><span class="s3">\n      </span><span class="s1">basePath: '',</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.analyze()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private analyze() {</span><span class="s3">\n    </span><span class="s1">const info = getNextPathnameInfo(this[Internal].url.pathname, {</span><span class="s3">\n      </span><span class="s1">nextConfig: this[Internal].options.nextConfig,</span><span class="s3">\n      </span><span class="s1">parseData: !process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE,</span><span class="s3">\n      </span><span class="s1">i18nProvider: this[Internal].options.i18nProvider,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const hostname = getHostname(</span><span class="s3">\n      </span><span class="s1">this[Internal].url,</span><span class="s3">\n      </span><span class="s1">this[Internal].options.headers</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this[Internal].domainLocale = this[Internal].options.i18nProvider</span><span class="s3">\n      </span><span class="s1">? this[Internal].options.i18nProvider.detectDomainLocale(hostname)</span><span class="s3">\n      </span><span class="s1">: detectDomainLocale(</span><span class="s3">\n          </span><span class="s1">this[Internal].options.nextConfig?.i18n?.domains,</span><span class="s3">\n          </span><span class="s1">hostname</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const defaultLocale =</span><span class="s3">\n      </span><span class="s1">this[Internal].domainLocale?.defaultLocale ||</span><span class="s3">\n      </span><span class="s1">this[Internal].options.nextConfig?.i18n?.defaultLocale</span><span class="s3">\n\n    </span><span class="s1">this[Internal].url.pathname = info.pathname</span><span class="s3">\n    </span><span class="s1">this[Internal].defaultLocale = defaultLocale</span><span class="s3">\n    </span><span class="s1">this[Internal].basePath = info.basePath ?? ''</span><span class="s3">\n    </span><span class="s1">this[Internal].buildId = info.buildId</span><span class="s3">\n    </span><span class="s1">this[Internal].locale = info.locale ?? defaultLocale</span><span class="s3">\n    </span><span class="s1">this[Internal].trailingSlash = info.trailingSlash</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private formatPathname() {</span><span class="s3">\n    </span><span class="s1">return formatNextPathnameInfo({</span><span class="s3">\n      </span><span class="s1">basePath: this[Internal].basePath,</span><span class="s3">\n      </span><span class="s1">buildId: this[Internal].buildId,</span><span class="s3">\n      </span><span class="s1">defaultLocale: !this[Internal].options.forceLocale</span><span class="s3">\n        </span><span class="s1">? this[Internal].defaultLocale</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">locale: this[Internal].locale,</span><span class="s3">\n      </span><span class="s1">pathname: this[Internal].url.pathname,</span><span class="s3">\n      </span><span class="s1">trailingSlash: this[Internal].trailingSlash,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private formatSearch() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get buildId() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].buildId</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set buildId(buildId: string | undefined) {</span><span class="s3">\n    </span><span class="s1">this[Internal].buildId = buildId</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get locale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].locale ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set locale(locale: string) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this[Internal].locale ||</span><span class="s3">\n      </span><span class="s1">!this[Internal].options.nextConfig?.i18n?.locales.includes(locale)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(</span><span class="s3">\n        </span><span class="s1">`The NextURL configuration includes no locale </span><span class="s3">\&quot;</span><span class="s1">${locale}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[Internal].locale = locale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get defaultLocale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].defaultLocale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get domainLocale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].domainLocale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get searchParams() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.searchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get host() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.host</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set host(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.host = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get hostname() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.hostname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set hostname(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.hostname = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get port() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.port</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set port(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.port = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get protocol() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.protocol</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set protocol(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.protocol = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get href() {</span><span class="s3">\n    </span><span class="s1">const pathname = this.formatPathname()</span><span class="s3">\n    </span><span class="s1">const search = this.formatSearch()</span><span class="s3">\n    </span><span class="s1">return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set href(url: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url = parseURL(url)</span><span class="s3">\n    </span><span class="s1">this.analyze()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get origin() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.origin</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get pathname() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set pathname(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.pathname = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get hash() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.hash</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set hash(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.hash = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get search() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set search(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.search = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get password() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.password</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set password(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.password = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get username() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.username</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set username(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.username = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get basePath() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].basePath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set basePath(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].basePath = value.startsWith('/') ? value : `/${value}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return this.href</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toJSON() {</span><span class="s3">\n    </span><span class="s1">return this.href</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.for('edge-runtime.inspect.custom')]() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">href: this.href,</span><span class="s3">\n      </span><span class="s1">origin: this.origin,</span><span class="s3">\n      </span><span class="s1">protocol: this.protocol,</span><span class="s3">\n      </span><span class="s1">username: this.username,</span><span class="s3">\n      </span><span class="s1">password: this.password,</span><span class="s3">\n      </span><span class="s1">host: this.host,</span><span class="s3">\n      </span><span class="s1">hostname: this.hostname,</span><span class="s3">\n      </span><span class="s1">port: this.port,</span><span class="s3">\n      </span><span class="s1">pathname: this.pathname,</span><span class="s3">\n      </span><span class="s1">search: this.search,</span><span class="s3">\n      </span><span class="s1">searchParams: this.searchParams,</span><span class="s3">\n      </span><span class="s1">hash: this.hash,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">clone() {</span><span class="s3">\n    </span><span class="s1">return new NextURL(String(this), this[Internal].options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizeLocalePath } from '../../i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from './remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../../../../server/lib/i18n-provider'</span><span class="s3">\n\n</span><span class="s1">export interface NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The base path in case the pathname included it.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">basePath?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The buildId for when the parsed URL is a data URL. Parsing it can be</span><span class="s3">\n   </span><span class="s1">* disabled with the `parseData` option.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">buildId?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If there was a locale in the pathname, this will hold its value.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The processed pathname without a base path, locale, or data URL elements</span><span class="s3">\n   </span><span class="s1">* when parsing it is enabled.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A boolean telling if the pathname had a trailingSlash. This can be only</span><span class="s3">\n   </span><span class="s1">* true if trailingSlash is enabled.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When passed to true, this function will also parse Nextjs data URLs.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">parseData?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A partial of the Next.js configuration to parse the URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: { locales?: readonly string[] } | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If provided, this normalizer will be used to detect the locale instead of</span><span class="s3">\n   </span><span class="s1">* the default locale detection.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">i18nProvider?: I18NProvider</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getNextPathnameInfo(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">options: Options</span><span class="s3">\n</span><span class="s1">): NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">const { basePath, i18n, trailingSlash } = options.nextConfig ?? {}</span><span class="s3">\n  </span><span class="s1">const info: NextPathnameInfo = {</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (basePath &amp;&amp; pathHasPrefix(info.pathname, basePath)) {</span><span class="s3">\n    </span><span class="s1">info.pathname = removePathPrefix(info.pathname, basePath)</span><span class="s3">\n    </span><span class="s1">info.basePath = basePath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let pathnameNoDataPrefix = info.pathname</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">info.pathname.startsWith('/_next/data/') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">info.pathname.endsWith('.json')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const paths = info.pathname</span><span class="s3">\n      </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">/data</span><span class="s3">\\</span><span class="s1">//, '')</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">.json$/, '')</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n\n    </span><span class="s1">const buildId = paths[0]</span><span class="s3">\n    </span><span class="s1">info.buildId = buildId</span><span class="s3">\n    </span><span class="s1">pathnameNoDataPrefix =</span><span class="s3">\n      </span><span class="s1">paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/'</span><span class="s3">\n\n    </span><span class="s1">// update pathname with normalized if enabled although</span><span class="s3">\n    </span><span class="s1">// we use normalized to populate locale info still</span><span class="s3">\n    </span><span class="s1">if (options.parseData === true) {</span><span class="s3">\n      </span><span class="s1">info.pathname = pathnameNoDataPrefix</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If provided, use the locale route normalizer to detect the locale instead</span><span class="s3">\n  </span><span class="s1">// of the function below.</span><span class="s3">\n  </span><span class="s1">if (i18n) {</span><span class="s3">\n    </span><span class="s1">let result = options.i18nProvider</span><span class="s3">\n      </span><span class="s1">? options.i18nProvider.analyze(info.pathname)</span><span class="s3">\n      </span><span class="s1">: normalizeLocalePath(info.pathname, i18n.locales)</span><span class="s3">\n\n    </span><span class="s1">info.locale = result.detectedLocale</span><span class="s3">\n    </span><span class="s1">info.pathname = result.pathname ?? info.pathname</span><span class="s3">\n\n    </span><span class="s1">if (!result.detectedLocale &amp;&amp; info.buildId) {</span><span class="s3">\n      </span><span class="s1">result = options.i18nProvider</span><span class="s3">\n        </span><span class="s1">? options.i18nProvider.analyze(pathnameNoDataPrefix)</span><span class="s3">\n        </span><span class="s1">: normalizeLocalePath(pathnameNoDataPrefix, i18n.locales)</span><span class="s3">\n\n      </span><span class="s1">if (result.detectedLocale) {</span><span class="s3">\n        </span><span class="s1">info.locale = result.detectedLocale</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return info</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextPathnameInfo } from './get-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from './remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { addPathPrefix } from './add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { addPathSuffix } from './add-path-suffix'</span><span class="s3">\n</span><span class="s1">import { addLocale } from './add-locale'</span><span class="s3">\n\n</span><span class="s1">interface ExtendedInfo extends NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">ignorePrefix?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function formatNextPathnameInfo(info: ExtendedInfo) {</span><span class="s3">\n  </span><span class="s1">let pathname = addLocale(</span><span class="s3">\n    </span><span class="s1">info.pathname,</span><span class="s3">\n    </span><span class="s1">info.locale,</span><span class="s3">\n    </span><span class="s1">info.buildId ? undefined : info.defaultLocale,</span><span class="s3">\n    </span><span class="s1">info.ignorePrefix</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (info.buildId || !info.trailingSlash) {</span><span class="s3">\n    </span><span class="s1">pathname = removeTrailingSlash(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (info.buildId) {</span><span class="s3">\n    </span><span class="s1">pathname = addPathSuffix(</span><span class="s3">\n      </span><span class="s1">addPathPrefix(pathname, `/_next/data/${info.buildId}`),</span><span class="s3">\n      </span><span class="s1">info.pathname === '/' ? 'index.json' : '.json'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">pathname = addPathPrefix(pathname, info.basePath)</span><span class="s3">\n  </span><span class="s1">return !info.buildId &amp;&amp; info.trailingSlash</span><span class="s3">\n    </span><span class="s1">? !pathname.endsWith('/')</span><span class="s3">\n      </span><span class="s1">? addPathSuffix(pathname, '/')</span><span class="s3">\n      </span><span class="s1">: pathname</span><span class="s3">\n    </span><span class="s1">: removeTrailingSlash(pathname)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { addPathPrefix } from './add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* For a given path and a locale, if the locale is given, it will prefix the</span><span class="s3">\n </span><span class="s1">* locale. The path shouldn't be an API path. If a default locale is given the</span><span class="s3">\n </span><span class="s1">* prefix will be omitted if the locale is already the default locale.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addLocale(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">locale?: string | false,</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string,</span><span class="s3">\n  </span><span class="s1">ignorePrefix?: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// If no locale was given or the locale is the default locale, we don't need</span><span class="s3">\n  </span><span class="s1">// to prefix the path.</span><span class="s3">\n  </span><span class="s1">if (!locale || locale === defaultLocale) return path</span><span class="s3">\n\n  </span><span class="s1">const lower = path.toLowerCase()</span><span class="s3">\n\n  </span><span class="s1">// If the path is an API path or the path already has the locale prefix, we</span><span class="s3">\n  </span><span class="s1">// don't need to prefix the path.</span><span class="s3">\n  </span><span class="s1">if (!ignorePrefix) {</span><span class="s3">\n    </span><span class="s1">if (pathHasPrefix(lower, '/api')) return path</span><span class="s3">\n    </span><span class="s1">if (pathHasPrefix(lower, `/${locale.toLowerCase()}`)) return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Add the locale prefix to the path.</span><span class="s3">\n  </span><span class="s1">return addPathPrefix(path, `/${locale}`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { I18NConfig } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import { NextURL } from '../next-url'</span><span class="s3">\n</span><span class="s1">import { toNodeOutgoingHttpHeaders, validateURL } from '../utils'</span><span class="s3">\n</span><span class="s1">import { RemovedUAError, RemovedPageError } from '../error'</span><span class="s3">\n</span><span class="s1">import { RequestCookies } from './cookies'</span><span class="s3">\n\n</span><span class="s1">export const INTERNALS = Symbol('internal request')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This class extends the [Web `Request` API](https://developer.mozilla.org/docs/Web/API/Request) with additional convenience methods.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `NextRequest`](https://nextjs.org/docs/app/api-reference/functions/next-request)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class NextRequest extends Request {</span><span class="s3">\n  </span><span class="s1">/** @internal */</span><span class="s3">\n  </span><span class="s1">[INTERNALS]: {</span><span class="s3">\n    </span><span class="s1">cookies: RequestCookies</span><span class="s3">\n    </span><span class="s1">url: string</span><span class="s3">\n    </span><span class="s1">nextUrl: NextURL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(input: URL | RequestInfo, init: RequestInit = {}) {</span><span class="s3">\n    </span><span class="s1">const url =</span><span class="s3">\n      </span><span class="s1">typeof input !== 'string' &amp;&amp; 'url' in input ? input.url : String(input)</span><span class="s3">\n\n    </span><span class="s1">validateURL(url)</span><span class="s3">\n\n    </span><span class="s1">// node Request instance requires duplex option when a body</span><span class="s3">\n    </span><span class="s1">// is present or it errors, we don't handle this for</span><span class="s3">\n    </span><span class="s1">// Request being passed in since it would have already</span><span class="s3">\n    </span><span class="s1">// errored if this wasn't configured</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">if (init.body &amp;&amp; init.duplex !== 'half') {</span><span class="s3">\n        </span><span class="s1">init.duplex = 'half'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (input instanceof Request) super(input, init)</span><span class="s3">\n    </span><span class="s1">else super(url, init)</span><span class="s3">\n\n    </span><span class="s1">const nextUrl = new NextURL(url, {</span><span class="s3">\n      </span><span class="s1">headers: toNodeOutgoingHttpHeaders(this.headers),</span><span class="s3">\n      </span><span class="s1">nextConfig: init.nextConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">this[INTERNALS] = {</span><span class="s3">\n      </span><span class="s1">cookies: new RequestCookies(this.headers),</span><span class="s3">\n      </span><span class="s1">nextUrl,</span><span class="s3">\n      </span><span class="s1">url: process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE</span><span class="s3">\n        </span><span class="s1">? url</span><span class="s3">\n        </span><span class="s1">: nextUrl.toString(),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.for('edge-runtime.inspect.custom')]() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">cookies: this.cookies,</span><span class="s3">\n      </span><span class="s1">nextUrl: this.nextUrl,</span><span class="s3">\n      </span><span class="s1">url: this.url,</span><span class="s3">\n      </span><span class="s1">// rest of props come from Request</span><span class="s3">\n      </span><span class="s1">bodyUsed: this.bodyUsed,</span><span class="s3">\n      </span><span class="s1">cache: this.cache,</span><span class="s3">\n      </span><span class="s1">credentials: this.credentials,</span><span class="s3">\n      </span><span class="s1">destination: this.destination,</span><span class="s3">\n      </span><span class="s1">headers: Object.fromEntries(this.headers),</span><span class="s3">\n      </span><span class="s1">integrity: this.integrity,</span><span class="s3">\n      </span><span class="s1">keepalive: this.keepalive,</span><span class="s3">\n      </span><span class="s1">method: this.method,</span><span class="s3">\n      </span><span class="s1">mode: this.mode,</span><span class="s3">\n      </span><span class="s1">redirect: this.redirect,</span><span class="s3">\n      </span><span class="s1">referrer: this.referrer,</span><span class="s3">\n      </span><span class="s1">referrerPolicy: this.referrerPolicy,</span><span class="s3">\n      </span><span class="s1">signal: this.signal,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get cookies() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].cookies</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get nextUrl() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">* `page` has been deprecated in favour of `URLPattern`.</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-request-page</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get page() {</span><span class="s3">\n    </span><span class="s1">throw new RemovedPageError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">* `ua` has been removed in favour of </span><span class="s3">\\</span><span class="s1">`userAgent</span><span class="s3">\\</span><span class="s1">` function.</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get ua() {</span><span class="s3">\n    </span><span class="s1">throw new RemovedUAError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get url() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RequestInit extends globalThis.RequestInit {</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: I18NConfig | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n  </span><span class="s1">// see https://github.com/whatwg/fetch/pull/1457</span><span class="s3">\n  </span><span class="s1">duplex?: 'half'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { BaseNextRequest } from '../../../base-http'</span><span class="s3">\n</span><span class="s1">import type { NodeNextRequest } from '../../../base-http/node'</span><span class="s3">\n</span><span class="s1">import type { WebNextRequest } from '../../../base-http/web'</span><span class="s3">\n</span><span class="s1">import type { Writable } from 'node:stream'</span><span class="s3">\n\n</span><span class="s1">import { getRequestMeta } from '../../../request-meta'</span><span class="s3">\n</span><span class="s1">import { fromNodeOutgoingHttpHeaders } from '../../utils'</span><span class="s3">\n</span><span class="s1">import { NextRequest } from '../request'</span><span class="s3">\n</span><span class="s1">import { isNodeNextRequest, isWebNextRequest } from '../../../base-http/helpers'</span><span class="s3">\n\n</span><span class="s1">export const ResponseAbortedName = 'ResponseAborted'</span><span class="s3">\n</span><span class="s1">export class ResponseAborted extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly name = ResponseAbortedName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an AbortController tied to the closing of a ServerResponse (or other</span><span class="s3">\n </span><span class="s1">* appropriate Writable).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the `close` event is fired before the `finish` event, then we'll send the</span><span class="s3">\n </span><span class="s1">* `abort` signal.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createAbortController(response: Writable): AbortController {</span><span class="s3">\n  </span><span class="s1">const controller = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">// If `finish` fires first, then `res.end()` has been called and the close is</span><span class="s3">\n  </span><span class="s1">// just us finishing the stream on our side. If `close` fires first, then we</span><span class="s3">\n  </span><span class="s1">// know the client disconnected before we finished.</span><span class="s3">\n  </span><span class="s1">response.once('close', () =&gt; {</span><span class="s3">\n    </span><span class="s1">if (response.writableFinished) return</span><span class="s3">\n\n    </span><span class="s1">controller.abort(new ResponseAborted())</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return controller</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an AbortSignal tied to the closing of a ServerResponse (or other</span><span class="s3">\n </span><span class="s1">* appropriate Writable).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This cannot be done with the request (IncomingMessage or Readable) because</span><span class="s3">\n </span><span class="s1">* the `abort` event will not fire if to data has been fully read (because that</span><span class="s3">\n </span><span class="s1">* will </span><span class="s3">\&quot;</span><span class="s1">close</span><span class="s3">\&quot; </span><span class="s1">the readable stream and nothing fires after that).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function signalFromNodeResponse(response: Writable): AbortSignal {</span><span class="s3">\n  </span><span class="s1">const { errored, destroyed } = response</span><span class="s3">\n  </span><span class="s1">if (errored || destroyed) {</span><span class="s3">\n    </span><span class="s1">return AbortSignal.abort(errored ?? new ResponseAborted())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { signal } = createAbortController(response)</span><span class="s3">\n  </span><span class="s1">return signal</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class NextRequestAdapter {</span><span class="s3">\n  </span><span class="s1">public static fromBaseNextRequest(</span><span class="s3">\n    </span><span class="s1">request: BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal</span><span class="s3">\n  </span><span class="s1">): NextRequest {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME === 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isWebNextRequest(request)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return NextRequestAdapter.fromWebNextRequest(request)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isNodeNextRequest(request)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return NextRequestAdapter.fromNodeNextRequest(request, signal)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: Unsupported NextRequest type')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static fromNodeNextRequest(</span><span class="s3">\n    </span><span class="s1">request: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal</span><span class="s3">\n  </span><span class="s1">): NextRequest {</span><span class="s3">\n    </span><span class="s1">// HEAD and GET requests can not have a body.</span><span class="s3">\n    </span><span class="s1">let body: BodyInit | null = null</span><span class="s3">\n    </span><span class="s1">if (request.method !== 'GET' &amp;&amp; request.method !== 'HEAD' &amp;&amp; request.body) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error - this is handled by undici, when streams/web land use it instead</span><span class="s3">\n      </span><span class="s1">body = request.body</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let url: URL</span><span class="s3">\n    </span><span class="s1">if (request.url.startsWith('http')) {</span><span class="s3">\n      </span><span class="s1">url = new URL(request.url)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Grab the full URL from the request metadata.</span><span class="s3">\n      </span><span class="s1">const base = getRequestMeta(request, 'initURL')</span><span class="s3">\n      </span><span class="s1">if (!base || !base.startsWith('http')) {</span><span class="s3">\n        </span><span class="s1">// Because the URL construction relies on the fact that the URL provided</span><span class="s3">\n        </span><span class="s1">// is absolute, we need to provide a base URL. We can't use the request</span><span class="s3">\n        </span><span class="s1">// URL because it's relative, so we use a dummy URL instead.</span><span class="s3">\n        </span><span class="s1">url = new URL(request.url, 'http://n')</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">url = new URL(request.url, base)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new NextRequest(url, {</span><span class="s3">\n      </span><span class="s1">method: request.method,</span><span class="s3">\n      </span><span class="s1">headers: fromNodeOutgoingHttpHeaders(request.headers),</span><span class="s3">\n      </span><span class="s1">duplex: 'half',</span><span class="s3">\n      </span><span class="s1">signal,</span><span class="s3">\n      </span><span class="s1">// geo</span><span class="s3">\n      </span><span class="s1">// ip</span><span class="s3">\n      </span><span class="s1">// nextConfig</span><span class="s3">\n\n      </span><span class="s1">// body can not be passed if request was aborted</span><span class="s3">\n      </span><span class="s1">// or we get a Request body was disturbed error</span><span class="s3">\n      </span><span class="s1">...(signal.aborted</span><span class="s3">\n        </span><span class="s1">? {}</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">body,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static fromWebNextRequest(request: WebNextRequest): NextRequest {</span><span class="s3">\n    </span><span class="s1">// HEAD and GET requests can not have a body.</span><span class="s3">\n    </span><span class="s1">let body: ReadableStream | null = null</span><span class="s3">\n    </span><span class="s1">if (request.method !== 'GET' &amp;&amp; request.method !== 'HEAD') {</span><span class="s3">\n      </span><span class="s1">body = request.body</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new NextRequest(request.url, {</span><span class="s3">\n      </span><span class="s1">method: request.method,</span><span class="s3">\n      </span><span class="s1">headers: fromNodeOutgoingHttpHeaders(request.headers),</span><span class="s3">\n      </span><span class="s1">duplex: 'half',</span><span class="s3">\n      </span><span class="s1">signal: request.request.signal,</span><span class="s3">\n      </span><span class="s1">// geo</span><span class="s3">\n      </span><span class="s1">// ip</span><span class="s3">\n      </span><span class="s1">// nextConfig</span><span class="s3">\n\n      </span><span class="s1">// body can not be passed if request was aborted</span><span class="s3">\n      </span><span class="s1">// or we get a Request body was disturbed error</span><span class="s3">\n      </span><span class="s1">...(request.request.signal.aborted</span><span class="s3">\n        </span><span class="s1">? {}</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">body,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Contains predefined constants for the trace span name in next/server.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Currently, next/server/tracer is internal implementation only for tracking</span><span class="s3">\n </span><span class="s1">* next.js's implementation only with known span names defined here.</span><span class="s3">\n </span><span class="s1">**/</span><span class="s3">\n\n</span><span class="s1">// eslint typescript has a bug with TS enums</span><span class="s3">\n</span><span class="s1">/* eslint-disable no-shadow */</span><span class="s3">\n\n</span><span class="s1">enum BaseServerSpan {</span><span class="s3">\n  </span><span class="s1">handleRequest = 'BaseServer.handleRequest',</span><span class="s3">\n  </span><span class="s1">run = 'BaseServer.run',</span><span class="s3">\n  </span><span class="s1">pipe = 'BaseServer.pipe',</span><span class="s3">\n  </span><span class="s1">getStaticHTML = 'BaseServer.getStaticHTML',</span><span class="s3">\n  </span><span class="s1">render = 'BaseServer.render',</span><span class="s3">\n  </span><span class="s1">renderToResponseWithComponents = 'BaseServer.renderToResponseWithComponents',</span><span class="s3">\n  </span><span class="s1">renderToResponse = 'BaseServer.renderToResponse',</span><span class="s3">\n  </span><span class="s1">renderToHTML = 'BaseServer.renderToHTML',</span><span class="s3">\n  </span><span class="s1">renderError = 'BaseServer.renderError',</span><span class="s3">\n  </span><span class="s1">renderErrorToResponse = 'BaseServer.renderErrorToResponse',</span><span class="s3">\n  </span><span class="s1">renderErrorToHTML = 'BaseServer.renderErrorToHTML',</span><span class="s3">\n  </span><span class="s1">render404 = 'BaseServer.render404',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum LoadComponentsSpan {</span><span class="s3">\n  </span><span class="s1">loadDefaultErrorComponents = 'LoadComponents.loadDefaultErrorComponents',</span><span class="s3">\n  </span><span class="s1">loadComponents = 'LoadComponents.loadComponents',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NextServerSpan {</span><span class="s3">\n  </span><span class="s1">getRequestHandler = 'NextServer.getRequestHandler',</span><span class="s3">\n  </span><span class="s1">getServer = 'NextServer.getServer',</span><span class="s3">\n  </span><span class="s1">getServerRequestHandler = 'NextServer.getServerRequestHandler',</span><span class="s3">\n  </span><span class="s1">createServer = 'createServer.createServer',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NextNodeServerSpan {</span><span class="s3">\n  </span><span class="s1">compression = 'NextNodeServer.compression',</span><span class="s3">\n  </span><span class="s1">getBuildId = 'NextNodeServer.getBuildId',</span><span class="s3">\n  </span><span class="s1">createComponentTree = 'NextNodeServer.createComponentTree',</span><span class="s3">\n  </span><span class="s1">clientComponentLoading = 'NextNodeServer.clientComponentLoading',</span><span class="s3">\n  </span><span class="s1">getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule',</span><span class="s3">\n  </span><span class="s1">generateStaticRoutes = 'NextNodeServer.generateStaticRoutes',</span><span class="s3">\n  </span><span class="s1">generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes',</span><span class="s3">\n  </span><span class="s1">generatePublicRoutes = 'NextNodeServer.generatePublicRoutes',</span><span class="s3">\n  </span><span class="s1">generateImageRoutes = 'NextNodeServer.generateImageRoutes.route',</span><span class="s3">\n  </span><span class="s1">sendRenderResult = 'NextNodeServer.sendRenderResult',</span><span class="s3">\n  </span><span class="s1">proxyRequest = 'NextNodeServer.proxyRequest',</span><span class="s3">\n  </span><span class="s1">runApi = 'NextNodeServer.runApi',</span><span class="s3">\n  </span><span class="s1">render = 'NextNodeServer.render',</span><span class="s3">\n  </span><span class="s1">renderHTML = 'NextNodeServer.renderHTML',</span><span class="s3">\n  </span><span class="s1">imageOptimizer = 'NextNodeServer.imageOptimizer',</span><span class="s3">\n  </span><span class="s1">getPagePath = 'NextNodeServer.getPagePath',</span><span class="s3">\n  </span><span class="s1">getRoutesManifest = 'NextNodeServer.getRoutesManifest',</span><span class="s3">\n  </span><span class="s1">findPageComponents = 'NextNodeServer.findPageComponents',</span><span class="s3">\n  </span><span class="s1">getFontManifest = 'NextNodeServer.getFontManifest',</span><span class="s3">\n  </span><span class="s1">getServerComponentManifest = 'NextNodeServer.getServerComponentManifest',</span><span class="s3">\n  </span><span class="s1">getRequestHandler = 'NextNodeServer.getRequestHandler',</span><span class="s3">\n  </span><span class="s1">renderToHTML = 'NextNodeServer.renderToHTML',</span><span class="s3">\n  </span><span class="s1">renderError = 'NextNodeServer.renderError',</span><span class="s3">\n  </span><span class="s1">renderErrorToHTML = 'NextNodeServer.renderErrorToHTML',</span><span class="s3">\n  </span><span class="s1">render404 = 'NextNodeServer.render404',</span><span class="s3">\n  </span><span class="s1">startResponse = 'NextNodeServer.startResponse',</span><span class="s3">\n\n  </span><span class="s1">// nested inner span, does not require parent scope name</span><span class="s3">\n  </span><span class="s1">route = 'route',</span><span class="s3">\n  </span><span class="s1">onProxyReq = 'onProxyReq',</span><span class="s3">\n  </span><span class="s1">apiResolver = 'apiResolver',</span><span class="s3">\n  </span><span class="s1">internalFetch = 'internalFetch',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum StartServerSpan {</span><span class="s3">\n  </span><span class="s1">startServer = 'startServer.startServer',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum RenderSpan {</span><span class="s3">\n  </span><span class="s1">getServerSideProps = 'Render.getServerSideProps',</span><span class="s3">\n  </span><span class="s1">getStaticProps = 'Render.getStaticProps',</span><span class="s3">\n  </span><span class="s1">renderToString = 'Render.renderToString',</span><span class="s3">\n  </span><span class="s1">renderDocument = 'Render.renderDocument',</span><span class="s3">\n  </span><span class="s1">createBodyResult = 'Render.createBodyResult',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum AppRenderSpan {</span><span class="s3">\n  </span><span class="s1">renderToString = 'AppRender.renderToString',</span><span class="s3">\n  </span><span class="s1">renderToReadableStream = 'AppRender.renderToReadableStream',</span><span class="s3">\n  </span><span class="s1">getBodyResult = 'AppRender.getBodyResult',</span><span class="s3">\n  </span><span class="s1">fetch = 'AppRender.fetch',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum RouterSpan {</span><span class="s3">\n  </span><span class="s1">executeRoute = 'Router.executeRoute',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NodeSpan {</span><span class="s3">\n  </span><span class="s1">runHandler = 'Node.runHandler',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum AppRouteRouteHandlersSpan {</span><span class="s3">\n  </span><span class="s1">runHandler = 'AppRouteRouteHandlers.runHandler',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum ResolveMetadataSpan {</span><span class="s3">\n  </span><span class="s1">generateMetadata = 'ResolveMetadata.generateMetadata',</span><span class="s3">\n  </span><span class="s1">generateViewport = 'ResolveMetadata.generateViewport',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum MiddlewareSpan {</span><span class="s3">\n  </span><span class="s1">execute = 'Middleware.execute',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SpanTypes =</span><span class="s3">\n  </span><span class="s1">| `${BaseServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${LoadComponentsSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NextServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${StartServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NextNodeServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${RenderSpan}`</span><span class="s3">\n  </span><span class="s1">| `${RouterSpan}`</span><span class="s3">\n  </span><span class="s1">| `${AppRenderSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NodeSpan}`</span><span class="s3">\n  </span><span class="s1">| `${AppRouteRouteHandlersSpan}`</span><span class="s3">\n  </span><span class="s1">| `${ResolveMetadataSpan}`</span><span class="s3">\n  </span><span class="s1">| `${MiddlewareSpan}`</span><span class="s3">\n\n</span><span class="s1">// This list is used to filter out spans that are not relevant to the user</span><span class="s3">\n</span><span class="s1">export const NextVanillaSpanAllowlist = [</span><span class="s3">\n  </span><span class="s1">MiddlewareSpan.execute,</span><span class="s3">\n  </span><span class="s1">BaseServerSpan.handleRequest,</span><span class="s3">\n  </span><span class="s1">RenderSpan.getServerSideProps,</span><span class="s3">\n  </span><span class="s1">RenderSpan.getStaticProps,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan.fetch,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan.getBodyResult,</span><span class="s3">\n  </span><span class="s1">RenderSpan.renderDocument,</span><span class="s3">\n  </span><span class="s1">NodeSpan.runHandler,</span><span class="s3">\n  </span><span class="s1">AppRouteRouteHandlersSpan.runHandler,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan.generateMetadata,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan.generateViewport,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.createComponentTree,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.findPageComponents,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.getLayoutOrPageModule,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.startResponse,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.clientComponentLoading,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">// These Spans are allowed to be always logged</span><span class="s3">\n</span><span class="s1">// when the otel log prefix env is set</span><span class="s3">\n</span><span class="s1">export const LogSpanAllowList = [</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.findPageComponents,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.createComponentTree,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.clientComponentLoading,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">BaseServerSpan,</span><span class="s3">\n  </span><span class="s1">LoadComponentsSpan,</span><span class="s3">\n  </span><span class="s1">NextServerSpan,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan,</span><span class="s3">\n  </span><span class="s1">StartServerSpan,</span><span class="s3">\n  </span><span class="s1">RenderSpan,</span><span class="s3">\n  </span><span class="s1">RouterSpan,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan,</span><span class="s3">\n  </span><span class="s1">NodeSpan,</span><span class="s3">\n  </span><span class="s1">AppRouteRouteHandlersSpan,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan,</span><span class="s3">\n  </span><span class="s1">MiddlewareSpan,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type { SpanTypes }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AppPageModule } from './route-modules/app-page/module'</span><span class="s3">\n\n</span><span class="s1">// Combined load times for loading client components</span><span class="s3">\n</span><span class="s1">let clientComponentLoadStart = 0</span><span class="s3">\n</span><span class="s1">let clientComponentLoadTimes = 0</span><span class="s3">\n</span><span class="s1">let clientComponentLoadCount = 0</span><span class="s3">\n\n</span><span class="s1">export function wrapClientComponentLoader(</span><span class="s3">\n  </span><span class="s1">ComponentMod: AppPageModule</span><span class="s3">\n</span><span class="s1">): AppPageModule['__next_app__'] {</span><span class="s3">\n  </span><span class="s1">if (!('performance' in globalThis)) {</span><span class="s3">\n    </span><span class="s1">return ComponentMod.__next_app__</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">require: (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const startTime = performance.now()</span><span class="s3">\n\n      </span><span class="s1">if (clientComponentLoadStart === 0) {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadStart = startTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadCount += 1</span><span class="s3">\n        </span><span class="s1">return ComponentMod.__next_app__.require(...args)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadTimes += performance.now() - startTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">loadChunk: (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const startTime = performance.now()</span><span class="s3">\n      </span><span class="s1">const result = ComponentMod.__next_app__.loadChunk(...args)</span><span class="s3">\n      </span><span class="s1">// Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.</span><span class="s3">\n      </span><span class="s1">// We only need to know when it's settled.</span><span class="s3">\n      </span><span class="s1">result.finally(() =&gt; {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadTimes += performance.now() - startTime</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">return result</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getClientComponentLoaderMetrics(</span><span class="s3">\n  </span><span class="s1">options: { reset?: boolean } = {}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const metrics =</span><span class="s3">\n    </span><span class="s1">clientComponentLoadStart === 0</span><span class="s3">\n      </span><span class="s1">? undefined</span><span class="s3">\n      </span><span class="s1">: {</span><span class="s3">\n          </span><span class="s1">clientComponentLoadStart,</span><span class="s3">\n          </span><span class="s1">clientComponentLoadTimes,</span><span class="s3">\n          </span><span class="s1">clientComponentLoadCount,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (options.reset) {</span><span class="s3">\n    </span><span class="s1">clientComponentLoadStart = 0</span><span class="s3">\n    </span><span class="s1">clientComponentLoadTimes = 0</span><span class="s3">\n    </span><span class="s1">clientComponentLoadCount = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return metrics</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ServerResponse } from 'node:http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ResponseAbortedName,</span><span class="s3">\n  </span><span class="s1">createAbortController,</span><span class="s3">\n</span><span class="s1">} from './web/spec-extension/adapters/next-request'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../lib/detached-promise'</span><span class="s3">\n</span><span class="s1">import { getTracer } from './lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NextNodeServerSpan } from './lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { getClientComponentLoaderMetrics } from './client-component-renderer-logger'</span><span class="s3">\n\n</span><span class="s1">export function isAbortError(e: any): e is Error &amp; { name: 'AbortError' } {</span><span class="s3">\n  </span><span class="s1">return e?.name === 'AbortError' || e?.name === ResponseAbortedName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createWriterFromResponse(</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">waitUntilForEnd?: Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">): WritableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let started = false</span><span class="s3">\n\n  </span><span class="s1">// Create a promise that will resolve once the response has drained. See</span><span class="s3">\n  </span><span class="s1">// https://nodejs.org/api/stream.html#stream_event_drain</span><span class="s3">\n  </span><span class="s1">let drained = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n  </span><span class="s1">function onDrain() {</span><span class="s3">\n    </span><span class="s1">drained.resolve()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">res.on('drain', onDrain)</span><span class="s3">\n\n  </span><span class="s1">// If the finish event fires, it means we shouldn't block and wait for the</span><span class="s3">\n  </span><span class="s1">// drain event.</span><span class="s3">\n  </span><span class="s1">res.once('close', () =&gt; {</span><span class="s3">\n    </span><span class="s1">res.off('drain', onDrain)</span><span class="s3">\n    </span><span class="s1">drained.resolve()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Create a promise that will resolve once the response has finished. See</span><span class="s3">\n  </span><span class="s1">// https://nodejs.org/api/http.html#event-finish_1</span><span class="s3">\n  </span><span class="s1">const finished = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n  </span><span class="s1">res.once('finish', () =&gt; {</span><span class="s3">\n    </span><span class="s1">finished.resolve()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Create a writable stream that will write to the response.</span><span class="s3">\n  </span><span class="s1">return new WritableStream&lt;Uint8Array&gt;({</span><span class="s3">\n    </span><span class="s1">write: async (chunk) =&gt; {</span><span class="s3">\n      </span><span class="s1">// You'd think we'd want to use `start` instead of placing this in `write`</span><span class="s3">\n      </span><span class="s1">// but this ensures that we don't actually flush the headers until we've</span><span class="s3">\n      </span><span class="s1">// started writing chunks.</span><span class="s3">\n      </span><span class="s1">if (!started) {</span><span class="s3">\n        </span><span class="s1">started = true</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">'performance' in globalThis &amp;&amp;</span><span class="s3">\n          </span><span class="s1">process.env.NEXT_OTEL_PERFORMANCE_PREFIX</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const metrics = getClientComponentLoaderMetrics()</span><span class="s3">\n          </span><span class="s1">if (metrics) {</span><span class="s3">\n            </span><span class="s1">performance.measure(</span><span class="s3">\n              </span><span class="s1">`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,</span><span class="s3">\n              </span><span class="s1">{</span><span class="s3">\n                </span><span class="s1">start: metrics.clientComponentLoadStart,</span><span class="s3">\n                </span><span class="s1">end:</span><span class="s3">\n                  </span><span class="s1">metrics.clientComponentLoadStart +</span><span class="s3">\n                  </span><span class="s1">metrics.clientComponentLoadTimes,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">res.flushHeaders()</span><span class="s3">\n        </span><span class="s1">getTracer().trace(</span><span class="s3">\n          </span><span class="s1">NextNodeServerSpan.startResponse,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">spanName: 'start response',</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">() =&gt; undefined</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const ok = res.write(chunk)</span><span class="s3">\n\n        </span><span class="s1">// Added by the `compression` middleware, this is a function that will</span><span class="s3">\n        </span><span class="s1">// flush the partially-compressed response to the client.</span><span class="s3">\n        </span><span class="s1">if ('flush' in res &amp;&amp; typeof res.flush === 'function') {</span><span class="s3">\n          </span><span class="s1">res.flush()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If the write returns false, it means there's some backpressure, so</span><span class="s3">\n        </span><span class="s1">// wait until it's streamed before continuing.</span><span class="s3">\n        </span><span class="s1">if (!ok) {</span><span class="s3">\n          </span><span class="s1">await drained.promise</span><span class="s3">\n\n          </span><span class="s1">// Reset the drained promise so that we can wait for the next drain event.</span><span class="s3">\n          </span><span class="s1">drained = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">res.end()</span><span class="s3">\n        </span><span class="s1">throw new Error('failed to write chunk to response', { cause: err })</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">abort: (err) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (res.writableFinished) return</span><span class="s3">\n\n      </span><span class="s1">res.destroy(err)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">close: async () =&gt; {</span><span class="s3">\n      </span><span class="s1">// if a waitUntil promise was passed, wait for it to resolve before</span><span class="s3">\n      </span><span class="s1">// ending the response.</span><span class="s3">\n      </span><span class="s1">if (waitUntilForEnd) {</span><span class="s3">\n        </span><span class="s1">await waitUntilForEnd</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (res.writableFinished) return</span><span class="s3">\n\n      </span><span class="s1">res.end()</span><span class="s3">\n      </span><span class="s1">return finished.promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function pipeToNodeResponse(</span><span class="s3">\n  </span><span class="s1">readable: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">waitUntilForEnd?: Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// If the response has already errored, then just return now.</span><span class="s3">\n    </span><span class="s1">const { errored, destroyed } = res</span><span class="s3">\n    </span><span class="s1">if (errored || destroyed) return</span><span class="s3">\n\n    </span><span class="s1">// Create a new AbortController so that we can abort the readable if the</span><span class="s3">\n    </span><span class="s1">// client disconnects.</span><span class="s3">\n    </span><span class="s1">const controller = createAbortController(res)</span><span class="s3">\n\n    </span><span class="s1">const writer = createWriterFromResponse(res, waitUntilForEnd)</span><span class="s3">\n\n    </span><span class="s1">await readable.pipeTo(writer, { signal: controller.signal })</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">// If this isn't related to an abort error, re-throw it.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(err)) return</span><span class="s3">\n\n    </span><span class="s1">throw new Error('failed to pipe response', { cause: err })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class InvariantError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(message: string, options?: ErrorOptions) {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">`Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,</span><span class="s3">\n      </span><span class="s1">options</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.name = 'InvariantError'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { FetchMetrics } from './base-http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">chainStreams,</span><span class="s3">\n  </span><span class="s1">streamFromBuffer,</span><span class="s3">\n  </span><span class="s1">streamFromString,</span><span class="s3">\n  </span><span class="s1">streamToString,</span><span class="s3">\n</span><span class="s1">} from './stream-utils/node-web-streams-helper'</span><span class="s3">\n</span><span class="s1">import { isAbortError, pipeToNodeResponse } from './pipe-readable'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">TEXT_PLAIN_CONTENT_TYPE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import type { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">type ContentTypeOption =</span><span class="s3">\n  </span><span class="s1">| typeof RSC_CONTENT_TYPE_HEADER // For App Page RSC responses</span><span class="s3">\n  </span><span class="s1">| typeof HTML_CONTENT_TYPE_HEADER // For App Page, Pages HTML responses</span><span class="s3">\n  </span><span class="s1">| typeof JSON_CONTENT_TYPE_HEADER // For API routes, Next.js data requests</span><span class="s3">\n  </span><span class="s1">| typeof TEXT_PLAIN_CONTENT_TYPE_HEADER // For simplified errors</span><span class="s3">\n\n</span><span class="s1">export type AppPageRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">flightData?: Buffer</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">staticBailoutInfo?: {</span><span class="s3">\n    </span><span class="s1">stack?: string</span><span class="s3">\n    </span><span class="s1">description?: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The postponed state if the render had postponed and needs to be resumed.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The headers to set on the response that were added by the render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">statusCode?: number</span><span class="s3">\n  </span><span class="s1">fetchTags?: string</span><span class="s3">\n  </span><span class="s1">fetchMetrics?: FetchMetrics</span><span class="s3">\n\n  </span><span class="s1">segmentData?: Map&lt;string, Buffer&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the resume data cache is warmed up before the render. This</span><span class="s3">\n   </span><span class="s1">* is attached to the metadata so that it can be used during the render. When</span><span class="s3">\n   </span><span class="s1">* prerendering, the filled resume data cache is also attached to the metadata</span><span class="s3">\n   </span><span class="s1">* so that it can be used when prerendering matching fallback shells.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PagesRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">pageData?: any</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">assetQueryString?: string</span><span class="s3">\n  </span><span class="s1">isNotFound?: boolean</span><span class="s3">\n  </span><span class="s1">isRedirect?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type StaticRenderResultMetadata = {}</span><span class="s3">\n\n</span><span class="s1">export type RenderResultMetadata = AppPageRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">PagesRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">StaticRenderResultMetadata</span><span class="s3">\n\n</span><span class="s1">export type RenderResultResponse =</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;[]</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">| string</span><span class="s3">\n  </span><span class="s1">| Buffer</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n\n</span><span class="s1">export type RenderResultOptions&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; = {</span><span class="s3">\n  </span><span class="s1">contentType: ContentTypeOption | null</span><span class="s3">\n  </span><span class="s1">waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n  </span><span class="s1">metadata: Metadata</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class RenderResult&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The detected content type for the response. This is used to set the</span><span class="s3">\n   </span><span class="s1">* `Content-Type` header.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly contentType: ContentTypeOption | null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The metadata for the response. This is used to set the revalidation times</span><span class="s3">\n   </span><span class="s1">* and other metadata.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly metadata: Readonly&lt;Metadata&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The response itself. This can be a string, a stream, or null. If it's a</span><span class="s3">\n   </span><span class="s1">* string, then it's a static response. If it's a stream, then it's a</span><span class="s3">\n   </span><span class="s1">* dynamic response. If it's null, then the response was not found or was</span><span class="s3">\n   </span><span class="s1">* already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private response: RenderResultResponse</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A render result that represents an empty response. This is used to</span><span class="s3">\n   </span><span class="s1">* represent a response that was not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static readonly EMPTY = new RenderResult&lt;StaticRenderResultMetadata&gt;(</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">{ metadata: {}, contentType: null }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a new RenderResult instance from a static response.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param value the static response value</span><span class="s3">\n   </span><span class="s1">* @param contentType the content type of the response</span><span class="s3">\n   </span><span class="s1">* @returns a new RenderResult instance</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static fromStatic(</span><span class="s3">\n    </span><span class="s1">value: string | Buffer,</span><span class="s3">\n    </span><span class="s1">contentType: ContentTypeOption</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return new RenderResult&lt;StaticRenderResultMetadata&gt;(value, {</span><span class="s3">\n      </span><span class="s1">metadata: {},</span><span class="s3">\n      </span><span class="s1">contentType,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private readonly waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">response: RenderResultResponse,</span><span class="s3">\n    </span><span class="s1">{ contentType, waitUntil, metadata }: RenderResultOptions&lt;Metadata&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.response = response</span><span class="s3">\n    </span><span class="s1">this.contentType = contentType</span><span class="s3">\n    </span><span class="s1">this.metadata = metadata</span><span class="s3">\n    </span><span class="s1">this.waitUntil = waitUntil</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public assignMetadata(metadata: Metadata) {</span><span class="s3">\n    </span><span class="s1">Object.assign(this.metadata, metadata)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns true if the response is null. It can be null if the response was</span><span class="s3">\n   </span><span class="s1">* not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isNull(): boolean {</span><span class="s3">\n    </span><span class="s1">return this.response === null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns false if the response is a string. It can be a string if the page</span><span class="s3">\n   </span><span class="s1">* was prerendered. If it's not, then it was generated dynamically.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isDynamic(): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.response !== 'string'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the response if it is a string. If the page was dynamic, this will</span><span class="s3">\n   </span><span class="s1">* return a promise if the `stream` option is true, or it will throw an error.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param stream Whether or not to return a promise if the response is dynamic</span><span class="s3">\n   </span><span class="s1">* @returns The response as a string</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream?: false): string</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream: true): Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream = false): Promise&lt;string&gt; | string {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty string. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response !== 'string') {</span><span class="s3">\n      </span><span class="s1">if (!stream) {</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'dynamic responses cannot be unchunked. This is a bug in Next.js'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return streamToString(this.readable)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a readable stream of the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private get readable(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return new ReadableStream&lt;Uint8Array&gt;({</span><span class="s3">\n        </span><span class="s1">start(controller) {</span><span class="s3">\n          </span><span class="s1">controller.close()</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return streamFromString(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return streamFromBuffer(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the response is an array of streams, then chain them together.</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return chainStreams(...this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Coerces the response to an array of streams. This will convert the response</span><span class="s3">\n   </span><span class="s1">* to an array of streams if it is not already one.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @returns An array of streams</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private coerce(): ReadableStream&lt;Uint8Array&gt;[] {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return []</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return [streamFromString(this.response)]</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return this.response</span><span class="s3">\n    </span><span class="s1">} else if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return [streamFromBuffer(this.response)]</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return [this.response]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Unshifts a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the start of the array. When this response is piped, all of the streams</span><span class="s3">\n   </span><span class="s1">* will be piped one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to unshift</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public unshift(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the start of the array.</span><span class="s3">\n    </span><span class="s1">this.response.unshift(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Chains a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the end. When this response is piped, all of the streams will be piped</span><span class="s3">\n   </span><span class="s1">* one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to chain</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public push(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the end of the array.</span><span class="s3">\n    </span><span class="s1">this.response.push(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a writable stream. This will close/cancel the</span><span class="s3">\n   </span><span class="s1">* writable stream if an error is encountered. If this doesn't throw, then</span><span class="s3">\n   </span><span class="s1">* the writable stream will be closed or aborted.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param writable Writable stream to pipe the response to</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeTo(writable: WritableStream&lt;Uint8Array&gt;): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">await this.readable.pipeTo(writable, {</span><span class="s3">\n        </span><span class="s1">// We want to close the writable stream ourselves so that we can wait</span><span class="s3">\n        </span><span class="s1">// for the waitUntil promise to resolve before closing it. If an error</span><span class="s3">\n        </span><span class="s1">// is encountered, we'll abort the writable stream if we swallowed the</span><span class="s3">\n        </span><span class="s1">// error.</span><span class="s3">\n        </span><span class="s1">preventClose: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// If there is a waitUntil promise, wait for it to resolve before</span><span class="s3">\n      </span><span class="s1">// closing the writable stream.</span><span class="s3">\n      </span><span class="s1">if (this.waitUntil) await this.waitUntil</span><span class="s3">\n\n      </span><span class="s1">// Close the writable stream.</span><span class="s3">\n      </span><span class="s1">await writable.close()</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">// If this is an abort error, we should abort the writable stream (as we</span><span class="s3">\n      </span><span class="s1">// took ownership of it when we started piping). We don't need to re-throw</span><span class="s3">\n      </span><span class="s1">// because we handled the error.</span><span class="s3">\n      </span><span class="s1">if (isAbortError(err)) {</span><span class="s3">\n        </span><span class="s1">// Abort the writable stream if an error is encountered.</span><span class="s3">\n        </span><span class="s1">await writable.abort(err)</span><span class="s3">\n\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We're not aborting the writer here as when this method throws it's not</span><span class="s3">\n      </span><span class="s1">// clear as to how so the caller should assume it's their responsibility</span><span class="s3">\n      </span><span class="s1">// to clean up the writer.</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a node response. This will close/cancel the node</span><span class="s3">\n   </span><span class="s1">* response if an error is encountered.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param res</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeToNodeResponse(res: ServerResponse) {</span><span class="s3">\n    </span><span class="s1">await pipeToNodeResponse(this.readable, res, this.waitUntil)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const enum RouteKind {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES` represents all the React pages that are under `pages/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES_API` represents all the API routes under `pages/api/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES_API = 'PAGES_API',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_PAGE` represents all the React pages that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `page.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `route.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `IMAGE` represents all the images that are generated by `next/image`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedAppPageValue,</span><span class="s3">\n  </span><span class="s1">type CachedPageValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">type ResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n\n</span><span class="s1">import RenderResult from '../render-result'</span><span class="s3">\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import { HTML_CONTENT_TYPE_HEADER } from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">export async function fromResponseCacheEntry(</span><span class="s3">\n  </span><span class="s1">cacheEntry: ResponseCacheEntry</span><span class="s3">\n</span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry&gt; {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...cacheEntry,</span><span class="s3">\n    </span><span class="s1">value:</span><span class="s3">\n      </span><span class="s1">cacheEntry.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n        </span><span class="s1">? {</span><span class="s3">\n            </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">html: await cacheEntry.value.html.toUnchunkedString(true),</span><span class="s3">\n            </span><span class="s1">pageData: cacheEntry.value.pageData,</span><span class="s3">\n            </span><span class="s1">headers: cacheEntry.value.headers,</span><span class="s3">\n            </span><span class="s1">status: cacheEntry.value.status,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: cacheEntry.value?.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n          </span><span class="s1">? {</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n              </span><span class="s1">html: await cacheEntry.value.html.toUnchunkedString(true),</span><span class="s3">\n              </span><span class="s1">postponed: cacheEntry.value.postponed,</span><span class="s3">\n              </span><span class="s1">rscData: cacheEntry.value.rscData,</span><span class="s3">\n              </span><span class="s1">headers: cacheEntry.value.headers,</span><span class="s3">\n              </span><span class="s1">status: cacheEntry.value.status,</span><span class="s3">\n              </span><span class="s1">segmentData: cacheEntry.value.segmentData,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">: cacheEntry.value,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function toResponseCacheEntry(</span><span class="s3">\n  </span><span class="s1">response: IncrementalResponseCacheEntry | null</span><span class="s3">\n</span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt; {</span><span class="s3">\n  </span><span class="s1">if (!response) return null</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">isMiss: response.isMiss,</span><span class="s3">\n    </span><span class="s1">isStale: response.isStale,</span><span class="s3">\n    </span><span class="s1">cacheControl: response.cacheControl,</span><span class="s3">\n    </span><span class="s1">value:</span><span class="s3">\n      </span><span class="s1">response.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n        </span><span class="s1">? ({</span><span class="s3">\n            </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">html: RenderResult.fromStatic(</span><span class="s3">\n              </span><span class="s1">response.value.html,</span><span class="s3">\n              </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">pageData: response.value.pageData,</span><span class="s3">\n            </span><span class="s1">headers: response.value.headers,</span><span class="s3">\n            </span><span class="s1">status: response.value.status,</span><span class="s3">\n          </span><span class="s1">} satisfies CachedPageValue)</span><span class="s3">\n        </span><span class="s1">: response.value?.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n          </span><span class="s1">? ({</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n              </span><span class="s1">html: RenderResult.fromStatic(</span><span class="s3">\n                </span><span class="s1">response.value.html,</span><span class="s3">\n                </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">rscData: response.value.rscData,</span><span class="s3">\n              </span><span class="s1">headers: response.value.headers,</span><span class="s3">\n              </span><span class="s1">status: response.value.status,</span><span class="s3">\n              </span><span class="s1">postponed: response.value.postponed,</span><span class="s3">\n              </span><span class="s1">segmentData: response.value.segmentData,</span><span class="s3">\n            </span><span class="s1">} satisfies CachedAppPageValue)</span><span class="s3">\n          </span><span class="s1">: response.value,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function routeKindToIncrementalCacheKind(</span><span class="s3">\n  </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n</span><span class="s1">): Exclude&lt;IncrementalCacheKind, IncrementalCacheKind.FETCH&gt; {</span><span class="s3">\n  </span><span class="s1">switch (routeKind) {</span><span class="s3">\n    </span><span class="s1">case RouteKind.PAGES:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.PAGES</span><span class="s3">\n    </span><span class="s1">case RouteKind.APP_PAGE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.APP_PAGE</span><span class="s3">\n    </span><span class="s1">case RouteKind.IMAGE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.IMAGE</span><span class="s3">\n    </span><span class="s1">case RouteKind.APP_ROUTE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n    </span><span class="s1">case RouteKind.PAGES_API:</span><span class="s3">\n      </span><span class="s1">// Pages Router API routes are not cached in the incremental cache.</span><span class="s3">\n      </span><span class="s1">throw new Error(`Unexpected route kind ${routeKind}`)</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return routeKind satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">ResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">ResponseGenerator,</span><span class="s3">\n  </span><span class="s1">ResponseCacheBase,</span><span class="s3">\n  </span><span class="s1">IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">IncrementalResponseCache,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n\n</span><span class="s1">import { Batcher } from '../../lib/batcher'</span><span class="s3">\n</span><span class="s1">import { scheduleOnNextTick } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">fromResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">routeKindToIncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">toResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './utils'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export * from './types'</span><span class="s3">\n\n</span><span class="s1">export default class ResponseCache implements ResponseCacheBase {</span><span class="s3">\n  </span><span class="s1">private readonly batcher = Batcher.create&lt;</span><span class="s3">\n    </span><span class="s1">{ key: string; isOnDemandRevalidate: boolean },</span><span class="s3">\n    </span><span class="s1">IncrementalResponseCacheEntry | null,</span><span class="s3">\n    </span><span class="s1">string</span><span class="s3">\n  </span><span class="s1">&gt;({</span><span class="s3">\n    </span><span class="s1">// Ensure on-demand revalidate doesn't block normal requests, it should be</span><span class="s3">\n    </span><span class="s1">// safe to run an on-demand revalidate for the same key as a normal request.</span><span class="s3">\n    </span><span class="s1">cacheKeyFn: ({ key, isOnDemandRevalidate }) =&gt;</span><span class="s3">\n      </span><span class="s1">`${key}-${isOnDemandRevalidate ? '1' : '0'}`,</span><span class="s3">\n    </span><span class="s1">// We wait to do any async work until after we've added our promise to</span><span class="s3">\n    </span><span class="s1">// `pendingResponses` to ensure that any any other calls will reuse the</span><span class="s3">\n    </span><span class="s1">// same promise until we've fully finished our work.</span><span class="s3">\n    </span><span class="s1">schedulerFn: scheduleOnNextTick,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">private previousCacheItem?: {</span><span class="s3">\n    </span><span class="s1">key: string</span><span class="s3">\n    </span><span class="s1">entry: IncrementalResponseCacheEntry | null</span><span class="s3">\n    </span><span class="s1">expiresAt: number</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// we don't use minimal_mode name here as this.minimal_mode is</span><span class="s3">\n  </span><span class="s1">// statically replace for server runtimes but we need it to</span><span class="s3">\n  </span><span class="s1">// be dynamic here</span><span class="s3">\n  </span><span class="s1">private minimal_mode?: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(minimal_mode: boolean) {</span><span class="s3">\n    </span><span class="s1">this.minimal_mode = minimal_mode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async get(</span><span class="s3">\n    </span><span class="s1">key: string | null,</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator,</span><span class="s3">\n    </span><span class="s1">context: {</span><span class="s3">\n      </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n      </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n      </span><span class="s1">incrementalCache: IncrementalResponseCache</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n      </span><span class="s1">isFallback?: boolean</span><span class="s3">\n      </span><span class="s1">waitUntil?: (prom: Promise&lt;any&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">// If there is no key for the cache, we can't possibly look this up in the</span><span class="s3">\n    </span><span class="s1">// cache so just return the result of the response generator.</span><span class="s3">\n    </span><span class="s1">if (!key) {</span><span class="s3">\n      </span><span class="s1">return responseGenerator({ hasResolved: false, previousCacheEntry: null })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">incrementalCache,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate = false,</span><span class="s3">\n      </span><span class="s1">isFallback = false,</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled = false,</span><span class="s3">\n      </span><span class="s1">waitUntil,</span><span class="s3">\n    </span><span class="s1">} = context</span><span class="s3">\n\n    </span><span class="s1">const response = await this.batcher.batch(</span><span class="s3">\n      </span><span class="s1">{ key, isOnDemandRevalidate },</span><span class="s3">\n      </span><span class="s1">(cacheKey, resolve) =&gt; {</span><span class="s3">\n        </span><span class="s1">const prom = (async () =&gt; {</span><span class="s3">\n          </span><span class="s1">// We keep the previous cache entry around to leverage when the</span><span class="s3">\n          </span><span class="s1">// incremental cache is disabled in minimal mode.</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">this.minimal_mode &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.previousCacheItem?.key === cacheKey &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.previousCacheItem.expiresAt &gt; Date.now()</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return this.previousCacheItem.entry</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Coerce the kindHint into a given kind for the incremental cache.</span><span class="s3">\n          </span><span class="s1">const kind = routeKindToIncrementalCacheKind(context.routeKind)</span><span class="s3">\n\n          </span><span class="s1">let resolved = false</span><span class="s3">\n          </span><span class="s1">let cachedResponse: IncrementalResponseCacheEntry | null = null</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">cachedResponse = !this.minimal_mode</span><span class="s3">\n              </span><span class="s1">? await incrementalCache.get(key, {</span><span class="s3">\n                  </span><span class="s1">kind,</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled: context.isRoutePPREnabled,</span><span class="s3">\n                  </span><span class="s1">isFallback,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">: null</span><span class="s3">\n\n            </span><span class="s1">if (cachedResponse &amp;&amp; !isOnDemandRevalidate) {</span><span class="s3">\n              </span><span class="s1">resolve(cachedResponse)</span><span class="s3">\n              </span><span class="s1">resolved = true</span><span class="s3">\n\n              </span><span class="s1">if (!cachedResponse.isStale || context.isPrefetch) {</span><span class="s3">\n                </span><span class="s1">// The cached value is still valid, so we don't need</span><span class="s3">\n                </span><span class="s1">// to update it yet.</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const cacheEntry = await responseGenerator({</span><span class="s3">\n              </span><span class="s1">hasResolved: resolved,</span><span class="s3">\n              </span><span class="s1">previousCacheEntry: cachedResponse,</span><span class="s3">\n              </span><span class="s1">isRevalidating: true,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">// If the cache entry couldn't be generated, we don't want to cache</span><span class="s3">\n            </span><span class="s1">// the result.</span><span class="s3">\n            </span><span class="s1">if (!cacheEntry) {</span><span class="s3">\n              </span><span class="s1">// Unset the previous cache item if it was set.</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) this.previousCacheItem = undefined</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const resolveValue = await fromResponseCacheEntry({</span><span class="s3">\n              </span><span class="s1">...cacheEntry,</span><span class="s3">\n              </span><span class="s1">isMiss: !cachedResponse,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">if (!resolveValue) {</span><span class="s3">\n              </span><span class="s1">// Unset the previous cache item if it was set.</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) this.previousCacheItem = undefined</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// For on-demand revalidate wait to resolve until cache is set.</span><span class="s3">\n            </span><span class="s1">// Otherwise resolve now.</span><span class="s3">\n            </span><span class="s1">if (!isOnDemandRevalidate &amp;&amp; !resolved) {</span><span class="s3">\n              </span><span class="s1">resolve(resolveValue)</span><span class="s3">\n              </span><span class="s1">resolved = true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// We want to persist the result only if it has a cache control value</span><span class="s3">\n            </span><span class="s1">// defined.</span><span class="s3">\n            </span><span class="s1">if (resolveValue.cacheControl) {</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) {</span><span class="s3">\n                </span><span class="s1">this.previousCacheItem = {</span><span class="s3">\n                  </span><span class="s1">key: cacheKey,</span><span class="s3">\n                  </span><span class="s1">entry: resolveValue,</span><span class="s3">\n                  </span><span class="s1">expiresAt: Date.now() + 1000,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">await incrementalCache.set(key, resolveValue.value, {</span><span class="s3">\n                  </span><span class="s1">cacheControl: resolveValue.cacheControl,</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n                  </span><span class="s1">isFallback,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return resolveValue</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">// When a path is erroring we automatically re-set the existing cache</span><span class="s3">\n            </span><span class="s1">// with new revalidate and expire times to prevent non-stop retrying.</span><span class="s3">\n            </span><span class="s1">if (cachedResponse?.cacheControl) {</span><span class="s3">\n              </span><span class="s1">const newRevalidate = Math.min(</span><span class="s3">\n                </span><span class="s1">Math.max(cachedResponse.cacheControl.revalidate || 3, 3),</span><span class="s3">\n                </span><span class="s1">30</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">const newExpire =</span><span class="s3">\n                </span><span class="s1">cachedResponse.cacheControl.expire === undefined</span><span class="s3">\n                  </span><span class="s1">? undefined</span><span class="s3">\n                  </span><span class="s1">: Math.max(</span><span class="s3">\n                      </span><span class="s1">newRevalidate + 3,</span><span class="s3">\n                      </span><span class="s1">cachedResponse.cacheControl.expire</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">await incrementalCache.set(key, cachedResponse.value, {</span><span class="s3">\n                </span><span class="s1">cacheControl: { revalidate: newRevalidate, expire: newExpire },</span><span class="s3">\n                </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n                </span><span class="s1">isFallback,</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// While revalidating in the background we can't reject as we already</span><span class="s3">\n            </span><span class="s1">// resolved the cache entry so log the error here.</span><span class="s3">\n            </span><span class="s1">if (resolved) {</span><span class="s3">\n              </span><span class="s1">console.error(err)</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// We haven't resolved yet, so let's throw to indicate an error.</span><span class="s3">\n            </span><span class="s1">throw err</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})()</span><span class="s3">\n\n        </span><span class="s1">// we need to ensure background revalidates are</span><span class="s3">\n        </span><span class="s1">// passed to waitUntil</span><span class="s3">\n        </span><span class="s1">if (waitUntil) {</span><span class="s3">\n          </span><span class="s1">waitUntil(prom)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return prom</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return toResponseCacheEntry(response)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from '../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import type { CacheFs } from '../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A task to be written.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type Task = [</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The directory to create.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">directory: string,</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The promise to create the directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mkdir: Promise&lt;unknown&gt;,</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The promises to write the files that are dependent on the directory being</span><span class="s3">\n   </span><span class="s1">* created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeFile: Promise&lt;unknown&gt;[],</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* MultiFileWriter is a utility for writing multiple files in parallel that</span><span class="s3">\n </span><span class="s1">* guarantees that all files will be written after their containing directory</span><span class="s3">\n </span><span class="s1">* is created, and that the directory will only be created once.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class MultiFileWriter {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The tasks to be written.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly tasks: Task[] = []</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The file system methods to use.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">private readonly fs: Pick&lt;CacheFs, 'mkdir' | 'writeFile'&gt;</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Finds or creates a task for a directory.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param directory - The directory to find or create a task for.</span><span class="s3">\n   </span><span class="s1">* @returns The task for the directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private findOrCreateTask(directory: string): Task {</span><span class="s3">\n    </span><span class="s1">// See if this directory already has a task to create it.</span><span class="s3">\n    </span><span class="s1">for (const task of this.tasks) {</span><span class="s3">\n      </span><span class="s1">if (task[0] === directory) {</span><span class="s3">\n        </span><span class="s1">return task</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const promise = this.fs.mkdir(directory)</span><span class="s3">\n\n    </span><span class="s1">// Attach a catch handler so that it doesn't throw an unhandled promise</span><span class="s3">\n    </span><span class="s1">// rejection warning.</span><span class="s3">\n    </span><span class="s1">promise.catch(() =&gt; {})</span><span class="s3">\n\n    </span><span class="s1">// Otherwise, create a new task for this directory.</span><span class="s3">\n    </span><span class="s1">const task: Task = [directory, promise, []]</span><span class="s3">\n    </span><span class="s1">this.tasks.push(task)</span><span class="s3">\n\n    </span><span class="s1">return task</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Appends a file to the writer to be written after its containing directory</span><span class="s3">\n   </span><span class="s1">* is created. The file writer should be awaited after all the files have been</span><span class="s3">\n   </span><span class="s1">* appended. Any async operation that occurs between appending and awaiting</span><span class="s3">\n   </span><span class="s1">* may cause an unhandled promise rejection warning and potentially crash the</span><span class="s3">\n   </span><span class="s1">* process.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param filePath - The path to the file to write.</span><span class="s3">\n   </span><span class="s1">* @param data - The data to write to the file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public append(filePath: string, data: Buffer | string): void {</span><span class="s3">\n    </span><span class="s1">// Find or create a task for the directory that contains the file.</span><span class="s3">\n    </span><span class="s1">const task = this.findOrCreateTask(path.dirname(filePath))</span><span class="s3">\n\n    </span><span class="s1">const promise = task[1].then(() =&gt; this.fs.writeFile(filePath, data))</span><span class="s3">\n\n    </span><span class="s1">// Attach a catch handler so that it doesn't throw an unhandled promise</span><span class="s3">\n    </span><span class="s1">// rejection warning.</span><span class="s3">\n    </span><span class="s1">promise.catch(() =&gt; {})</span><span class="s3">\n\n    </span><span class="s1">// Add the file write to the task AFTER the directory promise has resolved.</span><span class="s3">\n    </span><span class="s1">task[2].push(promise)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a promise that resolves when all the files have been written.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public wait(): Promise&lt;unknown&gt; {</span><span class="s3">\n    </span><span class="s1">return Promise.all(this.tasks.flatMap((task) =&gt; task[2]))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RouteMetadata } from '../../../export/routes/types'</span><span class="s3">\n</span><span class="s1">import type { CacheHandler, CacheHandlerContext, CacheHandlerValue } from '.'</span><span class="s3">\n</span><span class="s1">import type { CacheFs } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedFetchValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalResponseCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n\n</span><span class="s1">import type { LRUCache } from '../lru-cache'</span><span class="s3">\n</span><span class="s1">import path from '../../../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_DATA_SUFFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_META_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_PREFETCH_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENT_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SUFFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { isStale, tagsManifest } from './tags-manifest.external'</span><span class="s3">\n</span><span class="s1">import { MultiFileWriter } from '../../../lib/multi-file-writer'</span><span class="s3">\n</span><span class="s1">import { getMemoryCache } from './memory-cache.external'</span><span class="s3">\n\n</span><span class="s1">type FileSystemCacheContext = Omit&lt;</span><span class="s3">\n  </span><span class="s1">CacheHandlerContext,</span><span class="s3">\n  </span><span class="s1">'fs' | 'serverDistDir'</span><span class="s3">\n</span><span class="s1">&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">fs: CacheFs</span><span class="s3">\n  </span><span class="s1">serverDistDir: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class FileSystemCache implements CacheHandler {</span><span class="s3">\n  </span><span class="s1">private fs: FileSystemCacheContext['fs']</span><span class="s3">\n  </span><span class="s1">private flushToDisk?: FileSystemCacheContext['flushToDisk']</span><span class="s3">\n  </span><span class="s1">private serverDistDir: FileSystemCacheContext['serverDistDir']</span><span class="s3">\n  </span><span class="s1">private revalidatedTags: string[]</span><span class="s3">\n  </span><span class="s1">private static debug: boolean = !!process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">private static memoryCache: LRUCache&lt;CacheHandlerValue&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(ctx: FileSystemCacheContext) {</span><span class="s3">\n    </span><span class="s1">this.fs = ctx.fs</span><span class="s3">\n    </span><span class="s1">this.flushToDisk = ctx.flushToDisk</span><span class="s3">\n    </span><span class="s1">this.serverDistDir = ctx.serverDistDir</span><span class="s3">\n    </span><span class="s1">this.revalidatedTags = ctx.revalidatedTags</span><span class="s3">\n\n    </span><span class="s1">if (ctx.maxMemoryCacheSize) {</span><span class="s3">\n      </span><span class="s1">if (!FileSystemCache.memoryCache) {</span><span class="s3">\n        </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n          </span><span class="s1">console.log('using memory store for fetch cache')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">FileSystemCache.memoryCache = getMemoryCache(ctx.maxMemoryCacheSize)</span><span class="s3">\n      </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n        </span><span class="s1">console.log('memory store already initialized')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('not using memory store for fetch cache')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public resetRequestCache(): void {}</span><span class="s3">\n\n  </span><span class="s1">public async revalidateTag(</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;CacheHandler['revalidateTag']&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let [tags] = args</span><span class="s3">\n    </span><span class="s1">tags = typeof tags === 'string' ? [tags] : tags</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('revalidateTag', tags)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (tags.length === 0) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const tag of tags) {</span><span class="s3">\n      </span><span class="s1">if (!tagsManifest.has(tag)) {</span><span class="s3">\n        </span><span class="s1">tagsManifest.set(tag, Date.now())</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async get(...args: Parameters&lt;CacheHandler['get']&gt;) {</span><span class="s3">\n    </span><span class="s1">const [key, ctx] = args</span><span class="s3">\n    </span><span class="s1">const { kind } = ctx</span><span class="s3">\n\n    </span><span class="s1">let data = FileSystemCache.memoryCache?.get(key)</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, ctx.tags, kind, !!data)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, kind, !!data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// let's check the disk for seed data</span><span class="s3">\n    </span><span class="s1">if (!data &amp;&amp; process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (kind === IncrementalCacheKind.APP_ROUTE) {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}.body`,</span><span class="s3">\n            </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath)</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">const meta = JSON.parse(</span><span class="s3">\n            </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n              </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n              </span><span class="s1">'utf8'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">data = {</span><span class="s3">\n            </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n            </span><span class="s1">value: {</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_ROUTE,</span><span class="s3">\n              </span><span class="s1">body: fileData,</span><span class="s3">\n              </span><span class="s1">headers: meta.headers,</span><span class="s3">\n              </span><span class="s1">status: meta.status,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">kind === IncrementalCacheKind.FETCH ? key : `${key}.html`,</span><span class="s3">\n            </span><span class="s1">kind</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath, 'utf8')</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n            </span><span class="s1">const { tags, fetchIdx, fetchUrl } = ctx</span><span class="s3">\n\n            </span><span class="s1">if (!this.flushToDisk) return null</span><span class="s3">\n\n            </span><span class="s1">const lastModified = mtime.getTime()</span><span class="s3">\n            </span><span class="s1">const parsedData: CachedFetchValue = JSON.parse(fileData)</span><span class="s3">\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified,</span><span class="s3">\n              </span><span class="s1">value: parsedData,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (data.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n              </span><span class="s1">const storedTags = data.value?.tags</span><span class="s3">\n\n              </span><span class="s1">// update stored tags if a new one is being added</span><span class="s3">\n              </span><span class="s1">// TODO: remove this when we can send the tags</span><span class="s3">\n              </span><span class="s1">// via header on GET same as SET</span><span class="s3">\n              </span><span class="s1">if (!tags?.every((tag) =&gt; storedTags?.includes(tag))) {</span><span class="s3">\n                </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n                  </span><span class="s1">console.log('tags vs storedTags mismatch', tags, storedTags)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">await this.set(key, data.value, {</span><span class="s3">\n                  </span><span class="s1">fetchCache: true,</span><span class="s3">\n                  </span><span class="s1">tags,</span><span class="s3">\n                  </span><span class="s1">fetchIdx,</span><span class="s3">\n                  </span><span class="s1">fetchUrl,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.APP_PAGE) {</span><span class="s3">\n            </span><span class="s1">// We try to load the metadata file, but if it fails, we don't</span><span class="s3">\n            </span><span class="s1">// error. We also don't load it if this is a fallback.</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">meta = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} catch {}</span><span class="s3">\n\n            </span><span class="s1">let maybeSegmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n            </span><span class="s1">if (meta?.segmentPaths) {</span><span class="s3">\n              </span><span class="s1">// Collect all the segment data for this page.</span><span class="s3">\n              </span><span class="s1">// TODO: To optimize file system reads, we should consider creating</span><span class="s3">\n              </span><span class="s1">// separate cache entries for each segment, rather than storing them</span><span class="s3">\n              </span><span class="s1">// all on the page's entry. Though the behavior is</span><span class="s3">\n              </span><span class="s1">// identical regardless.</span><span class="s3">\n              </span><span class="s1">const segmentData: Map&lt;string, Buffer&gt; = new Map()</span><span class="s3">\n              </span><span class="s1">maybeSegmentData = segmentData</span><span class="s3">\n              </span><span class="s1">const segmentsDir = key + RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n              </span><span class="s1">await Promise.all(</span><span class="s3">\n                </span><span class="s1">meta.segmentPaths.map(async (segmentPath: string) =&gt; {</span><span class="s3">\n                  </span><span class="s1">const segmentDataFilePath = this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">segmentData.set(</span><span class="s3">\n                      </span><span class="s1">segmentPath,</span><span class="s3">\n                      </span><span class="s1">await this.fs.readFile(segmentDataFilePath)</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">} catch {</span><span class="s3">\n                    </span><span class="s1">// This shouldn't happen, but if for some reason we fail to</span><span class="s3">\n                    </span><span class="s1">// load a segment from the filesystem, treat it the same as if</span><span class="s3">\n                    </span><span class="s1">// the segment is dynamic and does not have a prefetch.</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">let rscData: Buffer | undefined</span><span class="s3">\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">rscData = await this.fs.readFile(</span><span class="s3">\n                </span><span class="s1">this.getFilePath(</span><span class="s3">\n                  </span><span class="s1">`${key}${ctx.isRoutePPREnabled ? RSC_PREFETCH_SUFFIX : RSC_SUFFIX}`,</span><span class="s3">\n                  </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">rscData,</span><span class="s3">\n                </span><span class="s1">postponed: meta?.postponed,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n                </span><span class="s1">segmentData: maybeSegmentData,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.PAGES) {</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">let pageData: string | object = {}</span><span class="s3">\n\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">pageData = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">`${key}${NEXT_DATA_SUFFIX}`,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.PAGES</span><span class="s3">\n                  </span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">pageData,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`Invariant: Unexpected route kind ${kind} in file system cache.`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (data) {</span><span class="s3">\n          </span><span class="s1">FileSystemCache.memoryCache?.set(key, data)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_PAGE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_ROUTE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">let cacheTags: undefined | string[]</span><span class="s3">\n      </span><span class="s1">const tagsHeader = data.value.headers?.[NEXT_CACHE_TAGS_HEADER]</span><span class="s3">\n\n      </span><span class="s1">if (typeof tagsHeader === 'string') {</span><span class="s3">\n        </span><span class="s1">cacheTags = tagsHeader.split(',')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheTags?.length) {</span><span class="s3">\n        </span><span class="s1">// we trigger a blocking validation if an ISR page</span><span class="s3">\n        </span><span class="s1">// had a tag revalidated, if we want to be a background</span><span class="s3">\n        </span><span class="s1">// revalidation instead we return data.lastModified = -1</span><span class="s3">\n        </span><span class="s1">if (isStale(cacheTags, data?.lastModified || Date.now())) {</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data?.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const combinedTags =</span><span class="s3">\n        </span><span class="s1">ctx.kind === IncrementalCacheKind.FETCH</span><span class="s3">\n          </span><span class="s1">? [...(ctx.tags || []), ...(ctx.softTags || [])]</span><span class="s3">\n          </span><span class="s1">: []</span><span class="s3">\n\n      </span><span class="s1">const wasRevalidated = combinedTags.some((tag) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (this.revalidatedTags.includes(tag)) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return isStale([tag], data?.lastModified || Date.now())</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">// When revalidate tag is called we don't return</span><span class="s3">\n      </span><span class="s1">// stale data so it's updated right away</span><span class="s3">\n      </span><span class="s1">if (wasRevalidated) {</span><span class="s3">\n        </span><span class="s1">data = undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return data ?? null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">FileSystemCache.memoryCache?.set(key, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">lastModified: Date.now(),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('set', key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.flushToDisk || !data) return</span><span class="s3">\n\n    </span><span class="s1">// Create a new writer that will prepare to write all the files to disk</span><span class="s3">\n    </span><span class="s1">// after their containing directory is created.</span><span class="s3">\n    </span><span class="s1">const writer = new MultiFileWriter(this.fs)</span><span class="s3">\n\n    </span><span class="s1">if (data.kind === CachedRouteKind.APP_ROUTE) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.body`,</span><span class="s3">\n        </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(filePath, data.body)</span><span class="s3">\n\n      </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n        </span><span class="s1">headers: data.headers,</span><span class="s3">\n        </span><span class="s1">status: data.status,</span><span class="s3">\n        </span><span class="s1">postponed: undefined,</span><span class="s3">\n        </span><span class="s1">segmentPaths: undefined,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n        </span><span class="s1">JSON.stringify(meta, null, 2)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.PAGES ||</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const isAppPath = data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n      </span><span class="s1">const htmlPath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.html`,</span><span class="s3">\n        </span><span class="s1">isAppPath ? IncrementalCacheKind.APP_PAGE : IncrementalCacheKind.PAGES</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(htmlPath, data.html)</span><span class="s3">\n\n      </span><span class="s1">// Fallbacks don't generate a data file.</span><span class="s3">\n      </span><span class="s1">if (!ctx.fetchCache &amp;&amp; !ctx.isFallback) {</span><span class="s3">\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}${</span><span class="s3">\n              </span><span class="s1">isAppPath</span><span class="s3">\n                </span><span class="s1">? ctx.isRoutePPREnabled</span><span class="s3">\n                  </span><span class="s1">? RSC_PREFETCH_SUFFIX</span><span class="s3">\n                  </span><span class="s1">: RSC_SUFFIX</span><span class="s3">\n                </span><span class="s1">: NEXT_DATA_SUFFIX</span><span class="s3">\n            </span><span class="s1">}`,</span><span class="s3">\n            </span><span class="s1">isAppPath</span><span class="s3">\n              </span><span class="s1">? IncrementalCacheKind.APP_PAGE</span><span class="s3">\n              </span><span class="s1">: IncrementalCacheKind.PAGES</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">isAppPath ? data.rscData! : JSON.stringify(data.pageData)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (data?.kind === CachedRouteKind.APP_PAGE) {</span><span class="s3">\n        </span><span class="s1">let segmentPaths: string[] | undefined</span><span class="s3">\n        </span><span class="s1">if (data.segmentData) {</span><span class="s3">\n          </span><span class="s1">segmentPaths = []</span><span class="s3">\n          </span><span class="s1">const segmentsDir = htmlPath.replace(</span><span class="s3">\n            </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.html$/,</span><span class="s3">\n            </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">for (const [segmentPath, buffer] of data.segmentData) {</span><span class="s3">\n            </span><span class="s1">segmentPaths.push(segmentPath)</span><span class="s3">\n            </span><span class="s1">const segmentDataFilePath =</span><span class="s3">\n              </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX</span><span class="s3">\n            </span><span class="s1">writer.append(segmentDataFilePath, buffer)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n          </span><span class="s1">headers: data.headers,</span><span class="s3">\n          </span><span class="s1">status: data.status,</span><span class="s3">\n          </span><span class="s1">postponed: data.postponed,</span><span class="s3">\n          </span><span class="s1">segmentPaths,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">htmlPath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n          </span><span class="s1">JSON.stringify(meta)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(key, IncrementalCacheKind.FETCH)</span><span class="s3">\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath,</span><span class="s3">\n        </span><span class="s1">JSON.stringify({</span><span class="s3">\n          </span><span class="s1">...data,</span><span class="s3">\n          </span><span class="s1">tags: ctx.fetchCache ? ctx.tags : [],</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Wait for all FS operations to complete.</span><span class="s3">\n    </span><span class="s1">await writer.wait()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private getFilePath(pathname: string, kind: IncrementalCacheKind): string {</span><span class="s3">\n    </span><span class="s1">switch (kind) {</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.FETCH:</span><span class="s3">\n        </span><span class="s1">// we store in .next/cache/fetch-cache so it can be persisted</span><span class="s3">\n        </span><span class="s1">// across deploys</span><span class="s3">\n        </span><span class="s1">return path.join(</span><span class="s3">\n          </span><span class="s1">this.serverDistDir,</span><span class="s3">\n          </span><span class="s1">'..',</span><span class="s3">\n          </span><span class="s1">'cache',</span><span class="s3">\n          </span><span class="s1">'fetch-cache',</span><span class="s3">\n          </span><span class="s1">pathname</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.PAGES:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'pages', pathname)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.IMAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_PAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_ROUTE:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'app', pathname)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">throw new Error(`Unexpected file path kind: ${kind}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This transforms a URL pathname into a route. It removes any trailing slashes</span><span class="s3">\n </span><span class="s1">* and the `/index` suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pathname - The URL path that needs to be optimized.</span><span class="s3">\n </span><span class="s1">* @returns - The route</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/example'</span><span class="s3">\n </span><span class="s1">* toRoute('/example/index/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/example'</span><span class="s3">\n </span><span class="s1">* toRoute('/example/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/'</span><span class="s3">\n </span><span class="s1">* toRoute('/index/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/'</span><span class="s3">\n </span><span class="s1">* toRoute('/');</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function toRoute(pathname: string): string {</span><span class="s3">\n  </span><span class="s1">return pathname.replace(/(?:</span><span class="s3">\\</span><span class="s1">/index)?</span><span class="s3">\\</span><span class="s1">/?$/, '') || '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { CacheFs } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { PrerenderManifest } from '../../../build'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheEntry,</span><span class="s3">\n  </span><span class="s1">type IncrementalCache as IncrementalCacheType,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">type IncrementalFetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">type GetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type GetIncrementalResponseCacheContext,</span><span class="s3">\n  </span><span class="s1">type CachedFetchValue,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalResponseCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">import FileSystemCache from './file-system-cache'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CACHE_ONE_YEAR,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { toRoute } from '../to-route'</span><span class="s3">\n</span><span class="s1">import { SharedCacheControls } from './shared-cache-controls.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getPrerenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">getRenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import type { Revalidate } from '../cache-control'</span><span class="s3">\n</span><span class="s1">import { getPreviouslyRevalidatedTags } from '../../server-utils'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../../lib/detached-promise'</span><span class="s3">\n\n</span><span class="s1">export interface CacheHandlerContext {</span><span class="s3">\n  </span><span class="s1">fs?: CacheFs</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">flushToDisk?: boolean</span><span class="s3">\n  </span><span class="s1">serverDistDir?: string</span><span class="s3">\n  </span><span class="s1">maxMemoryCacheSize?: number</span><span class="s3">\n  </span><span class="s1">fetchCacheKeyPrefix?: string</span><span class="s3">\n  </span><span class="s1">prerenderManifest?: PrerenderManifest</span><span class="s3">\n  </span><span class="s1">revalidatedTags: string[]</span><span class="s3">\n  </span><span class="s1">_requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CacheHandlerValue {</span><span class="s3">\n  </span><span class="s1">lastModified?: number</span><span class="s3">\n  </span><span class="s1">age?: number</span><span class="s3">\n  </span><span class="s1">cacheState?: string</span><span class="s3">\n  </span><span class="s1">value: IncrementalCacheValue | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class CacheHandler {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line</span><span class="s3">\n  </span><span class="s1">constructor(_ctx: CacheHandlerContext) {}</span><span class="s3">\n\n  </span><span class="s1">public async get(</span><span class="s3">\n    </span><span class="s1">_cacheKey: string,</span><span class="s3">\n    </span><span class="s1">_ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;CacheHandlerValue | null&gt; {</span><span class="s3">\n    </span><span class="s1">return {} as any</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async set(</span><span class="s3">\n    </span><span class="s1">_cacheKey: string,</span><span class="s3">\n    </span><span class="s1">_data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">_ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public async revalidateTag(</span><span class="s3">\n    </span><span class="s1">..._args: Parameters&lt;IncrementalCache['revalidateTag']&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public resetRequestCache(): void {}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class IncrementalCache implements IncrementalCacheType {</span><span class="s3">\n  </span><span class="s1">readonly dev?: boolean</span><span class="s3">\n  </span><span class="s1">readonly disableForTestmode?: boolean</span><span class="s3">\n  </span><span class="s1">readonly cacheHandler?: CacheHandler</span><span class="s3">\n  </span><span class="s1">readonly hasCustomCacheHandler: boolean</span><span class="s3">\n  </span><span class="s1">readonly prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">readonly requestHeaders: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n  </span><span class="s1">readonly allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n  </span><span class="s1">readonly minimalMode?: boolean</span><span class="s3">\n  </span><span class="s1">readonly fetchCacheKeyPrefix?: string</span><span class="s3">\n  </span><span class="s1">readonly revalidatedTags?: string[]</span><span class="s3">\n  </span><span class="s1">readonly isOnDemandRevalidate?: boolean</span><span class="s3">\n\n  </span><span class="s1">private static readonly debug: boolean =</span><span class="s3">\n    </span><span class="s1">!!process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">private readonly locks = new Map&lt;string, Promise&lt;void&gt;&gt;()</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cache controls for routes. This will source the values from the</span><span class="s3">\n   </span><span class="s1">* prerender manifest until the in-memory cache is updated with new values.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly cacheControls: SharedCacheControls</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">fs,</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">flushToDisk,</span><span class="s3">\n    </span><span class="s1">minimalMode,</span><span class="s3">\n    </span><span class="s1">serverDistDir,</span><span class="s3">\n    </span><span class="s1">requestHeaders,</span><span class="s3">\n    </span><span class="s1">maxMemoryCacheSize,</span><span class="s3">\n    </span><span class="s1">getPrerenderManifest,</span><span class="s3">\n    </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n    </span><span class="s1">CurCacheHandler,</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">fs?: CacheFs</span><span class="s3">\n    </span><span class="s1">dev: boolean</span><span class="s3">\n    </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n    </span><span class="s1">serverDistDir?: string</span><span class="s3">\n    </span><span class="s1">flushToDisk?: boolean</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n    </span><span class="s1">requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n    </span><span class="s1">maxMemoryCacheSize?: number</span><span class="s3">\n    </span><span class="s1">getPrerenderManifest: () =&gt; DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">fetchCacheKeyPrefix?: string</span><span class="s3">\n    </span><span class="s1">CurCacheHandler?: typeof CacheHandler</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">this.hasCustomCacheHandler = Boolean(CurCacheHandler)</span><span class="s3">\n\n    </span><span class="s1">const cacheHandlersSymbol = Symbol.for('@next/cache-handlers')</span><span class="s3">\n    </span><span class="s1">const _globalThis: typeof globalThis &amp; {</span><span class="s3">\n      </span><span class="s1">[cacheHandlersSymbol]?: {</span><span class="s3">\n        </span><span class="s1">FetchCache?: typeof CacheHandler</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} = globalThis</span><span class="s3">\n\n    </span><span class="s1">if (!CurCacheHandler) {</span><span class="s3">\n      </span><span class="s1">// if we have a global cache handler available leverage it</span><span class="s3">\n      </span><span class="s1">const globalCacheHandler = _globalThis[cacheHandlersSymbol]</span><span class="s3">\n\n      </span><span class="s1">if (globalCacheHandler?.FetchCache) {</span><span class="s3">\n        </span><span class="s1">CurCacheHandler = globalCacheHandler.FetchCache</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (fs &amp;&amp; serverDistDir) {</span><span class="s3">\n          </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n            </span><span class="s1">console.log('using filesystem cache handler')</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">CurCacheHandler = FileSystemCache</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (IncrementalCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('using custom cache handler', CurCacheHandler.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {</span><span class="s3">\n      </span><span class="s1">// Allow cache size to be overridden for testing purposes</span><span class="s3">\n      </span><span class="s1">maxMemoryCacheSize = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.dev = dev</span><span class="s3">\n    </span><span class="s1">this.disableForTestmode = process.env.NEXT_PRIVATE_TEST_PROXY === 'true'</span><span class="s3">\n    </span><span class="s1">// this is a hack to avoid Webpack knowing this is equal to this.minimalMode</span><span class="s3">\n    </span><span class="s1">// because we replace this.minimalMode to true in production bundles.</span><span class="s3">\n    </span><span class="s1">const minimalModeKey = 'minimalMode'</span><span class="s3">\n    </span><span class="s1">this[minimalModeKey] = minimalMode</span><span class="s3">\n    </span><span class="s1">this.requestHeaders = requestHeaders</span><span class="s3">\n    </span><span class="s1">this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys</span><span class="s3">\n    </span><span class="s1">this.prerenderManifest = getPrerenderManifest()</span><span class="s3">\n    </span><span class="s1">this.cacheControls = new SharedCacheControls(this.prerenderManifest)</span><span class="s3">\n    </span><span class="s1">this.fetchCacheKeyPrefix = fetchCacheKeyPrefix</span><span class="s3">\n    </span><span class="s1">let revalidatedTags: string[] = []</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">requestHeaders[PRERENDER_REVALIDATE_HEADER] ===</span><span class="s3">\n      </span><span class="s1">this.prerenderManifest?.preview?.previewModeId</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.isOnDemandRevalidate = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (minimalMode) {</span><span class="s3">\n      </span><span class="s1">revalidatedTags = getPreviouslyRevalidatedTags(</span><span class="s3">\n        </span><span class="s1">requestHeaders,</span><span class="s3">\n        </span><span class="s1">this.prerenderManifest?.preview?.previewModeId</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (CurCacheHandler) {</span><span class="s3">\n      </span><span class="s1">this.cacheHandler = new CurCacheHandler({</span><span class="s3">\n        </span><span class="s1">dev,</span><span class="s3">\n        </span><span class="s1">fs,</span><span class="s3">\n        </span><span class="s1">flushToDisk,</span><span class="s3">\n        </span><span class="s1">serverDistDir,</span><span class="s3">\n        </span><span class="s1">revalidatedTags,</span><span class="s3">\n        </span><span class="s1">maxMemoryCacheSize,</span><span class="s3">\n        </span><span class="s1">_requestHeaders: requestHeaders,</span><span class="s3">\n        </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private calculateRevalidate(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">fromTime: number,</span><span class="s3">\n    </span><span class="s1">dev: boolean,</span><span class="s3">\n    </span><span class="s1">isFallback: boolean | undefined</span><span class="s3">\n  </span><span class="s1">): Revalidate {</span><span class="s3">\n    </span><span class="s1">// in development we don't have a prerender-manifest</span><span class="s3">\n    </span><span class="s1">// and default to always revalidating to allow easier debugging</span><span class="s3">\n    </span><span class="s1">if (dev)</span><span class="s3">\n      </span><span class="s1">return Math.floor(performance.timeOrigin + performance.now() - 1000)</span><span class="s3">\n\n    </span><span class="s1">const cacheControl = this.cacheControls.get(toRoute(pathname))</span><span class="s3">\n\n    </span><span class="s1">// if an entry isn't present in routes we fallback to a default</span><span class="s3">\n    </span><span class="s1">// of revalidating after 1 second unless it's a fallback request.</span><span class="s3">\n    </span><span class="s1">const initialRevalidateSeconds = cacheControl</span><span class="s3">\n      </span><span class="s1">? cacheControl.revalidate</span><span class="s3">\n      </span><span class="s1">: isFallback</span><span class="s3">\n        </span><span class="s1">? false</span><span class="s3">\n        </span><span class="s1">: 1</span><span class="s3">\n\n    </span><span class="s1">const revalidateAfter =</span><span class="s3">\n      </span><span class="s1">typeof initialRevalidateSeconds === 'number'</span><span class="s3">\n        </span><span class="s1">? initialRevalidateSeconds * 1000 + fromTime</span><span class="s3">\n        </span><span class="s1">: initialRevalidateSeconds</span><span class="s3">\n\n    </span><span class="s1">return revalidateAfter</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_getPathname(pathname: string, fetchCache?: boolean) {</span><span class="s3">\n    </span><span class="s1">return fetchCache ? pathname : normalizePagePath(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">resetRequestCache() {</span><span class="s3">\n    </span><span class="s1">this.cacheHandler?.resetRequestCache?.()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async lock(cacheKey: string): Promise&lt;() =&gt; Promise&lt;void&gt; | void&gt; {</span><span class="s3">\n    </span><span class="s1">// Wait for any existing lock on this cache key to be released</span><span class="s3">\n    </span><span class="s1">// This implements a simple queue-based locking mechanism</span><span class="s3">\n    </span><span class="s1">while (true) {</span><span class="s3">\n      </span><span class="s1">const lock = this.locks.get(cacheKey)</span><span class="s3">\n\n      </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n        </span><span class="s1">console.log('lock get', cacheKey, !!lock)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If no lock exists, we can proceed to acquire it</span><span class="s3">\n      </span><span class="s1">if (!lock) break</span><span class="s3">\n\n      </span><span class="s1">// Wait for the existing lock to be released before trying again</span><span class="s3">\n      </span><span class="s1">await lock</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Create a new detached promise that will represent this lock</span><span class="s3">\n    </span><span class="s1">// The resolve function (unlock) will be returned to the caller</span><span class="s3">\n    </span><span class="s1">const { resolve, promise } = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n\n    </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('successfully locked', cacheKey)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Store the lock promise in the locks map</span><span class="s3">\n    </span><span class="s1">this.locks.set(cacheKey, promise)</span><span class="s3">\n\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">// Resolve the promise to release the lock.</span><span class="s3">\n      </span><span class="s1">resolve()</span><span class="s3">\n\n      </span><span class="s1">// Remove the lock from the map once it's released so that future gets</span><span class="s3">\n      </span><span class="s1">// can acquire the lock.</span><span class="s3">\n      </span><span class="s1">this.locks.delete(cacheKey)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async revalidateTag(tags: string | string[]): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return this.cacheHandler?.revalidateTag(tags)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23</span><span class="s3">\n  </span><span class="s1">async generateCacheKey(</span><span class="s3">\n    </span><span class="s1">url: string,</span><span class="s3">\n    </span><span class="s1">init: RequestInit | Request = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">// this should be bumped anytime a fix is made to cache entries</span><span class="s3">\n    </span><span class="s1">// that should bust the cache</span><span class="s3">\n    </span><span class="s1">const MAIN_KEY_PREFIX = 'v3'</span><span class="s3">\n\n    </span><span class="s1">const bodyChunks: string[] = []</span><span class="s3">\n\n    </span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n    </span><span class="s1">const decoder = new TextDecoder()</span><span class="s3">\n\n    </span><span class="s1">if (init.body) {</span><span class="s3">\n      </span><span class="s1">// handle Uint8Array body</span><span class="s3">\n      </span><span class="s1">if (init.body instanceof Uint8Array) {</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(decoder.decode(init.body))</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n      </span><span class="s1">} // handle ReadableStream body</span><span class="s3">\n      </span><span class="s1">else if (typeof (init.body as any).getReader === 'function') {</span><span class="s3">\n        </span><span class="s1">const readableBody = init.body as ReadableStream&lt;Uint8Array | string&gt;</span><span class="s3">\n\n        </span><span class="s1">const chunks: Uint8Array[] = []</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">await readableBody.pipeTo(</span><span class="s3">\n            </span><span class="s1">new WritableStream({</span><span class="s3">\n              </span><span class="s1">write(chunk) {</span><span class="s3">\n                </span><span class="s1">if (typeof chunk === 'string') {</span><span class="s3">\n                  </span><span class="s1">chunks.push(encoder.encode(chunk))</span><span class="s3">\n                  </span><span class="s1">bodyChunks.push(chunk)</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                  </span><span class="s1">chunks.push(chunk)</span><span class="s3">\n                  </span><span class="s1">bodyChunks.push(decoder.decode(chunk, { stream: true }))</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// Flush the decoder.</span><span class="s3">\n          </span><span class="s1">bodyChunks.push(decoder.decode())</span><span class="s3">\n\n          </span><span class="s1">// Create a new buffer with all the chunks.</span><span class="s3">\n          </span><span class="s1">const length = chunks.reduce((total, arr) =&gt; total + arr.length, 0)</span><span class="s3">\n          </span><span class="s1">const arrayBuffer = new Uint8Array(length)</span><span class="s3">\n\n          </span><span class="s1">// Push each of the chunks into the new array buffer.</span><span class="s3">\n          </span><span class="s1">let offset = 0</span><span class="s3">\n          </span><span class="s1">for (const chunk of chunks) {</span><span class="s3">\n            </span><span class="s1">arrayBuffer.set(chunk, offset)</span><span class="s3">\n            </span><span class="s1">offset += chunk.length</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">;(init as any)._ogBody = arrayBuffer</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">console.error('Problem reading body', err)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // handle FormData or URLSearchParams bodies</span><span class="s3">\n      </span><span class="s1">else if (typeof (init.body as any).keys === 'function') {</span><span class="s3">\n        </span><span class="s1">const formData = init.body as FormData</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n        </span><span class="s1">for (const key of new Set([...formData.keys()])) {</span><span class="s3">\n          </span><span class="s1">const values = formData.getAll(key)</span><span class="s3">\n          </span><span class="s1">bodyChunks.push(</span><span class="s3">\n            </span><span class="s1">`${key}=${(</span><span class="s3">\n              </span><span class="s1">await Promise.all(</span><span class="s3">\n                </span><span class="s1">values.map(async (val) =&gt; {</span><span class="s3">\n                  </span><span class="s1">if (typeof val === 'string') {</span><span class="s3">\n                    </span><span class="s1">return val</span><span class="s3">\n                  </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">return await val.text()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">).join(',')}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// handle blob body</span><span class="s3">\n      </span><span class="s1">} else if (typeof (init.body as any).arrayBuffer === 'function') {</span><span class="s3">\n        </span><span class="s1">const blob = init.body as Blob</span><span class="s3">\n        </span><span class="s1">const arrayBuffer = await blob.arrayBuffer()</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(await blob.text())</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = new Blob([arrayBuffer], { type: blob.type })</span><span class="s3">\n      </span><span class="s1">} else if (typeof init.body === 'string') {</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(init.body)</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const headers =</span><span class="s3">\n      </span><span class="s1">typeof (init.headers || {}).keys === 'function'</span><span class="s3">\n        </span><span class="s1">? Object.fromEntries(init.headers as Headers)</span><span class="s3">\n        </span><span class="s1">: Object.assign({}, init.headers)</span><span class="s3">\n\n    </span><span class="s1">// w3c trace context headers can break request caching and deduplication</span><span class="s3">\n    </span><span class="s1">// so we remove them from the cache key</span><span class="s3">\n    </span><span class="s1">if ('traceparent' in headers) delete headers['traceparent']</span><span class="s3">\n    </span><span class="s1">if ('tracestate' in headers) delete headers['tracestate']</span><span class="s3">\n\n    </span><span class="s1">const cacheString = JSON.stringify([</span><span class="s3">\n      </span><span class="s1">MAIN_KEY_PREFIX,</span><span class="s3">\n      </span><span class="s1">this.fetchCacheKeyPrefix || '',</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">init.method,</span><span class="s3">\n      </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">init.mode,</span><span class="s3">\n      </span><span class="s1">init.redirect,</span><span class="s3">\n      </span><span class="s1">init.credentials,</span><span class="s3">\n      </span><span class="s1">init.referrer,</span><span class="s3">\n      </span><span class="s1">init.referrerPolicy,</span><span class="s3">\n      </span><span class="s1">init.integrity,</span><span class="s3">\n      </span><span class="s1">init.cache,</span><span class="s3">\n      </span><span class="s1">bodyChunks,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">function bufferToHex(buffer: ArrayBuffer): string {</span><span class="s3">\n        </span><span class="s1">return Array.prototype.map</span><span class="s3">\n          </span><span class="s1">.call(new Uint8Array(buffer), (b) =&gt; b.toString(16).padStart(2, '0'))</span><span class="s3">\n          </span><span class="s1">.join('')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const buffer = encoder.encode(cacheString)</span><span class="s3">\n      </span><span class="s1">return bufferToHex(await crypto.subtle.digest('SHA-256', buffer))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const crypto = require('crypto') as typeof import('crypto')</span><span class="s3">\n      </span><span class="s1">return crypto.createHash('sha256').update(cacheString).digest('hex')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalFetchCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">// Unlike other caches if we have a resume data cache, we use it even if</span><span class="s3">\n    </span><span class="s1">// testmode would normally disable it or if requestHeaders say 'no-cache'.</span><span class="s3">\n    </span><span class="s1">if (ctx.kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const resumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getRenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">if (resumeDataCache) {</span><span class="s3">\n        </span><span class="s1">const memoryCacheData = resumeDataCache.fetch.get(cacheKey)</span><span class="s3">\n        </span><span class="s1">if (memoryCacheData?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n          </span><span class="s1">return { isStale: false, value: memoryCacheData }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// we don't leverage the prerender cache in dev mode</span><span class="s3">\n    </span><span class="s1">// so that getStaticProps is always called for easier debugging</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this.disableForTestmode ||</span><span class="s3">\n      </span><span class="s1">(this.dev &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(ctx.kind !== IncrementalCacheKind.FETCH ||</span><span class="s3">\n          </span><span class="s1">this.requestHeaders['cache-control'] === 'no-cache'))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">cacheKey = this._getPathname(</span><span class="s3">\n      </span><span class="s1">cacheKey,</span><span class="s3">\n      </span><span class="s1">ctx.kind === IncrementalCacheKind.FETCH</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const cacheData = await this.cacheHandler?.get(cacheKey, ctx)</span><span class="s3">\n\n    </span><span class="s1">if (ctx.kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">if (!cacheData) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheData.value?.kind !== CachedRouteKind.FETCH) {</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">`Expected cached value for cache key ${JSON.stringify(cacheKey)} to be a </span><span class="s3">\&quot;</span><span class="s1">FETCH</span><span class="s3">\&quot; </span><span class="s1">kind, got ${JSON.stringify(cacheData.value?.kind)} instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const combinedTags = [...(ctx.tags || []), ...(ctx.softTags || [])]</span><span class="s3">\n      </span><span class="s1">// if a tag was revalidated we don't return stale data</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">combinedTags.some(</span><span class="s3">\n          </span><span class="s1">(tag) =&gt;</span><span class="s3">\n            </span><span class="s1">this.revalidatedTags?.includes(tag) ||</span><span class="s3">\n            </span><span class="s1">workStore?.pendingRevalidatedTags?.includes(tag)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const revalidate = ctx.revalidate || cacheData.value.revalidate</span><span class="s3">\n      </span><span class="s1">const age =</span><span class="s3">\n        </span><span class="s1">(performance.timeOrigin +</span><span class="s3">\n          </span><span class="s1">performance.now() -</span><span class="s3">\n          </span><span class="s1">(cacheData.lastModified || 0)) /</span><span class="s3">\n        </span><span class="s1">1000</span><span class="s3">\n\n      </span><span class="s1">const isStale = age &gt; revalidate</span><span class="s3">\n      </span><span class="s1">const data = cacheData.value.data</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">value: { kind: CachedRouteKind.FETCH, data, revalidate },</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (cacheData?.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">`Expected cached value for cache key ${JSON.stringify(cacheKey)} not to be a ${JSON.stringify(ctx.kind)} kind, got </span><span class="s3">\&quot;</span><span class="s1">FETCH</span><span class="s3">\&quot; </span><span class="s1">instead.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let entry: IncrementalResponseCacheEntry | null = null</span><span class="s3">\n    </span><span class="s1">const cacheControl = this.cacheControls.get(toRoute(cacheKey))</span><span class="s3">\n\n    </span><span class="s1">let isStale: boolean | -1 | undefined</span><span class="s3">\n    </span><span class="s1">let revalidateAfter: Revalidate</span><span class="s3">\n\n    </span><span class="s1">if (cacheData?.lastModified === -1) {</span><span class="s3">\n      </span><span class="s1">isStale = -1</span><span class="s3">\n      </span><span class="s1">revalidateAfter = -1 * CACHE_ONE_YEAR</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">revalidateAfter = this.calculateRevalidate(</span><span class="s3">\n        </span><span class="s1">cacheKey,</span><span class="s3">\n        </span><span class="s1">cacheData?.lastModified || performance.timeOrigin + performance.now(),</span><span class="s3">\n        </span><span class="s1">this.dev ?? false,</span><span class="s3">\n        </span><span class="s1">ctx.isFallback</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">isStale =</span><span class="s3">\n        </span><span class="s1">revalidateAfter !== false &amp;&amp;</span><span class="s3">\n        </span><span class="s1">revalidateAfter &lt; performance.timeOrigin + performance.now()</span><span class="s3">\n          </span><span class="s1">? true</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (cacheData) {</span><span class="s3">\n      </span><span class="s1">entry = {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n        </span><span class="s1">revalidateAfter,</span><span class="s3">\n        </span><span class="s1">value: cacheData.value,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!cacheData &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.prerenderManifest.notFoundRoutes.includes(cacheKey)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// for the first hit after starting the server the cache</span><span class="s3">\n      </span><span class="s1">// may not have a way to save notFound: true so if</span><span class="s3">\n      </span><span class="s1">// the prerender-manifest marks this as notFound then we</span><span class="s3">\n      </span><span class="s1">// return that entry and trigger a cache set to give it a</span><span class="s3">\n      </span><span class="s1">// chance to update in-memory entries</span><span class="s3">\n      </span><span class="s1">entry = {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">value: null,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n        </span><span class="s1">revalidateAfter,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.set(cacheKey, entry.value, { ...ctx, cacheControl })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return entry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: CachedFetchValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">// Even if we otherwise disable caching for testMode or if no fetchCache is</span><span class="s3">\n    </span><span class="s1">// configured we still always stash results in the resume data cache if one</span><span class="s3">\n    </span><span class="s1">// exists. This is because this is a transient in memory cache that</span><span class="s3">\n    </span><span class="s1">// populates caches ahead of a dynamic render in dev mode to allow the RSC</span><span class="s3">\n    </span><span class="s1">// debug info to have the right environment associated to it.</span><span class="s3">\n    </span><span class="s1">if (data?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const prerenderResumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getPrerenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">if (prerenderResumeDataCache) {</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache.fetch.set(pathname, data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.disableForTestmode || (this.dev &amp;&amp; !ctx.fetchCache)) return</span><span class="s3">\n\n    </span><span class="s1">pathname = this._getPathname(pathname, ctx.fetchCache)</span><span class="s3">\n\n    </span><span class="s1">// FetchCache has upper limit of 2MB per-entry currently</span><span class="s3">\n    </span><span class="s1">const itemSize = JSON.stringify(data).length</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">ctx.fetchCache &amp;&amp;</span><span class="s3">\n      </span><span class="s1">itemSize &gt; 2 * 1024 * 1024 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We ignore the size limit when custom cache handler is being used, as it</span><span class="s3">\n      </span><span class="s1">// might not have this limit</span><span class="s3">\n      </span><span class="s1">!this.hasCustomCacheHandler &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We also ignore the size limit when it's an implicit build-time-only</span><span class="s3">\n      </span><span class="s1">// caching that the user isn't even aware of.</span><span class="s3">\n      </span><span class="s1">!ctx.isImplicitBuildTimeCache</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const warningText = `Failed to set Next.js data cache for ${ctx.fetchUrl || pathname}, items over 2MB can not be cached (${itemSize} bytes)`</span><span class="s3">\n\n      </span><span class="s1">if (this.dev) {</span><span class="s3">\n        </span><span class="s1">throw new Error(warningText)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">console.warn(warningText)</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">if (!ctx.fetchCache &amp;&amp; ctx.cacheControl) {</span><span class="s3">\n        </span><span class="s1">this.cacheControls.set(toRoute(pathname), ctx.cacheControl)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">await this.cacheHandler?.set(pathname, data, ctx)</span><span class="s3">\n    </span><span class="s1">} catch (error) {</span><span class="s3">\n      </span><span class="s1">console.warn('Failed to update prerender cache for', pathname, error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import DefaultCacheHandler from '../lib/cache-handlers/default.external'</span><span class="s3">\n</span><span class="s1">import type { CacheHandlerCompat } from '../lib/cache-handlers/types'</span><span class="s3">\n\n</span><span class="s1">const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">? (message: string, ...args: any[]) =&gt; {</span><span class="s3">\n      </span><span class="s1">console.log(`use-cache: ${message}`, ...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">const handlersSymbol = Symbol.for('@next/cache-handlers')</span><span class="s3">\n</span><span class="s1">const handlersMapSymbol = Symbol.for('@next/cache-handlers-map')</span><span class="s3">\n</span><span class="s1">const handlersSetSymbol = Symbol.for('@next/cache-handlers-set')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The reference to the cache handlers. We store the cache handlers on the</span><span class="s3">\n </span><span class="s1">* global object so that we can access the same instance across different</span><span class="s3">\n </span><span class="s1">* boundaries (such as different copies of the same module).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const reference: typeof globalThis &amp; {</span><span class="s3">\n  </span><span class="s1">[handlersSymbol]?: {</span><span class="s3">\n    </span><span class="s1">RemoteCache?: CacheHandlerCompat</span><span class="s3">\n    </span><span class="s1">DefaultCache?: CacheHandlerCompat</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[handlersMapSymbol]?: Map&lt;string, CacheHandlerCompat&gt;</span><span class="s3">\n  </span><span class="s1">[handlersSetSymbol]?: Set&lt;CacheHandlerCompat&gt;</span><span class="s3">\n</span><span class="s1">} = globalThis</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Initialize the cache handlers.</span><span class="s3">\n </span><span class="s1">* @returns `true` if the cache handlers were initialized, `false` if they were already initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function initializeCacheHandlers(): boolean {</span><span class="s3">\n  </span><span class="s1">// If the cache handlers have already been initialized, don't do it again.</span><span class="s3">\n  </span><span class="s1">if (reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">debug?.('cache handlers already initialized')</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">debug?.('initializing cache handlers')</span><span class="s3">\n  </span><span class="s1">reference[handlersMapSymbol] = new Map&lt;string, CacheHandlerCompat&gt;()</span><span class="s3">\n\n  </span><span class="s1">// Initialize the cache from the symbol contents first.</span><span class="s3">\n  </span><span class="s1">if (reference[handlersSymbol]) {</span><span class="s3">\n    </span><span class="s1">let fallback: CacheHandlerCompat</span><span class="s3">\n    </span><span class="s1">if (reference[handlersSymbol].DefaultCache) {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from symbol')</span><span class="s3">\n      </span><span class="s1">fallback = reference[handlersSymbol].DefaultCache</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n      </span><span class="s1">fallback = DefaultCacheHandler</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">reference[handlersMapSymbol].set('default', fallback)</span><span class="s3">\n\n    </span><span class="s1">if (reference[handlersSymbol].RemoteCache) {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from symbol')</span><span class="s3">\n      </span><span class="s1">reference[handlersMapSymbol].set(</span><span class="s3">\n        </span><span class="s1">'remote',</span><span class="s3">\n        </span><span class="s1">reference[handlersSymbol].RemoteCache</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n      </span><span class="s1">reference[handlersMapSymbol].set('remote', fallback)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n    </span><span class="s1">reference[handlersMapSymbol].set('default', DefaultCacheHandler)</span><span class="s3">\n    </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n    </span><span class="s1">reference[handlersMapSymbol].set('remote', DefaultCacheHandler)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Create a set of the cache handlers.</span><span class="s3">\n  </span><span class="s1">reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a cache handler by kind.</span><span class="s3">\n </span><span class="s1">* @param kind - The kind of cache handler to get.</span><span class="s3">\n </span><span class="s1">* @returns The cache handler, or `undefined` if it does not exist.</span><span class="s3">\n </span><span class="s1">* @throws If the cache handlers are not initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandler(kind: string): CacheHandlerCompat | undefined {</span><span class="s3">\n  </span><span class="s1">// This should never be called before initializeCacheHandlers.</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Cache handlers not initialized')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersMapSymbol].get(kind)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a set iterator over the cache handlers.</span><span class="s3">\n </span><span class="s1">* @returns An iterator over the cache handlers, or `undefined` if they are not</span><span class="s3">\n </span><span class="s1">* initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandlers():</span><span class="s3">\n  </span><span class="s1">| SetIterator&lt;CacheHandlerCompat&gt;</span><span class="s3">\n  </span><span class="s1">| undefined {</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersSetSymbol]) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersSetSymbol].values()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a map iterator over the cache handlers (keyed by kind).</span><span class="s3">\n </span><span class="s1">* @returns An iterator over the cache handler entries, or `undefined` if they</span><span class="s3">\n </span><span class="s1">* are not initialized.</span><span class="s3">\n </span><span class="s1">* @throws If the cache handlers are not initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandlerEntries():</span><span class="s3">\n  </span><span class="s1">| MapIterator&lt;[string, CacheHandlerCompat]&gt;</span><span class="s3">\n  </span><span class="s1">| undefined {</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersMapSymbol].entries()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set a cache handler by kind.</span><span class="s3">\n </span><span class="s1">* @param kind - The kind of cache handler to set.</span><span class="s3">\n </span><span class="s1">* @param cacheHandler - The cache handler to set.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setCacheHandler(</span><span class="s3">\n  </span><span class="s1">kind: string,</span><span class="s3">\n  </span><span class="s1">cacheHandler: CacheHandlerCompat</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// This should never be called before initializeCacheHandlers.</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Cache handlers not initialized')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">debug?.('setting cache handler for </span><span class="s3">\&quot;</span><span class="s1">%s</span><span class="s3">\&quot;</span><span class="s1">', kind)</span><span class="s3">\n  </span><span class="s1">reference[handlersMapSymbol].set(kind, cacheHandler)</span><span class="s3">\n  </span><span class="s1">reference[handlersSetSymbol].add(cacheHandler)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Interop between </span><span class="s3">\&quot;</span><span class="s1">export default</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">module.exports</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function interopDefault(mod: any) {</span><span class="s3">\n  </span><span class="s1">return mod.default || mod</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'node:http'</span><span class="s3">\n</span><span class="s1">import type { NextConfigComplete } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'node:url'</span><span class="s3">\n\n</span><span class="s1">export type RevalidateFn = (config: {</span><span class="s3">\n  </span><span class="s1">urlPath: string</span><span class="s3">\n  </span><span class="s1">revalidateHeaders: { [key: string]: string | string[] }</span><span class="s3">\n  </span><span class="s1">opts: { unstable_onlyGenerated?: boolean }</span><span class="s3">\n</span><span class="s1">}) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n</span><span class="s1">// The RouterServerContext contains instance specific</span><span class="s3">\n</span><span class="s1">// information that isn't available/relevant when</span><span class="s3">\n</span><span class="s1">// deployed in serverless environments, the key is</span><span class="s3">\n</span><span class="s1">// the relative project dir this allows separate contexts</span><span class="s3">\n</span><span class="s1">// when running multiple next instances in same process</span><span class="s3">\n</span><span class="s1">export type RouterServerContext = Record&lt;</span><span class="s3">\n  </span><span class="s1">string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">// hostname the server is started with</span><span class="s3">\n    </span><span class="s1">hostname?: string</span><span class="s3">\n    </span><span class="s1">// revalidate function to bypass going through network</span><span class="s3">\n    </span><span class="s1">// to invoke revalidate request (uses mocked req/res)</span><span class="s3">\n    </span><span class="s1">revalidate?: RevalidateFn</span><span class="s3">\n    </span><span class="s1">// function to render the 404 page</span><span class="s3">\n    </span><span class="s1">render404?: (</span><span class="s3">\n      </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n      </span><span class="s1">res: ServerResponse,</span><span class="s3">\n      </span><span class="s1">parsedUrl?: UrlWithParsedQuery,</span><span class="s3">\n      </span><span class="s1">setHeaders?: boolean</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n    </span><span class="s1">// current loaded public runtime config</span><span class="s3">\n    </span><span class="s1">publicRuntimeConfig?: NextConfigComplete['publicRuntimeConfig']</span><span class="s3">\n    </span><span class="s1">// exposing nextConfig for dev mode specifically</span><span class="s3">\n    </span><span class="s1">nextConfig?: NextConfigComplete</span><span class="s3">\n    </span><span class="s1">// whether running in custom server mode</span><span class="s3">\n    </span><span class="s1">isCustomServer?: boolean</span><span class="s3">\n    </span><span class="s1">// whether test proxy is enabled</span><span class="s3">\n    </span><span class="s1">experimentalTestProxy?: boolean</span><span class="s3">\n    </span><span class="s1">// allow dev server to log with original stack</span><span class="s3">\n    </span><span class="s1">logErrorWithOriginalStack?: (err: unknown, type: string) =&gt; void</span><span class="s3">\n    </span><span class="s1">// allow setting ISR status in dev</span><span class="s3">\n    </span><span class="s1">setIsrStatus?: (key: string, value: boolean | null) =&gt; void</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export const RouterServerContextSymbol = Symbol.for(</span><span class="s3">\n  </span><span class="s1">'@next/router-server-methods'</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export const routerServerGlobal = globalThis as typeof globalThis &amp; {</span><span class="s3">\n  </span><span class="s1">[RouterServerContextSymbol]?: RouterServerContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'node:http'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">InstrumentationOnRequestError,</span><span class="s3">\n  </span><span class="s1">RequestErrorContext,</span><span class="s3">\n</span><span class="s1">} from '../instrumentation/types'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'node:querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'node:url'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">PrerenderManifest,</span><span class="s3">\n  </span><span class="s1">RequiredServerFilesManifest,</span><span class="s3">\n</span><span class="s1">} from '../../build'</span><span class="s3">\n</span><span class="s1">import type { DevRoutesManifest } from '../lib/router-utils/setup-dev-bundler'</span><span class="s3">\n</span><span class="s1">import type { RouteDefinition } from '../route-definitions/route-definition'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">BUILD_ID_FILE,</span><span class="s3">\n  </span><span class="s1">BUILD_MANIFEST,</span><span class="s3">\n  </span><span class="s1">CLIENT_REFERENCE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">DYNAMIC_CSS_MANIFEST,</span><span class="s3">\n  </span><span class="s1">NEXT_FONT_MANIFEST,</span><span class="s3">\n  </span><span class="s1">PRERENDER_MANIFEST,</span><span class="s3">\n  </span><span class="s1">REACT_LOADABLE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">ROUTES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SERVER_FILES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SERVER_REFERENCE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SUBRESOURCE_INTEGRITY_MANIFEST,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { parseReqUrl } from '../../lib/url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">normalizeLocalePath,</span><span class="s3">\n  </span><span class="s1">type PathLocale,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { getServerUtils } from '../server-utils'</span><span class="s3">\n</span><span class="s1">import { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import { checkIsOnDemandRevalidate } from '../api-utils'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../types'</span><span class="s3">\n</span><span class="s1">import type { BuildManifest } from '../get-page-files'</span><span class="s3">\n</span><span class="s1">import type { ReactLoadableManifest } from '../load-components'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import { normalizeDataPath } from '../../shared/lib/page-path/normalize-data-path'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'</span><span class="s3">\n</span><span class="s1">import { addRequestMeta, getRequestMeta } from '../request-meta'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n</span><span class="s1">import { isStaticMetadataRoute } from '../../lib/metadata/is-metadata-route'</span><span class="s3">\n</span><span class="s1">import { IncrementalCache } from '../lib/incremental-cache'</span><span class="s3">\n</span><span class="s1">import { initializeCacheHandlers, setCacheHandler } from '../use-cache/handlers'</span><span class="s3">\n</span><span class="s1">import { interopDefault } from '../app-render/interop-default'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { I18NConfig, NextConfigComplete } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import ResponseCache, { type ResponseGenerator } from '../response-cache'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RouterServerContextSymbol,</span><span class="s3">\n  </span><span class="s1">routerServerGlobal,</span><span class="s3">\n  </span><span class="s1">type RouterServerContext,</span><span class="s3">\n</span><span class="s1">} from '../lib/router-utils/router-server-context'</span><span class="s3">\n</span><span class="s1">import { decodePathParams } from '../lib/router-utils/decode-path-params'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../../lib/generate-interception-routes-rewrites'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RouteModuleOptions is the options that are passed to the route module, other</span><span class="s3">\n </span><span class="s1">* route modules should extend this class to add specific options for their</span><span class="s3">\n </span><span class="s1">* route.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RouteModuleOptions&lt;</span><span class="s3">\n  </span><span class="s1">D extends RouteDefinition = RouteDefinition,</span><span class="s3">\n  </span><span class="s1">U = unknown,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">readonly definition: Readonly&lt;D&gt;</span><span class="s3">\n  </span><span class="s1">readonly userland: Readonly&lt;U&gt;</span><span class="s3">\n  </span><span class="s1">readonly distDir: string</span><span class="s3">\n  </span><span class="s1">readonly relativeProjectDir: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RouteHandlerContext is the base context for a route handler.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RouteModuleHandleContext {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Any matched parameters for the request. This is only defined for dynamic</span><span class="s3">\n   </span><span class="s1">* routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">params: Record&lt;string, string | string[] | undefined&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const dynamicImportEsmDefault = (id: string) =&gt;</span><span class="s3">\n  </span><span class="s1">import(/* webpackIgnore: true */ /* turbopackIgnore: true */ id).then(</span><span class="s3">\n    </span><span class="s1">(mod) =&gt; mod.default || mod</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RouteModule is the base class for all route modules. This class should be</span><span class="s3">\n </span><span class="s1">* extended by all route modules.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export abstract class RouteModule&lt;</span><span class="s3">\n  </span><span class="s1">D extends RouteDefinition = RouteDefinition,</span><span class="s3">\n  </span><span class="s1">U = unknown,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The userland module. This is the module that is exported from the user's</span><span class="s3">\n   </span><span class="s1">* code. This is marked as readonly to ensure that the module is not mutated</span><span class="s3">\n   </span><span class="s1">* because the module (when compiled) only provides getters.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly userland: Readonly&lt;U&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The definition of the route.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly definition: Readonly&lt;D&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The shared modules that are exposed and required for the route module.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static readonly sharedModules: any</span><span class="s3">\n\n  </span><span class="s1">public isDev: boolean</span><span class="s3">\n  </span><span class="s1">public distDir: string</span><span class="s3">\n  </span><span class="s1">public isAppRouter?: boolean</span><span class="s3">\n  </span><span class="s1">public relativeProjectDir: string</span><span class="s3">\n  </span><span class="s1">public incrementCache?: IncrementalCache</span><span class="s3">\n  </span><span class="s1">public responseCache?: ResponseCache</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">userland,</span><span class="s3">\n    </span><span class="s1">definition,</span><span class="s3">\n    </span><span class="s1">distDir,</span><span class="s3">\n    </span><span class="s1">relativeProjectDir,</span><span class="s3">\n  </span><span class="s1">}: RouteModuleOptions&lt;D, U&gt;) {</span><span class="s3">\n    </span><span class="s1">this.userland = userland</span><span class="s3">\n    </span><span class="s1">this.definition = definition</span><span class="s3">\n    </span><span class="s1">this.isDev = process.env.NODE_ENV === 'development'</span><span class="s3">\n    </span><span class="s1">this.distDir = distDir</span><span class="s3">\n    </span><span class="s1">this.relativeProjectDir = relativeProjectDir</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async instrumentationOnRequestError(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;InstrumentationOnRequestError&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">const { getEdgeInstrumentationModule } = await import('../web/globals')</span><span class="s3">\n      </span><span class="s1">const instrumentation = await getEdgeInstrumentationModule()</span><span class="s3">\n\n      </span><span class="s1">if (instrumentation) {</span><span class="s3">\n        </span><span class="s1">await instrumentation.onRequestError?.(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const { join } = require('node:path') as typeof import('node:path')</span><span class="s3">\n      </span><span class="s1">const absoluteProjectDir = join(</span><span class="s3">\n        </span><span class="s1">process.cwd(),</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const { instrumentationOnRequestError } = await import(</span><span class="s3">\n        </span><span class="s1">'../lib/router-utils/instrumentation-globals.external.js'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">return instrumentationOnRequestError(</span><span class="s3">\n        </span><span class="s1">absoluteProjectDir,</span><span class="s3">\n        </span><span class="s1">this.distDir,</span><span class="s3">\n        </span><span class="s1">...args</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private loadManifests(</span><span class="s3">\n    </span><span class="s1">srcPage: string,</span><span class="s3">\n    </span><span class="s1">projectDir?: string</span><span class="s3">\n  </span><span class="s1">): {</span><span class="s3">\n    </span><span class="s1">buildId: string</span><span class="s3">\n    </span><span class="s1">buildManifest: BuildManifest</span><span class="s3">\n    </span><span class="s1">fallbackBuildManifest: BuildManifest</span><span class="s3">\n    </span><span class="s1">routesManifest: DeepReadonly&lt;DevRoutesManifest&gt;</span><span class="s3">\n    </span><span class="s1">nextFontManifest: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n    </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">serverFilesManifest: RequiredServerFilesManifest</span><span class="s3">\n    </span><span class="s1">reactLoadableManifest: DeepReadonly&lt;ReactLoadableManifest&gt;</span><span class="s3">\n    </span><span class="s1">subresourceIntegrityManifest: any</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest: any</span><span class="s3">\n    </span><span class="s1">serverActionsManifest: any</span><span class="s3">\n    </span><span class="s1">dynamicCssManifest: any</span><span class="s3">\n    </span><span class="s1">interceptionRoutePatterns: RegExp[]</span><span class="s3">\n  </span><span class="s1">} {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">const { getEdgePreviewProps } =</span><span class="s3">\n        </span><span class="s1">require('../web/get-edge-preview-props') as typeof import('../web/get-edge-preview-props')</span><span class="s3">\n\n      </span><span class="s1">const maybeJSONParse = (str?: string) =&gt;</span><span class="s3">\n        </span><span class="s1">str ? JSON.parse(str) : undefined</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">buildId: process.env.__NEXT_BUILD_ID || '',</span><span class="s3">\n        </span><span class="s1">buildManifest: self.__BUILD_MANIFEST as any,</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest: {} as any,</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest: maybeJSONParse(self.__REACT_LOADABLE_MANIFEST),</span><span class="s3">\n        </span><span class="s1">nextFontManifest: maybeJSONParse(self.__NEXT_FONT_MANIFEST),</span><span class="s3">\n        </span><span class="s1">prerenderManifest: {</span><span class="s3">\n          </span><span class="s1">routes: {},</span><span class="s3">\n          </span><span class="s1">dynamicRoutes: {},</span><span class="s3">\n          </span><span class="s1">notFoundRoutes: [],</span><span class="s3">\n          </span><span class="s1">version: 4,</span><span class="s3">\n          </span><span class="s1">preview: getEdgePreviewProps(),</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">routesManifest: {</span><span class="s3">\n          </span><span class="s1">version: 4,</span><span class="s3">\n          </span><span class="s1">caseSensitive: Boolean(process.env.__NEXT_CASE_SENSITIVE_ROUTES),</span><span class="s3">\n          </span><span class="s1">basePath: process.env.__NEXT_BASE_PATH || '',</span><span class="s3">\n          </span><span class="s1">rewrites: (process.env.__NEXT_REWRITES as any) || {</span><span class="s3">\n            </span><span class="s1">beforeFiles: [],</span><span class="s3">\n            </span><span class="s1">afterFiles: [],</span><span class="s3">\n            </span><span class="s1">fallback: [],</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">redirects: [],</span><span class="s3">\n          </span><span class="s1">headers: [],</span><span class="s3">\n          </span><span class="s1">i18n:</span><span class="s3">\n            </span><span class="s1">(process.env.__NEXT_I18N_CONFIG as any as I18NConfig) || undefined,</span><span class="s3">\n          </span><span class="s1">skipMiddlewareUrlNormalize: Boolean(</span><span class="s3">\n            </span><span class="s1">process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">serverFilesManifest: {</span><span class="s3">\n          </span><span class="s1">config: (globalThis as any).nextConfig || {},</span><span class="s3">\n        </span><span class="s1">} as any,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest: self.__RSC_MANIFEST?.[srcPage],</span><span class="s3">\n        </span><span class="s1">serverActionsManifest: maybeJSONParse(self.__RSC_SERVER_MANIFEST),</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest: maybeJSONParse(</span><span class="s3">\n          </span><span class="s1">self.__SUBRESOURCE_INTEGRITY_MANIFEST</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest: maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST),</span><span class="s3">\n        </span><span class="s1">interceptionRoutePatterns: (</span><span class="s3">\n          </span><span class="s1">maybeJSONParse(self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST) ?? []</span><span class="s3">\n        </span><span class="s1">).map((rewrite: any) =&gt; new RegExp(rewrite.regex)),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (!projectDir) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Invariant: projectDir is required for node runtime')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { loadManifestFromRelativePath } =</span><span class="s3">\n        </span><span class="s1">require('../load-manifest.external') as typeof import('../load-manifest.external')</span><span class="s3">\n      </span><span class="s1">const normalizedPagePath = normalizePagePath(srcPage)</span><span class="s3">\n\n      </span><span class="s1">const [</span><span class="s3">\n        </span><span class="s1">routesManifest,</span><span class="s3">\n        </span><span class="s1">prerenderManifest,</span><span class="s3">\n        </span><span class="s1">buildManifest,</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest,</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest,</span><span class="s3">\n        </span><span class="s1">nextFontManifest,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n        </span><span class="s1">serverActionsManifest,</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n        </span><span class="s1">serverFilesManifest,</span><span class="s3">\n        </span><span class="s1">buildId,</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest,</span><span class="s3">\n      </span><span class="s1">] = [</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;DevRoutesManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: ROUTES_MANIFEST,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;PrerenderManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: PRERENDER_MANIFEST,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;BuildManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: BUILD_MANIFEST,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">srcPage === '/_error'</span><span class="s3">\n          </span><span class="s1">? loadManifestFromRelativePath&lt;BuildManifest&gt;({</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">manifest: `fallback-${BUILD_MANIFEST}`,</span><span class="s3">\n              </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n              </span><span class="s1">handleMissing: true,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: ({} as BuildManifest),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;ReactLoadableManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: process.env.TURBOPACK</span><span class="s3">\n            </span><span class="s1">? `server/${this.isAppRouter ? 'app' : 'pages'}${normalizedPagePath}/${REACT_LOADABLE_MANIFEST}`</span><span class="s3">\n            </span><span class="s1">: REACT_LOADABLE_MANIFEST,</span><span class="s3">\n          </span><span class="s1">handleMissing: true,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;NextFontManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: `server/${NEXT_FONT_MANIFEST}.json`,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">this.isAppRouter &amp;&amp; !isStaticMetadataRoute(srcPage)</span><span class="s3">\n          </span><span class="s1">? loadManifestFromRelativePath({</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">useEval: true,</span><span class="s3">\n              </span><span class="s1">handleMissing: true,</span><span class="s3">\n              </span><span class="s1">manifest: `server/app${srcPage.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST}.js`,</span><span class="s3">\n              </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n        </span><span class="s1">this.isAppRouter</span><span class="s3">\n          </span><span class="s1">? loadManifestFromRelativePath&lt;any&gt;({</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">manifest: `server/${SERVER_REFERENCE_MANIFEST}.json`,</span><span class="s3">\n              </span><span class="s1">handleMissing: true,</span><span class="s3">\n              </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: {},</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;Record&lt;string, string&gt;&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: `server/${SUBRESOURCE_INTEGRITY_MANIFEST}.json`,</span><span class="s3">\n          </span><span class="s1">handleMissing: true,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">this.isDev</span><span class="s3">\n          </span><span class="s1">? ({} as any)</span><span class="s3">\n          </span><span class="s1">: loadManifestFromRelativePath&lt;RequiredServerFilesManifest&gt;({</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">manifest: SERVER_FILES_MANIFEST,</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">this.isDev</span><span class="s3">\n          </span><span class="s1">? 'development'</span><span class="s3">\n          </span><span class="s1">: loadManifestFromRelativePath&lt;any&gt;({</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">manifest: BUILD_ID_FILE,</span><span class="s3">\n              </span><span class="s1">skipParse: true,</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;any&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: DYNAMIC_CSS_MANIFEST,</span><span class="s3">\n          </span><span class="s1">handleMissing: true,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">buildId,</span><span class="s3">\n        </span><span class="s1">buildManifest,</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest,</span><span class="s3">\n        </span><span class="s1">routesManifest,</span><span class="s3">\n        </span><span class="s1">nextFontManifest,</span><span class="s3">\n        </span><span class="s1">prerenderManifest,</span><span class="s3">\n        </span><span class="s1">serverFilesManifest,</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest: (clientReferenceManifest as any)</span><span class="s3">\n          </span><span class="s1">?.__RSC_MANIFEST?.[srcPage.replace(/%5F/g, '_')],</span><span class="s3">\n        </span><span class="s1">serverActionsManifest,</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest,</span><span class="s3">\n        </span><span class="s1">interceptionRoutePatterns: routesManifest.rewrites.beforeFiles</span><span class="s3">\n          </span><span class="s1">.filter(isInterceptionRouteRewrite)</span><span class="s3">\n          </span><span class="s1">.map((rewrite) =&gt; new RegExp(rewrite.regex)),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async loadCustomCacheHandlers(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">const { cacheHandlers } = nextConfig.experimental</span><span class="s3">\n      </span><span class="s1">if (!cacheHandlers) return</span><span class="s3">\n\n      </span><span class="s1">// If we've already initialized the cache handlers interface, don't do it</span><span class="s3">\n      </span><span class="s1">// again.</span><span class="s3">\n      </span><span class="s1">if (!initializeCacheHandlers()) return</span><span class="s3">\n\n      </span><span class="s1">for (const [kind, handler] of Object.entries(cacheHandlers)) {</span><span class="s3">\n        </span><span class="s1">if (!handler) continue</span><span class="s3">\n\n        </span><span class="s1">const { formatDynamicImportPath } =</span><span class="s3">\n          </span><span class="s1">require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')</span><span class="s3">\n\n        </span><span class="s1">const { join } = require('node:path') as typeof import('node:path')</span><span class="s3">\n        </span><span class="s1">const absoluteProjectDir = join(</span><span class="s3">\n          </span><span class="s1">process.cwd(),</span><span class="s3">\n          </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">setCacheHandler(</span><span class="s3">\n          </span><span class="s1">kind,</span><span class="s3">\n          </span><span class="s1">interopDefault(</span><span class="s3">\n            </span><span class="s1">await dynamicImportEsmDefault(</span><span class="s3">\n              </span><span class="s1">formatDynamicImportPath(</span><span class="s3">\n                </span><span class="s1">`${absoluteProjectDir}/${this.distDir}`,</span><span class="s3">\n                </span><span class="s1">handler</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async getIncrementalCache(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete,</span><span class="s3">\n    </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalCache&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">return (globalThis as any).__incrementalCache</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">let CacheHandler: any</span><span class="s3">\n      </span><span class="s1">const { cacheHandler } = nextConfig</span><span class="s3">\n\n      </span><span class="s1">if (cacheHandler) {</span><span class="s3">\n        </span><span class="s1">const { formatDynamicImportPath } =</span><span class="s3">\n          </span><span class="s1">require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')</span><span class="s3">\n\n        </span><span class="s1">CacheHandler = interopDefault(</span><span class="s3">\n          </span><span class="s1">await dynamicImportEsmDefault(</span><span class="s3">\n            </span><span class="s1">formatDynamicImportPath(this.distDir, cacheHandler)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { join } = require('node:path') as typeof import('node:path')</span><span class="s3">\n      </span><span class="s1">const projectDir = join(</span><span class="s3">\n        </span><span class="s1">process.cwd(),</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">await this.loadCustomCacheHandlers(req, nextConfig)</span><span class="s3">\n\n      </span><span class="s1">// incremental-cache is request specific</span><span class="s3">\n      </span><span class="s1">// although can have shared caches in module scope</span><span class="s3">\n      </span><span class="s1">// per-cache handler</span><span class="s3">\n      </span><span class="s1">return new IncrementalCache({</span><span class="s3">\n        </span><span class="s1">fs: (</span><span class="s3">\n          </span><span class="s1">require('../lib/node-fs-methods') as typeof import('../lib/node-fs-methods')</span><span class="s3">\n        </span><span class="s1">).nodeFs,</span><span class="s3">\n        </span><span class="s1">dev: this.isDev,</span><span class="s3">\n        </span><span class="s1">requestHeaders: req.headers,</span><span class="s3">\n        </span><span class="s1">allowedRevalidateHeaderKeys:</span><span class="s3">\n          </span><span class="s1">nextConfig.experimental.allowedRevalidateHeaderKeys,</span><span class="s3">\n        </span><span class="s1">minimalMode: getRequestMeta(req, 'minimalMode'),</span><span class="s3">\n        </span><span class="s1">serverDistDir: `${projectDir}/${this.distDir}/server`,</span><span class="s3">\n        </span><span class="s1">fetchCacheKeyPrefix: nextConfig.experimental.fetchCacheKeyPrefix,</span><span class="s3">\n        </span><span class="s1">maxMemoryCacheSize: nextConfig.cacheMaxMemorySize,</span><span class="s3">\n        </span><span class="s1">flushToDisk: nextConfig.experimental.isrFlushToDisk,</span><span class="s3">\n        </span><span class="s1">getPrerenderManifest: () =&gt; prerenderManifest,</span><span class="s3">\n        </span><span class="s1">CurCacheHandler: CacheHandler,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async onRequestError(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">err: unknown,</span><span class="s3">\n    </span><span class="s1">errorContext: RequestErrorContext,</span><span class="s3">\n    </span><span class="s1">routerServerContext?: RouterServerContext[string]</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (routerServerContext?.logErrorWithOriginalStack) {</span><span class="s3">\n      </span><span class="s1">routerServerContext.logErrorWithOriginalStack(err, 'app-dir')</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">console.error(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">await this.instrumentationOnRequestError(</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">path: req.url || '/',</span><span class="s3">\n        </span><span class="s1">headers: req.headers,</span><span class="s3">\n        </span><span class="s1">method: req.method || 'GET',</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">errorContext</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async prepare(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse | null,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">srcPage,</span><span class="s3">\n      </span><span class="s1">multiZoneDraftMode,</span><span class="s3">\n    </span><span class="s1">}: {</span><span class="s3">\n      </span><span class="s1">srcPage: string</span><span class="s3">\n      </span><span class="s1">multiZoneDraftMode?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;</span><span class="s3">\n    </span><span class="s1">| {</span><span class="s3">\n        </span><span class="s1">buildId: string</span><span class="s3">\n        </span><span class="s1">locale?: string</span><span class="s3">\n        </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n        </span><span class="s1">defaultLocale?: string</span><span class="s3">\n        </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n        </span><span class="s1">originalQuery: ParsedUrlQuery</span><span class="s3">\n        </span><span class="s1">originalPathname: string</span><span class="s3">\n        </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n        </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n        </span><span class="s1">previewData: PreviewData</span><span class="s3">\n        </span><span class="s1">pageIsDynamic: boolean</span><span class="s3">\n        </span><span class="s1">isDraftMode: boolean</span><span class="s3">\n        </span><span class="s1">resolvedPathname: string</span><span class="s3">\n        </span><span class="s1">isNextDataRequest: boolean</span><span class="s3">\n        </span><span class="s1">buildManifest: DeepReadonly&lt;BuildManifest&gt;</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest: DeepReadonly&lt;BuildManifest&gt;</span><span class="s3">\n        </span><span class="s1">nextFontManifest: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n        </span><span class="s1">serverFilesManifest: DeepReadonly&lt;RequiredServerFilesManifest&gt;</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest: DeepReadonly&lt;ReactLoadableManifest&gt;</span><span class="s3">\n        </span><span class="s1">routesManifest: DeepReadonly&lt;DevRoutesManifest&gt;</span><span class="s3">\n        </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n        </span><span class="s1">// we can't pull in the client reference type or it causes issues with</span><span class="s3">\n        </span><span class="s1">// our pre-compiled types</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest?: any</span><span class="s3">\n        </span><span class="s1">serverActionsManifest?: any</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest?: any</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest?: DeepReadonly&lt;Record&lt;string, string&gt;&gt;</span><span class="s3">\n        </span><span class="s1">isOnDemandRevalidate: boolean</span><span class="s3">\n        </span><span class="s1">revalidateOnlyGenerated: boolean</span><span class="s3">\n        </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n        </span><span class="s1">routerServerContext?: RouterServerContext[string]</span><span class="s3">\n        </span><span class="s1">interceptionRoutePatterns?: any</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">| undefined</span><span class="s3">\n  </span><span class="s1">&gt; {</span><span class="s3">\n    </span><span class="s1">let absoluteProjectDir: string | undefined</span><span class="s3">\n\n    </span><span class="s1">// edge runtime handles loading instrumentation at the edge adapter level</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">const { join, relative } =</span><span class="s3">\n        </span><span class="s1">require('node:path') as typeof import('node:path')</span><span class="s3">\n\n      </span><span class="s1">absoluteProjectDir = join(</span><span class="s3">\n        </span><span class="s1">process.cwd(),</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const absoluteDistDir = getRequestMeta(req, 'distDir')</span><span class="s3">\n\n      </span><span class="s1">if (absoluteDistDir) {</span><span class="s3">\n        </span><span class="s1">this.distDir = relative(absoluteProjectDir, absoluteDistDir)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { ensureInstrumentationRegistered } = await import(</span><span class="s3">\n        </span><span class="s1">'../lib/router-utils/instrumentation-globals.external.js'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// ensure instrumentation is registered and pass</span><span class="s3">\n      </span><span class="s1">// onRequestError below</span><span class="s3">\n      </span><span class="s1">ensureInstrumentationRegistered(absoluteProjectDir, this.distDir)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const manifests = await this.loadManifests(srcPage, absoluteProjectDir)</span><span class="s3">\n    </span><span class="s1">const { routesManifest, prerenderManifest, serverFilesManifest } = manifests</span><span class="s3">\n\n    </span><span class="s1">const { basePath, i18n, rewrites } = routesManifest</span><span class="s3">\n\n    </span><span class="s1">if (basePath) {</span><span class="s3">\n      </span><span class="s1">req.url = removePathPrefix(req.url || '/', basePath)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const parsedUrl = parseReqUrl(req.url || '/')</span><span class="s3">\n    </span><span class="s1">// if we couldn't parse the URL we can't continue</span><span class="s3">\n    </span><span class="s1">if (!parsedUrl) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let isNextDataRequest = false</span><span class="s3">\n\n    </span><span class="s1">if (pathHasPrefix(parsedUrl.pathname || '/', '/_next/data')) {</span><span class="s3">\n      </span><span class="s1">isNextDataRequest = true</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = normalizeDataPath(parsedUrl.pathname || '/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let originalPathname = parsedUrl.pathname || '/'</span><span class="s3">\n    </span><span class="s1">const originalQuery = { ...parsedUrl.query }</span><span class="s3">\n    </span><span class="s1">const pageIsDynamic = isDynamicRoute(srcPage)</span><span class="s3">\n\n    </span><span class="s1">let localeResult: PathLocale | undefined</span><span class="s3">\n    </span><span class="s1">let detectedLocale: string | undefined</span><span class="s3">\n\n    </span><span class="s1">if (i18n) {</span><span class="s3">\n      </span><span class="s1">localeResult = normalizeLocalePath(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '/',</span><span class="s3">\n        </span><span class="s1">i18n.locales</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (localeResult.detectedLocale) {</span><span class="s3">\n        </span><span class="s1">req.url = `${localeResult.pathname}${parsedUrl.search}`</span><span class="s3">\n        </span><span class="s1">originalPathname = localeResult.pathname</span><span class="s3">\n\n        </span><span class="s1">if (!detectedLocale) {</span><span class="s3">\n          </span><span class="s1">detectedLocale = localeResult.detectedLocale</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const serverUtils = getServerUtils({</span><span class="s3">\n      </span><span class="s1">page: srcPage,</span><span class="s3">\n      </span><span class="s1">i18n,</span><span class="s3">\n      </span><span class="s1">basePath,</span><span class="s3">\n      </span><span class="s1">rewrites,</span><span class="s3">\n      </span><span class="s1">pageIsDynamic,</span><span class="s3">\n      </span><span class="s1">trailingSlash: process.env.__NEXT_TRAILING_SLASH as any as boolean,</span><span class="s3">\n      </span><span class="s1">caseSensitive: Boolean(routesManifest.caseSensitive),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const domainLocale = detectDomainLocale(</span><span class="s3">\n      </span><span class="s1">i18n?.domains,</span><span class="s3">\n      </span><span class="s1">getHostname(parsedUrl, req.headers),</span><span class="s3">\n      </span><span class="s1">detectedLocale</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))</span><span class="s3">\n\n    </span><span class="s1">const defaultLocale = domainLocale?.defaultLocale || i18n?.defaultLocale</span><span class="s3">\n\n    </span><span class="s1">// Ensure parsedUrl.pathname includes locale before processing</span><span class="s3">\n    </span><span class="s1">// rewrites or they won't match correctly.</span><span class="s3">\n    </span><span class="s1">if (defaultLocale &amp;&amp; !detectedLocale) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname === '/' ? '' : parsedUrl.pathname}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const locale =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'locale') || detectedLocale || defaultLocale</span><span class="s3">\n\n    </span><span class="s1">const rewriteParamKeys = Object.keys(</span><span class="s3">\n      </span><span class="s1">serverUtils.handleRewrites(req, parsedUrl)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// after processing rewrites we want to remove locale</span><span class="s3">\n    </span><span class="s1">// from parsedUrl pathname</span><span class="s3">\n    </span><span class="s1">if (i18n) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = normalizeLocalePath(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '/',</span><span class="s3">\n        </span><span class="s1">i18n.locales</span><span class="s3">\n      </span><span class="s1">).pathname</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let params: Record&lt;string, undefined | string | string[]&gt; | undefined =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'params')</span><span class="s3">\n\n    </span><span class="s1">// attempt parsing from pathname</span><span class="s3">\n    </span><span class="s1">if (!params &amp;&amp; serverUtils.dynamicRouteMatcher) {</span><span class="s3">\n      </span><span class="s1">const paramsMatch = serverUtils.dynamicRouteMatcher(</span><span class="s3">\n        </span><span class="s1">normalizeDataPath(localeResult?.pathname || parsedUrl.pathname || '/')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const paramsResult = serverUtils.normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">paramsMatch || {},</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (paramsResult.hasValidParams) {</span><span class="s3">\n        </span><span class="s1">params = paramsResult.params</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Local </span><span class="s3">\&quot;</span><span class="s1">next start</span><span class="s3">\&quot; </span><span class="s1">expects the routing parsed query values</span><span class="s3">\n    </span><span class="s1">// to not be present in the URL although when deployed proxies</span><span class="s3">\n    </span><span class="s1">// will add query values from resolving the routes to pass to function.</span><span class="s3">\n\n    </span><span class="s1">// TODO: do we want to change expectations for </span><span class="s3">\&quot;</span><span class="s1">next start</span><span class="s3">\&quot;\n    </span><span class="s1">// to include these query values in the URL which affects asPath</span><span class="s3">\n    </span><span class="s1">// but would match deployed behavior, e.g. a rewrite from middleware</span><span class="s3">\n    </span><span class="s1">// that adds a query param would be in asPath as query but locally</span><span class="s3">\n    </span><span class="s1">// it won't be in the asPath but still available in the query object</span><span class="s3">\n    </span><span class="s1">const query = getRequestMeta(req, 'query') || {</span><span class="s3">\n      </span><span class="s1">...parsedUrl.query,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const routeParamKeys = new Set&lt;string&gt;()</span><span class="s3">\n    </span><span class="s1">const combinedParamKeys = []</span><span class="s3">\n\n    </span><span class="s1">// we don't include rewriteParamKeys in the combinedParamKeys</span><span class="s3">\n    </span><span class="s1">// for app router since the searchParams is populated from the</span><span class="s3">\n    </span><span class="s1">// URL so we don't want to strip the rewrite params from the URL</span><span class="s3">\n    </span><span class="s1">// so that searchParams can include them</span><span class="s3">\n    </span><span class="s1">if (!this.isAppRouter) {</span><span class="s3">\n      </span><span class="s1">for (const key of [</span><span class="s3">\n        </span><span class="s1">...rewriteParamKeys,</span><span class="s3">\n        </span><span class="s1">...Object.keys(serverUtils.defaultRouteMatches || {}),</span><span class="s3">\n      </span><span class="s1">]) {</span><span class="s3">\n        </span><span class="s1">// We only want to filter rewrite param keys from the URL</span><span class="s3">\n        </span><span class="s1">// if they are matches from the URL e.g. the key/value matches</span><span class="s3">\n        </span><span class="s1">// before and after applying the rewrites /:path for /hello and</span><span class="s3">\n        </span><span class="s1">// { path: 'hello' } but not for { path: 'another' } and /hello</span><span class="s3">\n        </span><span class="s1">// TODO: we should prefix rewrite param keys the same as we do</span><span class="s3">\n        </span><span class="s1">// for dynamic routes so we can identify them properly</span><span class="s3">\n        </span><span class="s1">const originalValue = Array.isArray(originalQuery[key])</span><span class="s3">\n          </span><span class="s1">? originalQuery[key].join('')</span><span class="s3">\n          </span><span class="s1">: originalQuery[key]</span><span class="s3">\n\n        </span><span class="s1">const queryValue = Array.isArray(query[key])</span><span class="s3">\n          </span><span class="s1">? query[key].join('')</span><span class="s3">\n          </span><span class="s1">: query[key]</span><span class="s3">\n\n        </span><span class="s1">if (!(key in originalQuery) || originalValue === queryValue) {</span><span class="s3">\n          </span><span class="s1">combinedParamKeys.push(key)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">serverUtils.normalizeCdnUrl(req, combinedParamKeys)</span><span class="s3">\n    </span><span class="s1">serverUtils.normalizeQueryParams(query, routeParamKeys)</span><span class="s3">\n    </span><span class="s1">serverUtils.filterInternalQuery(originalQuery, combinedParamKeys)</span><span class="s3">\n\n    </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n      </span><span class="s1">const queryResult = serverUtils.normalizeDynamicRouteParams(query, true)</span><span class="s3">\n\n      </span><span class="s1">const paramsResult = serverUtils.normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">params || {},</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const paramsToInterpolate: ParsedUrlQuery =</span><span class="s3">\n        </span><span class="s1">paramsResult.hasValidParams &amp;&amp; params</span><span class="s3">\n          </span><span class="s1">? params</span><span class="s3">\n          </span><span class="s1">: queryResult.hasValidParams</span><span class="s3">\n            </span><span class="s1">? query</span><span class="s3">\n            </span><span class="s1">: {}</span><span class="s3">\n\n      </span><span class="s1">req.url = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">req.url || '/',</span><span class="s3">\n        </span><span class="s1">paramsToInterpolate</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '/',</span><span class="s3">\n        </span><span class="s1">paramsToInterpolate</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">originalPathname = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">originalPathname,</span><span class="s3">\n        </span><span class="s1">paramsToInterpolate</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// try pulling from query if valid</span><span class="s3">\n      </span><span class="s1">if (!params) {</span><span class="s3">\n        </span><span class="s1">if (queryResult.hasValidParams) {</span><span class="s3">\n          </span><span class="s1">params = Object.assign({}, queryResult.params)</span><span class="s3">\n\n          </span><span class="s1">// If we pulled from query remove it so it's</span><span class="s3">\n          </span><span class="s1">// only in params</span><span class="s3">\n          </span><span class="s1">for (const key in serverUtils.defaultRouteMatches) {</span><span class="s3">\n            </span><span class="s1">delete query[key]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// use final params from URL matching</span><span class="s3">\n          </span><span class="s1">const paramsMatch = serverUtils.dynamicRouteMatcher?.(</span><span class="s3">\n            </span><span class="s1">normalizeDataPath(</span><span class="s3">\n              </span><span class="s1">localeResult?.pathname || parsedUrl.pathname || '/'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">// we don't normalize these as they are allowed to be</span><span class="s3">\n          </span><span class="s1">// the literal slug matches here e.g. /blog/[slug]</span><span class="s3">\n          </span><span class="s1">// actually being requested</span><span class="s3">\n          </span><span class="s1">if (paramsMatch) {</span><span class="s3">\n            </span><span class="s1">params = Object.assign({}, paramsMatch)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Remove any normalized params from the query if they</span><span class="s3">\n    </span><span class="s1">// weren't present as non-prefixed query key e.g.</span><span class="s3">\n    </span><span class="s1">// ?search=1&amp;nxtPsearch=hello we don't delete search</span><span class="s3">\n    </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n      </span><span class="s1">if (!(key in originalQuery)) {</span><span class="s3">\n        </span><span class="s1">delete query[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { isOnDemandRevalidate, revalidateOnlyGenerated } =</span><span class="s3">\n      </span><span class="s1">checkIsOnDemandRevalidate(req, prerenderManifest.preview)</span><span class="s3">\n\n    </span><span class="s1">let isDraftMode = false</span><span class="s3">\n    </span><span class="s1">let previewData: PreviewData</span><span class="s3">\n\n    </span><span class="s1">// preview data relies on non-edge utils</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge' &amp;&amp; res) {</span><span class="s3">\n      </span><span class="s1">const { tryGetPreviewData } =</span><span class="s3">\n        </span><span class="s1">require('../api-utils/node/try-get-preview-data') as typeof import('../api-utils/node/try-get-preview-data')</span><span class="s3">\n\n      </span><span class="s1">previewData = tryGetPreviewData(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">res,</span><span class="s3">\n        </span><span class="s1">prerenderManifest.preview,</span><span class="s3">\n        </span><span class="s1">Boolean(multiZoneDraftMode)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">isDraftMode = previewData !== false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const relativeProjectDir =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n\n    </span><span class="s1">const routerServerContext =</span><span class="s3">\n      </span><span class="s1">routerServerGlobal[RouterServerContextSymbol]?.[relativeProjectDir]</span><span class="s3">\n    </span><span class="s1">const nextConfig =</span><span class="s3">\n      </span><span class="s1">routerServerContext?.nextConfig || serverFilesManifest.config</span><span class="s3">\n\n    </span><span class="s1">const normalizedSrcPage = normalizeAppPath(srcPage)</span><span class="s3">\n    </span><span class="s1">let resolvedPathname =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'rewroteURL') || normalizedSrcPage</span><span class="s3">\n\n    </span><span class="s1">if (isDynamicRoute(resolvedPathname) &amp;&amp; params) {</span><span class="s3">\n      </span><span class="s1">resolvedPathname = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">resolvedPathname,</span><span class="s3">\n        </span><span class="s1">params</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (resolvedPathname === '/index') {</span><span class="s3">\n      </span><span class="s1">resolvedPathname = '/'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">resolvedPathname = decodePathParams(resolvedPathname)</span><span class="s3">\n    </span><span class="s1">} catch (_) {}</span><span class="s3">\n\n    </span><span class="s1">resolvedPathname = removeTrailingSlash(resolvedPathname)</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n      </span><span class="s1">originalQuery,</span><span class="s3">\n      </span><span class="s1">originalPathname,</span><span class="s3">\n      </span><span class="s1">params,</span><span class="s3">\n      </span><span class="s1">parsedUrl,</span><span class="s3">\n      </span><span class="s1">locale,</span><span class="s3">\n      </span><span class="s1">isNextDataRequest,</span><span class="s3">\n      </span><span class="s1">locales: i18n?.locales,</span><span class="s3">\n      </span><span class="s1">defaultLocale,</span><span class="s3">\n      </span><span class="s1">isDraftMode,</span><span class="s3">\n      </span><span class="s1">previewData,</span><span class="s3">\n      </span><span class="s1">pageIsDynamic,</span><span class="s3">\n      </span><span class="s1">resolvedPathname,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate,</span><span class="s3">\n      </span><span class="s1">revalidateOnlyGenerated,</span><span class="s3">\n      </span><span class="s1">...manifests,</span><span class="s3">\n      </span><span class="s1">serverActionsManifest: manifests.serverActionsManifest,</span><span class="s3">\n      </span><span class="s1">clientReferenceManifest: manifests.clientReferenceManifest,</span><span class="s3">\n      </span><span class="s1">nextConfig,</span><span class="s3">\n      </span><span class="s1">routerServerContext,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getResponseCache(req: IncomingMessage | BaseNextRequest) {</span><span class="s3">\n    </span><span class="s1">if (!this.responseCache) {</span><span class="s3">\n      </span><span class="s1">const minimalMode = getRequestMeta(req, 'minimalMode') ?? false</span><span class="s3">\n      </span><span class="s1">this.responseCache = new ResponseCache(minimalMode)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.responseCache</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async handleResponse({</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">nextConfig,</span><span class="s3">\n    </span><span class="s1">cacheKey,</span><span class="s3">\n    </span><span class="s1">routeKind,</span><span class="s3">\n    </span><span class="s1">isFallback,</span><span class="s3">\n    </span><span class="s1">prerenderManifest,</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n    </span><span class="s1">isOnDemandRevalidate,</span><span class="s3">\n    </span><span class="s1">revalidateOnlyGenerated,</span><span class="s3">\n    </span><span class="s1">responseGenerator,</span><span class="s3">\n    </span><span class="s1">waitUntil,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n    </span><span class="s1">cacheKey: string | null</span><span class="s3">\n    </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n    </span><span class="s1">isFallback?: boolean</span><span class="s3">\n    </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n    </span><span class="s1">revalidateOnlyGenerated?: boolean</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator</span><span class="s3">\n    </span><span class="s1">waitUntil?: (prom: Promise&lt;any&gt;) =&gt; void</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">const responseCache = this.getResponseCache(req)</span><span class="s3">\n    </span><span class="s1">const cacheEntry = await responseCache.get(cacheKey, responseGenerator, {</span><span class="s3">\n      </span><span class="s1">routeKind,</span><span class="s3">\n      </span><span class="s1">isFallback,</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate,</span><span class="s3">\n      </span><span class="s1">isPrefetch: req.headers.purpose === 'prefetch',</span><span class="s3">\n      </span><span class="s1">incrementalCache: await this.getIncrementalCache(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">nextConfig,</span><span class="s3">\n        </span><span class="s1">prerenderManifest</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">waitUntil,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (!cacheEntry) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">cacheKey &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// revalidate only generated can bail even if cacheKey is provided</span><span class="s3">\n        </span><span class="s1">!(isOnDemandRevalidate &amp;&amp; revalidateOnlyGenerated)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// A cache entry might not be generated if a response is written</span><span class="s3">\n        </span><span class="s1">// in `getInitialProps` or `getServerSideProps`, but those shouldn't</span><span class="s3">\n        </span><span class="s1">// have a cache key. If we do have a cache key but we don't end up</span><span class="s3">\n        </span><span class="s1">// with a cache entry, then either Next.js or the application has a</span><span class="s3">\n        </span><span class="s1">// bug that needs fixing.</span><span class="s3">\n        </span><span class="s1">throw new Error('invariant: cache entry required but not generated')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return cacheEntry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function isAppRouteRoute(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">return route.endsWith('/route')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* For a given page path, this function ensures that there is no backslash</span><span class="s3">\n </span><span class="s1">* escaping slashes in the path. Example:</span><span class="s3">\n </span><span class="s1">*  - `foo</span><span class="s3">\\</span><span class="s1">/bar</span><span class="s3">\\</span><span class="s1">/baz` -&gt; `foo/bar/baz`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizePathSep(path: string): string {</span><span class="s3">\n  </span><span class="s1">return path.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Key } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import { regexpToFunction } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A transformer function that will be applied to the regexp generated</span><span class="s3">\n   </span><span class="s1">* from the provided path and path-to-regexp.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">regexModifier?: (regex: string) =&gt; string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the function will remove all unnamed parameters</span><span class="s3">\n   </span><span class="s1">* from the matched parameters.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">removeUnnamedParams?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the regexp won't allow an optional trailing delimiter</span><span class="s3">\n   </span><span class="s1">* to match.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">strict?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the matcher will be case-sensitive, defaults to false</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">sensitive?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PatchMatcher = (</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">params?: Record&lt;string, any&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; Record&lt;string, any&gt; | false</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a path matcher function for a given path and options based on</span><span class="s3">\n </span><span class="s1">* path-to-regexp. By default the match will be case insensitive, non strict</span><span class="s3">\n </span><span class="s1">* and delimited by `/`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getPathMatch(path: string, options?: Options): PatchMatcher {</span><span class="s3">\n  </span><span class="s1">const keys: Key[] = []</span><span class="s3">\n  </span><span class="s1">const regexp = pathToRegexp(path, keys, {</span><span class="s3">\n    </span><span class="s1">delimiter: '/',</span><span class="s3">\n    </span><span class="s1">sensitive:</span><span class="s3">\n      </span><span class="s1">typeof options?.sensitive === 'boolean' ? options.sensitive : false,</span><span class="s3">\n    </span><span class="s1">strict: options?.strict,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const matcher = regexpToFunction&lt;Record&lt;string, any&gt;&gt;(</span><span class="s3">\n    </span><span class="s1">options?.regexModifier</span><span class="s3">\n      </span><span class="s1">? new RegExp(options.regexModifier(regexp.source), regexp.flags)</span><span class="s3">\n      </span><span class="s1">: regexp,</span><span class="s3">\n    </span><span class="s1">keys</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A matcher function that will check if a given pathname matches the path</span><span class="s3">\n   </span><span class="s1">* given in the builder function. When the path does not match it will return</span><span class="s3">\n   </span><span class="s1">* `false` but if it does it will return an object with the matched params</span><span class="s3">\n   </span><span class="s1">* merged with the params provided in the second argument.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">return (pathname, params) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If no pathname is provided it's not a match.</span><span class="s3">\n    </span><span class="s1">if (typeof pathname !== 'string') return false</span><span class="s3">\n\n    </span><span class="s1">const match = matcher(pathname)</span><span class="s3">\n\n    </span><span class="s1">// If the path did not match `false` will be returned.</span><span class="s3">\n    </span><span class="s1">if (!match) return false</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If unnamed params are not allowed they must be removed from</span><span class="s3">\n     </span><span class="s1">* the matched parameters. path-to-regexp uses </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">for named and</span><span class="s3">\n     </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">for unnamed parameters.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (options?.removeUnnamedParams) {</span><span class="s3">\n      </span><span class="s1">for (const key of keys) {</span><span class="s3">\n        </span><span class="s1">if (typeof key.name === 'number') {</span><span class="s3">\n          </span><span class="s1">delete match.params[key.name]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return { ...params, ...match.params }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextApiRequestCookies } from '.'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse cookies from the `headers` of request</span><span class="s3">\n </span><span class="s1">* @param req request object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function getCookieParser(headers: {</span><span class="s3">\n  </span><span class="s1">[key: string]: string | string[] | null | undefined</span><span class="s3">\n</span><span class="s1">}): () =&gt; NextApiRequestCookies {</span><span class="s3">\n  </span><span class="s1">return function parseCookie(): NextApiRequestCookies {</span><span class="s3">\n    </span><span class="s1">const { cookie } = headers</span><span class="s3">\n\n    </span><span class="s1">if (!cookie) {</span><span class="s3">\n      </span><span class="s1">return {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { parse: parseCookieFn } =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n    </span><span class="s1">return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isGroupSegment,</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n\n</span><span class="s1">const removeLeadingSlash = (segment: string): string =&gt; {</span><span class="s3">\n  </span><span class="s1">return segment[0] === '/' ? segment.slice(1) : segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const segmentToPathname = (segment: Segment): string =&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">// 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page</span><span class="s3">\n    </span><span class="s1">// if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.</span><span class="s3">\n    </span><span class="s1">if (segment === 'children') return ''</span><span class="s3">\n\n    </span><span class="s1">return segment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment[1]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function normalizeSegments(segments: string[]): string {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">segments.reduce((acc, segment) =&gt; {</span><span class="s3">\n      </span><span class="s1">segment = removeLeadingSlash(segment)</span><span class="s3">\n      </span><span class="s1">if (segment === '' || isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return acc</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${acc}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '') || '/'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractPathFromFlightRouterState(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">const segment = Array.isArray(flightRouterState[0])</span><span class="s3">\n    </span><span class="s1">? flightRouterState[0][1]</span><span class="s3">\n    </span><span class="s1">: flightRouterState[0]</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">segment === DEFAULT_SEGMENT_KEY ||</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some((m) =&gt; segment.startsWith(m))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n\n  </span><span class="s1">if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''</span><span class="s3">\n\n  </span><span class="s1">const segments = [segmentToPathname(segment)]</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = flightRouterState[1] ?? {}</span><span class="s3">\n\n  </span><span class="s1">const childrenPath = parallelRoutes.children</span><span class="s3">\n    </span><span class="s1">? extractPathFromFlightRouterState(parallelRoutes.children)</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">if (childrenPath !== undefined) {</span><span class="s3">\n    </span><span class="s1">segments.push(childrenPath)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of Object.entries(parallelRoutes)) {</span><span class="s3">\n      </span><span class="s1">if (key === 'children') continue</span><span class="s3">\n\n      </span><span class="s1">const childPath = extractPathFromFlightRouterState(value)</span><span class="s3">\n\n      </span><span class="s1">if (childPath !== undefined) {</span><span class="s3">\n        </span><span class="s1">segments.push(childPath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalizeSegments(segments)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeChangedPathImpl(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const [segmentA, parallelRoutesA] = treeA</span><span class="s3">\n  </span><span class="s1">const [segmentB, parallelRoutesB] = treeB</span><span class="s3">\n\n  </span><span class="s1">const normalizedSegmentA = segmentToPathname(segmentA)</span><span class="s3">\n  </span><span class="s1">const normalizedSegmentB = segmentToPathname(segmentB)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some(</span><span class="s3">\n      </span><span class="s1">(m) =&gt;</span><span class="s3">\n        </span><span class="s1">normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!matchSegment(segmentA, segmentB)) {</span><span class="s3">\n    </span><span class="s1">// once we find where the tree changed, we compute the rest of the path by traversing the tree</span><span class="s3">\n    </span><span class="s1">return extractPathFromFlightRouterState(treeB) ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRouterKey in parallelRoutesA) {</span><span class="s3">\n    </span><span class="s1">if (parallelRoutesB[parallelRouterKey]) {</span><span class="s3">\n      </span><span class="s1">const changedPath = computeChangedPathImpl(</span><span class="s3">\n        </span><span class="s1">parallelRoutesA[parallelRouterKey],</span><span class="s3">\n        </span><span class="s1">parallelRoutesB[parallelRouterKey]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (changedPath !== null) {</span><span class="s3">\n        </span><span class="s1">return `${segmentToPathname(segmentB)}/${changedPath}`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function computeChangedPath(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const changedPath = computeChangedPathImpl(treeA, treeB)</span><span class="s3">\n\n  </span><span class="s1">if (changedPath == null || changedPath === '/') {</span><span class="s3">\n    </span><span class="s1">return changedPath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// lightweight normalization to remove route groups</span><span class="s3">\n  </span><span class="s1">return normalizeSegments(changedPath.split('/'))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively extracts dynamic parameters from FlightRouterState.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSelectedParams(</span><span class="s3">\n  </span><span class="s1">currentTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">params: Params = {}</span><span class="s3">\n</span><span class="s1">): Params {</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = currentTree[1]</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRoute of Object.values(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">const segment = parallelRoute[0]</span><span class="s3">\n    </span><span class="s1">const isDynamicParameter = Array.isArray(segment)</span><span class="s3">\n    </span><span class="s1">const segmentValue = isDynamicParameter ? segment[1] : segment</span><span class="s3">\n    </span><span class="s1">if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue</span><span class="s3">\n\n    </span><span class="s1">// Ensure catchAll and optional catchall are turned into an array</span><span class="s3">\n    </span><span class="s1">const isCatchAll =</span><span class="s3">\n      </span><span class="s1">isDynamicParameter &amp;&amp; (segment[2] === 'c' || segment[2] === 'oc')</span><span class="s3">\n\n    </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1].split('/')</span><span class="s3">\n    </span><span class="s1">} else if (isDynamicParameter) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">params = getSelectedParams(parallelRoute, params)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { FlightRouterState } from './types'</span><span class="s3">\n</span><span class="s1">import { flightRouterStateSchema } from './types'</span><span class="s3">\n</span><span class="s1">import { assert } from 'next/dist/compiled/superstruct'</span><span class="s3">\n\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[]</span><span class="s3">\n</span><span class="s1">): FlightRouterState</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: undefined</span><span class="s3">\n</span><span class="s1">): undefined</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[] | undefined</span><span class="s3">\n</span><span class="s1">): FlightRouterState | undefined</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[] | undefined</span><span class="s3">\n</span><span class="s1">): FlightRouterState | undefined {</span><span class="s3">\n  </span><span class="s1">if (typeof stateHeader === 'undefined') {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(stateHeader)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Multiple router state headers were sent. This is not allowed.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We limit the size of the router state header to ~40kb. This is to prevent</span><span class="s3">\n  </span><span class="s1">// a malicious user from sending a very large header and slowing down the</span><span class="s3">\n  </span><span class="s1">// resolving of the router state.</span><span class="s3">\n  </span><span class="s1">// This is around 2,000 nested or parallel route segment states:</span><span class="s3">\n  </span><span class="s1">// '{</span><span class="s3">\&quot;</span><span class="s1">children</span><span class="s3">\&quot;</span><span class="s1">:[</span><span class="s3">\&quot;\&quot;</span><span class="s1">,{}]}'.length === 20.</span><span class="s3">\n  </span><span class="s1">if (stateHeader.length &gt; 20 * 2000) {</span><span class="s3">\n    </span><span class="s1">throw new Error('The router state header was too large.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const state = JSON.parse(decodeURIComponent(stateHeader))</span><span class="s3">\n    </span><span class="s1">assert(state, flightRouterStateSchema)</span><span class="s3">\n    </span><span class="s1">return state</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">throw new Error('The router state header was sent but could not be parsed.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">import { searchParamsToUrlQuery } from './querystring'</span><span class="s3">\n</span><span class="s1">import { parseRelativeUrl } from './parse-relative-url'</span><span class="s3">\n\n</span><span class="s1">export interface ParsedUrl {</span><span class="s3">\n  </span><span class="s1">hash: string</span><span class="s3">\n  </span><span class="s1">hostname?: string | null</span><span class="s3">\n  </span><span class="s1">href: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">port?: string | null</span><span class="s3">\n  </span><span class="s1">protocol?: string | null</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">search: string</span><span class="s3">\n  </span><span class="s1">slashes: boolean | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseUrl(url: string): ParsedUrl {</span><span class="s3">\n  </span><span class="s1">if (url.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">return parseRelativeUrl(url)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsedURL = new URL(url)</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">hash: parsedURL.hash,</span><span class="s3">\n    </span><span class="s1">hostname: parsedURL.hostname,</span><span class="s3">\n    </span><span class="s1">href: parsedURL.href,</span><span class="s3">\n    </span><span class="s1">pathname: parsedURL.pathname,</span><span class="s3">\n    </span><span class="s1">port: parsedURL.port,</span><span class="s3">\n    </span><span class="s1">protocol: parsedURL.protocol,</span><span class="s3">\n    </span><span class="s1">query: searchParamsToUrlQuery(parsedURL.searchParams),</span><span class="s3">\n    </span><span class="s1">search: parsedURL.search,</span><span class="s3">\n    </span><span class="s1">slashes:</span><span class="s3">\n      </span><span class="s1">parsedURL.href.slice(</span><span class="s3">\n        </span><span class="s1">parsedURL.protocol.length,</span><span class="s3">\n        </span><span class="s1">parsedURL.protocol.length + 2</span><span class="s3">\n      </span><span class="s1">) === '//',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import { getLocationOrigin } from '../../utils'</span><span class="s3">\n</span><span class="s1">import { searchParamsToUrlQuery } from './querystring'</span><span class="s3">\n\n</span><span class="s1">export interface ParsedRelativeUrl {</span><span class="s3">\n  </span><span class="s1">hash: string</span><span class="s3">\n  </span><span class="s1">href: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">search: string</span><span class="s3">\n  </span><span class="s1">slashes: undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative</span><span class="s3">\n </span><span class="s1">* (e.g. `./hello`) then at least base must be.</span><span class="s3">\n </span><span class="s1">* Absolute urls are rejected with one exception, in the browser, absolute urls that are on</span><span class="s3">\n </span><span class="s1">* the current origin will be parsed as relative</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base?: string,</span><span class="s3">\n  </span><span class="s1">parseQuery?: true</span><span class="s3">\n</span><span class="s1">): ParsedRelativeUrl</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base: string | undefined,</span><span class="s3">\n  </span><span class="s1">parseQuery: false</span><span class="s3">\n</span><span class="s1">): Omit&lt;ParsedRelativeUrl, 'query'&gt;</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base?: string,</span><span class="s3">\n  </span><span class="s1">parseQuery = true</span><span class="s3">\n</span><span class="s1">): ParsedRelativeUrl | Omit&lt;ParsedRelativeUrl, 'query'&gt; {</span><span class="s3">\n  </span><span class="s1">const globalBase = new URL(</span><span class="s3">\n    </span><span class="s1">typeof window === 'undefined' ? 'http://n' : getLocationOrigin()</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const resolvedBase = base</span><span class="s3">\n    </span><span class="s1">? new URL(base, globalBase)</span><span class="s3">\n    </span><span class="s1">: url.startsWith('.')</span><span class="s3">\n      </span><span class="s1">? new URL(</span><span class="s3">\n          </span><span class="s1">typeof window === 'undefined' ? 'http://n' : window.location.href</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: globalBase</span><span class="s3">\n\n  </span><span class="s1">const { pathname, searchParams, search, hash, href, origin } = new URL(</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">resolvedBase</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (origin !== globalBase.origin) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`invariant: invalid relative URL, router received ${url}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">query: parseQuery ? searchParamsToUrlQuery(searchParams) : undefined,</span><span class="s3">\n    </span><span class="s1">search,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">href: href.slice(origin.length),</span><span class="s3">\n    </span><span class="s1">// We don't know for relative URLs at this point since we set a custom, internal</span><span class="s3">\n    </span><span class="s1">// base that isn't surfaced to users.</span><span class="s3">\n    </span><span class="s1">slashes: undefined,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import escapePathDelimiters from '../../../shared/lib/router/utils/escape-path-delimiters'</span><span class="s3">\n</span><span class="s1">import { DecodeError } from '../../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We only encode path delimiters for path segments from</span><span class="s3">\n </span><span class="s1">* getStaticPaths so we need to attempt decoding the URL</span><span class="s3">\n </span><span class="s1">* to match against and only escape the path delimiters</span><span class="s3">\n </span><span class="s1">* this allows non-ascii values to be handled e.g.</span><span class="s3">\n </span><span class="s1">* Japanese characters.</span><span class="s3">\n </span><span class="s1">* */</span><span class="s3">\n</span><span class="s1">function decodePathParams(pathname: string): string {</span><span class="s3">\n  </span><span class="s1">// TODO: investigate adding this handling for non-SSG</span><span class="s3">\n  </span><span class="s1">// pages so non-ascii names also work there.</span><span class="s3">\n  </span><span class="s1">return pathname</span><span class="s3">\n    </span><span class="s1">.split('/')</span><span class="s3">\n    </span><span class="s1">.map((seg) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">seg = escapePathDelimiters(decodeURIComponent(seg), true)</span><span class="s3">\n      </span><span class="s1">} catch (_) {</span><span class="s3">\n        </span><span class="s1">// An improperly encoded URL was provided</span><span class="s3">\n        </span><span class="s1">throw new DecodeError('Failed to decode path param(s).')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return seg</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.join('/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { decodePathParams }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// escape delimiters used by path-to-regexp</span><span class="s3">\n</span><span class="s1">export default function escapePathDelimiters(</span><span class="s3">\n  </span><span class="s1">segment: string,</span><span class="s3">\n  </span><span class="s1">escapeEncoded?: boolean</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">return segment.replace(</span><span class="s3">\n    </span><span class="s1">new RegExp(`([/#?]${escapeEncoded ? '|%(2f|23|3f|5c)' : ''})`, 'gi'),</span><span class="s3">\n    </span><span class="s1">(char: string) =&gt; encodeURIComponent(char)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { RequestCookies } from '../cookies'</span><span class="s3">\n\n</span><span class="s1">import { ResponseCookies } from '../cookies'</span><span class="s3">\n</span><span class="s1">import { ReflectAdapter } from './reflect'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../../../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type { RequestStore } from '../../../app-render/work-unit-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ReadonlyRequestCookiesError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static callable() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyRequestCookiesError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We use this to type some APIs but we don't construct instances directly</span><span class="s3">\n</span><span class="s1">export type { ResponseCookies }</span><span class="s3">\n\n</span><span class="s1">// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,</span><span class="s3">\n</span><span class="s1">// we want to return the request cookie if it exists. For mutative methods like `.set()`,</span><span class="s3">\n</span><span class="s1">// we want to return the response cookie.</span><span class="s3">\n</span><span class="s1">export type ReadonlyRequestCookies = Omit&lt;</span><span class="s3">\n  </span><span class="s1">RequestCookies,</span><span class="s3">\n  </span><span class="s1">'set' | 'clear' | 'delete'</span><span class="s3">\n</span><span class="s1">&gt; &amp;</span><span class="s3">\n  </span><span class="s1">Pick&lt;ResponseCookies, 'set' | 'delete'&gt;</span><span class="s3">\n\n</span><span class="s1">export class RequestCookiesAdapter {</span><span class="s3">\n  </span><span class="s1">public static seal(cookies: RequestCookies): ReadonlyRequestCookies {</span><span class="s3">\n    </span><span class="s1">return new Proxy(cookies as any, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">switch (prop) {</span><span class="s3">\n          </span><span class="s1">case 'clear':</span><span class="s3">\n          </span><span class="s1">case 'delete':</span><span class="s3">\n          </span><span class="s1">case 'set':</span><span class="s3">\n            </span><span class="s1">return ReadonlyRequestCookiesError.callable</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')</span><span class="s3">\n\n</span><span class="s1">export function getModifiedCookieValues(</span><span class="s3">\n  </span><span class="s1">cookies: ResponseCookies</span><span class="s3">\n</span><span class="s1">): ResponseCookie[] {</span><span class="s3">\n  </span><span class="s1">const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[</span><span class="s3">\n    </span><span class="s1">SYMBOL_MODIFY_COOKIE_VALUES</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">if (!modified || !Array.isArray(modified) || modified.length === 0) {</span><span class="s3">\n    </span><span class="s1">return []</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return modified</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SetCookieArgs =</span><span class="s3">\n  </span><span class="s1">| [key: string, value: string, cookie?: Partial&lt;ResponseCookie&gt;]</span><span class="s3">\n  </span><span class="s1">| [options: ResponseCookie]</span><span class="s3">\n\n</span><span class="s1">export function appendMutableCookies(</span><span class="s3">\n  </span><span class="s1">headers: Headers,</span><span class="s3">\n  </span><span class="s1">mutableCookies: ResponseCookies</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const modifiedCookieValues = getModifiedCookieValues(mutableCookies)</span><span class="s3">\n  </span><span class="s1">if (modifiedCookieValues.length === 0) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Return a new response that extends the response with</span><span class="s3">\n  </span><span class="s1">// the modified cookies as fallbacks. `res` cookies</span><span class="s3">\n  </span><span class="s1">// will still take precedence.</span><span class="s3">\n  </span><span class="s1">const resCookies = new ResponseCookies(headers)</span><span class="s3">\n  </span><span class="s1">const returnedCookies = resCookies.getAll()</span><span class="s3">\n\n  </span><span class="s1">// Set the modified cookies as fallbacks.</span><span class="s3">\n  </span><span class="s1">for (const cookie of modifiedCookieValues) {</span><span class="s3">\n    </span><span class="s1">resCookies.set(cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Set the original cookies as the final values.</span><span class="s3">\n  </span><span class="s1">for (const cookie of returnedCookies) {</span><span class="s3">\n    </span><span class="s1">resCookies.set(cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ResponseCookie = NonNullable&lt;</span><span class="s3">\n  </span><span class="s1">ReturnType&lt;InstanceType&lt;typeof ResponseCookies&gt;['get']&gt;</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export class MutableRequestCookiesAdapter {</span><span class="s3">\n  </span><span class="s1">public static wrap(</span><span class="s3">\n    </span><span class="s1">cookies: RequestCookies,</span><span class="s3">\n    </span><span class="s1">onUpdateCookies?: (cookies: string[]) =&gt; void</span><span class="s3">\n  </span><span class="s1">): ResponseCookies {</span><span class="s3">\n    </span><span class="s1">const responseCookies = new ResponseCookies(new Headers())</span><span class="s3">\n    </span><span class="s1">for (const cookie of cookies.getAll()) {</span><span class="s3">\n      </span><span class="s1">responseCookies.set(cookie)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let modifiedValues: ResponseCookie[] = []</span><span class="s3">\n    </span><span class="s1">const modifiedCookies = new Set&lt;string&gt;()</span><span class="s3">\n    </span><span class="s1">const updateResponseCookies = () =&gt; {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: change method of getting workStore</span><span class="s3">\n      </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">if (workStore) {</span><span class="s3">\n        </span><span class="s1">workStore.pathWasRevalidated = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const allCookies = responseCookies.getAll()</span><span class="s3">\n      </span><span class="s1">modifiedValues = allCookies.filter((c) =&gt; modifiedCookies.has(c.name))</span><span class="s3">\n      </span><span class="s1">if (onUpdateCookies) {</span><span class="s3">\n        </span><span class="s1">const serializedCookies: string[] = []</span><span class="s3">\n        </span><span class="s1">for (const cookie of modifiedValues) {</span><span class="s3">\n          </span><span class="s1">const tempCookies = new ResponseCookies(new Headers())</span><span class="s3">\n          </span><span class="s1">tempCookies.set(cookie)</span><span class="s3">\n          </span><span class="s1">serializedCookies.push(tempCookies.toString())</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">onUpdateCookies(serializedCookies)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const wrappedCookies = new Proxy(responseCookies, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">switch (prop) {</span><span class="s3">\n          </span><span class="s1">// A special symbol to get the modified cookie values</span><span class="s3">\n          </span><span class="s1">case SYMBOL_MODIFY_COOKIE_VALUES:</span><span class="s3">\n            </span><span class="s1">return modifiedValues</span><span class="s3">\n\n          </span><span class="s1">// TODO: Throw error if trying to set a cookie after the response</span><span class="s3">\n          </span><span class="s1">// headers have been set.</span><span class="s3">\n          </span><span class="s1">case 'delete':</span><span class="s3">\n            </span><span class="s1">return function (...args: [string] | [ResponseCookie]) {</span><span class="s3">\n              </span><span class="s1">modifiedCookies.add(</span><span class="s3">\n                </span><span class="s1">typeof args[0] === 'string' ? args[0] : args[0].name</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">target.delete(...args)</span><span class="s3">\n                </span><span class="s1">return wrappedCookies</span><span class="s3">\n              </span><span class="s1">} finally {</span><span class="s3">\n                </span><span class="s1">updateResponseCookies()</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case 'set':</span><span class="s3">\n            </span><span class="s1">return function (...args: SetCookieArgs) {</span><span class="s3">\n              </span><span class="s1">modifiedCookies.add(</span><span class="s3">\n                </span><span class="s1">typeof args[0] === 'string' ? args[0] : args[0].name</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">target.set(...args)</span><span class="s3">\n                </span><span class="s1">return wrappedCookies</span><span class="s3">\n              </span><span class="s1">} finally {</span><span class="s3">\n                </span><span class="s1">updateResponseCookies()</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">return wrappedCookies</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createCookiesWithMutableAccessCheck(</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore</span><span class="s3">\n</span><span class="s1">): ResponseCookies {</span><span class="s3">\n  </span><span class="s1">const wrappedCookies = new Proxy(requestStore.mutableCookies, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">switch (prop) {</span><span class="s3">\n        </span><span class="s1">case 'delete':</span><span class="s3">\n          </span><span class="s1">return function (...args: [string] | [ResponseCookie]) {</span><span class="s3">\n            </span><span class="s1">ensureCookiesAreStillMutable(requestStore, 'cookies().delete')</span><span class="s3">\n            </span><span class="s1">target.delete(...args)</span><span class="s3">\n            </span><span class="s1">return wrappedCookies</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'set':</span><span class="s3">\n          </span><span class="s1">return function (...args: SetCookieArgs) {</span><span class="s3">\n            </span><span class="s1">ensureCookiesAreStillMutable(requestStore, 'cookies().set')</span><span class="s3">\n            </span><span class="s1">target.set(...args)</span><span class="s3">\n            </span><span class="s1">return wrappedCookies</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return wrappedCookies</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {</span><span class="s3">\n  </span><span class="s1">return requestStore.phase === 'action'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Ensure that cookies() starts throwing on mutation</span><span class="s3">\n </span><span class="s1">* if we changed phases and can no longer mutate.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This can happen when going:</span><span class="s3">\n </span><span class="s1">*   'render' -&gt; 'after'</span><span class="s3">\n </span><span class="s1">*   'action' -&gt; 'render'</span><span class="s3">\n </span><span class="s1">* */</span><span class="s3">\n</span><span class="s1">function ensureCookiesAreStillMutable(</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore,</span><span class="s3">\n  </span><span class="s1">_callingExpression: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!areCookiesMutableInCurrentPhase(requestStore)) {</span><span class="s3">\n    </span><span class="s1">// TODO: maybe we can give a more precise error message based on callingExpression?</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyRequestCookiesError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function responseCookiesToRequestCookies(</span><span class="s3">\n  </span><span class="s1">responseCookies: ResponseCookies</span><span class="s3">\n</span><span class="s1">): RequestCookies {</span><span class="s3">\n  </span><span class="s1">const requestCookies = new RequestCookies(new Headers())</span><span class="s3">\n  </span><span class="s1">for (const cookie of responseCookies.getAll()) {</span><span class="s3">\n    </span><span class="s1">requestCookies.set(cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return requestCookies</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'</span><span class="s3">\n</span><span class="s1">import type { ResponseCookies } from '../web/spec-extension/cookies'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { NextRequest } from '../web/spec-extension/request'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">COOKIE_NAME_PRERENDER_BYPASS,</span><span class="s3">\n  </span><span class="s1">checkIsOnDemandRevalidate,</span><span class="s3">\n</span><span class="s1">} from '../api-utils'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../api-utils'</span><span class="s3">\n\n</span><span class="s1">export class DraftModeProvider {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @internal - this declaration is stripped via `tsc --stripInternal`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private _isEnabled: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @internal - this declaration is stripped via `tsc --stripInternal`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly _previewModeId: string | undefined</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @internal - this declaration is stripped via `tsc --stripInternal`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly _mutableCookies: ResponseCookies</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">previewProps: __ApiPreviewProps | undefined,</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest&lt;unknown&gt; | NextRequest,</span><span class="s3">\n    </span><span class="s1">cookies: ReadonlyRequestCookies,</span><span class="s3">\n    </span><span class="s1">mutableCookies: ResponseCookies</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// The logic for draftMode() is very similar to tryGetPreviewData()</span><span class="s3">\n    </span><span class="s1">// but Draft Mode does not have any data associated with it.</span><span class="s3">\n    </span><span class="s1">const isOnDemandRevalidate =</span><span class="s3">\n      </span><span class="s1">previewProps &amp;&amp;</span><span class="s3">\n      </span><span class="s1">checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate</span><span class="s3">\n\n    </span><span class="s1">const cookieValue = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value</span><span class="s3">\n\n    </span><span class="s1">this._isEnabled = Boolean(</span><span class="s3">\n      </span><span class="s1">!isOnDemandRevalidate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">cookieValue &amp;&amp;</span><span class="s3">\n        </span><span class="s1">previewProps &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(cookieValue === previewProps.previewModeId ||</span><span class="s3">\n          </span><span class="s1">// In dev mode, the cookie can be actual hash value preview id but the preview props can still be `development-id`.</span><span class="s3">\n          </span><span class="s1">(process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">previewProps.previewModeId === 'development-id'))</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">this._previewModeId = previewProps?.previewModeId</span><span class="s3">\n    </span><span class="s1">this._mutableCookies = mutableCookies</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get isEnabled() {</span><span class="s3">\n    </span><span class="s1">return this._isEnabled</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">enable() {</span><span class="s3">\n    </span><span class="s1">if (!this._previewModeId) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Invariant: previewProps missing previewModeId this should never happen'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._mutableCookies.set({</span><span class="s3">\n      </span><span class="s1">name: COOKIE_NAME_PRERENDER_BYPASS,</span><span class="s3">\n      </span><span class="s1">value: this._previewModeId,</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">this._isEnabled = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">disable() {</span><span class="s3">\n    </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n    </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n    </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n    </span><span class="s1">this._mutableCookies.set({</span><span class="s3">\n      </span><span class="s1">name: COOKIE_NAME_PRERENDER_BYPASS,</span><span class="s3">\n      </span><span class="s1">value: '',</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">expires: new Date(0),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">this._isEnabled = false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { BaseNextRequest, BaseNextResponse } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { IncomingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type { RequestStore } from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type { RenderOpts } from '../app-render/types'</span><span class="s3">\n</span><span class="s1">import type { NextRequest } from '../web/spec-extension/request'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../api-utils'</span><span class="s3">\n\n</span><span class="s1">import { FLIGHT_HEADERS } from '../../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">HeadersAdapter,</span><span class="s3">\n  </span><span class="s1">type ReadonlyHeaders,</span><span class="s3">\n</span><span class="s1">} from '../web/spec-extension/adapters/headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">MutableRequestCookiesAdapter,</span><span class="s3">\n  </span><span class="s1">RequestCookiesAdapter,</span><span class="s3">\n  </span><span class="s1">responseCookiesToRequestCookies,</span><span class="s3">\n  </span><span class="s1">createCookiesWithMutableAccessCheck,</span><span class="s3">\n  </span><span class="s1">type ReadonlyRequestCookies,</span><span class="s3">\n</span><span class="s1">} from '../web/spec-extension/adapters/request-cookies'</span><span class="s3">\n</span><span class="s1">import { ResponseCookies, RequestCookies } from '../web/spec-extension/cookies'</span><span class="s3">\n</span><span class="s1">import { DraftModeProvider } from './draft-mode-provider'</span><span class="s3">\n</span><span class="s1">import { splitCookiesString } from '../web/utils'</span><span class="s3">\n</span><span class="s1">import type { ServerComponentsHmrCache } from '../response-cache'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../request/params'</span><span class="s3">\n</span><span class="s1">import type { ImplicitTags } from '../lib/implicit-tags'</span><span class="s3">\n</span><span class="s1">import type { FallbackRouteParams } from '../request/fallback-params'</span><span class="s3">\n\n</span><span class="s1">function getHeaders(headers: Headers | IncomingHttpHeaders): ReadonlyHeaders {</span><span class="s3">\n  </span><span class="s1">const cleaned = HeadersAdapter.from(headers)</span><span class="s3">\n  </span><span class="s1">for (const header of FLIGHT_HEADERS) {</span><span class="s3">\n    </span><span class="s1">cleaned.delete(header)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return HeadersAdapter.seal(cleaned)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getMutableCookies(</span><span class="s3">\n  </span><span class="s1">headers: Headers | IncomingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">onUpdateCookies?: (cookies: string[]) =&gt; void</span><span class="s3">\n</span><span class="s1">): ResponseCookies {</span><span class="s3">\n  </span><span class="s1">const cookies = new RequestCookies(HeadersAdapter.from(headers))</span><span class="s3">\n  </span><span class="s1">return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type WrapperRenderOpts = Partial&lt;Pick&lt;RenderOpts, 'onUpdateCookies'&gt;&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">previewProps?: __ApiPreviewProps</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RequestContext = RequestResponsePair &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The URL of the request. This only specifies the pathname and the search</span><span class="s3">\n   </span><span class="s1">* part of the URL. This is only undefined when generating static paths (ie,</span><span class="s3">\n   </span><span class="s1">* there is no request in progress, nor do we know one).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">url: {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The pathname of the requested URL.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">pathname: string</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The search part of the requested URL. If the request did not provide a</span><span class="s3">\n     </span><span class="s1">* search part, this will be an empty string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">search?: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">phase: RequestStore['phase']</span><span class="s3">\n  </span><span class="s1">renderOpts?: WrapperRenderOpts</span><span class="s3">\n  </span><span class="s1">isHmrRefresh?: boolean</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache?: ServerComponentsHmrCache</span><span class="s3">\n  </span><span class="s1">implicitTags: ImplicitTags</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RequestResponsePair =</span><span class="s3">\n  </span><span class="s1">| { req: BaseNextRequest; res: BaseNextResponse } // for an app page</span><span class="s3">\n  </span><span class="s1">| { req: NextRequest; res: undefined } // in an api route or middleware</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* If middleware set cookies in this request (indicated by `x-middleware-set-cookie`),</span><span class="s3">\n </span><span class="s1">* then merge those into the existing cookie object, so that when `cookies()` is accessed</span><span class="s3">\n </span><span class="s1">* it's able to read the newly set cookies.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mergeMiddlewareCookies(</span><span class="s3">\n  </span><span class="s1">req: RequestContext['req'],</span><span class="s3">\n  </span><span class="s1">existingCookies: RequestCookies | ResponseCookies</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">'x-middleware-set-cookie' in req.headers &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof req.headers['x-middleware-set-cookie'] === 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const setCookieValue = req.headers['x-middleware-set-cookie']</span><span class="s3">\n    </span><span class="s1">const responseHeaders = new Headers()</span><span class="s3">\n\n    </span><span class="s1">for (const cookie of splitCookiesString(setCookieValue)) {</span><span class="s3">\n      </span><span class="s1">responseHeaders.append('set-cookie', cookie)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const responseCookies = new ResponseCookies(responseHeaders)</span><span class="s3">\n\n    </span><span class="s1">// Transfer cookies from ResponseCookies to RequestCookies</span><span class="s3">\n    </span><span class="s1">for (const cookie of responseCookies.getAll()) {</span><span class="s3">\n      </span><span class="s1">existingCookies.set(cookie)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createRequestStoreForRender(</span><span class="s3">\n  </span><span class="s1">req: RequestContext['req'],</span><span class="s3">\n  </span><span class="s1">res: RequestContext['res'],</span><span class="s3">\n  </span><span class="s1">url: RequestContext['url'],</span><span class="s3">\n  </span><span class="s1">rootParams: Params,</span><span class="s3">\n  </span><span class="s1">implicitTags: RequestContext['implicitTags'],</span><span class="s3">\n  </span><span class="s1">onUpdateCookies: RenderOpts['onUpdateCookies'],</span><span class="s3">\n  </span><span class="s1">previewProps: WrapperRenderOpts['previewProps'],</span><span class="s3">\n  </span><span class="s1">isHmrRefresh: RequestContext['isHmrRefresh'],</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache: RenderResumeDataCache | undefined,</span><span class="s3">\n  </span><span class="s1">devFallbackParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">): RequestStore {</span><span class="s3">\n  </span><span class="s1">return createRequestStoreImpl(</span><span class="s3">\n    </span><span class="s1">// Pages start in render phase by default</span><span class="s3">\n    </span><span class="s1">'render',</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">res,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">onUpdateCookies,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">previewProps,</span><span class="s3">\n    </span><span class="s1">isHmrRefresh,</span><span class="s3">\n    </span><span class="s1">serverComponentsHmrCache,</span><span class="s3">\n    </span><span class="s1">devFallbackParams</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createRequestStoreForAPI(</span><span class="s3">\n  </span><span class="s1">req: RequestContext['req'],</span><span class="s3">\n  </span><span class="s1">url: RequestContext['url'],</span><span class="s3">\n  </span><span class="s1">implicitTags: RequestContext['implicitTags'],</span><span class="s3">\n  </span><span class="s1">onUpdateCookies: RenderOpts['onUpdateCookies'],</span><span class="s3">\n  </span><span class="s1">previewProps: WrapperRenderOpts['previewProps']</span><span class="s3">\n</span><span class="s1">): RequestStore {</span><span class="s3">\n  </span><span class="s1">return createRequestStoreImpl(</span><span class="s3">\n    </span><span class="s1">// API routes start in action phase by default</span><span class="s3">\n    </span><span class="s1">'action',</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">undefined,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">{},</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">onUpdateCookies,</span><span class="s3">\n    </span><span class="s1">undefined,</span><span class="s3">\n    </span><span class="s1">previewProps,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">undefined,</span><span class="s3">\n    </span><span class="s1">null</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createRequestStoreImpl(</span><span class="s3">\n  </span><span class="s1">phase: RequestStore['phase'],</span><span class="s3">\n  </span><span class="s1">req: RequestContext['req'],</span><span class="s3">\n  </span><span class="s1">res: RequestContext['res'],</span><span class="s3">\n  </span><span class="s1">url: RequestContext['url'],</span><span class="s3">\n  </span><span class="s1">rootParams: Params,</span><span class="s3">\n  </span><span class="s1">implicitTags: RequestContext['implicitTags'],</span><span class="s3">\n  </span><span class="s1">onUpdateCookies: RenderOpts['onUpdateCookies'],</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache: RenderResumeDataCache | undefined,</span><span class="s3">\n  </span><span class="s1">previewProps: WrapperRenderOpts['previewProps'],</span><span class="s3">\n  </span><span class="s1">isHmrRefresh: RequestContext['isHmrRefresh'],</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],</span><span class="s3">\n  </span><span class="s1">devFallbackParams: FallbackRouteParams | null | undefined</span><span class="s3">\n</span><span class="s1">): RequestStore {</span><span class="s3">\n  </span><span class="s1">function defaultOnUpdateCookies(cookies: string[]) {</span><span class="s3">\n    </span><span class="s1">if (res) {</span><span class="s3">\n      </span><span class="s1">res.setHeader('Set-Cookie', cookies)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const cache: {</span><span class="s3">\n    </span><span class="s1">headers?: ReadonlyHeaders</span><span class="s3">\n    </span><span class="s1">cookies?: ReadonlyRequestCookies</span><span class="s3">\n    </span><span class="s1">mutableCookies?: ResponseCookies</span><span class="s3">\n    </span><span class="s1">userspaceMutableCookies?: ResponseCookies</span><span class="s3">\n    </span><span class="s1">draftMode?: DraftModeProvider</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: 'request',</span><span class="s3">\n    </span><span class="s1">phase,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">// Rather than just using the whole `url` here, we pull the parts we want</span><span class="s3">\n    </span><span class="s1">// to ensure we don't use parts of the URL that we shouldn't. This also</span><span class="s3">\n    </span><span class="s1">// lets us avoid requiring an empty string for `search` in the type.</span><span class="s3">\n    </span><span class="s1">url: { pathname: url.pathname, search: url.search ?? '' },</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">get headers() {</span><span class="s3">\n      </span><span class="s1">if (!cache.headers) {</span><span class="s3">\n        </span><span class="s1">// Seal the headers object that'll freeze out any methods that could</span><span class="s3">\n        </span><span class="s1">// mutate the underlying data.</span><span class="s3">\n        </span><span class="s1">cache.headers = getHeaders(req.headers)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return cache.headers</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">get cookies() {</span><span class="s3">\n      </span><span class="s1">if (!cache.cookies) {</span><span class="s3">\n        </span><span class="s1">// if middleware is setting cookie(s), then include those in</span><span class="s3">\n        </span><span class="s1">// the initial cached cookies so they can be read in render</span><span class="s3">\n        </span><span class="s1">const requestCookies = new RequestCookies(</span><span class="s3">\n          </span><span class="s1">HeadersAdapter.from(req.headers)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">mergeMiddlewareCookies(req, requestCookies)</span><span class="s3">\n\n        </span><span class="s1">// Seal the cookies object that'll freeze out any methods that could</span><span class="s3">\n        </span><span class="s1">// mutate the underlying data.</span><span class="s3">\n        </span><span class="s1">cache.cookies = RequestCookiesAdapter.seal(requestCookies)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return cache.cookies</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set cookies(value: ReadonlyRequestCookies) {</span><span class="s3">\n      </span><span class="s1">cache.cookies = value</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">get mutableCookies() {</span><span class="s3">\n      </span><span class="s1">if (!cache.mutableCookies) {</span><span class="s3">\n        </span><span class="s1">const mutableCookies = getMutableCookies(</span><span class="s3">\n          </span><span class="s1">req.headers,</span><span class="s3">\n          </span><span class="s1">onUpdateCookies || (res ? defaultOnUpdateCookies : undefined)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">mergeMiddlewareCookies(req, mutableCookies)</span><span class="s3">\n\n        </span><span class="s1">cache.mutableCookies = mutableCookies</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return cache.mutableCookies</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">get userspaceMutableCookies() {</span><span class="s3">\n      </span><span class="s1">if (!cache.userspaceMutableCookies) {</span><span class="s3">\n        </span><span class="s1">const userspaceMutableCookies =</span><span class="s3">\n          </span><span class="s1">createCookiesWithMutableAccessCheck(this)</span><span class="s3">\n        </span><span class="s1">cache.userspaceMutableCookies = userspaceMutableCookies</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return cache.userspaceMutableCookies</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">get draftMode() {</span><span class="s3">\n      </span><span class="s1">if (!cache.draftMode) {</span><span class="s3">\n        </span><span class="s1">cache.draftMode = new DraftModeProvider(</span><span class="s3">\n          </span><span class="s1">previewProps,</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">this.cookies,</span><span class="s3">\n          </span><span class="s1">this.mutableCookies</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return cache.draftMode</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache: renderResumeDataCache ?? null,</span><span class="s3">\n    </span><span class="s1">isHmrRefresh,</span><span class="s3">\n    </span><span class="s1">serverComponentsHmrCache:</span><span class="s3">\n      </span><span class="s1">serverComponentsHmrCache ||</span><span class="s3">\n      </span><span class="s1">(globalThis as any).__serverComponentsHmrCache,</span><span class="s3">\n    </span><span class="s1">devFallbackParams,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function synchronizeMutableCookies(store: RequestStore) {</span><span class="s3">\n  </span><span class="s1">// TODO: does this need to update headers as well?</span><span class="s3">\n  </span><span class="s1">store.cookies = RequestCookiesAdapter.seal(</span><span class="s3">\n    </span><span class="s1">responseCookiesToRequestCookies(store.mutableCookies)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { WorkStore } from './app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type { IncrementalCache } from './lib/incremental-cache'</span><span class="s3">\n</span><span class="s1">import { getCacheHandlers } from './use-cache/handlers'</span><span class="s3">\n\n</span><span class="s1">/** Run a callback, and execute any *new* revalidations added during its runtime. */</span><span class="s3">\n</span><span class="s1">export async function withExecuteRevalidates&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">store: WorkStore | undefined,</span><span class="s3">\n  </span><span class="s1">callback: () =&gt; Promise&lt;T&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (!store) {</span><span class="s3">\n    </span><span class="s1">return callback()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// If we executed any revalidates during the request, then we don't want to execute them again.</span><span class="s3">\n  </span><span class="s1">// save the state so we can check if anything changed after we're done running callbacks.</span><span class="s3">\n  </span><span class="s1">const savedRevalidationState = cloneRevalidationState(store)</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return await callback()</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">// Check if we have any new revalidates, and if so, wait until they are all resolved.</span><span class="s3">\n    </span><span class="s1">const newRevalidates = diffRevalidationState(</span><span class="s3">\n      </span><span class="s1">savedRevalidationState,</span><span class="s3">\n      </span><span class="s1">cloneRevalidationState(store)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">await executeRevalidates(store, newRevalidates)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RevalidationState = Required&lt;</span><span class="s3">\n  </span><span class="s1">Pick&lt;</span><span class="s3">\n    </span><span class="s1">WorkStore,</span><span class="s3">\n    </span><span class="s1">'pendingRevalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'</span><span class="s3">\n  </span><span class="s1">&gt;</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">function cloneRevalidationState(store: WorkStore): RevalidationState {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">pendingRevalidatedTags: store.pendingRevalidatedTags</span><span class="s3">\n      </span><span class="s1">? [...store.pendingRevalidatedTags]</span><span class="s3">\n      </span><span class="s1">: [],</span><span class="s3">\n    </span><span class="s1">pendingRevalidates: { ...store.pendingRevalidates },</span><span class="s3">\n    </span><span class="s1">pendingRevalidateWrites: store.pendingRevalidateWrites</span><span class="s3">\n      </span><span class="s1">? [...store.pendingRevalidateWrites]</span><span class="s3">\n      </span><span class="s1">: [],</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function diffRevalidationState(</span><span class="s3">\n  </span><span class="s1">prev: RevalidationState,</span><span class="s3">\n  </span><span class="s1">curr: RevalidationState</span><span class="s3">\n</span><span class="s1">): RevalidationState {</span><span class="s3">\n  </span><span class="s1">const prevTags = new Set(prev.pendingRevalidatedTags)</span><span class="s3">\n  </span><span class="s1">const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites)</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">pendingRevalidatedTags: curr.pendingRevalidatedTags.filter(</span><span class="s3">\n      </span><span class="s1">(tag) =&gt; !prevTags.has(tag)</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">pendingRevalidates: Object.fromEntries(</span><span class="s3">\n      </span><span class="s1">Object.entries(curr.pendingRevalidates).filter(</span><span class="s3">\n        </span><span class="s1">([key]) =&gt; !(key in prev.pendingRevalidates)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">pendingRevalidateWrites: curr.pendingRevalidateWrites.filter(</span><span class="s3">\n      </span><span class="s1">(promise) =&gt; !prevRevalidateWrites.has(promise)</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function revalidateTags(</span><span class="s3">\n  </span><span class="s1">tags: string[],</span><span class="s3">\n  </span><span class="s1">incrementalCache: IncrementalCache | undefined</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">if (tags.length === 0) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promises: Promise&lt;void&gt;[] = []</span><span class="s3">\n\n  </span><span class="s1">if (incrementalCache) {</span><span class="s3">\n    </span><span class="s1">promises.push(incrementalCache.revalidateTag(tags))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const handlers = getCacheHandlers()</span><span class="s3">\n  </span><span class="s1">if (handlers) {</span><span class="s3">\n    </span><span class="s1">for (const handler of handlers) {</span><span class="s3">\n      </span><span class="s1">promises.push(handler.expireTags(...tags))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">await Promise.all(promises)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function executeRevalidates(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">state?: RevalidationState</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const pendingRevalidatedTags =</span><span class="s3">\n    </span><span class="s1">state?.pendingRevalidatedTags ?? workStore.pendingRevalidatedTags ?? []</span><span class="s3">\n\n  </span><span class="s1">const pendingRevalidates =</span><span class="s3">\n    </span><span class="s1">state?.pendingRevalidates ?? workStore.pendingRevalidates ?? {}</span><span class="s3">\n\n  </span><span class="s1">const pendingRevalidateWrites =</span><span class="s3">\n    </span><span class="s1">state?.pendingRevalidateWrites ?? workStore.pendingRevalidateWrites ?? []</span><span class="s3">\n\n  </span><span class="s1">return Promise.all([</span><span class="s3">\n    </span><span class="s1">revalidateTags(pendingRevalidatedTags, workStore.incrementalCache),</span><span class="s3">\n    </span><span class="s1">...Object.values(pendingRevalidates),</span><span class="s3">\n    </span><span class="s1">...pendingRevalidateWrites,</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AsyncLocalStorage } from 'async_hooks'</span><span class="s3">\n\n</span><span class="s1">const sharedAsyncLocalStorageNotAvailableError = new Error(</span><span class="s3">\n  </span><span class="s1">'Invariant: AsyncLocalStorage accessed in runtime where it is not available'</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">class FakeAsyncLocalStorage&lt;Store extends {}&gt;</span><span class="s3">\n  </span><span class="s1">implements AsyncLocalStorage&lt;Store&gt;</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">disable(): void {</span><span class="s3">\n    </span><span class="s1">throw sharedAsyncLocalStorageNotAvailableError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getStore(): Store | undefined {</span><span class="s3">\n    </span><span class="s1">// This fake implementation of AsyncLocalStorage always returns `undefined`.</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">run&lt;R&gt;(): R {</span><span class="s3">\n    </span><span class="s1">throw sharedAsyncLocalStorageNotAvailableError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">exit&lt;R&gt;(): R {</span><span class="s3">\n    </span><span class="s1">throw sharedAsyncLocalStorageNotAvailableError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">enterWith(): void {</span><span class="s3">\n    </span><span class="s1">throw sharedAsyncLocalStorageNotAvailableError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static bind&lt;T&gt;(fn: T): T {</span><span class="s3">\n    </span><span class="s1">return fn</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const maybeGlobalAsyncLocalStorage =</span><span class="s3">\n  </span><span class="s1">typeof globalThis !== 'undefined' &amp;&amp; (globalThis as any).AsyncLocalStorage</span><span class="s3">\n\n</span><span class="s1">export function createAsyncLocalStorage&lt;</span><span class="s3">\n  </span><span class="s1">Store extends {},</span><span class="s3">\n</span><span class="s1">&gt;(): AsyncLocalStorage&lt;Store&gt; {</span><span class="s3">\n  </span><span class="s1">if (maybeGlobalAsyncLocalStorage) {</span><span class="s3">\n    </span><span class="s1">return new maybeGlobalAsyncLocalStorage()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return new FakeAsyncLocalStorage()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function bindSnapshot&lt;T&gt;(fn: T): T {</span><span class="s3">\n  </span><span class="s1">if (maybeGlobalAsyncLocalStorage) {</span><span class="s3">\n    </span><span class="s1">return maybeGlobalAsyncLocalStorage.bind(fn)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return FakeAsyncLocalStorage.bind(fn)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createSnapshot(): &lt;R, TArgs extends any[]&gt;(</span><span class="s3">\n  </span><span class="s1">fn: (...args: TArgs) =&gt; R,</span><span class="s3">\n  </span><span class="s1">...args: TArgs</span><span class="s3">\n</span><span class="s1">) =&gt; R {</span><span class="s3">\n  </span><span class="s1">if (maybeGlobalAsyncLocalStorage) {</span><span class="s3">\n    </span><span class="s1">return maybeGlobalAsyncLocalStorage.snapshot()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function (fn: any, ...args: any[]) {</span><span class="s3">\n    </span><span class="s1">return fn(...args)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import PromiseQueue from 'next/dist/compiled/p-queue'</span><span class="s3">\n</span><span class="s1">import type { RequestLifecycleOpts } from '../base-server'</span><span class="s3">\n</span><span class="s1">import type { AfterCallback, AfterTask } from './after'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import { isThenable } from '../../shared/lib/is-thenable'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { withExecuteRevalidates } from '../revalidation-utils'</span><span class="s3">\n</span><span class="s1">import { bindSnapshot } from '../app-render/async-local-storage'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type WorkUnitStore,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">export type AfterContextOpts = {</span><span class="s3">\n  </span><span class="s1">waitUntil: RequestLifecycleOpts['waitUntil'] | undefined</span><span class="s3">\n  </span><span class="s1">onClose: RequestLifecycleOpts['onClose']</span><span class="s3">\n  </span><span class="s1">onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class AfterContext {</span><span class="s3">\n  </span><span class="s1">private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined</span><span class="s3">\n  </span><span class="s1">private onClose: RequestLifecycleOpts['onClose']</span><span class="s3">\n  </span><span class="s1">private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined</span><span class="s3">\n\n  </span><span class="s1">private runCallbacksOnClosePromise: Promise&lt;void&gt; | undefined</span><span class="s3">\n  </span><span class="s1">private callbackQueue: PromiseQueue</span><span class="s3">\n  </span><span class="s1">private workUnitStores = new Set&lt;WorkUnitStore&gt;()</span><span class="s3">\n\n  </span><span class="s1">constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {</span><span class="s3">\n    </span><span class="s1">this.waitUntil = waitUntil</span><span class="s3">\n    </span><span class="s1">this.onClose = onClose</span><span class="s3">\n    </span><span class="s1">this.onTaskError = onTaskError</span><span class="s3">\n\n    </span><span class="s1">this.callbackQueue = new PromiseQueue()</span><span class="s3">\n    </span><span class="s1">this.callbackQueue.pause()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public after(task: AfterTask): void {</span><span class="s3">\n    </span><span class="s1">if (isThenable(task)) {</span><span class="s3">\n      </span><span class="s1">if (!this.waitUntil) {</span><span class="s3">\n        </span><span class="s1">errorWaitUntilNotAvailable()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.waitUntil(</span><span class="s3">\n        </span><span class="s1">task.catch((error) =&gt; this.reportTaskError('promise', error))</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (typeof task === 'function') {</span><span class="s3">\n      </span><span class="s1">// TODO(after): implement tracing</span><span class="s3">\n      </span><span class="s1">this.addCallback(task)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error('`after()`: Argument must be a promise or a function')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private addCallback(callback: AfterCallback) {</span><span class="s3">\n    </span><span class="s1">// if something is wrong, throw synchronously, bubbling up to the `after` callsite.</span><span class="s3">\n    </span><span class="s1">if (!this.waitUntil) {</span><span class="s3">\n      </span><span class="s1">errorWaitUntilNotAvailable()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n    </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n      </span><span class="s1">this.workUnitStores.add(workUnitStore)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const afterTaskStore = afterTaskAsyncStorage.getStore()</span><span class="s3">\n\n    </span><span class="s1">// This is used for checking if request APIs can be called inside `after`.</span><span class="s3">\n    </span><span class="s1">// Note that we need to check the phase in which the *topmost* `after` was called (which should be </span><span class="s3">\&quot;</span><span class="s1">action</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">// not the current phase (which might be </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot; </span><span class="s1">if we're in a nested after).</span><span class="s3">\n    </span><span class="s1">// Otherwise, we might allow `after(() =&gt; headers())`, but not `after(() =&gt; after(() =&gt; headers()))`.</span><span class="s3">\n    </span><span class="s1">const rootTaskSpawnPhase = afterTaskStore</span><span class="s3">\n      </span><span class="s1">? afterTaskStore.rootTaskSpawnPhase // nested after</span><span class="s3">\n      </span><span class="s1">: workUnitStore?.phase // topmost after</span><span class="s3">\n\n    </span><span class="s1">// this should only happen once.</span><span class="s3">\n    </span><span class="s1">if (!this.runCallbacksOnClosePromise) {</span><span class="s3">\n      </span><span class="s1">this.runCallbacksOnClosePromise = this.runCallbacksOnClose()</span><span class="s3">\n      </span><span class="s1">this.waitUntil(this.runCallbacksOnClosePromise)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).</span><span class="s3">\n    </span><span class="s1">// We do this because we want all of these to be equivalent in every regard except timing:</span><span class="s3">\n    </span><span class="s1">//   after(() =&gt; x())</span><span class="s3">\n    </span><span class="s1">//   after(x())</span><span class="s3">\n    </span><span class="s1">//   await x()</span><span class="s3">\n    </span><span class="s1">const wrappedCallback = bindSnapshot(async () =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">await afterTaskAsyncStorage.run({ rootTaskSpawnPhase }, () =&gt;</span><span class="s3">\n          </span><span class="s1">callback()</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (error) {</span><span class="s3">\n        </span><span class="s1">this.reportTaskError('function', error)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">this.callbackQueue.add(wrappedCallback)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async runCallbacksOnClose() {</span><span class="s3">\n    </span><span class="s1">await new Promise&lt;void&gt;((resolve) =&gt; this.onClose!(resolve))</span><span class="s3">\n    </span><span class="s1">return this.runCallbacks()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async runCallbacks(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.callbackQueue.size === 0) return</span><span class="s3">\n\n    </span><span class="s1">for (const workUnitStore of this.workUnitStores) {</span><span class="s3">\n      </span><span class="s1">workUnitStore.phase = 'after'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n    </span><span class="s1">if (!workStore) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError('Missing workStore in AfterContext.runCallbacks')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return withExecuteRevalidates(workStore, () =&gt; {</span><span class="s3">\n      </span><span class="s1">this.callbackQueue.start()</span><span class="s3">\n      </span><span class="s1">return this.callbackQueue.onIdle()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private reportTaskError(taskKind: 'promise' | 'function', error: unknown) {</span><span class="s3">\n    </span><span class="s1">// TODO(after): this is fine for now, but will need better intergration with our error reporting.</span><span class="s3">\n    </span><span class="s1">// TODO(after): should we log this if we have a onTaskError callback?</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">taskKind === 'promise'</span><span class="s3">\n        </span><span class="s1">? `A promise passed to </span><span class="s3">\\</span><span class="s1">`after()</span><span class="s3">\\</span><span class="s1">` rejected:`</span><span class="s3">\n        </span><span class="s1">: `An error occurred in a function passed to </span><span class="s3">\\</span><span class="s1">`after()</span><span class="s3">\\</span><span class="s1">`:`,</span><span class="s3">\n      </span><span class="s1">error</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (this.onTaskError) {</span><span class="s3">\n      </span><span class="s1">// this is very defensive, but we really don't want anything to blow up in an error handler</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">this.onTaskError?.(error)</span><span class="s3">\n      </span><span class="s1">} catch (handlerError) {</span><span class="s3">\n        </span><span class="s1">console.error(</span><span class="s3">\n          </span><span class="s1">new InvariantError(</span><span class="s3">\n            </span><span class="s1">'`onTaskError` threw while handling an error thrown from an `after` task',</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">cause: handlerError,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function errorWaitUntilNotAvailable(): never {</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    </span><span class="s1">'`after()` will not work correctly, because `waitUntil` is not available in the current environment.'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Check to see if a value is Thenable.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param promise the maybe-thenable value</span><span class="s3">\n </span><span class="s1">* @returns true if the value is thenable</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isThenable&lt;T = unknown&gt;(</span><span class="s3">\n  </span><span class="s1">promise: Promise&lt;T&gt; | T</span><span class="s3">\n</span><span class="s1">): promise is Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">promise !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof promise === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'then' in promise &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof promise.then === 'function'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export type LazyResult&lt;TValue&gt; = PromiseLike&lt;TValue&gt; &amp; { value?: TValue }</span><span class="s3">\n</span><span class="s1">export type ResolvedLazyResult&lt;TValue&gt; = PromiseLike&lt;TValue&gt; &amp; { value: TValue }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calls the given async function only when the returned promise-like object is</span><span class="s3">\n </span><span class="s1">* awaited. Afterwards, it provides the resolved value synchronously as `value`</span><span class="s3">\n </span><span class="s1">* property.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createLazyResult&lt;TValue&gt;(</span><span class="s3">\n  </span><span class="s1">fn: () =&gt; Promise&lt;TValue&gt;</span><span class="s3">\n</span><span class="s1">): LazyResult&lt;TValue&gt; {</span><span class="s3">\n  </span><span class="s1">let pendingResult: Promise&lt;TValue&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const result: LazyResult&lt;TValue&gt; = {</span><span class="s3">\n    </span><span class="s1">then(onfulfilled, onrejected) {</span><span class="s3">\n      </span><span class="s1">if (!pendingResult) {</span><span class="s3">\n        </span><span class="s1">pendingResult = fn()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">pendingResult</span><span class="s3">\n        </span><span class="s1">.then((value) =&gt; {</span><span class="s3">\n          </span><span class="s1">result.value = value</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">.catch(() =&gt; {</span><span class="s3">\n          </span><span class="s1">// The externally awaited result will be rejected via `onrejected`. We</span><span class="s3">\n          </span><span class="s1">// don't need to handle it here. But we do want to avoid an unhandled</span><span class="s3">\n          </span><span class="s1">// rejection.</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">return pendingResult.then(onfulfilled, onrejected)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isResolvedLazyResult&lt;TValue&gt;(</span><span class="s3">\n  </span><span class="s1">result: LazyResult&lt;TValue&gt;</span><span class="s3">\n</span><span class="s1">): result is ResolvedLazyResult&lt;TValue&gt; {</span><span class="s3">\n  </span><span class="s1">return result.hasOwnProperty('value')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* List of valid HTTP methods that can be implemented by Next.js's Custom App</span><span class="s3">\n </span><span class="s1">* Routes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const HTTP_METHODS = [</span><span class="s3">\n  </span><span class="s1">'GET',</span><span class="s3">\n  </span><span class="s1">'HEAD',</span><span class="s3">\n  </span><span class="s1">'OPTIONS',</span><span class="s3">\n  </span><span class="s1">'POST',</span><span class="s3">\n  </span><span class="s1">'PUT',</span><span class="s3">\n  </span><span class="s1">'DELETE',</span><span class="s3">\n  </span><span class="s1">'PATCH',</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A type representing the valid HTTP methods that can be implemented by</span><span class="s3">\n </span><span class="s1">* Next.js's Custom App Routes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type HTTP_METHOD = (typeof HTTP_METHODS)[number]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks to see if the passed string is an HTTP method. Note that this is case</span><span class="s3">\n </span><span class="s1">* sensitive.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param maybeMethod the string that may be an HTTP method</span><span class="s3">\n </span><span class="s1">* @returns true if the string is an HTTP method</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isHTTPMethod(maybeMethod: string): maybeMethod is HTTP_METHOD {</span><span class="s3">\n  </span><span class="s1">return HTTP_METHODS.includes(maybeMethod as HTTP_METHOD)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { NEXT_CACHE_IMPLICIT_TAG_ID } from '../../lib/constants'</span><span class="s3">\n</span><span class="s1">import type { FallbackRouteParams } from '../request/fallback-params'</span><span class="s3">\n</span><span class="s1">import { getCacheHandlerEntries } from '../use-cache/handlers'</span><span class="s3">\n</span><span class="s1">import { createLazyResult, type LazyResult } from './lazy-result'</span><span class="s3">\n\n</span><span class="s1">export interface ImplicitTags {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* For legacy usage, the implicit tags are passed to the incremental cache</span><span class="s3">\n   </span><span class="s1">* handler in `get` calls.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly tags: string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Modern cache handlers don't receive implicit tags. Instead, the implicit</span><span class="s3">\n   </span><span class="s1">* tags' expirations are stored in the work unit store, and used to compare</span><span class="s3">\n   </span><span class="s1">* with a cache entry's timestamp.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note: This map contains lazy results so that we can evaluate them when the</span><span class="s3">\n   </span><span class="s1">* first cache entry is read. It allows us to skip fetching the expiration</span><span class="s3">\n   </span><span class="s1">* values if no caches are read at all.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly expirationsByCacheKind: Map&lt;string, LazyResult&lt;number&gt;&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const getDerivedTags = (pathname: string): string[] =&gt; {</span><span class="s3">\n  </span><span class="s1">const derivedTags: string[] = [`/layout`]</span><span class="s3">\n\n  </span><span class="s1">// we automatically add the current path segments as tags</span><span class="s3">\n  </span><span class="s1">// for revalidatePath handling</span><span class="s3">\n  </span><span class="s1">if (pathname.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">const pathnameParts = pathname.split('/')</span><span class="s3">\n\n    </span><span class="s1">for (let i = 1; i &lt; pathnameParts.length + 1; i++) {</span><span class="s3">\n      </span><span class="s1">let curPathname = pathnameParts.slice(0, i).join('/')</span><span class="s3">\n\n      </span><span class="s1">if (curPathname) {</span><span class="s3">\n        </span><span class="s1">// all derived tags other than the page are layout tags</span><span class="s3">\n        </span><span class="s1">if (!curPathname.endsWith('/page') &amp;&amp; !curPathname.endsWith('/route')) {</span><span class="s3">\n          </span><span class="s1">curPathname = `${curPathname}${</span><span class="s3">\n            </span><span class="s1">!curPathname.endsWith('/') ? '/' : ''</span><span class="s3">\n          </span><span class="s1">}layout`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">derivedTags.push(curPathname)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return derivedTags</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a map with lazy results that fetch the expiration value for the given</span><span class="s3">\n </span><span class="s1">* tags and respective cache kind when they're awaited for the first time.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createTagsExpirationsByCacheKind(</span><span class="s3">\n  </span><span class="s1">tags: string[]</span><span class="s3">\n</span><span class="s1">): Map&lt;string, LazyResult&lt;number&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">const expirationsByCacheKind = new Map&lt;string, LazyResult&lt;number&gt;&gt;()</span><span class="s3">\n  </span><span class="s1">const cacheHandlers = getCacheHandlerEntries()</span><span class="s3">\n\n  </span><span class="s1">if (cacheHandlers) {</span><span class="s3">\n    </span><span class="s1">for (const [kind, cacheHandler] of cacheHandlers) {</span><span class="s3">\n      </span><span class="s1">if ('getExpiration' in cacheHandler) {</span><span class="s3">\n        </span><span class="s1">expirationsByCacheKind.set(</span><span class="s3">\n          </span><span class="s1">kind,</span><span class="s3">\n          </span><span class="s1">createLazyResult(async () =&gt; cacheHandler.getExpiration(...tags))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return expirationsByCacheKind</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function getImplicitTags(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">url: {</span><span class="s3">\n    </span><span class="s1">pathname: string</span><span class="s3">\n    </span><span class="s1">search?: string</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: null | FallbackRouteParams</span><span class="s3">\n</span><span class="s1">): Promise&lt;ImplicitTags&gt; {</span><span class="s3">\n  </span><span class="s1">const tags: string[] = []</span><span class="s3">\n  </span><span class="s1">const hasFallbackRouteParams =</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams &amp;&amp; fallbackRouteParams.size &gt; 0</span><span class="s3">\n\n  </span><span class="s1">// Add the derived tags from the page.</span><span class="s3">\n  </span><span class="s1">const derivedTags = getDerivedTags(page)</span><span class="s3">\n  </span><span class="s1">for (let tag of derivedTags) {</span><span class="s3">\n    </span><span class="s1">tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`</span><span class="s3">\n    </span><span class="s1">tags.push(tag)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Add the tags from the pathname. If the route has unknown params, we don't</span><span class="s3">\n  </span><span class="s1">// want to add the pathname as a tag, as it will be invalid.</span><span class="s3">\n  </span><span class="s1">if (url.pathname &amp;&amp; !hasFallbackRouteParams) {</span><span class="s3">\n    </span><span class="s1">const tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${url.pathname}`</span><span class="s3">\n    </span><span class="s1">tags.push(tag)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">tags,</span><span class="s3">\n    </span><span class="s1">expirationsByCacheKind: createTagsExpirationsByCacheKind(tags),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'</span><span class="s3">\n\n</span><span class="s1">export class DynamicServerError extends Error {</span><span class="s3">\n  </span><span class="s1">digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE</span><span class="s3">\n\n  </span><span class="s1">constructor(public readonly description: string) {</span><span class="s3">\n    </span><span class="s1">super(`Dynamic server usage: ${description}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isDynamicServerError(err: unknown): err is DynamicServerError {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof err !== 'object' ||</span><span class="s3">\n    </span><span class="s1">err === null ||</span><span class="s3">\n    </span><span class="s1">!('digest' in err) ||</span><span class="s3">\n    </span><span class="s1">typeof err.digest !== 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return err.digest === DYNAMIC_ERROR_CODE</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'</span><span class="s3">\n\n</span><span class="s1">export class StaticGenBailoutError extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly code = NEXT_STATIC_GEN_BAILOUT</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isStaticGenBailoutError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is StaticGenBailoutError {</span><span class="s3">\n  </span><span class="s1">if (typeof error !== 'object' || error === null || !('code' in error)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return error.code === NEXT_STATIC_GEN_BAILOUT</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function isHangingPromiseRejectionError(</span><span class="s3">\n  </span><span class="s1">err: unknown</span><span class="s3">\n</span><span class="s1">): err is HangingPromiseRejectionError {</span><span class="s3">\n  </span><span class="s1">if (typeof err !== 'object' || err === null || !('digest' in err)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return err.digest === HANGING_PROMISE_REJECTION</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'</span><span class="s3">\n\n</span><span class="s1">class HangingPromiseRejectionError extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly digest = HANGING_PROMISE_REJECTION</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">public readonly route: string,</span><span class="s3">\n    </span><span class="s1">public readonly expression: string</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using </span><span class="s3">\\</span><span class="s1">`setTimeout</span><span class="s3">\\</span><span class="s1">`, </span><span class="s3">\\</span><span class="s1">`after</span><span class="s3">\\</span><span class="s1">`, or similar functions you may observe this error and you should handle it in that context. This occurred at route </span><span class="s3">\&quot;</span><span class="s1">${route}</span><span class="s3">\&quot;</span><span class="s1">.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type AbortListeners = Array&lt;(err: unknown) =&gt; void&gt;</span><span class="s3">\n</span><span class="s1">const abortListenersBySignal = new WeakMap&lt;AbortSignal, AbortListeners&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function constructs a promise that will never resolve. This is primarily</span><span class="s3">\n </span><span class="s1">* useful for cacheComponents where we use promise resolution timing to determine which</span><span class="s3">\n </span><span class="s1">* parts of a render can be included in a prerender.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function makeHangingPromise&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">signal: AbortSignal,</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">): Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (signal.aborted) {</span><span class="s3">\n    </span><span class="s1">return Promise.reject(new HangingPromiseRejectionError(route, expression))</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const hangingPromise = new Promise&lt;T&gt;((_, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">const boundRejection = reject.bind(</span><span class="s3">\n        </span><span class="s1">null,</span><span class="s3">\n        </span><span class="s1">new HangingPromiseRejectionError(route, expression)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">let currentListeners = abortListenersBySignal.get(signal)</span><span class="s3">\n      </span><span class="s1">if (currentListeners) {</span><span class="s3">\n        </span><span class="s1">currentListeners.push(boundRejection)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const listeners = [boundRejection]</span><span class="s3">\n        </span><span class="s1">abortListenersBySignal.set(signal, listeners)</span><span class="s3">\n        </span><span class="s1">signal.addEventListener(</span><span class="s3">\n          </span><span class="s1">'abort',</span><span class="s3">\n          </span><span class="s1">() =&gt; {</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; listeners.length; i++) {</span><span class="s3">\n              </span><span class="s1">listeners[i]()</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">{ once: true }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">// We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so</span><span class="s3">\n    </span><span class="s1">// we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct</span><span class="s3">\n    </span><span class="s1">// your own promise out of it you'll need to ensure you handle the error when it rejects.</span><span class="s3">\n    </span><span class="s1">hangingPromise.catch(ignoreReject)</span><span class="s3">\n    </span><span class="s1">return hangingPromise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ignoreReject() {}</span><span class="s3">\n\n</span><span class="s1">export function makeDevtoolsIOAwarePromise&lt;T&gt;(underlying: T): Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">// in React DevTools if we resolve in a setTimeout we will observe</span><span class="s3">\n  </span><span class="s1">// the promise resolution as something that can suspend a boundary or root.</span><span class="s3">\n  </span><span class="s1">return new Promise&lt;T&gt;((resolve) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Must use setTimeout to be considered IO React DevTools. setImmediate will not work.</span><span class="s3">\n    </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n      </span><span class="s1">resolve(underlying)</span><span class="s3">\n    </span><span class="s1">}, 0)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The functions provided by this module are used to communicate certain properties</span><span class="s3">\n </span><span class="s1">* about the currently running code so that Next.js can make decisions on how to handle</span><span class="s3">\n </span><span class="s1">* the current execution in different rendering modes such as pre-rendering, resuming, and SSR.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.</span><span class="s3">\n </span><span class="s1">* Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts</span><span class="s3">\n </span><span class="s1">* of a React tree as dynamic while still keeping other parts static. There are really two different kinds of</span><span class="s3">\n </span><span class="s1">* Dynamic indications.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The first is simply an intention to be dynamic. unstable_noStore is an example of this where</span><span class="s3">\n </span><span class="s1">* the currently executing code simply declares that the current scope is dynamic but if you use it</span><span class="s3">\n </span><span class="s1">* inside unstable_cache it can still be cached. This type of indication can be removed if we ever</span><span class="s3">\n </span><span class="s1">* make the default dynamic to begin with because the only way you would ever be static is inside</span><span class="s3">\n </span><span class="s1">* a cache scope which this indication does not affect.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The second is an indication that a dynamic data source was read. This is a stronger form of dynamic</span><span class="s3">\n </span><span class="s1">* because it means that it is inappropriate to cache this at all. using a dynamic data source inside</span><span class="s3">\n </span><span class="s1">* unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should</span><span class="s3">\n </span><span class="s1">* read that data outside the cache and pass it in as an argument to the cached function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type { WorkStore } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">WorkUnitStore,</span><span class="s3">\n  </span><span class="s1">RequestStore,</span><span class="s3">\n  </span><span class="s1">PrerenderStoreLegacy,</span><span class="s3">\n  </span><span class="s1">PrerenderStoreModern,</span><span class="s3">\n  </span><span class="s1">PrerenderStoreModernRuntime,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">// Once postpone is in stable we should switch to importing the postpone export directly</span><span class="s3">\n</span><span class="s1">import React from 'react'</span><span class="s3">\n\n</span><span class="s1">import { DynamicServerError } from '../../client/components/hooks-server-context'</span><span class="s3">\n</span><span class="s1">import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getRuntimeStagePromise,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from './work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { makeHangingPromise } from '../dynamic-rendering-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">METADATA_BOUNDARY_NAME,</span><span class="s3">\n  </span><span class="s1">VIEWPORT_BOUNDARY_NAME,</span><span class="s3">\n  </span><span class="s1">OUTLET_BOUNDARY_NAME,</span><span class="s3">\n  </span><span class="s1">ROOT_LAYOUT_BOUNDARY_NAME,</span><span class="s3">\n</span><span class="s1">} from '../../lib/framework/boundary-constants'</span><span class="s3">\n</span><span class="s1">import { scheduleOnNextTick } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">const hasPostpone = typeof React.unstable_postpone === 'function'</span><span class="s3">\n\n</span><span class="s1">export type DynamicAccess = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If debugging, this will contain the stack trace of where the dynamic access</span><span class="s3">\n   </span><span class="s1">* occurred. This is used to provide more information to the user about why</span><span class="s3">\n   </span><span class="s1">* their page is being rendered dynamically.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">stack?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The expression that was accessed dynamically.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Stores dynamic reasons used during an RSC render.</span><span class="s3">\n</span><span class="s1">export type DynamicTrackingState = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, stack information will also be tracked during dynamic access.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly isDebugDynamicAccesses: boolean | undefined</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The dynamic accesses that occurred during the render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly dynamicAccesses: Array&lt;DynamicAccess&gt;</span><span class="s3">\n\n  </span><span class="s1">syncDynamicErrorWithStack: null | Error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Stores dynamic reasons used during an SSR render.</span><span class="s3">\n</span><span class="s1">export type DynamicValidationState = {</span><span class="s3">\n  </span><span class="s1">hasSuspenseAboveBody: boolean</span><span class="s3">\n  </span><span class="s1">hasDynamicMetadata: boolean</span><span class="s3">\n  </span><span class="s1">hasDynamicViewport: boolean</span><span class="s3">\n  </span><span class="s1">hasAllowedDynamic: boolean</span><span class="s3">\n  </span><span class="s1">dynamicErrors: Array&lt;Error&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createDynamicTrackingState(</span><span class="s3">\n  </span><span class="s1">isDebugDynamicAccesses: boolean | undefined</span><span class="s3">\n</span><span class="s1">): DynamicTrackingState {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">isDebugDynamicAccesses,</span><span class="s3">\n    </span><span class="s1">dynamicAccesses: [],</span><span class="s3">\n    </span><span class="s1">syncDynamicErrorWithStack: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createDynamicValidationState(): DynamicValidationState {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">hasSuspenseAboveBody: false,</span><span class="s3">\n    </span><span class="s1">hasDynamicMetadata: false,</span><span class="s3">\n    </span><span class="s1">hasDynamicViewport: false,</span><span class="s3">\n    </span><span class="s1">hasAllowedDynamic: false,</span><span class="s3">\n    </span><span class="s1">dynamicErrors: [],</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getFirstDynamicReason(</span><span class="s3">\n  </span><span class="s1">trackingState: DynamicTrackingState</span><span class="s3">\n</span><span class="s1">): undefined | string {</span><span class="s3">\n  </span><span class="s1">return trackingState.dynamicAccesses[0]?.expression</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function communicates that the current scope should be treated as dynamic.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In most cases this function is a no-op but if called during</span><span class="s3">\n </span><span class="s1">* a PPR prerender it will postpone the current sub-tree and calling</span><span class="s3">\n </span><span class="s1">* it during a normal prerender will cause the entire prerender to abort</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function markCurrentScopeAsDynamic(</span><span class="s3">\n  </span><span class="s1">store: WorkStore,</span><span class="s3">\n  </span><span class="s1">workUnitStore: undefined | Exclude&lt;WorkUnitStore, PrerenderStoreModern&gt;,</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">// Inside cache scopes, marking a scope as dynamic has no effect,</span><span class="s3">\n        </span><span class="s1">// because the outer cache scope creates a cache boundary. This is</span><span class="s3">\n        </span><span class="s1">// subtly different from reading a dynamic data source, which is</span><span class="s3">\n        </span><span class="s1">// forbidden inside a cache scope.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">// A private cache scope is already dynamic by definition.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we're forcing dynamic rendering or we're forcing static rendering, we</span><span class="s3">\n  </span><span class="s1">// don't need to do anything here because the entire page is already dynamic</span><span class="s3">\n  </span><span class="s1">// or it's static and it should not throw or postpone here.</span><span class="s3">\n  </span><span class="s1">if (store.forceDynamic || store.forceStatic) return</span><span class="s3">\n\n  </span><span class="s1">if (store.dynamicShouldError) {</span><span class="s3">\n    </span><span class="s1">throw new StaticGenBailoutError(</span><span class="s3">\n      </span><span class="s1">`Route ${store.route} with </span><span class="s3">\\</span><span class="s1">`dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;\\</span><span class="s1">` couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n        </span><span class="s1">return postponeWithTracking(</span><span class="s3">\n          </span><span class="s1">store.route,</span><span class="s3">\n          </span><span class="s1">expression,</span><span class="s3">\n          </span><span class="s1">workUnitStore.dynamicTracking</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">workUnitStore.revalidate = 0</span><span class="s3">\n\n        </span><span class="s1">// We aren't prerendering, but we are generating a static page. We need</span><span class="s3">\n        </span><span class="s1">// to bail out of static generation.</span><span class="s3">\n        </span><span class="s1">const err = new DynamicServerError(</span><span class="s3">\n          </span><span class="s1">`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">store.dynamicUsageDescription = expression</span><span class="s3">\n        </span><span class="s1">store.dynamicUsageStack = err.stack</span><span class="s3">\n\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n          </span><span class="s1">workUnitStore.usedDynamic = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is meant to be used when prerendering without cacheComponents or PPR.</span><span class="s3">\n </span><span class="s1">* When called during a build it will cause Next.js to consider the route as dynamic.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function throwToInterruptStaticGeneration(</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">store: WorkStore,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreLegacy</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">// We aren't prerendering but we are generating a static page. We need to bail out of static generation</span><span class="s3">\n  </span><span class="s1">const err = new DynamicServerError(</span><span class="s3">\n    </span><span class="s1">`Route ${store.route} couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">prerenderStore.revalidate = 0</span><span class="s3">\n\n  </span><span class="s1">store.dynamicUsageDescription = expression</span><span class="s3">\n  </span><span class="s1">store.dynamicUsageStack = err.stack</span><span class="s3">\n\n  </span><span class="s1">throw err</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function should be used to track whether something dynamic happened even when</span><span class="s3">\n </span><span class="s1">* we are in a dynamic render. This is useful for Dev where all renders are dynamic but</span><span class="s3">\n </span><span class="s1">* we still track whether dynamic APIs were accessed for helpful messaging</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {</span><span class="s3">\n  </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n    </span><span class="s1">case 'cache':</span><span class="s3">\n    </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n      </span><span class="s1">// Inside cache scopes, marking a scope as dynamic has no effect,</span><span class="s3">\n      </span><span class="s1">// because the outer cache scope creates a cache boundary. This is</span><span class="s3">\n      </span><span class="s1">// subtly different from reading a dynamic data source, which is</span><span class="s3">\n      </span><span class="s1">// forbidden inside a cache scope.</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">// A private cache scope is already dynamic by definition.</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">case 'prerender':</span><span class="s3">\n    </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n    </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n    </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n    </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n        </span><span class="s1">workUnitStore.usedDynamic = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function abortOnSynchronousDynamicDataAccess(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`</span><span class="s3">\n\n  </span><span class="s1">const error = createPrerenderInterruptedError(reason)</span><span class="s3">\n\n  </span><span class="s1">prerenderStore.controller.abort(error)</span><span class="s3">\n\n  </span><span class="s1">const dynamicTracking = prerenderStore.dynamicTracking</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n    </span><span class="s1">dynamicTracking.dynamicAccesses.push({</span><span class="s3">\n      </span><span class="s1">// When we aren't debugging, we don't need to create another error for the</span><span class="s3">\n      </span><span class="s1">// stack trace.</span><span class="s3">\n      </span><span class="s1">stack: dynamicTracking.isDebugDynamicAccesses</span><span class="s3">\n        </span><span class="s1">? new Error().stack</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function abortOnSynchronousPlatformIOAccess(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">errorWithStack: Error,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const dynamicTracking = prerenderStore.dynamicTracking</span><span class="s3">\n  </span><span class="s1">abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)</span><span class="s3">\n  </span><span class="s1">// It is important that we set this tracking value after aborting. Aborts are executed</span><span class="s3">\n  </span><span class="s1">// synchronously except for the case where you abort during render itself. By setting this</span><span class="s3">\n  </span><span class="s1">// value late we can use it to determine if any of the aborted tasks are the task that</span><span class="s3">\n  </span><span class="s1">// called the sync IO expression in the first place.</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n    </span><span class="s1">if (dynamicTracking.syncDynamicErrorWithStack === null) {</span><span class="s3">\n      </span><span class="s1">dynamicTracking.syncDynamicErrorWithStack = errorWithStack</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function trackSynchronousPlatformIOAccessInDev(</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// We don't actually have a controller to abort but we do the semantic equivalent by</span><span class="s3">\n  </span><span class="s1">// advancing the request store out of prerender mode</span><span class="s3">\n  </span><span class="s1">requestStore.prerenderPhase = false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* use this function when prerendering with cacheComponents. If we are doing a</span><span class="s3">\n </span><span class="s1">* prospective prerender we don't actually abort because we want to discover</span><span class="s3">\n </span><span class="s1">* all caches for the shell. If this is the actual prerender we do abort.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function accepts a prerenderStore but the caller should ensure we're</span><span class="s3">\n </span><span class="s1">* actually running in cacheComponents mode.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function abortAndThrowOnSynchronousRequestDataAccess(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">errorWithStack: Error,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">const prerenderSignal = prerenderStore.controller.signal</span><span class="s3">\n  </span><span class="s1">if (prerenderSignal.aborted === false) {</span><span class="s3">\n    </span><span class="s1">// TODO it would be better to move this aborted check into the callsite so we can avoid making</span><span class="s3">\n    </span><span class="s1">// the error object when it isn't relevant to the aborting of the prerender however</span><span class="s3">\n    </span><span class="s1">// since we need the throw semantics regardless of whether we abort it is easier to land</span><span class="s3">\n    </span><span class="s1">// this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer</span><span class="s3">\n    </span><span class="s1">// to ideal implementation</span><span class="s3">\n    </span><span class="s1">abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)</span><span class="s3">\n    </span><span class="s1">// It is important that we set this tracking value after aborting. Aborts are executed</span><span class="s3">\n    </span><span class="s1">// synchronously except for the case where you abort during render itself. By setting this</span><span class="s3">\n    </span><span class="s1">// value late we can use it to determine if any of the aborted tasks are the task that</span><span class="s3">\n    </span><span class="s1">// called the sync IO expression in the first place.</span><span class="s3">\n    </span><span class="s1">const dynamicTracking = prerenderStore.dynamicTracking</span><span class="s3">\n    </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n      </span><span class="s1">if (dynamicTracking.syncDynamicErrorWithStack === null) {</span><span class="s3">\n        </span><span class="s1">dynamicTracking.syncDynamicErrorWithStack = errorWithStack</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw createPrerenderInterruptedError(</span><span class="s3">\n    </span><span class="s1">`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Use this function when dynamically prerendering with dynamicIO.</span><span class="s3">\n </span><span class="s1">* We don't want to error, because it's better to return something</span><span class="s3">\n </span><span class="s1">* (and we've already aborted the render at the point where the sync dynamic error occured),</span><span class="s3">\n </span><span class="s1">* but we should log an error server-side.</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function warnOnSyncDynamicError(dynamicTracking: DynamicTrackingState) {</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking.syncDynamicErrorWithStack) {</span><span class="s3">\n    </span><span class="s1">// the server did something sync dynamic, likely</span><span class="s3">\n    </span><span class="s1">// leading to an early termination of the prerender.</span><span class="s3">\n    </span><span class="s1">console.error(dynamicTracking.syncDynamicErrorWithStack)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// For now these implementations are the same so we just reexport</span><span class="s3">\n</span><span class="s1">export const trackSynchronousRequestDataAccessInDev =</span><span class="s3">\n  </span><span class="s1">trackSynchronousPlatformIOAccessInDev</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This component will call `React.postpone` that throws the postponed error.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type PostponeProps = {</span><span class="s3">\n  </span><span class="s1">reason: string</span><span class="s3">\n  </span><span class="s1">route: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function Postpone({ reason, route }: PostponeProps): never {</span><span class="s3">\n  </span><span class="s1">const prerenderStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">const dynamicTracking =</span><span class="s3">\n    </span><span class="s1">prerenderStore &amp;&amp; prerenderStore.type === 'prerender-ppr'</span><span class="s3">\n      </span><span class="s1">? prerenderStore.dynamicTracking</span><span class="s3">\n      </span><span class="s1">: null</span><span class="s3">\n  </span><span class="s1">postponeWithTracking(route, reason, dynamicTracking)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function postponeWithTracking(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">dynamicTracking: null | DynamicTrackingState</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">assertPostpone()</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n    </span><span class="s1">dynamicTracking.dynamicAccesses.push({</span><span class="s3">\n      </span><span class="s1">// When we aren't debugging, we don't need to create another error for the</span><span class="s3">\n      </span><span class="s1">// stack trace.</span><span class="s3">\n      </span><span class="s1">stack: dynamicTracking.isDebugDynamicAccesses</span><span class="s3">\n        </span><span class="s1">? new Error().stack</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">React.unstable_postpone(createPostponeReason(route, expression))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPostponeReason(route: string, expression: string) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">`Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +</span><span class="s3">\n    </span><span class="s1">`React throws this special object to indicate where. It should not be caught by ` +</span><span class="s3">\n    </span><span class="s1">`your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isDynamicPostpone(err: unknown) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof err === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">err !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof (err as any).message === 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return isDynamicPostponeReason((err as any).message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isDynamicPostponeReason(reason: string) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">reason.includes(</span><span class="s3">\n      </span><span class="s1">'needs to bail out of prerendering at this point because it used'</span><span class="s3">\n    </span><span class="s1">) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">reason.includes(</span><span class="s3">\n      </span><span class="s1">'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    </span><span class="s1">'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'</span><span class="s3">\n\n</span><span class="s1">function createPrerenderInterruptedError(message: string): Error {</span><span class="s3">\n  </span><span class="s1">const error = new Error(message)</span><span class="s3">\n  </span><span class="s1">;(error as any).digest = NEXT_PRERENDER_INTERRUPTED</span><span class="s3">\n  </span><span class="s1">return error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type DigestError = Error &amp; {</span><span class="s3">\n  </span><span class="s1">digest: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isPrerenderInterruptedError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is DigestError {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof error === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(error as any).digest === NEXT_PRERENDER_INTERRUPTED &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'name' in error &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'message' in error &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error instanceof Error</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function accessedDynamicData(</span><span class="s3">\n  </span><span class="s1">dynamicAccesses: Array&lt;DynamicAccess&gt;</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return dynamicAccesses.length &gt; 0</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function consumeDynamicAccess(</span><span class="s3">\n  </span><span class="s1">serverDynamic: DynamicTrackingState,</span><span class="s3">\n  </span><span class="s1">clientDynamic: DynamicTrackingState</span><span class="s3">\n</span><span class="s1">): DynamicTrackingState['dynamicAccesses'] {</span><span class="s3">\n  </span><span class="s1">// We mutate because we only call this once we are no longer writing</span><span class="s3">\n  </span><span class="s1">// to the dynamicTrackingState and it's more efficient than creating a new</span><span class="s3">\n  </span><span class="s1">// array.</span><span class="s3">\n  </span><span class="s1">serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)</span><span class="s3">\n  </span><span class="s1">return serverDynamic.dynamicAccesses</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function formatDynamicAPIAccesses(</span><span class="s3">\n  </span><span class="s1">dynamicAccesses: Array&lt;DynamicAccess&gt;</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">return dynamicAccesses</span><span class="s3">\n    </span><span class="s1">.filter(</span><span class="s3">\n      </span><span class="s1">(access): access is Required&lt;DynamicAccess&gt; =&gt;</span><span class="s3">\n        </span><span class="s1">typeof access.stack === 'string' &amp;&amp; access.stack.length &gt; 0</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">.map(({ expression, stack }) =&gt; {</span><span class="s3">\n      </span><span class="s1">stack = stack</span><span class="s3">\n        </span><span class="s1">.split('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n        </span><span class="s1">// Remove the </span><span class="s3">\&quot;</span><span class="s1">Error: </span><span class="s3">\&quot; </span><span class="s1">prefix from the first line of the stack trace as</span><span class="s3">\n        </span><span class="s1">// well as the first 4 lines of the stack trace which is the distance</span><span class="s3">\n        </span><span class="s1">// from the user code and the `new Error().stack` call.</span><span class="s3">\n        </span><span class="s1">.slice(4)</span><span class="s3">\n        </span><span class="s1">.filter((line) =&gt; {</span><span class="s3">\n          </span><span class="s1">// Exclude Next.js internals from the stack trace.</span><span class="s3">\n          </span><span class="s1">if (line.includes('node_modules/next/')) {</span><span class="s3">\n            </span><span class="s1">return false</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Exclude anonymous functions from the stack trace.</span><span class="s3">\n          </span><span class="s1">if (line.includes(' (&lt;anonymous&gt;)')) {</span><span class="s3">\n            </span><span class="s1">return false</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Exclude Node.js internals from the stack trace.</span><span class="s3">\n          </span><span class="s1">if (line.includes(' (node:')) {</span><span class="s3">\n            </span><span class="s1">return false</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">.join('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n      </span><span class="s1">return `Dynamic API Usage Debug - ${expression}:</span><span class="s3">\\</span><span class="s1">n${stack}`</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assertPostpone() {</span><span class="s3">\n  </span><span class="s1">if (!hasPostpone) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's</span><span class="s3">\n </span><span class="s1">* abort semantics slightly.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createRenderInBrowserAbortSignal(): AbortSignal {</span><span class="s3">\n  </span><span class="s1">const controller = new AbortController()</span><span class="s3">\n  </span><span class="s1">controller.abort(new BailoutToCSRError('Render in Browser'))</span><span class="s3">\n  </span><span class="s1">return controller.signal</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* In a prerender, we may end up with hanging Promises as inputs due them</span><span class="s3">\n </span><span class="s1">* stalling on connection() or because they're loading dynamic data. In that</span><span class="s3">\n </span><span class="s1">* case we need to abort the encoding of arguments since they'll never complete.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createHangingInputAbortSignal(</span><span class="s3">\n  </span><span class="s1">workUnitStore: WorkUnitStore</span><span class="s3">\n</span><span class="s1">): AbortSignal | undefined {</span><span class="s3">\n  </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n    </span><span class="s1">case 'prerender':</span><span class="s3">\n    </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">const controller = new AbortController()</span><span class="s3">\n\n      </span><span class="s1">if (workUnitStore.cacheSignal) {</span><span class="s3">\n        </span><span class="s1">// If we have a cacheSignal it means we're in a prospective render. If</span><span class="s3">\n        </span><span class="s1">// the input we're waiting on is coming from another cache, we do want</span><span class="s3">\n        </span><span class="s1">// to wait for it so that we can resolve this cache entry too.</span><span class="s3">\n        </span><span class="s1">workUnitStore.cacheSignal.inputReady().then(() =&gt; {</span><span class="s3">\n          </span><span class="s1">controller.abort()</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Otherwise we're in the final render and we should already have all</span><span class="s3">\n        </span><span class="s1">// our caches filled.</span><span class="s3">\n        </span><span class="s1">// If the prerender uses stages, we have wait until the runtime stage,</span><span class="s3">\n        </span><span class="s1">// at which point all runtime inputs will be resolved.</span><span class="s3">\n        </span><span class="s1">// (otherwise, a runtime prerender might consider `cookies()` hanging</span><span class="s3">\n        </span><span class="s1">//  even though they'd resolve in the next task.)</span><span class="s3">\n        </span><span class="s1">//</span><span class="s3">\n        </span><span class="s1">// We might still be waiting on some microtasks so we</span><span class="s3">\n        </span><span class="s1">// wait one tick before giving up. When we give up, we still want to</span><span class="s3">\n        </span><span class="s1">// render the content of this cache as deeply as we can so that we can</span><span class="s3">\n        </span><span class="s1">// suspend as deeply as possible in the tree or not at all if we don't</span><span class="s3">\n        </span><span class="s1">// end up waiting for the input.</span><span class="s3">\n        </span><span class="s1">const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)</span><span class="s3">\n        </span><span class="s1">if (runtimeStagePromise) {</span><span class="s3">\n          </span><span class="s1">runtimeStagePromise.then(() =&gt;</span><span class="s3">\n            </span><span class="s1">scheduleOnNextTick(() =&gt; controller.abort())</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">scheduleOnNextTick(() =&gt; controller.abort())</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return controller.signal</span><span class="s3">\n    </span><span class="s1">case 'prerender-client':</span><span class="s3">\n    </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n    </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n    </span><span class="s1">case 'request':</span><span class="s3">\n    </span><span class="s1">case 'cache':</span><span class="s3">\n    </span><span class="s1">case 'private-cache':</span><span class="s3">\n    </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function annotateDynamicAccess(</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const dynamicTracking = prerenderStore.dynamicTracking</span><span class="s3">\n  </span><span class="s1">if (dynamicTracking) {</span><span class="s3">\n    </span><span class="s1">dynamicTracking.dynamicAccesses.push({</span><span class="s3">\n      </span><span class="s1">stack: dynamicTracking.isDebugDynamicAccesses</span><span class="s3">\n        </span><span class="s1">? new Error().stack</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function useDynamicRouteParams(expression: string) {</span><span class="s3">\n  </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workStore &amp;&amp; workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender': {</span><span class="s3">\n        </span><span class="s1">const fallbackParams = workUnitStore.fallbackRouteParams</span><span class="s3">\n        </span><span class="s1">if (fallbackParams &amp;&amp; fallbackParams.size &gt; 0) {</span><span class="s3">\n          </span><span class="s1">// We are in a prerender with cacheComponents semantics. We are going to</span><span class="s3">\n          </span><span class="s1">// hang here and never resolve. This will cause the currently</span><span class="s3">\n          </span><span class="s1">// rendering component to effectively be a dynamic hole.</span><span class="s3">\n          </span><span class="s1">React.use(</span><span class="s3">\n            </span><span class="s1">makeHangingPromise(</span><span class="s3">\n              </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n              </span><span class="s1">workStore.route,</span><span class="s3">\n              </span><span class="s1">expression</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr': {</span><span class="s3">\n        </span><span class="s1">const fallbackParams = workUnitStore.fallbackRouteParams</span><span class="s3">\n        </span><span class="s1">if (fallbackParams &amp;&amp; fallbackParams.size &gt; 0) {</span><span class="s3">\n          </span><span class="s1">return postponeWithTracking(</span><span class="s3">\n            </span><span class="s1">workStore.route,</span><span class="s3">\n            </span><span class="s1">expression,</span><span class="s3">\n            </span><span class="s1">workUnitStore.dynamicTracking</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const hasSuspenseRegex = /</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">s+at Suspense </span><span class="s3">\\</span><span class="s1">(&lt;anonymous&gt;</span><span class="s3">\\</span><span class="s1">)/</span><span class="s3">\n\n</span><span class="s1">// Common implicit body tags that React will treat as body when placed directly in html</span><span class="s3">\n</span><span class="s1">const bodyAndImplicitTags =</span><span class="s3">\n  </span><span class="s1">'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'</span><span class="s3">\n\n</span><span class="s1">// Detects when RootLayoutBoundary (our framework marker component) appears</span><span class="s3">\n</span><span class="s1">// after Suspense in the component stack, indicating the root layout is wrapped</span><span class="s3">\n</span><span class="s1">// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Example matches:</span><span class="s3">\n</span><span class="s1">//   at Suspense (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">//   at __next_root_layout_boundary__ (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Or with other components in between (but not body/html/implicit-body):</span><span class="s3">\n</span><span class="s1">//   at Suspense (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">//   at SomeComponent (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">//   at __next_root_layout_boundary__ (&lt;anonymous&gt;)</span><span class="s3">\n</span><span class="s1">const hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(</span><span class="s3">\n  </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at Suspense </span><span class="s3">\\\\</span><span class="s1">(&lt;anonymous&gt;</span><span class="s3">\\\\</span><span class="s1">)(?:(?!</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at (?:${bodyAndImplicitTags}) </span><span class="s3">\\\\</span><span class="s1">(&lt;anonymous&gt;</span><span class="s3">\\\\</span><span class="s1">))[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S])*?</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at ${ROOT_LAYOUT_BOUNDARY_NAME} </span><span class="s3">\\\\</span><span class="s1">([^</span><span class="s3">\\\\</span><span class="s1">n]*</span><span class="s3">\\\\</span><span class="s1">)`</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">const hasMetadataRegex = new RegExp(</span><span class="s3">\n  </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at ${METADATA_BOUNDARY_NAME}[</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s]`</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const hasViewportRegex = new RegExp(</span><span class="s3">\n  </span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at ${VIEWPORT_BOUNDARY_NAME}[</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s]`</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const hasOutletRegex = new RegExp(`</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s+at ${OUTLET_BOUNDARY_NAME}[</span><span class="s3">\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s]`)</span><span class="s3">\n\n</span><span class="s1">export function trackAllowedDynamicAccess(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">componentStack: string,</span><span class="s3">\n  </span><span class="s1">dynamicValidation: DynamicValidationState,</span><span class="s3">\n  </span><span class="s1">clientDynamic: DynamicTrackingState</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (hasOutletRegex.test(componentStack)) {</span><span class="s3">\n    </span><span class="s1">// We don't need to track that this is dynamic. It is only so when something else is also dynamic.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (hasMetadataRegex.test(componentStack)) {</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasDynamicMetadata = true</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (hasViewportRegex.test(componentStack)) {</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasDynamicViewport = true</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(</span><span class="s3">\n      </span><span class="s1">componentStack</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.</span><span class="s3">\n    </span><span class="s1">// But if you have Suspense above body, the prelude is empty but we allow that because having Suspense</span><span class="s3">\n    </span><span class="s1">// is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasAllowedDynamic = true</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasSuspenseAboveBody = true</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (hasSuspenseRegex.test(componentStack)) {</span><span class="s3">\n    </span><span class="s1">// this error had a Suspense boundary above it so we don't need to report it as a source</span><span class="s3">\n    </span><span class="s1">// of disallowed</span><span class="s3">\n    </span><span class="s1">dynamicValidation.hasAllowedDynamic = true</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else if (clientDynamic.syncDynamicErrorWithStack) {</span><span class="s3">\n    </span><span class="s1">// This task was the task that called the sync error.</span><span class="s3">\n    </span><span class="s1">dynamicValidation.dynamicErrors.push(</span><span class="s3">\n      </span><span class="s1">clientDynamic.syncDynamicErrorWithStack</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const message = `Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot;</span><span class="s1">: A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`</span><span class="s3">\n    </span><span class="s1">const error = createErrorWithComponentOrOwnerStack(message, componentStack)</span><span class="s3">\n    </span><span class="s1">dynamicValidation.dynamicErrors.push(error)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* In dev mode, we prefer using the owner stack, otherwise the provided</span><span class="s3">\n </span><span class="s1">* component stack is used.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createErrorWithComponentOrOwnerStack(</span><span class="s3">\n  </span><span class="s1">message: string,</span><span class="s3">\n  </span><span class="s1">componentStack: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const ownerStack =</span><span class="s3">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; React.captureOwnerStack</span><span class="s3">\n      </span><span class="s1">? React.captureOwnerStack()</span><span class="s3">\n      </span><span class="s1">: null</span><span class="s3">\n\n  </span><span class="s1">const error = new Error(message)</span><span class="s3">\n  </span><span class="s1">error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)</span><span class="s3">\n  </span><span class="s1">return error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export enum PreludeState {</span><span class="s3">\n  </span><span class="s1">Full = 0,</span><span class="s3">\n  </span><span class="s1">Empty = 1,</span><span class="s3">\n  </span><span class="s1">Errored = 2,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function logDisallowedDynamicError(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">error: Error</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">console.error(error)</span><span class="s3">\n\n  </span><span class="s1">if (!workStore.dev) {</span><span class="s3">\n    </span><span class="s1">if (workStore.hasReadableErrorStacks) {</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running </span><span class="s3">\\</span><span class="s1">`next dev</span><span class="s3">\\</span><span class="s1">`, then open </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">in your browser to investigate the error.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:</span><span class="s3">\n  </span><span class="s1">- Start the app in development mode by running </span><span class="s3">\\</span><span class="s1">`next dev</span><span class="s3">\\</span><span class="s1">`, then open </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">in your browser to investigate the error.</span><span class="s3">\n  </span><span class="s1">- Rerun the production build with </span><span class="s3">\\</span><span class="s1">`next build --debug-prerender</span><span class="s3">\\</span><span class="s1">` to generate better stack traces.`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function throwIfDisallowedDynamic(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">prelude: PreludeState,</span><span class="s3">\n  </span><span class="s1">dynamicValidation: DynamicValidationState,</span><span class="s3">\n  </span><span class="s1">serverDynamic: DynamicTrackingState</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">if (prelude !== PreludeState.Full) {</span><span class="s3">\n    </span><span class="s1">if (dynamicValidation.hasSuspenseAboveBody) {</span><span class="s3">\n      </span><span class="s1">// This route has opted into allowing fully dynamic rendering</span><span class="s3">\n      </span><span class="s1">// by including a Suspense boundary above the body. In this case</span><span class="s3">\n      </span><span class="s1">// a lack of a shell is not considered disallowed so we simply return</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (serverDynamic.syncDynamicErrorWithStack) {</span><span class="s3">\n      </span><span class="s1">// There is no shell and the server did something sync dynamic likely</span><span class="s3">\n      </span><span class="s1">// leading to an early termination of the prerender before the shell</span><span class="s3">\n      </span><span class="s1">// could be completed. We terminate the build/validating render.</span><span class="s3">\n      </span><span class="s1">logDisallowedDynamicError(</span><span class="s3">\n        </span><span class="s1">workStore,</span><span class="s3">\n        </span><span class="s1">serverDynamic.syncDynamicErrorWithStack</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We didn't have any sync bailouts but there may be user code which</span><span class="s3">\n    </span><span class="s1">// blocked the root. We would have captured these during the prerender</span><span class="s3">\n    </span><span class="s1">// and can log them here and then terminate the build/validating render</span><span class="s3">\n    </span><span class="s1">const dynamicErrors = dynamicValidation.dynamicErrors</span><span class="s3">\n    </span><span class="s1">if (dynamicErrors.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; dynamicErrors.length; i++) {</span><span class="s3">\n        </span><span class="s1">logDisallowedDynamicError(workStore, dynamicErrors[i])</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we got this far then the only other thing that could be blocking</span><span class="s3">\n    </span><span class="s1">// the root is dynamic Viewport. If this is dynamic then</span><span class="s3">\n    </span><span class="s1">// you need to opt into that by adding a Suspense boundary above the body</span><span class="s3">\n    </span><span class="s1">// to indicate your are ok with fully dynamic rendering.</span><span class="s3">\n    </span><span class="s1">if (dynamicValidation.hasDynamicViewport) {</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">has a </span><span class="s3">\\</span><span class="s1">`generateViewport</span><span class="s3">\\</span><span class="s1">` that depends on Request data (</span><span class="s3">\\</span><span class="s1">`cookies()</span><span class="s3">\\</span><span class="s1">`, etc...) or uncached external data (</span><span class="s3">\\</span><span class="s1">`fetch(...)</span><span class="s3">\\</span><span class="s1">`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (prelude === PreludeState.Empty) {</span><span class="s3">\n      </span><span class="s1">// If we ever get this far then we messed up the tracking of invalid dynamic.</span><span class="s3">\n      </span><span class="s1">// We still adhere to the constraint that you must produce a shell but invite the</span><span class="s3">\n      </span><span class="s1">// user to report this as a bug in Next.js.</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">dynamicValidation.hasAllowedDynamic === false &amp;&amp;</span><span class="s3">\n      </span><span class="s1">dynamicValidation.hasDynamicMetadata</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`Route </span><span class="s3">\&quot;</span><span class="s1">${workStore.route}</span><span class="s3">\&quot; </span><span class="s1">has a </span><span class="s3">\\</span><span class="s1">`generateMetadata</span><span class="s3">\\</span><span class="s1">` that depends on Request data (</span><span class="s3">\\</span><span class="s1">`cookies()</span><span class="s3">\\</span><span class="s1">`, etc...) or uncached external data (</span><span class="s3">\\</span><span class="s1">`fetch(...)</span><span class="s3">\\</span><span class="s1">`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function delayUntilRuntimeStage&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModernRuntime,</span><span class="s3">\n  </span><span class="s1">result: Promise&lt;T&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (prerenderStore.runtimeStagePromise) {</span><span class="s3">\n    </span><span class="s1">return prerenderStore.runtimeStagePromise.then(() =&gt; result)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">WorkAsyncStorage,</span><span class="s3">\n  </span><span class="s1">WorkStore,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">import { AppRenderSpan, NextNodeServerSpan } from './trace/constants'</span><span class="s3">\n</span><span class="s1">import { getTracer, SpanKind } from './trace/tracer'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CACHE_ONE_YEAR,</span><span class="s3">\n  </span><span class="s1">INFINITE_CACHE,</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_TAG_MAX_ITEMS,</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_TAG_MAX_LENGTH,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { markCurrentScopeAsDynamic } from '../app-render/dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import { makeHangingPromise } from '../dynamic-rendering-utils'</span><span class="s3">\n</span><span class="s1">import type { FetchMetric } from '../base-http'</span><span class="s3">\n</span><span class="s1">import { createDedupeFetch } from './dedupe-fetch'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getCacheSignal,</span><span class="s3">\n  </span><span class="s1">type RevalidateStore,</span><span class="s3">\n  </span><span class="s1">type WorkUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedFetchData,</span><span class="s3">\n  </span><span class="s1">type ServerComponentsHmrCache,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../response-cache'</span><span class="s3">\n</span><span class="s1">import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import { cloneResponse } from './clone-response'</span><span class="s3">\n</span><span class="s1">import type { IncrementalCache } from './incremental-cache'</span><span class="s3">\n\n</span><span class="s1">const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'</span><span class="s3">\n\n</span><span class="s1">type Fetcher = typeof fetch</span><span class="s3">\n\n</span><span class="s1">type PatchedFetcher = Fetcher &amp; {</span><span class="s3">\n  </span><span class="s1">readonly __nextPatched: true</span><span class="s3">\n  </span><span class="s1">readonly __nextGetStaticStore: () =&gt; WorkAsyncStorage</span><span class="s3">\n  </span><span class="s1">readonly _nextOriginalFetch: Fetcher</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const NEXT_PATCH_SYMBOL = Symbol.for('next-patch')</span><span class="s3">\n\n</span><span class="s1">function isFetchPatched() {</span><span class="s3">\n  </span><span class="s1">return (globalThis as Record&lt;symbol, unknown&gt;)[NEXT_PATCH_SYMBOL] === true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function validateRevalidate(</span><span class="s3">\n  </span><span class="s1">revalidateVal: unknown,</span><span class="s3">\n  </span><span class="s1">route: string</span><span class="s3">\n</span><span class="s1">): undefined | number {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">let normalizedRevalidate: number | undefined = undefined</span><span class="s3">\n\n    </span><span class="s1">if (revalidateVal === false) {</span><span class="s3">\n      </span><span class="s1">normalizedRevalidate = INFINITE_CACHE</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">typeof revalidateVal === 'number' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isNaN(revalidateVal) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">revalidateVal &gt; -1</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">normalizedRevalidate = revalidateVal</span><span class="s3">\n    </span><span class="s1">} else if (typeof revalidateVal !== 'undefined') {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Invalid revalidate value </span><span class="s3">\&quot;</span><span class="s1">${revalidateVal}</span><span class="s3">\&quot; </span><span class="s1">on </span><span class="s3">\&quot;</span><span class="s1">${route}</span><span class="s3">\&quot;</span><span class="s1">, must be a non-negative number or false`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return normalizedRevalidate</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">// handle client component error from attempting to check revalidate value</span><span class="s3">\n    </span><span class="s1">if (err instanceof Error &amp;&amp; err.message.includes('Invalid revalidate')) {</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function validateTags(tags: any[], description: string) {</span><span class="s3">\n  </span><span class="s1">const validTags: string[] = []</span><span class="s3">\n  </span><span class="s1">const invalidTags: Array&lt;{</span><span class="s3">\n    </span><span class="s1">tag: any</span><span class="s3">\n    </span><span class="s1">reason: string</span><span class="s3">\n  </span><span class="s1">}&gt; = []</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; tags.length; i++) {</span><span class="s3">\n    </span><span class="s1">const tag = tags[i]</span><span class="s3">\n\n    </span><span class="s1">if (typeof tag !== 'string') {</span><span class="s3">\n      </span><span class="s1">invalidTags.push({ tag, reason: 'invalid type, must be a string' })</span><span class="s3">\n    </span><span class="s1">} else if (tag.length &gt; NEXT_CACHE_TAG_MAX_LENGTH) {</span><span class="s3">\n      </span><span class="s1">invalidTags.push({</span><span class="s3">\n        </span><span class="s1">tag,</span><span class="s3">\n        </span><span class="s1">reason: `exceeded max length of ${NEXT_CACHE_TAG_MAX_LENGTH}`,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">validTags.push(tag)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (validTags.length &gt; NEXT_CACHE_TAG_MAX_ITEMS) {</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">`Warning: exceeded max tag count for ${description}, dropped tags:`,</span><span class="s3">\n        </span><span class="s1">tags.slice(i).join(', ')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (invalidTags.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">console.warn(`Warning: invalid tags passed to ${description}: `)</span><span class="s3">\n\n    </span><span class="s1">for (const { tag, reason } of invalidTags) {</span><span class="s3">\n      </span><span class="s1">console.log(`tag: </span><span class="s3">\&quot;</span><span class="s1">${tag}</span><span class="s3">\&quot; </span><span class="s1">${reason}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return validTags</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function trackFetchMetric(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">ctx: Omit&lt;FetchMetric, 'end' | 'idx'&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!workStore.shouldTrackFetchMetrics) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">workStore.fetchMetrics ??= []</span><span class="s3">\n\n  </span><span class="s1">workStore.fetchMetrics.push({</span><span class="s3">\n    </span><span class="s1">...ctx,</span><span class="s3">\n    </span><span class="s1">end: performance.timeOrigin + performance.now(),</span><span class="s3">\n    </span><span class="s1">idx: workStore.nextFetchId || 0,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function createCachedPrerenderResponse(</span><span class="s3">\n  </span><span class="s1">res: Response,</span><span class="s3">\n  </span><span class="s1">cacheKey: string,</span><span class="s3">\n  </span><span class="s1">incrementalCacheContext: SetIncrementalFetchCacheContext | undefined,</span><span class="s3">\n  </span><span class="s1">incrementalCache: IncrementalCache,</span><span class="s3">\n  </span><span class="s1">revalidate: number,</span><span class="s3">\n  </span><span class="s1">handleUnlock: () =&gt; Promise&lt;void&gt; | void</span><span class="s3">\n</span><span class="s1">): Promise&lt;Response&gt; {</span><span class="s3">\n  </span><span class="s1">// We are prerendering at build time or revalidate time with cacheComponents so we</span><span class="s3">\n  </span><span class="s1">// need to buffer the response so we can guarantee it can be read in a</span><span class="s3">\n  </span><span class="s1">// microtask.</span><span class="s3">\n  </span><span class="s1">const bodyBuffer = await res.arrayBuffer()</span><span class="s3">\n\n  </span><span class="s1">const fetchedData = {</span><span class="s3">\n    </span><span class="s1">headers: Object.fromEntries(res.headers.entries()),</span><span class="s3">\n    </span><span class="s1">body: Buffer.from(bodyBuffer).toString('base64'),</span><span class="s3">\n    </span><span class="s1">status: res.status,</span><span class="s3">\n    </span><span class="s1">url: res.url,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We can skip setting the serverComponentsHmrCache because we aren't in dev</span><span class="s3">\n  </span><span class="s1">// mode.</span><span class="s3">\n\n  </span><span class="s1">if (incrementalCacheContext) {</span><span class="s3">\n    </span><span class="s1">await incrementalCache.set(</span><span class="s3">\n      </span><span class="s1">cacheKey,</span><span class="s3">\n      </span><span class="s1">{ kind: CachedRouteKind.FETCH, data: fetchedData, revalidate },</span><span class="s3">\n      </span><span class="s1">incrementalCacheContext</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">await handleUnlock()</span><span class="s3">\n\n  </span><span class="s1">// We return a new Response to the caller.</span><span class="s3">\n  </span><span class="s1">return new Response(bodyBuffer, {</span><span class="s3">\n    </span><span class="s1">headers: res.headers,</span><span class="s3">\n    </span><span class="s1">status: res.status,</span><span class="s3">\n    </span><span class="s1">statusText: res.statusText,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function createCachedDynamicResponse(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">res: Response,</span><span class="s3">\n  </span><span class="s1">cacheKey: string,</span><span class="s3">\n  </span><span class="s1">incrementalCacheContext: SetIncrementalFetchCacheContext | undefined,</span><span class="s3">\n  </span><span class="s1">incrementalCache: IncrementalCache,</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache: ServerComponentsHmrCache | undefined,</span><span class="s3">\n  </span><span class="s1">revalidate: number,</span><span class="s3">\n  </span><span class="s1">input: RequestInfo | URL,</span><span class="s3">\n  </span><span class="s1">handleUnlock: () =&gt; Promise&lt;void&gt; | void</span><span class="s3">\n</span><span class="s1">): Promise&lt;Response&gt; {</span><span class="s3">\n  </span><span class="s1">// We're cloning the response using this utility because there exists a bug in</span><span class="s3">\n  </span><span class="s1">// the undici library around response cloning. See the following pull request</span><span class="s3">\n  </span><span class="s1">// for more details: https://github.com/vercel/next.js/pull/73274</span><span class="s3">\n  </span><span class="s1">const [cloned1, cloned2] = cloneResponse(res)</span><span class="s3">\n\n  </span><span class="s1">// We are dynamically rendering including dev mode. We want to return the</span><span class="s3">\n  </span><span class="s1">// response to the caller as soon as possible because it might stream over a</span><span class="s3">\n  </span><span class="s1">// very long time.</span><span class="s3">\n  </span><span class="s1">const cacheSetPromise = cloned1</span><span class="s3">\n    </span><span class="s1">.arrayBuffer()</span><span class="s3">\n    </span><span class="s1">.then(async (arrayBuffer) =&gt; {</span><span class="s3">\n      </span><span class="s1">const bodyBuffer = Buffer.from(arrayBuffer)</span><span class="s3">\n\n      </span><span class="s1">const fetchedData = {</span><span class="s3">\n        </span><span class="s1">headers: Object.fromEntries(cloned1.headers.entries()),</span><span class="s3">\n        </span><span class="s1">body: bodyBuffer.toString('base64'),</span><span class="s3">\n        </span><span class="s1">status: cloned1.status,</span><span class="s3">\n        </span><span class="s1">url: cloned1.url,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">serverComponentsHmrCache?.set(cacheKey, fetchedData)</span><span class="s3">\n\n      </span><span class="s1">if (incrementalCacheContext) {</span><span class="s3">\n        </span><span class="s1">await incrementalCache.set(</span><span class="s3">\n          </span><span class="s1">cacheKey,</span><span class="s3">\n          </span><span class="s1">{ kind: CachedRouteKind.FETCH, data: fetchedData, revalidate },</span><span class="s3">\n          </span><span class="s1">incrementalCacheContext</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.catch((error) =&gt; console.warn(`Failed to set fetch cache`, input, error))</span><span class="s3">\n    </span><span class="s1">.finally(handleUnlock)</span><span class="s3">\n\n  </span><span class="s1">const pendingRevalidateKey = `cache-set-${cacheKey}`</span><span class="s3">\n  </span><span class="s1">workStore.pendingRevalidates ??= {}</span><span class="s3">\n\n  </span><span class="s1">if (pendingRevalidateKey in workStore.pendingRevalidates) {</span><span class="s3">\n    </span><span class="s1">// there is already a pending revalidate entry that we need to await to</span><span class="s3">\n    </span><span class="s1">// avoid race conditions</span><span class="s3">\n    </span><span class="s1">await workStore.pendingRevalidates[pendingRevalidateKey]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">workStore.pendingRevalidates[pendingRevalidateKey] = cacheSetPromise.finally(</span><span class="s3">\n    </span><span class="s1">() =&gt; {</span><span class="s3">\n      </span><span class="s1">// If the pending revalidate is not present in the store, then we have</span><span class="s3">\n      </span><span class="s1">// nothing to delete.</span><span class="s3">\n      </span><span class="s1">if (!workStore.pendingRevalidates?.[pendingRevalidateKey]) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">delete workStore.pendingRevalidates[pendingRevalidateKey]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return cloned2</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PatchableModule {</span><span class="s3">\n  </span><span class="s1">workAsyncStorage: WorkAsyncStorage</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage: WorkUnitAsyncStorage</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createPatchedFetcher(</span><span class="s3">\n  </span><span class="s1">originFetch: Fetcher,</span><span class="s3">\n  </span><span class="s1">{ workAsyncStorage, workUnitAsyncStorage }: PatchableModule</span><span class="s3">\n</span><span class="s1">): PatchedFetcher {</span><span class="s3">\n  </span><span class="s1">// Create the patched fetch function.</span><span class="s3">\n  </span><span class="s1">const patched = async function fetch(</span><span class="s3">\n    </span><span class="s1">input: RequestInfo | URL,</span><span class="s3">\n    </span><span class="s1">init: RequestInit | undefined</span><span class="s3">\n  </span><span class="s1">): Promise&lt;Response&gt; {</span><span class="s3">\n    </span><span class="s1">let url: URL | undefined</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">url = new URL(input instanceof Request ? input.url : input)</span><span class="s3">\n      </span><span class="s1">url.username = ''</span><span class="s3">\n      </span><span class="s1">url.password = ''</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n      </span><span class="s1">// Error caused by malformed URL should be handled by native fetch</span><span class="s3">\n      </span><span class="s1">url = undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const fetchUrl = url?.href ?? ''</span><span class="s3">\n    </span><span class="s1">const method = init?.method?.toUpperCase() || 'GET'</span><span class="s3">\n\n    </span><span class="s1">// Do create a new span trace for internal fetches in the</span><span class="s3">\n    </span><span class="s1">// non-verbose mode.</span><span class="s3">\n    </span><span class="s1">const isInternal = (init?.next as any)?.internal === true</span><span class="s3">\n    </span><span class="s1">const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1'</span><span class="s3">\n    </span><span class="s1">// We don't track fetch metrics for internal fetches</span><span class="s3">\n    </span><span class="s1">// so it's not critical that we have a start time, as it won't be recorded.</span><span class="s3">\n    </span><span class="s1">// This is to workaround a flaky issue where performance APIs might</span><span class="s3">\n    </span><span class="s1">// not be available and will require follow-up investigation.</span><span class="s3">\n    </span><span class="s1">const fetchStart: number | undefined = isInternal</span><span class="s3">\n      </span><span class="s1">? undefined</span><span class="s3">\n      </span><span class="s1">: performance.timeOrigin + performance.now()</span><span class="s3">\n\n    </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n    </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n\n    </span><span class="s1">// During static generation we track cache reads so we can reason about when they fill</span><span class="s3">\n    </span><span class="s1">let cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null</span><span class="s3">\n    </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n      </span><span class="s1">cacheSignal.beginRead()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const result = getTracer().trace(</span><span class="s3">\n      </span><span class="s1">isInternal ? NextNodeServerSpan.internalFetch : AppRenderSpan.fetch,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">hideSpan,</span><span class="s3">\n        </span><span class="s1">kind: SpanKind.CLIENT,</span><span class="s3">\n        </span><span class="s1">spanName: ['fetch', method, fetchUrl].filter(Boolean).join(' '),</span><span class="s3">\n        </span><span class="s1">attributes: {</span><span class="s3">\n          </span><span class="s1">'http.url': fetchUrl,</span><span class="s3">\n          </span><span class="s1">'http.method': method,</span><span class="s3">\n          </span><span class="s1">'net.peer.name': url?.hostname,</span><span class="s3">\n          </span><span class="s1">'net.peer.port': url?.port || undefined,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">async () =&gt; {</span><span class="s3">\n        </span><span class="s1">// If this is an internal fetch, we should not do any special treatment.</span><span class="s3">\n        </span><span class="s1">if (isInternal) {</span><span class="s3">\n          </span><span class="s1">return originFetch(input, init)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If the workStore is not available, we can't do any</span><span class="s3">\n        </span><span class="s1">// special treatment of fetch, therefore fallback to the original</span><span class="s3">\n        </span><span class="s1">// fetch implementation.</span><span class="s3">\n        </span><span class="s1">if (!workStore) {</span><span class="s3">\n          </span><span class="s1">return originFetch(input, init)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// We should also fallback to the original fetch implementation if we</span><span class="s3">\n        </span><span class="s1">// are in draft mode, it does not constitute a static generation.</span><span class="s3">\n        </span><span class="s1">if (workStore.isDraftMode) {</span><span class="s3">\n          </span><span class="s1">return originFetch(input, init)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const isRequestInput =</span><span class="s3">\n          </span><span class="s1">input &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof input === 'object' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof (input as Request).method === 'string'</span><span class="s3">\n\n        </span><span class="s1">const getRequestMeta = (field: string) =&gt; {</span><span class="s3">\n          </span><span class="s1">// If request input is present but init is not, retrieve from input first.</span><span class="s3">\n          </span><span class="s1">const value = (init as any)?.[field]</span><span class="s3">\n          </span><span class="s1">return value || (isRequestInput ? (input as any)[field] : null)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">let finalRevalidate: number | undefined = undefined</span><span class="s3">\n        </span><span class="s1">const getNextField = (field: 'revalidate' | 'tags') =&gt; {</span><span class="s3">\n          </span><span class="s1">return typeof init?.next?.[field] !== 'undefined'</span><span class="s3">\n            </span><span class="s1">? init?.next?.[field]</span><span class="s3">\n            </span><span class="s1">: isRequestInput</span><span class="s3">\n              </span><span class="s1">? (input as any).next?.[field]</span><span class="s3">\n              </span><span class="s1">: undefined</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// RequestInit doesn't keep extra fields e.g. next so it's</span><span class="s3">\n        </span><span class="s1">// only available if init is used separate</span><span class="s3">\n        </span><span class="s1">const originalFetchRevalidate = getNextField('revalidate')</span><span class="s3">\n        </span><span class="s1">let currentFetchRevalidate = originalFetchRevalidate</span><span class="s3">\n        </span><span class="s1">const tags: string[] = validateTags(</span><span class="s3">\n          </span><span class="s1">getNextField('tags') || [],</span><span class="s3">\n          </span><span class="s1">`fetch ${input.toString()}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">let revalidateStore: RevalidateStore | undefined</span><span class="s3">\n\n        </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n          </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n            </span><span class="s1">case 'prerender':</span><span class="s3">\n            </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n            </span><span class="s1">// TODO: Stop accumulating tags in client prerender. (fallthrough)</span><span class="s3">\n            </span><span class="s1">case 'prerender-client':</span><span class="s3">\n            </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n            </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n            </span><span class="s1">case 'cache':</span><span class="s3">\n            </span><span class="s1">case 'private-cache':</span><span class="s3">\n              </span><span class="s1">revalidateStore = workUnitStore</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">case 'request':</span><span class="s3">\n            </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n              </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (revalidateStore) {</span><span class="s3">\n          </span><span class="s1">if (Array.isArray(tags)) {</span><span class="s3">\n            </span><span class="s1">// Collect tags onto parent caches or parent prerenders.</span><span class="s3">\n            </span><span class="s1">const collectedTags =</span><span class="s3">\n              </span><span class="s1">revalidateStore.tags ?? (revalidateStore.tags = [])</span><span class="s3">\n            </span><span class="s1">for (const tag of tags) {</span><span class="s3">\n              </span><span class="s1">if (!collectedTags.includes(tag)) {</span><span class="s3">\n                </span><span class="s1">collectedTags.push(tag)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const implicitTags = workUnitStore?.implicitTags</span><span class="s3">\n\n        </span><span class="s1">let pageFetchCacheMode = workStore.fetchCache</span><span class="s3">\n\n        </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n          </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n            </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n              </span><span class="s1">// Inside unstable-cache we treat it the same as force-no-store on</span><span class="s3">\n              </span><span class="s1">// the page.</span><span class="s3">\n              </span><span class="s1">pageFetchCacheMode = 'force-no-store'</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">case 'prerender':</span><span class="s3">\n            </span><span class="s1">case 'prerender-client':</span><span class="s3">\n            </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n            </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n            </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n            </span><span class="s1">case 'request':</span><span class="s3">\n            </span><span class="s1">case 'cache':</span><span class="s3">\n            </span><span class="s1">case 'private-cache':</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n              </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const isUsingNoStore = !!workStore.isUnstableNoStore</span><span class="s3">\n\n        </span><span class="s1">let currentFetchCacheConfig = getRequestMeta('cache')</span><span class="s3">\n        </span><span class="s1">let cacheReason = ''</span><span class="s3">\n        </span><span class="s1">let cacheWarning: string | undefined</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">typeof currentFetchCacheConfig === 'string' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof currentFetchRevalidate !== 'undefined'</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// If the revalidate value conflicts with the cache value, we should warn the user and unset the conflicting values.</span><span class="s3">\n          </span><span class="s1">const isConflictingRevalidate =</span><span class="s3">\n            </span><span class="s1">// revalidate: 0 and cache: force-cache</span><span class="s3">\n            </span><span class="s1">(currentFetchCacheConfig === 'force-cache' &amp;&amp;</span><span class="s3">\n              </span><span class="s1">currentFetchRevalidate === 0) ||</span><span class="s3">\n            </span><span class="s1">// revalidate: &gt;0 or revalidate: false and cache: no-store</span><span class="s3">\n            </span><span class="s1">(currentFetchCacheConfig === 'no-store' &amp;&amp;</span><span class="s3">\n              </span><span class="s1">(currentFetchRevalidate &gt; 0 || currentFetchRevalidate === false))</span><span class="s3">\n\n          </span><span class="s1">if (isConflictingRevalidate) {</span><span class="s3">\n            </span><span class="s1">cacheWarning = `Specified </span><span class="s3">\&quot;</span><span class="s1">cache: ${currentFetchCacheConfig}</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">revalidate: ${currentFetchRevalidate}</span><span class="s3">\&quot;</span><span class="s1">, only one should be specified.`</span><span class="s3">\n            </span><span class="s1">currentFetchCacheConfig = undefined</span><span class="s3">\n            </span><span class="s1">currentFetchRevalidate = undefined</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const hasExplicitFetchCacheOptOut =</span><span class="s3">\n          </span><span class="s1">// fetch config itself signals not to cache</span><span class="s3">\n          </span><span class="s1">currentFetchCacheConfig === 'no-cache' ||</span><span class="s3">\n          </span><span class="s1">currentFetchCacheConfig === 'no-store' ||</span><span class="s3">\n          </span><span class="s1">// the fetch isn't explicitly caching and the segment level cache config signals not to cache</span><span class="s3">\n          </span><span class="s1">// note: `pageFetchCacheMode` is also set by being in an unstable_cache context.</span><span class="s3">\n          </span><span class="s1">pageFetchCacheMode === 'force-no-store' ||</span><span class="s3">\n          </span><span class="s1">pageFetchCacheMode === 'only-no-store'</span><span class="s3">\n\n        </span><span class="s1">// If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,</span><span class="s3">\n        </span><span class="s1">// we shouldn't consider caching the fetch. This is because the `dynamic` cache</span><span class="s3">\n        </span><span class="s1">// is considered a </span><span class="s3">\&quot;</span><span class="s1">top-level</span><span class="s3">\&quot; </span><span class="s1">cache mode, whereas something like `fetchCache` is more</span><span class="s3">\n        </span><span class="s1">// fine-grained. Top-level modes are responsible for setting reasonable defaults for the</span><span class="s3">\n        </span><span class="s1">// other configurations.</span><span class="s3">\n        </span><span class="s1">const noFetchConfigAndForceDynamic =</span><span class="s3">\n          </span><span class="s1">!pageFetchCacheMode &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!currentFetchCacheConfig &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!currentFetchRevalidate &amp;&amp;</span><span class="s3">\n          </span><span class="s1">workStore.forceDynamic</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">// force-cache was specified without a revalidate value. We set the revalidate value to false</span><span class="s3">\n          </span><span class="s1">// which will signal the cache to not revalidate</span><span class="s3">\n          </span><span class="s1">currentFetchCacheConfig === 'force-cache' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof currentFetchRevalidate === 'undefined'</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">currentFetchRevalidate = false</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          </span><span class="s1">hasExplicitFetchCacheOptOut ||</span><span class="s3">\n          </span><span class="s1">noFetchConfigAndForceDynamic</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">currentFetchRevalidate = 0</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">currentFetchCacheConfig === 'no-cache' ||</span><span class="s3">\n          </span><span class="s1">currentFetchCacheConfig === 'no-store'</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">cacheReason = `cache: ${currentFetchCacheConfig}`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">finalRevalidate = validateRevalidate(</span><span class="s3">\n          </span><span class="s1">currentFetchRevalidate,</span><span class="s3">\n          </span><span class="s1">workStore.route</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">const _headers = getRequestMeta('headers')</span><span class="s3">\n        </span><span class="s1">const initHeaders: Headers =</span><span class="s3">\n          </span><span class="s1">typeof _headers?.get === 'function'</span><span class="s3">\n            </span><span class="s1">? _headers</span><span class="s3">\n            </span><span class="s1">: new Headers(_headers || {})</span><span class="s3">\n\n        </span><span class="s1">const hasUnCacheableHeader =</span><span class="s3">\n          </span><span class="s1">initHeaders.get('authorization') || initHeaders.get('cookie')</span><span class="s3">\n\n        </span><span class="s1">const isUnCacheableMethod = !['get', 'head'].includes(</span><span class="s3">\n          </span><span class="s1">getRequestMeta('method')?.toLowerCase() || 'get'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* We automatically disable fetch caching under the following conditions:</span><span class="s3">\n         </span><span class="s1">* - Fetch cache configs are not set. Specifically:</span><span class="s3">\n         </span><span class="s1">*    - A page fetch cache mode is not set (export const fetchCache=...)</span><span class="s3">\n         </span><span class="s1">*    - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ... }))</span><span class="s3">\n         </span><span class="s1">*      or the fetch cache mode is set to 'default'</span><span class="s3">\n         </span><span class="s1">*    - A fetch revalidate value is not set in the fetch call (fetch(url, { revalidate: ... }))</span><span class="s3">\n         </span><span class="s1">* - OR the fetch comes after a configuration that triggered dynamic rendering (e.g., reading cookies())</span><span class="s3">\n         </span><span class="s1">*   and the fetch was considered uncacheable (e.g., POST method or has authorization headers)</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const hasNoExplicitCacheConfig =</span><span class="s3">\n          </span><span class="s1">// eslint-disable-next-line eqeqeq</span><span class="s3">\n          </span><span class="s1">pageFetchCacheMode == undefined &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// eslint-disable-next-line eqeqeq</span><span class="s3">\n          </span><span class="s1">(currentFetchCacheConfig == undefined ||</span><span class="s3">\n            </span><span class="s1">// when considering whether to opt into the default </span><span class="s3">\&quot;</span><span class="s1">no-cache</span><span class="s3">\&quot; </span><span class="s1">fetch semantics,</span><span class="s3">\n            </span><span class="s1">// a </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache config should be treated the same as no cache config</span><span class="s3">\n            </span><span class="s1">currentFetchCacheConfig === 'default') &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// eslint-disable-next-line eqeqeq</span><span class="s3">\n          </span><span class="s1">currentFetchRevalidate == undefined</span><span class="s3">\n\n        </span><span class="s1">let autoNoCache = Boolean(</span><span class="s3">\n          </span><span class="s1">(hasUnCacheableHeader || isUnCacheableMethod) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">revalidateStore?.revalidate === 0</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">let isImplicitBuildTimeCache = false</span><span class="s3">\n\n        </span><span class="s1">if (!autoNoCache &amp;&amp; hasNoExplicitCacheConfig) {</span><span class="s3">\n          </span><span class="s1">// We don't enable automatic no-cache behavior during build-time</span><span class="s3">\n          </span><span class="s1">// prerendering so that we can still leverage the fetch cache between</span><span class="s3">\n          </span><span class="s1">// export workers.</span><span class="s3">\n          </span><span class="s1">if (workStore.isBuildTimePrerendering) {</span><span class="s3">\n            </span><span class="s1">isImplicitBuildTimeCache = true</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">autoNoCache = true</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If we have no cache config, and we're in Dynamic I/O prerendering,</span><span class="s3">\n        </span><span class="s1">// it'll be a dynamic call. We don't have to issue that dynamic call.</span><span class="s3">\n        </span><span class="s1">if (hasNoExplicitCacheConfig &amp;&amp; workUnitStore !== undefined) {</span><span class="s3">\n          </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n            </span><span class="s1">case 'prerender':</span><span class="s3">\n            </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n            </span><span class="s1">// While we don't want to do caching in the client scope we know the</span><span class="s3">\n            </span><span class="s1">// fetch will be dynamic for cacheComponents so we may as well avoid the</span><span class="s3">\n            </span><span class="s1">// call here. (fallthrough)</span><span class="s3">\n            </span><span class="s1">case 'prerender-client':</span><span class="s3">\n              </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n                </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n                </span><span class="s1">cacheSignal = null</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">return makeHangingPromise&lt;Response&gt;(</span><span class="s3">\n                </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                </span><span class="s1">workStore.route,</span><span class="s3">\n                </span><span class="s1">'fetch()'</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n            </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n            </span><span class="s1">case 'request':</span><span class="s3">\n            </span><span class="s1">case 'cache':</span><span class="s3">\n            </span><span class="s1">case 'private-cache':</span><span class="s3">\n            </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n              </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">switch (pageFetchCacheMode) {</span><span class="s3">\n          </span><span class="s1">case 'force-no-store': {</span><span class="s3">\n            </span><span class="s1">cacheReason = 'fetchCache = force-no-store'</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case 'only-no-store': {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">currentFetchCacheConfig === 'force-cache' ||</span><span class="s3">\n              </span><span class="s1">(typeof finalRevalidate !== 'undefined' &amp;&amp; finalRevalidate &gt; 0)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">throw new Error(</span><span class="s3">\n                </span><span class="s1">`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">cacheReason = 'fetchCache = only-no-store'</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case 'only-cache': {</span><span class="s3">\n            </span><span class="s1">if (currentFetchCacheConfig === 'no-store') {</span><span class="s3">\n              </span><span class="s1">throw new Error(</span><span class="s3">\n                </span><span class="s1">`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case 'force-cache': {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">typeof currentFetchRevalidate === 'undefined' ||</span><span class="s3">\n              </span><span class="s1">currentFetchRevalidate === 0</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">cacheReason = 'fetchCache = force-cache'</span><span class="s3">\n              </span><span class="s1">finalRevalidate = INFINITE_CACHE</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case 'default-cache':</span><span class="s3">\n          </span><span class="s1">case 'default-no-store':</span><span class="s3">\n          </span><span class="s1">case 'auto':</span><span class="s3">\n          </span><span class="s1">case undefined:</span><span class="s3">\n            </span><span class="s1">// sometimes we won't match the above cases. the reason we don't move</span><span class="s3">\n            </span><span class="s1">// everything to this switch is the use of autoNoCache which is not a fetchCacheMode</span><span class="s3">\n            </span><span class="s1">// I suspect this could be unified with fetchCacheMode however in which case we could</span><span class="s3">\n            </span><span class="s1">// simplify the switch case and ensure we have an exhaustive switch handling all modes</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">pageFetchCacheMode satisfies never</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (typeof finalRevalidate === 'undefined') {</span><span class="s3">\n          </span><span class="s1">if (pageFetchCacheMode === 'default-cache' &amp;&amp; !isUsingNoStore) {</span><span class="s3">\n            </span><span class="s1">finalRevalidate = INFINITE_CACHE</span><span class="s3">\n            </span><span class="s1">cacheReason = 'fetchCache = default-cache'</span><span class="s3">\n          </span><span class="s1">} else if (pageFetchCacheMode === 'default-no-store') {</span><span class="s3">\n            </span><span class="s1">finalRevalidate = 0</span><span class="s3">\n            </span><span class="s1">cacheReason = 'fetchCache = default-no-store'</span><span class="s3">\n          </span><span class="s1">} else if (isUsingNoStore) {</span><span class="s3">\n            </span><span class="s1">finalRevalidate = 0</span><span class="s3">\n            </span><span class="s1">cacheReason = 'noStore call'</span><span class="s3">\n          </span><span class="s1">} else if (autoNoCache) {</span><span class="s3">\n            </span><span class="s1">finalRevalidate = 0</span><span class="s3">\n            </span><span class="s1">cacheReason = 'auto no cache'</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// TODO: should we consider this case an invariant?</span><span class="s3">\n            </span><span class="s1">cacheReason = 'auto cache'</span><span class="s3">\n            </span><span class="s1">finalRevalidate = revalidateStore</span><span class="s3">\n              </span><span class="s1">? revalidateStore.revalidate</span><span class="s3">\n              </span><span class="s1">: INFINITE_CACHE</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (!cacheReason) {</span><span class="s3">\n          </span><span class="s1">cacheReason = `revalidate: ${finalRevalidate}`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">// when force static is configured we don't bail from</span><span class="s3">\n          </span><span class="s1">// `revalidate: 0` values</span><span class="s3">\n          </span><span class="s1">!(workStore.forceStatic &amp;&amp; finalRevalidate === 0) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// we don't consider autoNoCache to switch to dynamic for ISR</span><span class="s3">\n          </span><span class="s1">!autoNoCache &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// If the revalidate value isn't currently set or the value is less</span><span class="s3">\n          </span><span class="s1">// than the current revalidate value, we should update the revalidate</span><span class="s3">\n          </span><span class="s1">// value.</span><span class="s3">\n          </span><span class="s1">revalidateStore &amp;&amp;</span><span class="s3">\n          </span><span class="s1">finalRevalidate &lt; revalidateStore.revalidate</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// If we were setting the revalidate value to 0, we should try to</span><span class="s3">\n          </span><span class="s1">// postpone instead first.</span><span class="s3">\n          </span><span class="s1">if (finalRevalidate === 0) {</span><span class="s3">\n            </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n              </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n                </span><span class="s1">case 'prerender':</span><span class="s3">\n                </span><span class="s1">case 'prerender-client':</span><span class="s3">\n                </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n                  </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n                    </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n                    </span><span class="s1">cacheSignal = null</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">return makeHangingPromise&lt;Response&gt;(</span><span class="s3">\n                    </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                    </span><span class="s1">workStore.route,</span><span class="s3">\n                    </span><span class="s1">'fetch()'</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n                </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n                </span><span class="s1">case 'request':</span><span class="s3">\n                </span><span class="s1">case 'cache':</span><span class="s3">\n                </span><span class="s1">case 'private-cache':</span><span class="s3">\n                </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n                  </span><span class="s1">break</span><span class="s3">\n                </span><span class="s1">default:</span><span class="s3">\n                  </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">markCurrentScopeAsDynamic(</span><span class="s3">\n              </span><span class="s1">workStore,</span><span class="s3">\n              </span><span class="s1">workUnitStore,</span><span class="s3">\n              </span><span class="s1">`revalidate: 0 fetch ${input} ${workStore.route}`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// We only want to set the revalidate store's revalidate time if it</span><span class="s3">\n          </span><span class="s1">// was explicitly set for the fetch call, i.e.</span><span class="s3">\n          </span><span class="s1">// originalFetchRevalidate.</span><span class="s3">\n          </span><span class="s1">if (revalidateStore &amp;&amp; originalFetchRevalidate === finalRevalidate) {</span><span class="s3">\n            </span><span class="s1">revalidateStore.revalidate = finalRevalidate</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const isCacheableRevalidate =</span><span class="s3">\n          </span><span class="s1">typeof finalRevalidate === 'number' &amp;&amp; finalRevalidate &gt; 0</span><span class="s3">\n\n        </span><span class="s1">let cacheKey: string | undefined</span><span class="s3">\n        </span><span class="s1">const { incrementalCache } = workStore</span><span class="s3">\n        </span><span class="s1">let isHmrRefresh = false</span><span class="s3">\n        </span><span class="s1">let serverComponentsHmrCache: ServerComponentsHmrCache | undefined</span><span class="s3">\n\n        </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n          </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n            </span><span class="s1">case 'request':</span><span class="s3">\n            </span><span class="s1">case 'cache':</span><span class="s3">\n            </span><span class="s1">case 'private-cache':</span><span class="s3">\n              </span><span class="s1">isHmrRefresh = workUnitStore.isHmrRefresh ?? false</span><span class="s3">\n              </span><span class="s1">serverComponentsHmrCache = workUnitStore.serverComponentsHmrCache</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">case 'prerender':</span><span class="s3">\n            </span><span class="s1">case 'prerender-client':</span><span class="s3">\n            </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n            </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n            </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n            </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n              </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">incrementalCache &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(isCacheableRevalidate || serverComponentsHmrCache)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">cacheKey = await incrementalCache.generateCacheKey(</span><span class="s3">\n              </span><span class="s1">fetchUrl,</span><span class="s3">\n              </span><span class="s1">isRequestInput ? (input as RequestInit) : init</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">console.error(`Failed to generate cache key for`, input)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const fetchIdx = workStore.nextFetchId ?? 1</span><span class="s3">\n        </span><span class="s1">workStore.nextFetchId = fetchIdx + 1</span><span class="s3">\n\n        </span><span class="s1">let handleUnlock: () =&gt; Promise&lt;void&gt; | void = () =&gt; {}</span><span class="s3">\n\n        </span><span class="s1">const doOriginalFetch = async (</span><span class="s3">\n          </span><span class="s1">isStale?: boolean,</span><span class="s3">\n          </span><span class="s1">cacheReasonOverride?: string</span><span class="s3">\n        </span><span class="s1">) =&gt; {</span><span class="s3">\n          </span><span class="s1">const requestInputFields = [</span><span class="s3">\n            </span><span class="s1">'cache',</span><span class="s3">\n            </span><span class="s1">'credentials',</span><span class="s3">\n            </span><span class="s1">'headers',</span><span class="s3">\n            </span><span class="s1">'integrity',</span><span class="s3">\n            </span><span class="s1">'keepalive',</span><span class="s3">\n            </span><span class="s1">'method',</span><span class="s3">\n            </span><span class="s1">'mode',</span><span class="s3">\n            </span><span class="s1">'redirect',</span><span class="s3">\n            </span><span class="s1">'referrer',</span><span class="s3">\n            </span><span class="s1">'referrerPolicy',</span><span class="s3">\n            </span><span class="s1">'window',</span><span class="s3">\n            </span><span class="s1">'duplex',</span><span class="s3">\n\n            </span><span class="s1">// don't pass through signal when revalidating</span><span class="s3">\n            </span><span class="s1">...(isStale ? [] : ['signal']),</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n\n          </span><span class="s1">if (isRequestInput) {</span><span class="s3">\n            </span><span class="s1">const reqInput: Request = input as any</span><span class="s3">\n            </span><span class="s1">const reqOptions: RequestInit = {</span><span class="s3">\n              </span><span class="s1">body: (reqInput as any)._ogBody || reqInput.body,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">for (const field of requestInputFields) {</span><span class="s3">\n              </span><span class="s1">// @ts-expect-error custom fields</span><span class="s3">\n              </span><span class="s1">reqOptions[field] = reqInput[field]</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">input = new Request(reqInput.url, reqOptions)</span><span class="s3">\n          </span><span class="s1">} else if (init) {</span><span class="s3">\n            </span><span class="s1">const { _ogBody, body, signal, ...otherInput } =</span><span class="s3">\n              </span><span class="s1">init as RequestInit &amp; { _ogBody?: any }</span><span class="s3">\n            </span><span class="s1">init = {</span><span class="s3">\n              </span><span class="s1">...otherInput,</span><span class="s3">\n              </span><span class="s1">body: _ogBody || body,</span><span class="s3">\n              </span><span class="s1">signal: isStale ? undefined : signal,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// add metadata to init without editing the original</span><span class="s3">\n          </span><span class="s1">const clonedInit = {</span><span class="s3">\n            </span><span class="s1">...init,</span><span class="s3">\n            </span><span class="s1">next: { ...init?.next, fetchType: 'origin', fetchIdx },</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return originFetch(input, clonedInit)</span><span class="s3">\n            </span><span class="s1">.then(async (res) =&gt; {</span><span class="s3">\n              </span><span class="s1">if (!isStale &amp;&amp; fetchStart) {</span><span class="s3">\n                </span><span class="s1">trackFetchMetric(workStore, {</span><span class="s3">\n                  </span><span class="s1">start: fetchStart,</span><span class="s3">\n                  </span><span class="s1">url: fetchUrl,</span><span class="s3">\n                  </span><span class="s1">cacheReason: cacheReasonOverride || cacheReason,</span><span class="s3">\n                  </span><span class="s1">cacheStatus:</span><span class="s3">\n                    </span><span class="s1">finalRevalidate === 0 || cacheReasonOverride</span><span class="s3">\n                      </span><span class="s1">? 'skip'</span><span class="s3">\n                      </span><span class="s1">: 'miss',</span><span class="s3">\n                  </span><span class="s1">cacheWarning,</span><span class="s3">\n                  </span><span class="s1">status: res.status,</span><span class="s3">\n                  </span><span class="s1">method: clonedInit.method || 'GET',</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">res.status === 200 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">incrementalCache &amp;&amp;</span><span class="s3">\n                </span><span class="s1">cacheKey &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(isCacheableRevalidate || serverComponentsHmrCache)</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">const normalizedRevalidate =</span><span class="s3">\n                  </span><span class="s1">finalRevalidate &gt;= INFINITE_CACHE</span><span class="s3">\n                    </span><span class="s1">? CACHE_ONE_YEAR</span><span class="s3">\n                    </span><span class="s1">: finalRevalidate</span><span class="s3">\n\n                </span><span class="s1">const incrementalCacheConfig:</span><span class="s3">\n                  </span><span class="s1">| SetIncrementalFetchCacheContext</span><span class="s3">\n                  </span><span class="s1">| undefined = isCacheableRevalidate</span><span class="s3">\n                  </span><span class="s1">? {</span><span class="s3">\n                      </span><span class="s1">fetchCache: true,</span><span class="s3">\n                      </span><span class="s1">fetchUrl,</span><span class="s3">\n                      </span><span class="s1">fetchIdx,</span><span class="s3">\n                      </span><span class="s1">tags,</span><span class="s3">\n                      </span><span class="s1">isImplicitBuildTimeCache,</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">: undefined</span><span class="s3">\n\n                </span><span class="s1">switch (workUnitStore?.type) {</span><span class="s3">\n                  </span><span class="s1">case 'prerender':</span><span class="s3">\n                  </span><span class="s1">case 'prerender-client':</span><span class="s3">\n                  </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n                    </span><span class="s1">return createCachedPrerenderResponse(</span><span class="s3">\n                      </span><span class="s1">res,</span><span class="s3">\n                      </span><span class="s1">cacheKey,</span><span class="s3">\n                      </span><span class="s1">incrementalCacheConfig,</span><span class="s3">\n                      </span><span class="s1">incrementalCache,</span><span class="s3">\n                      </span><span class="s1">normalizedRevalidate,</span><span class="s3">\n                      </span><span class="s1">handleUnlock</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n                  </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n                  </span><span class="s1">case 'request':</span><span class="s3">\n                  </span><span class="s1">case 'cache':</span><span class="s3">\n                  </span><span class="s1">case 'private-cache':</span><span class="s3">\n                  </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n                  </span><span class="s1">case undefined:</span><span class="s3">\n                    </span><span class="s1">return createCachedDynamicResponse(</span><span class="s3">\n                      </span><span class="s1">workStore,</span><span class="s3">\n                      </span><span class="s1">res,</span><span class="s3">\n                      </span><span class="s1">cacheKey,</span><span class="s3">\n                      </span><span class="s1">incrementalCacheConfig,</span><span class="s3">\n                      </span><span class="s1">incrementalCache,</span><span class="s3">\n                      </span><span class="s1">serverComponentsHmrCache,</span><span class="s3">\n                      </span><span class="s1">normalizedRevalidate,</span><span class="s3">\n                      </span><span class="s1">input,</span><span class="s3">\n                      </span><span class="s1">handleUnlock</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">default:</span><span class="s3">\n                    </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">// we had response that we determined shouldn't be cached so we return it</span><span class="s3">\n              </span><span class="s1">// and don't cache it. This also needs to unlock the cache lock we acquired.</span><span class="s3">\n              </span><span class="s1">await handleUnlock()</span><span class="s3">\n\n              </span><span class="s1">return res</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">.catch((error) =&gt; {</span><span class="s3">\n              </span><span class="s1">handleUnlock()</span><span class="s3">\n              </span><span class="s1">throw error</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">let cacheReasonOverride</span><span class="s3">\n        </span><span class="s1">let isForegroundRevalidate = false</span><span class="s3">\n        </span><span class="s1">let isHmrRefreshCache = false</span><span class="s3">\n\n        </span><span class="s1">if (cacheKey &amp;&amp; incrementalCache) {</span><span class="s3">\n          </span><span class="s1">let cachedFetchData: CachedFetchData | undefined</span><span class="s3">\n\n          </span><span class="s1">if (isHmrRefresh &amp;&amp; serverComponentsHmrCache) {</span><span class="s3">\n            </span><span class="s1">cachedFetchData = serverComponentsHmrCache.get(cacheKey)</span><span class="s3">\n            </span><span class="s1">isHmrRefreshCache = true</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (isCacheableRevalidate &amp;&amp; !cachedFetchData) {</span><span class="s3">\n            </span><span class="s1">handleUnlock = await incrementalCache.lock(cacheKey)</span><span class="s3">\n            </span><span class="s1">const entry = workStore.isOnDemandRevalidate</span><span class="s3">\n              </span><span class="s1">? null</span><span class="s3">\n              </span><span class="s1">: await incrementalCache.get(cacheKey, {</span><span class="s3">\n                  </span><span class="s1">kind: IncrementalCacheKind.FETCH,</span><span class="s3">\n                  </span><span class="s1">revalidate: finalRevalidate,</span><span class="s3">\n                  </span><span class="s1">fetchUrl,</span><span class="s3">\n                  </span><span class="s1">fetchIdx,</span><span class="s3">\n                  </span><span class="s1">tags,</span><span class="s3">\n                  </span><span class="s1">softTags: implicitTags?.tags,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">if (hasNoExplicitCacheConfig &amp;&amp; workUnitStore) {</span><span class="s3">\n              </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n                </span><span class="s1">case 'prerender':</span><span class="s3">\n                </span><span class="s1">case 'prerender-client':</span><span class="s3">\n                </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n                  </span><span class="s1">// We sometimes use the cache to dedupe fetches that do not</span><span class="s3">\n                  </span><span class="s1">// specify a cache configuration. In these cases we want to</span><span class="s3">\n                  </span><span class="s1">// make sure we still exclude them from prerenders if</span><span class="s3">\n                  </span><span class="s1">// cacheComponents is on so we introduce an artificial task boundary</span><span class="s3">\n                  </span><span class="s1">// here.</span><span class="s3">\n                  </span><span class="s1">await waitAtLeastOneReactRenderTask()</span><span class="s3">\n                  </span><span class="s1">break</span><span class="s3">\n                </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n                </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n                </span><span class="s1">case 'request':</span><span class="s3">\n                </span><span class="s1">case 'cache':</span><span class="s3">\n                </span><span class="s1">case 'private-cache':</span><span class="s3">\n                </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n                  </span><span class="s1">break</span><span class="s3">\n                </span><span class="s1">default:</span><span class="s3">\n                  </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (entry) {</span><span class="s3">\n              </span><span class="s1">await handleUnlock()</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers</span><span class="s3">\n              </span><span class="s1">cacheReasonOverride = 'cache-control: no-cache (hard refresh)'</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (entry?.value &amp;&amp; entry.value.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n              </span><span class="s1">// when stale and is revalidating we wait for fresh data</span><span class="s3">\n              </span><span class="s1">// so the revalidated entry has the updated data</span><span class="s3">\n              </span><span class="s1">if (workStore.isRevalidate &amp;&amp; entry.isStale) {</span><span class="s3">\n                </span><span class="s1">isForegroundRevalidate = true</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">if (entry.isStale) {</span><span class="s3">\n                  </span><span class="s1">workStore.pendingRevalidates ??= {}</span><span class="s3">\n                  </span><span class="s1">if (!workStore.pendingRevalidates[cacheKey]) {</span><span class="s3">\n                    </span><span class="s1">const pendingRevalidate = doOriginalFetch(true)</span><span class="s3">\n                      </span><span class="s1">.then(async (response) =&gt; ({</span><span class="s3">\n                        </span><span class="s1">body: await response.arrayBuffer(),</span><span class="s3">\n                        </span><span class="s1">headers: response.headers,</span><span class="s3">\n                        </span><span class="s1">status: response.status,</span><span class="s3">\n                        </span><span class="s1">statusText: response.statusText,</span><span class="s3">\n                      </span><span class="s1">}))</span><span class="s3">\n                      </span><span class="s1">.finally(() =&gt; {</span><span class="s3">\n                        </span><span class="s1">workStore.pendingRevalidates ??= {}</span><span class="s3">\n                        </span><span class="s1">delete workStore.pendingRevalidates[cacheKey || '']</span><span class="s3">\n                      </span><span class="s1">})</span><span class="s3">\n\n                    </span><span class="s1">// Attach the empty catch here so we don't get a </span><span class="s3">\&quot;</span><span class="s1">unhandled</span><span class="s3">\n                    </span><span class="s1">// promise rejection</span><span class="s3">\&quot; </span><span class="s1">warning.</span><span class="s3">\n                    </span><span class="s1">pendingRevalidate.catch(console.error)</span><span class="s3">\n\n                    </span><span class="s1">workStore.pendingRevalidates[cacheKey] = pendingRevalidate</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">cachedFetchData = entry.value.data</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (cachedFetchData) {</span><span class="s3">\n            </span><span class="s1">if (fetchStart) {</span><span class="s3">\n              </span><span class="s1">trackFetchMetric(workStore, {</span><span class="s3">\n                </span><span class="s1">start: fetchStart,</span><span class="s3">\n                </span><span class="s1">url: fetchUrl,</span><span class="s3">\n                </span><span class="s1">cacheReason,</span><span class="s3">\n                </span><span class="s1">cacheStatus: isHmrRefreshCache ? 'hmr' : 'hit',</span><span class="s3">\n                </span><span class="s1">cacheWarning,</span><span class="s3">\n                </span><span class="s1">status: cachedFetchData.status || 200,</span><span class="s3">\n                </span><span class="s1">method: init?.method || 'GET',</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const response = new Response(</span><span class="s3">\n              </span><span class="s1">Buffer.from(cachedFetchData.body, 'base64'),</span><span class="s3">\n              </span><span class="s1">{</span><span class="s3">\n                </span><span class="s1">headers: cachedFetchData.headers,</span><span class="s3">\n                </span><span class="s1">status: cachedFetchData.status,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">Object.defineProperty(response, 'url', {</span><span class="s3">\n              </span><span class="s1">value: cachedFetchData.url,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">return response</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (workStore.isStaticGeneration &amp;&amp; init &amp;&amp; typeof init === 'object') {</span><span class="s3">\n          </span><span class="s1">const { cache } = init</span><span class="s3">\n\n          </span><span class="s1">// Delete `cache` property as Cloudflare Workers will throw an error</span><span class="s3">\n          </span><span class="s1">if (isEdgeRuntime) delete init.cache</span><span class="s3">\n\n          </span><span class="s1">if (cache === 'no-store') {</span><span class="s3">\n            </span><span class="s1">// If enabled, we should bail out of static generation.</span><span class="s3">\n            </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n              </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n                </span><span class="s1">case 'prerender':</span><span class="s3">\n                </span><span class="s1">case 'prerender-client':</span><span class="s3">\n                </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n                  </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n                    </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n                    </span><span class="s1">cacheSignal = null</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">return makeHangingPromise&lt;Response&gt;(</span><span class="s3">\n                    </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                    </span><span class="s1">workStore.route,</span><span class="s3">\n                    </span><span class="s1">'fetch()'</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n                </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n                </span><span class="s1">case 'request':</span><span class="s3">\n                </span><span class="s1">case 'cache':</span><span class="s3">\n                </span><span class="s1">case 'private-cache':</span><span class="s3">\n                </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n                  </span><span class="s1">break</span><span class="s3">\n                </span><span class="s1">default:</span><span class="s3">\n                  </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">markCurrentScopeAsDynamic(</span><span class="s3">\n              </span><span class="s1">workStore,</span><span class="s3">\n              </span><span class="s1">workUnitStore,</span><span class="s3">\n              </span><span class="s1">`no-store fetch ${input} ${workStore.route}`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const hasNextConfig = 'next' in init</span><span class="s3">\n          </span><span class="s1">const { next = {} } = init</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">typeof next.revalidate === 'number' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">revalidateStore &amp;&amp;</span><span class="s3">\n            </span><span class="s1">next.revalidate &lt; revalidateStore.revalidate</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (next.revalidate === 0) {</span><span class="s3">\n              </span><span class="s1">// If enabled, we should bail out of static generation.</span><span class="s3">\n              </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n                </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n                  </span><span class="s1">case 'prerender':</span><span class="s3">\n                  </span><span class="s1">case 'prerender-client':</span><span class="s3">\n                  </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n                    </span><span class="s1">return makeHangingPromise&lt;Response&gt;(</span><span class="s3">\n                      </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                      </span><span class="s1">workStore.route,</span><span class="s3">\n                      </span><span class="s1">'fetch()'</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">case 'request':</span><span class="s3">\n                  </span><span class="s1">case 'cache':</span><span class="s3">\n                  </span><span class="s1">case 'private-cache':</span><span class="s3">\n                  </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n                  </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n                  </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n                    </span><span class="s1">break</span><span class="s3">\n                  </span><span class="s1">default:</span><span class="s3">\n                    </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">markCurrentScopeAsDynamic(</span><span class="s3">\n                </span><span class="s1">workStore,</span><span class="s3">\n                </span><span class="s1">workUnitStore,</span><span class="s3">\n                </span><span class="s1">`revalidate: 0 fetch ${input} ${workStore.route}`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (!workStore.forceStatic || next.revalidate !== 0) {</span><span class="s3">\n              </span><span class="s1">revalidateStore.revalidate = next.revalidate</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (hasNextConfig) delete init.next</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// if we are revalidating the whole page via time or on-demand and</span><span class="s3">\n        </span><span class="s1">// the fetch cache entry is stale we should still de-dupe the</span><span class="s3">\n        </span><span class="s1">// origin hit if it's a cache-able entry</span><span class="s3">\n        </span><span class="s1">if (cacheKey &amp;&amp; isForegroundRevalidate) {</span><span class="s3">\n          </span><span class="s1">const pendingRevalidateKey = cacheKey</span><span class="s3">\n          </span><span class="s1">workStore.pendingRevalidates ??= {}</span><span class="s3">\n          </span><span class="s1">let pendingRevalidate =</span><span class="s3">\n            </span><span class="s1">workStore.pendingRevalidates[pendingRevalidateKey]</span><span class="s3">\n\n          </span><span class="s1">if (pendingRevalidate) {</span><span class="s3">\n            </span><span class="s1">const revalidatedResult: {</span><span class="s3">\n              </span><span class="s1">body: ArrayBuffer</span><span class="s3">\n              </span><span class="s1">headers: Headers</span><span class="s3">\n              </span><span class="s1">status: number</span><span class="s3">\n              </span><span class="s1">statusText: string</span><span class="s3">\n            </span><span class="s1">} = await pendingRevalidate</span><span class="s3">\n            </span><span class="s1">return new Response(revalidatedResult.body, {</span><span class="s3">\n              </span><span class="s1">headers: revalidatedResult.headers,</span><span class="s3">\n              </span><span class="s1">status: revalidatedResult.status,</span><span class="s3">\n              </span><span class="s1">statusText: revalidatedResult.statusText,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// We used to just resolve the Response and clone it however for</span><span class="s3">\n          </span><span class="s1">// static generation with cacheComponents we need the response to be able to</span><span class="s3">\n          </span><span class="s1">// be resolved in a microtask and cloning the response will never have</span><span class="s3">\n          </span><span class="s1">// a body that can resolve in a microtask in node (as observed through</span><span class="s3">\n          </span><span class="s1">// experimentation) So instead we await the body and then when it is</span><span class="s3">\n          </span><span class="s1">// available we construct manually cloned Response objects with the</span><span class="s3">\n          </span><span class="s1">// body as an ArrayBuffer. This will be resolvable in a microtask</span><span class="s3">\n          </span><span class="s1">// making it compatible with cacheComponents.</span><span class="s3">\n          </span><span class="s1">const pendingResponse = doOriginalFetch(true, cacheReasonOverride)</span><span class="s3">\n            </span><span class="s1">// We're cloning the response using this utility because there</span><span class="s3">\n            </span><span class="s1">// exists a bug in the undici library around response cloning.</span><span class="s3">\n            </span><span class="s1">// See the following pull request for more details:</span><span class="s3">\n            </span><span class="s1">// https://github.com/vercel/next.js/pull/73274</span><span class="s3">\n            </span><span class="s1">.then(cloneResponse)</span><span class="s3">\n\n          </span><span class="s1">pendingRevalidate = pendingResponse</span><span class="s3">\n            </span><span class="s1">.then(async (responses) =&gt; {</span><span class="s3">\n              </span><span class="s1">const response = responses[0]</span><span class="s3">\n              </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">body: await response.arrayBuffer(),</span><span class="s3">\n                </span><span class="s1">headers: response.headers,</span><span class="s3">\n                </span><span class="s1">status: response.status,</span><span class="s3">\n                </span><span class="s1">statusText: response.statusText,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">.finally(() =&gt; {</span><span class="s3">\n              </span><span class="s1">// If the pending revalidate is not present in the store, then</span><span class="s3">\n              </span><span class="s1">// we have nothing to delete.</span><span class="s3">\n              </span><span class="s1">if (!workStore.pendingRevalidates?.[pendingRevalidateKey]) {</span><span class="s3">\n                </span><span class="s1">return</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">delete workStore.pendingRevalidates[pendingRevalidateKey]</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">// Attach the empty catch here so we don't get a </span><span class="s3">\&quot;</span><span class="s1">unhandled promise</span><span class="s3">\n          </span><span class="s1">// rejection</span><span class="s3">\&quot; </span><span class="s1">warning</span><span class="s3">\n          </span><span class="s1">pendingRevalidate.catch(() =&gt; {})</span><span class="s3">\n\n          </span><span class="s1">workStore.pendingRevalidates[pendingRevalidateKey] = pendingRevalidate</span><span class="s3">\n\n          </span><span class="s1">return pendingResponse.then((responses) =&gt; responses[1])</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return doOriginalFetch(false, cacheReasonOverride)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return await result</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n          </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Attach the necessary properties to the patched fetch function.</span><span class="s3">\n  </span><span class="s1">// We don't use this to determine if the fetch function has been patched,</span><span class="s3">\n  </span><span class="s1">// but for external consumers to determine if the fetch function has been</span><span class="s3">\n  </span><span class="s1">// patched.</span><span class="s3">\n  </span><span class="s1">patched.__nextPatched = true as const</span><span class="s3">\n  </span><span class="s1">patched.__nextGetStaticStore = () =&gt; workAsyncStorage</span><span class="s3">\n  </span><span class="s1">patched._nextOriginalFetch = originFetch</span><span class="s3">\n  </span><span class="s1">;(globalThis as Record&lt;symbol, unknown&gt;)[NEXT_PATCH_SYMBOL] = true</span><span class="s3">\n\n  </span><span class="s1">// Assign the function name also as a name property, so that it's preserved</span><span class="s3">\n  </span><span class="s1">// even when mangling is enabled.</span><span class="s3">\n  </span><span class="s1">Object.defineProperty(patched, 'name', { value: 'fetch', writable: false })</span><span class="s3">\n\n  </span><span class="s1">return patched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// we patch fetch to collect cache information used for</span><span class="s3">\n</span><span class="s1">// determining if a page is static or not</span><span class="s3">\n</span><span class="s1">export function patchFetch(options: PatchableModule) {</span><span class="s3">\n  </span><span class="s1">// If we've already patched fetch, we should not patch it again.</span><span class="s3">\n  </span><span class="s1">if (isFetchPatched()) return</span><span class="s3">\n\n  </span><span class="s1">// Grab the original fetch function. We'll attach this so we can use it in</span><span class="s3">\n  </span><span class="s1">// the patched fetch function.</span><span class="s3">\n  </span><span class="s1">const original = createDedupeFetch(globalThis.fetch)</span><span class="s3">\n\n  </span><span class="s1">// Set the global fetch to the patched fetch.</span><span class="s3">\n  </span><span class="s1">globalThis.fetch = createPatchedFetcher(original, options)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Node in the doubly-linked list used for LRU tracking.</span><span class="s3">\n </span><span class="s1">* Each node represents a cache entry with bidirectional pointers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class LRUNode&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">public readonly key: string</span><span class="s3">\n  </span><span class="s1">public data: T</span><span class="s3">\n  </span><span class="s1">public size: number</span><span class="s3">\n  </span><span class="s1">public prev: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n  </span><span class="s1">public next: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n\n  </span><span class="s1">constructor(key: string, data: T, size: number) {</span><span class="s3">\n    </span><span class="s1">this.key = key</span><span class="s3">\n    </span><span class="s1">this.data = data</span><span class="s3">\n    </span><span class="s1">this.size = size</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sentinel node used for head/tail boundaries.</span><span class="s3">\n </span><span class="s1">* These nodes don't contain actual cache data but simplify list operations.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SentinelNode&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">public prev: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n  </span><span class="s1">public next: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* LRU (Least Recently Used) Cache implementation using a doubly-linked list</span><span class="s3">\n </span><span class="s1">* and hash map for O(1) operations.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Algorithm:</span><span class="s3">\n </span><span class="s1">* - Uses a doubly-linked list to maintain access order (most recent at head)</span><span class="s3">\n </span><span class="s1">* - Hash map provides O(1) key-to-node lookup</span><span class="s3">\n </span><span class="s1">* - Sentinel head/tail nodes simplify edge case handling</span><span class="s3">\n </span><span class="s1">* - Size-based eviction supports custom size calculation functions</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Data Structure Layout:</span><span class="s3">\n </span><span class="s1">* HEAD &lt;-&gt; [most recent] &lt;-&gt; ... &lt;-&gt; [least recent] &lt;-&gt; TAIL</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Operations:</span><span class="s3">\n </span><span class="s1">* - get(): Move accessed node to head (mark as most recent)</span><span class="s3">\n </span><span class="s1">* - set(): Add new node at head, evict from tail if over capacity</span><span class="s3">\n </span><span class="s1">* - Eviction: Remove least recent node (tail.prev) when size exceeds limit</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class LRUCache&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly cache: Map&lt;string, LRUNode&lt;T&gt;&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">private readonly head: SentinelNode&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">private readonly tail: SentinelNode&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">private totalSize: number = 0</span><span class="s3">\n  </span><span class="s1">private readonly maxSize: number</span><span class="s3">\n  </span><span class="s1">private readonly calculateSize: ((value: T) =&gt; number) | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(maxSize: number, calculateSize?: (value: T) =&gt; number) {</span><span class="s3">\n    </span><span class="s1">this.maxSize = maxSize</span><span class="s3">\n    </span><span class="s1">this.calculateSize = calculateSize</span><span class="s3">\n\n    </span><span class="s1">// Create sentinel nodes to simplify doubly-linked list operations</span><span class="s3">\n    </span><span class="s1">// HEAD &lt;-&gt; TAIL (empty list)</span><span class="s3">\n    </span><span class="s1">this.head = new SentinelNode&lt;T&gt;()</span><span class="s3">\n    </span><span class="s1">this.tail = new SentinelNode&lt;T&gt;()</span><span class="s3">\n    </span><span class="s1">this.head.next = this.tail</span><span class="s3">\n    </span><span class="s1">this.tail.prev = this.head</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Adds a node immediately after the head (marks as most recently used).</span><span class="s3">\n   </span><span class="s1">* Used when inserting new items or when an item is accessed.</span><span class="s3">\n   </span><span class="s1">* PRECONDITION: node must be disconnected (prev/next should be null)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private addToHead(node: LRUNode&lt;T&gt;): void {</span><span class="s3">\n    </span><span class="s1">node.prev = this.head</span><span class="s3">\n    </span><span class="s1">node.next = this.head.next</span><span class="s3">\n    </span><span class="s1">// head.next is always non-null (points to tail or another node)</span><span class="s3">\n    </span><span class="s1">this.head.next!.prev = node</span><span class="s3">\n    </span><span class="s1">this.head.next = node</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes a node from its current position in the doubly-linked list.</span><span class="s3">\n   </span><span class="s1">* Updates the prev/next pointers of adjacent nodes to maintain list integrity.</span><span class="s3">\n   </span><span class="s1">* PRECONDITION: node must be connected (prev/next are non-null)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private removeNode(node: LRUNode&lt;T&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Connected nodes always have non-null prev/next</span><span class="s3">\n    </span><span class="s1">node.prev!.next = node.next</span><span class="s3">\n    </span><span class="s1">node.next!.prev = node.prev</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Moves an existing node to the head position (marks as most recently used).</span><span class="s3">\n   </span><span class="s1">* This is the core LRU operation - accessed items become most recent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private moveToHead(node: LRUNode&lt;T&gt;): void {</span><span class="s3">\n    </span><span class="s1">this.removeNode(node)</span><span class="s3">\n    </span><span class="s1">this.addToHead(node)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes and returns the least recently used node (the one before tail).</span><span class="s3">\n   </span><span class="s1">* This is called during eviction when the cache exceeds capacity.</span><span class="s3">\n   </span><span class="s1">* PRECONDITION: cache is not empty (ensured by caller)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private removeTail(): LRUNode&lt;T&gt; {</span><span class="s3">\n    </span><span class="s1">const lastNode = this.tail.prev as LRUNode&lt;T&gt;</span><span class="s3">\n    </span><span class="s1">// tail.prev is always non-null and always LRUNode when cache is not empty</span><span class="s3">\n    </span><span class="s1">this.removeNode(lastNode)</span><span class="s3">\n    </span><span class="s1">return lastNode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Sets a key-value pair in the cache.</span><span class="s3">\n   </span><span class="s1">* If the key exists, updates the value and moves to head.</span><span class="s3">\n   </span><span class="s1">* If new, adds at head and evicts from tail if necessary.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity:</span><span class="s3">\n   </span><span class="s1">* - O(1) for uniform item sizes</span><span class="s3">\n   </span><span class="s1">* - O(k) where k is the number of items evicted (can be O(N) for variable sizes)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public set(key: string, value: T): void {</span><span class="s3">\n    </span><span class="s1">const size = this.calculateSize?.(value) ?? 1</span><span class="s3">\n    </span><span class="s1">if (size &gt; this.maxSize) {</span><span class="s3">\n      </span><span class="s1">console.warn('Single item size exceeds maxSize')</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const existing = this.cache.get(key)</span><span class="s3">\n    </span><span class="s1">if (existing) {</span><span class="s3">\n      </span><span class="s1">// Update existing node: adjust size and move to head (most recent)</span><span class="s3">\n      </span><span class="s1">existing.data = value</span><span class="s3">\n      </span><span class="s1">this.totalSize = this.totalSize - existing.size + size</span><span class="s3">\n      </span><span class="s1">existing.size = size</span><span class="s3">\n      </span><span class="s1">this.moveToHead(existing)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Add new node at head (most recent position)</span><span class="s3">\n      </span><span class="s1">const newNode = new LRUNode(key, value, size)</span><span class="s3">\n      </span><span class="s1">this.cache.set(key, newNode)</span><span class="s3">\n      </span><span class="s1">this.addToHead(newNode)</span><span class="s3">\n      </span><span class="s1">this.totalSize += size</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Evict least recently used items until under capacity</span><span class="s3">\n    </span><span class="s1">while (this.totalSize &gt; this.maxSize &amp;&amp; this.cache.size &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const tail = this.removeTail()</span><span class="s3">\n      </span><span class="s1">this.cache.delete(tail.key)</span><span class="s3">\n      </span><span class="s1">this.totalSize -= tail.size</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Checks if a key exists in the cache.</span><span class="s3">\n   </span><span class="s1">* This is a pure query operation - does NOT update LRU order.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity: O(1)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public has(key: string): boolean {</span><span class="s3">\n    </span><span class="s1">return this.cache.has(key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Retrieves a value by key and marks it as most recently used.</span><span class="s3">\n   </span><span class="s1">* Moving to head maintains the LRU property for future evictions.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity: O(1)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get(key: string): T | undefined {</span><span class="s3">\n    </span><span class="s1">const node = this.cache.get(key)</span><span class="s3">\n    </span><span class="s1">if (!node) return undefined</span><span class="s3">\n\n    </span><span class="s1">// Mark as most recently used by moving to head</span><span class="s3">\n    </span><span class="s1">this.moveToHead(node)</span><span class="s3">\n\n    </span><span class="s1">return node.data</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns an iterator over the cache entries. The order is outputted in the</span><span class="s3">\n   </span><span class="s1">* order of most recently used to least recently used.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public *[Symbol.iterator](): IterableIterator&lt;[string, T]&gt; {</span><span class="s3">\n    </span><span class="s1">let current = this.head.next</span><span class="s3">\n    </span><span class="s1">while (current &amp;&amp; current !== this.tail) {</span><span class="s3">\n      </span><span class="s1">// Between head and tail, current is always LRUNode</span><span class="s3">\n      </span><span class="s1">const node = current as LRUNode&lt;T&gt;</span><span class="s3">\n      </span><span class="s1">yield [node.key, node.data]</span><span class="s3">\n      </span><span class="s1">current = current.next</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes a specific key from the cache.</span><span class="s3">\n   </span><span class="s1">* Updates both the hash map and doubly-linked list.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity: O(1)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public remove(key: string): void {</span><span class="s3">\n    </span><span class="s1">const node = this.cache.get(key)</span><span class="s3">\n    </span><span class="s1">if (!node) return</span><span class="s3">\n\n    </span><span class="s1">this.removeNode(node)</span><span class="s3">\n    </span><span class="s1">this.cache.delete(key)</span><span class="s3">\n    </span><span class="s1">this.totalSize -= node.size</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the number of items in the cache.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get size(): number {</span><span class="s3">\n    </span><span class="s1">return this.cache.size</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the current total size of all cached items.</span><span class="s3">\n   </span><span class="s1">* This uses the custom size calculation if provided.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get currentSize(): number {</span><span class="s3">\n    </span><span class="s1">return this.totalSize</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { bold, green, magenta, red, yellow, white } from '../../lib/picocolors'</span><span class="s3">\n</span><span class="s1">import { LRUCache } from '../../server/lib/lru-cache'</span><span class="s3">\n\n</span><span class="s1">export const prefixes = {</span><span class="s3">\n  </span><span class="s1">wait: white(bold('')),</span><span class="s3">\n  </span><span class="s1">error: red(bold('')),</span><span class="s3">\n  </span><span class="s1">warn: yellow(bold('')),</span><span class="s3">\n  </span><span class="s1">ready: '', // no color</span><span class="s3">\n  </span><span class="s1">info: white(bold(' ')),</span><span class="s3">\n  </span><span class="s1">event: green(bold('')),</span><span class="s3">\n  </span><span class="s1">trace: magenta(bold('')),</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">const LOGGING_METHOD = {</span><span class="s3">\n  </span><span class="s1">log: 'log',</span><span class="s3">\n  </span><span class="s1">warn: 'warn',</span><span class="s3">\n  </span><span class="s1">error: 'error',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">function prefixedLog(prefixType: keyof typeof prefixes, ...message: any[]) {</span><span class="s3">\n  </span><span class="s1">if ((message[0] === '' || message[0] === undefined) &amp;&amp; message.length === 1) {</span><span class="s3">\n    </span><span class="s1">message.shift()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const consoleMethod: keyof typeof LOGGING_METHOD =</span><span class="s3">\n    </span><span class="s1">prefixType in LOGGING_METHOD</span><span class="s3">\n      </span><span class="s1">? LOGGING_METHOD[prefixType as keyof typeof LOGGING_METHOD]</span><span class="s3">\n      </span><span class="s1">: 'log'</span><span class="s3">\n\n  </span><span class="s1">const prefix = prefixes[prefixType]</span><span class="s3">\n  </span><span class="s1">// If there's no message, don't print the prefix but a new line</span><span class="s3">\n  </span><span class="s1">if (message.length === 0) {</span><span class="s3">\n    </span><span class="s1">console[consoleMethod]('')</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Ensure if there's ANSI escape codes it's concatenated into one string.</span><span class="s3">\n    </span><span class="s1">// Chrome DevTool can only handle color if it's in one string.</span><span class="s3">\n    </span><span class="s1">if (message.length === 1 &amp;&amp; typeof message[0] === 'string') {</span><span class="s3">\n      </span><span class="s1">console[consoleMethod](' ' + prefix + ' ' + message[0])</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">console[consoleMethod](' ' + prefix, ...message)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function bootstrap(...message: string[]) {</span><span class="s3">\n  </span><span class="s1">// logging format: ' &lt;prefix&gt; &lt;message&gt;'</span><span class="s3">\n  </span><span class="s1">// e.g. '  Compiled successfully'</span><span class="s3">\n  </span><span class="s1">// Add spaces to align with the indent of other logs</span><span class="s3">\n  </span><span class="s1">console.log('   ' + message.join(' '))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function wait(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('wait', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function error(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('error', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function warn(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('warn', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ready(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('ready', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function info(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('info', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function event(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('event', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function trace(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('trace', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const warnOnceCache = new LRUCache&lt;string&gt;(10_000, (value) =&gt; value.length)</span><span class="s3">\n</span><span class="s1">export function warnOnce(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">const key = message.join(' ')</span><span class="s3">\n  </span><span class="s1">if (!warnOnceCache.has(key)) {</span><span class="s3">\n    </span><span class="s1">warnOnceCache.set(key, key)</span><span class="s3">\n    </span><span class="s1">warn(...message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AppRouteHandlerFn, AppRouteHandlers } from '../module'</span><span class="s3">\n\n</span><span class="s1">import { HTTP_METHODS, type HTTP_METHOD } from '../../../web/http'</span><span class="s3">\n\n</span><span class="s1">const AUTOMATIC_ROUTE_METHODS = ['HEAD', 'OPTIONS'] as const</span><span class="s3">\n\n</span><span class="s1">function handleMethodNotAllowedResponse(): Response {</span><span class="s3">\n  </span><span class="s1">return new Response(null, { status: 405 })</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function autoImplementMethods(</span><span class="s3">\n  </span><span class="s1">handlers: AppRouteHandlers</span><span class="s3">\n</span><span class="s1">): Record&lt;HTTP_METHOD, AppRouteHandlerFn&gt; {</span><span class="s3">\n  </span><span class="s1">// Loop through all the HTTP methods to create the initial methods object.</span><span class="s3">\n  </span><span class="s1">// Each of the methods will be set to the 405 response handler.</span><span class="s3">\n  </span><span class="s1">const methods: Record&lt;HTTP_METHOD, AppRouteHandlerFn&gt; = HTTP_METHODS.reduce(</span><span class="s3">\n    </span><span class="s1">(acc, method) =&gt; ({</span><span class="s3">\n      </span><span class="s1">...acc,</span><span class="s3">\n      </span><span class="s1">// If the userland module implements the method, then use it. Otherwise,</span><span class="s3">\n      </span><span class="s1">// use the 405 response handler.</span><span class="s3">\n      </span><span class="s1">[method]: handlers[method] ?? handleMethodNotAllowedResponse,</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">{} as Record&lt;HTTP_METHOD, AppRouteHandlerFn&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Get all the methods that could be automatically implemented that were not</span><span class="s3">\n  </span><span class="s1">// implemented by the userland module.</span><span class="s3">\n  </span><span class="s1">const implemented = new Set(HTTP_METHODS.filter((method) =&gt; handlers[method]))</span><span class="s3">\n  </span><span class="s1">const missing = AUTOMATIC_ROUTE_METHODS.filter(</span><span class="s3">\n    </span><span class="s1">(method) =&gt; !implemented.has(method)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Loop over the missing methods to automatically implement them if we can.</span><span class="s3">\n  </span><span class="s1">for (const method of missing) {</span><span class="s3">\n    </span><span class="s1">// If the userland module doesn't implement the HEAD method, then</span><span class="s3">\n    </span><span class="s1">// we'll automatically implement it by calling the GET method (if it</span><span class="s3">\n    </span><span class="s1">// exists).</span><span class="s3">\n    </span><span class="s1">if (method === 'HEAD') {</span><span class="s3">\n      </span><span class="s1">if (handlers.GET) {</span><span class="s3">\n        </span><span class="s1">// Implement the HEAD method by calling the GET method.</span><span class="s3">\n        </span><span class="s1">methods.HEAD = handlers.GET</span><span class="s3">\n\n        </span><span class="s1">// Mark it as implemented.</span><span class="s3">\n        </span><span class="s1">implemented.add('HEAD')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If OPTIONS is not provided then implement it.</span><span class="s3">\n    </span><span class="s1">if (method === 'OPTIONS') {</span><span class="s3">\n      </span><span class="s1">// TODO: check if HEAD is implemented, if so, use it to add more headers</span><span class="s3">\n\n      </span><span class="s1">// Get all the methods that were implemented by the userland module.</span><span class="s3">\n      </span><span class="s1">const allow: HTTP_METHOD[] = ['OPTIONS', ...implemented]</span><span class="s3">\n\n      </span><span class="s1">// If the list of methods doesn't include HEAD, but it includes GET, then</span><span class="s3">\n      </span><span class="s1">// add HEAD as it's automatically implemented.</span><span class="s3">\n      </span><span class="s1">if (!implemented.has('HEAD') &amp;&amp; implemented.has('GET')) {</span><span class="s3">\n        </span><span class="s1">allow.push('HEAD')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Sort and join the list with commas to create the `Allow` header. See:</span><span class="s3">\n      </span><span class="s1">// https://httpwg.org/specs/rfc9110.html#field.allow</span><span class="s3">\n      </span><span class="s1">const headers = { Allow: allow.sort().join(', ') }</span><span class="s3">\n\n      </span><span class="s1">// Implement the OPTIONS method by returning a 204 response with the</span><span class="s3">\n      </span><span class="s1">// `Allow` header.</span><span class="s3">\n      </span><span class="s1">methods.OPTIONS = () =&gt; new Response(null, { status: 204, headers })</span><span class="s3">\n\n      </span><span class="s1">// Mark this method as implemented.</span><span class="s3">\n      </span><span class="s1">implemented.add('OPTIONS')</span><span class="s3">\n\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invariant: should handle all automatic implementable methods, got method: ${method}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return methods</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const HTTPAccessErrorStatus = {</span><span class="s3">\n  </span><span class="s1">NOT_FOUND: 404,</span><span class="s3">\n  </span><span class="s1">FORBIDDEN: 403,</span><span class="s3">\n  </span><span class="s1">UNAUTHORIZED: 401,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))</span><span class="s3">\n\n</span><span class="s1">export const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'</span><span class="s3">\n\n</span><span class="s1">export type HTTPAccessFallbackError = Error &amp; {</span><span class="s3">\n  </span><span class="s1">digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks an error to determine if it's an error generated by</span><span class="s3">\n </span><span class="s1">* the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param error the error that may reference a HTTP access error</span><span class="s3">\n </span><span class="s1">* @returns true if the error is a HTTP access error</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isHTTPAccessFallbackError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is HTTPAccessFallbackError {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof error !== 'object' ||</span><span class="s3">\n    </span><span class="s1">error === null ||</span><span class="s3">\n    </span><span class="s1">!('digest' in error) ||</span><span class="s3">\n    </span><span class="s1">typeof error.digest !== 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const [prefix, httpStatus] = error.digest.split(';')</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &amp;&amp;</span><span class="s3">\n    </span><span class="s1">ALLOWED_CODES.has(Number(httpStatus))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getAccessFallbackHTTPStatus(</span><span class="s3">\n  </span><span class="s1">error: HTTPAccessFallbackError</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">const httpStatus = error.digest.split(';')[1]</span><span class="s3">\n  </span><span class="s1">return Number(httpStatus)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getAccessFallbackErrorTypeByStatus(</span><span class="s3">\n  </span><span class="s1">status: number</span><span class="s3">\n</span><span class="s1">): 'not-found' | 'forbidden' | 'unauthorized' | undefined {</span><span class="s3">\n  </span><span class="s1">switch (status) {</span><span class="s3">\n    </span><span class="s1">case 401:</span><span class="s3">\n      </span><span class="s1">return 'unauthorized'</span><span class="s3">\n    </span><span class="s1">case 403:</span><span class="s3">\n      </span><span class="s1">return 'forbidden'</span><span class="s3">\n    </span><span class="s1">case 404:</span><span class="s3">\n      </span><span class="s1">return 'not-found'</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export enum RedirectStatusCode {</span><span class="s3">\n  </span><span class="s1">SeeOther = 303,</span><span class="s3">\n  </span><span class="s1">TemporaryRedirect = 307,</span><span class="s3">\n  </span><span class="s1">PermanentRedirect = 308,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { RedirectStatusCode } from './redirect-status-code'</span><span class="s3">\n\n</span><span class="s1">export const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'</span><span class="s3">\n\n</span><span class="s1">export enum RedirectType {</span><span class="s3">\n  </span><span class="s1">push = 'push',</span><span class="s3">\n  </span><span class="s1">replace = 'replace',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RedirectError = Error &amp; {</span><span class="s3">\n  </span><span class="s1">digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks an error to determine if it's an error generated by the</span><span class="s3">\n </span><span class="s1">* `redirect(url)` helper.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param error the error that may reference a redirect error</span><span class="s3">\n </span><span class="s1">* @returns true if the error is a redirect error</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isRedirectError(error: unknown): error is RedirectError {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof error !== 'object' ||</span><span class="s3">\n    </span><span class="s1">error === null ||</span><span class="s3">\n    </span><span class="s1">!('digest' in error) ||</span><span class="s3">\n    </span><span class="s1">typeof error.digest !== 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const digest = error.digest.split(';')</span><span class="s3">\n  </span><span class="s1">const [errorCode, type] = digest</span><span class="s3">\n  </span><span class="s1">const destination = digest.slice(2, -2).join(';')</span><span class="s3">\n  </span><span class="s1">const status = digest.at(-2)</span><span class="s3">\n\n  </span><span class="s1">const statusCode = Number(status)</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">errorCode === REDIRECT_ERROR_CODE &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(type === 'replace' || type === 'push') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof destination === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!isNaN(statusCode) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">statusCode in RedirectStatusCode</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { getDigestForWellKnownError } from './create-error-handler'</span><span class="s3">\n</span><span class="s1">import { isReactLargeShellError } from './react-large-shell-error'</span><span class="s3">\n\n</span><span class="s1">export function printDebugThrownValueForProspectiveRender(</span><span class="s3">\n  </span><span class="s1">thrownValue: unknown,</span><span class="s3">\n  </span><span class="s1">route: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// We don't need to print well-known Next.js errors.</span><span class="s3">\n  </span><span class="s1">if (getDigestForWellKnownError(thrownValue)) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isReactLargeShellError(thrownValue)) {</span><span class="s3">\n    </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n    </span><span class="s1">console.error(thrownValue)</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let message: undefined | string</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof thrownValue === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">thrownValue !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof (thrownValue as any).message === 'string'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">message = (thrownValue as any).message</span><span class="s3">\n    </span><span class="s1">if (typeof (thrownValue as any).stack === 'string') {</span><span class="s3">\n      </span><span class="s1">const originalErrorStack: string = (thrownValue as any).stack</span><span class="s3">\n      </span><span class="s1">const stackStart = originalErrorStack.indexOf('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n      </span><span class="s1">if (stackStart &gt; -1) {</span><span class="s3">\n        </span><span class="s1">const error = new Error(</span><span class="s3">\n          </span><span class="s1">`Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled.</span><span class="s3">\n          \n</span><span class="s1">Original Error: ${message}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">error.stack =</span><span class="s3">\n          </span><span class="s1">'Error: ' + error.message + originalErrorStack.slice(stackStart)</span><span class="s3">\n        </span><span class="s1">console.error(error)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (typeof thrownValue === 'string') {</span><span class="s3">\n    </span><span class="s1">message = thrownValue</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (message) {</span><span class="s3">\n    </span><span class="s1">console.error(`Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. No stack was provided.</span><span class="s3">\n          \n</span><span class="s1">Original Message: ${message}`)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">console.error(</span><span class="s3">\n    </span><span class="s1">`Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. The thrown value is logged just following this message`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">console.error(thrownValue)</span><span class="s3">\n  </span><span class="s1">return</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ErrorInfo } from 'react'</span><span class="s3">\n\n</span><span class="s1">import stringHash from 'next/dist/compiled/string-hash'</span><span class="s3">\n</span><span class="s1">import { formatServerError } from '../../lib/format-server-error'</span><span class="s3">\n</span><span class="s1">import { SpanStatusCode, getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { isAbortError } from '../pipe-readable'</span><span class="s3">\n</span><span class="s1">import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import { isDynamicServerError } from '../../client/components/hooks-server-context'</span><span class="s3">\n</span><span class="s1">import { isNextRouterError } from '../../client/components/is-next-router-error'</span><span class="s3">\n</span><span class="s1">import { isPrerenderInterruptedError } from './dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import { getProperError } from '../../lib/is-error'</span><span class="s3">\n</span><span class="s1">import { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'</span><span class="s3">\n</span><span class="s1">import { isReactLargeShellError } from './react-large-shell-error'</span><span class="s3">\n\n</span><span class="s1">declare global {</span><span class="s3">\n  </span><span class="s1">var __next_log_error__: undefined | ((err: unknown) =&gt; void)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RSCErrorHandler = (err: unknown) =&gt; string | undefined</span><span class="s3">\n</span><span class="s1">type SSRErrorHandler = (</span><span class="s3">\n  </span><span class="s1">err: unknown,</span><span class="s3">\n  </span><span class="s1">errorInfo?: ErrorInfo</span><span class="s3">\n</span><span class="s1">) =&gt; string | undefined</span><span class="s3">\n\n</span><span class="s1">export type DigestedError = Error &amp; { digest: string }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a digest for well-known Next.js errors, otherwise `undefined`. If a</span><span class="s3">\n </span><span class="s1">* digest is returned this also means that the error does not need to be</span><span class="s3">\n </span><span class="s1">* reported.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getDigestForWellKnownError(error: unknown): string | undefined {</span><span class="s3">\n  </span><span class="s1">// If we're bailing out to CSR, we don't need to log the error.</span><span class="s3">\n  </span><span class="s1">if (isBailoutToCSRError(error)) return error.digest</span><span class="s3">\n\n  </span><span class="s1">// If this is a navigation error, we don't need to log the error.</span><span class="s3">\n  </span><span class="s1">if (isNextRouterError(error)) return error.digest</span><span class="s3">\n\n  </span><span class="s1">// If this error occurs, we know that we should be stopping the static</span><span class="s3">\n  </span><span class="s1">// render. This is only thrown in static generation when PPR is not enabled,</span><span class="s3">\n  </span><span class="s1">// which causes the whole page to be marked as dynamic. We don't need to</span><span class="s3">\n  </span><span class="s1">// tell the user about this error, as it's not actionable.</span><span class="s3">\n  </span><span class="s1">if (isDynamicServerError(error)) return error.digest</span><span class="s3">\n\n  </span><span class="s1">// If this is a prerender interrupted error, we don't need to log the error.</span><span class="s3">\n  </span><span class="s1">if (isPrerenderInterruptedError(error)) return error.digest</span><span class="s3">\n\n  </span><span class="s1">return undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createFlightReactServerErrorHandler(</span><span class="s3">\n  </span><span class="s1">shouldFormatError: boolean,</span><span class="s3">\n  </span><span class="s1">onReactServerRenderError: (err: DigestedError) =&gt; void</span><span class="s3">\n</span><span class="s1">): RSCErrorHandler {</span><span class="s3">\n  </span><span class="s1">return (thrownValue: unknown) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (typeof thrownValue === 'string') {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span><span class="s3">\n      </span><span class="s1">return stringHash(thrownValue).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the response was closed, we don't need to log the error.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(thrownValue)) return</span><span class="s3">\n\n    </span><span class="s1">const digest = getDigestForWellKnownError(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">if (digest) {</span><span class="s3">\n      </span><span class="s1">return digest</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isReactLargeShellError(thrownValue)) {</span><span class="s3">\n      </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n      </span><span class="s1">console.error(thrownValue)</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const err = getProperError(thrownValue) as DigestedError</span><span class="s3">\n\n    </span><span class="s1">// If the error already has a digest, respect the original digest,</span><span class="s3">\n    </span><span class="s1">// so it won't get re-generated into another new error.</span><span class="s3">\n    </span><span class="s1">if (!err.digest) {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span><span class="s3">\n      </span><span class="s1">err.digest = stringHash(err.message + err.stack || '').toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Format server errors in development to add more helpful error messages</span><span class="s3">\n    </span><span class="s1">if (shouldFormatError) {</span><span class="s3">\n      </span><span class="s1">formatServerError(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Record exception in an active span, if available.</span><span class="s3">\n    </span><span class="s1">const span = getTracer().getActiveScopeSpan()</span><span class="s3">\n    </span><span class="s1">if (span) {</span><span class="s3">\n      </span><span class="s1">span.recordException(err)</span><span class="s3">\n      </span><span class="s1">span.setAttribute('error.type', err.name)</span><span class="s3">\n      </span><span class="s1">span.setStatus({</span><span class="s3">\n        </span><span class="s1">code: SpanStatusCode.ERROR,</span><span class="s3">\n        </span><span class="s1">message: err.message,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">onReactServerRenderError(err)</span><span class="s3">\n\n    </span><span class="s1">return createDigestWithErrorCode(thrownValue, err.digest)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createHTMLReactServerErrorHandler(</span><span class="s3">\n  </span><span class="s1">shouldFormatError: boolean,</span><span class="s3">\n  </span><span class="s1">isNextExport: boolean,</span><span class="s3">\n  </span><span class="s1">reactServerErrors: Map&lt;string, DigestedError&gt;,</span><span class="s3">\n  </span><span class="s1">silenceLogger: boolean,</span><span class="s3">\n  </span><span class="s1">onReactServerRenderError: undefined | ((err: DigestedError) =&gt; void)</span><span class="s3">\n</span><span class="s1">): RSCErrorHandler {</span><span class="s3">\n  </span><span class="s1">return (thrownValue: unknown) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (typeof thrownValue === 'string') {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span><span class="s3">\n      </span><span class="s1">return stringHash(thrownValue).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the response was closed, we don't need to log the error.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(thrownValue)) return</span><span class="s3">\n\n    </span><span class="s1">const digest = getDigestForWellKnownError(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">if (digest) {</span><span class="s3">\n      </span><span class="s1">return digest</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isReactLargeShellError(thrownValue)) {</span><span class="s3">\n      </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n      </span><span class="s1">console.error(thrownValue)</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const err = getProperError(thrownValue) as DigestedError</span><span class="s3">\n\n    </span><span class="s1">// If the error already has a digest, respect the original digest,</span><span class="s3">\n    </span><span class="s1">// so it won't get re-generated into another new error.</span><span class="s3">\n    </span><span class="s1">if (!err.digest) {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span><span class="s3">\n      </span><span class="s1">err.digest = stringHash(err.message + (err.stack || '')).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @TODO by putting this here and not at the top it is possible that</span><span class="s3">\n    </span><span class="s1">// we don't error the build in places we actually expect to</span><span class="s3">\n    </span><span class="s1">if (!reactServerErrors.has(err.digest)) {</span><span class="s3">\n      </span><span class="s1">reactServerErrors.set(err.digest, err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Format server errors in development to add more helpful error messages</span><span class="s3">\n    </span><span class="s1">if (shouldFormatError) {</span><span class="s3">\n      </span><span class="s1">formatServerError(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Don't log the suppressed error during export</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!(</span><span class="s3">\n        </span><span class="s1">isNextExport &amp;&amp;</span><span class="s3">\n        </span><span class="s1">err?.message?.includes(</span><span class="s3">\n          </span><span class="s1">'The specific message is omitted in production builds to avoid leaking sensitive details.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Record exception in an active span, if available.</span><span class="s3">\n      </span><span class="s1">const span = getTracer().getActiveScopeSpan()</span><span class="s3">\n      </span><span class="s1">if (span) {</span><span class="s3">\n        </span><span class="s1">span.recordException(err)</span><span class="s3">\n        </span><span class="s1">span.setAttribute('error.type', err.name)</span><span class="s3">\n        </span><span class="s1">span.setStatus({</span><span class="s3">\n          </span><span class="s1">code: SpanStatusCode.ERROR,</span><span class="s3">\n          </span><span class="s1">message: err.message,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!silenceLogger) {</span><span class="s3">\n        </span><span class="s1">onReactServerRenderError?.(err)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return createDigestWithErrorCode(thrownValue, err.digest)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createHTMLErrorHandler(</span><span class="s3">\n  </span><span class="s1">shouldFormatError: boolean,</span><span class="s3">\n  </span><span class="s1">isNextExport: boolean,</span><span class="s3">\n  </span><span class="s1">reactServerErrors: Map&lt;string, DigestedError&gt;,</span><span class="s3">\n  </span><span class="s1">allCapturedErrors: Array&lt;unknown&gt;,</span><span class="s3">\n  </span><span class="s1">silenceLogger: boolean,</span><span class="s3">\n  </span><span class="s1">onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) =&gt; void</span><span class="s3">\n</span><span class="s1">): SSRErrorHandler {</span><span class="s3">\n  </span><span class="s1">return (thrownValue: unknown, errorInfo?: ErrorInfo) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (isReactLargeShellError(thrownValue)) {</span><span class="s3">\n      </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n      </span><span class="s1">console.error(thrownValue)</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let isSSRError = true</span><span class="s3">\n\n    </span><span class="s1">allCapturedErrors.push(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">// If the response was closed, we don't need to log the error.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(thrownValue)) return</span><span class="s3">\n\n    </span><span class="s1">const digest = getDigestForWellKnownError(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">if (digest) {</span><span class="s3">\n      </span><span class="s1">return digest</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const err = getProperError(thrownValue) as DigestedError</span><span class="s3">\n    </span><span class="s1">// If the error already has a digest, respect the original digest,</span><span class="s3">\n    </span><span class="s1">// so it won't get re-generated into another new error.</span><span class="s3">\n    </span><span class="s1">if (err.digest) {</span><span class="s3">\n      </span><span class="s1">if (reactServerErrors.has(err.digest)) {</span><span class="s3">\n        </span><span class="s1">// This error is likely an obfuscated error from react-server.</span><span class="s3">\n        </span><span class="s1">// We recover the original error here.</span><span class="s3">\n        </span><span class="s1">thrownValue = reactServerErrors.get(err.digest)</span><span class="s3">\n        </span><span class="s1">isSSRError = false</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// The error is not from react-server but has a digest</span><span class="s3">\n        </span><span class="s1">// from other means so we don't need to produce a new one</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">err.digest = stringHash(</span><span class="s3">\n        </span><span class="s1">err.message + (errorInfo?.componentStack || err.stack || '')</span><span class="s3">\n      </span><span class="s1">).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Format server errors in development to add more helpful error messages</span><span class="s3">\n    </span><span class="s1">if (shouldFormatError) {</span><span class="s3">\n      </span><span class="s1">formatServerError(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Don't log the suppressed error during export</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!(</span><span class="s3">\n        </span><span class="s1">isNextExport &amp;&amp;</span><span class="s3">\n        </span><span class="s1">err?.message?.includes(</span><span class="s3">\n          </span><span class="s1">'The specific message is omitted in production builds to avoid leaking sensitive details.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Record exception in an active span, if available.</span><span class="s3">\n      </span><span class="s1">const span = getTracer().getActiveScopeSpan()</span><span class="s3">\n      </span><span class="s1">if (span) {</span><span class="s3">\n        </span><span class="s1">span.recordException(err)</span><span class="s3">\n        </span><span class="s1">span.setAttribute('error.type', err.name)</span><span class="s3">\n        </span><span class="s1">span.setStatus({</span><span class="s3">\n          </span><span class="s1">code: SpanStatusCode.ERROR,</span><span class="s3">\n          </span><span class="s1">message: err.message,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!silenceLogger &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// HTML errors contain RSC errors as well, filter them out before reporting</span><span class="s3">\n        </span><span class="s1">isSSRError</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">onHTMLRenderSSRError(err, errorInfo)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return createDigestWithErrorCode(thrownValue, err.digest)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isUserLandError(err: any): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">!isAbortError(err) &amp;&amp; !isBailoutToCSRError(err) &amp;&amp; !isNextRouterError(err)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// This has to be a shared module which is shared between client component error boundary and dynamic component</span><span class="s3">\n</span><span class="s1">const BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'</span><span class="s3">\n\n</span><span class="s1">/** An error that should be thrown when we want to bail out to client-side rendering. */</span><span class="s3">\n</span><span class="s1">export class BailoutToCSRError extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly digest = BAILOUT_TO_CSR</span><span class="s3">\n\n  </span><span class="s1">constructor(public readonly reason: string) {</span><span class="s3">\n    </span><span class="s1">super(`Bail out to client-side rendering: ${reason}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */</span><span class="s3">\n</span><span class="s1">export function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {</span><span class="s3">\n  </span><span class="s1">if (typeof err !== 'object' || err === null || !('digest' in err)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return err.digest === BAILOUT_TO_CSR</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">isHTTPAccessFallbackError,</span><span class="s3">\n  </span><span class="s1">type HTTPAccessFallbackError,</span><span class="s3">\n</span><span class="s1">} from './http-access-fallback/http-access-fallback'</span><span class="s3">\n</span><span class="s1">import { isRedirectError, type RedirectError } from './redirect-error'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns true if the error is a navigation signal error. These errors are</span><span class="s3">\n </span><span class="s1">* thrown by user code to perform navigation operations and interrupt the React</span><span class="s3">\n </span><span class="s1">* render.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isNextRouterError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is RedirectError | HTTPAccessFallbackError {</span><span class="s3">\n  </span><span class="s1">return isRedirectError(error) || isHTTPAccessFallbackError(error)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// TODO: isWellKnownError -&gt; isNextInternalError</span><span class="s3">\n</span><span class="s1">// isReactLargeShellError -&gt; isWarning</span><span class="s3">\n</span><span class="s1">export function isReactLargeShellError(</span><span class="s3">\n  </span><span class="s1">error: unknown</span><span class="s3">\n</span><span class="s1">): error is Error &amp; { digest?: string } {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof error === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'message' in error &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof error.message === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error.message.startsWith('This rendered a large document (&gt;')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import type { FetchServerResponseResult } from '../../client/components/router-reducer/fetch-server-response'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FocusAndScrollRef,</span><span class="s3">\n  </span><span class="s1">PrefetchKind,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import React from 'react'</span><span class="s3">\n\n</span><span class="s1">export type ChildSegmentMap = Map&lt;string, CacheNode&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cache node used in app-router / layout-router.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type CacheNode = ReadyCacheNode | LazyCacheNode</span><span class="s3">\n\n</span><span class="s1">export type LoadingModuleData =</span><span class="s3">\n  </span><span class="s1">| [React.JSX.Element, React.ReactNode, React.ReactNode]</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n\n</span><span class="s1">/** viewport metadata node */</span><span class="s3">\n</span><span class="s1">export type HeadData = React.ReactNode</span><span class="s3">\n\n</span><span class="s1">export type LazyCacheNode = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When rsc is null, this is a lazily-initialized cache node.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* If the app attempts to render it, it triggers a lazy data fetch,</span><span class="s3">\n   </span><span class="s1">* postpones the render, and schedules an update to a new tree.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* TODO: This mechanism should not be used when PPR is enabled, though it</span><span class="s3">\n   </span><span class="s1">* currently is in some cases until we've implemented partial</span><span class="s3">\n   </span><span class="s1">* segment fetching.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rsc: null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A prefetched version of the segment data. See explanation in corresponding</span><span class="s3">\n   </span><span class="s1">* field of ReadyCacheNode (below).</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Since LazyCacheNode mostly only exists in the non-PPR implementation, this</span><span class="s3">\n   </span><span class="s1">* will usually be null, but it could have been cloned from a previous</span><span class="s3">\n   </span><span class="s1">* CacheNode that was created by the PPR implementation. Eventually we want</span><span class="s3">\n   </span><span class="s1">* to migrate everything away from LazyCacheNode entirely.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetchRsc: React.ReactNode</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A pending response for the lazy data fetch. If this is not present</span><span class="s3">\n   </span><span class="s1">* during render, it is lazily created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">lazyData: Promise&lt;FetchServerResponseResult&gt; | null</span><span class="s3">\n\n  </span><span class="s1">prefetchHead: HeadData | null</span><span class="s3">\n\n  </span><span class="s1">head: HeadData</span><span class="s3">\n\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Child parallel routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">parallelRoutes: Map&lt;string, ChildSegmentMap&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The timestamp of the navigation that last updated the CacheNode's data. If</span><span class="s3">\n   </span><span class="s1">* a CacheNode is reused from a previous navigation, this value is not</span><span class="s3">\n   </span><span class="s1">* updated. Used to track the staleness of the data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReadyCacheNode = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When rsc is not null, it represents the RSC data for the</span><span class="s3">\n   </span><span class="s1">* corresponding segment.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* `null` is a valid React Node but because segment data is always a</span><span class="s3">\n   </span><span class="s1">* &lt;LayoutRouter&gt; component, we can use `null` to represent empty.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* TODO: For additional type safety, update this type to</span><span class="s3">\n   </span><span class="s1">* Exclude&lt;React.ReactNode, null&gt;. Need to update createEmptyCacheNode to</span><span class="s3">\n   </span><span class="s1">* accept rsc as an argument, or just inline the callers.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rsc: React.ReactNode</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Represents a static version of the segment that can be shown immediately,</span><span class="s3">\n   </span><span class="s1">* and may or may not contain dynamic holes. It's prefetched before a</span><span class="s3">\n   </span><span class="s1">* navigation occurs.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* During rendering, we will choose whether to render `rsc` or `prefetchRsc`</span><span class="s3">\n   </span><span class="s1">* with `useDeferredValue`. As with the `rsc` field, a value of `null` means</span><span class="s3">\n   </span><span class="s1">* no value was provided. In this case, the LayoutRouter will go straight to</span><span class="s3">\n   </span><span class="s1">* rendering the `rsc` value; if that one is also missing, it will suspend and</span><span class="s3">\n   </span><span class="s1">* trigger a lazy fetch.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetchRsc: React.ReactNode</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* There should never be a lazy data request in this case.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">lazyData: null</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null</span><span class="s3">\n\n  </span><span class="s1">head: HeadData</span><span class="s3">\n\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n\n  </span><span class="s1">parallelRoutes: Map&lt;string, ChildSegmentMap&gt;</span><span class="s3">\n\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface NavigateOptions {</span><span class="s3">\n  </span><span class="s1">scroll?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface PrefetchOptions {</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n  </span><span class="s1">onInvalidate?: () =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface AppRouterInstance {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the previous history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">back(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the next history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">forward(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Refresh the current page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">refresh(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Refresh the current page. Use in development only.</span><span class="s3">\n   </span><span class="s1">* @internal</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hmrRefresh(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the provided href.</span><span class="s3">\n   </span><span class="s1">* Pushes a new history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">push(href: string, options?: NavigateOptions): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the provided href.</span><span class="s3">\n   </span><span class="s1">* Replaces the current history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">replace(href: string, options?: NavigateOptions): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Prefetch the provided href.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetch(href: string, options?: PrefetchOptions): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const AppRouterContext = React.createContext&lt;AppRouterInstance | null&gt;(</span><span class="s3">\n  </span><span class="s1">null</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const LayoutRouterContext = React.createContext&lt;{</span><span class="s3">\n  </span><span class="s1">parentTree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">parentCacheNode: CacheNode</span><span class="s3">\n  </span><span class="s1">parentSegmentPath: FlightSegmentPath | null</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n</span><span class="s1">} | null&gt;(null)</span><span class="s3">\n\n</span><span class="s1">export const GlobalLayoutRouterContext = React.createContext&lt;{</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">focusAndScrollRef: FocusAndScrollRef</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null</span><span class="s3">\n</span><span class="s1">}&gt;(null as any)</span><span class="s3">\n\n</span><span class="s1">export const TemplateContext = React.createContext&lt;React.ReactNode&gt;(null as any)</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">AppRouterContext.displayName = 'AppRouterContext'</span><span class="s3">\n  </span><span class="s1">LayoutRouterContext.displayName = 'LayoutRouterContext'</span><span class="s3">\n  </span><span class="s1">GlobalLayoutRouterContext.displayName = 'GlobalLayoutRouterContext'</span><span class="s3">\n  </span><span class="s1">TemplateContext.displayName = 'TemplateContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const MissingSlotContext = React.createContext&lt;Set&lt;string&gt;&gt;(new Set())</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This class is used to detect when all cache reads for a given render are settled.</span><span class="s3">\n </span><span class="s1">* We do this to allow for cache warming the prerender without having to continue rendering</span><span class="s3">\n </span><span class="s1">* the remainder of the page. This feature is really only useful when the cacheComponents flag is on</span><span class="s3">\n </span><span class="s1">* and should only be used in codepaths gated with this feature.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">export class CacheSignal {</span><span class="s3">\n  </span><span class="s1">private count = 0</span><span class="s3">\n  </span><span class="s1">private earlyListeners: Array&lt;() =&gt; void&gt; = []</span><span class="s3">\n  </span><span class="s1">private listeners: Array&lt;() =&gt; void&gt; = []</span><span class="s3">\n  </span><span class="s1">private tickPending = false</span><span class="s3">\n  </span><span class="s1">private taskPending = false</span><span class="s3">\n\n  </span><span class="s1">private subscribedSignals: Set&lt;CacheSignal&gt; | null = null</span><span class="s3">\n\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">// we rely on `process.nextTick`, which is not supported in edge</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">'CacheSignal cannot be used in the edge runtime, because `cacheComponents` does not support it.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private noMorePendingCaches() {</span><span class="s3">\n    </span><span class="s1">if (!this.tickPending) {</span><span class="s3">\n      </span><span class="s1">this.tickPending = true</span><span class="s3">\n      </span><span class="s1">process.nextTick(() =&gt; {</span><span class="s3">\n        </span><span class="s1">this.tickPending = false</span><span class="s3">\n        </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n          </span><span class="s1">for (let i = 0; i &lt; this.earlyListeners.length; i++) {</span><span class="s3">\n            </span><span class="s1">this.earlyListeners[i]()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">this.earlyListeners.length = 0</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!this.taskPending) {</span><span class="s3">\n      </span><span class="s1">this.taskPending = true</span><span class="s3">\n      </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n        </span><span class="s1">this.taskPending = false</span><span class="s3">\n        </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n          </span><span class="s1">for (let i = 0; i &lt; this.listeners.length; i++) {</span><span class="s3">\n            </span><span class="s1">this.listeners[i]()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">this.listeners.length = 0</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, 0)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This promise waits until there are no more in progress cache reads but no later.</span><span class="s3">\n   </span><span class="s1">* This allows for adding more cache reads after to delay cacheReady.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">inputReady() {</span><span class="s3">\n    </span><span class="s1">return new Promise&lt;void&gt;((resolve) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.earlyListeners.push(resolve)</span><span class="s3">\n      </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n        </span><span class="s1">this.noMorePendingCaches()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If there are inflight cache reads this Promise can resolve in a microtask however</span><span class="s3">\n   </span><span class="s1">* if there are no inflight cache reads then we wait at least one task to allow initial</span><span class="s3">\n   </span><span class="s1">* cache reads to be initiated.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cacheReady() {</span><span class="s3">\n    </span><span class="s1">return new Promise&lt;void&gt;((resolve) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.listeners.push(resolve)</span><span class="s3">\n      </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n        </span><span class="s1">this.noMorePendingCaches()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">beginRead() {</span><span class="s3">\n    </span><span class="s1">this.count++</span><span class="s3">\n\n    </span><span class="s1">if (this.subscribedSignals !== null) {</span><span class="s3">\n      </span><span class="s1">for (const subscriber of this.subscribedSignals) {</span><span class="s3">\n        </span><span class="s1">subscriber.beginRead()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">endRead() {</span><span class="s3">\n    </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">'CacheSignal got more endRead() calls than beginRead() calls'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If this is the last read we need to wait a task before we can claim the cache is settled.</span><span class="s3">\n    </span><span class="s1">// The cache read will likely ping a Server Component which can read from the cache again and this</span><span class="s3">\n    </span><span class="s1">// will play out in a microtask so we need to only resolve pending listeners if we're still at 0</span><span class="s3">\n    </span><span class="s1">// after at least one task.</span><span class="s3">\n    </span><span class="s1">// We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.</span><span class="s3">\n    </span><span class="s1">// If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency</span><span class="s3">\n    </span><span class="s1">this.count--</span><span class="s3">\n    </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n      </span><span class="s1">this.noMorePendingCaches()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.subscribedSignals !== null) {</span><span class="s3">\n      </span><span class="s1">for (const subscriber of this.subscribedSignals) {</span><span class="s3">\n        </span><span class="s1">subscriber.endRead()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">trackRead&lt;T&gt;(promise: Promise&lt;T&gt;) {</span><span class="s3">\n    </span><span class="s1">this.beginRead()</span><span class="s3">\n    </span><span class="s1">// `promise.finally()` still rejects, so don't use it here to avoid unhandled rejections</span><span class="s3">\n    </span><span class="s1">const onFinally = this.endRead.bind(this)</span><span class="s3">\n    </span><span class="s1">promise.then(onFinally, onFinally)</span><span class="s3">\n    </span><span class="s1">return promise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">subscribeToReads(subscriber: CacheSignal): () =&gt; void {</span><span class="s3">\n    </span><span class="s1">if (subscriber === this) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError('A CacheSignal cannot subscribe to itself')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.subscribedSignals === null) {</span><span class="s3">\n      </span><span class="s1">this.subscribedSignals = new Set()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.subscribedSignals.add(subscriber)</span><span class="s3">\n\n    </span><span class="s1">// we'll notify the subscriber of each endRead() on this signal,</span><span class="s3">\n    </span><span class="s1">// so we need to give it a corresponding beginRead() for each read we have in flight now.</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; this.count; i++) {</span><span class="s3">\n      </span><span class="s1">subscriber.beginRead()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.unsubscribeFromReads.bind(this, subscriber)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">unsubscribeFromReads(subscriber: CacheSignal) {</span><span class="s3">\n    </span><span class="s1">if (!this.subscribedSignals) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.subscribedSignals.delete(subscriber)</span><span class="s3">\n\n    </span><span class="s1">// we don't need to set the set back to `null` if it's empty --</span><span class="s3">\n    </span><span class="s1">// if other signals are subscribing to this one, it'll likely get more subscriptions later,</span><span class="s3">\n    </span><span class="s1">// so we'd have to allocate a fresh set again when that happens.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// This regex will have fast negatives meaning valid identifiers may not pass</span><span class="s3">\n</span><span class="s1">// this test. However this is only used during static generation to provide hints</span><span class="s3">\n</span><span class="s1">// about why a page bailed out of some or all prerendering and we can use bracket notation</span><span class="s3">\n</span><span class="s1">// for example while `_` is a valid identifier it's ok to print `searchParams['_']`</span><span class="s3">\n</span><span class="s1">// even if this would have been fine too `searchParams._`</span><span class="s3">\n</span><span class="s1">const isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/</span><span class="s3">\n\n</span><span class="s1">export function describeStringPropertyAccess(target: string, prop: string) {</span><span class="s3">\n  </span><span class="s1">if (isDefinitelyAValidIdentifier.test(prop)) {</span><span class="s3">\n    </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">`${target}.${prop}</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">`${target}[${JSON.stringify(prop)}]</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function describeHasCheckingStringProperty(</span><span class="s3">\n  </span><span class="s1">target: string,</span><span class="s3">\n  </span><span class="s1">prop: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const stringifiedProp = JSON.stringify(prop)</span><span class="s3">\n  </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">`Reflect.has(${target}, ${stringifiedProp})</span><span class="s3">\\</span><span class="s1">`, </span><span class="s3">\\</span><span class="s1">`${stringifiedProp} in ${target}</span><span class="s3">\\</span><span class="s1">`, or similar`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const wellKnownProperties = new Set([</span><span class="s3">\n  </span><span class="s1">'hasOwnProperty',</span><span class="s3">\n  </span><span class="s1">'isPrototypeOf',</span><span class="s3">\n  </span><span class="s1">'propertyIsEnumerable',</span><span class="s3">\n  </span><span class="s1">'toString',</span><span class="s3">\n  </span><span class="s1">'valueOf',</span><span class="s3">\n  </span><span class="s1">'toLocaleString',</span><span class="s3">\n\n  </span><span class="s1">// Promise prototype</span><span class="s3">\n  </span><span class="s1">// fallthrough</span><span class="s3">\n  </span><span class="s1">'then',</span><span class="s3">\n  </span><span class="s1">'catch',</span><span class="s3">\n  </span><span class="s1">'finally',</span><span class="s3">\n\n  </span><span class="s1">// React Promise extension</span><span class="s3">\n  </span><span class="s1">// fallthrough</span><span class="s3">\n  </span><span class="s1">'status',</span><span class="s3">\n\n  </span><span class="s1">// React introspection</span><span class="s3">\n  </span><span class="s1">'displayName',</span><span class="s3">\n  </span><span class="s1">'_debugInfo',</span><span class="s3">\n\n  </span><span class="s1">// Common tested properties</span><span class="s3">\n  </span><span class="s1">// fallthrough</span><span class="s3">\n  </span><span class="s1">'toJSON',</span><span class="s3">\n  </span><span class="s1">'$$typeof',</span><span class="s3">\n  </span><span class="s1">'__esModule',</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as React from 'react'</span><span class="s3">\n\n</span><span class="s1">const errorRef: { current: null | Error } = { current: null }</span><span class="s3">\n\n</span><span class="s1">// React.cache is currently only available in canary/experimental React channels.</span><span class="s3">\n</span><span class="s1">const cache =</span><span class="s3">\n  </span><span class="s1">typeof React.cache === 'function'</span><span class="s3">\n    </span><span class="s1">? React.cache</span><span class="s3">\n    </span><span class="s1">: (fn: (key: unknown) =&gt; void) =&gt; fn</span><span class="s3">\n\n</span><span class="s1">// When Cache Components is enabled, we record these as errors so that they</span><span class="s3">\n</span><span class="s1">// are captured by the dev overlay as it's more critical to fix these</span><span class="s3">\n</span><span class="s1">// when enabled.</span><span class="s3">\n</span><span class="s1">const logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS</span><span class="s3">\n  </span><span class="s1">? console.error</span><span class="s3">\n  </span><span class="s1">: console.warn</span><span class="s3">\n\n</span><span class="s1">// We don't want to dedupe across requests.</span><span class="s3">\n</span><span class="s1">// The developer might've just attempted to fix the warning so we should warn again if it still happens.</span><span class="s3">\n</span><span class="s1">const flushCurrentErrorIfNew = cache(</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key</span><span class="s3">\n  </span><span class="s1">(key: unknown) =&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">logErrorOrWarn(errorRef.current)</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">errorRef.current = null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a function that logs an error message that is deduped by the userland</span><span class="s3">\n </span><span class="s1">* callsite.</span><span class="s3">\n </span><span class="s1">* This requires no indirection between the call of this function and the userland</span><span class="s3">\n </span><span class="s1">* callsite i.e. there's only a single library frame above this.</span><span class="s3">\n </span><span class="s1">* Do not use on the Client where sourcemaps and ignore listing might be enabled.</span><span class="s3">\n </span><span class="s1">* Only use that for warnings need a fix independent of the callstack.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param getMessage</span><span class="s3">\n </span><span class="s1">* @returns</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createDedupedByCallsiteServerErrorLoggerDev&lt;Args extends any[]&gt;(</span><span class="s3">\n  </span><span class="s1">getMessage: (...args: Args) =&gt; Error</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return function logDedupedError(...args: Args) {</span><span class="s3">\n    </span><span class="s1">const message = getMessage(...args)</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">const callStackFrames = new Error().stack?.split('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n      </span><span class="s1">if (callStackFrames === undefined || callStackFrames.length &lt; 4) {</span><span class="s3">\n        </span><span class="s1">logErrorOrWarn(message)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Error:</span><span class="s3">\n        </span><span class="s1">//   logDedupedError</span><span class="s3">\n        </span><span class="s1">//   asyncApiBeingAccessedSynchronously</span><span class="s3">\n        </span><span class="s1">//   &lt;userland callsite&gt;</span><span class="s3">\n        </span><span class="s1">// TODO: This breaks if sourcemaps with ignore lists are enabled.</span><span class="s3">\n        </span><span class="s1">const key = callStackFrames[4]</span><span class="s3">\n        </span><span class="s1">errorRef.current = message</span><span class="s3">\n        </span><span class="s1">flushCurrentErrorIfNew(key)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">logErrorOrWarn(message)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">workAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type WorkStore,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type { FallbackRouteParams } from './fallback-params'</span><span class="s3">\n\n</span><span class="s1">import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">throwToInterruptStaticGeneration,</span><span class="s3">\n  </span><span class="s1">postponeWithTracking,</span><span class="s3">\n  </span><span class="s1">trackSynchronousRequestDataAccessInDev,</span><span class="s3">\n  </span><span class="s1">delayUntilRuntimeStage,</span><span class="s3">\n</span><span class="s1">} from '../app-render/dynamic-rendering'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type PrerenderStorePPR,</span><span class="s3">\n  </span><span class="s1">type PrerenderStoreLegacy,</span><span class="s3">\n  </span><span class="s1">type StaticPrerenderStoreModern,</span><span class="s3">\n  </span><span class="s1">type StaticPrerenderStore,</span><span class="s3">\n  </span><span class="s1">throwInvariantForMissingStore,</span><span class="s3">\n  </span><span class="s1">type PrerenderStoreModernRuntime,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">describeStringPropertyAccess,</span><span class="s3">\n  </span><span class="s1">wellKnownProperties,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/utils/reflect-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">makeDevtoolsIOAwarePromise,</span><span class="s3">\n  </span><span class="s1">makeHangingPromise,</span><span class="s3">\n</span><span class="s1">} from '../dynamic-rendering-utils'</span><span class="s3">\n</span><span class="s1">import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'</span><span class="s3">\n</span><span class="s1">import { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">export type ParamValue = string | Array&lt;string&gt; | undefined</span><span class="s3">\n</span><span class="s1">export type Params = Record&lt;string, ParamValue&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.</span><span class="s3">\n </span><span class="s1">* However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.</span><span class="s3">\n </span><span class="s1">* The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you</span><span class="s3">\n </span><span class="s1">* have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```tsx</span><span class="s3">\n </span><span class="s1">* type Props = { params: Promise&lt;{ id: string }&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export default async function Layout(props: Props) {</span><span class="s3">\n </span><span class="s1">*  const directParams = (props.params as unknown as UnsafeUnwrappedParams&lt;typeof props.params&gt;)</span><span class="s3">\n </span><span class="s1">*  return ...</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This type is marked deprecated to help identify it as target for refactoring away.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @deprecated</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type UnsafeUnwrappedParams&lt;P&gt; =</span><span class="s3">\n  </span><span class="s1">P extends Promise&lt;infer U&gt; ? Omit&lt;U, 'then' | 'status' | 'value'&gt; : never</span><span class="s3">\n\n</span><span class="s1">export function createParamsFromClient(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">return createStaticPrerenderParams(</span><span class="s3">\n          </span><span class="s1">underlyingParams,</span><span class="s3">\n          </span><span class="s1">workStore,</span><span class="s3">\n          </span><span class="s1">workUnitStore</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createParamsFromClient should not be called in cache contexts.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createParamsFromClient should not be called in a runtime prerender.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n          </span><span class="s1">// Semantically we only need the dev tracking when running in `next dev`</span><span class="s3">\n          </span><span class="s1">// but since you would never use next dev with production NODE_ENV we use this</span><span class="s3">\n          </span><span class="s1">// as a proxy so we can statically exclude this code from production builds.</span><span class="s3">\n          </span><span class="s1">const devFallbackParams = workUnitStore.devFallbackParams</span><span class="s3">\n          </span><span class="s1">return createRenderParamsInDev(</span><span class="s3">\n            </span><span class="s1">underlyingParams,</span><span class="s3">\n            </span><span class="s1">devFallbackParams,</span><span class="s3">\n            </span><span class="s1">workStore</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return createRenderParamsInProd(underlyingParams)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throwInvariantForMissingStore()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component</span><span class="s3">\n</span><span class="s1">export type CreateServerParamsForMetadata = typeof createServerParamsForMetadata</span><span class="s3">\n</span><span class="s1">export const createServerParamsForMetadata = createServerParamsForServerSegment</span><span class="s3">\n\n</span><span class="s1">// routes always runs in RSC context so it is equivalent to a Server Page Component</span><span class="s3">\n</span><span class="s1">export function createServerParamsForRoute(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">return createStaticPrerenderParams(</span><span class="s3">\n          </span><span class="s1">underlyingParams,</span><span class="s3">\n          </span><span class="s1">workStore,</span><span class="s3">\n          </span><span class="s1">workUnitStore</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createServerParamsForRoute should not be called in cache contexts.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">return createRuntimePrerenderParams(underlyingParams, workUnitStore)</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n          </span><span class="s1">// Semantically we only need the dev tracking when running in `next dev`</span><span class="s3">\n          </span><span class="s1">// but since you would never use next dev with production NODE_ENV we use this</span><span class="s3">\n          </span><span class="s1">// as a proxy so we can statically exclude this code from production builds.</span><span class="s3">\n          </span><span class="s1">const devFallbackParams = workUnitStore.devFallbackParams</span><span class="s3">\n          </span><span class="s1">return createRenderParamsInDev(</span><span class="s3">\n            </span><span class="s1">underlyingParams,</span><span class="s3">\n            </span><span class="s1">devFallbackParams,</span><span class="s3">\n            </span><span class="s1">workStore</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return createRenderParamsInProd(underlyingParams)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throwInvariantForMissingStore()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createServerParamsForServerSegment(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">return createStaticPrerenderParams(</span><span class="s3">\n          </span><span class="s1">underlyingParams,</span><span class="s3">\n          </span><span class="s1">workStore,</span><span class="s3">\n          </span><span class="s1">workUnitStore</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createServerParamsForServerSegment should not be called in cache contexts.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">return createRuntimePrerenderParams(underlyingParams, workUnitStore)</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n          </span><span class="s1">// Semantically we only need the dev tracking when running in `next dev`</span><span class="s3">\n          </span><span class="s1">// but since you would never use next dev with production NODE_ENV we use this</span><span class="s3">\n          </span><span class="s1">// as a proxy so we can statically exclude this code from production builds.</span><span class="s3">\n          </span><span class="s1">const devFallbackParams = workUnitStore.devFallbackParams</span><span class="s3">\n          </span><span class="s1">return createRenderParamsInDev(</span><span class="s3">\n            </span><span class="s1">underlyingParams,</span><span class="s3">\n            </span><span class="s1">devFallbackParams,</span><span class="s3">\n            </span><span class="s1">workStore</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return createRenderParamsInProd(underlyingParams)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throwInvariantForMissingStore()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createPrerenderParamsForClientSegment(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (!workStore) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      </span><span class="s1">'Missing workStore in createPrerenderParamsForClientSegment'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n        </span><span class="s1">const fallbackParams = workUnitStore.fallbackRouteParams</span><span class="s3">\n        </span><span class="s1">if (fallbackParams) {</span><span class="s3">\n          </span><span class="s1">for (let key in underlyingParams) {</span><span class="s3">\n            </span><span class="s1">if (fallbackParams.has(key)) {</span><span class="s3">\n              </span><span class="s1">// This params object has one or more fallback params, so we need</span><span class="s3">\n              </span><span class="s1">// to consider the awaiting of this params object </span><span class="s3">\&quot;</span><span class="s1">dynamic</span><span class="s3">\&quot;</span><span class="s1">. Since</span><span class="s3">\n              </span><span class="s1">// we are in cacheComponents mode we encode this as a promise that never</span><span class="s3">\n              </span><span class="s1">// resolves.</span><span class="s3">\n              </span><span class="s1">return makeHangingPromise(</span><span class="s3">\n                </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n                </span><span class="s1">workStore.route,</span><span class="s3">\n                </span><span class="s1">'`params`'</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createPrerenderParamsForClientSegment should not be called in cache contexts.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// We're prerendering in a mode that does not abort. We resolve the promise without</span><span class="s3">\n  </span><span class="s1">// any tracking because we're just transporting a value from server to client where the tracking</span><span class="s3">\n  </span><span class="s1">// will be applied.</span><span class="s3">\n  </span><span class="s1">return Promise.resolve(underlyingParams)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createStaticPrerenderParams(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">prerenderStore: StaticPrerenderStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">switch (prerenderStore.type) {</span><span class="s3">\n    </span><span class="s1">case 'prerender':</span><span class="s3">\n    </span><span class="s1">case 'prerender-client': {</span><span class="s3">\n      </span><span class="s1">const fallbackParams = prerenderStore.fallbackRouteParams</span><span class="s3">\n      </span><span class="s1">if (fallbackParams) {</span><span class="s3">\n        </span><span class="s1">for (const key in underlyingParams) {</span><span class="s3">\n          </span><span class="s1">if (fallbackParams.has(key)) {</span><span class="s3">\n            </span><span class="s1">// This params object has one or more fallback params, so we need</span><span class="s3">\n            </span><span class="s1">// to consider the awaiting of this params object </span><span class="s3">\&quot;</span><span class="s1">dynamic</span><span class="s3">\&quot;</span><span class="s1">. Since</span><span class="s3">\n            </span><span class="s1">// we are in cacheComponents mode we encode this as a promise that never</span><span class="s3">\n            </span><span class="s1">// resolves.</span><span class="s3">\n            </span><span class="s1">return makeHangingParams(</span><span class="s3">\n              </span><span class="s1">underlyingParams,</span><span class="s3">\n              </span><span class="s1">workStore,</span><span class="s3">\n              </span><span class="s1">prerenderStore</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case 'prerender-ppr': {</span><span class="s3">\n      </span><span class="s1">const fallbackParams = prerenderStore.fallbackRouteParams</span><span class="s3">\n      </span><span class="s1">if (fallbackParams) {</span><span class="s3">\n        </span><span class="s1">for (const key in underlyingParams) {</span><span class="s3">\n          </span><span class="s1">if (fallbackParams.has(key)) {</span><span class="s3">\n            </span><span class="s1">return makeErroringExoticParams(</span><span class="s3">\n              </span><span class="s1">underlyingParams,</span><span class="s3">\n              </span><span class="s1">fallbackParams,</span><span class="s3">\n              </span><span class="s1">workStore,</span><span class="s3">\n              </span><span class="s1">prerenderStore</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">prerenderStore satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.__NEXT_CACHE_COMPONENTS) {</span><span class="s3">\n    </span><span class="s1">return makeUntrackedParams(underlyingParams)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return makeUntrackedExoticParams(underlyingParams)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createRuntimePrerenderParams(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">workUnitStore: PrerenderStoreModernRuntime</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">return delayUntilRuntimeStage(</span><span class="s3">\n    </span><span class="s1">workUnitStore,</span><span class="s3">\n    </span><span class="s1">process.env.__NEXT_CACHE_COMPONENTS</span><span class="s3">\n      </span><span class="s1">? makeUntrackedParams(underlyingParams)</span><span class="s3">\n      </span><span class="s1">: makeUntrackedExoticParams(underlyingParams)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createRenderParamsInProd(underlyingParams: Params): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_CACHE_COMPONENTS) {</span><span class="s3">\n    </span><span class="s1">return makeUntrackedParams(underlyingParams)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return makeUntrackedExoticParams(underlyingParams)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createRenderParamsInDev(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">devFallbackParams: FallbackRouteParams | null | undefined,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">let hasFallbackParams = false</span><span class="s3">\n  </span><span class="s1">if (devFallbackParams) {</span><span class="s3">\n    </span><span class="s1">for (let key in underlyingParams) {</span><span class="s3">\n      </span><span class="s1">if (devFallbackParams.has(key)) {</span><span class="s3">\n        </span><span class="s1">hasFallbackParams = true</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_CACHE_COMPONENTS) {</span><span class="s3">\n    </span><span class="s1">return makeDynamicallyTrackedParamsWithDevWarnings(</span><span class="s3">\n      </span><span class="s1">underlyingParams,</span><span class="s3">\n      </span><span class="s1">hasFallbackParams,</span><span class="s3">\n      </span><span class="s1">workStore</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return makeDynamicallyTrackedExoticParamsWithDevWarnings(</span><span class="s3">\n    </span><span class="s1">underlyingParams,</span><span class="s3">\n    </span><span class="s1">hasFallbackParams,</span><span class="s3">\n    </span><span class="s1">workStore</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface CacheLifetime {}</span><span class="s3">\n</span><span class="s1">const CachedParams = new WeakMap&lt;CacheLifetime, Promise&lt;Params&gt;&gt;()</span><span class="s3">\n\n</span><span class="s1">const fallbackParamsProxyHandler: ProxyHandler&lt;Promise&lt;Params&gt;&gt; = {</span><span class="s3">\n  </span><span class="s1">get: function get(target, prop, receiver) {</span><span class="s3">\n    </span><span class="s1">if (prop === 'then' || prop === 'catch' || prop === 'finally') {</span><span class="s3">\n      </span><span class="s1">const originalMethod = ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">[prop]: (...args: unknown[]) =&gt; {</span><span class="s3">\n          </span><span class="s1">const store = dynamicAccessAsyncStorage.getStore()</span><span class="s3">\n\n          </span><span class="s1">if (store) {</span><span class="s3">\n            </span><span class="s1">store.abortController.abort(</span><span class="s3">\n              </span><span class="s1">new Error(`Accessed fallback </span><span class="s3">\\</span><span class="s1">`params</span><span class="s3">\\</span><span class="s1">` during prerendering.`)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return new Proxy(</span><span class="s3">\n            </span><span class="s1">originalMethod.apply(target, args),</span><span class="s3">\n            </span><span class="s1">fallbackParamsProxyHandler</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">}[prop]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeHangingParams(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">prerenderStore: StaticPrerenderStoreModern</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedParams = CachedParams.get(underlyingParams)</span><span class="s3">\n  </span><span class="s1">if (cachedParams) {</span><span class="s3">\n    </span><span class="s1">return cachedParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = new Proxy(</span><span class="s3">\n    </span><span class="s1">makeHangingPromise&lt;Params&gt;(</span><span class="s3">\n      </span><span class="s1">prerenderStore.renderSignal,</span><span class="s3">\n      </span><span class="s1">workStore.route,</span><span class="s3">\n      </span><span class="s1">'`params`'</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">fallbackParamsProxyHandler</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">CachedParams.set(underlyingParams, promise)</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeErroringExoticParams(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">fallbackParams: FallbackRouteParams,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedParams = CachedParams.get(underlyingParams)</span><span class="s3">\n  </span><span class="s1">if (cachedParams) {</span><span class="s3">\n    </span><span class="s1">return cachedParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const augmentedUnderlying = { ...underlyingParams }</span><span class="s3">\n\n  </span><span class="s1">// We don't use makeResolvedReactPromise here because params</span><span class="s3">\n  </span><span class="s1">// supports copying with spread and we don't want to unnecessarily</span><span class="s3">\n  </span><span class="s1">// instrument the promise with spreadable properties of ReactPromise.</span><span class="s3">\n  </span><span class="s1">const promise = Promise.resolve(augmentedUnderlying)</span><span class="s3">\n  </span><span class="s1">CachedParams.set(underlyingParams, promise)</span><span class="s3">\n\n  </span><span class="s1">Object.keys(underlyingParams).forEach((prop) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (wellKnownProperties.has(prop)) {</span><span class="s3">\n      </span><span class="s1">// These properties cannot be shadowed because they need to be the</span><span class="s3">\n      </span><span class="s1">// true underlying value for Promises to work correctly at runtime</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (fallbackParams.has(prop)) {</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(augmentedUnderlying, prop, {</span><span class="s3">\n          </span><span class="s1">get() {</span><span class="s3">\n            </span><span class="s1">const expression = describeStringPropertyAccess('params', prop)</span><span class="s3">\n            </span><span class="s1">// In most dynamic APIs we also throw if `dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">` however</span><span class="s3">\n            </span><span class="s1">// for params is only dynamic when we're generating a fallback shell</span><span class="s3">\n            </span><span class="s1">// and even when `dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">` we still support generating dynamic</span><span class="s3">\n            </span><span class="s1">// fallback shells</span><span class="s3">\n            </span><span class="s1">// TODO remove this comment when cacheComponents is the default since there</span><span class="s3">\n            </span><span class="s1">// will be no `dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n            </span><span class="s1">if (prerenderStore.type === 'prerender-ppr') {</span><span class="s3">\n              </span><span class="s1">// PPR Prerender (no cacheComponents)</span><span class="s3">\n              </span><span class="s1">postponeWithTracking(</span><span class="s3">\n                </span><span class="s1">workStore.route,</span><span class="s3">\n                </span><span class="s1">expression,</span><span class="s3">\n                </span><span class="s1">prerenderStore.dynamicTracking</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// Legacy Prerender</span><span class="s3">\n              </span><span class="s1">throwToInterruptStaticGeneration(</span><span class="s3">\n                </span><span class="s1">expression,</span><span class="s3">\n                </span><span class="s1">workStore,</span><span class="s3">\n                </span><span class="s1">prerenderStore</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">enumerable: true,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(promise, prop, {</span><span class="s3">\n          </span><span class="s1">get() {</span><span class="s3">\n            </span><span class="s1">const expression = describeStringPropertyAccess('params', prop)</span><span class="s3">\n            </span><span class="s1">// In most dynamic APIs we also throw if `dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">` however</span><span class="s3">\n            </span><span class="s1">// for params is only dynamic when we're generating a fallback shell</span><span class="s3">\n            </span><span class="s1">// and even when `dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">` we still support generating dynamic</span><span class="s3">\n            </span><span class="s1">// fallback shells</span><span class="s3">\n            </span><span class="s1">// TODO remove this comment when cacheComponents is the default since there</span><span class="s3">\n            </span><span class="s1">// will be no `dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n            </span><span class="s1">if (prerenderStore.type === 'prerender-ppr') {</span><span class="s3">\n              </span><span class="s1">// PPR Prerender (no cacheComponents)</span><span class="s3">\n              </span><span class="s1">postponeWithTracking(</span><span class="s3">\n                </span><span class="s1">workStore.route,</span><span class="s3">\n                </span><span class="s1">expression,</span><span class="s3">\n                </span><span class="s1">prerenderStore.dynamicTracking</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// Legacy Prerender</span><span class="s3">\n              </span><span class="s1">throwToInterruptStaticGeneration(</span><span class="s3">\n                </span><span class="s1">expression,</span><span class="s3">\n                </span><span class="s1">workStore,</span><span class="s3">\n                </span><span class="s1">prerenderStore</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">set(newValue) {</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(promise, prop, {</span><span class="s3">\n              </span><span class="s1">value: newValue,</span><span class="s3">\n              </span><span class="s1">writable: true,</span><span class="s3">\n              </span><span class="s1">enumerable: true,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">enumerable: true,</span><span class="s3">\n          </span><span class="s1">configurable: true,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">;(promise as any)[prop] = underlyingParams[prop]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeUntrackedExoticParams(underlyingParams: Params): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedParams = CachedParams.get(underlyingParams)</span><span class="s3">\n  </span><span class="s1">if (cachedParams) {</span><span class="s3">\n    </span><span class="s1">return cachedParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We don't use makeResolvedReactPromise here because params</span><span class="s3">\n  </span><span class="s1">// supports copying with spread and we don't want to unnecessarily</span><span class="s3">\n  </span><span class="s1">// instrument the promise with spreadable properties of ReactPromise.</span><span class="s3">\n  </span><span class="s1">const promise = Promise.resolve(underlyingParams)</span><span class="s3">\n  </span><span class="s1">CachedParams.set(underlyingParams, promise)</span><span class="s3">\n\n  </span><span class="s1">Object.keys(underlyingParams).forEach((prop) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (wellKnownProperties.has(prop)) {</span><span class="s3">\n      </span><span class="s1">// These properties cannot be shadowed because they need to be the</span><span class="s3">\n      </span><span class="s1">// true underlying value for Promises to work correctly at runtime</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">;(promise as any)[prop] = underlyingParams[prop]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeUntrackedParams(underlyingParams: Params): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedParams = CachedParams.get(underlyingParams)</span><span class="s3">\n  </span><span class="s1">if (cachedParams) {</span><span class="s3">\n    </span><span class="s1">return cachedParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = Promise.resolve(underlyingParams)</span><span class="s3">\n  </span><span class="s1">CachedParams.set(underlyingParams, promise)</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeDynamicallyTrackedExoticParamsWithDevWarnings(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">hasFallbackParams: boolean,</span><span class="s3">\n  </span><span class="s1">store: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedParams = CachedParams.get(underlyingParams)</span><span class="s3">\n  </span><span class="s1">if (cachedParams) {</span><span class="s3">\n    </span><span class="s1">return cachedParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We don't use makeResolvedReactPromise here because params</span><span class="s3">\n  </span><span class="s1">// supports copying with spread and we don't want to unnecessarily</span><span class="s3">\n  </span><span class="s1">// instrument the promise with spreadable properties of ReactPromise.</span><span class="s3">\n  </span><span class="s1">const promise = hasFallbackParams</span><span class="s3">\n    </span><span class="s1">? makeDevtoolsIOAwarePromise(underlyingParams)</span><span class="s3">\n    </span><span class="s1">: // We don't want to force an environment transition when this params is not part of the fallback params set</span><span class="s3">\n      </span><span class="s1">Promise.resolve(underlyingParams)</span><span class="s3">\n\n  </span><span class="s1">const proxiedProperties = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">const unproxiedProperties: Array&lt;string&gt; = []</span><span class="s3">\n\n  </span><span class="s1">Object.keys(underlyingParams).forEach((prop) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (wellKnownProperties.has(prop)) {</span><span class="s3">\n      </span><span class="s1">// These properties cannot be shadowed because they need to be the</span><span class="s3">\n      </span><span class="s1">// true underlying value for Promises to work correctly at runtime</span><span class="s3">\n      </span><span class="s1">unproxiedProperties.push(prop)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">proxiedProperties.add(prop)</span><span class="s3">\n      </span><span class="s1">;(promise as any)[prop] = underlyingParams[prop]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const proxiedPromise = new Proxy(promise, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">// We are accessing a property that was proxied to the promise instance</span><span class="s3">\n          </span><span class="s1">proxiedProperties.has(prop)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const expression = describeStringPropertyAccess('params', prop)</span><span class="s3">\n          </span><span class="s1">syncIODev(store.route, expression)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set(target, prop, value, receiver) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">proxiedProperties.delete(prop)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ReflectAdapter.set(target, prop, value, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ownKeys(target) {</span><span class="s3">\n      </span><span class="s1">const expression = '`...params` or similar expression'</span><span class="s3">\n      </span><span class="s1">syncIODev(store.route, expression, unproxiedProperties)</span><span class="s3">\n      </span><span class="s1">return Reflect.ownKeys(target)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">CachedParams.set(underlyingParams, proxiedPromise)</span><span class="s3">\n  </span><span class="s1">return proxiedPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just</span><span class="s3">\n</span><span class="s1">// logging the sync access without actually defining the params on the promise.</span><span class="s3">\n</span><span class="s1">function makeDynamicallyTrackedParamsWithDevWarnings(</span><span class="s3">\n  </span><span class="s1">underlyingParams: Params,</span><span class="s3">\n  </span><span class="s1">hasFallbackParams: boolean,</span><span class="s3">\n  </span><span class="s1">store: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;Params&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedParams = CachedParams.get(underlyingParams)</span><span class="s3">\n  </span><span class="s1">if (cachedParams) {</span><span class="s3">\n    </span><span class="s1">return cachedParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We don't use makeResolvedReactPromise here because params</span><span class="s3">\n  </span><span class="s1">// supports copying with spread and we don't want to unnecessarily</span><span class="s3">\n  </span><span class="s1">// instrument the promise with spreadable properties of ReactPromise.</span><span class="s3">\n  </span><span class="s1">const promise = hasFallbackParams</span><span class="s3">\n    </span><span class="s1">? makeDevtoolsIOAwarePromise(underlyingParams)</span><span class="s3">\n    </span><span class="s1">: // We don't want to force an environment transition when this params is not part of the fallback params set</span><span class="s3">\n      </span><span class="s1">Promise.resolve(underlyingParams)</span><span class="s3">\n\n  </span><span class="s1">const proxiedProperties = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">const unproxiedProperties: Array&lt;string&gt; = []</span><span class="s3">\n\n  </span><span class="s1">Object.keys(underlyingParams).forEach((prop) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (wellKnownProperties.has(prop)) {</span><span class="s3">\n      </span><span class="s1">// These properties cannot be shadowed because they need to be the</span><span class="s3">\n      </span><span class="s1">// true underlying value for Promises to work correctly at runtime</span><span class="s3">\n      </span><span class="s1">unproxiedProperties.push(prop)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">proxiedProperties.add(prop)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const proxiedPromise = new Proxy(promise, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">// We are accessing a property that was proxied to the promise instance</span><span class="s3">\n          </span><span class="s1">proxiedProperties.has(prop)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const expression = describeStringPropertyAccess('params', prop)</span><span class="s3">\n          </span><span class="s1">warnForSyncAccess(store.route, expression)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set(target, prop, value, receiver) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">proxiedProperties.delete(prop)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ReflectAdapter.set(target, prop, value, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ownKeys(target) {</span><span class="s3">\n      </span><span class="s1">const expression = '`...params` or similar expression'</span><span class="s3">\n      </span><span class="s1">warnForIncompleteEnumeration(store.route, expression, unproxiedProperties)</span><span class="s3">\n      </span><span class="s1">return Reflect.ownKeys(target)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">CachedParams.set(underlyingParams, proxiedPromise)</span><span class="s3">\n  </span><span class="s1">return proxiedPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function syncIODev(</span><span class="s3">\n  </span><span class="s1">route: string | undefined,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">missingProperties?: Array&lt;string&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">if (workUnitStore.prerenderPhase === true) {</span><span class="s3">\n          </span><span class="s1">// When we're rendering dynamically in dev, we need to advance out of</span><span class="s3">\n          </span><span class="s1">// the Prerender environment when we read Request data synchronously.</span><span class="s3">\n          </span><span class="s1">trackSynchronousRequestDataAccessInDev(workUnitStore)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// In all cases we warn normally</span><span class="s3">\n  </span><span class="s1">if (missingProperties &amp;&amp; missingProperties.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">warnForIncompleteEnumeration(route, expression, missingProperties)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">warnForSyncAccess(route, expression)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(</span><span class="s3">\n  </span><span class="s1">createParamsAccessError</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">const warnForIncompleteEnumeration =</span><span class="s3">\n  </span><span class="s1">createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)</span><span class="s3">\n\n</span><span class="s1">function createParamsAccessError(</span><span class="s3">\n  </span><span class="s1">route: string | undefined,</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const prefix = route ? `Route </span><span class="s3">\&quot;</span><span class="s1">${route}</span><span class="s3">\&quot; </span><span class="s1">` : 'This route '</span><span class="s3">\n  </span><span class="s1">return new Error(</span><span class="s3">\n    </span><span class="s1">`${prefix}used ${expression}. ` +</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`params</span><span class="s3">\\</span><span class="s1">` should be awaited before using its properties. ` +</span><span class="s3">\n      </span><span class="s1">`Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createIncompleteEnumerationError(</span><span class="s3">\n  </span><span class="s1">route: string | undefined,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">missingProperties: Array&lt;string&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const prefix = route ? `Route </span><span class="s3">\&quot;</span><span class="s1">${route}</span><span class="s3">\&quot; </span><span class="s1">` : 'This route '</span><span class="s3">\n  </span><span class="s1">return new Error(</span><span class="s3">\n    </span><span class="s1">`${prefix}used ${expression}. ` +</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`params</span><span class="s3">\\</span><span class="s1">` should be awaited before using its properties. ` +</span><span class="s3">\n      </span><span class="s1">`The following properties were not available through enumeration ` +</span><span class="s3">\n      </span><span class="s1">`because they conflict with builtin property names: ` +</span><span class="s3">\n      </span><span class="s1">`${describeListOfPropertyNames(missingProperties)}. ` +</span><span class="s3">\n      </span><span class="s1">`Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function describeListOfPropertyNames(properties: Array&lt;string&gt;) {</span><span class="s3">\n  </span><span class="s1">switch (properties.length) {</span><span class="s3">\n    </span><span class="s1">case 0:</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">case 1:</span><span class="s3">\n      </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">`${properties[0]}</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n    </span><span class="s1">case 2:</span><span class="s3">\n      </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">`${properties[0]}</span><span class="s3">\\</span><span class="s1">` and </span><span class="s3">\\</span><span class="s1">`${properties[1]}</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n    </span><span class="s1">default: {</span><span class="s3">\n      </span><span class="s1">let description = ''</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; properties.length - 1; i++) {</span><span class="s3">\n        </span><span class="s1">description += `</span><span class="s3">\\</span><span class="s1">`${properties[i]}</span><span class="s3">\\</span><span class="s1">`, `</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">description += `, and </span><span class="s3">\\</span><span class="s1">`${properties[properties.length - 1]}</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n      </span><span class="s1">return description</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { RedirectStatusCode } from './redirect-status-code'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RedirectType,</span><span class="s3">\n  </span><span class="s1">type RedirectError,</span><span class="s3">\n  </span><span class="s1">isRedirectError,</span><span class="s3">\n  </span><span class="s1">REDIRECT_ERROR_CODE,</span><span class="s3">\n</span><span class="s1">} from './redirect-error'</span><span class="s3">\n\n</span><span class="s1">const actionAsyncStorage =</span><span class="s3">\n  </span><span class="s1">typeof window === 'undefined'</span><span class="s3">\n    </span><span class="s1">? (</span><span class="s3">\n        </span><span class="s1">require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')</span><span class="s3">\n      </span><span class="s1">).actionAsyncStorage</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">export function getRedirectError(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">type: RedirectType,</span><span class="s3">\n  </span><span class="s1">statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect</span><span class="s3">\n</span><span class="s1">): RedirectError {</span><span class="s3">\n  </span><span class="s1">const error = new Error(REDIRECT_ERROR_CODE) as RedirectError</span><span class="s3">\n  </span><span class="s1">error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`</span><span class="s3">\n  </span><span class="s1">return error</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function allows you to redirect the user to another URL. It can be used in</span><span class="s3">\n </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span><span class="s3">\n </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - In a Server Component, this will insert a meta tag to redirect the user to the target page.</span><span class="s3">\n </span><span class="s1">* - In a Route Handler or Server Action, it will serve a 307/303 to the caller.</span><span class="s3">\n </span><span class="s1">* - In a Server Action, type defaults to 'push' and 'replace' elsewhere.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function redirect(</span><span class="s3">\n  </span><span class="s1">/** The URL to redirect to */</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">type?: RedirectType</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">type ??= actionAsyncStorage?.getStore()?.isAction</span><span class="s3">\n    </span><span class="s1">? RedirectType.push</span><span class="s3">\n    </span><span class="s1">: RedirectType.replace</span><span class="s3">\n\n  </span><span class="s1">throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function allows you to redirect the user to another URL. It can be used in</span><span class="s3">\n </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span><span class="s3">\n </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - In a Server Component, this will insert a meta tag to redirect the user to the target page.</span><span class="s3">\n </span><span class="s1">* - In a Route Handler or Server Action, it will serve a 308/303 to the caller.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function permanentRedirect(</span><span class="s3">\n  </span><span class="s1">/** The URL to redirect to */</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">type: RedirectType = RedirectType.replace</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the encoded URL from the error if it's a RedirectError, null</span><span class="s3">\n </span><span class="s1">* otherwise. Note that this does not validate the URL returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param error the error that may be a redirect error</span><span class="s3">\n </span><span class="s1">* @return the url if the error was a redirect error</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getURLFromRedirectError(error: RedirectError): string</span><span class="s3">\n</span><span class="s1">export function getURLFromRedirectError(error: unknown): string | null {</span><span class="s3">\n  </span><span class="s1">if (!isRedirectError(error)) return null</span><span class="s3">\n\n  </span><span class="s1">// Slices off the beginning of the digest that contains the code and the</span><span class="s3">\n  </span><span class="s1">// separating ';'.</span><span class="s3">\n  </span><span class="s1">return error.digest.split(';').slice(2, -2).join(';')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRedirectTypeFromError(error: RedirectError): RedirectType {</span><span class="s3">\n  </span><span class="s1">if (!isRedirectError(error)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Not a redirect error')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return error.digest.split(';', 2)[1] as RedirectType</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRedirectStatusCodeFromError(error: RedirectError): number {</span><span class="s3">\n  </span><span class="s1">if (!isRedirectError(error)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Not a redirect error')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return Number(error.digest.split(';').at(-2))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextConfig } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import type { AppRouteRouteDefinition } from '../../route-definitions/app-route-route-definition'</span><span class="s3">\n</span><span class="s1">import type { AppSegmentConfig } from '../../../build/segment-config/app/app-segment-config'</span><span class="s3">\n</span><span class="s1">import type { NextRequest } from '../../web/spec-extension/request'</span><span class="s3">\n</span><span class="s1">import type { PrerenderManifest } from '../../../build'</span><span class="s3">\n</span><span class="s1">import type { NextURL } from '../../web/next-url'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import type { WorkUnitStore } from '../../app-render/work-unit-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RouteModule,</span><span class="s3">\n  </span><span class="s1">type RouteModuleHandleContext,</span><span class="s3">\n  </span><span class="s1">type RouteModuleOptions,</span><span class="s3">\n</span><span class="s1">} from '../route-module'</span><span class="s3">\n</span><span class="s1">import { createRequestStoreForAPI } from '../../async-storage/request-store'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createWorkStore,</span><span class="s3">\n  </span><span class="s1">type WorkStoreContext,</span><span class="s3">\n</span><span class="s1">} from '../../async-storage/work-store'</span><span class="s3">\n</span><span class="s1">import { type HTTP_METHOD, HTTP_METHODS, isHTTPMethod } from '../../web/http'</span><span class="s3">\n</span><span class="s1">import { getImplicitTags, type ImplicitTags } from '../../lib/implicit-tags'</span><span class="s3">\n</span><span class="s1">import { patchFetch } from '../../lib/patch-fetch'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { AppRouteRouteHandlersSpan } from '../../lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { getPathnameFromAbsolutePath } from './helpers/get-pathname-from-absolute-path'</span><span class="s3">\n</span><span class="s1">import * as Log from '../../../build/output/log'</span><span class="s3">\n</span><span class="s1">import { autoImplementMethods } from './helpers/auto-implement-methods'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">appendMutableCookies,</span><span class="s3">\n  </span><span class="s1">type ReadonlyRequestCookies,</span><span class="s3">\n</span><span class="s1">} from '../../web/spec-extension/adapters/request-cookies'</span><span class="s3">\n</span><span class="s1">import { HeadersAdapter } from '../../web/spec-extension/adapters/headers'</span><span class="s3">\n</span><span class="s1">import { RequestCookiesAdapter } from '../../web/spec-extension/adapters/request-cookies'</span><span class="s3">\n</span><span class="s1">import { parsedUrlQueryToParams } from './helpers/parsed-url-query-to-params'</span><span class="s3">\n</span><span class="s1">import { printDebugThrownValueForProspectiveRender } from '../../app-render/prospective-render-utils'</span><span class="s3">\n\n</span><span class="s1">import * as serverHooks from '../../../client/components/hooks-server-context'</span><span class="s3">\n</span><span class="s1">import { DynamicServerError } from '../../../client/components/hooks-server-context'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type WorkStore,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type RequestStore,</span><span class="s3">\n  </span><span class="s1">type PrerenderStore,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">actionAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type ActionStore,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/action-async-storage.external'</span><span class="s3">\n</span><span class="s1">import * as sharedModules from './shared-modules'</span><span class="s3">\n</span><span class="s1">import { getIsPossibleServerAction } from '../../lib/server-action-request-meta'</span><span class="s3">\n</span><span class="s1">import { RequestCookies } from 'next/dist/compiled/@edge-runtime/cookies'</span><span class="s3">\n</span><span class="s1">import { cleanURL } from './helpers/clean-url'</span><span class="s3">\n</span><span class="s1">import { StaticGenBailoutError } from '../../../client/components/static-generation-bailout'</span><span class="s3">\n</span><span class="s1">import { isStaticGenEnabled } from './helpers/is-static-gen-enabled'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">abortAndThrowOnSynchronousRequestDataAccess,</span><span class="s3">\n  </span><span class="s1">postponeWithTracking,</span><span class="s3">\n  </span><span class="s1">createDynamicTrackingState,</span><span class="s3">\n  </span><span class="s1">getFirstDynamicReason,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import { ReflectAdapter } from '../../web/spec-extension/adapters/reflect'</span><span class="s3">\n</span><span class="s1">import type { RenderOptsPartial } from '../../app-render/types'</span><span class="s3">\n</span><span class="s1">import { CacheSignal } from '../../app-render/cache-signal'</span><span class="s3">\n</span><span class="s1">import { scheduleImmediate } from '../../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import { createServerParamsForRoute } from '../../request/params'</span><span class="s3">\n</span><span class="s1">import type { AppSegment } from '../../../build/segment-config/app/app-segments'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getRedirectStatusCodeFromError,</span><span class="s3">\n  </span><span class="s1">getURLFromRedirectError,</span><span class="s3">\n</span><span class="s1">} from '../../../client/components/redirect'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isRedirectError,</span><span class="s3">\n  </span><span class="s1">type RedirectError,</span><span class="s3">\n</span><span class="s1">} from '../../../client/components/redirect-error'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getAccessFallbackHTTPStatus,</span><span class="s3">\n  </span><span class="s1">isHTTPAccessFallbackError,</span><span class="s3">\n</span><span class="s1">} from '../../../client/components/http-access-fallback/http-access-fallback'</span><span class="s3">\n</span><span class="s1">import { RedirectStatusCode } from '../../../client/components/redirect-status-code'</span><span class="s3">\n</span><span class="s1">import { INFINITE_CACHE } from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { executeRevalidates } from '../../revalidation-utils'</span><span class="s3">\n</span><span class="s1">import { trackPendingModules } from '../../app-render/module-loading/track-module-loading.external'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">export class WrappedNextRouterError {</span><span class="s3">\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">public readonly error: RedirectError,</span><span class="s3">\n    </span><span class="s1">public readonly headers?: Headers</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The AppRouteModule is the type of the module exported by the bundled App</span><span class="s3">\n </span><span class="s1">* Route module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type AppRouteModule = typeof import('../../../build/templates/app-route')</span><span class="s3">\n\n</span><span class="s1">export type AppRouteSharedContext = {</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* AppRouteRouteHandlerContext is the context that is passed to the route</span><span class="s3">\n </span><span class="s1">* handler for app routes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface AppRouteRouteHandlerContext extends RouteModuleHandleContext {</span><span class="s3">\n  </span><span class="s1">renderOpts: WorkStoreContext['renderOpts'] &amp;</span><span class="s3">\n    </span><span class="s1">Pick&lt;RenderOptsPartial, 'onInstrumentationRequestError'&gt; &amp;</span><span class="s3">\n    </span><span class="s1">CollectedCacheInfo</span><span class="s3">\n  </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">sharedContext: AppRouteSharedContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type CollectedCacheInfo = {</span><span class="s3">\n  </span><span class="s1">collectedTags?: string</span><span class="s3">\n  </span><span class="s1">collectedRevalidate?: number</span><span class="s3">\n  </span><span class="s1">collectedExpire?: number</span><span class="s3">\n  </span><span class="s1">collectedStale?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* AppRouteHandlerFnContext is the context that is passed to the handler as the</span><span class="s3">\n </span><span class="s1">* second argument.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type AppRouteHandlerFnContext = {</span><span class="s3">\n  </span><span class="s1">params?: Promise&lt;Record&lt;string, string | string[] | undefined&gt;&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handler function for app routes. If a non-Response value is returned, an error</span><span class="s3">\n </span><span class="s1">* will be thrown.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type AppRouteHandlerFn = (</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Incoming request object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">req: NextRequest,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Context properties on the request (including the parameters if this was a</span><span class="s3">\n   </span><span class="s1">* dynamic route).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ctx: AppRouteHandlerFnContext</span><span class="s3">\n</span><span class="s1">) =&gt; unknown</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* AppRouteHandlers describes the handlers for app routes that is provided by</span><span class="s3">\n </span><span class="s1">* the userland module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type AppRouteHandlers = {</span><span class="s3">\n  </span><span class="s1">[method in HTTP_METHOD]?: AppRouteHandlerFn</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* AppRouteUserlandModule is the userland module that is provided for app</span><span class="s3">\n </span><span class="s1">* routes. This contains all the user generated code.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type AppRouteUserlandModule = AppRouteHandlers &amp;</span><span class="s3">\n  </span><span class="s1">Pick&lt;</span><span class="s3">\n    </span><span class="s1">AppSegmentConfig,</span><span class="s3">\n    </span><span class="s1">'dynamic' | 'revalidate' | 'dynamicParams' | 'fetchCache'</span><span class="s3">\n  </span><span class="s1">&gt; &amp;</span><span class="s3">\n  </span><span class="s1">Pick&lt;AppSegment, 'generateStaticParams'&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* AppRouteRouteModuleOptions is the options that are passed to the app route</span><span class="s3">\n </span><span class="s1">* module from the bundled code.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface AppRouteRouteModuleOptions</span><span class="s3">\n  </span><span class="s1">extends RouteModuleOptions&lt;AppRouteRouteDefinition, AppRouteUserlandModule&gt; {</span><span class="s3">\n  </span><span class="s1">readonly resolvedPagePath: string</span><span class="s3">\n  </span><span class="s1">readonly nextConfigOutput: NextConfig['output']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* AppRouteRouteHandler is the handler for app routes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class AppRouteRouteModule extends RouteModule&lt;</span><span class="s3">\n  </span><span class="s1">AppRouteRouteDefinition,</span><span class="s3">\n  </span><span class="s1">AppRouteUserlandModule</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A reference to the request async storage.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly workUnitAsyncStorage = workUnitAsyncStorage</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A reference to the static generation async storage.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly workAsyncStorage = workAsyncStorage</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* An interface to call server hooks which interact with the underlying</span><span class="s3">\n   </span><span class="s1">* storage.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly serverHooks = serverHooks</span><span class="s3">\n\n  </span><span class="s1">public static readonly sharedModules = sharedModules</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A reference to the mutation related async storage, such as mutations of</span><span class="s3">\n   </span><span class="s1">* cookies.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly actionAsyncStorage = actionAsyncStorage</span><span class="s3">\n\n  </span><span class="s1">public readonly resolvedPagePath: string</span><span class="s3">\n  </span><span class="s1">public readonly nextConfigOutput: NextConfig['output'] | undefined</span><span class="s3">\n\n  </span><span class="s1">private readonly methods: Record&lt;HTTP_METHOD, AppRouteHandlerFn&gt;</span><span class="s3">\n  </span><span class="s1">private readonly hasNonStaticMethods: boolean</span><span class="s3">\n  </span><span class="s1">private readonly dynamic: AppRouteUserlandModule['dynamic']</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">userland,</span><span class="s3">\n    </span><span class="s1">definition,</span><span class="s3">\n    </span><span class="s1">distDir,</span><span class="s3">\n    </span><span class="s1">relativeProjectDir,</span><span class="s3">\n    </span><span class="s1">resolvedPagePath,</span><span class="s3">\n    </span><span class="s1">nextConfigOutput,</span><span class="s3">\n  </span><span class="s1">}: AppRouteRouteModuleOptions) {</span><span class="s3">\n    </span><span class="s1">super({ userland, definition, distDir, relativeProjectDir })</span><span class="s3">\n\n    </span><span class="s1">this.resolvedPagePath = resolvedPagePath</span><span class="s3">\n    </span><span class="s1">this.nextConfigOutput = nextConfigOutput</span><span class="s3">\n\n    </span><span class="s1">// Automatically implement some methods if they aren't implemented by the</span><span class="s3">\n    </span><span class="s1">// userland module.</span><span class="s3">\n    </span><span class="s1">this.methods = autoImplementMethods(userland)</span><span class="s3">\n    </span><span class="s1">this.isAppRouter = true</span><span class="s3">\n\n    </span><span class="s1">// Get the non-static methods for this route.</span><span class="s3">\n    </span><span class="s1">this.hasNonStaticMethods = hasNonStaticMethods(userland)</span><span class="s3">\n\n    </span><span class="s1">// Get the dynamic property from the userland module.</span><span class="s3">\n    </span><span class="s1">this.dynamic = this.userland.dynamic</span><span class="s3">\n    </span><span class="s1">if (this.nextConfigOutput === 'export') {</span><span class="s3">\n      </span><span class="s1">if (this.dynamic === 'force-dynamic') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`export const dynamic = </span><span class="s3">\&quot;</span><span class="s1">force-dynamic</span><span class="s3">\&quot; </span><span class="s1">on page </span><span class="s3">\&quot;</span><span class="s1">${definition.pathname}</span><span class="s3">\&quot; </span><span class="s1">cannot be used with </span><span class="s3">\&quot;</span><span class="s1">output: export</span><span class="s3">\&quot;</span><span class="s1">. See more info here: https://nextjs.org/docs/advanced-features/static-html-export`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else if (!isStaticGenEnabled(this.userland) &amp;&amp; this.userland['GET']) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`export const dynamic = </span><span class="s3">\&quot;</span><span class="s1">force-static</span><span class="s3">\&quot;</span><span class="s1">/export const revalidate not configured on route </span><span class="s3">\&quot;</span><span class="s1">${definition.pathname}</span><span class="s3">\&quot; </span><span class="s1">with </span><span class="s3">\&quot;</span><span class="s1">output: export</span><span class="s3">\&quot;</span><span class="s1">. See more info here: https://nextjs.org/docs/advanced-features/static-html-export`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.dynamic = 'error'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We only warn in development after here, so return if we're not in</span><span class="s3">\n    </span><span class="s1">// development.</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n      </span><span class="s1">// Print error in development if the exported handlers are in lowercase, only</span><span class="s3">\n      </span><span class="s1">// uppercase handlers are supported.</span><span class="s3">\n      </span><span class="s1">const lowercased = HTTP_METHODS.map((method) =&gt; method.toLowerCase())</span><span class="s3">\n      </span><span class="s1">for (const method of lowercased) {</span><span class="s3">\n        </span><span class="s1">if (method in this.userland) {</span><span class="s3">\n          </span><span class="s1">Log.error(</span><span class="s3">\n            </span><span class="s1">`Detected lowercase method '${method}' in '${</span><span class="s3">\n              </span><span class="s1">this.resolvedPagePath</span><span class="s3">\n            </span><span class="s1">}'. Export the uppercase '${method.toUpperCase()}' method name to fix this error.`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Print error if the module exports a default handler, they must use named</span><span class="s3">\n      </span><span class="s1">// exports for each HTTP method.</span><span class="s3">\n      </span><span class="s1">if ('default' in this.userland) {</span><span class="s3">\n        </span><span class="s1">Log.error(</span><span class="s3">\n          </span><span class="s1">`Detected default export in '${this.resolvedPagePath}'. Export a named export for each HTTP method instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If there is no methods exported by this module, then return a not found</span><span class="s3">\n      </span><span class="s1">// response.</span><span class="s3">\n      </span><span class="s1">if (!HTTP_METHODS.some((method) =&gt; method in this.userland)) {</span><span class="s3">\n        </span><span class="s1">Log.error(</span><span class="s3">\n          </span><span class="s1">`No HTTP methods exported in '${this.resolvedPagePath}'. Export a named export for each HTTP method.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Resolves the handler function for the given method.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param method the requested method</span><span class="s3">\n   </span><span class="s1">* @returns the handler function for the given method</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private resolve(method: string): AppRouteHandlerFn {</span><span class="s3">\n    </span><span class="s1">// Ensure that the requested method is a valid method (to prevent RCE's).</span><span class="s3">\n    </span><span class="s1">if (!isHTTPMethod(method)) return () =&gt; new Response(null, { status: 400 })</span><span class="s3">\n\n    </span><span class="s1">// Return the handler.</span><span class="s3">\n    </span><span class="s1">return this.methods[method]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private async do(</span><span class="s3">\n    </span><span class="s1">handler: AppRouteHandlerFn,</span><span class="s3">\n    </span><span class="s1">actionStore: ActionStore,</span><span class="s3">\n    </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n    </span><span class="s1">// @TODO refactor to not take this argument but instead construct the RequestStore</span><span class="s3">\n    </span><span class="s1">// inside this function. Right now we get passed a RequestStore even when</span><span class="s3">\n    </span><span class="s1">// we're going to do a prerender. We should probably just split do up into prexecute and execute</span><span class="s3">\n    </span><span class="s1">requestStore: RequestStore,</span><span class="s3">\n    </span><span class="s1">implicitTags: ImplicitTags,</span><span class="s3">\n    </span><span class="s1">request: NextRequest,</span><span class="s3">\n    </span><span class="s1">context: AppRouteRouteHandlerContext</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const isStaticGeneration = workStore.isStaticGeneration</span><span class="s3">\n    </span><span class="s1">const cacheComponentsEnabled =</span><span class="s3">\n      </span><span class="s1">!!context.renderOpts.experimental?.cacheComponents</span><span class="s3">\n\n    </span><span class="s1">// Patch the global fetch.</span><span class="s3">\n    </span><span class="s1">patchFetch({</span><span class="s3">\n      </span><span class="s1">workAsyncStorage: this.workAsyncStorage,</span><span class="s3">\n      </span><span class="s1">workUnitAsyncStorage: this.workUnitAsyncStorage,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const handlerContext: AppRouteHandlerFnContext = {</span><span class="s3">\n      </span><span class="s1">params: context.params</span><span class="s3">\n        </span><span class="s1">? createServerParamsForRoute(</span><span class="s3">\n            </span><span class="s1">parsedUrlQueryToParams(context.params),</span><span class="s3">\n            </span><span class="s1">workStore</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const resolvePendingRevalidations = () =&gt; {</span><span class="s3">\n      </span><span class="s1">context.renderOpts.pendingWaitUntil = executeRevalidates(</span><span class="s3">\n        </span><span class="s1">workStore</span><span class="s3">\n      </span><span class="s1">).finally(() =&gt; {</span><span class="s3">\n        </span><span class="s1">if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {</span><span class="s3">\n          </span><span class="s1">console.log(</span><span class="s3">\n            </span><span class="s1">'pending revalidates promise finished for:',</span><span class="s3">\n            </span><span class="s1">requestStore.url</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let prerenderStore: null | PrerenderStore = null</span><span class="s3">\n\n    </span><span class="s1">let res: unknown</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">if (isStaticGeneration) {</span><span class="s3">\n        </span><span class="s1">const userlandRevalidate = this.userland.revalidate</span><span class="s3">\n        </span><span class="s1">const defaultRevalidate: number =</span><span class="s3">\n          </span><span class="s1">// If the static generation store does not have a revalidate value</span><span class="s3">\n          </span><span class="s1">// set, then we should set it the revalidate value from the userland</span><span class="s3">\n          </span><span class="s1">// module or default to false.</span><span class="s3">\n          </span><span class="s1">userlandRevalidate === false || userlandRevalidate === undefined</span><span class="s3">\n            </span><span class="s1">? INFINITE_CACHE</span><span class="s3">\n            </span><span class="s1">: userlandRevalidate</span><span class="s3">\n\n        </span><span class="s1">if (cacheComponentsEnabled) {</span><span class="s3">\n          </span><span class="s1">/**</span><span class="s3">\n           </span><span class="s1">* When we are attempting to statically prerender the GET handler of a route.ts module</span><span class="s3">\n           </span><span class="s1">* and cacheComponents is on we follow a similar pattern to rendering.</span><span class="s3">\n           </span><span class="s1">*</span><span class="s3">\n           </span><span class="s1">* We first run the handler letting caches fill. If something synchronously dynamic occurs</span><span class="s3">\n           </span><span class="s1">* during this prospective render then we can infer it will happen on every render and we</span><span class="s3">\n           </span><span class="s1">* just bail out of prerendering.</span><span class="s3">\n           </span><span class="s1">*</span><span class="s3">\n           </span><span class="s1">* Next we run the handler again and we check if we get a result back in a microtask.</span><span class="s3">\n           </span><span class="s1">* Next.js expects the return value to be a Response or a Thenable that resolves to a Response.</span><span class="s3">\n           </span><span class="s1">* Unfortunately Response's do not allow for accessing the response body synchronously or in</span><span class="s3">\n           </span><span class="s1">* a microtask so we need to allow one more task to unwrap the response body. This is a slightly</span><span class="s3">\n           </span><span class="s1">* different semantic than what we have when we render and it means that certain tasks can still</span><span class="s3">\n           </span><span class="s1">* execute before a prerender completes such as a carefully timed setImmediate.</span><span class="s3">\n           </span><span class="s1">*</span><span class="s3">\n           </span><span class="s1">* Functionally though IO should still take longer than the time it takes to unwrap the response body</span><span class="s3">\n           </span><span class="s1">* so our heuristic of excluding any IO should be preserved.</span><span class="s3">\n           </span><span class="s1">*/</span><span class="s3">\n          </span><span class="s1">const prospectiveController = new AbortController()</span><span class="s3">\n          </span><span class="s1">let prospectiveRenderIsDynamic = false</span><span class="s3">\n          </span><span class="s1">const cacheSignal = new CacheSignal()</span><span class="s3">\n          </span><span class="s1">let dynamicTracking = createDynamicTrackingState(undefined)</span><span class="s3">\n\n          </span><span class="s1">const prospectiveRoutePrerenderStore: PrerenderStore =</span><span class="s3">\n            </span><span class="s1">(prerenderStore = {</span><span class="s3">\n              </span><span class="s1">type: 'prerender',</span><span class="s3">\n              </span><span class="s1">phase: 'action',</span><span class="s3">\n              </span><span class="s1">// This replicates prior behavior where rootParams is empty in routes</span><span class="s3">\n              </span><span class="s1">// TODO we need to make this have the proper rootParams for this route</span><span class="s3">\n              </span><span class="s1">rootParams: {},</span><span class="s3">\n              </span><span class="s1">fallbackRouteParams: null,</span><span class="s3">\n              </span><span class="s1">implicitTags,</span><span class="s3">\n              </span><span class="s1">renderSignal: prospectiveController.signal,</span><span class="s3">\n              </span><span class="s1">controller: prospectiveController,</span><span class="s3">\n              </span><span class="s1">cacheSignal,</span><span class="s3">\n              </span><span class="s1">// During prospective render we don't use a controller</span><span class="s3">\n              </span><span class="s1">// because we need to let all caches fill.</span><span class="s3">\n              </span><span class="s1">dynamicTracking,</span><span class="s3">\n              </span><span class="s1">allowEmptyStaticShell: false,</span><span class="s3">\n              </span><span class="s1">revalidate: defaultRevalidate,</span><span class="s3">\n              </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n              </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n              </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n              </span><span class="s1">// TODO: Shouldn't we provide an RDC here?</span><span class="s3">\n              </span><span class="s1">prerenderResumeDataCache: null,</span><span class="s3">\n              </span><span class="s1">renderResumeDataCache: null,</span><span class="s3">\n              </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n              </span><span class="s1">captureOwnerStack: undefined,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">let prospectiveResult</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">prospectiveResult = this.workUnitAsyncStorage.run(</span><span class="s3">\n              </span><span class="s1">prospectiveRoutePrerenderStore,</span><span class="s3">\n              </span><span class="s1">handler,</span><span class="s3">\n              </span><span class="s1">request,</span><span class="s3">\n              </span><span class="s1">handlerContext</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">if (prospectiveController.signal.aborted) {</span><span class="s3">\n              </span><span class="s1">// the route handler called an API which is always dynamic</span><span class="s3">\n              </span><span class="s1">// there is no need to try again</span><span class="s3">\n              </span><span class="s1">prospectiveRenderIsDynamic = true</span><span class="s3">\n            </span><span class="s1">} else if (</span><span class="s3">\n              </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n              </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">typeof prospectiveResult === 'object' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">prospectiveResult !== null &amp;&amp;</span><span class="s3">\n            </span><span class="s1">typeof (prospectiveResult as any).then === 'function'</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// The handler returned a Thenable. We'll listen for rejections to determine</span><span class="s3">\n            </span><span class="s1">// if the route is erroring for dynamic reasons.</span><span class="s3">\n            </span><span class="s1">;(prospectiveResult as any as Promise&lt;unknown&gt;).then(</span><span class="s3">\n              </span><span class="s1">() =&gt; {},</span><span class="s3">\n              </span><span class="s1">(err) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (prospectiveController.signal.aborted) {</span><span class="s3">\n                  </span><span class="s1">// the route handler called an API which is always dynamic</span><span class="s3">\n                  </span><span class="s1">// there is no need to try again</span><span class="s3">\n                  </span><span class="s1">prospectiveRenderIsDynamic = true</span><span class="s3">\n                </span><span class="s1">} else if (process.env.NEXT_DEBUG_BUILD) {</span><span class="s3">\n                  </span><span class="s1">printDebugThrownValueForProspectiveRender(</span><span class="s3">\n                    </span><span class="s1">err,</span><span class="s3">\n                    </span><span class="s1">workStore.route</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">trackPendingModules(cacheSignal)</span><span class="s3">\n          </span><span class="s1">await cacheSignal.cacheReady()</span><span class="s3">\n\n          </span><span class="s1">if (prospectiveRenderIsDynamic) {</span><span class="s3">\n            </span><span class="s1">// the route handler called an API which is always dynamic</span><span class="s3">\n            </span><span class="s1">// there is no need to try again</span><span class="s3">\n            </span><span class="s1">const dynamicReason = getFirstDynamicReason(dynamicTracking)</span><span class="s3">\n            </span><span class="s1">if (dynamicReason) {</span><span class="s3">\n              </span><span class="s1">throw new DynamicServerError(</span><span class="s3">\n                </span><span class="s1">`Route ${workStore.route} couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`${dynamicReason}</span><span class="s3">\\</span><span class="s1">`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">console.error(</span><span class="s3">\n                </span><span class="s1">'Expected Next.js to keep track of reason for opting out of static rendering but one was not found. This is a bug in Next.js'</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">throw new DynamicServerError(</span><span class="s3">\n                </span><span class="s1">`Route ${workStore.route} couldn't be rendered statically because it used a dynamic API. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// TODO start passing this controller to the route handler. We should expose</span><span class="s3">\n          </span><span class="s1">// it so the handler to abort inflight requests and other operations if we abort</span><span class="s3">\n          </span><span class="s1">// the prerender.</span><span class="s3">\n          </span><span class="s1">const finalController = new AbortController()</span><span class="s3">\n          </span><span class="s1">dynamicTracking = createDynamicTrackingState(undefined)</span><span class="s3">\n\n          </span><span class="s1">const finalRoutePrerenderStore: PrerenderStore = (prerenderStore = {</span><span class="s3">\n            </span><span class="s1">type: 'prerender',</span><span class="s3">\n            </span><span class="s1">phase: 'action',</span><span class="s3">\n            </span><span class="s1">rootParams: {},</span><span class="s3">\n            </span><span class="s1">fallbackRouteParams: null,</span><span class="s3">\n            </span><span class="s1">implicitTags,</span><span class="s3">\n            </span><span class="s1">renderSignal: finalController.signal,</span><span class="s3">\n            </span><span class="s1">controller: finalController,</span><span class="s3">\n            </span><span class="s1">cacheSignal: null,</span><span class="s3">\n            </span><span class="s1">dynamicTracking,</span><span class="s3">\n            </span><span class="s1">allowEmptyStaticShell: false,</span><span class="s3">\n            </span><span class="s1">revalidate: defaultRevalidate,</span><span class="s3">\n            </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n            </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n            </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n            </span><span class="s1">// TODO: Shouldn't we provide an RDC here?</span><span class="s3">\n            </span><span class="s1">prerenderResumeDataCache: null,</span><span class="s3">\n            </span><span class="s1">renderResumeDataCache: null,</span><span class="s3">\n            </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n            </span><span class="s1">captureOwnerStack: undefined,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">let responseHandled = false</span><span class="s3">\n          </span><span class="s1">res = await new Promise((resolve, reject) =&gt; {</span><span class="s3">\n            </span><span class="s1">scheduleImmediate(async () =&gt; {</span><span class="s3">\n              </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">const result = await (this.workUnitAsyncStorage.run(</span><span class="s3">\n                  </span><span class="s1">finalRoutePrerenderStore,</span><span class="s3">\n                  </span><span class="s1">handler,</span><span class="s3">\n                  </span><span class="s1">request,</span><span class="s3">\n                  </span><span class="s1">handlerContext</span><span class="s3">\n                </span><span class="s1">) as Promise&lt;Response&gt;)</span><span class="s3">\n                </span><span class="s1">if (responseHandled) {</span><span class="s3">\n                  </span><span class="s1">// we already rejected in the followup task</span><span class="s3">\n                  </span><span class="s1">return</span><span class="s3">\n                </span><span class="s1">} else if (!(result instanceof Response)) {</span><span class="s3">\n                  </span><span class="s1">// This is going to error but we let that happen below</span><span class="s3">\n                  </span><span class="s1">resolve(result)</span><span class="s3">\n                  </span><span class="s1">return</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">responseHandled = true</span><span class="s3">\n\n                </span><span class="s1">let bodyHandled = false</span><span class="s3">\n                </span><span class="s1">result.arrayBuffer().then((body) =&gt; {</span><span class="s3">\n                  </span><span class="s1">if (!bodyHandled) {</span><span class="s3">\n                    </span><span class="s1">bodyHandled = true</span><span class="s3">\n\n                    </span><span class="s1">resolve(</span><span class="s3">\n                      </span><span class="s1">new Response(body, {</span><span class="s3">\n                        </span><span class="s1">headers: result.headers,</span><span class="s3">\n                        </span><span class="s1">status: result.status,</span><span class="s3">\n                        </span><span class="s1">statusText: result.statusText,</span><span class="s3">\n                      </span><span class="s1">})</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}, reject)</span><span class="s3">\n                </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n                  </span><span class="s1">if (!bodyHandled) {</span><span class="s3">\n                    </span><span class="s1">bodyHandled = true</span><span class="s3">\n                    </span><span class="s1">finalController.abort()</span><span class="s3">\n                    </span><span class="s1">reject(createCacheComponentsError(workStore.route))</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">} catch (err) {</span><span class="s3">\n                </span><span class="s1">reject(err)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n              </span><span class="s1">if (!responseHandled) {</span><span class="s3">\n                </span><span class="s1">responseHandled = true</span><span class="s3">\n                </span><span class="s1">finalController.abort()</span><span class="s3">\n                </span><span class="s1">reject(createCacheComponentsError(workStore.route))</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">if (finalController.signal.aborted) {</span><span class="s3">\n            </span><span class="s1">// We aborted from within the execution</span><span class="s3">\n            </span><span class="s1">throw createCacheComponentsError(workStore.route)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// We didn't abort during the execution. We can abort now as a matter of semantics</span><span class="s3">\n            </span><span class="s1">// though at the moment nothing actually consumes this signal so it won't halt any</span><span class="s3">\n            </span><span class="s1">// inflight work.</span><span class="s3">\n            </span><span class="s1">finalController.abort()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">prerenderStore = {</span><span class="s3">\n            </span><span class="s1">type: 'prerender-legacy',</span><span class="s3">\n            </span><span class="s1">phase: 'action',</span><span class="s3">\n            </span><span class="s1">rootParams: {},</span><span class="s3">\n            </span><span class="s1">implicitTags,</span><span class="s3">\n            </span><span class="s1">revalidate: defaultRevalidate,</span><span class="s3">\n            </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n            </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n            </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">res = await workUnitAsyncStorage.run(</span><span class="s3">\n            </span><span class="s1">prerenderStore,</span><span class="s3">\n            </span><span class="s1">handler,</span><span class="s3">\n            </span><span class="s1">request,</span><span class="s3">\n            </span><span class="s1">handlerContext</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">res = await workUnitAsyncStorage.run(</span><span class="s3">\n          </span><span class="s1">requestStore,</span><span class="s3">\n          </span><span class="s1">handler,</span><span class="s3">\n          </span><span class="s1">request,</span><span class="s3">\n          </span><span class="s1">handlerContext</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">if (isRedirectError(err)) {</span><span class="s3">\n        </span><span class="s1">const url = getURLFromRedirectError(err)</span><span class="s3">\n        </span><span class="s1">if (!url) {</span><span class="s3">\n          </span><span class="s1">throw new Error('Invariant: Unexpected redirect url format')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// We need to capture any headers that should be sent on</span><span class="s3">\n        </span><span class="s1">// the response.</span><span class="s3">\n        </span><span class="s1">const headers = new Headers({ Location: url })</span><span class="s3">\n\n        </span><span class="s1">// Let's append any cookies that were added by the</span><span class="s3">\n        </span><span class="s1">// cookie API.</span><span class="s3">\n        </span><span class="s1">// TODO leaving the gate here b/c it indicates that we might not actually want to do this</span><span class="s3">\n        </span><span class="s1">// on every `do` call. During prerender there should be no mutableCookies because</span><span class="s3">\n        </span><span class="s1">appendMutableCookies(headers, requestStore.mutableCookies)</span><span class="s3">\n\n        </span><span class="s1">resolvePendingRevalidations()</span><span class="s3">\n\n        </span><span class="s1">// Return the redirect response.</span><span class="s3">\n        </span><span class="s1">return new Response(null, {</span><span class="s3">\n          </span><span class="s1">// If we're in an action, we want to use a 303 redirect as we don't</span><span class="s3">\n          </span><span class="s1">// want the POST request to follow the redirect, as it could result in</span><span class="s3">\n          </span><span class="s1">// erroneous re-submissions.</span><span class="s3">\n          </span><span class="s1">status: actionStore.isAction</span><span class="s3">\n            </span><span class="s1">? RedirectStatusCode.SeeOther</span><span class="s3">\n            </span><span class="s1">: getRedirectStatusCodeFromError(err),</span><span class="s3">\n          </span><span class="s1">headers,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else if (isHTTPAccessFallbackError(err)) {</span><span class="s3">\n        </span><span class="s1">const httpStatus = getAccessFallbackHTTPStatus(err)</span><span class="s3">\n        </span><span class="s1">return new Response(null, { status: httpStatus })</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Validate that the response is a valid response object.</span><span class="s3">\n    </span><span class="s1">if (!(res instanceof Response)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`No response is returned from route handler '${this.resolvedPagePath}'. Ensure you return a </span><span class="s3">\\</span><span class="s1">`Response</span><span class="s3">\\</span><span class="s1">` or a </span><span class="s3">\\</span><span class="s1">`NextResponse</span><span class="s3">\\</span><span class="s1">` in all branches of your handler.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">context.renderOpts.fetchMetrics = workStore.fetchMetrics</span><span class="s3">\n\n    </span><span class="s1">resolvePendingRevalidations()</span><span class="s3">\n\n    </span><span class="s1">if (prerenderStore) {</span><span class="s3">\n      </span><span class="s1">context.renderOpts.collectedTags = prerenderStore.tags?.join(',')</span><span class="s3">\n      </span><span class="s1">context.renderOpts.collectedRevalidate = prerenderStore.revalidate</span><span class="s3">\n      </span><span class="s1">context.renderOpts.collectedExpire = prerenderStore.expire</span><span class="s3">\n      </span><span class="s1">context.renderOpts.collectedStale = prerenderStore.stale</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// It's possible cookies were set in the handler, so we need</span><span class="s3">\n    </span><span class="s1">// to merge the modified cookies and the returned response</span><span class="s3">\n    </span><span class="s1">// here.</span><span class="s3">\n    </span><span class="s1">const headers = new Headers(res.headers)</span><span class="s3">\n    </span><span class="s1">if (appendMutableCookies(headers, requestStore.mutableCookies)) {</span><span class="s3">\n      </span><span class="s1">return new Response(res.body, {</span><span class="s3">\n        </span><span class="s1">status: res.status,</span><span class="s3">\n        </span><span class="s1">statusText: res.statusText,</span><span class="s3">\n        </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async handle(</span><span class="s3">\n    </span><span class="s1">req: NextRequest,</span><span class="s3">\n    </span><span class="s1">context: AppRouteRouteHandlerContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;Response&gt; {</span><span class="s3">\n    </span><span class="s1">// Get the handler function for the given method.</span><span class="s3">\n    </span><span class="s1">const handler = this.resolve(req.method)</span><span class="s3">\n\n    </span><span class="s1">// Get the context for the static generation.</span><span class="s3">\n    </span><span class="s1">const staticGenerationContext: WorkStoreContext = {</span><span class="s3">\n      </span><span class="s1">page: this.definition.page,</span><span class="s3">\n      </span><span class="s1">renderOpts: context.renderOpts,</span><span class="s3">\n      </span><span class="s1">buildId: context.sharedContext.buildId,</span><span class="s3">\n      </span><span class="s1">previouslyRevalidatedTags: [],</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Add the fetchCache option to the renderOpts.</span><span class="s3">\n    </span><span class="s1">staticGenerationContext.renderOpts.fetchCache = this.userland.fetchCache</span><span class="s3">\n\n    </span><span class="s1">const actionStore: ActionStore = {</span><span class="s3">\n      </span><span class="s1">isAppRoute: true,</span><span class="s3">\n      </span><span class="s1">isAction: getIsPossibleServerAction(req),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const implicitTags = await getImplicitTags(</span><span class="s3">\n      </span><span class="s1">this.definition.page,</span><span class="s3">\n      </span><span class="s1">req.nextUrl,</span><span class="s3">\n      </span><span class="s1">// App Routes don't support unknown route params.</span><span class="s3">\n      </span><span class="s1">null</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const requestStore = createRequestStoreForAPI(</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">req.nextUrl,</span><span class="s3">\n      </span><span class="s1">implicitTags,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">context.prerenderManifest.preview</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const workStore = createWorkStore(staticGenerationContext)</span><span class="s3">\n\n    </span><span class="s1">// Run the handler with the request AsyncLocalStorage to inject the helper</span><span class="s3">\n    </span><span class="s1">// support. We set this to `unknown` because the type is not known until</span><span class="s3">\n    </span><span class="s1">// runtime when we do a instanceof check below.</span><span class="s3">\n    </span><span class="s1">const response: unknown = await this.actionAsyncStorage.run(</span><span class="s3">\n      </span><span class="s1">actionStore,</span><span class="s3">\n      </span><span class="s1">() =&gt;</span><span class="s3">\n        </span><span class="s1">this.workUnitAsyncStorage.run(requestStore, () =&gt;</span><span class="s3">\n          </span><span class="s1">this.workAsyncStorage.run(workStore, async () =&gt; {</span><span class="s3">\n            </span><span class="s1">// Check to see if we should bail out of static generation based on</span><span class="s3">\n            </span><span class="s1">// having non-static methods.</span><span class="s3">\n            </span><span class="s1">if (this.hasNonStaticMethods) {</span><span class="s3">\n              </span><span class="s1">if (workStore.isStaticGeneration) {</span><span class="s3">\n                </span><span class="s1">const err = new DynamicServerError(</span><span class="s3">\n                  </span><span class="s1">'Route is configured with methods that cannot be statically generated.'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">workStore.dynamicUsageDescription = err.message</span><span class="s3">\n                </span><span class="s1">workStore.dynamicUsageStack = err.stack</span><span class="s3">\n                </span><span class="s1">throw err</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// We assume we can pass the original request through however we may end up</span><span class="s3">\n            </span><span class="s1">// proxying it in certain circumstances based on execution type and configuration</span><span class="s3">\n            </span><span class="s1">let request = req</span><span class="s3">\n\n            </span><span class="s1">// Update the static generation store based on the dynamic property.</span><span class="s3">\n            </span><span class="s1">switch (this.dynamic) {</span><span class="s3">\n              </span><span class="s1">case 'force-dynamic': {</span><span class="s3">\n                </span><span class="s1">// Routes of generated paths should be dynamic</span><span class="s3">\n                </span><span class="s1">workStore.forceDynamic = true</span><span class="s3">\n                </span><span class="s1">if (workStore.isStaticGeneration) {</span><span class="s3">\n                  </span><span class="s1">const err = new DynamicServerError(</span><span class="s3">\n                    </span><span class="s1">'Route is configured with dynamic = error which cannot be statically generated.'</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">workStore.dynamicUsageDescription = err.message</span><span class="s3">\n                  </span><span class="s1">workStore.dynamicUsageStack = err.stack</span><span class="s3">\n                  </span><span class="s1">throw err</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">case 'force-static':</span><span class="s3">\n                </span><span class="s1">// The dynamic property is set to force-static, so we should</span><span class="s3">\n                </span><span class="s1">// force the page to be static.</span><span class="s3">\n                </span><span class="s1">workStore.forceStatic = true</span><span class="s3">\n                </span><span class="s1">// We also Proxy the request to replace dynamic data on the request</span><span class="s3">\n                </span><span class="s1">// with empty stubs to allow for safely executing as static</span><span class="s3">\n                </span><span class="s1">request = new Proxy(req, forceStaticRequestHandlers)</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">case 'error':</span><span class="s3">\n                </span><span class="s1">// The dynamic property is set to error, so we should throw an</span><span class="s3">\n                </span><span class="s1">// error if the page is being statically generated.</span><span class="s3">\n                </span><span class="s1">workStore.dynamicShouldError = true</span><span class="s3">\n                </span><span class="s1">if (workStore.isStaticGeneration)</span><span class="s3">\n                  </span><span class="s1">request = new Proxy(req, requireStaticRequestHandlers)</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">case undefined:</span><span class="s3">\n              </span><span class="s1">case 'auto':</span><span class="s3">\n                </span><span class="s1">// We proxy `NextRequest` to track dynamic access, and</span><span class="s3">\n                </span><span class="s1">// potentially bail out of static generation.</span><span class="s3">\n                </span><span class="s1">request = proxyNextRequest(req, workStore)</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">this.dynamic satisfies never</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// TODO: propagate this pathname from route matcher</span><span class="s3">\n            </span><span class="s1">const route = getPathnameFromAbsolutePath(this.resolvedPagePath)</span><span class="s3">\n\n            </span><span class="s1">const tracer = getTracer()</span><span class="s3">\n\n            </span><span class="s1">// Update the root span attribute for the route.</span><span class="s3">\n            </span><span class="s1">tracer.setRootSpanAttribute('next.route', route)</span><span class="s3">\n\n            </span><span class="s1">return tracer.trace(</span><span class="s3">\n              </span><span class="s1">AppRouteRouteHandlersSpan.runHandler,</span><span class="s3">\n              </span><span class="s1">{</span><span class="s3">\n                </span><span class="s1">spanName: `executing api route (app) ${route}`,</span><span class="s3">\n                </span><span class="s1">attributes: {</span><span class="s3">\n                  </span><span class="s1">'next.route': route,</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">async () =&gt;</span><span class="s3">\n                </span><span class="s1">this.do(</span><span class="s3">\n                  </span><span class="s1">handler,</span><span class="s3">\n                  </span><span class="s1">actionStore,</span><span class="s3">\n                  </span><span class="s1">workStore,</span><span class="s3">\n                  </span><span class="s1">requestStore,</span><span class="s3">\n                  </span><span class="s1">implicitTags,</span><span class="s3">\n                  </span><span class="s1">request,</span><span class="s3">\n                  </span><span class="s1">context</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// If the handler did't return a valid response, then return the internal</span><span class="s3">\n    </span><span class="s1">// error response.</span><span class="s3">\n    </span><span class="s1">if (!(response instanceof Response)) {</span><span class="s3">\n      </span><span class="s1">// TODO: validate the correct handling behavior, maybe log something?</span><span class="s3">\n      </span><span class="s1">return new Response(null, { status: 500 })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (response.headers.has('x-middleware-rewrite')) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'NextResponse.rewrite() was used in a app route handler, this is not currently supported. Please remove the invocation to continue.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (response.headers.get('x-middleware-next') === '1') {</span><span class="s3">\n      </span><span class="s1">// TODO: move this error into the `NextResponse.next()` function.</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'NextResponse.next() was used in a app route handler, this is not supported. See here for more info: https://nextjs.org/docs/messages/next-response-next-in-app-route-handler'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default AppRouteRouteModule</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets all the method names for handlers that are not considered static.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param handlers the handlers from the userland module</span><span class="s3">\n </span><span class="s1">* @returns the method names that are not considered static or false if all</span><span class="s3">\n </span><span class="s1">*          methods are static</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hasNonStaticMethods(handlers: AppRouteHandlers): boolean {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// Order these by how common they are to be used</span><span class="s3">\n    </span><span class="s1">handlers.POST ||</span><span class="s3">\n    </span><span class="s1">handlers.PUT ||</span><span class="s3">\n    </span><span class="s1">handlers.DELETE ||</span><span class="s3">\n    </span><span class="s1">handlers.PATCH ||</span><span class="s3">\n    </span><span class="s1">handlers.OPTIONS</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// These symbols will be used to stash cached values on Proxied requests without requiring</span><span class="s3">\n</span><span class="s1">// additional closures or storage such as WeakMaps.</span><span class="s3">\n</span><span class="s1">const nextURLSymbol = Symbol('nextUrl')</span><span class="s3">\n</span><span class="s1">const requestCloneSymbol = Symbol('clone')</span><span class="s3">\n</span><span class="s1">const urlCloneSymbol = Symbol('clone')</span><span class="s3">\n</span><span class="s1">const searchParamsSymbol = Symbol('searchParams')</span><span class="s3">\n</span><span class="s1">const hrefSymbol = Symbol('href')</span><span class="s3">\n</span><span class="s1">const toStringSymbol = Symbol('toString')</span><span class="s3">\n</span><span class="s1">const headersSymbol = Symbol('headers')</span><span class="s3">\n</span><span class="s1">const cookiesSymbol = Symbol('cookies')</span><span class="s3">\n\n</span><span class="s1">type RequestSymbolTarget = {</span><span class="s3">\n  </span><span class="s1">[headersSymbol]?: Headers</span><span class="s3">\n  </span><span class="s1">[cookiesSymbol]?: RequestCookies | ReadonlyRequestCookies</span><span class="s3">\n  </span><span class="s1">[nextURLSymbol]?: NextURL</span><span class="s3">\n  </span><span class="s1">[requestCloneSymbol]?: () =&gt; NextRequest</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type UrlSymbolTarget = {</span><span class="s3">\n  </span><span class="s1">[searchParamsSymbol]?: URLSearchParams</span><span class="s3">\n  </span><span class="s1">[hrefSymbol]?: string</span><span class="s3">\n  </span><span class="s1">[toStringSymbol]?: () =&gt; string</span><span class="s3">\n  </span><span class="s1">[urlCloneSymbol]?: () =&gt; NextURL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The general technique with these proxy handlers is to prioritize keeping them static</span><span class="s3">\n </span><span class="s1">* by stashing computed values on the Proxy itself. This is safe because the Proxy is</span><span class="s3">\n </span><span class="s1">* inaccessible to the consumer since all operations are forwarded</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const forceStaticRequestHandlers = {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">target: NextRequest &amp; RequestSymbolTarget,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">receiver: any</span><span class="s3">\n  </span><span class="s1">): unknown {</span><span class="s3">\n    </span><span class="s1">switch (prop) {</span><span class="s3">\n      </span><span class="s1">case 'headers':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[headersSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[headersSymbol] = HeadersAdapter.seal(new Headers({})))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'cookies':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[cookiesSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[cookiesSymbol] = RequestCookiesAdapter.seal(</span><span class="s3">\n            </span><span class="s1">new RequestCookies(new Headers({}))</span><span class="s3">\n          </span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'nextUrl':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[nextURLSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[nextURLSymbol] = new Proxy(</span><span class="s3">\n            </span><span class="s1">target.nextUrl,</span><span class="s3">\n            </span><span class="s1">forceStaticNextUrlHandlers</span><span class="s3">\n          </span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'url':</span><span class="s3">\n        </span><span class="s1">// we don't need to separately cache this we can just read the nextUrl</span><span class="s3">\n        </span><span class="s1">// and return the href since we know it will have been stripped of any</span><span class="s3">\n        </span><span class="s1">// dynamic parts. We access via the receiver to trigger the get trap</span><span class="s3">\n        </span><span class="s1">return receiver.nextUrl.href</span><span class="s3">\n      </span><span class="s1">case 'geo':</span><span class="s3">\n      </span><span class="s1">case 'ip':</span><span class="s3">\n        </span><span class="s1">return undefined</span><span class="s3">\n      </span><span class="s1">case 'clone':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[requestCloneSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[requestCloneSymbol] = () =&gt;</span><span class="s3">\n            </span><span class="s1">new Proxy(</span><span class="s3">\n              </span><span class="s1">// This is vaguely unsafe but it's required since NextRequest does not implement</span><span class="s3">\n              </span><span class="s1">// clone. The reason we might expect this to work in this context is the Proxy will</span><span class="s3">\n              </span><span class="s1">// respond with static-amenable values anyway somewhat restoring the interface.</span><span class="s3">\n              </span><span class="s1">// @TODO we need to rethink NextRequest and NextURL because they are not sufficientlly</span><span class="s3">\n              </span><span class="s1">// sophisticated to adequately represent themselves in all contexts. A better approach is</span><span class="s3">\n              </span><span class="s1">// to probably embed the static generation logic into the class itself removing the need</span><span class="s3">\n              </span><span class="s1">// for any kind of proxying</span><span class="s3">\n              </span><span class="s1">target.clone() as NextRequest,</span><span class="s3">\n              </span><span class="s1">forceStaticRequestHandlers</span><span class="s3">\n            </span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// We don't need to proxy set because all the properties we proxy are ready only</span><span class="s3">\n  </span><span class="s1">// and will be ignored</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const forceStaticNextUrlHandlers = {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">target: NextURL &amp; UrlSymbolTarget,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">receiver: any</span><span class="s3">\n  </span><span class="s1">): unknown {</span><span class="s3">\n    </span><span class="s1">switch (prop) {</span><span class="s3">\n      </span><span class="s1">// URL properties</span><span class="s3">\n      </span><span class="s1">case 'search':</span><span class="s3">\n        </span><span class="s1">return ''</span><span class="s3">\n      </span><span class="s1">case 'searchParams':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[searchParamsSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[searchParamsSymbol] = new URLSearchParams())</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'href':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[hrefSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[hrefSymbol] = cleanURL(target.href).href)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'toJSON':</span><span class="s3">\n      </span><span class="s1">case 'toString':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[toStringSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[toStringSymbol] = () =&gt; receiver.href)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// NextUrl properties</span><span class="s3">\n      </span><span class="s1">case 'url':</span><span class="s3">\n        </span><span class="s1">// Currently nextURL does not expose url but our Docs indicate that it is an available property</span><span class="s3">\n        </span><span class="s1">// I am forcing this to undefined here to avoid accidentally exposing a dynamic value later if</span><span class="s3">\n        </span><span class="s1">// the underlying nextURL ends up adding this property</span><span class="s3">\n        </span><span class="s1">return undefined</span><span class="s3">\n      </span><span class="s1">case 'clone':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[urlCloneSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[urlCloneSymbol] = () =&gt;</span><span class="s3">\n            </span><span class="s1">new Proxy(target.clone(), forceStaticNextUrlHandlers))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function proxyNextRequest(request: NextRequest, workStore: WorkStore) {</span><span class="s3">\n  </span><span class="s1">const nextUrlHandlers = {</span><span class="s3">\n    </span><span class="s1">get(</span><span class="s3">\n      </span><span class="s1">target: NextURL &amp; UrlSymbolTarget,</span><span class="s3">\n      </span><span class="s1">prop: string | symbol,</span><span class="s3">\n      </span><span class="s1">receiver: any</span><span class="s3">\n    </span><span class="s1">): unknown {</span><span class="s3">\n      </span><span class="s1">switch (prop) {</span><span class="s3">\n        </span><span class="s1">case 'search':</span><span class="s3">\n        </span><span class="s1">case 'searchParams':</span><span class="s3">\n        </span><span class="s1">case 'url':</span><span class="s3">\n        </span><span class="s1">case 'href':</span><span class="s3">\n        </span><span class="s1">case 'toJSON':</span><span class="s3">\n        </span><span class="s1">case 'toString':</span><span class="s3">\n        </span><span class="s1">case 'origin': {</span><span class="s3">\n          </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n          </span><span class="s1">trackDynamic(workStore, workUnitStore, `nextUrl.${prop}`)</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'clone':</span><span class="s3">\n          </span><span class="s1">return (</span><span class="s3">\n            </span><span class="s1">target[urlCloneSymbol] ||</span><span class="s3">\n            </span><span class="s1">(target[urlCloneSymbol] = () =&gt;</span><span class="s3">\n              </span><span class="s1">new Proxy(target.clone(), nextUrlHandlers))</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const nextRequestHandlers = {</span><span class="s3">\n    </span><span class="s1">get(</span><span class="s3">\n      </span><span class="s1">target: NextRequest &amp; RequestSymbolTarget,</span><span class="s3">\n      </span><span class="s1">prop: string | symbol</span><span class="s3">\n    </span><span class="s1">): unknown {</span><span class="s3">\n      </span><span class="s1">switch (prop) {</span><span class="s3">\n        </span><span class="s1">case 'nextUrl':</span><span class="s3">\n          </span><span class="s1">return (</span><span class="s3">\n            </span><span class="s1">target[nextURLSymbol] ||</span><span class="s3">\n            </span><span class="s1">(target[nextURLSymbol] = new Proxy(target.nextUrl, nextUrlHandlers))</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">case 'headers':</span><span class="s3">\n        </span><span class="s1">case 'cookies':</span><span class="s3">\n        </span><span class="s1">case 'url':</span><span class="s3">\n        </span><span class="s1">case 'body':</span><span class="s3">\n        </span><span class="s1">case 'blob':</span><span class="s3">\n        </span><span class="s1">case 'json':</span><span class="s3">\n        </span><span class="s1">case 'text':</span><span class="s3">\n        </span><span class="s1">case 'arrayBuffer':</span><span class="s3">\n        </span><span class="s1">case 'formData': {</span><span class="s3">\n          </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n          </span><span class="s1">trackDynamic(workStore, workUnitStore, `request.${prop}`)</span><span class="s3">\n          </span><span class="s1">// The receiver arg is intentionally the same as the target to fix an issue with</span><span class="s3">\n          </span><span class="s1">// edge runtime, where attempting to access internal slots with the wrong `this` context</span><span class="s3">\n          </span><span class="s1">// results in an error.</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, target)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'clone':</span><span class="s3">\n          </span><span class="s1">return (</span><span class="s3">\n            </span><span class="s1">target[requestCloneSymbol] ||</span><span class="s3">\n            </span><span class="s1">(target[requestCloneSymbol] = () =&gt;</span><span class="s3">\n              </span><span class="s1">new Proxy(</span><span class="s3">\n                </span><span class="s1">// This is vaguely unsafe but it's required since NextRequest does not implement</span><span class="s3">\n                </span><span class="s1">// clone. The reason we might expect this to work in this context is the Proxy will</span><span class="s3">\n                </span><span class="s1">// respond with static-amenable values anyway somewhat restoring the interface.</span><span class="s3">\n                </span><span class="s1">// @TODO we need to rethink NextRequest and NextURL because they are not sufficientlly</span><span class="s3">\n                </span><span class="s1">// sophisticated to adequately represent themselves in all contexts. A better approach is</span><span class="s3">\n                </span><span class="s1">// to probably embed the static generation logic into the class itself removing the need</span><span class="s3">\n                </span><span class="s1">// for any kind of proxying</span><span class="s3">\n                </span><span class="s1">target.clone() as NextRequest,</span><span class="s3">\n                </span><span class="s1">nextRequestHandlers</span><span class="s3">\n              </span><span class="s1">))</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">// The receiver arg is intentionally the same as the target to fix an issue with</span><span class="s3">\n          </span><span class="s1">// edge runtime, where attempting to access internal slots with the wrong `this` context</span><span class="s3">\n          </span><span class="s1">// results in an error.</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, target)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// We don't need to proxy set because all the properties we proxy are ready only</span><span class="s3">\n    </span><span class="s1">// and will be ignored</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new Proxy(request, nextRequestHandlers)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const requireStaticRequestHandlers = {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">target: NextRequest &amp; RequestSymbolTarget,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">receiver: any</span><span class="s3">\n  </span><span class="s1">): unknown {</span><span class="s3">\n    </span><span class="s1">switch (prop) {</span><span class="s3">\n      </span><span class="s1">case 'nextUrl':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[nextURLSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[nextURLSymbol] = new Proxy(</span><span class="s3">\n            </span><span class="s1">target.nextUrl,</span><span class="s3">\n            </span><span class="s1">requireStaticNextUrlHandlers</span><span class="s3">\n          </span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'headers':</span><span class="s3">\n      </span><span class="s1">case 'cookies':</span><span class="s3">\n      </span><span class="s1">case 'url':</span><span class="s3">\n      </span><span class="s1">case 'body':</span><span class="s3">\n      </span><span class="s1">case 'blob':</span><span class="s3">\n      </span><span class="s1">case 'json':</span><span class="s3">\n      </span><span class="s1">case 'text':</span><span class="s3">\n      </span><span class="s1">case 'arrayBuffer':</span><span class="s3">\n      </span><span class="s1">case 'formData':</span><span class="s3">\n        </span><span class="s1">throw new StaticGenBailoutError(</span><span class="s3">\n          </span><span class="s1">`Route ${target.nextUrl.pathname} with </span><span class="s3">\\</span><span class="s1">`dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;\\</span><span class="s1">` couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`request.${prop}</span><span class="s3">\\</span><span class="s1">`.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'clone':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[requestCloneSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[requestCloneSymbol] = () =&gt;</span><span class="s3">\n            </span><span class="s1">new Proxy(</span><span class="s3">\n              </span><span class="s1">// This is vaguely unsafe but it's required since NextRequest does not implement</span><span class="s3">\n              </span><span class="s1">// clone. The reason we might expect this to work in this context is the Proxy will</span><span class="s3">\n              </span><span class="s1">// respond with static-amenable values anyway somewhat restoring the interface.</span><span class="s3">\n              </span><span class="s1">// @TODO we need to rethink NextRequest and NextURL because they are not sufficientlly</span><span class="s3">\n              </span><span class="s1">// sophisticated to adequately represent themselves in all contexts. A better approach is</span><span class="s3">\n              </span><span class="s1">// to probably embed the static generation logic into the class itself removing the need</span><span class="s3">\n              </span><span class="s1">// for any kind of proxying</span><span class="s3">\n              </span><span class="s1">target.clone() as NextRequest,</span><span class="s3">\n              </span><span class="s1">requireStaticRequestHandlers</span><span class="s3">\n            </span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// We don't need to proxy set because all the properties we proxy are ready only</span><span class="s3">\n  </span><span class="s1">// and will be ignored</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const requireStaticNextUrlHandlers = {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">target: NextURL &amp; UrlSymbolTarget,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">receiver: any</span><span class="s3">\n  </span><span class="s1">): unknown {</span><span class="s3">\n    </span><span class="s1">switch (prop) {</span><span class="s3">\n      </span><span class="s1">case 'search':</span><span class="s3">\n      </span><span class="s1">case 'searchParams':</span><span class="s3">\n      </span><span class="s1">case 'url':</span><span class="s3">\n      </span><span class="s1">case 'href':</span><span class="s3">\n      </span><span class="s1">case 'toJSON':</span><span class="s3">\n      </span><span class="s1">case 'toString':</span><span class="s3">\n      </span><span class="s1">case 'origin':</span><span class="s3">\n        </span><span class="s1">throw new StaticGenBailoutError(</span><span class="s3">\n          </span><span class="s1">`Route ${target.pathname} with </span><span class="s3">\\</span><span class="s1">`dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;\\</span><span class="s1">` couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`nextUrl.${prop}</span><span class="s3">\\</span><span class="s1">`.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'clone':</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">target[urlCloneSymbol] ||</span><span class="s3">\n          </span><span class="s1">(target[urlCloneSymbol] = () =&gt;</span><span class="s3">\n            </span><span class="s1">new Proxy(target.clone(), requireStaticNextUrlHandlers))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createCacheComponentsError(route: string) {</span><span class="s3">\n  </span><span class="s1">return new DynamicServerError(</span><span class="s3">\n    </span><span class="s1">`Route ${route} couldn't be rendered statically because it used IO that was not cached. See more info here: https://nextjs.org/docs/messages/cache-components`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function trackDynamic(</span><span class="s3">\n  </span><span class="s1">store: WorkStore,</span><span class="s3">\n  </span><span class="s1">workUnitStore: undefined | WorkUnitStore,</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">if (store.dynamicShouldError) {</span><span class="s3">\n    </span><span class="s1">throw new StaticGenBailoutError(</span><span class="s3">\n      </span><span class="s1">`Route ${store.route} with </span><span class="s3">\\</span><span class="s1">`dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;\\</span><span class="s1">` couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">// TODO: Should we allow reading cookies and search params from the</span><span class="s3">\n        </span><span class="s1">// request for private caches in route handlers?</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Route ${store.route} used </span><span class="s3">\&quot;</span><span class="s1">${expression}</span><span class="s3">\&quot; </span><span class="s1">inside </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use </span><span class="s3">\&quot;</span><span class="s1">${expression}</span><span class="s3">\&quot; </span><span class="s1">outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Route ${store.route} used </span><span class="s3">\&quot;</span><span class="s1">${expression}</span><span class="s3">\&quot; </span><span class="s1">inside a function cached with </span><span class="s3">\&quot;</span><span class="s1">unstable_cache(...)</span><span class="s3">\&quot;</span><span class="s1">. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use </span><span class="s3">\&quot;</span><span class="s1">${expression}</span><span class="s3">\&quot; </span><span class="s1">outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n        </span><span class="s1">const error = new Error(</span><span class="s3">\n          </span><span class="s1">`Route ${store.route} used ${expression} without first calling </span><span class="s3">\\</span><span class="s1">`await connection()</span><span class="s3">\\</span><span class="s1">`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-request`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return abortAndThrowOnSynchronousRequestDataAccess(</span><span class="s3">\n          </span><span class="s1">store.route,</span><span class="s3">\n          </span><span class="s1">expression,</span><span class="s3">\n          </span><span class="s1">error,</span><span class="s3">\n          </span><span class="s1">workUnitStore</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'A client prerender store should not be used for a route handler.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'A runtime prerender store should not be used for a route handler.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n        </span><span class="s1">return postponeWithTracking(</span><span class="s3">\n          </span><span class="s1">store.route,</span><span class="s3">\n          </span><span class="s1">expression,</span><span class="s3">\n          </span><span class="s1">workUnitStore.dynamicTracking</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">workUnitStore.revalidate = 0</span><span class="s3">\n\n        </span><span class="s1">const err = new DynamicServerError(</span><span class="s3">\n          </span><span class="s1">`Route ${store.route} couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`${expression}</span><span class="s3">\\</span><span class="s1">`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">store.dynamicUsageDescription = expression</span><span class="s3">\n        </span><span class="s1">store.dynamicUsageStack = err.stack</span><span class="s3">\n\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n          </span><span class="s1">// TODO: This is currently not really needed for route handlers, as it</span><span class="s3">\n          </span><span class="s1">// only controls the ISR status that's shown for pages.</span><span class="s3">\n          </span><span class="s1">workUnitStore.usedDynamic = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AppRouteModule } from '../module.compiled'</span><span class="s3">\n\n</span><span class="s1">// route handlers are only statically optimized if they define</span><span class="s3">\n</span><span class="s1">// one of these top-level configs manually</span><span class="s3">\n</span><span class="s1">//   - dynamic = 'force-static'</span><span class="s3">\n</span><span class="s1">//   - dynamic = 'error'</span><span class="s3">\n</span><span class="s1">//   - revalidate &gt; 0</span><span class="s3">\n</span><span class="s1">//   - revalidate = false</span><span class="s3">\n</span><span class="s1">//   - generateStaticParams</span><span class="s3">\n</span><span class="s1">export function isStaticGenEnabled(</span><span class="s3">\n  </span><span class="s1">mod: AppRouteModule['routeModule']['userland']</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">mod.dynamic === 'force-static' ||</span><span class="s3">\n    </span><span class="s1">mod.dynamic === 'error' ||</span><span class="s3">\n    </span><span class="s1">mod.revalidate === false ||</span><span class="s3">\n    </span><span class="s1">(mod.revalidate !== undefined &amp;&amp; mod.revalidate &gt; 0) ||</span><span class="s3">\n    </span><span class="s1">typeof mod.generateStaticParams == 'function'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Based on https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">import * as React from 'react'</span><span class="s3">\n</span><span class="s1">import { cloneResponse } from './clone-response'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">const simpleCacheKey = '[</span><span class="s3">\&quot;</span><span class="s1">GET</span><span class="s3">\&quot;</span><span class="s1">,[],null,</span><span class="s3">\&quot;</span><span class="s1">follow</span><span class="s3">\&quot;</span><span class="s1">,null,null,null,null]' // generateCacheKey(new Request('https://blank'));</span><span class="s3">\n\n</span><span class="s1">function generateCacheKey(request: Request): string {</span><span class="s3">\n  </span><span class="s1">// We pick the fields that goes into the key used to dedupe requests.</span><span class="s3">\n  </span><span class="s1">// We don't include the `cache` field, because we end up using whatever</span><span class="s3">\n  </span><span class="s1">// caching resulted from the first request.</span><span class="s3">\n  </span><span class="s1">// Notably we currently don't consider non-standard (or future) options.</span><span class="s3">\n  </span><span class="s1">// This might not be safe. TODO: warn for non-standard extensions differing.</span><span class="s3">\n  </span><span class="s1">// IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.</span><span class="s3">\n  </span><span class="s1">return JSON.stringify([</span><span class="s3">\n    </span><span class="s1">request.method,</span><span class="s3">\n    </span><span class="s1">Array.from(request.headers.entries()),</span><span class="s3">\n    </span><span class="s1">request.mode,</span><span class="s3">\n    </span><span class="s1">request.redirect,</span><span class="s3">\n    </span><span class="s1">request.credentials,</span><span class="s3">\n    </span><span class="s1">request.referrer,</span><span class="s3">\n    </span><span class="s1">request.referrerPolicy,</span><span class="s3">\n    </span><span class="s1">request.integrity,</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type CacheEntry = [</span><span class="s3">\n  </span><span class="s1">key: string,</span><span class="s3">\n  </span><span class="s1">promise: Promise&lt;Response&gt;,</span><span class="s3">\n  </span><span class="s1">response: Response | null,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export function createDedupeFetch(originalFetch: typeof fetch) {</span><span class="s3">\n  </span><span class="s1">const getCacheEntries = React.cache(</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars -- url is the cache key</span><span class="s3">\n    </span><span class="s1">(url: string): CacheEntry[] =&gt; []</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return function dedupeFetch(</span><span class="s3">\n    </span><span class="s1">resource: URL | RequestInfo,</span><span class="s3">\n    </span><span class="s1">options?: RequestInit</span><span class="s3">\n  </span><span class="s1">): Promise&lt;Response&gt; {</span><span class="s3">\n    </span><span class="s1">if (options &amp;&amp; options.signal) {</span><span class="s3">\n      </span><span class="s1">// If we're passed a signal, then we assume that</span><span class="s3">\n      </span><span class="s1">// someone else controls the lifetime of this object and opts out of</span><span class="s3">\n      </span><span class="s1">// caching. It's effectively the opt-out mechanism.</span><span class="s3">\n      </span><span class="s1">// Ideally we should be able to check this on the Request but</span><span class="s3">\n      </span><span class="s1">// it always gets initialized with its own signal so we don't</span><span class="s3">\n      </span><span class="s1">// know if it's supposed to override - unless we also override the</span><span class="s3">\n      </span><span class="s1">// Request constructor.</span><span class="s3">\n      </span><span class="s1">return originalFetch(resource, options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Normalize the Request</span><span class="s3">\n    </span><span class="s1">let url: string</span><span class="s3">\n    </span><span class="s1">let cacheKey: string</span><span class="s3">\n    </span><span class="s1">if (typeof resource === 'string' &amp;&amp; !options) {</span><span class="s3">\n      </span><span class="s1">// Fast path.</span><span class="s3">\n      </span><span class="s1">cacheKey = simpleCacheKey</span><span class="s3">\n      </span><span class="s1">url = resource</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Normalize the request.</span><span class="s3">\n      </span><span class="s1">// if resource is not a string or a URL (its an instance of Request)</span><span class="s3">\n      </span><span class="s1">// then do not instantiate a new Request but instead</span><span class="s3">\n      </span><span class="s1">// reuse the request as to not disturb the body in the event it's a ReadableStream.</span><span class="s3">\n      </span><span class="s1">const request =</span><span class="s3">\n        </span><span class="s1">typeof resource === 'string' || resource instanceof URL</span><span class="s3">\n          </span><span class="s1">? new Request(resource, options)</span><span class="s3">\n          </span><span class="s1">: resource</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(request.method !== 'GET' &amp;&amp; request.method !== 'HEAD') ||</span><span class="s3">\n        </span><span class="s1">request.keepalive</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// We currently don't dedupe requests that might have side-effects. Those</span><span class="s3">\n        </span><span class="s1">// have to be explicitly cached. We assume that the request doesn't have a</span><span class="s3">\n        </span><span class="s1">// body if it's GET or HEAD.</span><span class="s3">\n        </span><span class="s1">// keepalive gets treated the same as if you passed a custom cache signal.</span><span class="s3">\n        </span><span class="s1">return originalFetch(resource, options)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">cacheKey = generateCacheKey(request)</span><span class="s3">\n      </span><span class="s1">url = request.url</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const cacheEntries = getCacheEntries(url)</span><span class="s3">\n    </span><span class="s1">for (let i = 0, j = cacheEntries.length; i &lt; j; i += 1) {</span><span class="s3">\n      </span><span class="s1">const [key, promise] = cacheEntries[i]</span><span class="s3">\n      </span><span class="s1">if (key === cacheKey) {</span><span class="s3">\n        </span><span class="s1">return promise.then(() =&gt; {</span><span class="s3">\n          </span><span class="s1">const response = cacheEntries[i][2]</span><span class="s3">\n          </span><span class="s1">if (!response) throw new InvariantError('No cached response')</span><span class="s3">\n\n          </span><span class="s1">// We're cloning the response using this utility because there exists</span><span class="s3">\n          </span><span class="s1">// a bug in the undici library around response cloning. See the</span><span class="s3">\n          </span><span class="s1">// following pull request for more details:</span><span class="s3">\n          </span><span class="s1">// https://github.com/vercel/next.js/pull/73274</span><span class="s3">\n          </span><span class="s1">const [cloned1, cloned2] = cloneResponse(response)</span><span class="s3">\n          </span><span class="s1">cacheEntries[i][2] = cloned2</span><span class="s3">\n          </span><span class="s1">return cloned1</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We pass the original arguments here in case normalizing the Request</span><span class="s3">\n    </span><span class="s1">// doesn't include all the options in this environment.</span><span class="s3">\n    </span><span class="s1">const promise = originalFetch(resource, options)</span><span class="s3">\n    </span><span class="s1">const entry: CacheEntry = [cacheKey, promise, null]</span><span class="s3">\n    </span><span class="s1">cacheEntries.push(entry)</span><span class="s3">\n\n    </span><span class="s1">return promise.then((response) =&gt; {</span><span class="s3">\n      </span><span class="s1">// We're cloning the response using this utility because there exists</span><span class="s3">\n      </span><span class="s1">// a bug in the undici library around response cloning. See the</span><span class="s3">\n      </span><span class="s1">// following pull request for more details:</span><span class="s3">\n      </span><span class="s1">// https://github.com/vercel/next.js/pull/73274</span><span class="s3">\n      </span><span class="s1">const [cloned1, cloned2] = cloneResponse(response)</span><span class="s3">\n      </span><span class="s1">entry[2] = cloned2</span><span class="s3">\n      </span><span class="s1">return cloned1</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts the query into params.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param query the query to convert to params</span><span class="s3">\n </span><span class="s1">* @returns the params</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parsedUrlQueryToParams(</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n</span><span class="s1">): Record&lt;string, string | string[]&gt; {</span><span class="s3">\n  </span><span class="s1">const params: Record&lt;string, string | string[]&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n    </span><span class="s1">params[key] = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { NextRequest } from '../web/exports'</span><span class="s3">\n</span><span class="s1">import { ACTION_HEADER } from '../../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">export function getServerActionRequestMetadata(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage | BaseNextRequest | NextRequest</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">actionId: string | null</span><span class="s3">\n  </span><span class="s1">isURLEncodedAction: boolean</span><span class="s3">\n  </span><span class="s1">isMultipartAction: boolean</span><span class="s3">\n  </span><span class="s1">isFetchAction: boolean</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction: boolean</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">let actionId: string | null</span><span class="s3">\n  </span><span class="s1">let contentType: string | null</span><span class="s3">\n\n  </span><span class="s1">if (req.headers instanceof Headers) {</span><span class="s3">\n    </span><span class="s1">actionId = req.headers.get(ACTION_HEADER) ?? null</span><span class="s3">\n    </span><span class="s1">contentType = req.headers.get('content-type')</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">actionId = (req.headers[ACTION_HEADER] as string) ?? null</span><span class="s3">\n    </span><span class="s1">contentType = req.headers['content-type'] ?? null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const isURLEncodedAction = Boolean(</span><span class="s3">\n    </span><span class="s1">req.method === 'POST' &amp;&amp; contentType === 'application/x-www-form-urlencoded'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const isMultipartAction = Boolean(</span><span class="s3">\n    </span><span class="s1">req.method === 'POST' &amp;&amp; contentType?.startsWith('multipart/form-data')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const isFetchAction = Boolean(</span><span class="s3">\n    </span><span class="s1">actionId !== undefined &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof actionId === 'string' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">req.method === 'POST'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const isPossibleServerAction = Boolean(</span><span class="s3">\n    </span><span class="s1">isFetchAction || isURLEncodedAction || isMultipartAction</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">actionId,</span><span class="s3">\n    </span><span class="s1">isURLEncodedAction,</span><span class="s3">\n    </span><span class="s1">isMultipartAction,</span><span class="s3">\n    </span><span class="s1">isFetchAction,</span><span class="s3">\n    </span><span class="s1">isPossibleServerAction,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getIsPossibleServerAction(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage | BaseNextRequest | NextRequest</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return getServerActionRequestMetadata(req).isPossibleServerAction</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { WorkStore } from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type { IncrementalCache } from '../lib/incremental-cache'</span><span class="s3">\n</span><span class="s1">import type { RenderOpts } from '../app-render/types'</span><span class="s3">\n</span><span class="s1">import type { FetchMetric } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { RequestLifecycleOpts } from '../base-server'</span><span class="s3">\n</span><span class="s1">import type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'</span><span class="s3">\n</span><span class="s1">import type { CacheLife } from '../use-cache/cache-life'</span><span class="s3">\n\n</span><span class="s1">import { AfterContext } from '../after/after-context'</span><span class="s3">\n\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { createLazyResult, type LazyResult } from '../lib/lazy-result'</span><span class="s3">\n</span><span class="s1">import { getCacheHandlerEntries } from '../use-cache/handlers'</span><span class="s3">\n</span><span class="s1">import { createSnapshot } from '../app-render/async-local-storage'</span><span class="s3">\n\n</span><span class="s1">export type WorkStoreContext = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The page that is being rendered. This relates to the path to the page file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n\n  </span><span class="s1">isPrefetchRequest?: boolean</span><span class="s3">\n  </span><span class="s1">renderOpts: {</span><span class="s3">\n    </span><span class="s1">cacheLifeProfiles?: { [profile: string]: CacheLife }</span><span class="s3">\n    </span><span class="s1">incrementalCache?: IncrementalCache</span><span class="s3">\n    </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n    </span><span class="s1">fetchCache?: AppSegmentConfig['fetchCache']</span><span class="s3">\n    </span><span class="s1">isPossibleServerAction?: boolean</span><span class="s3">\n    </span><span class="s1">pendingWaitUntil?: Promise&lt;any&gt;</span><span class="s3">\n    </span><span class="s1">experimental: Pick&lt;</span><span class="s3">\n      </span><span class="s1">RenderOpts['experimental'],</span><span class="s3">\n      </span><span class="s1">'isRoutePPREnabled' | 'cacheComponents' | 'authInterrupts'</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Fetch metrics attached in patch-fetch.ts</span><span class="s3">\n     </span><span class="s1">**/</span><span class="s3">\n    </span><span class="s1">fetchMetrics?: FetchMetric[]</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A hack around accessing the store value outside the context of the</span><span class="s3">\n     </span><span class="s1">* request.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @internal</span><span class="s3">\n     </span><span class="s1">* @deprecated should only be used as a temporary workaround</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">// TODO: remove this when we resolve accessing the store outside the execution context</span><span class="s3">\n    </span><span class="s1">store?: WorkStore</span><span class="s3">\n  </span><span class="s1">} &amp; Pick&lt;</span><span class="s3">\n    </span><span class="s1">// Pull some properties from RenderOpts so that the docs are also</span><span class="s3">\n    </span><span class="s1">// mirrored.</span><span class="s3">\n    </span><span class="s1">RenderOpts,</span><span class="s3">\n    </span><span class="s1">| 'assetPrefix'</span><span class="s3">\n    </span><span class="s1">| 'supportsDynamicResponse'</span><span class="s3">\n    </span><span class="s1">| 'shouldWaitOnAllReady'</span><span class="s3">\n    </span><span class="s1">| 'isRevalidate'</span><span class="s3">\n    </span><span class="s1">| 'nextExport'</span><span class="s3">\n    </span><span class="s1">| 'isDraftMode'</span><span class="s3">\n    </span><span class="s1">| 'isDebugDynamicAccesses'</span><span class="s3">\n    </span><span class="s1">| 'dev'</span><span class="s3">\n    </span><span class="s1">| 'hasReadableErrorStacks'</span><span class="s3">\n  </span><span class="s1">&gt; &amp;</span><span class="s3">\n    </span><span class="s1">RequestLifecycleOpts &amp;</span><span class="s3">\n    </span><span class="s1">Partial&lt;Pick&lt;RenderOpts, 'reactLoadableManifest'&gt;&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The build ID of the current build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n\n  </span><span class="s1">// Tags that were previously revalidated (e.g. by a redirecting server action)</span><span class="s3">\n  </span><span class="s1">// and have already been sent to cache handlers.</span><span class="s3">\n  </span><span class="s1">previouslyRevalidatedTags: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createWorkStore({</span><span class="s3">\n  </span><span class="s1">page,</span><span class="s3">\n  </span><span class="s1">renderOpts,</span><span class="s3">\n  </span><span class="s1">isPrefetchRequest,</span><span class="s3">\n  </span><span class="s1">buildId,</span><span class="s3">\n  </span><span class="s1">previouslyRevalidatedTags,</span><span class="s3">\n</span><span class="s1">}: WorkStoreContext): WorkStore {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Rules of Static &amp; Dynamic HTML:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*    1.) We must generate static HTML unless the caller explicitly opts</span><span class="s3">\n   </span><span class="s1">*        in to dynamic HTML support.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*    2.) If dynamic HTML support is requested, we must honor that request</span><span class="s3">\n   </span><span class="s1">*        or throw an error. It is the sole responsibility of the caller to</span><span class="s3">\n   </span><span class="s1">*        ensure they aren't e.g. requesting dynamic HTML for an AMP page.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*    3.) If the request is in draft mode, we must generate dynamic HTML.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*    4.) If the request is a server action, we must generate dynamic HTML.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* These rules help ensure that other existing features like request caching,</span><span class="s3">\n   </span><span class="s1">* coalescing, and ISR continue working as intended.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const isStaticGeneration =</span><span class="s3">\n    </span><span class="s1">!renderOpts.shouldWaitOnAllReady &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!renderOpts.supportsDynamicResponse &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!renderOpts.isDraftMode &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!renderOpts.isPossibleServerAction</span><span class="s3">\n\n  </span><span class="s1">const isDevelopment = renderOpts.dev ?? false</span><span class="s3">\n\n  </span><span class="s1">const shouldTrackFetchMetrics =</span><span class="s3">\n    </span><span class="s1">isDevelopment ||</span><span class="s3">\n    </span><span class="s1">// The only times we want to track fetch metrics outside of development is</span><span class="s3">\n    </span><span class="s1">// when we are performing a static generation and we either are in debug</span><span class="s3">\n    </span><span class="s1">// mode, or tracking fetch metrics was specifically opted into.</span><span class="s3">\n    </span><span class="s1">(isStaticGeneration &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!!process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n        </span><span class="s1">process.env.NEXT_SSG_FETCH_METRICS === '1'))</span><span class="s3">\n\n  </span><span class="s1">const store: WorkStore = {</span><span class="s3">\n    </span><span class="s1">isStaticGeneration,</span><span class="s3">\n    </span><span class="s1">page,</span><span class="s3">\n    </span><span class="s1">route: normalizeAppPath(page),</span><span class="s3">\n    </span><span class="s1">incrementalCache:</span><span class="s3">\n      </span><span class="s1">// we fallback to a global incremental cache for edge-runtime locally</span><span class="s3">\n      </span><span class="s1">// so that it can access the fs cache without mocks</span><span class="s3">\n      </span><span class="s1">renderOpts.incrementalCache || (globalThis as any).__incrementalCache,</span><span class="s3">\n    </span><span class="s1">cacheLifeProfiles: renderOpts.cacheLifeProfiles,</span><span class="s3">\n    </span><span class="s1">isRevalidate: renderOpts.isRevalidate,</span><span class="s3">\n    </span><span class="s1">isBuildTimePrerendering: renderOpts.nextExport,</span><span class="s3">\n    </span><span class="s1">hasReadableErrorStacks: renderOpts.hasReadableErrorStacks,</span><span class="s3">\n    </span><span class="s1">fetchCache: renderOpts.fetchCache,</span><span class="s3">\n    </span><span class="s1">isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,</span><span class="s3">\n\n    </span><span class="s1">isDraftMode: renderOpts.isDraftMode,</span><span class="s3">\n\n    </span><span class="s1">isPrefetchRequest,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n    </span><span class="s1">reactLoadableManifest: renderOpts?.reactLoadableManifest || {},</span><span class="s3">\n    </span><span class="s1">assetPrefix: renderOpts?.assetPrefix || '',</span><span class="s3">\n\n    </span><span class="s1">afterContext: createAfterContext(renderOpts),</span><span class="s3">\n    </span><span class="s1">cacheComponentsEnabled: renderOpts.experimental.cacheComponents,</span><span class="s3">\n    </span><span class="s1">dev: isDevelopment,</span><span class="s3">\n    </span><span class="s1">previouslyRevalidatedTags,</span><span class="s3">\n    </span><span class="s1">refreshTagsByCacheKind: createRefreshTagsByCacheKind(),</span><span class="s3">\n    </span><span class="s1">runInCleanSnapshot: createSnapshot(),</span><span class="s3">\n    </span><span class="s1">shouldTrackFetchMetrics,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO: remove this when we resolve accessing the store outside the execution context</span><span class="s3">\n  </span><span class="s1">renderOpts.store = store</span><span class="s3">\n\n  </span><span class="s1">return store</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createAfterContext(renderOpts: RequestLifecycleOpts): AfterContext {</span><span class="s3">\n  </span><span class="s1">const { waitUntil, onClose, onAfterTaskError } = renderOpts</span><span class="s3">\n  </span><span class="s1">return new AfterContext({</span><span class="s3">\n    </span><span class="s1">waitUntil,</span><span class="s3">\n    </span><span class="s1">onClose,</span><span class="s3">\n    </span><span class="s1">onTaskError: onAfterTaskError,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a map with lazy results that refresh tags for the respective cache</span><span class="s3">\n </span><span class="s1">* kind when they're awaited for the first time.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createRefreshTagsByCacheKind(): Map&lt;string, LazyResult&lt;void&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">const refreshTagsByCacheKind = new Map&lt;string, LazyResult&lt;void&gt;&gt;()</span><span class="s3">\n  </span><span class="s1">const cacheHandlers = getCacheHandlerEntries()</span><span class="s3">\n\n  </span><span class="s1">if (cacheHandlers) {</span><span class="s3">\n    </span><span class="s1">for (const [kind, cacheHandler] of cacheHandlers) {</span><span class="s3">\n      </span><span class="s1">if ('refreshTags' in cacheHandler) {</span><span class="s3">\n        </span><span class="s1">refreshTagsByCacheKind.set(</span><span class="s3">\n          </span><span class="s1">kind,</span><span class="s3">\n          </span><span class="s1">createLazyResult(async () =&gt; cacheHandler.refreshTags())</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return refreshTagsByCacheKind</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Get pathname from absolute path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param absolutePath the absolute path</span><span class="s3">\n </span><span class="s1">* @returns the pathname</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getPathnameFromAbsolutePath(absolutePath: string) {</span><span class="s3">\n  </span><span class="s1">// Remove prefix including app dir</span><span class="s3">\n  </span><span class="s1">let appDir = '/app/'</span><span class="s3">\n  </span><span class="s1">if (!absolutePath.includes(appDir)) {</span><span class="s3">\n    </span><span class="s1">appDir = '</span><span class="s3">\\\\</span><span class="s1">app</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const [, ...parts] = absolutePath.split(appDir)</span><span class="s3">\n  </span><span class="s1">const relativePath = appDir[0] + parts.join(appDir)</span><span class="s3">\n\n  </span><span class="s1">// remove extension</span><span class="s3">\n  </span><span class="s1">const pathname = relativePath.split('.').slice(0, -1).join('.')</span><span class="s3">\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Cleans a URL by stripping the protocol, host, and search params.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param urlString the url to clean</span><span class="s3">\n </span><span class="s1">* @returns the cleaned url</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function cleanURL(url: string | URL): URL {</span><span class="s3">\n  </span><span class="s1">const u = new URL(url)</span><span class="s3">\n  </span><span class="s1">u.host = 'localhost:3000'</span><span class="s3">\n  </span><span class="s1">u.search = ''</span><span class="s3">\n  </span><span class="s1">u.protocol = 'http'</span><span class="s3">\n  </span><span class="s1">return u</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;__nccwpck_require__&quot;</span><span class="s0">,</span><span class="s1">&quot;__dirname&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinite&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;clearTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;clearInterval&quot;</span><span class="s0">,</span><span class="s1">&quot;setInterval&quot;</span><span class="s0">,</span><span class="s1">&quot;u&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;reportError&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;HTML_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_QUERY_PARAM_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_INTERCEPTION_MARKER_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;PRERENDER_REVALIDATE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_PREFETCH_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENTS_DIR_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENT_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DATA_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_META_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATED_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_TAG_MAX_ITEMS&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_TAG_MAX_LENGTH&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_IMPLICIT_TAG_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;CACHE_ONE_YEAR&quot;</span><span class="s0">,</span><span class="s1">&quot;INFINITE_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;WEBPACK_LAYERS_NAMES&quot;</span><span class="s0">,</span><span class="s1">&quot;shared&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;serverSideRendering&quot;</span><span class="s0">,</span><span class="s1">&quot;actionBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;apiNode&quot;</span><span class="s0">,</span><span class="s1">&quot;apiEdge&quot;</span><span class="s0">,</span><span class="s1">&quot;middleware&quot;</span><span class="s0">,</span><span class="s1">&quot;instrument&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeAsset&quot;</span><span class="s0">,</span><span class="s1">&quot;appPagesBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirEdge&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirNode&quot;</span><span class="s0">,</span><span class="s1">&quot;GROUP&quot;</span><span class="s0">,</span><span class="s1">&quot;builtinReact&quot;</span><span class="s0">,</span><span class="s1">&quot;serverOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;neutralTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;clientOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;bundled&quot;</span><span class="s0">,</span><span class="s1">&quot;appPages&quot;</span><span class="s0">,</span><span class="s1">&quot;formatDynamicImportPath&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToFileURL&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;checkIsOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;previewProps&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;HeadersAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;isOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeId&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateOnlyGenerated&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;COOKIE_NAME_PRERENDER_BYPASS&quot;</span><span class="s0">,</span><span class="s1">&quot;COOKIE_NAME_PRERENDER_DATA&quot;</span><span class="s0">,</span><span class="s1">&quot;SYMBOL_PREVIEW_DATA&quot;</span><span class="s0">,</span><span class="s1">&quot;SYMBOL_CLEARED_COOKIES&quot;</span><span class="s0">,</span><span class="s1">&quot;clearPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;serialize&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;previous&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;expires&quot;</span><span class="s0">,</span><span class="s1">&quot;httpOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;sameSite&quot;</span><span class="s0">,</span><span class="s1">&quot;secure&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;tryGetPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;multiZoneDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptedPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;RequestCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;jsonwebtoken&quot;</span><span class="s0">,</span><span class="s1">&quot;verify&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeSigningKey&quot;</span><span class="s0">,</span><span class="s1">&quot;decryptWithSecret&quot;</span><span class="s0">,</span><span class="s1">&quot;decryptedPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeEncryptionKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;CIPHER_ALGORITHM&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptWithSecret&quot;</span><span class="s0">,</span><span class="s1">&quot;secret&quot;</span><span class="s0">,</span><span class="s1">&quot;iv&quot;</span><span class="s0">,</span><span class="s1">&quot;crypto&quot;</span><span class="s0">,</span><span class="s1">&quot;salt&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;cipher&quot;</span><span class="s0">,</span><span class="s1">&quot;encrypted&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;final&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;getAuthTag&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptedData&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;CIPHER_SALT_LENGTH&quot;</span><span class="s0">,</span><span class="s1">&quot;decipher&quot;</span><span class="s0">,</span><span class="s1">&quot;setAuthTag&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeFs&quot;</span><span class="s0">,</span><span class="s1">&quot;existsSync&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">,</span><span class="s1">&quot;readFileSync&quot;</span><span class="s0">,</span><span class="s1">&quot;writeFile&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;mkdir&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;stat&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadonlyHeadersError&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;callable&quot;</span><span class="s0">,</span><span class="s1">&quot;Headers&quot;</span><span class="s0">,</span><span class="s1">&quot;Proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;receiver&quot;</span><span class="s0">,</span><span class="s1">&quot;ReflectAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;lowercased&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;original&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;seal&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;callbackfn&quot;</span><span class="s0">,</span><span class="s1">&quot;thisArg&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;Reflect&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;registry&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;COMPILER_NAMES&quot;</span><span class="s0">,</span><span class="s1">&quot;client&quot;</span><span class="s0">,</span><span class="s1">&quot;server&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeServer&quot;</span><span class="s0">,</span><span class="s1">&quot;BUILD_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;parseReqUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsed&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getAll&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;auth&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;slashes&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeLocalePath&quot;</span><span class="s0">,</span><span class="s1">&quot;locales&quot;</span><span class="s0">,</span><span class="s1">&quot;detectedLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;lowercasedLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;locale&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureLeadingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRscURL&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_ROUTE_MARKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;TEST_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;TEST_STRICT_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;strict&quot;</span><span class="s0">,</span><span class="s1">&quot;extractInterceptionRouteInformation&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;marker&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;splitInterceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePath&quot;</span><span class="s0">,</span><span class="s1">&quot;hashIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;queryIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;hasQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;pathHasPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;removePathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;withoutPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;reHasRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;reReplaceRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeStringRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAMETER_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;parseMatchedParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeKeyFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;backreferenceDuplicateKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;SP&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;DecodeError&quot;</span><span class="s0">,</span><span class="s1">&quot;NormalizeError&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAM_SEPARATOR&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAdjacentParameterIssues&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAdjacentParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;normalized&quot;</span><span class="s0">,</span><span class="s1">&quot;safePathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;needsNormalization&quot;</span><span class="s0">,</span><span class="s1">&quot;routeToUse&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;retryError&quot;</span><span class="s0">,</span><span class="s1">&quot;safeCompile&quot;</span><span class="s0">,</span><span class="s1">&quot;compile&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;matcherFn&quot;</span><span class="s0">,</span><span class="s1">&quot;re&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;group&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;cleaned&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParamsToUrlQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyUrlQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;unescapeSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;compileNonPath&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeNextQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeQueryPathParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;slashedProtocols&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParamTypesSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterStateSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;FLIGHT_HEADERS&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;filterInternalQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;paramKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextQueryPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextInterceptionMarkerPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;detectDomainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;domainItems&quot;</span><span class="s0">,</span><span class="s1">&quot;domain&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;getHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDataPath&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REQUEST_META&quot;</span><span class="s0">,</span><span class="s1">&quot;for&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;posix&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPage&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_METADATA_IMAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;icon&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;extensions&quot;</span><span class="s0">,</span><span class="s1">&quot;apple&quot;</span><span class="s0">,</span><span class="s1">&quot;openGraph&quot;</span><span class="s0">,</span><span class="s1">&quot;twitter&quot;</span><span class="s0">,</span><span class="s1">&quot;getExtensionRegexString&quot;</span><span class="s0">,</span><span class="s1">&quot;staticExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;DetachedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;rej&quot;</span><span class="s0">,</span><span class="s1">&quot;Batcher&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyFn&quot;</span><span class="s0">,</span><span class="s1">&quot;schedulerFn&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;batch&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleOnNextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleImmediate&quot;</span><span class="s0">,</span><span class="s1">&quot;setImmediate&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedRouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;voidCatch&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;encoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromString&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;streamToString&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;decoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextDecoder&quot;</span><span class="s0">,</span><span class="s1">&quot;fatal&quot;</span><span class="s0">,</span><span class="s1">&quot;string&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;suffix&quot;</span><span class="s0">,</span><span class="s1">&quot;REGEX_LOCALHOST_HOSTNAME&quot;</span><span class="s0">,</span><span class="s1">&quot;parseURL&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;Internal&quot;</span><span class="s0">,</span><span class="s1">&quot;NextURL&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;baseOrOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;analyze&quot;</span><span class="s0">,</span><span class="s1">&quot;info&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextPathnameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;i18n&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameNoDataPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;parseData&quot;</span><span class="s0">,</span><span class="s1">&quot;i18nProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_NO_MIDDLEWARE_URL_NORMALIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;domains&quot;</span><span class="s0">,</span><span class="s1">&quot;formatPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;addLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;ignorePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;lower&quot;</span><span class="s0">,</span><span class="s1">&quot;forceLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;formatSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;password&quot;</span><span class="s0">,</span><span class="s1">&quot;username&quot;</span><span class="s0">,</span><span class="s1">&quot;toJSON&quot;</span><span class="s0">,</span><span class="s1">&quot;clone&quot;</span><span class="s0">,</span><span class="s1">&quot;Request&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseAbortedName&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseAborted&quot;</span><span class="s0">,</span><span class="s1">&quot;NextNodeServerSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRenderSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouteRouteHandlersSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadStart&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadTimes&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadCount&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbortError&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeToNodeResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntilForEnd&quot;</span><span class="s0">,</span><span class="s1">&quot;errored&quot;</span><span class="s0">,</span><span class="s1">&quot;destroyed&quot;</span><span class="s0">,</span><span class="s1">&quot;createAbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;writableFinished&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;writer&quot;</span><span class="s0">,</span><span class="s1">&quot;createWriterFromResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;started&quot;</span><span class="s0">,</span><span class="s1">&quot;drained&quot;</span><span class="s0">,</span><span class="s1">&quot;onDrain&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;off&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;WritableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;write&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_OTEL_PERFORMANCE_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;metrics&quot;</span><span class="s0">,</span><span class="s1">&quot;getClientComponentLoaderMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;measure&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;flushHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;spanName&quot;</span><span class="s0">,</span><span class="s1">&quot;ok&quot;</span><span class="s0">,</span><span class="s1">&quot;flush&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">,</span><span class="s1">&quot;destroy&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeTo&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;EMPTY&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;fromStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;assignMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;isNull&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnchunkedString&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;chainStreams&quot;</span><span class="s0">,</span><span class="s1">&quot;streams&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;TransformStream&quot;</span><span class="s0">,</span><span class="s1">&quot;preventClose&quot;</span><span class="s0">,</span><span class="s1">&quot;nextStream&quot;</span><span class="s0">,</span><span class="s1">&quot;lastStream&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;coerce&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;fromResponseCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;html&quot;</span><span class="s0">,</span><span class="s1">&quot;pageData&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;rscData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;toResponseCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isMiss&quot;</span><span class="s0">,</span><span class="s1">&quot;isStale&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControl&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;minimal_mode&quot;</span><span class="s0">,</span><span class="s1">&quot;batcher&quot;</span><span class="s0">,</span><span class="s1">&quot;responseGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;hasResolved&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;isFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;prom&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheItem&quot;</span><span class="s0">,</span><span class="s1">&quot;expiresAt&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKindToIncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKind&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;isRevalidating&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveValue&quot;</span><span class="s0">,</span><span class="s1">&quot;newRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpire&quot;</span><span class="s0">,</span><span class="s1">&quot;expire&quot;</span><span class="s0">,</span><span class="s1">&quot;MultiFileWriter&quot;</span><span class="s0">,</span><span class="s1">&quot;tasks&quot;</span><span class="s0">,</span><span class="s1">&quot;findOrCreateTask&quot;</span><span class="s0">,</span><span class="s1">&quot;directory&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;wait&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;flatMap&quot;</span><span class="s0">,</span><span class="s1">&quot;FileSystemCache&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_DEBUG_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;flushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;serverDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;maxMemoryCacheSize&quot;</span><span class="s0">,</span><span class="s1">&quot;memoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;getMemoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;resetRequestCache&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateTag&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;fileData&quot;</span><span class="s0">,</span><span class="s1">&quot;mtime&quot;</span><span class="s0">,</span><span class="s1">&quot;lastModified&quot;</span><span class="s0">,</span><span class="s1">&quot;getTime&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedData&quot;</span><span class="s0">,</span><span class="s1">&quot;storedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeSegmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentsDir&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentDataFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheTags&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;combinedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;softTags&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;toRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;dev&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalMode&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCacheKeyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;CurCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedRevalidateHeaderKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;locks&quot;</span><span class="s0">,</span><span class="s1">&quot;hasCustomCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlersSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;_globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;globalCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TEST_MAX_ISR_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;disableForTestmode&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_TEST_PROXY&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControls&quot;</span><span class="s0">,</span><span class="s1">&quot;SharedCacheControls&quot;</span><span class="s0">,</span><span class="s1">&quot;preview&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreviouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;_requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;calculateRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;fromTime&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;timeOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;initialRevalidateSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;_getPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;lock&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyChunks&quot;</span><span class="s0">,</span><span class="s1">&quot;_ogBody&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;readableBody&quot;</span><span class="s0">,</span><span class="s1">&quot;chunks&quot;</span><span class="s0">,</span><span class="s1">&quot;total&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;formData&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;blob&quot;</span><span class="s0">,</span><span class="s1">&quot;Blob&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheString&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;credentials&quot;</span><span class="s0">,</span><span class="s1">&quot;referrer&quot;</span><span class="s0">,</span><span class="s1">&quot;referrerPolicy&quot;</span><span class="s0">,</span><span class="s1">&quot;integrity&quot;</span><span class="s0">,</span><span class="s1">&quot;createHash&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheData&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;resumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;memoryCacheData&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;age&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;itemSize&quot;</span><span class="s0">,</span><span class="s1">&quot;isImplicitBuildTimeCache&quot;</span><span class="s0">,</span><span class="s1">&quot;warningText&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersMapSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersSetSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;reference&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheHandlerEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;interopDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;mod&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;RouterServerContextSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;routerServerGlobal&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicImportEsmDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteModule&quot;</span><span class="s0">,</span><span class="s1">&quot;userland&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeProjectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;isDev&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentationOnRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteProjectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;cwd&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifests&quot;</span><span class="s0">,</span><span class="s1">&quot;srcPage&quot;</span><span class="s0">,</span><span class="s1">&quot;projectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifestFromRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;routesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;buildManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackBuildManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;reactLoadableManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFontManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;clientReferenceManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;serverActionsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;subresourceIntegrityManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;serverFilesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicCssManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;manifest&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMissing&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticMetadataRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRouteRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isMetadataRouteFile&quot;</span><span class="s0">,</span><span class="s1">&quot;appDirRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;pageExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;strictlyMatchExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;suffixMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;metadataRouteFilesRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedAppDirRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;useEval&quot;</span><span class="s0">,</span><span class="s1">&quot;skipParse&quot;</span><span class="s0">,</span><span class="s1">&quot;__RSC_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionRoutePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;regex&quot;</span><span class="s0">,</span><span class="s1">&quot;loadCustomCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;initializeCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultCache&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;RemoteCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;getIncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;CacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheMaxMemorySize&quot;</span><span class="s0">,</span><span class="s1">&quot;isrFlushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;onRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;errorContext&quot;</span><span class="s0">,</span><span class="s1">&quot;routerServerContext&quot;</span><span class="s0">,</span><span class="s1">&quot;logErrorWithOriginalStack&quot;</span><span class="s0">,</span><span class="s1">&quot;prepare&quot;</span><span class="s0">,</span><span class="s1">&quot;localeResult&quot;</span><span class="s0">,</span><span class="s1">&quot;previewData&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureInstrumentationRegistered&quot;</span><span class="s0">,</span><span class="s1">&quot;manifests&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextDataRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;originalQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;pageIsDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;serverUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixRouteKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;includeSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;includePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInterceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;paramMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;namedParameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;namedRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;excludeOptionalTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;parameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;getParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;groupIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;markerMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;checkRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;getPathMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;regexp&quot;</span><span class="s0">,</span><span class="s1">&quot;delimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;sensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;regexpToFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;regexModifier&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;removeUnnamedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;missing&quot;</span><span class="s0">,</span><span class="s1">&quot;hasParams&quot;</span><span class="s0">,</span><span class="s1">&quot;matchHas&quot;</span><span class="s0">,</span><span class="s1">&quot;hasMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasItem&quot;</span><span class="s0">,</span><span class="s1">&quot;getCookieParser&quot;</span><span class="s0">,</span><span class="s1">&quot;cookie&quot;</span><span class="s0">,</span><span class="s1">&quot;parseCookieFn&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;paramName&quot;</span><span class="s0">,</span><span class="s1">&quot;newParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;charCode&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;groupKey&quot;</span><span class="s0">,</span><span class="s1">&quot;stateHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndValidateFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;assert&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;newUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;escaped&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;parseRelativeUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;globalBase&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedBase&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedURL&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;destSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;destPath&quot;</span><span class="s0">,</span><span class="s1">&quot;destParams&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;strOrArray&quot;</span><span class="s0">,</span><span class="s1">&quot;appendParamsToQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;actualValue&quot;</span><span class="s0">,</span><span class="s1">&quot;nextInternalLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParams&quot;</span><span class="s0">,</span><span class="s1">&quot;afterFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesPage&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathnameNoSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeQueryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;routeParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;getParamsFromRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatchesHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;keyName&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDynamicRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreMissingOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;hasValidParams&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;isDefaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultVal&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeCdnUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;_parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;formatUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;urlObj&quot;</span><span class="s0">,</span><span class="s1">&quot;querystring&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolateDynamicPath&quot;</span><span class="s0">,</span><span class="s1">&quot;paramValue&quot;</span><span class="s0">,</span><span class="s1">&quot;builtParam&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceAll&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TRAILING_SLASH&quot;</span><span class="s0">,</span><span class="s1">&quot;addRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;combinedParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;originalValue&quot;</span><span class="s0">,</span><span class="s1">&quot;queryValue&quot;</span><span class="s0">,</span><span class="s1">&quot;queryResult&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsToInterpolate&quot;</span><span class="s0">,</span><span class="s1">&quot;isDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedSrcPage&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;seg&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;getResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;responseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handleResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;purpose&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadonlyRequestCookiesError&quot;</span><span class="s0">,</span><span class="s1">&quot;RequestCookiesAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;SYMBOL_MODIFY_COOKIE_VALUES&quot;</span><span class="s0">,</span><span class="s1">&quot;appendMutableCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;mutableCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;modifiedCookieValues&quot;</span><span class="s0">,</span><span class="s1">&quot;getModifiedCookieValues&quot;</span><span class="s0">,</span><span class="s1">&quot;modified&quot;</span><span class="s0">,</span><span class="s1">&quot;resCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;returnedCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;MutableRequestCookiesAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;wrap&quot;</span><span class="s0">,</span><span class="s1">&quot;onUpdateCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;responseCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;modifiedValues&quot;</span><span class="s0">,</span><span class="s1">&quot;modifiedCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;updateResponseCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;pathWasRevalidated&quot;</span><span class="s0">,</span><span class="s1">&quot;allCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;serializedCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;tempCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;wrappedCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureCookiesAreStillMutable&quot;</span><span class="s0">,</span><span class="s1">&quot;requestStore&quot;</span><span class="s0">,</span><span class="s1">&quot;_callingExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;DraftModeProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;cookieValue&quot;</span><span class="s0">,</span><span class="s1">&quot;_isEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;_previewModeId&quot;</span><span class="s0">,</span><span class="s1">&quot;_mutableCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;isEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;enable&quot;</span><span class="s0">,</span><span class="s1">&quot;disable&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeMiddlewareCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;setCookieValue&quot;</span><span class="s0">,</span><span class="s1">&quot;responseHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;splitCookiesString&quot;</span><span class="s0">,</span><span class="s1">&quot;cookiesString&quot;</span><span class="s0">,</span><span class="s1">&quot;ch&quot;</span><span class="s0">,</span><span class="s1">&quot;lastComma&quot;</span><span class="s0">,</span><span class="s1">&quot;nextStart&quot;</span><span class="s0">,</span><span class="s1">&quot;cookiesSeparatorFound&quot;</span><span class="s0">,</span><span class="s1">&quot;cookiesStrings&quot;</span><span class="s0">,</span><span class="s1">&quot;skipWhitespace&quot;</span><span class="s0">,</span><span class="s1">&quot;charAt&quot;</span><span class="s0">,</span><span class="s1">&quot;withExecuteRevalidates&quot;</span><span class="s0">,</span><span class="s1">&quot;store&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;savedRevalidationState&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneRevalidationState&quot;</span><span class="s0">,</span><span class="s1">&quot;newRevalidates&quot;</span><span class="s0">,</span><span class="s1">&quot;diffRevalidationState&quot;</span><span class="s0">,</span><span class="s1">&quot;prev&quot;</span><span class="s0">,</span><span class="s1">&quot;curr&quot;</span><span class="s0">,</span><span class="s1">&quot;prevTags&quot;</span><span class="s0">,</span><span class="s1">&quot;prevRevalidateWrites&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidateWrites&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidates&quot;</span><span class="s0">,</span><span class="s1">&quot;executeRevalidates&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateTags&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;handlers&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;expireTags&quot;</span><span class="s0">,</span><span class="s1">&quot;sharedAsyncLocalStorageNotAvailableError&quot;</span><span class="s0">,</span><span class="s1">&quot;FakeAsyncLocalStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;enterWith&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeGlobalAsyncLocalStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;AsyncLocalStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;AfterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;onClose&quot;</span><span class="s0">,</span><span class="s1">&quot;onTaskError&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStores&quot;</span><span class="s0">,</span><span class="s1">&quot;callbackQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;PromiseQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;pause&quot;</span><span class="s0">,</span><span class="s1">&quot;after&quot;</span><span class="s0">,</span><span class="s1">&quot;errorWaitUntilNotAvailable&quot;</span><span class="s0">,</span><span class="s1">&quot;reportTaskError&quot;</span><span class="s0">,</span><span class="s1">&quot;addCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;afterTaskStore&quot;</span><span class="s0">,</span><span class="s1">&quot;afterTaskAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;rootTaskSpawnPhase&quot;</span><span class="s0">,</span><span class="s1">&quot;runCallbacksOnClosePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;runCallbacksOnClose&quot;</span><span class="s0">,</span><span class="s1">&quot;wrappedCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;runCallbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;onIdle&quot;</span><span class="s0">,</span><span class="s1">&quot;taskKind&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerError&quot;</span><span class="s0">,</span><span class="s1">&quot;createLazyResult&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingResult&quot;</span><span class="s0">,</span><span class="s1">&quot;onfulfilled&quot;</span><span class="s0">,</span><span class="s1">&quot;onrejected&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTP_METHODS&quot;</span><span class="s0">,</span><span class="s1">&quot;getImplicitTags&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;hasFallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;derivedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameParts&quot;</span><span class="s0">,</span><span class="s1">&quot;curPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;expirationsByCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;createTagsExpirationsByCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;getExpiration&quot;</span><span class="s0">,</span><span class="s1">&quot;DYNAMIC_ERROR_CODE&quot;</span><span class="s0">,</span><span class="s1">&quot;DynamicServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;description&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;StaticGenBailoutError&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;HangingPromiseRejectionError&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;abortListenersBySignal&quot;</span><span class="s0">,</span><span class="s1">&quot;makeHangingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;hangingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;boundRejection&quot;</span><span class="s0">,</span><span class="s1">&quot;currentListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;listeners&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreReject&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPostpone&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;createDynamicTrackingState&quot;</span><span class="s0">,</span><span class="s1">&quot;isDebugDynamicAccesses&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicAccesses&quot;</span><span class="s0">,</span><span class="s1">&quot;syncDynamicErrorWithStack&quot;</span><span class="s0">,</span><span class="s1">&quot;markCurrentScopeAsDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;forceDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;forceStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicShouldError&quot;</span><span class="s0">,</span><span class="s1">&quot;postponeWithTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicUsageDescription&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicUsageStack&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;throwToInterruptStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;assertPostpone&quot;</span><span class="s0">,</span><span class="s1">&quot;createPostponeReason&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicPostponeReason&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRERENDER_INTERRUPTED&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrerenderInterruptedError&quot;</span><span class="s0">,</span><span class="s1">&quot;noop&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;body1&quot;</span><span class="s0">,</span><span class="s1">&quot;body2&quot;</span><span class="s0">,</span><span class="s1">&quot;tee&quot;</span><span class="s0">,</span><span class="s1">&quot;cloned1&quot;</span><span class="s0">,</span><span class="s1">&quot;Response&quot;</span><span class="s0">,</span><span class="s1">&quot;statusText&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;register&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakRef&quot;</span><span class="s0">,</span><span class="s1">&quot;cloned2&quot;</span><span class="s0">,</span><span class="s1">&quot;FinalizationRegistry&quot;</span><span class="s0">,</span><span class="s1">&quot;weakRef&quot;</span><span class="s0">,</span><span class="s1">&quot;deref&quot;</span><span class="s0">,</span><span class="s1">&quot;locked&quot;</span><span class="s0">,</span><span class="s1">&quot;cancel&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PATCH_SYMBOL&quot;</span><span class="s0">,</span><span class="s1">&quot;trackFetchMetric&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldTrackFetchMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;idx&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFetchId&quot;</span><span class="s0">,</span><span class="s1">&quot;createCachedPrerenderResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCacheContext&quot;</span><span class="s0">,</span><span class="s1">&quot;handleUnlock&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchedData&quot;</span><span class="s0">,</span><span class="s1">&quot;createCachedDynamicResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;serverComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheSetPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;finally&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;stdout&quot;</span><span class="s0">,</span><span class="s1">&quot;enabled&quot;</span><span class="s0">,</span><span class="s1">&quot;NO_COLOR&quot;</span><span class="s0">,</span><span class="s1">&quot;FORCE_COLOR&quot;</span><span class="s0">,</span><span class="s1">&quot;isTTY&quot;</span><span class="s0">,</span><span class="s1">&quot;CI&quot;</span><span class="s0">,</span><span class="s1">&quot;TERM&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceClose&quot;</span><span class="s0">,</span><span class="s1">&quot;nextIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;formatter&quot;</span><span class="s0">,</span><span class="s1">&quot;open&quot;</span><span class="s0">,</span><span class="s1">&quot;bold&quot;</span><span class="s0">,</span><span class="s1">&quot;red&quot;</span><span class="s0">,</span><span class="s1">&quot;green&quot;</span><span class="s0">,</span><span class="s1">&quot;yellow&quot;</span><span class="s0">,</span><span class="s1">&quot;magenta&quot;</span><span class="s0">,</span><span class="s1">&quot;white&quot;</span><span class="s0">,</span><span class="s1">&quot;LRUNode&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;SentinelNode&quot;</span><span class="s0">,</span><span class="s1">&quot;LRUCache&quot;</span><span class="s0">,</span><span class="s1">&quot;maxSize&quot;</span><span class="s0">,</span><span class="s1">&quot;calculateSize&quot;</span><span class="s0">,</span><span class="s1">&quot;totalSize&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;tail&quot;</span><span class="s0">,</span><span class="s1">&quot;addToHead&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;removeNode&quot;</span><span class="s0">,</span><span class="s1">&quot;moveToHead&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTail&quot;</span><span class="s0">,</span><span class="s1">&quot;lastNode&quot;</span><span class="s0">,</span><span class="s1">&quot;newNode&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;currentSize&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTOMATIC_ROUTE_METHODS&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMethodNotAllowedResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;ALLOWED_CODES&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_FOUND&quot;</span><span class="s0">,</span><span class="s1">&quot;FORBIDDEN&quot;</span><span class="s0">,</span><span class="s1">&quot;UNAUTHORIZED&quot;</span><span class="s0">,</span><span class="s1">&quot;isHTTPAccessFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;httpStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;errorCode&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">,</span><span class="s1">&quot;printDebugThrownValueForProspectiveRender&quot;</span><span class="s0">,</span><span class="s1">&quot;thrownValue&quot;</span><span class="s0">,</span><span class="s1">&quot;getDigestForWellKnownError&quot;</span><span class="s0">,</span><span class="s1">&quot;originalErrorStack&quot;</span><span class="s0">,</span><span class="s1">&quot;stackStart&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;LayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;GlobalLayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;TemplateContext&quot;</span><span class="s0">,</span><span class="s1">&quot;MissingSlotContext&quot;</span><span class="s0">,</span><span class="s1">&quot;CacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;earlyListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;tickPending&quot;</span><span class="s0">,</span><span class="s1">&quot;taskPending&quot;</span><span class="s0">,</span><span class="s1">&quot;subscribedSignals&quot;</span><span class="s0">,</span><span class="s1">&quot;noMorePendingCaches&quot;</span><span class="s0">,</span><span class="s1">&quot;inputReady&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheReady&quot;</span><span class="s0">,</span><span class="s1">&quot;beginRead&quot;</span><span class="s0">,</span><span class="s1">&quot;subscriber&quot;</span><span class="s0">,</span><span class="s1">&quot;endRead&quot;</span><span class="s0">,</span><span class="s1">&quot;trackRead&quot;</span><span class="s0">,</span><span class="s1">&quot;onFinally&quot;</span><span class="s0">,</span><span class="s1">&quot;subscribeToReads&quot;</span><span class="s0">,</span><span class="s1">&quot;unsubscribeFromReads&quot;</span><span class="s0">,</span><span class="s1">&quot;isDefinitelyAValidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;describeStringPropertyAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;wellKnownProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;errorRef&quot;</span><span class="s0">,</span><span class="s1">&quot;logErrorOrWarn&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CACHE_COMPONENTS&quot;</span><span class="s0">,</span><span class="s1">&quot;createDedupedByCallsiteServerErrorLoggerDev&quot;</span><span class="s0">,</span><span class="s1">&quot;getMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackParamsProxyHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;originalMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicAccessAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;abortController&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;makeUntrackedExoticParams&quot;</span><span class="s0">,</span><span class="s1">&quot;underlyingParams&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;makeUntrackedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;missingProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;describeListOfPropertyNames&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;WrappedNextRouterError&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouteRouteModule&quot;</span><span class="s0">,</span><span class="s1">&quot;sharedModules&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfigOutput&quot;</span><span class="s0">,</span><span class="s1">&quot;serverHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;actionAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;methods&quot;</span><span class="s0">,</span><span class="s1">&quot;autoImplementMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;acc&quot;</span><span class="s0">,</span><span class="s1">&quot;implemented&quot;</span><span class="s0">,</span><span class="s1">&quot;GET&quot;</span><span class="s0">,</span><span class="s1">&quot;HEAD&quot;</span><span class="s0">,</span><span class="s1">&quot;allow&quot;</span><span class="s0">,</span><span class="s1">&quot;Allow&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;OPTIONS&quot;</span><span class="s0">,</span><span class="s1">&quot;hasNonStaticMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticGenEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;generateStaticParams&quot;</span><span class="s0">,</span><span class="s1">&quot;do&quot;</span><span class="s0">,</span><span class="s1">&quot;actionStore&quot;</span><span class="s0">,</span><span class="s1">&quot;implicitTags&quot;</span><span class="s0">,</span><span class="s1">&quot;trackingState&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheComponentsEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;patchFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;createDedupeFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;resource&quot;</span><span class="s0">,</span><span class="s1">&quot;keepalive&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;createPatchedFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;originFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;patched&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;isInternal&quot;</span><span class="s0">,</span><span class="s1">&quot;internal&quot;</span><span class="s0">,</span><span class="s1">&quot;hideSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_OTEL_FETCH_DISABLED&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchStart&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;SpanKind&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateStore&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheReasonOverride&quot;</span><span class="s0">,</span><span class="s1">&quot;finalRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;isRequestInput&quot;</span><span class="s0">,</span><span class="s1">&quot;field&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextField&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFetchRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;currentFetchRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;validateTags&quot;</span><span class="s0">,</span><span class="s1">&quot;validTags&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidTags&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;pageFetchCacheMode&quot;</span><span class="s0">,</span><span class="s1">&quot;isUsingNoStore&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnstableNoStore&quot;</span><span class="s0">,</span><span class="s1">&quot;currentFetchCacheConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheReason&quot;</span><span class="s0">,</span><span class="s1">&quot;hasExplicitFetchCacheOptOut&quot;</span><span class="s0">,</span><span class="s1">&quot;noFetchConfigAndForceDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;validateRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateVal&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;_headers&quot;</span><span class="s0">,</span><span class="s1">&quot;initHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;hasUnCacheableHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnCacheableMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;hasNoExplicitCacheConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;autoNoCache&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuildTimePrerendering&quot;</span><span class="s0">,</span><span class="s1">&quot;renderSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;isCacheableRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;isHmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;doOriginalFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;requestInputFields&quot;</span><span class="s0">,</span><span class="s1">&quot;reqInput&quot;</span><span class="s0">,</span><span class="s1">&quot;reqOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;otherInput&quot;</span><span class="s0">,</span><span class="s1">&quot;clonedInit&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchType&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCacheConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;isForegroundRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;isHmrRefreshCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedFetchData&quot;</span><span class="s0">,</span><span class="s1">&quot;isRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;hasNextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatedResult&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;responses&quot;</span><span class="s0">,</span><span class="s1">&quot;__nextPatched&quot;</span><span class="s0">,</span><span class="s1">&quot;__nextGetStaticStore&quot;</span><span class="s0">,</span><span class="s1">&quot;_nextOriginalFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerContext&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerParamsForRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;createStaticPrerenderParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackParams&quot;</span><span class="s0">,</span><span class="s1">&quot;makeHangingParams&quot;</span><span class="s0">,</span><span class="s1">&quot;makeErroringExoticParams&quot;</span><span class="s0">,</span><span class="s1">&quot;augmentedUnderlying&quot;</span><span class="s0">,</span><span class="s1">&quot;newValue&quot;</span><span class="s0">,</span><span class="s1">&quot;createRuntimePrerenderParams&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeStagePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;throwInvariantForMissingStore&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrlQueryToParams&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvePendingRevalidations&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingWaitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;userlandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;prospectiveResult&quot;</span><span class="s0">,</span><span class="s1">&quot;prospectiveController&quot;</span><span class="s0">,</span><span class="s1">&quot;prospectiveRenderIsDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;prospectiveRoutePrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;rootParams&quot;</span><span class="s0">,</span><span class="s1">&quot;allowEmptyStaticShell&quot;</span><span class="s0">,</span><span class="s1">&quot;stale&quot;</span><span class="s0">,</span><span class="s1">&quot;renderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefreshHash&quot;</span><span class="s0">,</span><span class="s1">&quot;captureOwnerStack&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DEBUG_BUILD&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_VERBOSE_LOGGING&quot;</span><span class="s0">,</span><span class="s1">&quot;trackPendingModules&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicReason&quot;</span><span class="s0">,</span><span class="s1">&quot;finalController&quot;</span><span class="s0">,</span><span class="s1">&quot;finalRoutePrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;responseHandled&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyHandled&quot;</span><span class="s0">,</span><span class="s1">&quot;createCacheComponentsError&quot;</span><span class="s0">,</span><span class="s1">&quot;Location&quot;</span><span class="s0">,</span><span class="s1">&quot;isAction&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectStatusCodeFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedExpire&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedStale&quot;</span><span class="s0">,</span><span class="s1">&quot;handle&quot;</span><span class="s0">,</span><span class="s1">&quot;staticGenerationContext&quot;</span><span class="s0">,</span><span class="s1">&quot;sharedContext&quot;</span><span class="s0">,</span><span class="s1">&quot;previouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerActionRequestMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;actionId&quot;</span><span class="s0">,</span><span class="s1">&quot;isURLEncodedAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isMultipartAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isFetchAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isPossibleServerAction&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;createRequestStoreImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;devFallbackParams&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultOnUpdateCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;header&quot;</span><span class="s0">,</span><span class="s1">&quot;requestCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;getMutableCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;userspaceMutableCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;createCookiesWithMutableAccessCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;draftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;__serverComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;createWorkStore&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldWaitOnAllReady&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsDynamicResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isDevelopment&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_SSG_FETCH_METRICS&quot;</span><span class="s0">,</span><span class="s1">&quot;__incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheLifeProfiles&quot;</span><span class="s0">,</span><span class="s1">&quot;nextExport&quot;</span><span class="s0">,</span><span class="s1">&quot;hasReadableErrorStacks&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;afterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;createAfterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;onAfterTaskError&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshTagsByCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;createRefreshTagsByCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshTags&quot;</span><span class="s0">,</span><span class="s1">&quot;runInCleanSnapshot&quot;</span><span class="s0">,</span><span class="s1">&quot;snapshot&quot;</span><span class="s0">,</span><span class="s1">&quot;forceStaticRequestHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;requireStaticRequestHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;proxyNextRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrlHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;trackDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;urlCloneSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;nextRequestHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;nextURLSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;requestCloneSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;getPathnameFromAbsolutePath&quot;</span><span class="s0">,</span><span class="s1">&quot;absolutePath&quot;</span><span class="s0">,</span><span class="s1">&quot;appDir&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;relativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;tracer&quot;</span><span class="s0">,</span><span class="s1">&quot;setRootSpanAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;POST&quot;</span><span class="s0">,</span><span class="s1">&quot;PUT&quot;</span><span class="s0">,</span><span class="s1">&quot;DELETE&quot;</span><span class="s0">,</span><span class="s1">&quot;PATCH&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParamsSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;hrefSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;toStringSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;headersSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;cookiesSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;forceStaticNextUrlHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanURL&quot;</span><span class="s0">,</span><span class="s1">&quot;requireStaticNextUrlHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;abortAndThrowOnSynchronousRequestDataAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;errorWithStack&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderSignal&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">33</span><span class="s0">,</span><span class="s2">34</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">38</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">40</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">51</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">53</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">55</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">57</span><span class="s0">,</span><span class="s2">58</span><span class="s0">,</span><span class="s2">59</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">61</span><span class="s0">,</span><span class="s2">62</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">64</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">68</span><span class="s0">,</span><span class="s2">69</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">73</span><span class="s0">,</span><span class="s2">74</span><span class="s0">,</span><span class="s2">75</span><span class="s0">,</span><span class="s2">76</span><span class="s0">,</span><span class="s2">77</span><span class="s0">,</span><span class="s2">78</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">80</span><span class="s0">,</span><span class="s2">81</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">85</span><span class="s0">,</span><span class="s2">86</span><span class="s0">,</span><span class="s2">87</span><span class="s0">,</span><span class="s2">88</span><span class="s0">,</span><span class="s2">89</span><span class="s0">,</span><span class="s2">90</span><span class="s0">,</span><span class="s2">91</span><span class="s0">,</span><span class="s2">92</span><span class="s0">,</span><span class="s2">93</span><span class="s0">,</span><span class="s2">94</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">96</span><span class="s0">,</span><span class="s2">97</span><span class="s0">,</span><span class="s2">98</span><span class="s0">,</span><span class="s2">99</span><span class="s0">,</span><span class="s2">100</span><span class="s0">,</span><span class="s2">101</span><span class="s0">,</span><span class="s2">102</span><span class="s0">,</span><span class="s2">103</span><span class="s0">,</span><span class="s2">104</span><span class="s0">,</span><span class="s2">105</span><span class="s0">,</span><span class="s2">106</span><span class="s0">,</span><span class="s2">107</span><span class="s0">,</span><span class="s2">108</span><span class="s0">,</span><span class="s2">109</span><span class="s0">,</span><span class="s2">110</span><span class="s0">,</span><span class="s2">111</span><span class="s0">,</span><span class="s2">112</span><span class="s0">,</span><span class="s2">113</span><span class="s0">,</span><span class="s2">114</span><span class="s0">,</span><span class="s2">115</span><span class="s0">,</span><span class="s2">116</span><span class="s0">,</span><span class="s2">117</span><span class="s0">,</span><span class="s2">118</span><span class="s0">,</span><span class="s2">119</span><span class="s0">,</span><span class="s2">120</span><span class="s0">,</span><span class="s2">121</span><span class="s0">,</span><span class="s2">122</span><span class="s0">,</span><span class="s2">123</span><span class="s0">,</span><span class="s2">124</span><span class="s0">,</span><span class="s2">125</span><span class="s0">,</span><span class="s2">126</span><span class="s0">,</span><span class="s2">127</span><span class="s0">,</span><span class="s2">128</span><span class="s0">,</span><span class="s2">129</span><span class="s0">,</span><span class="s2">130</span><span class="s0">,</span><span class="s2">131</span><span class="s0">,</span><span class="s2">132</span><span class="s0">,</span><span class="s2">133</span><span class="s0">,</span><span class="s2">134</span><span class="s0">,</span><span class="s2">135</span><span class="s0">,</span><span class="s2">136</span><span class="s0">,</span><span class="s2">137</span><span class="s0">,</span><span class="s2">138</span><span class="s0">]}</span></pre>
</body>
</html>