<html>
<head>
<title>resolve-url.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolve-url.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/lib/metadata/resolvers/resolve-url.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import path from '../../../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import type { MetadataContext } from '../types/resolvers'</span><span class="s3">\n\n</span><span class="s1">function isStringOrURL(icon: any): icon is string | URL {</span><span class="s3">\n  </span><span class="s1">return typeof icon === 'string' || icon instanceof URL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createLocalMetadataBase() {</span><span class="s3">\n  </span><span class="s1">// Check if experimental HTTPS is enabled</span><span class="s3">\n  </span><span class="s1">const isExperimentalHttps = Boolean(process.env.__NEXT_EXPERIMENTAL_HTTPS)</span><span class="s3">\n  </span><span class="s1">const protocol = isExperimentalHttps ? 'https' : 'http'</span><span class="s3">\n  </span><span class="s1">return new URL(`${protocol}://localhost:${process.env.PORT || 3000}`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getPreviewDeploymentUrl(): URL | undefined {</span><span class="s3">\n  </span><span class="s1">const origin = process.env.VERCEL_BRANCH_URL || process.env.VERCEL_URL</span><span class="s3">\n  </span><span class="s1">return origin ? new URL(`https://${origin}`) : undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getProductionDeploymentUrl(): URL | undefined {</span><span class="s3">\n  </span><span class="s1">const origin = process.env.VERCEL_PROJECT_PRODUCTION_URL</span><span class="s3">\n  </span><span class="s1">return origin ? new URL(`https://${origin}`) : undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given an optional user-provided metadataBase, this determines what the metadataBase should</span><span class="s3">\n </span><span class="s1">* fallback to. Specifically:</span><span class="s3">\n </span><span class="s1">* - In dev, it should always be localhost</span><span class="s3">\n </span><span class="s1">* - In Vercel preview builds, it should be the preview build ID</span><span class="s3">\n </span><span class="s1">* - In start, it should be the user-provided metadataBase value. Otherwise,</span><span class="s3">\n </span><span class="s1">* it'll fall back to the Vercel production deployment, and localhost as a last resort.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSocialImageMetadataBaseFallback(</span><span class="s3">\n  </span><span class="s1">metadataBase: URL | null</span><span class="s3">\n</span><span class="s1">): URL {</span><span class="s3">\n  </span><span class="s1">const defaultMetadataBase = createLocalMetadataBase()</span><span class="s3">\n  </span><span class="s1">const previewDeploymentUrl = getPreviewDeploymentUrl()</span><span class="s3">\n  </span><span class="s1">const productionDeploymentUrl = getProductionDeploymentUrl()</span><span class="s3">\n\n  </span><span class="s1">let fallbackMetadataBase</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">fallbackMetadataBase = defaultMetadataBase</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">fallbackMetadataBase =</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV === 'production' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">previewDeploymentUrl &amp;&amp;</span><span class="s3">\n      </span><span class="s1">process.env.VERCEL_ENV === 'preview'</span><span class="s3">\n        </span><span class="s1">? previewDeploymentUrl</span><span class="s3">\n        </span><span class="s1">: metadataBase || productionDeploymentUrl || defaultMetadataBase</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return fallbackMetadataBase</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolveUrl(url: null | undefined, metadataBase: URL | null): null</span><span class="s3">\n</span><span class="s1">function resolveUrl(url: string | URL, metadataBase: URL | null): URL</span><span class="s3">\n</span><span class="s1">function resolveUrl(</span><span class="s3">\n  </span><span class="s1">url: string | URL | null | undefined,</span><span class="s3">\n  </span><span class="s1">metadataBase: URL | null</span><span class="s3">\n</span><span class="s1">): URL | null</span><span class="s3">\n</span><span class="s1">function resolveUrl(</span><span class="s3">\n  </span><span class="s1">url: string | URL | null | undefined,</span><span class="s3">\n  </span><span class="s1">metadataBase: URL | null</span><span class="s3">\n</span><span class="s1">): URL | null {</span><span class="s3">\n  </span><span class="s1">if (url instanceof URL) return url</span><span class="s3">\n  </span><span class="s1">if (!url) return null</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// If we can construct a URL instance from url, ignore metadataBase</span><span class="s3">\n    </span><span class="s1">const parsedUrl = new URL(url)</span><span class="s3">\n    </span><span class="s1">return parsedUrl</span><span class="s3">\n  </span><span class="s1">} catch {}</span><span class="s3">\n\n  </span><span class="s1">if (!metadataBase) {</span><span class="s3">\n    </span><span class="s1">metadataBase = createLocalMetadataBase()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Handle relative or absolute paths</span><span class="s3">\n  </span><span class="s1">const pathname = metadataBase.pathname || ''</span><span class="s3">\n  </span><span class="s1">const joinedPath = path.posix.join(pathname, url)</span><span class="s3">\n\n  </span><span class="s1">return new URL(joinedPath, metadataBase)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Resolve with `pathname` if `url` is a relative path.</span><span class="s3">\n</span><span class="s1">function resolveRelativeUrl(url: string | URL, pathname: string): string | URL {</span><span class="s3">\n  </span><span class="s1">if (typeof url === 'string' &amp;&amp; url.startsWith('./')) {</span><span class="s3">\n    </span><span class="s1">return path.posix.resolve(pathname, url)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return url</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// The regex is matching logic from packages/next/src/lib/load-custom-routes.ts</span><span class="s3">\n</span><span class="s1">const FILE_REGEX =</span><span class="s3">\n  </span><span class="s1">/^(?:</span><span class="s3">\\</span><span class="s1">/((?!</span><span class="s3">\\</span><span class="s1">.well-known(?:</span><span class="s3">\\</span><span class="s1">/.*)?)(?:[^/]+</span><span class="s3">\\</span><span class="s1">/)*[^/]+</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">w+))(</span><span class="s3">\\</span><span class="s1">/?|$)/i</span><span class="s3">\n</span><span class="s1">function isFilePattern(pathname: string): boolean {</span><span class="s3">\n  </span><span class="s1">return FILE_REGEX.test(pathname)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Resolve `pathname` if `url` is a relative path the compose with `metadataBase`.</span><span class="s3">\n</span><span class="s1">function resolveAbsoluteUrlWithPathname(</span><span class="s3">\n  </span><span class="s1">url: string | URL,</span><span class="s3">\n  </span><span class="s1">metadataBase: URL | null,</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">{ trailingSlash }: MetadataContext</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">// Resolve url with pathname that always starts with `/`</span><span class="s3">\n  </span><span class="s1">url = resolveRelativeUrl(url, pathname)</span><span class="s3">\n\n  </span><span class="s1">// Convert string url or URL instance to absolute url string,</span><span class="s3">\n  </span><span class="s1">// if there's case needs to be resolved with metadataBase</span><span class="s3">\n  </span><span class="s1">let resolvedUrl = ''</span><span class="s3">\n  </span><span class="s1">const result = metadataBase ? resolveUrl(url, metadataBase) : url</span><span class="s3">\n  </span><span class="s1">if (typeof result === 'string') {</span><span class="s3">\n    </span><span class="s1">resolvedUrl = result</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">resolvedUrl = result.pathname === '/' ? result.origin : result.href</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Add trailing slash if it's enabled for urls matches the condition</span><span class="s3">\n  </span><span class="s1">// - Not external, same origin with metadataBase</span><span class="s3">\n  </span><span class="s1">// - Doesn't have query</span><span class="s3">\n  </span><span class="s1">if (trailingSlash &amp;&amp; !resolvedUrl.endsWith('/')) {</span><span class="s3">\n    </span><span class="s1">let isRelative = resolvedUrl.startsWith('/')</span><span class="s3">\n    </span><span class="s1">let hasQuery = resolvedUrl.includes('?')</span><span class="s3">\n    </span><span class="s1">let isExternal = false</span><span class="s3">\n    </span><span class="s1">let isFileUrl = false</span><span class="s3">\n\n    </span><span class="s1">if (!isRelative) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const parsedUrl = new URL(resolvedUrl)</span><span class="s3">\n        </span><span class="s1">isExternal =</span><span class="s3">\n          </span><span class="s1">metadataBase != null &amp;&amp; parsedUrl.origin !== metadataBase.origin</span><span class="s3">\n        </span><span class="s1">isFileUrl = isFilePattern(parsedUrl.pathname)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// If it's not a valid URL, treat it as external</span><span class="s3">\n        </span><span class="s1">isExternal = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">// Do not apply trailing slash for file like urls, aligning with the behavior with `trailingSlash`</span><span class="s3">\n        </span><span class="s1">!isFileUrl &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!isExternal &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!hasQuery</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return `${resolvedUrl}/`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return resolvedUrl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">isStringOrURL,</span><span class="s3">\n  </span><span class="s1">resolveUrl,</span><span class="s3">\n  </span><span class="s1">resolveRelativeUrl,</span><span class="s3">\n  </span><span class="s1">resolveAbsoluteUrlWithPathname,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getSocialImageMetadataBaseFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringOrURL&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveAbsoluteUrlWithPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveRelativeUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;icon&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;createLocalMetadataBase&quot;</span><span class="s0">,</span><span class="s1">&quot;isExperimentalHttps&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_EXPERIMENTAL_HTTPS&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;PORT&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreviewDeploymentUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;VERCEL_BRANCH_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;VERCEL_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;getProductionDeploymentUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;VERCEL_PROJECT_PRODUCTION_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;metadataBase&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultMetadataBase&quot;</span><span class="s0">,</span><span class="s1">&quot;previewDeploymentUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;productionDeploymentUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackMetadataBase&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;VERCEL_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;joinedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;posix&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;FILE_REGEX&quot;</span><span class="s0">,</span><span class="s1">&quot;isFilePattern&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;isRelative&quot;</span><span class="s0">,</span><span class="s1">&quot;hasQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;isExternal&quot;</span><span class="s0">,</span><span class="s1">&quot;isFileUrl&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>