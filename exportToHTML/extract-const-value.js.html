<html>
<head>
<title>extract-const-value.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extract-const-value.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">NoSuchDeclarationError: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">UnsupportedValueError: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">extractExportedConstValue: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">NoSuchDeclarationError: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">NoSuchDeclarationError;</span>
    <span class="s1">},</span>
    <span class="s1">UnsupportedValueError: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">UnsupportedValueError;</span>
    <span class="s1">},</span>
    <span class="s1">extractExportedConstValue: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">extractExportedConstValue;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">class </span><span class="s1">NoSuchDeclarationError </span><span class="s2">extends </span><span class="s1">Error {</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isExportDeclaration(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'ExportDeclaration'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isVariableDeclaration(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'VariableDeclaration'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isIdentifier(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'Identifier'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isBooleanLiteral(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'BooleanLiteral'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isNullLiteral(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'NullLiteral'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isStringLiteral(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'StringLiteral'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isNumericLiteral(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'NumericLiteral'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isArrayExpression(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'ArrayExpression'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isObjectExpression(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'ObjectExpression'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isKeyValueProperty(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'KeyValueProperty'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isRegExpLiteral(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'RegExpLiteral'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isTemplateLiteral(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'TemplateLiteral'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isTsSatisfiesExpression(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'TsSatisfiesExpression'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">UnsupportedValueError </span><span class="s2">extends </span><span class="s1">Error {</span>
    <span class="s1">constructor(message, paths){</span>
        <span class="s2">super</span><span class="s1">(message);</span>
        <span class="s4">// Generating &quot;path&quot; that looks like &quot;config.runtime[0].value&quot;</span>
        <span class="s2">let </span><span class="s1">codePath;</span>
        <span class="s2">if </span><span class="s1">(paths) {</span>
            <span class="s1">codePath = </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">path of paths){</span>
                <span class="s2">if </span><span class="s1">(path[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'['</span><span class="s1">) {</span>
                    <span class="s4">// &quot;array&quot; + &quot;[0]&quot;</span>
                    <span class="s1">codePath += path;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(codePath === </span><span class="s0">''</span><span class="s1">) {</span>
                        <span class="s1">codePath = path;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// &quot;object&quot; + &quot;.key&quot;</span>
                        <span class="s1">codePath += </span><span class="s0">`.</span><span class="s1">${path}</span><span class="s0">`</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.path = codePath;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">extractValue(node, path) {</span>
    <span class="s2">if </span><span class="s1">(isNullLiteral(node)) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isBooleanLiteral(node)) {</span>
        <span class="s4">// e.g. true / false</span>
        <span class="s2">return </span><span class="s1">node.value;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isStringLiteral(node)) {</span>
        <span class="s4">// e.g. &quot;abc&quot;</span>
        <span class="s2">return </span><span class="s1">node.value;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isNumericLiteral(node)) {</span>
        <span class="s4">// e.g. 123</span>
        <span class="s2">return </span><span class="s1">node.value;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isRegExpLiteral(node)) {</span>
        <span class="s4">// e.g. /abc/i</span>
        <span class="s2">return new </span><span class="s1">RegExp(node.pattern, node.flags);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isIdentifier(node)) {</span>
        <span class="s2">switch</span><span class="s1">(node.value){</span>
            <span class="s2">case </span><span class="s0">'undefined'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">undefined;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">throw new </span><span class="s1">UnsupportedValueError(</span><span class="s0">`Unknown identifier &quot;</span><span class="s1">${node.value}</span><span class="s0">&quot;`</span><span class="s1">, path);</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isArrayExpression(node)) {</span>
        <span class="s4">// e.g. [1, 2, 3]</span>
        <span class="s2">const </span><span class="s1">arr = [];</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">, len = node.elements.length; i &lt; len; i++){</span>
            <span class="s2">const </span><span class="s1">elem = node.elements[i];</span>
            <span class="s2">if </span><span class="s1">(elem) {</span>
                <span class="s2">if </span><span class="s1">(elem.spread) {</span>
                    <span class="s4">// e.g. [ ...a ]</span>
                    <span class="s2">throw new </span><span class="s1">UnsupportedValueError(</span><span class="s0">'Unsupported spread operator in the Array Expression'</span><span class="s1">, path);</span>
                <span class="s1">}</span>
                <span class="s1">arr.push(extractValue(elem.expression, path &amp;&amp; [</span>
                    <span class="s1">...path,</span>
                    <span class="s0">`[</span><span class="s1">${i}</span><span class="s0">]`</span>
                <span class="s1">]));</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// e.g. [1, , 2]</span>
                <span class="s4">//         ^^</span>
                <span class="s1">arr.push(undefined);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">arr;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isObjectExpression(node)) {</span>
        <span class="s4">// e.g. { a: 1, b: 2 }</span>
        <span class="s2">const </span><span class="s1">obj = {};</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">prop of node.properties){</span>
            <span class="s2">if </span><span class="s1">(!isKeyValueProperty(prop)) {</span>
                <span class="s4">// e.g. { ...a }</span>
                <span class="s2">throw new </span><span class="s1">UnsupportedValueError(</span><span class="s0">'Unsupported spread operator in the Object Expression'</span><span class="s1">, path);</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">key;</span>
            <span class="s2">if </span><span class="s1">(isIdentifier(prop.key)) {</span>
                <span class="s4">// e.g. { a: 1, b: 2 }</span>
                <span class="s1">key = prop.key.value;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isStringLiteral(prop.key)) {</span>
                <span class="s4">// e.g. { &quot;a&quot;: 1, &quot;b&quot;: 2 }</span>
                <span class="s1">key = prop.key.value;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">throw new </span><span class="s1">UnsupportedValueError(</span><span class="s0">`Unsupported key type &quot;</span><span class="s1">${prop.key.type}</span><span class="s0">&quot; in the Object Expression`</span><span class="s1">, path);</span>
            <span class="s1">}</span>
            <span class="s1">obj[key] = extractValue(prop.value, path &amp;&amp; [</span>
                <span class="s1">...path,</span>
                <span class="s1">key</span>
            <span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isTemplateLiteral(node)) {</span>
        <span class="s4">// e.g. `abc`</span>
        <span class="s2">if </span><span class="s1">(node.expressions.length !== </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">// TODO: should we add support for `${'e'}d${'g'}'e'`?</span>
            <span class="s2">throw new </span><span class="s1">UnsupportedValueError(</span><span class="s0">'Unsupported template literal with expressions'</span><span class="s1">, path);</span>
        <span class="s1">}</span>
        <span class="s4">// When TemplateLiteral has 0 expressions, the length of quasis is always 1.</span>
        <span class="s4">// Because when parsing TemplateLiteral, the parser yields the first quasi,</span>
        <span class="s4">// then the first expression, then the next quasi, then the next expression, etc.,</span>
        <span class="s4">// until the last quasi.</span>
        <span class="s4">// Thus if there is no expression, the parser ends at the frst and also last quasis</span>
        <span class="s4">//</span>
        <span class="s4">// A &quot;cooked&quot; interpretation where backslashes have special meaning, while a</span>
        <span class="s4">// &quot;raw&quot; interpretation where backslashes do not have special meaning</span>
        <span class="s4">// https://exploringjs.com/impatient-js/ch_template-literals.html#template-strings-cooked-vs-raw</span>
        <span class="s2">const </span><span class="s1">[{ cooked, raw }] = node.quasis;</span>
        <span class="s2">return </span><span class="s1">cooked ?? raw;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isTsSatisfiesExpression(node)) {</span>
        <span class="s2">return </span><span class="s1">extractValue(node.expression);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">throw new </span><span class="s1">UnsupportedValueError(</span><span class="s0">`Unsupported node type &quot;</span><span class="s1">${node.type}</span><span class="s0">&quot;`</span><span class="s1">, path);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">extractExportedConstValue(module1, exportedName) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">moduleItem of module1.body){</span>
        <span class="s2">if </span><span class="s1">(!isExportDeclaration(moduleItem)) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">declaration = moduleItem.declaration;</span>
        <span class="s2">if </span><span class="s1">(!isVariableDeclaration(declaration)) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(declaration.kind !== </span><span class="s0">'const'</span><span class="s1">) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">decl of declaration.declarations){</span>
            <span class="s2">if </span><span class="s1">(isIdentifier(decl.id) &amp;&amp; decl.id.value === exportedName &amp;&amp; decl.init) {</span>
                <span class="s2">return </span><span class="s1">extractValue(decl.init, [</span>
                    <span class="s1">exportedName</span>
                <span class="s1">]);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">throw new </span><span class="s1">NoSuchDeclarationError();</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=extract-const-value.js.map</span></pre>
</body>
</html>