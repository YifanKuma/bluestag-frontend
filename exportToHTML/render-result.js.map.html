<html>
<head>
<title>render-result.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
render-result.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/server/render-result.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { OutgoingHttpHeaders, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { FetchMetrics } from './base-http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">chainStreams,</span><span class="s3">\n  </span><span class="s1">streamFromBuffer,</span><span class="s3">\n  </span><span class="s1">streamFromString,</span><span class="s3">\n  </span><span class="s1">streamToString,</span><span class="s3">\n</span><span class="s1">} from './stream-utils/node-web-streams-helper'</span><span class="s3">\n</span><span class="s1">import { isAbortError, pipeToNodeResponse } from './pipe-readable'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">TEXT_PLAIN_CONTENT_TYPE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import type { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">type ContentTypeOption =</span><span class="s3">\n  </span><span class="s1">| typeof RSC_CONTENT_TYPE_HEADER // For App Page RSC responses</span><span class="s3">\n  </span><span class="s1">| typeof HTML_CONTENT_TYPE_HEADER // For App Page, Pages HTML responses</span><span class="s3">\n  </span><span class="s1">| typeof JSON_CONTENT_TYPE_HEADER // For API routes, Next.js data requests</span><span class="s3">\n  </span><span class="s1">| typeof TEXT_PLAIN_CONTENT_TYPE_HEADER // For simplified errors</span><span class="s3">\n\n</span><span class="s1">export type AppPageRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">flightData?: Buffer</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">staticBailoutInfo?: {</span><span class="s3">\n    </span><span class="s1">stack?: string</span><span class="s3">\n    </span><span class="s1">description?: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The postponed state if the render had postponed and needs to be resumed.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The headers to set on the response that were added by the render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">statusCode?: number</span><span class="s3">\n  </span><span class="s1">fetchTags?: string</span><span class="s3">\n  </span><span class="s1">fetchMetrics?: FetchMetrics</span><span class="s3">\n\n  </span><span class="s1">segmentData?: Map&lt;string, Buffer&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the resume data cache is warmed up before the render. This</span><span class="s3">\n   </span><span class="s1">* is attached to the metadata so that it can be used during the render. When</span><span class="s3">\n   </span><span class="s1">* prerendering, the filled resume data cache is also attached to the metadata</span><span class="s3">\n   </span><span class="s1">* so that it can be used when prerendering matching fallback shells.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PagesRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">pageData?: any</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">assetQueryString?: string</span><span class="s3">\n  </span><span class="s1">isNotFound?: boolean</span><span class="s3">\n  </span><span class="s1">isRedirect?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type StaticRenderResultMetadata = {}</span><span class="s3">\n\n</span><span class="s1">export type RenderResultMetadata = AppPageRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">PagesRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">StaticRenderResultMetadata</span><span class="s3">\n\n</span><span class="s1">export type RenderResultResponse =</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;[]</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">| string</span><span class="s3">\n  </span><span class="s1">| Buffer</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n\n</span><span class="s1">export type RenderResultOptions&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; = {</span><span class="s3">\n  </span><span class="s1">contentType: ContentTypeOption | null</span><span class="s3">\n  </span><span class="s1">waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n  </span><span class="s1">metadata: Metadata</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class RenderResult&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The detected content type for the response. This is used to set the</span><span class="s3">\n   </span><span class="s1">* `Content-Type` header.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly contentType: ContentTypeOption | null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The metadata for the response. This is used to set the revalidation times</span><span class="s3">\n   </span><span class="s1">* and other metadata.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly metadata: Readonly&lt;Metadata&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The response itself. This can be a string, a stream, or null. If it's a</span><span class="s3">\n   </span><span class="s1">* string, then it's a static response. If it's a stream, then it's a</span><span class="s3">\n   </span><span class="s1">* dynamic response. If it's null, then the response was not found or was</span><span class="s3">\n   </span><span class="s1">* already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private response: RenderResultResponse</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A render result that represents an empty response. This is used to</span><span class="s3">\n   </span><span class="s1">* represent a response that was not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static readonly EMPTY = new RenderResult&lt;StaticRenderResultMetadata&gt;(</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">{ metadata: {}, contentType: null }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a new RenderResult instance from a static response.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param value the static response value</span><span class="s3">\n   </span><span class="s1">* @param contentType the content type of the response</span><span class="s3">\n   </span><span class="s1">* @returns a new RenderResult instance</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static fromStatic(</span><span class="s3">\n    </span><span class="s1">value: string | Buffer,</span><span class="s3">\n    </span><span class="s1">contentType: ContentTypeOption</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return new RenderResult&lt;StaticRenderResultMetadata&gt;(value, {</span><span class="s3">\n      </span><span class="s1">metadata: {},</span><span class="s3">\n      </span><span class="s1">contentType,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private readonly waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">response: RenderResultResponse,</span><span class="s3">\n    </span><span class="s1">{ contentType, waitUntil, metadata }: RenderResultOptions&lt;Metadata&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.response = response</span><span class="s3">\n    </span><span class="s1">this.contentType = contentType</span><span class="s3">\n    </span><span class="s1">this.metadata = metadata</span><span class="s3">\n    </span><span class="s1">this.waitUntil = waitUntil</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public assignMetadata(metadata: Metadata) {</span><span class="s3">\n    </span><span class="s1">Object.assign(this.metadata, metadata)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns true if the response is null. It can be null if the response was</span><span class="s3">\n   </span><span class="s1">* not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isNull(): boolean {</span><span class="s3">\n    </span><span class="s1">return this.response === null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns false if the response is a string. It can be a string if the page</span><span class="s3">\n   </span><span class="s1">* was prerendered. If it's not, then it was generated dynamically.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isDynamic(): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.response !== 'string'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the response if it is a string. If the page was dynamic, this will</span><span class="s3">\n   </span><span class="s1">* return a promise if the `stream` option is true, or it will throw an error.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param stream Whether or not to return a promise if the response is dynamic</span><span class="s3">\n   </span><span class="s1">* @returns The response as a string</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream?: false): string</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream: true): Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream = false): Promise&lt;string&gt; | string {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty string. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response !== 'string') {</span><span class="s3">\n      </span><span class="s1">if (!stream) {</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'dynamic responses cannot be unchunked. This is a bug in Next.js'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return streamToString(this.readable)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a readable stream of the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private get readable(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return new ReadableStream&lt;Uint8Array&gt;({</span><span class="s3">\n        </span><span class="s1">start(controller) {</span><span class="s3">\n          </span><span class="s1">controller.close()</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return streamFromString(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return streamFromBuffer(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the response is an array of streams, then chain them together.</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return chainStreams(...this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Coerces the response to an array of streams. This will convert the response</span><span class="s3">\n   </span><span class="s1">* to an array of streams if it is not already one.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @returns An array of streams</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private coerce(): ReadableStream&lt;Uint8Array&gt;[] {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return []</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return [streamFromString(this.response)]</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return this.response</span><span class="s3">\n    </span><span class="s1">} else if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return [streamFromBuffer(this.response)]</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return [this.response]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Unshifts a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the start of the array. When this response is piped, all of the streams</span><span class="s3">\n   </span><span class="s1">* will be piped one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to unshift</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public unshift(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the start of the array.</span><span class="s3">\n    </span><span class="s1">this.response.unshift(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Chains a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the end. When this response is piped, all of the streams will be piped</span><span class="s3">\n   </span><span class="s1">* one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to chain</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public push(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the end of the array.</span><span class="s3">\n    </span><span class="s1">this.response.push(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a writable stream. This will close/cancel the</span><span class="s3">\n   </span><span class="s1">* writable stream if an error is encountered. If this doesn't throw, then</span><span class="s3">\n   </span><span class="s1">* the writable stream will be closed or aborted.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param writable Writable stream to pipe the response to</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeTo(writable: WritableStream&lt;Uint8Array&gt;): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">await this.readable.pipeTo(writable, {</span><span class="s3">\n        </span><span class="s1">// We want to close the writable stream ourselves so that we can wait</span><span class="s3">\n        </span><span class="s1">// for the waitUntil promise to resolve before closing it. If an error</span><span class="s3">\n        </span><span class="s1">// is encountered, we'll abort the writable stream if we swallowed the</span><span class="s3">\n        </span><span class="s1">// error.</span><span class="s3">\n        </span><span class="s1">preventClose: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// If there is a waitUntil promise, wait for it to resolve before</span><span class="s3">\n      </span><span class="s1">// closing the writable stream.</span><span class="s3">\n      </span><span class="s1">if (this.waitUntil) await this.waitUntil</span><span class="s3">\n\n      </span><span class="s1">// Close the writable stream.</span><span class="s3">\n      </span><span class="s1">await writable.close()</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">// If this is an abort error, we should abort the writable stream (as we</span><span class="s3">\n      </span><span class="s1">// took ownership of it when we started piping). We don't need to re-throw</span><span class="s3">\n      </span><span class="s1">// because we handled the error.</span><span class="s3">\n      </span><span class="s1">if (isAbortError(err)) {</span><span class="s3">\n        </span><span class="s1">// Abort the writable stream if an error is encountered.</span><span class="s3">\n        </span><span class="s1">await writable.abort(err)</span><span class="s3">\n\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We're not aborting the writer here as when this method throws it's not</span><span class="s3">\n      </span><span class="s1">// clear as to how so the caller should assume it's their responsibility</span><span class="s3">\n      </span><span class="s1">// to clean up the writer.</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a node response. This will close/cancel the node</span><span class="s3">\n   </span><span class="s1">* response if an error is encountered.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param res</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeToNodeResponse(res: ServerResponse) {</span><span class="s3">\n    </span><span class="s1">await pipeToNodeResponse(this.readable, res, this.waitUntil)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;RenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;EMPTY&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;fromStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;assignMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;isNull&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnchunkedString&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;streamToString&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromString&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;chainStreams&quot;</span><span class="s0">,</span><span class="s1">&quot;coerce&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeTo&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;preventClose&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbortError&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeToNodeResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>