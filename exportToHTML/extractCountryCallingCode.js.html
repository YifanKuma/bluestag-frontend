<html>
<head>
<title>extractCountryCallingCode.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extractCountryCallingCode.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">stripIddPrefix from </span><span class="s2">'./stripIddPrefix.js'</span>
<span class="s0">import </span><span class="s1">extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from </span><span class="s2">'./extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js'</span>
<span class="s0">import </span><span class="s1">Metadata from </span><span class="s2">'../metadata.js'</span>
<span class="s0">import </span><span class="s1">{ MAX_LENGTH_COUNTRY_CODE } from </span><span class="s2">'../constants.js'</span>

<span class="s3">/**</span>
 <span class="s3">* Converts a phone number digits (possibly with a `+`)</span>
 <span class="s3">* into a calling code and the rest phone number digits.</span>
 <span class="s3">* The &quot;rest phone number digits&quot; could include</span>
 <span class="s3">* a national prefix, carrier code, and national</span>
 <span class="s3">* (significant) number.</span>
 <span class="s3">* </span><span class="s4">@param  </span><span class="s3">{string} number — Phone number digits (possibly with a `+`).</span>
 <span class="s3">* </span><span class="s4">@param  </span><span class="s3">{string} [country] — Country.</span>
 <span class="s3">* </span><span class="s4">@param  </span><span class="s3">{string} [defaultCountry] — Default country.</span>
 <span class="s3">* </span><span class="s4">@param  </span><span class="s3">{string} [defaultCallingCode] — Default calling code (some phone numbering plans are non-geographic).</span>
 <span class="s3">* </span><span class="s4">@param  </span><span class="s3">{object} metadata</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{object} `{ countryCallingCodeSource: string?, countryCallingCode: string?, number: string }`</span>
 <span class="s3">* </span><span class="s4">@example</span>
 <span class="s3">* // Returns `{ countryCallingCode: &quot;1&quot;, number: &quot;2133734253&quot; }`.</span>
 <span class="s3">* extractCountryCallingCode('2133734253', null, 'US', null, metadata)</span>
 <span class="s3">* extractCountryCallingCode('2133734253', null, null, '1', metadata)</span>
 <span class="s3">* extractCountryCallingCode('+12133734253', null, null, null, metadata)</span>
 <span class="s3">* extractCountryCallingCode('+12133734253', null, 'RU', null, metadata)</span>
 <span class="s3">*/</span>
<span class="s0">export default function </span><span class="s1">extractCountryCallingCode(</span>
	<span class="s1">number,</span>
	<span class="s1">country,</span>
	<span class="s1">defaultCountry,</span>
	<span class="s1">defaultCallingCode,</span>
	<span class="s1">metadata</span>
<span class="s1">) {</span>
	<span class="s0">if </span><span class="s1">(!number) {</span>
		<span class="s0">return </span><span class="s1">{}</span>
	<span class="s1">}</span>

	<span class="s0">let </span><span class="s1">isNumberWithIddPrefix</span>

	<span class="s3">// If this is not an international phone number,</span>
	<span class="s3">// then either extract an &quot;IDD&quot; prefix, or extract a</span>
	<span class="s3">// country calling code from a number by autocorrecting it</span>
	<span class="s3">// by prepending a leading `+` in cases when it starts</span>
	<span class="s3">// with the country calling code.</span>
	<span class="s3">// https://wikitravel.org/en/International_dialling_prefix</span>
	<span class="s3">// https://github.com/catamphetamine/libphonenumber-js/issues/376</span>
	<span class="s0">if </span><span class="s1">(number[</span><span class="s5">0</span><span class="s1">] !== </span><span class="s2">'+'</span><span class="s1">) {</span>
		<span class="s3">// Convert an &quot;out-of-country&quot; dialing phone number</span>
		<span class="s3">// to a proper international phone number.</span>
		<span class="s0">const </span><span class="s1">numberWithoutIDD = stripIddPrefix(number, country || defaultCountry, defaultCallingCode, metadata)</span>
		<span class="s3">// If an IDD prefix was stripped then</span>
		<span class="s3">// convert the number to international one</span>
		<span class="s3">// for subsequent parsing.</span>
		<span class="s0">if </span><span class="s1">(numberWithoutIDD &amp;&amp; numberWithoutIDD !== number) {</span>
			<span class="s1">isNumberWithIddPrefix = </span><span class="s0">true</span>
			<span class="s1">number = </span><span class="s2">'+' </span><span class="s1">+ numberWithoutIDD</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s3">// Check to see if the number starts with the country calling code</span>
			<span class="s3">// for the default country. If so, we remove the country calling code,</span>
			<span class="s3">// and do some checks on the validity of the number before and after.</span>
			<span class="s3">// https://github.com/catamphetamine/libphonenumber-js/issues/376</span>
			<span class="s0">if </span><span class="s1">(country || defaultCountry || defaultCallingCode) {</span>
				<span class="s0">const </span><span class="s1">{</span>
					<span class="s1">countryCallingCode,</span>
					<span class="s1">number: shorterNumber</span>
				<span class="s1">} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(</span>
					<span class="s1">number,</span>
					<span class="s1">country,</span>
					<span class="s1">defaultCountry,</span>
					<span class="s1">defaultCallingCode,</span>
					<span class="s1">metadata</span>
				<span class="s1">)</span>
				<span class="s0">if </span><span class="s1">(countryCallingCode) {</span>
					<span class="s0">return </span><span class="s1">{</span>
						<span class="s1">countryCallingCodeSource: </span><span class="s2">'FROM_NUMBER_WITHOUT_PLUS_SIGN'</span><span class="s1">,</span>
						<span class="s1">countryCallingCode,</span>
						<span class="s1">number: shorterNumber</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s0">return </span><span class="s1">{</span>
				<span class="s3">// No need to set it to `UNSPECIFIED`. It can be just `undefined`.</span>
				<span class="s3">// countryCallingCodeSource: 'UNSPECIFIED',</span>
				<span class="s1">number</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">// `number` can only be international at this point.</span>

	<span class="s3">// Fast abortion: country codes do not begin with a '0'</span>
	<span class="s0">if </span><span class="s1">(number[</span><span class="s5">1</span><span class="s1">] === </span><span class="s2">'0'</span><span class="s1">) {</span>
		<span class="s0">return </span><span class="s1">{}</span>
	<span class="s1">}</span>

	<span class="s1">metadata = </span><span class="s0">new </span><span class="s1">Metadata(metadata)</span>

	<span class="s3">// The thing with country phone codes</span>
	<span class="s3">// is that they are orthogonal to each other</span>
	<span class="s3">// i.e. there's no such country phone code A</span>
	<span class="s3">// for which country phone code B exists</span>
	<span class="s3">// where B starts with A.</span>
	<span class="s3">// Therefore, while scanning digits,</span>
	<span class="s3">// if a valid country code is found,</span>
	<span class="s3">// that means that it is the country code.</span>
	<span class="s3">//</span>
	<span class="s0">let </span><span class="s1">i = </span><span class="s5">2</span>
	<span class="s0">while </span><span class="s1">(i - </span><span class="s5">1 </span><span class="s1">&lt;= MAX_LENGTH_COUNTRY_CODE &amp;&amp; i &lt;= number.length) {</span>
		<span class="s0">const </span><span class="s1">countryCallingCode = number.slice(</span><span class="s5">1</span><span class="s1">, i)</span>
		<span class="s0">if </span><span class="s1">(metadata.hasCallingCode(countryCallingCode)) {</span>
			<span class="s1">metadata.selectNumberingPlan(countryCallingCode)</span>
			<span class="s0">return </span><span class="s1">{</span>
				<span class="s1">countryCallingCodeSource: isNumberWithIddPrefix ? </span><span class="s2">'FROM_NUMBER_WITH_IDD' </span><span class="s1">: </span><span class="s2">'FROM_NUMBER_WITH_PLUS_SIGN'</span><span class="s1">,</span>
				<span class="s1">countryCallingCode,</span>
				<span class="s1">number: number.slice(i)</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">i++</span>
	<span class="s1">}</span>

	<span class="s0">return </span><span class="s1">{}</span>
<span class="s1">}</span>

<span class="s3">// The possible values for the returned `countryCallingCodeSource` are:</span>
<span class="s3">//</span>
<span class="s3">// Copy-pasted from:</span>
<span class="s3">// https://github.com/google/libphonenumber/blob/master/resources/phonenumber.proto</span>
<span class="s3">//</span>
<span class="s3">// // The source from which the country_code is derived. This is not set in the</span>
<span class="s3">// // general parsing method, but in the method that parses and keeps raw_input.</span>
<span class="s3">// // New fields could be added upon request.</span>
<span class="s3">// enum CountryCodeSource {</span>
<span class="s3">//  // Default value returned if this is not set, because the phone number was</span>
<span class="s3">//  // created using parse, not parseAndKeepRawInput. hasCountryCodeSource will</span>
<span class="s3">//  // return false if this is the case.</span>
<span class="s3">//  UNSPECIFIED = 0;</span>
<span class="s3">//</span>
<span class="s3">//  // The country_code is derived based on a phone number with a leading &quot;+&quot;,</span>
<span class="s3">//  // e.g. the French number &quot;+33 1 42 68 53 00&quot;.</span>
<span class="s3">//  FROM_NUMBER_WITH_PLUS_SIGN = 1;</span>
<span class="s3">//</span>
<span class="s3">//  // The country_code is derived based on a phone number with a leading IDD,</span>
<span class="s3">//  // e.g. the French number &quot;011 33 1 42 68 53 00&quot;, as it is dialled from US.</span>
<span class="s3">//  FROM_NUMBER_WITH_IDD = 5;</span>
<span class="s3">//</span>
<span class="s3">//  // The country_code is derived based on a phone number without a leading</span>
<span class="s3">//  // &quot;+&quot;, e.g. the French number &quot;33 1 42 68 53 00&quot; when defaultCountry is</span>
<span class="s3">//  // supplied as France.</span>
<span class="s3">//  FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;</span>
<span class="s3">//</span>
<span class="s3">//  // The country_code is derived NOT based on the phone number itself, but</span>
<span class="s3">//  // from the defaultCountry parameter provided in the parsing function by the</span>
<span class="s3">//  // clients. This happens mostly for numbers written in the national format</span>
<span class="s3">//  // (without country code). For example, this would be set when parsing the</span>
<span class="s3">//  // French number &quot;01 42 68 53 00&quot;, when defaultCountry is supplied as</span>
<span class="s3">//  // France.</span>
<span class="s3">//  FROM_DEFAULT_COUNTRY = 20;</span>
<span class="s3">// }</span></pre>
</body>
</html>