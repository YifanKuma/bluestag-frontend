<html>
<head>
<title>usedPropTypes.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
usedPropTypes.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Common used propTypes detection functionality.</span>
 <span class="s0">*/</span>

<span class="s3">'use strict'</span><span class="s2">;</span>

<span class="s4">const </span><span class="s2">values = require(</span><span class="s3">'object.values'</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">astUtil = require(</span><span class="s3">'./ast'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">componentUtil = require(</span><span class="s3">'./componentUtil'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">testReactVersion = require(</span><span class="s3">'./version'</span><span class="s2">).testReactVersion;</span>
<span class="s4">const </span><span class="s2">ast = require(</span><span class="s3">'./ast'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">eslintUtil = require(</span><span class="s3">'./eslint'</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">getScope = eslintUtil.getScope;</span>
<span class="s4">const </span><span class="s2">getSourceCode = eslintUtil.getSourceCode;</span>

<span class="s0">// ------------------------------------------------------------------------------</span>
<span class="s0">// Constants</span>
<span class="s0">// ------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">LIFE_CYCLE_METHODS = [</span><span class="s3">'componentWillReceiveProps'</span><span class="s2">, </span><span class="s3">'shouldComponentUpdate'</span><span class="s2">, </span><span class="s3">'componentWillUpdate'</span><span class="s2">, </span><span class="s3">'componentDidUpdate'</span><span class="s2">];</span>
<span class="s4">const </span><span class="s2">ASYNC_SAFE_LIFE_CYCLE_METHODS = [</span><span class="s3">'getDerivedStateFromProps'</span><span class="s2">, </span><span class="s3">'getSnapshotBeforeUpdate'</span><span class="s2">, </span><span class="s3">'UNSAFE_componentWillReceiveProps'</span><span class="s2">, </span><span class="s3">'UNSAFE_componentWillUpdate'</span><span class="s2">];</span>

<span class="s4">function </span><span class="s2">createPropVariables() {</span>
  <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{Map&lt;string, string[]&gt;} Maps the variable to its definition. `props.a.b` is stored as `['a', 'b']` */</span>
  <span class="s4">let </span><span class="s2">propVariables = </span><span class="s4">new </span><span class="s2">Map();</span>
  <span class="s4">let </span><span class="s2">hasBeenWritten = </span><span class="s4">false</span><span class="s2">;</span>
  <span class="s4">const </span><span class="s2">stack = [{ propVariables, hasBeenWritten }];</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">pushScope() {</span>
      <span class="s0">// popVariables is not copied until first write.</span>
      <span class="s2">stack.push({ propVariables, hasBeenWritten: </span><span class="s4">false </span><span class="s2">});</span>
    <span class="s2">},</span>
    <span class="s2">popScope() {</span>
      <span class="s2">stack.pop();</span>
      <span class="s2">propVariables = stack[stack.length - </span><span class="s5">1</span><span class="s2">].propVariables;</span>
      <span class="s2">hasBeenWritten = stack[stack.length - </span><span class="s5">1</span><span class="s2">].hasBeenWritten;</span>
    <span class="s2">},</span>
    <span class="s0">/**</span>
     <span class="s0">* Add a variable name to the current scope</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string[]} allNames Example: `props.a.b` should be formatted as `['a', 'b']`</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Map&lt;string, string[]&gt;}</span>
     <span class="s0">*/</span>
    <span class="s2">set(name, allNames) {</span>
      <span class="s4">if </span><span class="s2">(!hasBeenWritten) {</span>
        <span class="s0">// copy on write</span>
        <span class="s2">propVariables = </span><span class="s4">new </span><span class="s2">Map(propVariables);</span>
        <span class="s2">Object.assign(stack[stack.length - </span><span class="s5">1</span><span class="s2">], { propVariables, hasBeenWritten: </span><span class="s4">true </span><span class="s2">});</span>
        <span class="s2">stack[stack.length - </span><span class="s5">1</span><span class="s2">].hasBeenWritten = </span><span class="s4">true</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">propVariables.set(name, allNames);</span>
    <span class="s2">},</span>
    <span class="s0">/**</span>
     <span class="s0">* Get the definition of a variable.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string[]} Example: `props.a.b` is represented by `['a', 'b']`</span>
     <span class="s0">*/</span>
    <span class="s2">get(name) {</span>
      <span class="s4">return </span><span class="s2">propVariables.get(name);</span>
    <span class="s2">},</span>
  <span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks if the string is one of `props`, `nextProps`, or `prevProps`</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name The AST node being checked.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the prop name matches</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isCommonVariableNameForProps(name) {</span>
  <span class="s4">return </span><span class="s2">name === </span><span class="s3">'props' </span><span class="s2">|| name === </span><span class="s3">'nextProps' </span><span class="s2">|| name === </span><span class="s3">'prevProps'</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks if the component must be validated</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} component The component to process</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the component must be validated, false if not.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">mustBeValidated(component) {</span>
  <span class="s4">return </span><span class="s2">!!(component &amp;&amp; !component.ignorePropsValidation);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check if we are in a lifecycle method</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{object} context</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} checkAsyncSafeLifeCycles</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">{boolean} true if we are in a class constructor, false if not</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">inLifeCycleMethod(context, node, checkAsyncSafeLifeCycles) {</span>
  <span class="s4">let </span><span class="s2">scope = getScope(context, node);</span>
  <span class="s4">while </span><span class="s2">(scope) {</span>
    <span class="s4">if </span><span class="s2">(scope.block &amp;&amp; scope.block.parent &amp;&amp; scope.block.parent.key) {</span>
      <span class="s4">const </span><span class="s2">name = scope.block.parent.key.name;</span>

      <span class="s4">if </span><span class="s2">(LIFE_CYCLE_METHODS.indexOf(name) &gt;= </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s4">return true</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(checkAsyncSafeLifeCycles &amp;&amp; ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(name) &gt;= </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s4">return true</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">scope = scope.upper;</span>
  <span class="s2">}</span>
  <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the given node is a React Component lifecycle method</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} checkAsyncSafeLifeCycles</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">{boolean} True if the node is a lifecycle method</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles) {</span>
  <span class="s4">if </span><span class="s2">(node.key) {</span>
    <span class="s4">if </span><span class="s2">(node.kind === </span><span class="s3">'constructor'</span><span class="s2">) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s4">const </span><span class="s2">nodeKeyName = node.key.name;</span>

    <span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">nodeKeyName !== </span><span class="s3">'string'</span><span class="s2">) {</span>
      <span class="s4">return false</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s4">if </span><span class="s2">(LIFE_CYCLE_METHODS.indexOf(nodeKeyName) &gt;= </span><span class="s5">0</span><span class="s2">) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(checkAsyncSafeLifeCycles &amp;&amp; ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(nodeKeyName) &gt;= </span><span class="s5">0</span><span class="s2">) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the given node is inside a React Component lifecycle</span>
 <span class="s0">* method.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being checked.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} checkAsyncSafeLifeCycles</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">{boolean} True if the node is inside a lifecycle method</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isInLifeCycleMethod(node, checkAsyncSafeLifeCycles) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">(node.type === </span><span class="s3">'MethodDefinition' </span><span class="s2">|| node.type === </span><span class="s3">'Property'</span><span class="s2">)</span>
    <span class="s2">&amp;&amp; isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles)</span>
  <span class="s2">) {</span>
    <span class="s4">return true</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s4">if </span><span class="s2">(node.parent) {</span>
    <span class="s4">return </span><span class="s2">isInLifeCycleMethod(node.parent, checkAsyncSafeLifeCycles);</span>
  <span class="s2">}</span>

  <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check if a function node is a setState updater</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node a function node</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">{boolean}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isSetStateUpdater(node) {</span>
  <span class="s4">const </span><span class="s2">unwrappedParentCalleeNode = astUtil.isCallExpression(node.parent)</span>
    <span class="s2">&amp;&amp; ast.unwrapTSAsExpression(node.parent.callee);</span>

  <span class="s4">return </span><span class="s2">unwrappedParentCalleeNode</span>
    <span class="s2">&amp;&amp; unwrappedParentCalleeNode.property</span>
    <span class="s2">&amp;&amp; unwrappedParentCalleeNode.property.name === </span><span class="s3">'setState'</span>
    <span class="s0">// Make sure we are in the updater not the callback</span>
    <span class="s2">&amp;&amp; node.parent.arguments[</span><span class="s5">0</span><span class="s2">] === node;</span>
<span class="s2">}</span>

<span class="s4">function </span><span class="s2">isPropArgumentInSetStateUpdater(context, node, name) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">name !== </span><span class="s3">'string'</span><span class="s2">) {</span>
    <span class="s4">return</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">let </span><span class="s2">scope = getScope(context, node);</span>
  <span class="s4">while </span><span class="s2">(scope) {</span>
    <span class="s4">const </span><span class="s2">unwrappedParentCalleeNode = scope.block</span>
      <span class="s2">&amp;&amp; astUtil.isCallExpression(scope.block.parent)</span>
      <span class="s2">&amp;&amp; ast.unwrapTSAsExpression(scope.block.parent.callee);</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">unwrappedParentCalleeNode</span>
      <span class="s2">&amp;&amp; unwrappedParentCalleeNode.property</span>
      <span class="s2">&amp;&amp; unwrappedParentCalleeNode.property.name === </span><span class="s3">'setState'</span>
      <span class="s0">// Make sure we are in the updater not the callback</span>
      <span class="s2">&amp;&amp; scope.block.parent.arguments[</span><span class="s5">0</span><span class="s2">].range[</span><span class="s5">0</span><span class="s2">] === scope.block.range[</span><span class="s5">0</span><span class="s2">]</span>
      <span class="s2">&amp;&amp; scope.block.parent.arguments[</span><span class="s5">0</span><span class="s2">].params</span>
      <span class="s2">&amp;&amp; scope.block.parent.arguments[</span><span class="s5">0</span><span class="s2">].params.length &gt; </span><span class="s5">1</span>
    <span class="s2">) {</span>
      <span class="s4">return </span><span class="s2">scope.block.parent.arguments[</span><span class="s5">0</span><span class="s2">].params[</span><span class="s5">1</span><span class="s2">].name === name;</span>
    <span class="s2">}</span>
    <span class="s2">scope = scope.upper;</span>
  <span class="s2">}</span>
  <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Context} context</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isInClassComponent(context, node) {</span>
  <span class="s4">return </span><span class="s2">!!(componentUtil.getParentES6Component(context, node) || componentUtil.getParentES5Component(context, node));</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks if the node is `this.props`</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|undefined} node</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isThisDotProps(node) {</span>
  <span class="s4">return </span><span class="s2">!!node</span>
    <span class="s2">&amp;&amp; node.type === </span><span class="s3">'MemberExpression'</span>
    <span class="s2">&amp;&amp; ast.unwrapTSAsExpression(node.object).type === </span><span class="s3">'ThisExpression'</span>
    <span class="s2">&amp;&amp; node.property.name === </span><span class="s3">'props'</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks if the prop has spread operator.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{object} context</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being marked.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the prop has spread operator, false if not.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">hasSpreadOperator(context, node) {</span>
  <span class="s4">const </span><span class="s2">tokens = getSourceCode(context).getTokens(node);</span>
  <span class="s4">return </span><span class="s2">tokens.length &amp;&amp; tokens[</span><span class="s5">0</span><span class="s2">].value === </span><span class="s3">'...'</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks if the node is a propTypes usage of the form `this.props.*`, `props.*`, `prevProps.*`, or `nextProps.*`.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Context} context</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} utils</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} checkAsyncSafeLifeCycles</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isPropTypesUsageByMemberExpression(context, node, utils, checkAsyncSafeLifeCycles) {</span>
  <span class="s4">const </span><span class="s2">unwrappedObjectNode = ast.unwrapTSAsExpression(node.object);</span>

  <span class="s4">if </span><span class="s2">(isInClassComponent(context, node)) {</span>
    <span class="s0">// this.props.*</span>
    <span class="s4">if </span><span class="s2">(isThisDotProps(unwrappedObjectNode)) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s0">// props.* or prevProps.* or nextProps.*</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">isCommonVariableNameForProps(unwrappedObjectNode.name)</span>
      <span class="s2">&amp;&amp; (inLifeCycleMethod(context, node, checkAsyncSafeLifeCycles) || astUtil.inConstructor(context, node))</span>
    <span class="s2">) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s0">// this.setState((_, props) =&gt; props.*))</span>
    <span class="s4">if </span><span class="s2">(isPropArgumentInSetStateUpdater(context, node, unwrappedObjectNode.name)) {</span>
      <span class="s4">return true</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">return false</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">// props.* in function component</span>
  <span class="s4">return </span><span class="s2">unwrappedObjectNode.name === </span><span class="s3">'props' </span><span class="s2">&amp;&amp; !ast.isAssignmentLHS(node);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Retrieve the name of a property node</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Context} context</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node with the property.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} utils</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} checkAsyncSafeLifeCycles</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">{string|undefined} the name of the property or undefined if not found</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getPropertyName(context, node, utils, checkAsyncSafeLifeCycles) {</span>
  <span class="s4">const </span><span class="s2">property = node.property;</span>
  <span class="s4">if </span><span class="s2">(property) {</span>
    <span class="s4">switch </span><span class="s2">(property.type) {</span>
      <span class="s4">case </span><span class="s3">'Identifier'</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s2">(node.computed) {</span>
          <span class="s4">return </span><span class="s3">'__COMPUTED_PROP__'</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">property.name;</span>
      <span class="s4">case </span><span class="s3">'MemberExpression'</span><span class="s2">:</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">'Literal'</span><span class="s2">:</span>
        <span class="s0">// Accept computed properties that are literal strings</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">property.value === </span><span class="s3">'string'</span><span class="s2">) {</span>
          <span class="s4">return </span><span class="s2">property.value;</span>
        <span class="s2">}</span>
        <span class="s0">// Accept number as well but only accept props[123]</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">property.value === </span><span class="s3">'number'</span><span class="s2">) {</span>
          <span class="s4">if </span><span class="s2">(isPropTypesUsageByMemberExpression(context, node, utils, checkAsyncSafeLifeCycles)) {</span>
            <span class="s4">return </span><span class="s2">property.raw;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s0">// falls through</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s2">(node.computed) {</span>
          <span class="s4">return </span><span class="s3">'__COMPUTED_PROP__'</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">break</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>

<span class="s2">module.exports = </span><span class="s4">function </span><span class="s2">usedPropTypesInstructions(context, components, utils) {</span>
  <span class="s4">const </span><span class="s2">checkAsyncSafeLifeCycles = testReactVersion(context, </span><span class="s3">'&gt;= 16.3.0'</span><span class="s2">);</span>

  <span class="s4">const </span><span class="s2">propVariables = createPropVariables();</span>
  <span class="s4">const </span><span class="s2">pushScope = propVariables.pushScope;</span>
  <span class="s4">const </span><span class="s2">popScope = propVariables.popScope;</span>

  <span class="s0">/**</span>
   <span class="s0">* Mark a prop type as used</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node being marked.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string[]} [parentNames]</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">markPropTypesAsUsed(node, parentNames) {</span>
    <span class="s2">parentNames = parentNames || [];</span>
    <span class="s4">let </span><span class="s2">type;</span>
    <span class="s4">let </span><span class="s2">name;</span>
    <span class="s4">let </span><span class="s2">allNames;</span>
    <span class="s4">let </span><span class="s2">properties;</span>
    <span class="s4">switch </span><span class="s2">(node.type) {</span>
      <span class="s4">case </span><span class="s3">'OptionalMemberExpression'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'MemberExpression'</span><span class="s2">:</span>
        <span class="s2">name = getPropertyName(context, node, utils, checkAsyncSafeLifeCycles);</span>
        <span class="s4">if </span><span class="s2">(name) {</span>
          <span class="s2">allNames = parentNames.concat(name);</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s0">// Match props.foo.bar, don't match bar[props.foo]</span>
            <span class="s2">node.parent.type === </span><span class="s3">'MemberExpression'</span>
            <span class="s2">&amp;&amp; node.parent.object === node</span>
          <span class="s2">) {</span>
            <span class="s2">markPropTypesAsUsed(node.parent, allNames);</span>
          <span class="s2">}</span>
          <span class="s0">// Handle the destructuring part of `const {foo} = props.a.b`</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">node.parent.type === </span><span class="s3">'VariableDeclarator'</span>
            <span class="s2">&amp;&amp; node.parent.id.type === </span><span class="s3">'ObjectPattern'</span>
          <span class="s2">) {</span>
            <span class="s2">node.parent.id.parent = node.parent; </span><span class="s0">// patch for bug in eslint@4 in which ObjectPattern has no parent</span>
            <span class="s2">markPropTypesAsUsed(node.parent.id, allNames);</span>
          <span class="s2">}</span>

          <span class="s0">// const a = props.a</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">node.parent.type === </span><span class="s3">'VariableDeclarator'</span>
            <span class="s2">&amp;&amp; node.parent.id.type === </span><span class="s3">'Identifier'</span>
          <span class="s2">) {</span>
            <span class="s2">propVariables.set(node.parent.id.name, allNames);</span>
          <span class="s2">}</span>
          <span class="s0">// Do not mark computed props as used.</span>
          <span class="s2">type = name !== </span><span class="s3">'__COMPUTED_PROP__' </span><span class="s2">? </span><span class="s3">'direct' </span><span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'FunctionDeclaration'</span><span class="s2">:</span>
      <span class="s4">case </span><span class="s3">'FunctionExpression'</span><span class="s2">: {</span>
        <span class="s4">if </span><span class="s2">(node.params.length === </span><span class="s5">0</span><span class="s2">) {</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">type = </span><span class="s3">'destructuring'</span><span class="s2">;</span>
        <span class="s4">const </span><span class="s2">propParam = isSetStateUpdater(node) ? node.params[</span><span class="s5">1</span><span class="s2">] : node.params[</span><span class="s5">0</span><span class="s2">];</span>
        <span class="s2">properties = propParam.type === </span><span class="s3">'AssignmentPattern'</span>
          <span class="s2">? propParam.left.properties</span>
          <span class="s2">: propParam.properties;</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">case </span><span class="s3">'ObjectPattern'</span><span class="s2">:</span>
        <span class="s2">type = </span><span class="s3">'destructuring'</span><span class="s2">;</span>
        <span class="s2">properties = node.properties;</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">'TSEmptyBodyFunctionExpression'</span><span class="s2">:</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">`</span><span class="s2">${node.type} </span><span class="s3">ASTNodes are not handled by markPropTypesAsUsed`</span><span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s4">const </span><span class="s2">component = components.get(utils.getParentComponent(node));</span>
    <span class="s4">const </span><span class="s2">usedPropTypes = (component &amp;&amp; component.usedPropTypes) || [];</span>
    <span class="s4">let </span><span class="s2">ignoreUnusedPropTypesValidation = (component &amp;&amp; component.ignoreUnusedPropTypesValidation) || </span><span class="s4">false</span><span class="s2">;</span>

    <span class="s4">switch </span><span class="s2">(type) {</span>
      <span class="s4">case </span><span class="s3">'direct'</span><span class="s2">: {</span>
        <span class="s0">// Ignore Object methods</span>
        <span class="s4">if </span><span class="s2">(name </span><span class="s4">in </span><span class="s2">Object.prototype) {</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s4">const </span><span class="s2">reportedNode = node.property;</span>
        <span class="s2">usedPropTypes.push({</span>
          <span class="s2">name,</span>
          <span class="s2">allNames,</span>
          <span class="s2">node: reportedNode,</span>
        <span class="s2">});</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">case </span><span class="s3">'destructuring'</span><span class="s2">: {</span>
        <span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">k = </span><span class="s5">0</span><span class="s2">, l = (properties || []).length; k &lt; l; k++) {</span>
          <span class="s4">if </span><span class="s2">(hasSpreadOperator(context, properties[k]) || properties[k].computed) {</span>
            <span class="s2">ignoreUnusedPropTypesValidation = </span><span class="s4">true</span><span class="s2">;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s4">const </span><span class="s2">propName = ast.getKeyValue(context, properties[k]);</span>

          <span class="s4">if </span><span class="s2">(!propName || properties[k].type !== </span><span class="s3">'Property'</span><span class="s2">) {</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s2">}</span>

          <span class="s2">usedPropTypes.push({</span>
            <span class="s2">allNames: parentNames.concat([propName]),</span>
            <span class="s2">name: propName,</span>
            <span class="s2">node: properties[k],</span>
          <span class="s2">});</span>

          <span class="s4">if </span><span class="s2">(properties[k].value.type === </span><span class="s3">'ObjectPattern'</span><span class="s2">) {</span>
            <span class="s2">markPropTypesAsUsed(properties[k].value, parentNames.concat([propName]));</span>
          <span class="s2">} </span><span class="s4">else if </span><span class="s2">(properties[k].value.type === </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
            <span class="s2">propVariables.set(properties[k].value.name, parentNames.concat(propName));</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">break</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">default</span><span class="s2">:</span>
        <span class="s4">break</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s2">components.set(component ? component.node : node, {</span>
      <span class="s2">usedPropTypes,</span>
      <span class="s2">ignoreUnusedPropTypesValidation,</span>
    <span class="s2">});</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node We expect either an ArrowFunctionExpression,</span>
   <span class="s0">*   FunctionDeclaration, or FunctionExpression</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">markDestructuredFunctionArgumentsAsUsed(node) {</span>
    <span class="s4">const </span><span class="s2">param = node.params &amp;&amp; isSetStateUpdater(node) ? node.params[</span><span class="s5">1</span><span class="s2">] : node.params[</span><span class="s5">0</span><span class="s2">];</span>

    <span class="s4">const </span><span class="s2">destructuring = param &amp;&amp; (</span>
      <span class="s2">param.type === </span><span class="s3">'ObjectPattern'</span>
      <span class="s2">|| ((param.type === </span><span class="s3">'AssignmentPattern'</span><span class="s2">) &amp;&amp; (param.left.type === </span><span class="s3">'ObjectPattern'</span><span class="s2">))</span>
    <span class="s2">);</span>

    <span class="s4">if </span><span class="s2">(destructuring &amp;&amp; (components.get(node) || components.get(node.parent))) {</span>
      <span class="s2">markPropTypesAsUsed(node);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">handleSetStateUpdater(node) {</span>
    <span class="s4">if </span><span class="s2">(!node.params || node.params.length &lt; </span><span class="s5">2 </span><span class="s2">|| !isSetStateUpdater(node)) {</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s2">markPropTypesAsUsed(node);</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* Handle both stateless functions and setState updater functions.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node We expect either an ArrowFunctionExpression,</span>
   <span class="s0">*   FunctionDeclaration, or FunctionExpression</span>
   <span class="s0">*/</span>
  <span class="s4">function </span><span class="s2">handleFunctionLikeExpressions(node) {</span>
    <span class="s2">pushScope();</span>
    <span class="s2">handleSetStateUpdater(node);</span>
    <span class="s2">markDestructuredFunctionArgumentsAsUsed(node);</span>
  <span class="s2">}</span>

  <span class="s4">function </span><span class="s2">handleCustomValidators(component) {</span>
    <span class="s4">const </span><span class="s2">propTypes = component.declaredPropTypes;</span>
    <span class="s4">if </span><span class="s2">(!propTypes) {</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s2">Object.keys(propTypes).forEach((key) =&gt; {</span>
      <span class="s4">const </span><span class="s2">node = propTypes[key].node;</span>

      <span class="s4">if </span><span class="s2">(node &amp;&amp; node.value &amp;&amp; astUtil.isFunctionLikeExpression(node.value)) {</span>
        <span class="s2">markPropTypesAsUsed(node.value);</span>
      <span class="s2">}</span>
    <span class="s2">});</span>
  <span class="s2">}</span>

  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">VariableDeclarator(node) {</span>
      <span class="s4">const </span><span class="s2">unwrappedInitNode = ast.unwrapTSAsExpression(node.init);</span>

      <span class="s0">// let props = this.props</span>
      <span class="s4">if </span><span class="s2">(isThisDotProps(unwrappedInitNode) &amp;&amp; isInClassComponent(context, node) &amp;&amp; node.id.type === </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
        <span class="s2">propVariables.set(node.id.name, []);</span>
      <span class="s2">}</span>

      <span class="s0">// Only handles destructuring</span>
      <span class="s4">if </span><span class="s2">(node.id.type !== </span><span class="s3">'ObjectPattern' </span><span class="s2">|| !unwrappedInitNode) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s0">// let {props: {firstname}} = this</span>
      <span class="s4">const </span><span class="s2">propsProperty = node.id.properties.find((property) =&gt; (</span>
        <span class="s2">property.key</span>
        <span class="s2">&amp;&amp; (property.key.name === </span><span class="s3">'props' </span><span class="s2">|| property.key.value === </span><span class="s3">'props'</span><span class="s2">)</span>
      <span class="s2">));</span>

      <span class="s4">if </span><span class="s2">(unwrappedInitNode.type === </span><span class="s3">'ThisExpression' </span><span class="s2">&amp;&amp; propsProperty &amp;&amp; propsProperty.value.type === </span><span class="s3">'ObjectPattern'</span><span class="s2">) {</span>
        <span class="s2">markPropTypesAsUsed(propsProperty.value);</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s0">// let {props} = this</span>
      <span class="s4">if </span><span class="s2">(unwrappedInitNode.type === </span><span class="s3">'ThisExpression' </span><span class="s2">&amp;&amp; propsProperty &amp;&amp; propsProperty.value.name === </span><span class="s3">'props'</span><span class="s2">) {</span>
        <span class="s2">propVariables.set(</span><span class="s3">'props'</span><span class="s2">, []);</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s0">// let {firstname} = props</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">isCommonVariableNameForProps(unwrappedInitNode.name)</span>
        <span class="s2">&amp;&amp; (utils.getParentStatelessComponent(node) || isInLifeCycleMethod(node, checkAsyncSafeLifeCycles))</span>
      <span class="s2">) {</span>
        <span class="s2">markPropTypesAsUsed(node.id);</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s0">// let {firstname} = this.props</span>
      <span class="s4">if </span><span class="s2">(isThisDotProps(unwrappedInitNode) &amp;&amp; isInClassComponent(context, node)) {</span>
        <span class="s2">markPropTypesAsUsed(node.id);</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s0">// let {firstname} = thing, where thing is defined by const thing = this.props.**.*</span>
      <span class="s4">if </span><span class="s2">(propVariables.get(unwrappedInitNode.name)) {</span>
        <span class="s2">markPropTypesAsUsed(node.id, propVariables.get(unwrappedInitNode.name));</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s2">FunctionDeclaration: handleFunctionLikeExpressions,</span>

    <span class="s2">ArrowFunctionExpression: handleFunctionLikeExpressions,</span>

    <span class="s2">FunctionExpression: handleFunctionLikeExpressions,</span>

    <span class="s3">'FunctionDeclaration:exit'</span><span class="s2">: popScope,</span>

    <span class="s3">'ArrowFunctionExpression:exit'</span><span class="s2">: popScope,</span>

    <span class="s3">'FunctionExpression:exit'</span><span class="s2">: popScope,</span>

    <span class="s2">JSXSpreadAttribute(node) {</span>
      <span class="s4">const </span><span class="s2">component = components.get(utils.getParentComponent(node));</span>
      <span class="s2">components.set(component ? component.node : node, {</span>
        <span class="s2">ignoreUnusedPropTypesValidation: node.argument.type !== </span><span class="s3">'ObjectExpression'</span><span class="s2">,</span>
      <span class="s2">});</span>
    <span class="s2">},</span>

    <span class="s3">'MemberExpression, OptionalMemberExpression'</span><span class="s2">(node) {</span>
      <span class="s4">if </span><span class="s2">(isPropTypesUsageByMemberExpression(context, node, utils, checkAsyncSafeLifeCycles)) {</span>
        <span class="s2">markPropTypesAsUsed(node);</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">propVariable = propVariables.get(ast.unwrapTSAsExpression(node.object).name);</span>
      <span class="s4">if </span><span class="s2">(propVariable) {</span>
        <span class="s2">markPropTypesAsUsed(node, propVariable);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s2">ObjectPattern(node) {</span>
      <span class="s0">// If the object pattern is a destructured props object in a lifecycle</span>
      <span class="s0">// method -- mark it for used props.</span>
      <span class="s4">if </span><span class="s2">(isNodeALifeCycleMethod(node.parent.parent, checkAsyncSafeLifeCycles) &amp;&amp; node.properties.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">markPropTypesAsUsed(node.parent);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>

    <span class="s3">'Program:exit'</span><span class="s2">() {</span>
      <span class="s2">values(components.list())</span>
        <span class="s2">.filter((component) =&gt; mustBeValidated(component))</span>
        <span class="s2">.forEach((component) =&gt; {</span>
          <span class="s2">handleCustomValidators(component);</span>
        <span class="s2">});</span>
    <span class="s2">},</span>
  <span class="s2">};</span>
<span class="s2">};</span>
</pre>
</body>
</html>