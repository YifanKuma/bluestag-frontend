<html>
<head>
<title>remapping.umd.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
remapping.umd.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">factory(module, require(</span><span class="s2">'@jridgewell/gen-mapping'</span><span class="s0">), require(</span><span class="s2">'@jridgewell/trace-mapping'</span><span class="s0">));</span>
    <span class="s0">module.exports = def(module);</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd) {</span>
    <span class="s0">define([</span><span class="s2">'module'</span><span class="s0">, </span><span class="s2">'@jridgewell/gen-mapping'</span><span class="s0">, </span><span class="s2">'@jridgewell/trace-mapping'</span><span class="s0">], </span><span class="s1">function</span><span class="s0">(mod) {</span>
      <span class="s0">factory.apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
      <span class="s0">mod.exports = def(mod);</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">const </span><span class="s0">mod = { exports: {} };</span>
    <span class="s0">factory(mod, global.genMapping, global.traceMapping);</span>
    <span class="s0">global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self;</span>
    <span class="s0">global.remapping = def(mod);</span>
  <span class="s0">}</span>
  <span class="s1">function </span><span class="s0">def(m) { </span><span class="s1">return </span><span class="s2">'default' </span><span class="s1">in </span><span class="s0">m.exports ? m.exports.default : m.exports; }</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(module, require_genMapping, require_traceMapping) {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">__create = Object.create;</span>
<span class="s1">var </span><span class="s0">__defProp = Object.defineProperty;</span>
<span class="s1">var </span><span class="s0">__getOwnPropDesc = Object.getOwnPropertyDescriptor;</span>
<span class="s1">var </span><span class="s0">__getOwnPropNames = Object.getOwnPropertyNames;</span>
<span class="s1">var </span><span class="s0">__getProtoOf = Object.getPrototypeOf;</span>
<span class="s1">var </span><span class="s0">__hasOwnProp = Object.prototype.hasOwnProperty;</span>
<span class="s1">var </span><span class="s0">__commonJS = (cb, mod) =&gt; </span><span class="s1">function </span><span class="s0">__require() {</span>
  <span class="s1">return </span><span class="s0">mod || (</span><span class="s3">0</span><span class="s0">, cb[__getOwnPropNames(cb)[</span><span class="s3">0</span><span class="s0">]])((mod = { exports: {} }).exports, mod), mod.exports;</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">__export = (target, all) =&gt; {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)</span>
    <span class="s0">__defProp(target, name, { get: all[name], enumerable: </span><span class="s1">true </span><span class="s0">});</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">__copyProps = (to, from, except, desc) =&gt; {</span>
  <span class="s1">if </span><span class="s0">(from &amp;&amp; </span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;object&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">key of __getOwnPropNames(from))</span>
      <span class="s1">if </span><span class="s0">(!__hasOwnProp.call(to, key) &amp;&amp; key !== except)</span>
        <span class="s0">__defProp(to, key, { get: () =&gt; from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">to;</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">__toESM = (mod, isNodeMode, target) =&gt; (target = mod != </span><span class="s1">null </span><span class="s0">? __create(__getProtoOf(mod)) : {}, __copyProps(</span>
  <span class="s4">// If the importer is in node compatibility mode or this is not an ESM</span>
  <span class="s4">// file that has been converted to a CommonJS file using a Babel-</span>
  <span class="s4">// compatible transform (i.e. &quot;__esModule&quot; has not been set), then set</span>
  <span class="s4">// &quot;default&quot; to the CommonJS &quot;module.exports&quot; for node compatibility.</span>
  <span class="s0">isNodeMode || !mod || !mod.__esModule ? __defProp(target, </span><span class="s2">&quot;default&quot;</span><span class="s0">, { value: mod, enumerable: </span><span class="s1">true </span><span class="s0">}) : target,</span>
  <span class="s0">mod</span>
<span class="s0">));</span>
<span class="s1">var </span><span class="s0">__toCommonJS = (mod) =&gt; __copyProps(__defProp({}, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, { value: </span><span class="s1">true </span><span class="s0">}), mod);</span>

<span class="s4">// umd:@jridgewell/trace-mapping</span>
<span class="s1">var </span><span class="s0">require_trace_mapping = __commonJS({</span>
  <span class="s2">&quot;umd:@jridgewell/trace-mapping&quot;</span><span class="s0">(exports, module2) {</span>
    <span class="s0">module2.exports = require_traceMapping;</span>
  <span class="s0">}</span>
<span class="s0">});</span>

<span class="s4">// umd:@jridgewell/gen-mapping</span>
<span class="s1">var </span><span class="s0">require_gen_mapping = __commonJS({</span>
  <span class="s2">&quot;umd:@jridgewell/gen-mapping&quot;</span><span class="s0">(exports, module2) {</span>
    <span class="s0">module2.exports = require_genMapping;</span>
  <span class="s0">}</span>
<span class="s0">});</span>

<span class="s4">// src/remapping.ts</span>
<span class="s1">var </span><span class="s0">remapping_exports = {};</span>
<span class="s0">__export(remapping_exports, {</span>
  <span class="s1">default</span><span class="s0">: () =&gt; remapping</span>
<span class="s0">});</span>
<span class="s0">module.exports = __toCommonJS(remapping_exports);</span>

<span class="s4">// src/build-source-map-tree.ts</span>
<span class="s1">var </span><span class="s0">import_trace_mapping2 = __toESM(require_trace_mapping());</span>

<span class="s4">// src/source-map-tree.ts</span>
<span class="s1">var </span><span class="s0">import_gen_mapping = __toESM(require_gen_mapping());</span>
<span class="s1">var </span><span class="s0">import_trace_mapping = __toESM(require_trace_mapping());</span>
<span class="s1">var </span><span class="s0">SOURCELESS_MAPPING = </span><span class="s4">/* @__PURE__ */ </span><span class="s0">SegmentObject(</span><span class="s2">&quot;&quot;</span><span class="s0">, -</span><span class="s3">1</span><span class="s0">, -</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">EMPTY_SOURCES = [];</span>
<span class="s1">function </span><span class="s0">SegmentObject(source, line, column, name, content, ignore) {</span>
  <span class="s1">return </span><span class="s0">{ source, line, column, name, content, ignore };</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">Source(map, sources, source, content, ignore) {</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">map,</span>
    <span class="s0">sources,</span>
    <span class="s0">source,</span>
    <span class="s0">content,</span>
    <span class="s0">ignore</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">MapSource(map, sources) {</span>
  <span class="s1">return </span><span class="s0">Source(map, sources, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">OriginalSource(source, content, ignore) {</span>
  <span class="s1">return </span><span class="s0">Source(</span><span class="s1">null</span><span class="s0">, EMPTY_SOURCES, source, content, ignore);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">traceMappings(tree) {</span>
  <span class="s1">const </span><span class="s0">gen = </span><span class="s1">new </span><span class="s0">import_gen_mapping.GenMapping({ file: tree.map.file });</span>
  <span class="s1">const </span><span class="s0">{ sources: rootSources, map } = tree;</span>
  <span class="s1">const </span><span class="s0">rootNames = map.names;</span>
  <span class="s1">const </span><span class="s0">rootMappings = (</span><span class="s3">0</span><span class="s0">, import_trace_mapping.decodedMappings)(map);</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; rootMappings.length; i++) {</span>
    <span class="s1">const </span><span class="s0">segments = rootMappings[i];</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">j = </span><span class="s3">0</span><span class="s0">; j &lt; segments.length; j++) {</span>
      <span class="s1">const </span><span class="s0">segment = segments[j];</span>
      <span class="s1">const </span><span class="s0">genCol = segment[</span><span class="s3">0</span><span class="s0">];</span>
      <span class="s1">let </span><span class="s0">traced = SOURCELESS_MAPPING;</span>
      <span class="s1">if </span><span class="s0">(segment.length !== </span><span class="s3">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">source2 = rootSources[segment[</span><span class="s3">1</span><span class="s0">]];</span>
        <span class="s0">traced = originalPositionFor(</span>
          <span class="s0">source2,</span>
          <span class="s0">segment[</span><span class="s3">2</span><span class="s0">],</span>
          <span class="s0">segment[</span><span class="s3">3</span><span class="s0">],</span>
          <span class="s0">segment.length === </span><span class="s3">5 </span><span class="s0">? rootNames[segment[</span><span class="s3">4</span><span class="s0">]] : </span><span class="s2">&quot;&quot;</span>
        <span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(traced == </span><span class="s1">null</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
      <span class="s0">}</span>
      <span class="s1">const </span><span class="s0">{ column, line, name, content, source, ignore } = traced;</span>
      <span class="s0">(</span><span class="s3">0</span><span class="s0">, import_gen_mapping.maybeAddSegment)(gen, i, genCol, source, line, column, name);</span>
      <span class="s1">if </span><span class="s0">(source &amp;&amp; content != </span><span class="s1">null</span><span class="s0">) (</span><span class="s3">0</span><span class="s0">, import_gen_mapping.setSourceContent)(gen, source, content);</span>
      <span class="s1">if </span><span class="s0">(ignore) (</span><span class="s3">0</span><span class="s0">, import_gen_mapping.setIgnore)(gen, source, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">gen;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">originalPositionFor(source, line, column, name) {</span>
  <span class="s1">if </span><span class="s0">(!source.map) {</span>
    <span class="s1">return </span><span class="s0">SegmentObject(source.source, line, column, name, source.content, source.ignore);</span>
  <span class="s0">}</span>
  <span class="s1">const </span><span class="s0">segment = (</span><span class="s3">0</span><span class="s0">, import_trace_mapping.traceSegment)(source.map, line, column);</span>
  <span class="s1">if </span><span class="s0">(segment == </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return null</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s3">1</span><span class="s0">) </span><span class="s1">return </span><span class="s0">SOURCELESS_MAPPING;</span>
  <span class="s1">return </span><span class="s0">originalPositionFor(</span>
    <span class="s0">source.sources[segment[</span><span class="s3">1</span><span class="s0">]],</span>
    <span class="s0">segment[</span><span class="s3">2</span><span class="s0">],</span>
    <span class="s0">segment[</span><span class="s3">3</span><span class="s0">],</span>
    <span class="s0">segment.length === </span><span class="s3">5 </span><span class="s0">? source.map.names[segment[</span><span class="s3">4</span><span class="s0">]] : name</span>
  <span class="s0">);</span>
<span class="s0">}</span>

<span class="s4">// src/build-source-map-tree.ts</span>
<span class="s1">function </span><span class="s0">asArray(value) {</span>
  <span class="s1">if </span><span class="s0">(Array.isArray(value)) </span><span class="s1">return </span><span class="s0">value;</span>
  <span class="s1">return </span><span class="s0">[value];</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">buildSourceMapTree(input, loader) {</span>
  <span class="s1">const </span><span class="s0">maps = asArray(input).map((m) =&gt; </span><span class="s1">new </span><span class="s0">import_trace_mapping2.TraceMap(m, </span><span class="s2">&quot;&quot;</span><span class="s0">));</span>
  <span class="s1">const </span><span class="s0">map = maps.pop();</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; maps.length; i++) {</span>
    <span class="s1">if </span><span class="s0">(maps[i].sources.length &gt; </span><span class="s3">1</span><span class="s0">) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span>
        <span class="s2">`Transformation map </span><span class="s0">${i} </span><span class="s2">must have exactly one source file. 
Did you specify these with the most recent transformation maps first?`</span>
      <span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s1">let </span><span class="s0">tree = build(map, loader, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s0">);</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = maps.length - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--) {</span>
    <span class="s0">tree = MapSource(maps[i], [tree]);</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">tree;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">build(map, loader, importer, importerDepth) {</span>
  <span class="s1">const </span><span class="s0">{ resolvedSources, sourcesContent, ignoreList } = map;</span>
  <span class="s1">const </span><span class="s0">depth = importerDepth + </span><span class="s3">1</span><span class="s0">;</span>
  <span class="s1">const </span><span class="s0">children = resolvedSources.map((sourceFile, i) =&gt; {</span>
    <span class="s1">const </span><span class="s0">ctx = {</span>
      <span class="s0">importer,</span>
      <span class="s0">depth,</span>
      <span class="s0">source: sourceFile || </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
      <span class="s0">content: </span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span>
      <span class="s0">ignore: </span><span class="s1">void </span><span class="s3">0</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">sourceMap = loader(ctx.source, ctx);</span>
    <span class="s1">const </span><span class="s0">{ source, content, ignore } = ctx;</span>
    <span class="s1">if </span><span class="s0">(sourceMap) </span><span class="s1">return </span><span class="s0">build(</span><span class="s1">new </span><span class="s0">import_trace_mapping2.TraceMap(sourceMap, source), loader, source, depth);</span>
    <span class="s1">const </span><span class="s0">sourceContent = content !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? content : sourcesContent ? sourcesContent[i] : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">ignored = ignore !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s0">? ignore : ignoreList ? ignoreList.includes(i) : </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">OriginalSource(source, sourceContent, ignored);</span>
  <span class="s0">});</span>
  <span class="s1">return </span><span class="s0">MapSource(map, children);</span>
<span class="s0">}</span>

<span class="s4">// src/source-map.ts</span>
<span class="s1">var </span><span class="s0">import_gen_mapping2 = __toESM(require_gen_mapping());</span>
<span class="s1">var </span><span class="s0">SourceMap = </span><span class="s1">class </span><span class="s0">{</span>
  <span class="s0">constructor(map, options) {</span>
    <span class="s1">const </span><span class="s0">out = options.decodedMappings ? (</span><span class="s3">0</span><span class="s0">, import_gen_mapping2.toDecodedMap)(map) : (</span><span class="s3">0</span><span class="s0">, import_gen_mapping2.toEncodedMap)(map);</span>
    <span class="s1">this</span><span class="s0">.version = out.version;</span>
    <span class="s1">this</span><span class="s0">.file = out.file;</span>
    <span class="s1">this</span><span class="s0">.mappings = out.mappings;</span>
    <span class="s1">this</span><span class="s0">.names = out.names;</span>
    <span class="s1">this</span><span class="s0">.ignoreList = out.ignoreList;</span>
    <span class="s1">this</span><span class="s0">.sourceRoot = out.sourceRoot;</span>
    <span class="s1">this</span><span class="s0">.sources = out.sources;</span>
    <span class="s1">if </span><span class="s0">(!options.excludeContent) {</span>
      <span class="s1">this</span><span class="s0">.sourcesContent = out.sourcesContent;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s0">toString() {</span>
    <span class="s1">return </span><span class="s0">JSON.stringify(</span><span class="s1">this</span><span class="s0">);</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s4">// src/remapping.ts</span>
<span class="s1">function </span><span class="s0">remapping(input, loader, options) {</span>
  <span class="s1">const </span><span class="s0">opts = </span><span class="s1">typeof </span><span class="s0">options === </span><span class="s2">&quot;object&quot; </span><span class="s0">? options : { excludeContent: !!options, decodedMappings: </span><span class="s1">false </span><span class="s0">};</span>
  <span class="s1">const </span><span class="s0">tree = buildSourceMapTree(input, loader);</span>
  <span class="s1">return new </span><span class="s0">SourceMap(traceMappings(tree), opts);</span>
<span class="s0">}</span>
<span class="s0">}));</span>
<span class="s4">//# sourceMappingURL=remapping.umd.js.map</span>
</pre>
</body>
</html>