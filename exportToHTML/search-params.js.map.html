<html>
<head>
<title>search-params.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
search-params.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/request/search-params.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { WorkStore } from '../app-render/work-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">throwToInterruptStaticGeneration,</span><span class="s3">\n  </span><span class="s1">postponeWithTracking,</span><span class="s3">\n  </span><span class="s1">trackDynamicDataInDynamicRender,</span><span class="s3">\n  </span><span class="s1">annotateDynamicAccess,</span><span class="s3">\n  </span><span class="s1">trackSynchronousRequestDataAccessInDev,</span><span class="s3">\n  </span><span class="s1">delayUntilRuntimeStage,</span><span class="s3">\n</span><span class="s1">} from '../app-render/dynamic-rendering'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type PrerenderStoreLegacy,</span><span class="s3">\n  </span><span class="s1">type PrerenderStorePPR,</span><span class="s3">\n  </span><span class="s1">type PrerenderStoreModern,</span><span class="s3">\n  </span><span class="s1">type PrerenderStoreModernRuntime,</span><span class="s3">\n  </span><span class="s1">type StaticPrerenderStore,</span><span class="s3">\n  </span><span class="s1">throwInvariantForMissingStore,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">makeDevtoolsIOAwarePromise,</span><span class="s3">\n  </span><span class="s1">makeHangingPromise,</span><span class="s3">\n</span><span class="s1">} from '../dynamic-rendering-utils'</span><span class="s3">\n</span><span class="s1">import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">describeStringPropertyAccess,</span><span class="s3">\n  </span><span class="s1">describeHasCheckingStringProperty,</span><span class="s3">\n  </span><span class="s1">wellKnownProperties,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/utils/reflect-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError,</span><span class="s3">\n  </span><span class="s1">throwForSearchParamsAccessInUseCache,</span><span class="s3">\n</span><span class="s1">} from './utils'</span><span class="s3">\n\n</span><span class="s1">export type SearchParams = { [key: string]: string | string[] | undefined }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.</span><span class="s3">\n </span><span class="s1">* However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.</span><span class="s3">\n </span><span class="s1">* The `UnsafeUnwrappedSearchParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you</span><span class="s3">\n </span><span class="s1">* have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```tsx</span><span class="s3">\n </span><span class="s1">* type Props = { searchParams: Promise&lt;{ foo: string }&gt; }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export default async function Page(props: Props) {</span><span class="s3">\n </span><span class="s1">*  const { searchParams } = (props.searchParams as unknown as UnsafeUnwrappedSearchParams&lt;typeof props.searchParams&gt;)</span><span class="s3">\n </span><span class="s1">*  return ...</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This type is marked deprecated to help identify it as target for refactoring away.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @deprecated</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type UnsafeUnwrappedSearchParams&lt;P&gt; =</span><span class="s3">\n  </span><span class="s1">P extends Promise&lt;infer U&gt; ? Omit&lt;U, 'then' | 'status' | 'value'&gt; : never</span><span class="s3">\n\n</span><span class="s1">export function createSearchParamsFromClient(</span><span class="s3">\n  </span><span class="s1">underlyingSearchParams: SearchParams,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">return createStaticPrerenderSearchParams(workStore, workUnitStore)</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createSearchParamsFromClient should not be called in a runtime prerender.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createSearchParamsFromClient should not be called in cache contexts.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">return createRenderSearchParams(underlyingSearchParams, workStore)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throwInvariantForMissingStore()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component</span><span class="s3">\n</span><span class="s1">export const createServerSearchParamsForMetadata =</span><span class="s3">\n  </span><span class="s1">createServerSearchParamsForServerPage</span><span class="s3">\n\n</span><span class="s1">export function createServerSearchParamsForServerPage(</span><span class="s3">\n  </span><span class="s1">underlyingSearchParams: SearchParams,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">return createStaticPrerenderSearchParams(workStore, workUnitStore)</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createServerSearchParamsForServerPage should not be called in cache contexts.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">return createRuntimePrerenderSearchParams(</span><span class="s3">\n          </span><span class="s1">underlyingSearchParams,</span><span class="s3">\n          </span><span class="s1">workUnitStore</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">return createRenderSearchParams(underlyingSearchParams, workStore)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throwInvariantForMissingStore()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createPrerenderSearchParamsForClientPage(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">if (workStore.forceStatic) {</span><span class="s3">\n    </span><span class="s1">// When using forceStatic we override all other logic and always just return an empty</span><span class="s3">\n    </span><span class="s1">// dictionary object.</span><span class="s3">\n    </span><span class="s1">return Promise.resolve({})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n        </span><span class="s1">// We're prerendering in a mode that aborts (cacheComponents) and should stall</span><span class="s3">\n        </span><span class="s1">// the promise to ensure the RSC side is considered dynamic</span><span class="s3">\n        </span><span class="s1">return makeHangingPromise(</span><span class="s3">\n          </span><span class="s1">workUnitStore.renderSignal,</span><span class="s3">\n          </span><span class="s1">workStore.route,</span><span class="s3">\n          </span><span class="s1">'`searchParams`'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'createPrerenderSearchParamsForClientPage should not be called in cache contexts.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">return Promise.resolve({})</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throwInvariantForMissingStore()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createStaticPrerenderSearchParams(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">prerenderStore: StaticPrerenderStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">if (workStore.forceStatic) {</span><span class="s3">\n    </span><span class="s1">// When using forceStatic we override all other logic and always just return an empty</span><span class="s3">\n    </span><span class="s1">// dictionary object.</span><span class="s3">\n    </span><span class="s1">return Promise.resolve({})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">switch (prerenderStore.type) {</span><span class="s3">\n    </span><span class="s1">case 'prerender':</span><span class="s3">\n    </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">// We are in a cacheComponents (PPR or otherwise) prerender</span><span class="s3">\n      </span><span class="s1">return makeHangingSearchParams(workStore, prerenderStore)</span><span class="s3">\n    </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n    </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">// We are in a legacy static generation and need to interrupt the</span><span class="s3">\n      </span><span class="s1">// prerender when search params are accessed.</span><span class="s3">\n      </span><span class="s1">return makeErroringExoticSearchParams(workStore, prerenderStore)</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return prerenderStore satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createRuntimePrerenderSearchParams(</span><span class="s3">\n  </span><span class="s1">underlyingSearchParams: SearchParams,</span><span class="s3">\n  </span><span class="s1">workUnitStore: PrerenderStoreModernRuntime</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">return delayUntilRuntimeStage(</span><span class="s3">\n    </span><span class="s1">workUnitStore,</span><span class="s3">\n    </span><span class="s1">process.env.__NEXT_CACHE_COMPONENTS</span><span class="s3">\n      </span><span class="s1">? makeUntrackedSearchParams(underlyingSearchParams)</span><span class="s3">\n      </span><span class="s1">: makeUntrackedExoticSearchParams(underlyingSearchParams)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createRenderSearchParams(</span><span class="s3">\n  </span><span class="s1">underlyingSearchParams: SearchParams,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">if (workStore.forceStatic) {</span><span class="s3">\n    </span><span class="s1">// When using forceStatic we override all other logic and always just return an empty</span><span class="s3">\n    </span><span class="s1">// dictionary object.</span><span class="s3">\n    </span><span class="s1">return Promise.resolve({})</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n      </span><span class="s1">// Semantically we only need the dev tracking when running in `next dev`</span><span class="s3">\n      </span><span class="s1">// but since you would never use next dev with production NODE_ENV we use this</span><span class="s3">\n      </span><span class="s1">// as a proxy so we can statically exclude this code from production builds.</span><span class="s3">\n      </span><span class="s1">if (process.env.__NEXT_CACHE_COMPONENTS) {</span><span class="s3">\n        </span><span class="s1">return makeUntrackedSearchParamsWithDevWarnings(</span><span class="s3">\n          </span><span class="s1">underlyingSearchParams,</span><span class="s3">\n          </span><span class="s1">workStore</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(</span><span class="s3">\n        </span><span class="s1">underlyingSearchParams,</span><span class="s3">\n        </span><span class="s1">workStore</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (process.env.__NEXT_CACHE_COMPONENTS) {</span><span class="s3">\n        </span><span class="s1">return makeUntrackedSearchParams(underlyingSearchParams)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return makeUntrackedExoticSearchParams(underlyingSearchParams)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface CacheLifetime {}</span><span class="s3">\n</span><span class="s1">const CachedSearchParams = new WeakMap&lt;CacheLifetime, Promise&lt;SearchParams&gt;&gt;()</span><span class="s3">\n\n</span><span class="s1">const CachedSearchParamsForUseCache = new WeakMap&lt;</span><span class="s3">\n  </span><span class="s1">CacheLifetime,</span><span class="s3">\n  </span><span class="s1">Promise&lt;SearchParams&gt;</span><span class="s3">\n</span><span class="s1">&gt;()</span><span class="s3">\n\n</span><span class="s1">function makeHangingSearchParams(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedSearchParams = CachedSearchParams.get(prerenderStore)</span><span class="s3">\n  </span><span class="s1">if (cachedSearchParams) {</span><span class="s3">\n    </span><span class="s1">return cachedSearchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = makeHangingPromise&lt;SearchParams&gt;(</span><span class="s3">\n    </span><span class="s1">prerenderStore.renderSignal,</span><span class="s3">\n    </span><span class="s1">workStore.route,</span><span class="s3">\n    </span><span class="s1">'`searchParams`'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const proxiedPromise = new Proxy(promise, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">if (Object.hasOwn(promise, prop)) {</span><span class="s3">\n        </span><span class="s1">// The promise has this property directly. we must return it.</span><span class="s3">\n        </span><span class="s1">// We know it isn't a dynamic access because it can only be something</span><span class="s3">\n        </span><span class="s1">// that was previously written to the promise and thus not an underlying searchParam value</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">switch (prop) {</span><span class="s3">\n        </span><span class="s1">case 'then': {</span><span class="s3">\n          </span><span class="s1">const expression =</span><span class="s3">\n            </span><span class="s1">'`await searchParams`, `searchParams.then`, or similar'</span><span class="s3">\n          </span><span class="s1">annotateDynamicAccess(expression, prerenderStore)</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'status': {</span><span class="s3">\n          </span><span class="s1">const expression =</span><span class="s3">\n            </span><span class="s1">'`use(searchParams)`, `searchParams.status`, or similar'</span><span class="s3">\n          </span><span class="s1">annotateDynamicAccess(expression, prerenderStore)</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">default: {</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">CachedSearchParams.set(prerenderStore, proxiedPromise)</span><span class="s3">\n  </span><span class="s1">return proxiedPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeErroringExoticSearchParams(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedSearchParams = CachedSearchParams.get(workStore)</span><span class="s3">\n  </span><span class="s1">if (cachedSearchParams) {</span><span class="s3">\n    </span><span class="s1">return cachedSearchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const underlyingSearchParams = {}</span><span class="s3">\n  </span><span class="s1">// For search params we don't construct a ReactPromise because we want to interrupt</span><span class="s3">\n  </span><span class="s1">// rendering on any property access that was not set from outside and so we only want</span><span class="s3">\n  </span><span class="s1">// to have properties like value and status if React sets them.</span><span class="s3">\n  </span><span class="s1">const promise = Promise.resolve(underlyingSearchParams)</span><span class="s3">\n\n  </span><span class="s1">const proxiedPromise = new Proxy(promise, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">if (Object.hasOwn(promise, prop)) {</span><span class="s3">\n        </span><span class="s1">// The promise has this property directly. we must return it.</span><span class="s3">\n        </span><span class="s1">// We know it isn't a dynamic access because it can only be something</span><span class="s3">\n        </span><span class="s1">// that was previously written to the promise and thus not an underlying searchParam value</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">switch (prop) {</span><span class="s3">\n        </span><span class="s1">case 'then': {</span><span class="s3">\n          </span><span class="s1">const expression =</span><span class="s3">\n            </span><span class="s1">'`await searchParams`, `searchParams.then`, or similar'</span><span class="s3">\n          </span><span class="s1">if (workStore.dynamicShouldError) {</span><span class="s3">\n            </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError(</span><span class="s3">\n              </span><span class="s1">workStore.route,</span><span class="s3">\n              </span><span class="s1">expression</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} else if (prerenderStore.type === 'prerender-ppr') {</span><span class="s3">\n            </span><span class="s1">// PPR Prerender (no cacheComponents)</span><span class="s3">\n            </span><span class="s1">postponeWithTracking(</span><span class="s3">\n              </span><span class="s1">workStore.route,</span><span class="s3">\n              </span><span class="s1">expression,</span><span class="s3">\n              </span><span class="s1">prerenderStore.dynamicTracking</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// Legacy Prerender</span><span class="s3">\n            </span><span class="s1">throwToInterruptStaticGeneration(</span><span class="s3">\n              </span><span class="s1">expression,</span><span class="s3">\n              </span><span class="s1">workStore,</span><span class="s3">\n              </span><span class="s1">prerenderStore</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'status': {</span><span class="s3">\n          </span><span class="s1">const expression =</span><span class="s3">\n            </span><span class="s1">'`use(searchParams)`, `searchParams.status`, or similar'</span><span class="s3">\n          </span><span class="s1">if (workStore.dynamicShouldError) {</span><span class="s3">\n            </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError(</span><span class="s3">\n              </span><span class="s1">workStore.route,</span><span class="s3">\n              </span><span class="s1">expression</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} else if (prerenderStore.type === 'prerender-ppr') {</span><span class="s3">\n            </span><span class="s1">// PPR Prerender (no cacheComponents)</span><span class="s3">\n            </span><span class="s1">postponeWithTracking(</span><span class="s3">\n              </span><span class="s1">workStore.route,</span><span class="s3">\n              </span><span class="s1">expression,</span><span class="s3">\n              </span><span class="s1">prerenderStore.dynamicTracking</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// Legacy Prerender</span><span class="s3">\n            </span><span class="s1">throwToInterruptStaticGeneration(</span><span class="s3">\n              </span><span class="s1">expression,</span><span class="s3">\n              </span><span class="s1">workStore,</span><span class="s3">\n              </span><span class="s1">prerenderStore</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">default: {</span><span class="s3">\n          </span><span class="s1">if (typeof prop === 'string' &amp;&amp; !wellKnownProperties.has(prop)) {</span><span class="s3">\n            </span><span class="s1">const expression = describeStringPropertyAccess(</span><span class="s3">\n              </span><span class="s1">'searchParams',</span><span class="s3">\n              </span><span class="s1">prop</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">if (workStore.dynamicShouldError) {</span><span class="s3">\n              </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError(</span><span class="s3">\n                </span><span class="s1">workStore.route,</span><span class="s3">\n                </span><span class="s1">expression</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else if (prerenderStore.type === 'prerender-ppr') {</span><span class="s3">\n              </span><span class="s1">// PPR Prerender (no cacheComponents)</span><span class="s3">\n              </span><span class="s1">postponeWithTracking(</span><span class="s3">\n                </span><span class="s1">workStore.route,</span><span class="s3">\n                </span><span class="s1">expression,</span><span class="s3">\n                </span><span class="s1">prerenderStore.dynamicTracking</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// Legacy Prerender</span><span class="s3">\n              </span><span class="s1">throwToInterruptStaticGeneration(</span><span class="s3">\n                </span><span class="s1">expression,</span><span class="s3">\n                </span><span class="s1">workStore,</span><span class="s3">\n                </span><span class="s1">prerenderStore</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">has(target, prop) {</span><span class="s3">\n      </span><span class="s1">// We don't expect key checking to be used except for testing the existence of</span><span class="s3">\n      </span><span class="s1">// searchParams so we make all has tests trigger dynamic. this means that `promise.then`</span><span class="s3">\n      </span><span class="s1">// can resolve to the then function on the Promise prototype but 'then' in promise will assume</span><span class="s3">\n      </span><span class="s1">// you are testing whether the searchParams has a 'then' property.</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">const expression = describeHasCheckingStringProperty(</span><span class="s3">\n          </span><span class="s1">'searchParams',</span><span class="s3">\n          </span><span class="s1">prop</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (workStore.dynamicShouldError) {</span><span class="s3">\n          </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError(</span><span class="s3">\n            </span><span class="s1">workStore.route,</span><span class="s3">\n            </span><span class="s1">expression</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else if (prerenderStore.type === 'prerender-ppr') {</span><span class="s3">\n          </span><span class="s1">// PPR Prerender (no cacheComponents)</span><span class="s3">\n          </span><span class="s1">postponeWithTracking(</span><span class="s3">\n            </span><span class="s1">workStore.route,</span><span class="s3">\n            </span><span class="s1">expression,</span><span class="s3">\n            </span><span class="s1">prerenderStore.dynamicTracking</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// Legacy Prerender</span><span class="s3">\n          </span><span class="s1">throwToInterruptStaticGeneration(</span><span class="s3">\n            </span><span class="s1">expression,</span><span class="s3">\n            </span><span class="s1">workStore,</span><span class="s3">\n            </span><span class="s1">prerenderStore</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ReflectAdapter.has(target, prop)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ownKeys() {</span><span class="s3">\n      </span><span class="s1">const expression =</span><span class="s3">\n        </span><span class="s1">'`{...searchParams}`, `Object.keys(searchParams)`, or similar'</span><span class="s3">\n      </span><span class="s1">if (workStore.dynamicShouldError) {</span><span class="s3">\n        </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError(</span><span class="s3">\n          </span><span class="s1">workStore.route,</span><span class="s3">\n          </span><span class="s1">expression</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else if (prerenderStore.type === 'prerender-ppr') {</span><span class="s3">\n        </span><span class="s1">// PPR Prerender (no cacheComponents)</span><span class="s3">\n        </span><span class="s1">postponeWithTracking(</span><span class="s3">\n          </span><span class="s1">workStore.route,</span><span class="s3">\n          </span><span class="s1">expression,</span><span class="s3">\n          </span><span class="s1">prerenderStore.dynamicTracking</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Legacy Prerender</span><span class="s3">\n        </span><span class="s1">throwToInterruptStaticGeneration(expression, workStore, prerenderStore)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">CachedSearchParams.set(workStore, proxiedPromise)</span><span class="s3">\n  </span><span class="s1">return proxiedPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is a variation of `makeErroringExoticSearchParams` that always throws an</span><span class="s3">\n </span><span class="s1">* error on access, because accessing searchParams inside of `</span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">` is</span><span class="s3">\n </span><span class="s1">* not allowed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function makeErroringSearchParamsForUseCache(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore)</span><span class="s3">\n  </span><span class="s1">if (cachedSearchParams) {</span><span class="s3">\n    </span><span class="s1">return cachedSearchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = Promise.resolve({})</span><span class="s3">\n\n  </span><span class="s1">const proxiedPromise = new Proxy(promise, {</span><span class="s3">\n    </span><span class="s1">get: function get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">if (Object.hasOwn(promise, prop)) {</span><span class="s3">\n        </span><span class="s1">// The promise has this property directly. we must return it. We know it</span><span class="s3">\n        </span><span class="s1">// isn't a dynamic access because it can only be something that was</span><span class="s3">\n        </span><span class="s1">// previously written to the promise and thus not an underlying</span><span class="s3">\n        </span><span class="s1">// searchParam value</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">typeof prop === 'string' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(prop === 'then' || !wellKnownProperties.has(prop))</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throwForSearchParamsAccessInUseCache(workStore, get)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">has: function has(target, prop) {</span><span class="s3">\n      </span><span class="s1">// We don't expect key checking to be used except for testing the existence of</span><span class="s3">\n      </span><span class="s1">// searchParams so we make all has tests throw an error. this means that `promise.then`</span><span class="s3">\n      </span><span class="s1">// can resolve to the then function on the Promise prototype but 'then' in promise will assume</span><span class="s3">\n      </span><span class="s1">// you are testing whether the searchParams has a 'then' property.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">typeof prop === 'string' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(prop === 'then' || !wellKnownProperties.has(prop))</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throwForSearchParamsAccessInUseCache(workStore, has)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return ReflectAdapter.has(target, prop)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ownKeys: function ownKeys() {</span><span class="s3">\n      </span><span class="s1">throwForSearchParamsAccessInUseCache(workStore, ownKeys)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">CachedSearchParamsForUseCache.set(workStore, proxiedPromise)</span><span class="s3">\n  </span><span class="s1">return proxiedPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeUntrackedExoticSearchParams(</span><span class="s3">\n  </span><span class="s1">underlyingSearchParams: SearchParams</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)</span><span class="s3">\n  </span><span class="s1">if (cachedSearchParams) {</span><span class="s3">\n    </span><span class="s1">return cachedSearchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We don't use makeResolvedReactPromise here because searchParams</span><span class="s3">\n  </span><span class="s1">// supports copying with spread and we don't want to unnecessarily</span><span class="s3">\n  </span><span class="s1">// instrument the promise with spreadable properties of ReactPromise.</span><span class="s3">\n  </span><span class="s1">const promise = Promise.resolve(underlyingSearchParams)</span><span class="s3">\n  </span><span class="s1">CachedSearchParams.set(underlyingSearchParams, promise)</span><span class="s3">\n\n  </span><span class="s1">Object.keys(underlyingSearchParams).forEach((prop) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!wellKnownProperties.has(prop)) {</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(promise, prop, {</span><span class="s3">\n        </span><span class="s1">get() {</span><span class="s3">\n          </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n          </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n            </span><span class="s1">trackDynamicDataInDynamicRender(workUnitStore)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return underlyingSearchParams[prop]</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">set(value) {</span><span class="s3">\n          </span><span class="s1">Object.defineProperty(promise, prop, {</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n            </span><span class="s1">writable: true,</span><span class="s3">\n            </span><span class="s1">enumerable: true,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">enumerable: true,</span><span class="s3">\n        </span><span class="s1">configurable: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeUntrackedSearchParams(</span><span class="s3">\n  </span><span class="s1">underlyingSearchParams: SearchParams</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)</span><span class="s3">\n  </span><span class="s1">if (cachedSearchParams) {</span><span class="s3">\n    </span><span class="s1">return cachedSearchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = Promise.resolve(underlyingSearchParams)</span><span class="s3">\n  </span><span class="s1">CachedSearchParams.set(underlyingSearchParams, promise)</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(</span><span class="s3">\n  </span><span class="s1">underlyingSearchParams: SearchParams,</span><span class="s3">\n  </span><span class="s1">store: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)</span><span class="s3">\n  </span><span class="s1">if (cachedSearchParams) {</span><span class="s3">\n    </span><span class="s1">return cachedSearchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const proxiedProperties = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">const unproxiedProperties: Array&lt;string&gt; = []</span><span class="s3">\n\n  </span><span class="s1">// We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying</span><span class="s3">\n  </span><span class="s1">// searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender</span><span class="s3">\n  </span><span class="s1">// indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking</span><span class="s3">\n  </span><span class="s1">// at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger</span><span class="s3">\n  </span><span class="s1">// dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce</span><span class="s3">\n  </span><span class="s1">// this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.</span><span class="s3">\n  </span><span class="s1">let promiseInitialized = false</span><span class="s3">\n  </span><span class="s1">const proxiedUnderlying = new Proxy(underlyingSearchParams, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string' &amp;&amp; promiseInitialized) {</span><span class="s3">\n        </span><span class="s1">if (store.dynamicShouldError) {</span><span class="s3">\n          </span><span class="s1">const expression = describeStringPropertyAccess('searchParams', prop)</span><span class="s3">\n          </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError(</span><span class="s3">\n            </span><span class="s1">store.route,</span><span class="s3">\n            </span><span class="s1">expression</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n        </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n          </span><span class="s1">trackDynamicDataInDynamicRender(workUnitStore)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">has(target, prop) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">if (store.dynamicShouldError) {</span><span class="s3">\n          </span><span class="s1">const expression = describeHasCheckingStringProperty(</span><span class="s3">\n            </span><span class="s1">'searchParams',</span><span class="s3">\n            </span><span class="s1">prop</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError(</span><span class="s3">\n            </span><span class="s1">store.route,</span><span class="s3">\n            </span><span class="s1">expression</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return Reflect.has(target, prop)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ownKeys(target) {</span><span class="s3">\n      </span><span class="s1">if (store.dynamicShouldError) {</span><span class="s3">\n        </span><span class="s1">const expression =</span><span class="s3">\n          </span><span class="s1">'`{...searchParams}`, `Object.keys(searchParams)`, or similar'</span><span class="s3">\n        </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError(</span><span class="s3">\n          </span><span class="s1">store.route,</span><span class="s3">\n          </span><span class="s1">expression</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return Reflect.ownKeys(target)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// We don't use makeResolvedReactPromise here because searchParams</span><span class="s3">\n  </span><span class="s1">// supports copying with spread and we don't want to unnecessarily</span><span class="s3">\n  </span><span class="s1">// instrument the promise with spreadable properties of ReactPromise.</span><span class="s3">\n  </span><span class="s1">const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams)</span><span class="s3">\n  </span><span class="s1">promise.then(() =&gt; {</span><span class="s3">\n    </span><span class="s1">promiseInitialized = true</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">Object.keys(underlyingSearchParams).forEach((prop) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (wellKnownProperties.has(prop)) {</span><span class="s3">\n      </span><span class="s1">// These properties cannot be shadowed because they need to be the</span><span class="s3">\n      </span><span class="s1">// true underlying value for Promises to work correctly at runtime</span><span class="s3">\n      </span><span class="s1">unproxiedProperties.push(prop)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">proxiedProperties.add(prop)</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(promise, prop, {</span><span class="s3">\n        </span><span class="s1">get() {</span><span class="s3">\n          </span><span class="s1">return proxiedUnderlying[prop]</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">set(newValue) {</span><span class="s3">\n          </span><span class="s1">Object.defineProperty(promise, prop, {</span><span class="s3">\n            </span><span class="s1">value: newValue,</span><span class="s3">\n            </span><span class="s1">writable: true,</span><span class="s3">\n            </span><span class="s1">enumerable: true,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">enumerable: true,</span><span class="s3">\n        </span><span class="s1">configurable: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const proxiedPromise = new Proxy(promise, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">if (prop === 'then' &amp;&amp; store.dynamicShouldError) {</span><span class="s3">\n        </span><span class="s1">const expression = '`searchParams.then`'</span><span class="s3">\n        </span><span class="s1">throwWithStaticGenerationBailoutErrorWithDynamicError(</span><span class="s3">\n          </span><span class="s1">store.route,</span><span class="s3">\n          </span><span class="s1">expression</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!wellKnownProperties.has(prop) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(proxiedProperties.has(prop) ||</span><span class="s3">\n            </span><span class="s1">// We are accessing a property that doesn't exist on the promise nor</span><span class="s3">\n            </span><span class="s1">// the underlying searchParams.</span><span class="s3">\n            </span><span class="s1">Reflect.has(target, prop) === false)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const expression = describeStringPropertyAccess('searchParams', prop)</span><span class="s3">\n          </span><span class="s1">syncIODev(store.route, expression)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set(target, prop, value, receiver) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">proxiedProperties.delete(prop)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return Reflect.set(target, prop, value, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">has(target, prop) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!wellKnownProperties.has(prop) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(proxiedProperties.has(prop) ||</span><span class="s3">\n            </span><span class="s1">// We are accessing a property that doesn't exist on the promise nor</span><span class="s3">\n            </span><span class="s1">// the underlying searchParams.</span><span class="s3">\n            </span><span class="s1">Reflect.has(target, prop) === false)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const expression = describeHasCheckingStringProperty(</span><span class="s3">\n            </span><span class="s1">'searchParams',</span><span class="s3">\n            </span><span class="s1">prop</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">syncIODev(store.route, expression)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return Reflect.has(target, prop)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ownKeys(target) {</span><span class="s3">\n      </span><span class="s1">const expression = '`Object.keys(searchParams)` or similar'</span><span class="s3">\n      </span><span class="s1">syncIODev(store.route, expression, unproxiedProperties)</span><span class="s3">\n      </span><span class="s1">return Reflect.ownKeys(target)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">CachedSearchParams.set(underlyingSearchParams, proxiedPromise)</span><span class="s3">\n  </span><span class="s1">return proxiedPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but</span><span class="s3">\n</span><span class="s1">// just logging the sync access without actually defining the search params on</span><span class="s3">\n</span><span class="s1">// the promise.</span><span class="s3">\n</span><span class="s1">function makeUntrackedSearchParamsWithDevWarnings(</span><span class="s3">\n  </span><span class="s1">underlyingSearchParams: SearchParams,</span><span class="s3">\n  </span><span class="s1">store: WorkStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;SearchParams&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)</span><span class="s3">\n  </span><span class="s1">if (cachedSearchParams) {</span><span class="s3">\n    </span><span class="s1">return cachedSearchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const proxiedProperties = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">const unproxiedProperties: Array&lt;string&gt; = []</span><span class="s3">\n  </span><span class="s1">const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams)</span><span class="s3">\n\n  </span><span class="s1">Object.keys(underlyingSearchParams).forEach((prop) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (wellKnownProperties.has(prop)) {</span><span class="s3">\n      </span><span class="s1">// These properties cannot be shadowed because they need to be the</span><span class="s3">\n      </span><span class="s1">// true underlying value for Promises to work correctly at runtime</span><span class="s3">\n      </span><span class="s1">unproxiedProperties.push(prop)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">proxiedProperties.add(prop)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const proxiedPromise = new Proxy(promise, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!wellKnownProperties.has(prop) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(proxiedProperties.has(prop) ||</span><span class="s3">\n            </span><span class="s1">// We are accessing a property that doesn't exist on the promise nor</span><span class="s3">\n            </span><span class="s1">// the underlying searchParams.</span><span class="s3">\n            </span><span class="s1">Reflect.has(target, prop) === false)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const expression = describeStringPropertyAccess('searchParams', prop)</span><span class="s3">\n          </span><span class="s1">warnForSyncAccess(store.route, expression)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set(target, prop, value, receiver) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">proxiedProperties.delete(prop)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return Reflect.set(target, prop, value, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">has(target, prop) {</span><span class="s3">\n      </span><span class="s1">if (typeof prop === 'string') {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!wellKnownProperties.has(prop) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(proxiedProperties.has(prop) ||</span><span class="s3">\n            </span><span class="s1">// We are accessing a property that doesn't exist on the promise nor</span><span class="s3">\n            </span><span class="s1">// the underlying searchParams.</span><span class="s3">\n            </span><span class="s1">Reflect.has(target, prop) === false)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const expression = describeHasCheckingStringProperty(</span><span class="s3">\n            </span><span class="s1">'searchParams',</span><span class="s3">\n            </span><span class="s1">prop</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">warnForSyncAccess(store.route, expression)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return Reflect.has(target, prop)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ownKeys(target) {</span><span class="s3">\n      </span><span class="s1">const expression = '`Object.keys(searchParams)` or similar'</span><span class="s3">\n      </span><span class="s1">warnForIncompleteEnumeration(store.route, expression, unproxiedProperties)</span><span class="s3">\n      </span><span class="s1">return Reflect.ownKeys(target)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">CachedSearchParams.set(underlyingSearchParams, proxiedPromise)</span><span class="s3">\n  </span><span class="s1">return proxiedPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function syncIODev(</span><span class="s3">\n  </span><span class="s1">route: string | undefined,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">missingProperties?: Array&lt;string&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// In all cases we warn normally</span><span class="s3">\n  </span><span class="s1">if (missingProperties &amp;&amp; missingProperties.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">warnForIncompleteEnumeration(route, expression, missingProperties)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">warnForSyncAccess(route, expression)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">if (workUnitStore.prerenderPhase === true) {</span><span class="s3">\n          </span><span class="s1">// When we're rendering dynamically in dev, we need to advance out of</span><span class="s3">\n          </span><span class="s1">// the Prerender environment when we read Request data synchronously.</span><span class="s3">\n          </span><span class="s1">trackSynchronousRequestDataAccessInDev(workUnitStore)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(</span><span class="s3">\n  </span><span class="s1">createSearchAccessError</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">const warnForIncompleteEnumeration =</span><span class="s3">\n  </span><span class="s1">createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)</span><span class="s3">\n\n</span><span class="s1">function createSearchAccessError(</span><span class="s3">\n  </span><span class="s1">route: string | undefined,</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const prefix = route ? `Route </span><span class="s3">\&quot;</span><span class="s1">${route}</span><span class="s3">\&quot; </span><span class="s1">` : 'This route '</span><span class="s3">\n  </span><span class="s1">return new Error(</span><span class="s3">\n    </span><span class="s1">`${prefix}used ${expression}. ` +</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`searchParams</span><span class="s3">\\</span><span class="s1">` should be awaited before using its properties. ` +</span><span class="s3">\n      </span><span class="s1">`Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createIncompleteEnumerationError(</span><span class="s3">\n  </span><span class="s1">route: string | undefined,</span><span class="s3">\n  </span><span class="s1">expression: string,</span><span class="s3">\n  </span><span class="s1">missingProperties: Array&lt;string&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const prefix = route ? `Route </span><span class="s3">\&quot;</span><span class="s1">${route}</span><span class="s3">\&quot; </span><span class="s1">` : 'This route '</span><span class="s3">\n  </span><span class="s1">return new Error(</span><span class="s3">\n    </span><span class="s1">`${prefix}used ${expression}. ` +</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`searchParams</span><span class="s3">\\</span><span class="s1">` should be awaited before using its properties. ` +</span><span class="s3">\n      </span><span class="s1">`The following properties were not available through enumeration ` +</span><span class="s3">\n      </span><span class="s1">`because they conflict with builtin or well-known property names: ` +</span><span class="s3">\n      </span><span class="s1">`${describeListOfPropertyNames(missingProperties)}. ` +</span><span class="s3">\n      </span><span class="s1">`Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function describeListOfPropertyNames(properties: Array&lt;string&gt;) {</span><span class="s3">\n  </span><span class="s1">switch (properties.length) {</span><span class="s3">\n    </span><span class="s1">case 0:</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">case 1:</span><span class="s3">\n      </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">`${properties[0]}</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n    </span><span class="s1">case 2:</span><span class="s3">\n      </span><span class="s1">return `</span><span class="s3">\\</span><span class="s1">`${properties[0]}</span><span class="s3">\\</span><span class="s1">` and </span><span class="s3">\\</span><span class="s1">`${properties[1]}</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n    </span><span class="s1">default: {</span><span class="s3">\n      </span><span class="s1">let description = ''</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; properties.length - 1; i++) {</span><span class="s3">\n        </span><span class="s1">description += `</span><span class="s3">\\</span><span class="s1">`${properties[i]}</span><span class="s3">\\</span><span class="s1">`, `</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">description += `, and </span><span class="s3">\\</span><span class="s1">`${properties[properties.length - 1]}</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n      </span><span class="s1">return description</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createPrerenderSearchParamsForClientPage&quot;</span><span class="s0">,</span><span class="s1">&quot;createSearchParamsFromClient&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerSearchParamsForMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerSearchParamsForServerPage&quot;</span><span class="s0">,</span><span class="s1">&quot;makeErroringSearchParamsForUseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;underlyingSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;createStaticPrerenderSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;createRenderSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;throwInvariantForMissingStore&quot;</span><span class="s0">,</span><span class="s1">&quot;createRuntimePrerenderSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;forceStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;makeHangingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;renderSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;makeHangingSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;makeErroringExoticSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;delayUntilRuntimeStage&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CACHE_COMPONENTS&quot;</span><span class="s0">,</span><span class="s1">&quot;makeUntrackedSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;makeUntrackedExoticSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;makeUntrackedSearchParamsWithDevWarnings&quot;</span><span class="s0">,</span><span class="s1">&quot;makeDynamicallyTrackedExoticSearchParamsWithDevWarnings&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedSearchParamsForUseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;proxiedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;receiver&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwn&quot;</span><span class="s0">,</span><span class="s1">&quot;ReflectAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;annotateDynamicAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicShouldError&quot;</span><span class="s0">,</span><span class="s1">&quot;throwWithStaticGenerationBailoutErrorWithDynamicError&quot;</span><span class="s0">,</span><span class="s1">&quot;postponeWithTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;throwToInterruptStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;wellKnownProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;describeStringPropertyAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;describeHasCheckingStringProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ownKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;throwForSearchParamsAccessInUseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;trackDynamicDataInDynamicRender&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;store&quot;</span><span class="s0">,</span><span class="s1">&quot;proxiedProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;unproxiedProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;promiseInitialized&quot;</span><span class="s0">,</span><span class="s1">&quot;proxiedUnderlying&quot;</span><span class="s0">,</span><span class="s1">&quot;Reflect&quot;</span><span class="s0">,</span><span class="s1">&quot;makeDevtoolsIOAwarePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;newValue&quot;</span><span class="s0">,</span><span class="s1">&quot;syncIODev&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;warnForSyncAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;warnForIncompleteEnumeration&quot;</span><span class="s0">,</span><span class="s1">&quot;missingProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderPhase&quot;</span><span class="s0">,</span><span class="s1">&quot;trackSynchronousRequestDataAccessInDev&quot;</span><span class="s0">,</span><span class="s1">&quot;createDedupedByCallsiteServerErrorLoggerDev&quot;</span><span class="s0">,</span><span class="s1">&quot;createSearchAccessError&quot;</span><span class="s0">,</span><span class="s1">&quot;createIncompleteEnumerationError&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;describeListOfPropertyNames&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;description&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;IAsIgBA,wCAAwC;eAAxCA;;IAnEAC,4BAA4B;eAA5BA;;IAgCHC,mCAAmC;eAAnCA;;IAGGC,qCAAqC;eAArCA;;IAqXAC,mCAAmC;eAAnCA;;;yBAzde;kCAQxB;8CAUA;gCACwB;uCAIxB;0DACqD;8BAKrD;uBAIA;AAgCA,SAASH,6BACdI,sBAAoC,EACpCC,SAAoB;IAEpB,MAAMC,gBAAgBC,kDAAoB,CAACC,QAAQ;IACnD,IAAIF,eAAe;QACjB,OAAQA,cAAcG,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,OAAOC,kCAAkCL,WAAWC;YACtD,KAAK;gBACH,MAAM,qBAEL,CAFK,IAAIK,8BAAc,CACtB,8EADI,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAM,qBAEL,CAFK,IAAIA,8BAAc,CACtB,yEADI,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF,KAAK;gBACH,OAAOC,yBAAyBR,wBAAwBC;YAC1D;gBACEC;QACJ;IACF;IACAO,IAAAA,2DAA6B;AAC/B;AAGO,MAAMZ,sCACXC;AAEK,SAASA,sCACdE,sBAAoC,EACpCC,SAAoB;IAEpB,MAAMC,gBAAgBC,kDAAoB,CAACC,QAAQ;IACnD,IAAIF,eAAe;QACjB,OAAQA,cAAcG,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,OAAOC,kCAAkCL,WAAWC;YACtD,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAM,qBAEL,CAFK,IAAIK,8BAAc,CACtB,kFADI,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF,KAAK;gBACH,OAAOG,mCACLV,wBACAE;YAEJ,KAAK;gBACH,OAAOM,yBAAyBR,wBAAwBC;YAC1D;gBACEC;QACJ;IACF;IACAO,IAAAA,2DAA6B;AAC/B;AAEO,SAASd,yCACdM,SAAoB;IAEpB,IAAIA,UAAUU,WAAW,EAAE;QACzB,qFAAqF;QACrF,qBAAqB;QACrB,OAAOC,QAAQC,OAAO,CAAC,CAAC;IAC1B;IAEA,MAAMX,gBAAgBC,kDAAoB,CAACC,QAAQ;IACnD,IAAIF,eAAe;QACjB,OAAQA,cAAcG,IAAI;YACxB,KAAK;YACL,KAAK;gBACH,8EAA8E;gBAC9E,2DAA2D;gBAC3D,OAAOS,IAAAA,yCAAkB,EACvBZ,cAAca,YAAY,EAC1Bd,UAAUe,KAAK,EACf;YAEJ,KAAK;gBACH,MAAM,qBAEL,CAFK,IAAIT,8BAAc,CACtB,0FADI,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAM,qBAEL,CAFK,IAAIA,8BAAc,CACtB,qFADI,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF,KAAK;YACL,KAAK;YACL,KAAK;gBACH,OAAOK,QAAQC,OAAO,CAAC,CAAC;YAC1B;gBACEX;QACJ;IACF;IACAO,IAAAA,2DAA6B;AAC/B;AAEA,SAASH,kCACPL,SAAoB,EACpBgB,cAAoC;IAEpC,IAAIhB,UAAUU,WAAW,EAAE;QACzB,qFAAqF;QACrF,qBAAqB;QACrB,OAAOC,QAAQC,OAAO,CAAC,CAAC;IAC1B;IAEA,OAAQI,eAAeZ,IAAI;QACzB,KAAK;QACL,KAAK;YACH,2DAA2D;YAC3D,OAAOa,wBAAwBjB,WAAWgB;QAC5C,KAAK;QACL,KAAK;YACH,iEAAiE;YACjE,6CAA6C;YAC7C,OAAOE,+BAA+BlB,WAAWgB;QACnD;YACE,OAAOA;IACX;AACF;AAEA,SAASP,mCACPV,sBAAoC,EACpCE,aAA0C;IAE1C,OAAOkB,IAAAA,wCAAsB,EAC3BlB,eACAmB,QAAQC,GAAG,CAACC,uBAAuB,GAC/BC,0BAA0BxB,0BAC1ByB,gCAAgCzB;AAExC;AAEA,SAASQ,yBACPR,sBAAoC,EACpCC,SAAoB;IAEpB,IAAIA,UAAUU,WAAW,EAAE;QACzB,qFAAqF;QACrF,qBAAqB;QACrB,OAAOC,QAAQC,OAAO,CAAC,CAAC;IAC1B,OAAO;QACL,IAAIQ,QAAQC,GAAG,CAACI,QAAQ,KAAK,eAAe;YAC1C,wEAAwE;YACxE,8EAA8E;YAC9E,4EAA4E;YAC5E,IAAIL,QAAQC,GAAG,CAACC,uBAAuB,EAAE;gBACvC,OAAOI,yCACL3B,wBACAC;YAEJ;YAEA,OAAO2B,wDACL5B,wBACAC;QAEJ,OAAO;YACL,IAAIoB,QAAQC,GAAG,CAACC,uBAAuB,EAAE;gBACvC,OAAOC,0BAA0BxB;YACnC;YAEA,OAAOyB,gCAAgCzB;QACzC;IACF;AACF;AAGA,MAAM6B,qBAAqB,IAAIC;AAE/B,MAAMC,gCAAgC,IAAID;AAK1C,SAASZ,wBACPjB,SAAoB,EACpBgB,cAAoC;IAEpC,MAAMe,qBAAqBH,mBAAmBI,GAAG,CAAChB;IAClD,IAAIe,oBAAoB;QACtB,OAAOA;IACT;IAEA,MAAME,UAAUpB,IAAAA,yCAAkB,EAChCG,eAAeF,YAAY,EAC3Bd,UAAUe,KAAK,EACf;IAGF,MAAMmB,iBAAiB,IAAIC,MAAMF,SAAS;QACxCD,KAAII,MAAM,EAAEC,IAAI,EAAEC,QAAQ;YACxB,IAAIC,OAAOC,MAAM,CAACP,SAASI,OAAO;gBAChC,6DAA6D;gBAC7D,qEAAqE;gBACrE,0FAA0F;gBAC1F,OAAOI,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;YAC1C;YAEA,OAAQD;gBACN,KAAK;oBAAQ;wBACX,MAAMK,aACJ;wBACFC,IAAAA,uCAAqB,EAACD,YAAY1B;wBAClC,OAAOyB,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;oBAC1C;gBACA,KAAK;oBAAU;wBACb,MAAMI,aACJ;wBACFC,IAAAA,uCAAqB,EAACD,YAAY1B;wBAClC,OAAOyB,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;oBAC1C;gBAEA;oBAAS;wBACP,OAAOG,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;oBAC1C;YACF;QACF;IACF;IAEAV,mBAAmBgB,GAAG,CAAC5B,gBAAgBkB;IACvC,OAAOA;AACT;AAEA,SAAShB,+BACPlB,SAAoB,EACpBgB,cAAwD;IAExD,MAAMe,qBAAqBH,mBAAmBI,GAAG,CAAChC;IAClD,IAAI+B,oBAAoB;QACtB,OAAOA;IACT;IAEA,MAAMhC,yBAAyB,CAAC;IAChC,mFAAmF;IACnF,qFAAqF;IACrF,+DAA+D;IAC/D,MAAMkC,UAAUtB,QAAQC,OAAO,CAACb;IAEhC,MAAMmC,iBAAiB,IAAIC,MAAMF,SAAS;QACxCD,KAAII,MAAM,EAAEC,IAAI,EAAEC,QAAQ;YACxB,IAAIC,OAAOC,MAAM,CAACP,SAASI,OAAO;gBAChC,6DAA6D;gBAC7D,qEAAqE;gBACrE,0FAA0F;gBAC1F,OAAOI,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;YAC1C;YAEA,OAAQD;gBACN,KAAK;oBAAQ;wBACX,MAAMK,aACJ;wBACF,IAAI1C,UAAU6C,kBAAkB,EAAE;4BAChCC,IAAAA,4DAAqD,EACnD9C,UAAUe,KAAK,EACf2B;wBAEJ,OAAO,IAAI1B,eAAeZ,IAAI,KAAK,iBAAiB;4BAClD,qCAAqC;4BACrC2C,IAAAA,sCAAoB,EAClB/C,UAAUe,KAAK,EACf2B,YACA1B,eAAegC,eAAe;wBAElC,OAAO;4BACL,mBAAmB;4BACnBC,IAAAA,kDAAgC,EAC9BP,YACA1C,WACAgB;wBAEJ;wBACA;oBACF;gBACA,KAAK;oBAAU;wBACb,MAAM0B,aACJ;wBACF,IAAI1C,UAAU6C,kBAAkB,EAAE;4BAChCC,IAAAA,4DAAqD,EACnD9C,UAAUe,KAAK,EACf2B;wBAEJ,OAAO,IAAI1B,eAAeZ,IAAI,KAAK,iBAAiB;4BAClD,qCAAqC;4BACrC2C,IAAAA,sCAAoB,EAClB/C,UAAUe,KAAK,EACf2B,YACA1B,eAAegC,eAAe;wBAElC,OAAO;4BACL,mBAAmB;4BACnBC,IAAAA,kDAAgC,EAC9BP,YACA1C,WACAgB;wBAEJ;wBACA;oBACF;gBACA;oBAAS;wBACP,IAAI,OAAOqB,SAAS,YAAY,CAACa,iCAAmB,CAACC,GAAG,CAACd,OAAO;4BAC9D,MAAMK,aAAaU,IAAAA,0CAA4B,EAC7C,gBACAf;4BAEF,IAAIrC,UAAU6C,kBAAkB,EAAE;gCAChCC,IAAAA,4DAAqD,EACnD9C,UAAUe,KAAK,EACf2B;4BAEJ,OAAO,IAAI1B,eAAeZ,IAAI,KAAK,iBAAiB;gCAClD,qCAAqC;gCACrC2C,IAAAA,sCAAoB,EAClB/C,UAAUe,KAAK,EACf2B,YACA1B,eAAegC,eAAe;4BAElC,OAAO;gCACL,mBAAmB;gCACnBC,IAAAA,kDAAgC,EAC9BP,YACA1C,WACAgB;4BAEJ;wBACF;wBACA,OAAOyB,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;oBAC1C;YACF;QACF;QACAa,KAAIf,MAAM,EAAEC,IAAI;YACd,8EAA8E;YAC9E,wFAAwF;YACxF,8FAA8F;YAC9F,kEAAkE;YAClE,IAAI,OAAOA,SAAS,UAAU;gBAC5B,MAAMK,aAAaW,IAAAA,+CAAiC,EAClD,gBACAhB;gBAEF,IAAIrC,UAAU6C,kBAAkB,EAAE;oBAChCC,IAAAA,4DAAqD,EACnD9C,UAAUe,KAAK,EACf2B;gBAEJ,OAAO,IAAI1B,eAAeZ,IAAI,KAAK,iBAAiB;oBAClD,qCAAqC;oBACrC2C,IAAAA,sCAAoB,EAClB/C,UAAUe,KAAK,EACf2B,YACA1B,eAAegC,eAAe;gBAElC,OAAO;oBACL,mBAAmB;oBACnBC,IAAAA,kDAAgC,EAC9BP,YACA1C,WACAgB;gBAEJ;gBACA,OAAO;YACT;YACA,OAAOyB,uBAAc,CAACU,GAAG,CAACf,QAAQC;QACpC;QACAiB;YACE,MAAMZ,aACJ;YACF,IAAI1C,UAAU6C,kBAAkB,EAAE;gBAChCC,IAAAA,4DAAqD,EACnD9C,UAAUe,KAAK,EACf2B;YAEJ,OAAO,IAAI1B,eAAeZ,IAAI,KAAK,iBAAiB;gBAClD,qCAAqC;gBACrC2C,IAAAA,sCAAoB,EAClB/C,UAAUe,KAAK,EACf2B,YACA1B,eAAegC,eAAe;YAElC,OAAO;gBACL,mBAAmB;gBACnBC,IAAAA,kDAAgC,EAACP,YAAY1C,WAAWgB;YAC1D;QACF;IACF;IAEAY,mBAAmBgB,GAAG,CAAC5C,WAAWkC;IAClC,OAAOA;AACT;AAOO,SAASpC,oCACdE,SAAoB;IAEpB,MAAM+B,qBAAqBD,8BAA8BE,GAAG,CAAChC;IAC7D,IAAI+B,oBAAoB;QACtB,OAAOA;IACT;IAEA,MAAME,UAAUtB,QAAQC,OAAO,CAAC,CAAC;IAEjC,MAAMsB,iBAAiB,IAAIC,MAAMF,SAAS;QACxCD,KAAK,SAASA,IAAII,MAAM,EAAEC,IAAI,EAAEC,QAAQ;YACtC,IAAIC,OAAOC,MAAM,CAACP,SAASI,OAAO;gBAChC,wEAAwE;gBACxE,mEAAmE;gBACnE,+DAA+D;gBAC/D,oBAAoB;gBACpB,OAAOI,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;YAC1C;YAEA,IACE,OAAOD,SAAS,YACfA,CAAAA,SAAS,UAAU,CAACa,iCAAmB,CAACC,GAAG,CAACd,KAAI,GACjD;gBACAkB,IAAAA,2CAAoC,EAACvD,WAAWgC;YAClD;YAEA,OAAOS,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;QAC1C;QACAa,KAAK,SAASA,IAAIf,MAAM,EAAEC,IAAI;YAC5B,8EAA8E;YAC9E,uFAAuF;YACvF,8FAA8F;YAC9F,kEAAkE;YAClE,IACE,OAAOA,SAAS,YACfA,CAAAA,SAAS,UAAU,CAACa,iCAAmB,CAACC,GAAG,CAACd,KAAI,GACjD;gBACAkB,IAAAA,2CAAoC,EAACvD,WAAWmD;YAClD;YAEA,OAAOV,uBAAc,CAACU,GAAG,CAACf,QAAQC;QACpC;QACAiB,SAAS,SAASA;YAChBC,IAAAA,2CAAoC,EAACvD,WAAWsD;QAClD;IACF;IAEAxB,8BAA8Bc,GAAG,CAAC5C,WAAWkC;IAC7C,OAAOA;AACT;AAEA,SAASV,gCACPzB,sBAAoC;IAEpC,MAAMgC,qBAAqBH,mBAAmBI,GAAG,CAACjC;IAClD,IAAIgC,oBAAoB;QACtB,OAAOA;IACT;IAEA,kEAAkE;IAClE,kEAAkE;IAClE,qEAAqE;IACrE,MAAME,UAAUtB,QAAQC,OAAO,CAACb;IAChC6B,mBAAmBgB,GAAG,CAAC7C,wBAAwBkC;IAE/CM,OAAOiB,IAAI,CAACzD,wBAAwB0D,OAAO,CAAC,CAACpB;QAC3C,IAAI,CAACa,iCAAmB,CAACC,GAAG,CAACd,OAAO;YAClCE,OAAOmB,cAAc,CAACzB,SAASI,MAAM;gBACnCL;oBACE,MAAM/B,gBAAgBC,kDAAoB,CAACC,QAAQ;oBACnD,IAAIF,eAAe;wBACjB0D,IAAAA,iDAA+B,EAAC1D;oBAClC;oBACA,OAAOF,sBAAsB,CAACsC,KAAK;gBACrC;gBACAO,KAAIgB,KAAK;oBACPrB,OAAOmB,cAAc,CAACzB,SAASI,MAAM;wBACnCuB;wBACAC,UAAU;wBACVC,YAAY;oBACd;gBACF;gBACAA,YAAY;gBACZC,cAAc;YAChB;QACF;IACF;IAEA,OAAO9B;AACT;AAEA,SAASV,0BACPxB,sBAAoC;IAEpC,MAAMgC,qBAAqBH,mBAAmBI,GAAG,CAACjC;IAClD,IAAIgC,oBAAoB;QACtB,OAAOA;IACT;IAEA,MAAME,UAAUtB,QAAQC,OAAO,CAACb;IAChC6B,mBAAmBgB,GAAG,CAAC7C,wBAAwBkC;IAE/C,OAAOA;AACT;AAEA,SAASN,wDACP5B,sBAAoC,EACpCiE,KAAgB;IAEhB,MAAMjC,qBAAqBH,mBAAmBI,GAAG,CAACjC;IAClD,IAAIgC,oBAAoB;QACtB,OAAOA;IACT;IAEA,MAAMkC,oBAAoB,IAAIC;IAC9B,MAAMC,sBAAqC,EAAE;IAE7C,0HAA0H;IAC1H,uIAAuI;IACvI,wIAAwI;IACxI,8IAA8I;IAC9I,6IAA6I;IAC7I,+GAA+G;IAC/G,IAAIC,qBAAqB;IACzB,MAAMC,oBAAoB,IAAIlC,MAAMpC,wBAAwB;QAC1DiC,KAAII,MAAM,EAAEC,IAAI,EAAEC,QAAQ;YACxB,IAAI,OAAOD,SAAS,YAAY+B,oBAAoB;gBAClD,IAAIJ,MAAMnB,kBAAkB,EAAE;oBAC5B,MAAMH,aAAaU,IAAAA,0CAA4B,EAAC,gBAAgBf;oBAChES,IAAAA,4DAAqD,EACnDkB,MAAMjD,KAAK,EACX2B;gBAEJ;gBACA,MAAMzC,gBAAgBC,kDAAoB,CAACC,QAAQ;gBACnD,IAAIF,eAAe;oBACjB0D,IAAAA,iDAA+B,EAAC1D;gBAClC;YACF;YACA,OAAOwC,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;QAC1C;QACAa,KAAIf,MAAM,EAAEC,IAAI;YACd,IAAI,OAAOA,SAAS,UAAU;gBAC5B,IAAI2B,MAAMnB,kBAAkB,EAAE;oBAC5B,MAAMH,aAAaW,IAAAA,+CAAiC,EAClD,gBACAhB;oBAEFS,IAAAA,4DAAqD,EACnDkB,MAAMjD,KAAK,EACX2B;gBAEJ;YACF;YACA,OAAO4B,QAAQnB,GAAG,CAACf,QAAQC;QAC7B;QACAiB,SAAQlB,MAAM;YACZ,IAAI4B,MAAMnB,kBAAkB,EAAE;gBAC5B,MAAMH,aACJ;gBACFI,IAAAA,4DAAqD,EACnDkB,MAAMjD,KAAK,EACX2B;YAEJ;YACA,OAAO4B,QAAQhB,OAAO,CAAClB;QACzB;IACF;IAEA,kEAAkE;IAClE,kEAAkE;IAClE,qEAAqE;IACrE,MAAMH,UAAUsC,IAAAA,iDAA0B,EAACxE;IAC3CkC,QAAQuC,IAAI,CAAC;QACXJ,qBAAqB;IACvB;IAEA7B,OAAOiB,IAAI,CAACzD,wBAAwB0D,OAAO,CAAC,CAACpB;QAC3C,IAAIa,iCAAmB,CAACC,GAAG,CAACd,OAAO;YACjC,kEAAkE;YAClE,kEAAkE;YAClE8B,oBAAoBM,IAAI,CAACpC;QAC3B,OAAO;YACL4B,kBAAkBS,GAAG,CAACrC;YACtBE,OAAOmB,cAAc,CAACzB,SAASI,MAAM;gBACnCL;oBACE,OAAOqC,iBAAiB,CAAChC,KAAK;gBAChC;gBACAO,KAAI+B,QAAQ;oBACVpC,OAAOmB,cAAc,CAACzB,SAASI,MAAM;wBACnCuB,OAAOe;wBACPd,UAAU;wBACVC,YAAY;oBACd;gBACF;gBACAA,YAAY;gBACZC,cAAc;YAChB;QACF;IACF;IAEA,MAAM7B,iBAAiB,IAAIC,MAAMF,SAAS;QACxCD,KAAII,MAAM,EAAEC,IAAI,EAAEC,QAAQ;YACxB,IAAID,SAAS,UAAU2B,MAAMnB,kBAAkB,EAAE;gBAC/C,MAAMH,aAAa;gBACnBI,IAAAA,4DAAqD,EACnDkB,MAAMjD,KAAK,EACX2B;YAEJ;YACA,IAAI,OAAOL,SAAS,UAAU;gBAC5B,IACE,CAACa,iCAAmB,CAACC,GAAG,CAACd,SACxB4B,CAAAA,kBAAkBd,GAAG,CAACd,SACrB,oEAAoE;gBACpE,+BAA+B;gBAC/BiC,QAAQnB,GAAG,CAACf,QAAQC,UAAU,KAAI,GACpC;oBACA,MAAMK,aAAaU,IAAAA,0CAA4B,EAAC,gBAAgBf;oBAChEuC,UAAUZ,MAAMjD,KAAK,EAAE2B;gBACzB;YACF;YACA,OAAOD,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;QAC1C;QACAM,KAAIR,MAAM,EAAEC,IAAI,EAAEuB,KAAK,EAAEtB,QAAQ;YAC/B,IAAI,OAAOD,SAAS,UAAU;gBAC5B4B,kBAAkBY,MAAM,CAACxC;YAC3B;YACA,OAAOiC,QAAQ1B,GAAG,CAACR,QAAQC,MAAMuB,OAAOtB;QAC1C;QACAa,KAAIf,MAAM,EAAEC,IAAI;YACd,IAAI,OAAOA,SAAS,UAAU;gBAC5B,IACE,CAACa,iCAAmB,CAACC,GAAG,CAACd,SACxB4B,CAAAA,kBAAkBd,GAAG,CAACd,SACrB,oEAAoE;gBACpE,+BAA+B;gBAC/BiC,QAAQnB,GAAG,CAACf,QAAQC,UAAU,KAAI,GACpC;oBACA,MAAMK,aAAaW,IAAAA,+CAAiC,EAClD,gBACAhB;oBAEFuC,UAAUZ,MAAMjD,KAAK,EAAE2B;gBACzB;YACF;YACA,OAAO4B,QAAQnB,GAAG,CAACf,QAAQC;QAC7B;QACAiB,SAAQlB,MAAM;YACZ,MAAMM,aAAa;YACnBkC,UAAUZ,MAAMjD,KAAK,EAAE2B,YAAYyB;YACnC,OAAOG,QAAQhB,OAAO,CAAClB;QACzB;IACF;IAEAR,mBAAmBgB,GAAG,CAAC7C,wBAAwBmC;IAC/C,OAAOA;AACT;AAEA,4EAA4E;AAC5E,8EAA8E;AAC9E,eAAe;AACf,SAASR,yCACP3B,sBAAoC,EACpCiE,KAAgB;IAEhB,MAAMjC,qBAAqBH,mBAAmBI,GAAG,CAACjC;IAClD,IAAIgC,oBAAoB;QACtB,OAAOA;IACT;IAEA,MAAMkC,oBAAoB,IAAIC;IAC9B,MAAMC,sBAAqC,EAAE;IAC7C,MAAMlC,UAAUsC,IAAAA,iDAA0B,EAACxE;IAE3CwC,OAAOiB,IAAI,CAACzD,wBAAwB0D,OAAO,CAAC,CAACpB;QAC3C,IAAIa,iCAAmB,CAACC,GAAG,CAACd,OAAO;YACjC,kEAAkE;YAClE,kEAAkE;YAClE8B,oBAAoBM,IAAI,CAACpC;QAC3B,OAAO;YACL4B,kBAAkBS,GAAG,CAACrC;QACxB;IACF;IAEA,MAAMH,iBAAiB,IAAIC,MAAMF,SAAS;QACxCD,KAAII,MAAM,EAAEC,IAAI,EAAEC,QAAQ;YACxB,IAAI,OAAOD,SAAS,UAAU;gBAC5B,IACE,CAACa,iCAAmB,CAACC,GAAG,CAACd,SACxB4B,CAAAA,kBAAkBd,GAAG,CAACd,SACrB,oEAAoE;gBACpE,+BAA+B;gBAC/BiC,QAAQnB,GAAG,CAACf,QAAQC,UAAU,KAAI,GACpC;oBACA,MAAMK,aAAaU,IAAAA,0CAA4B,EAAC,gBAAgBf;oBAChEyC,kBAAkBd,MAAMjD,KAAK,EAAE2B;gBACjC;YACF;YACA,OAAOD,uBAAc,CAACT,GAAG,CAACI,QAAQC,MAAMC;QAC1C;QACAM,KAAIR,MAAM,EAAEC,IAAI,EAAEuB,KAAK,EAAEtB,QAAQ;YAC/B,IAAI,OAAOD,SAAS,UAAU;gBAC5B4B,kBAAkBY,MAAM,CAACxC;YAC3B;YACA,OAAOiC,QAAQ1B,GAAG,CAACR,QAAQC,MAAMuB,OAAOtB;QAC1C;QACAa,KAAIf,MAAM,EAAEC,IAAI;YACd,IAAI,OAAOA,SAAS,UAAU;gBAC5B,IACE,CAACa,iCAAmB,CAACC,GAAG,CAACd,SACxB4B,CAAAA,kBAAkBd,GAAG,CAACd,SACrB,oEAAoE;gBACpE,+BAA+B;gBAC/BiC,QAAQnB,GAAG,CAACf,QAAQC,UAAU,KAAI,GACpC;oBACA,MAAMK,aAAaW,IAAAA,+CAAiC,EAClD,gBACAhB;oBAEFyC,kBAAkBd,MAAMjD,KAAK,EAAE2B;gBACjC;YACF;YACA,OAAO4B,QAAQnB,GAAG,CAACf,QAAQC;QAC7B;QACAiB,SAAQlB,MAAM;YACZ,MAAMM,aAAa;YACnBqC,6BAA6Bf,MAAMjD,KAAK,EAAE2B,YAAYyB;YACtD,OAAOG,QAAQhB,OAAO,CAAClB;QACzB;IACF;IAEAR,mBAAmBgB,GAAG,CAAC7C,wBAAwBmC;IAC/C,OAAOA;AACT;AAEA,SAAS0C,UACP7D,KAAyB,EACzB2B,UAAkB,EAClBsC,iBAAiC;IAEjC,gCAAgC;IAChC,IAAIA,qBAAqBA,kBAAkBC,MAAM,GAAG,GAAG;QACrDF,6BAA6BhE,OAAO2B,YAAYsC;IAClD,OAAO;QACLF,kBAAkB/D,OAAO2B;IAC3B;IAEA,MAAMzC,gBAAgBC,kDAAoB,CAACC,QAAQ;IACnD,IAAIF,eAAe;QACjB,OAAQA,cAAcG,IAAI;YACxB,KAAK;gBACH,IAAIH,cAAciF,cAAc,KAAK,MAAM;oBACzC,qEAAqE;oBACrE,qEAAqE;oBACrEC,IAAAA,wDAAsC,EAAClF;gBACzC;gBACA;YACF,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEA;QACJ;IACF;AACF;AAEA,MAAM6E,oBAAoBM,IAAAA,qFAA2C,EACnEC;AAGF,MAAMN,+BACJK,IAAAA,qFAA2C,EAACE;AAE9C,SAASD,wBACPtE,KAAyB,EACzB2B,UAAkB;IAElB,MAAM6C,SAASxE,QAAQ,CAAC,OAAO,EAAEA,MAAM,EAAE,CAAC,GAAG;IAC7C,OAAO,qBAIN,CAJM,IAAIyE,MACT,GAAGD,OAAO,KAAK,EAAE7C,WAAW,EAAE,CAAC,GAC7B,CAAC,gEAAgE,CAAC,GAClE,CAAC,8DAA8D,CAAC,GAH7D,qBAAA;eAAA;oBAAA;sBAAA;IAIP;AACF;AAEA,SAAS4C,iCACPvE,KAAyB,EACzB2B,UAAkB,EAClBsC,iBAAgC;IAEhC,MAAMO,SAASxE,QAAQ,CAAC,OAAO,EAAEA,MAAM,EAAE,CAAC,GAAG;IAC7C,OAAO,qBAON,CAPM,IAAIyE,MACT,GAAGD,OAAO,KAAK,EAAE7C,WAAW,EAAE,CAAC,GAC7B,CAAC,gEAAgE,CAAC,GAClE,CAAC,gEAAgE,CAAC,GAClE,CAAC,iEAAiE,CAAC,GACnE,GAAG+C,4BAA4BT,mBAAmB,EAAE,CAAC,GACrD,CAAC,8DAA8D,CAAC,GAN7D,qBAAA;eAAA;oBAAA;sBAAA;IAOP;AACF;AAEA,SAASS,4BAA4BC,UAAyB;IAC5D,OAAQA,WAAWT,MAAM;QACvB,KAAK;YACH,MAAM,qBAEL,CAFK,IAAI3E,8BAAc,CACtB,wFADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF,KAAK;YACH,OAAO,CAAC,EAAE,EAAEoF,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC;QAC/B,KAAK;YACH,OAAO,CAAC,EAAE,EAAEA,UAAU,CAAC,EAAE,CAAC,SAAS,EAAEA,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC;QACxD;YAAS;gBACP,IAAIC,cAAc;gBAClB,IAAK,IAAIC,IAAI,GAAGA,IAAIF,WAAWT,MAAM,GAAG,GAAGW,IAAK;oBAC9CD,eAAe,CAAC,EAAE,EAAED,UAAU,CAACE,EAAE,CAAC,IAAI,CAAC;gBACzC;gBACAD,eAAe,CAAC,QAAQ,EAAED,UAAU,CAACA,WAAWT,MAAM,GAAG,EAAE,CAAC,EAAE,CAAC;gBAC/D,OAAOU;YACT;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>