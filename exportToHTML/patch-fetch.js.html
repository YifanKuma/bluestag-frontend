<html>
<head>
<title>patch-fetch.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
patch-fetch.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">NEXT_PATCH_SYMBOL: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createPatchedFetcher: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">patchFetch: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">validateRevalidate: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">validateTags: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">NEXT_PATCH_SYMBOL: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">NEXT_PATCH_SYMBOL;</span>
    <span class="s1">},</span>
    <span class="s1">createPatchedFetcher: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createPatchedFetcher;</span>
    <span class="s1">},</span>
    <span class="s1">patchFetch: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">patchFetch;</span>
    <span class="s1">},</span>
    <span class="s1">validateRevalidate: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">validateRevalidate;</span>
    <span class="s1">},</span>
    <span class="s1">validateTags: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">validateTags;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;./trace/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_tracer = require(</span><span class="s0">&quot;./trace/tracer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrendering = require(</span><span class="s0">&quot;../app-render/dynamic-rendering&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrenderingutils = require(</span><span class="s0">&quot;../dynamic-rendering-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dedupefetch = require(</span><span class="s0">&quot;./dedupe-fetch&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_responsecache = require(</span><span class="s0">&quot;../response-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_scheduler = require(</span><span class="s0">&quot;../../lib/scheduler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_cloneresponse = require(</span><span class="s0">&quot;./clone-response&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">isEdgeRuntime = process.env.NEXT_RUNTIME === </span><span class="s0">'edge'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">NEXT_PATCH_SYMBOL = Symbol.for(</span><span class="s0">'next-patch'</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">isFetchPatched() {</span>
    <span class="s2">return </span><span class="s1">globalThis[NEXT_PATCH_SYMBOL] === </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validateRevalidate(revalidateVal, route) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">let </span><span class="s1">normalizedRevalidate = undefined;</span>
        <span class="s2">if </span><span class="s1">(revalidateVal === </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s1">normalizedRevalidate = _constants1.INFINITE_CACHE;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">revalidateVal === </span><span class="s0">'number' </span><span class="s1">&amp;&amp; !isNaN(revalidateVal) &amp;&amp; revalidateVal &gt; -</span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s1">normalizedRevalidate = revalidateVal;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">revalidateVal !== </span><span class="s0">'undefined'</span><span class="s1">) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invalid revalidate value &quot;</span><span class="s1">${revalidateVal}</span><span class="s0">&quot; on &quot;</span><span class="s1">${route}</span><span class="s0">&quot;, must be a non-negative number or false`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E179&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">normalizedRevalidate;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s4">// handle client component error from attempting to check revalidate value</span>
        <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">Error &amp;&amp; err.message.includes(</span><span class="s0">'Invalid revalidate'</span><span class="s1">)) {</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validateTags(tags, description) {</span>
    <span class="s2">const </span><span class="s1">validTags = [];</span>
    <span class="s2">const </span><span class="s1">invalidTags = [];</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; tags.length; i++){</span>
        <span class="s2">const </span><span class="s1">tag = tags[i];</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">tag !== </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s1">invalidTags.push({</span>
                <span class="s1">tag,</span>
                <span class="s1">reason: </span><span class="s0">'invalid type, must be a string'</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tag.length &gt; _constants1.NEXT_CACHE_TAG_MAX_LENGTH) {</span>
            <span class="s1">invalidTags.push({</span>
                <span class="s1">tag,</span>
                <span class="s1">reason: </span><span class="s0">`exceeded max length of </span><span class="s1">${_constants1.NEXT_CACHE_TAG_MAX_LENGTH}</span><span class="s0">`</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">validTags.push(tag);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(validTags.length &gt; _constants1.NEXT_CACHE_TAG_MAX_ITEMS) {</span>
            <span class="s1">console.warn(</span><span class="s0">`Warning: exceeded max tag count for </span><span class="s1">${description}</span><span class="s0">, dropped tags:`</span><span class="s1">, tags.slice(i).join(</span><span class="s0">', '</span><span class="s1">));</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(invalidTags.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s1">console.warn(</span><span class="s0">`Warning: invalid tags passed to </span><span class="s1">${description}</span><span class="s0">: `</span><span class="s1">);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ tag, reason } of invalidTags){</span>
            <span class="s1">console.log(</span><span class="s0">`tag: &quot;</span><span class="s1">${tag}</span><span class="s0">&quot; </span><span class="s1">${reason}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">validTags;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">trackFetchMetric(workStore, ctx) {</span>
    <span class="s2">if </span><span class="s1">(!workStore.shouldTrackFetchMetrics) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">workStore.fetchMetrics ??= [];</span>
    <span class="s1">workStore.fetchMetrics.push({</span>
        <span class="s1">...ctx,</span>
        <span class="s1">end: performance.timeOrigin + performance.now(),</span>
        <span class="s1">idx: workStore.nextFetchId || </span><span class="s3">0</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createCachedPrerenderResponse(res, cacheKey, incrementalCacheContext, incrementalCache, revalidate, handleUnlock) {</span>
    <span class="s4">// We are prerendering at build time or revalidate time with cacheComponents so we</span>
    <span class="s4">// need to buffer the response so we can guarantee it can be read in a</span>
    <span class="s4">// microtask.</span>
    <span class="s2">const </span><span class="s1">bodyBuffer = </span><span class="s2">await </span><span class="s1">res.arrayBuffer();</span>
    <span class="s2">const </span><span class="s1">fetchedData = {</span>
        <span class="s1">headers: Object.fromEntries(res.headers.entries()),</span>
        <span class="s1">body: Buffer.from(bodyBuffer).toString(</span><span class="s0">'base64'</span><span class="s1">),</span>
        <span class="s1">status: res.status,</span>
        <span class="s1">url: res.url</span>
    <span class="s1">};</span>
    <span class="s4">// We can skip setting the serverComponentsHmrCache because we aren't in dev</span>
    <span class="s4">// mode.</span>
    <span class="s2">if </span><span class="s1">(incrementalCacheContext) {</span>
        <span class="s2">await </span><span class="s1">incrementalCache.set(cacheKey, {</span>
            <span class="s1">kind: _responsecache.CachedRouteKind.FETCH,</span>
            <span class="s1">data: fetchedData,</span>
            <span class="s1">revalidate</span>
        <span class="s1">}, incrementalCacheContext);</span>
    <span class="s1">}</span>
    <span class="s2">await </span><span class="s1">handleUnlock();</span>
    <span class="s4">// We return a new Response to the caller.</span>
    <span class="s2">return new </span><span class="s1">Response(bodyBuffer, {</span>
        <span class="s1">headers: res.headers,</span>
        <span class="s1">status: res.status,</span>
        <span class="s1">statusText: res.statusText</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createCachedDynamicResponse(workStore, res, cacheKey, incrementalCacheContext, incrementalCache, serverComponentsHmrCache, revalidate, input, handleUnlock) {</span>
    <span class="s4">// We're cloning the response using this utility because there exists a bug in</span>
    <span class="s4">// the undici library around response cloning. See the following pull request</span>
    <span class="s4">// for more details: https://github.com/vercel/next.js/pull/73274</span>
    <span class="s2">const </span><span class="s1">[cloned1, cloned2] = (</span><span class="s3">0</span><span class="s1">, _cloneresponse.cloneResponse)(res);</span>
    <span class="s4">// We are dynamically rendering including dev mode. We want to return the</span>
    <span class="s4">// response to the caller as soon as possible because it might stream over a</span>
    <span class="s4">// very long time.</span>
    <span class="s2">const </span><span class="s1">cacheSetPromise = cloned1.arrayBuffer().then(async (arrayBuffer)=&gt;{</span>
        <span class="s2">const </span><span class="s1">bodyBuffer = Buffer.from(arrayBuffer);</span>
        <span class="s2">const </span><span class="s1">fetchedData = {</span>
            <span class="s1">headers: Object.fromEntries(cloned1.headers.entries()),</span>
            <span class="s1">body: bodyBuffer.toString(</span><span class="s0">'base64'</span><span class="s1">),</span>
            <span class="s1">status: cloned1.status,</span>
            <span class="s1">url: cloned1.url</span>
        <span class="s1">};</span>
        <span class="s1">serverComponentsHmrCache == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: serverComponentsHmrCache.set(cacheKey, fetchedData);</span>
        <span class="s2">if </span><span class="s1">(incrementalCacheContext) {</span>
            <span class="s2">await </span><span class="s1">incrementalCache.set(cacheKey, {</span>
                <span class="s1">kind: _responsecache.CachedRouteKind.FETCH,</span>
                <span class="s1">data: fetchedData,</span>
                <span class="s1">revalidate</span>
            <span class="s1">}, incrementalCacheContext);</span>
        <span class="s1">}</span>
    <span class="s1">}).catch((error)=&gt;console.warn(</span><span class="s0">`Failed to set fetch cache`</span><span class="s1">, input, error)).finally(handleUnlock);</span>
    <span class="s2">const </span><span class="s1">pendingRevalidateKey = </span><span class="s0">`cache-set-</span><span class="s1">${cacheKey}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">workStore.pendingRevalidates ??= {};</span>
    <span class="s2">if </span><span class="s1">(pendingRevalidateKey </span><span class="s2">in </span><span class="s1">workStore.pendingRevalidates) {</span>
        <span class="s4">// there is already a pending revalidate entry that we need to await to</span>
        <span class="s4">// avoid race conditions</span>
        <span class="s2">await </span><span class="s1">workStore.pendingRevalidates[pendingRevalidateKey];</span>
    <span class="s1">}</span>
    <span class="s1">workStore.pendingRevalidates[pendingRevalidateKey] = cacheSetPromise.finally(()=&gt;{</span>
        <span class="s2">var </span><span class="s1">_workStore_pendingRevalidates;</span>
        <span class="s4">// If the pending revalidate is not present in the store, then we have</span>
        <span class="s4">// nothing to delete.</span>
        <span class="s2">if </span><span class="s1">(!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _workStore_pendingRevalidates[pendingRevalidateKey])) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">delete </span><span class="s1">workStore.pendingRevalidates[pendingRevalidateKey];</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">cloned2;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPatchedFetcher(originFetch, { workAsyncStorage, workUnitAsyncStorage }) {</span>
    <span class="s4">// Create the patched fetch function.</span>
    <span class="s2">const </span><span class="s1">patched = async </span><span class="s2">function </span><span class="s1">fetch(input, init) {</span>
        <span class="s2">var </span><span class="s1">_init_method, _init_next;</span>
        <span class="s2">let </span><span class="s1">url;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">url = </span><span class="s2">new </span><span class="s1">URL(input </span><span class="s2">instanceof </span><span class="s1">Request ? input.url : input);</span>
            <span class="s1">url.username = </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s1">url.password = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
            <span class="s4">// Error caused by malformed URL should be handled by native fetch</span>
            <span class="s1">url = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">fetchUrl = (url == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: url.href) ?? </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">method = (init == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_init_method = init.method) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _init_method.toUpperCase()) || </span><span class="s0">'GET'</span><span class="s1">;</span>
        <span class="s4">// Do create a new span trace for internal fetches in the</span>
        <span class="s4">// non-verbose mode.</span>
        <span class="s2">const </span><span class="s1">isInternal = (init == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_init_next = init.next) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _init_next.internal) === </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === </span><span class="s0">'1'</span><span class="s1">;</span>
        <span class="s4">// We don't track fetch metrics for internal fetches</span>
        <span class="s4">// so it's not critical that we have a start time, as it won't be recorded.</span>
        <span class="s4">// This is to workaround a flaky issue where performance APIs might</span>
        <span class="s4">// not be available and will require follow-up investigation.</span>
        <span class="s2">const </span><span class="s1">fetchStart = isInternal ? undefined : performance.timeOrigin + performance.now();</span>
        <span class="s2">const </span><span class="s1">workStore = workAsyncStorage.getStore();</span>
        <span class="s2">const </span><span class="s1">workUnitStore = workUnitAsyncStorage.getStore();</span>
        <span class="s4">// During static generation we track cache reads so we can reason about when they fill</span>
        <span class="s2">let </span><span class="s1">cacheSignal = workUnitStore ? (</span><span class="s3">0</span><span class="s1">, _workunitasyncstorageexternal.getCacheSignal)(workUnitStore) : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
            <span class="s1">cacheSignal.beginRead();</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">result = (</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(isInternal ? _constants.NextNodeServerSpan.internalFetch : _constants.AppRenderSpan.fetch, {</span>
            <span class="s1">hideSpan,</span>
            <span class="s1">kind: _tracer.SpanKind.CLIENT,</span>
            <span class="s1">spanName: [</span>
                <span class="s0">'fetch'</span><span class="s1">,</span>
                <span class="s1">method,</span>
                <span class="s1">fetchUrl</span>
            <span class="s1">].filter(Boolean).join(</span><span class="s0">' '</span><span class="s1">),</span>
            <span class="s1">attributes: {</span>
                <span class="s0">'http.url'</span><span class="s1">: fetchUrl,</span>
                <span class="s0">'http.method'</span><span class="s1">: method,</span>
                <span class="s0">'net.peer.name'</span><span class="s1">: url == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: url.hostname,</span>
                <span class="s0">'net.peer.port'</span><span class="s1">: (url == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: url.port) || undefined</span>
            <span class="s1">}</span>
        <span class="s1">}, async ()=&gt;{</span>
            <span class="s2">var </span><span class="s1">_getRequestMeta;</span>
            <span class="s4">// If this is an internal fetch, we should not do any special treatment.</span>
            <span class="s2">if </span><span class="s1">(isInternal) {</span>
                <span class="s2">return </span><span class="s1">originFetch(input, init);</span>
            <span class="s1">}</span>
            <span class="s4">// If the workStore is not available, we can't do any</span>
            <span class="s4">// special treatment of fetch, therefore fallback to the original</span>
            <span class="s4">// fetch implementation.</span>
            <span class="s2">if </span><span class="s1">(!workStore) {</span>
                <span class="s2">return </span><span class="s1">originFetch(input, init);</span>
            <span class="s1">}</span>
            <span class="s4">// We should also fallback to the original fetch implementation if we</span>
            <span class="s4">// are in draft mode, it does not constitute a static generation.</span>
            <span class="s2">if </span><span class="s1">(workStore.isDraftMode) {</span>
                <span class="s2">return </span><span class="s1">originFetch(input, init);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">isRequestInput = input &amp;&amp; </span><span class="s2">typeof </span><span class="s1">input === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">input.method === </span><span class="s0">'string'</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">getRequestMeta = (field)=&gt;{</span>
                <span class="s4">// If request input is present but init is not, retrieve from input first.</span>
                <span class="s2">const </span><span class="s1">value = init == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: init[field];</span>
                <span class="s2">return </span><span class="s1">value || (isRequestInput ? input[field] : </span><span class="s2">null</span><span class="s1">);</span>
            <span class="s1">};</span>
            <span class="s2">let </span><span class="s1">finalRevalidate = undefined;</span>
            <span class="s2">const </span><span class="s1">getNextField = (field)=&gt;{</span>
                <span class="s2">var </span><span class="s1">_init_next, _init_next1, _input_next;</span>
                <span class="s2">return typeof </span><span class="s1">(init == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_init_next = init.next) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _init_next[field]) !== </span><span class="s0">'undefined' </span><span class="s1">? init == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_init_next1 = init.next) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _init_next1[field] : isRequestInput ? (_input_next = input.next) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _input_next[field] : undefined;</span>
            <span class="s1">};</span>
            <span class="s4">// RequestInit doesn't keep extra fields e.g. next so it's</span>
            <span class="s4">// only available if init is used separate</span>
            <span class="s2">const </span><span class="s1">originalFetchRevalidate = getNextField(</span><span class="s0">'revalidate'</span><span class="s1">);</span>
            <span class="s2">let </span><span class="s1">currentFetchRevalidate = originalFetchRevalidate;</span>
            <span class="s2">const </span><span class="s1">tags = validateTags(getNextField(</span><span class="s0">'tags'</span><span class="s1">) || [], </span><span class="s0">`fetch </span><span class="s1">${input.toString()}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s2">let </span><span class="s1">revalidateStore;</span>
            <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                    <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                    <span class="s4">// TODO: Stop accumulating tags in client prerender. (fallthrough)</span>
                    <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                        <span class="s1">revalidateStore = workUnitStore;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s1">workUnitStore;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(revalidateStore) {</span>
                <span class="s2">if </span><span class="s1">(Array.isArray(tags)) {</span>
                    <span class="s4">// Collect tags onto parent caches or parent prerenders.</span>
                    <span class="s2">const </span><span class="s1">collectedTags = revalidateStore.tags ?? (revalidateStore.tags = []);</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">tag of tags){</span>
                        <span class="s2">if </span><span class="s1">(!collectedTags.includes(tag)) {</span>
                            <span class="s1">collectedTags.push(tag);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">implicitTags = workUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: workUnitStore.implicitTags;</span>
            <span class="s2">let </span><span class="s1">pageFetchCacheMode = workStore.fetchCache;</span>
            <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                    <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                        <span class="s4">// Inside unstable-cache we treat it the same as force-no-store on</span>
                        <span class="s4">// the page.</span>
                        <span class="s1">pageFetchCacheMode = </span><span class="s0">'force-no-store'</span><span class="s1">;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s1">workUnitStore;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">isUsingNoStore = !!workStore.isUnstableNoStore;</span>
            <span class="s2">let </span><span class="s1">currentFetchCacheConfig = getRequestMeta(</span><span class="s0">'cache'</span><span class="s1">);</span>
            <span class="s2">let </span><span class="s1">cacheReason = </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">cacheWarning;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">currentFetchCacheConfig === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">currentFetchRevalidate !== </span><span class="s0">'undefined'</span><span class="s1">) {</span>
                <span class="s4">// If the revalidate value conflicts with the cache value, we should warn the user and unset the conflicting values.</span>
                <span class="s2">const </span><span class="s1">isConflictingRevalidate = </span><span class="s4">// revalidate: 0 and cache: force-cache</span>
                <span class="s1">currentFetchCacheConfig === </span><span class="s0">'force-cache' </span><span class="s1">&amp;&amp; currentFetchRevalidate === </span><span class="s3">0 </span><span class="s1">|| </span><span class="s4">// revalidate: &gt;0 or revalidate: false and cache: no-store</span>
                <span class="s1">currentFetchCacheConfig === </span><span class="s0">'no-store' </span><span class="s1">&amp;&amp; (currentFetchRevalidate &gt; </span><span class="s3">0 </span><span class="s1">|| currentFetchRevalidate === </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(isConflictingRevalidate) {</span>
                    <span class="s1">cacheWarning = </span><span class="s0">`Specified &quot;cache: </span><span class="s1">${currentFetchCacheConfig}</span><span class="s0">&quot; and &quot;revalidate: </span><span class="s1">${currentFetchRevalidate}</span><span class="s0">&quot;, only one should be specified.`</span><span class="s1">;</span>
                    <span class="s1">currentFetchCacheConfig = undefined;</span>
                    <span class="s1">currentFetchRevalidate = undefined;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">hasExplicitFetchCacheOptOut = </span><span class="s4">// fetch config itself signals not to cache</span>
            <span class="s1">currentFetchCacheConfig === </span><span class="s0">'no-cache' </span><span class="s1">|| currentFetchCacheConfig === </span><span class="s0">'no-store' </span><span class="s1">|| </span><span class="s4">// the fetch isn't explicitly caching and the segment level cache config signals not to cache</span>
            <span class="s4">// note: `pageFetchCacheMode` is also set by being in an unstable_cache context.</span>
            <span class="s1">pageFetchCacheMode === </span><span class="s0">'force-no-store' </span><span class="s1">|| pageFetchCacheMode === </span><span class="s0">'only-no-store'</span><span class="s1">;</span>
            <span class="s4">// If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,</span>
            <span class="s4">// we shouldn't consider caching the fetch. This is because the `dynamic` cache</span>
            <span class="s4">// is considered a &quot;top-level&quot; cache mode, whereas something like `fetchCache` is more</span>
            <span class="s4">// fine-grained. Top-level modes are responsible for setting reasonable defaults for the</span>
            <span class="s4">// other configurations.</span>
            <span class="s2">const </span><span class="s1">noFetchConfigAndForceDynamic = !pageFetchCacheMode &amp;&amp; !currentFetchCacheConfig &amp;&amp; !currentFetchRevalidate &amp;&amp; workStore.forceDynamic;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s4">// force-cache was specified without a revalidate value. We set the revalidate value to false</span>
            <span class="s4">// which will signal the cache to not revalidate</span>
            <span class="s1">currentFetchCacheConfig === </span><span class="s0">'force-cache' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">currentFetchRevalidate === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
                <span class="s1">currentFetchRevalidate = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasExplicitFetchCacheOptOut || noFetchConfigAndForceDynamic) {</span>
                <span class="s1">currentFetchRevalidate = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(currentFetchCacheConfig === </span><span class="s0">'no-cache' </span><span class="s1">|| currentFetchCacheConfig === </span><span class="s0">'no-store'</span><span class="s1">) {</span>
                <span class="s1">cacheReason = </span><span class="s0">`cache: </span><span class="s1">${currentFetchCacheConfig}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">finalRevalidate = validateRevalidate(currentFetchRevalidate, workStore.route);</span>
            <span class="s2">const </span><span class="s1">_headers = getRequestMeta(</span><span class="s0">'headers'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">initHeaders = </span><span class="s2">typeof </span><span class="s1">(_headers == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _headers.get) === </span><span class="s0">'function' </span><span class="s1">? _headers : </span><span class="s2">new </span><span class="s1">Headers(_headers || {});</span>
            <span class="s2">const </span><span class="s1">hasUnCacheableHeader = initHeaders.get(</span><span class="s0">'authorization'</span><span class="s1">) || initHeaders.get(</span><span class="s0">'cookie'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">isUnCacheableMethod = ![</span>
                <span class="s0">'get'</span><span class="s1">,</span>
                <span class="s0">'head'</span>
            <span class="s1">].includes(((_getRequestMeta = getRequestMeta(</span><span class="s0">'method'</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _getRequestMeta.toLowerCase()) || </span><span class="s0">'get'</span><span class="s1">);</span>
            <span class="s4">/**</span>
         <span class="s4">* We automatically disable fetch caching under the following conditions:</span>
         <span class="s4">* - Fetch cache configs are not set. Specifically:</span>
         <span class="s4">*    - A page fetch cache mode is not set (export const fetchCache=...)</span>
         <span class="s4">*    - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ... }))</span>
         <span class="s4">*      or the fetch cache mode is set to 'default'</span>
         <span class="s4">*    - A fetch revalidate value is not set in the fetch call (fetch(url, { revalidate: ... }))</span>
         <span class="s4">* - OR the fetch comes after a configuration that triggered dynamic rendering (e.g., reading cookies())</span>
         <span class="s4">*   and the fetch was considered uncacheable (e.g., POST method or has authorization headers)</span>
         <span class="s4">*/ </span><span class="s2">const </span><span class="s1">hasNoExplicitCacheConfig = </span><span class="s4">// eslint-disable-next-line eqeqeq</span>
            <span class="s1">pageFetchCacheMode == undefined &amp;&amp; </span><span class="s4">// eslint-disable-next-line eqeqeq</span>
            <span class="s1">(currentFetchCacheConfig == undefined || </span><span class="s4">// when considering whether to opt into the default &quot;no-cache&quot; fetch semantics,</span>
            <span class="s4">// a &quot;default&quot; cache config should be treated the same as no cache config</span>
            <span class="s1">currentFetchCacheConfig === </span><span class="s0">'default'</span><span class="s1">) &amp;&amp; </span><span class="s4">// eslint-disable-next-line eqeqeq</span>
            <span class="s1">currentFetchRevalidate == undefined;</span>
            <span class="s2">let </span><span class="s1">autoNoCache = Boolean((hasUnCacheableHeader || isUnCacheableMethod) &amp;&amp; (revalidateStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: revalidateStore.revalidate) === </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s2">let </span><span class="s1">isImplicitBuildTimeCache = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(!autoNoCache &amp;&amp; hasNoExplicitCacheConfig) {</span>
                <span class="s4">// We don't enable automatic no-cache behavior during build-time</span>
                <span class="s4">// prerendering so that we can still leverage the fetch cache between</span>
                <span class="s4">// export workers.</span>
                <span class="s2">if </span><span class="s1">(workStore.isBuildTimePrerendering) {</span>
                    <span class="s1">isImplicitBuildTimeCache = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">autoNoCache = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// If we have no cache config, and we're in Dynamic I/O prerendering,</span>
            <span class="s4">// it'll be a dynamic call. We don't have to issue that dynamic call.</span>
            <span class="s2">if </span><span class="s1">(hasNoExplicitCacheConfig &amp;&amp; workUnitStore !== undefined) {</span>
                <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                    <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                    <span class="s4">// While we don't want to do caching in the client scope we know the</span>
                    <span class="s4">// fetch will be dynamic for cacheComponents so we may as well avoid the</span>
                    <span class="s4">// call here. (fallthrough)</span>
                    <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                            <span class="s1">cacheSignal.endRead();</span>
                            <span class="s1">cacheSignal = </span><span class="s2">null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'fetch()'</span><span class="s1">);</span>
                    <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s1">workUnitStore;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">switch</span><span class="s1">(pageFetchCacheMode){</span>
                <span class="s2">case </span><span class="s0">'force-no-store'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s1">cacheReason = </span><span class="s0">'fetchCache = force-no-store'</span><span class="s1">;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s2">case </span><span class="s0">'only-no-store'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s2">if </span><span class="s1">(currentFetchCacheConfig === </span><span class="s0">'force-cache' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">finalRevalidate !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; finalRevalidate &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`cache: 'force-cache' used on fetch for </span><span class="s1">${fetchUrl} </span><span class="s0">with 'export const fetchCache = 'only-no-store'`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                                <span class="s1">value: </span><span class="s0">&quot;E448&quot;</span><span class="s1">,</span>
                                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">configurable: </span><span class="s2">true</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s1">cacheReason = </span><span class="s0">'fetchCache = only-no-store'</span><span class="s1">;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s2">case </span><span class="s0">'only-cache'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s2">if </span><span class="s1">(currentFetchCacheConfig === </span><span class="s0">'no-store'</span><span class="s1">) {</span>
                            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`cache: 'no-store' used on fetch for </span><span class="s1">${fetchUrl} </span><span class="s0">with 'export const fetchCache = 'only-cache'`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                                <span class="s1">value: </span><span class="s0">&quot;E521&quot;</span><span class="s1">,</span>
                                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">configurable: </span><span class="s2">true</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s2">case </span><span class="s0">'force-cache'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">currentFetchRevalidate === </span><span class="s0">'undefined' </span><span class="s1">|| currentFetchRevalidate === </span><span class="s3">0</span><span class="s1">) {</span>
                            <span class="s1">cacheReason = </span><span class="s0">'fetchCache = force-cache'</span><span class="s1">;</span>
                            <span class="s1">finalRevalidate = _constants1.INFINITE_CACHE;</span>
                        <span class="s1">}</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s2">case </span><span class="s0">'default-cache'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'default-no-store'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'auto'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s1">undefined:</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s1">pageFetchCacheMode;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">finalRevalidate === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(pageFetchCacheMode === </span><span class="s0">'default-cache' </span><span class="s1">&amp;&amp; !isUsingNoStore) {</span>
                    <span class="s1">finalRevalidate = _constants1.INFINITE_CACHE;</span>
                    <span class="s1">cacheReason = </span><span class="s0">'fetchCache = default-cache'</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(pageFetchCacheMode === </span><span class="s0">'default-no-store'</span><span class="s1">) {</span>
                    <span class="s1">finalRevalidate = </span><span class="s3">0</span><span class="s1">;</span>
                    <span class="s1">cacheReason = </span><span class="s0">'fetchCache = default-no-store'</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isUsingNoStore) {</span>
                    <span class="s1">finalRevalidate = </span><span class="s3">0</span><span class="s1">;</span>
                    <span class="s1">cacheReason = </span><span class="s0">'noStore call'</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(autoNoCache) {</span>
                    <span class="s1">finalRevalidate = </span><span class="s3">0</span><span class="s1">;</span>
                    <span class="s1">cacheReason = </span><span class="s0">'auto no cache'</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// TODO: should we consider this case an invariant?</span>
                    <span class="s1">cacheReason = </span><span class="s0">'auto cache'</span><span class="s1">;</span>
                    <span class="s1">finalRevalidate = revalidateStore ? revalidateStore.revalidate : _constants1.INFINITE_CACHE;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!cacheReason) {</span>
                <span class="s1">cacheReason = </span><span class="s0">`revalidate: </span><span class="s1">${finalRevalidate}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s4">// when force static is configured we don't bail from</span>
            <span class="s4">// `revalidate: 0` values</span>
            <span class="s1">!(workStore.forceStatic &amp;&amp; finalRevalidate === </span><span class="s3">0</span><span class="s1">) &amp;&amp; </span><span class="s4">// we don't consider autoNoCache to switch to dynamic for ISR</span>
            <span class="s1">!autoNoCache &amp;&amp; </span><span class="s4">// If the revalidate value isn't currently set or the value is less</span>
            <span class="s4">// than the current revalidate value, we should update the revalidate</span>
            <span class="s4">// value.</span>
            <span class="s1">revalidateStore &amp;&amp; finalRevalidate &lt; revalidateStore.revalidate) {</span>
                <span class="s4">// If we were setting the revalidate value to 0, we should try to</span>
                <span class="s4">// postpone instead first.</span>
                <span class="s2">if </span><span class="s1">(finalRevalidate === </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                                <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                                    <span class="s1">cacheSignal.endRead();</span>
                                    <span class="s1">cacheSignal = </span><span class="s2">null</span><span class="s1">;</span>
                                <span class="s1">}</span>
                                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'fetch()'</span><span class="s1">);</span>
                            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s2">default</span><span class="s1">:</span>
                                <span class="s1">workUnitStore;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, </span><span class="s0">`revalidate: 0 fetch </span><span class="s1">${input} ${workStore.route}</span><span class="s0">`</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s4">// We only want to set the revalidate store's revalidate time if it</span>
                <span class="s4">// was explicitly set for the fetch call, i.e.</span>
                <span class="s4">// originalFetchRevalidate.</span>
                <span class="s2">if </span><span class="s1">(revalidateStore &amp;&amp; originalFetchRevalidate === finalRevalidate) {</span>
                    <span class="s1">revalidateStore.revalidate = finalRevalidate;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">isCacheableRevalidate = </span><span class="s2">typeof </span><span class="s1">finalRevalidate === </span><span class="s0">'number' </span><span class="s1">&amp;&amp; finalRevalidate &gt; </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">cacheKey;</span>
            <span class="s2">const </span><span class="s1">{ incrementalCache } = workStore;</span>
            <span class="s2">let </span><span class="s1">isHmrRefresh = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">serverComponentsHmrCache;</span>
            <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                    <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                        <span class="s1">isHmrRefresh = workUnitStore.isHmrRefresh ?? </span><span class="s2">false</span><span class="s1">;</span>
                        <span class="s1">serverComponentsHmrCache = workUnitStore.serverComponentsHmrCache;</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s1">workUnitStore;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(incrementalCache &amp;&amp; (isCacheableRevalidate || serverComponentsHmrCache)) {</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">cacheKey = </span><span class="s2">await </span><span class="s1">incrementalCache.generateCacheKey(fetchUrl, isRequestInput ? input : init);</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                    <span class="s1">console.error(</span><span class="s0">`Failed to generate cache key for`</span><span class="s1">, input);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">fetchIdx = workStore.nextFetchId ?? </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">workStore.nextFetchId = fetchIdx + </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">handleUnlock = ()=&gt;{};</span>
            <span class="s2">const </span><span class="s1">doOriginalFetch = async (isStale, cacheReasonOverride)=&gt;{</span>
                <span class="s2">const </span><span class="s1">requestInputFields = [</span>
                    <span class="s0">'cache'</span><span class="s1">,</span>
                    <span class="s0">'credentials'</span><span class="s1">,</span>
                    <span class="s0">'headers'</span><span class="s1">,</span>
                    <span class="s0">'integrity'</span><span class="s1">,</span>
                    <span class="s0">'keepalive'</span><span class="s1">,</span>
                    <span class="s0">'method'</span><span class="s1">,</span>
                    <span class="s0">'mode'</span><span class="s1">,</span>
                    <span class="s0">'redirect'</span><span class="s1">,</span>
                    <span class="s0">'referrer'</span><span class="s1">,</span>
                    <span class="s0">'referrerPolicy'</span><span class="s1">,</span>
                    <span class="s0">'window'</span><span class="s1">,</span>
                    <span class="s0">'duplex'</span><span class="s1">,</span>
                    <span class="s4">// don't pass through signal when revalidating</span>
                    <span class="s1">...isStale ? [] : [</span>
                        <span class="s0">'signal'</span>
                    <span class="s1">]</span>
                <span class="s1">];</span>
                <span class="s2">if </span><span class="s1">(isRequestInput) {</span>
                    <span class="s2">const </span><span class="s1">reqInput = input;</span>
                    <span class="s2">const </span><span class="s1">reqOptions = {</span>
                        <span class="s1">body: reqInput._ogBody || reqInput.body</span>
                    <span class="s1">};</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">field of requestInputFields){</span>
                        <span class="s4">// @ts-expect-error custom fields</span>
                        <span class="s1">reqOptions[field] = reqInput[field];</span>
                    <span class="s1">}</span>
                    <span class="s1">input = </span><span class="s2">new </span><span class="s1">Request(reqInput.url, reqOptions);</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(init) {</span>
                    <span class="s2">const </span><span class="s1">{ _ogBody, body, signal, ...otherInput } = init;</span>
                    <span class="s1">init = {</span>
                        <span class="s1">...otherInput,</span>
                        <span class="s1">body: _ogBody || body,</span>
                        <span class="s1">signal: isStale ? undefined : signal</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
                <span class="s4">// add metadata to init without editing the original</span>
                <span class="s2">const </span><span class="s1">clonedInit = {</span>
                    <span class="s1">...init,</span>
                    <span class="s1">next: {</span>
                        <span class="s1">...init == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: init.next,</span>
                        <span class="s1">fetchType: </span><span class="s0">'origin'</span><span class="s1">,</span>
                        <span class="s1">fetchIdx</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>
                <span class="s2">return </span><span class="s1">originFetch(input, clonedInit).then(async (res)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(!isStale &amp;&amp; fetchStart) {</span>
                        <span class="s1">trackFetchMetric(workStore, {</span>
                            <span class="s1">start: fetchStart,</span>
                            <span class="s1">url: fetchUrl,</span>
                            <span class="s1">cacheReason: cacheReasonOverride || cacheReason,</span>
                            <span class="s1">cacheStatus: finalRevalidate === </span><span class="s3">0 </span><span class="s1">|| cacheReasonOverride ? </span><span class="s0">'skip' </span><span class="s1">: </span><span class="s0">'miss'</span><span class="s1">,</span>
                            <span class="s1">cacheWarning,</span>
                            <span class="s1">status: res.status,</span>
                            <span class="s1">method: clonedInit.method || </span><span class="s0">'GET'</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(res.status === </span><span class="s3">200 </span><span class="s1">&amp;&amp; incrementalCache &amp;&amp; cacheKey &amp;&amp; (isCacheableRevalidate || serverComponentsHmrCache)) {</span>
                        <span class="s2">const </span><span class="s1">normalizedRevalidate = finalRevalidate &gt;= _constants1.INFINITE_CACHE ? _constants1.CACHE_ONE_YEAR : finalRevalidate;</span>
                        <span class="s2">const </span><span class="s1">incrementalCacheConfig = isCacheableRevalidate ? {</span>
                            <span class="s1">fetchCache: </span><span class="s2">true</span><span class="s1">,</span>
                            <span class="s1">fetchUrl,</span>
                            <span class="s1">fetchIdx,</span>
                            <span class="s1">tags,</span>
                            <span class="s1">isImplicitBuildTimeCache</span>
                        <span class="s1">} : undefined;</span>
                        <span class="s2">switch</span><span class="s1">(workUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: workUnitStore.type){</span>
                            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                                <span class="s2">return </span><span class="s1">createCachedPrerenderResponse(res, cacheKey, incrementalCacheConfig, incrementalCache, normalizedRevalidate, handleUnlock);</span>
                            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s1">undefined:</span>
                                <span class="s2">return </span><span class="s1">createCachedDynamicResponse(workStore, res, cacheKey, incrementalCacheConfig, incrementalCache, serverComponentsHmrCache, normalizedRevalidate, input, handleUnlock);</span>
                            <span class="s2">default</span><span class="s1">:</span>
                                <span class="s1">workUnitStore;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s4">// we had response that we determined shouldn't be cached so we return it</span>
                    <span class="s4">// and don't cache it. This also needs to unlock the cache lock we acquired.</span>
                    <span class="s2">await </span><span class="s1">handleUnlock();</span>
                    <span class="s2">return </span><span class="s1">res;</span>
                <span class="s1">}).catch((error)=&gt;{</span>
                    <span class="s1">handleUnlock();</span>
                    <span class="s2">throw </span><span class="s1">error;</span>
                <span class="s1">});</span>
            <span class="s1">};</span>
            <span class="s2">let </span><span class="s1">cacheReasonOverride;</span>
            <span class="s2">let </span><span class="s1">isForegroundRevalidate = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">isHmrRefreshCache = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(cacheKey &amp;&amp; incrementalCache) {</span>
                <span class="s2">let </span><span class="s1">cachedFetchData;</span>
                <span class="s2">if </span><span class="s1">(isHmrRefresh &amp;&amp; serverComponentsHmrCache) {</span>
                    <span class="s1">cachedFetchData = serverComponentsHmrCache.get(cacheKey);</span>
                    <span class="s1">isHmrRefreshCache = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(isCacheableRevalidate &amp;&amp; !cachedFetchData) {</span>
                    <span class="s1">handleUnlock = </span><span class="s2">await </span><span class="s1">incrementalCache.lock(cacheKey);</span>
                    <span class="s2">const </span><span class="s1">entry = workStore.isOnDemandRevalidate ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">await </span><span class="s1">incrementalCache.get(cacheKey, {</span>
                        <span class="s1">kind: _responsecache.IncrementalCacheKind.FETCH,</span>
                        <span class="s1">revalidate: finalRevalidate,</span>
                        <span class="s1">fetchUrl,</span>
                        <span class="s1">fetchIdx,</span>
                        <span class="s1">tags,</span>
                        <span class="s1">softTags: implicitTags == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: implicitTags.tags</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">(hasNoExplicitCacheConfig &amp;&amp; workUnitStore) {</span>
                        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                                <span class="s4">// We sometimes use the cache to dedupe fetches that do not</span>
                                <span class="s4">// specify a cache configuration. In these cases we want to</span>
                                <span class="s4">// make sure we still exclude them from prerenders if</span>
                                <span class="s4">// cacheComponents is on so we introduce an artificial task boundary</span>
                                <span class="s4">// here.</span>
                                <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.waitAtLeastOneReactRenderTask)();</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s2">default</span><span class="s1">:</span>
                                <span class="s1">workUnitStore;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(entry) {</span>
                        <span class="s2">await </span><span class="s1">handleUnlock();</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers</span>
                        <span class="s1">cacheReasonOverride = </span><span class="s0">'cache-control: no-cache (hard refresh)'</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">((entry == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: entry.value) &amp;&amp; entry.value.kind === _responsecache.CachedRouteKind.FETCH) {</span>
                        <span class="s4">// when stale and is revalidating we wait for fresh data</span>
                        <span class="s4">// so the revalidated entry has the updated data</span>
                        <span class="s2">if </span><span class="s1">(workStore.isRevalidate &amp;&amp; entry.isStale) {</span>
                            <span class="s1">isForegroundRevalidate = </span><span class="s2">true</span><span class="s1">;</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s2">if </span><span class="s1">(entry.isStale) {</span>
                                <span class="s1">workStore.pendingRevalidates ??= {};</span>
                                <span class="s2">if </span><span class="s1">(!workStore.pendingRevalidates[cacheKey]) {</span>
                                    <span class="s2">const </span><span class="s1">pendingRevalidate = doOriginalFetch(</span><span class="s2">true</span><span class="s1">).then(async (response)=&gt;({</span>
                                            <span class="s1">body: </span><span class="s2">await </span><span class="s1">response.arrayBuffer(),</span>
                                            <span class="s1">headers: response.headers,</span>
                                            <span class="s1">status: response.status,</span>
                                            <span class="s1">statusText: response.statusText</span>
                                        <span class="s1">})).finally(()=&gt;{</span>
                                        <span class="s1">workStore.pendingRevalidates ??= {};</span>
                                        <span class="s2">delete </span><span class="s1">workStore.pendingRevalidates[cacheKey || </span><span class="s0">''</span><span class="s1">];</span>
                                    <span class="s1">});</span>
                                    <span class="s4">// Attach the empty catch here so we don't get a &quot;unhandled</span>
                                    <span class="s4">// promise rejection&quot; warning.</span>
                                    <span class="s1">pendingRevalidate.catch(console.error);</span>
                                    <span class="s1">workStore.pendingRevalidates[cacheKey] = pendingRevalidate;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s1">cachedFetchData = entry.value.data;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(cachedFetchData) {</span>
                    <span class="s2">if </span><span class="s1">(fetchStart) {</span>
                        <span class="s1">trackFetchMetric(workStore, {</span>
                            <span class="s1">start: fetchStart,</span>
                            <span class="s1">url: fetchUrl,</span>
                            <span class="s1">cacheReason,</span>
                            <span class="s1">cacheStatus: isHmrRefreshCache ? </span><span class="s0">'hmr' </span><span class="s1">: </span><span class="s0">'hit'</span><span class="s1">,</span>
                            <span class="s1">cacheWarning,</span>
                            <span class="s1">status: cachedFetchData.status || </span><span class="s3">200</span><span class="s1">,</span>
                            <span class="s1">method: (init == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: init.method) || </span><span class="s0">'GET'</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">response = </span><span class="s2">new </span><span class="s1">Response(Buffer.from(cachedFetchData.body, </span><span class="s0">'base64'</span><span class="s1">), {</span>
                        <span class="s1">headers: cachedFetchData.headers,</span>
                        <span class="s1">status: cachedFetchData.status</span>
                    <span class="s1">});</span>
                    <span class="s1">Object.defineProperty(response, </span><span class="s0">'url'</span><span class="s1">, {</span>
                        <span class="s1">value: cachedFetchData.url</span>
                    <span class="s1">});</span>
                    <span class="s2">return </span><span class="s1">response;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(workStore.isStaticGeneration &amp;&amp; init &amp;&amp; </span><span class="s2">typeof </span><span class="s1">init === </span><span class="s0">'object'</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">{ cache } = init;</span>
                <span class="s4">// Delete `cache` property as Cloudflare Workers will throw an error</span>
                <span class="s2">if </span><span class="s1">(isEdgeRuntime) </span><span class="s2">delete </span><span class="s1">init.cache;</span>
                <span class="s2">if </span><span class="s1">(cache === </span><span class="s0">'no-store'</span><span class="s1">) {</span>
                    <span class="s4">// If enabled, we should bail out of static generation.</span>
                    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                                <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                                    <span class="s1">cacheSignal.endRead();</span>
                                    <span class="s1">cacheSignal = </span><span class="s2">null</span><span class="s1">;</span>
                                <span class="s1">}</span>
                                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'fetch()'</span><span class="s1">);</span>
                            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s2">default</span><span class="s1">:</span>
                                <span class="s1">workUnitStore;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, </span><span class="s0">`no-store fetch </span><span class="s1">${input} ${workStore.route}</span><span class="s0">`</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">hasNextConfig = </span><span class="s0">'next' </span><span class="s2">in </span><span class="s1">init;</span>
                <span class="s2">const </span><span class="s1">{ next = {} } = init;</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">next.revalidate === </span><span class="s0">'number' </span><span class="s1">&amp;&amp; revalidateStore &amp;&amp; next.revalidate &lt; revalidateStore.revalidate) {</span>
                    <span class="s2">if </span><span class="s1">(next.revalidate === </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s4">// If enabled, we should bail out of static generation.</span>
                        <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                            <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                                <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                                    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'fetch()'</span><span class="s1">);</span>
                                <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                                    <span class="s2">break</span><span class="s1">;</span>
                                <span class="s2">default</span><span class="s1">:</span>
                                    <span class="s1">workUnitStore;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, </span><span class="s0">`revalidate: 0 fetch </span><span class="s1">${input} ${workStore.route}</span><span class="s0">`</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!workStore.forceStatic || next.revalidate !== </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s1">revalidateStore.revalidate = next.revalidate;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(hasNextConfig) </span><span class="s2">delete </span><span class="s1">init.next;</span>
            <span class="s1">}</span>
            <span class="s4">// if we are revalidating the whole page via time or on-demand and</span>
            <span class="s4">// the fetch cache entry is stale we should still de-dupe the</span>
            <span class="s4">// origin hit if it's a cache-able entry</span>
            <span class="s2">if </span><span class="s1">(cacheKey &amp;&amp; isForegroundRevalidate) {</span>
                <span class="s2">const </span><span class="s1">pendingRevalidateKey = cacheKey;</span>
                <span class="s1">workStore.pendingRevalidates ??= {};</span>
                <span class="s2">let </span><span class="s1">pendingRevalidate = workStore.pendingRevalidates[pendingRevalidateKey];</span>
                <span class="s2">if </span><span class="s1">(pendingRevalidate) {</span>
                    <span class="s2">const </span><span class="s1">revalidatedResult = </span><span class="s2">await </span><span class="s1">pendingRevalidate;</span>
                    <span class="s2">return new </span><span class="s1">Response(revalidatedResult.body, {</span>
                        <span class="s1">headers: revalidatedResult.headers,</span>
                        <span class="s1">status: revalidatedResult.status,</span>
                        <span class="s1">statusText: revalidatedResult.statusText</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s4">// We used to just resolve the Response and clone it however for</span>
                <span class="s4">// static generation with cacheComponents we need the response to be able to</span>
                <span class="s4">// be resolved in a microtask and cloning the response will never have</span>
                <span class="s4">// a body that can resolve in a microtask in node (as observed through</span>
                <span class="s4">// experimentation) So instead we await the body and then when it is</span>
                <span class="s4">// available we construct manually cloned Response objects with the</span>
                <span class="s4">// body as an ArrayBuffer. This will be resolvable in a microtask</span>
                <span class="s4">// making it compatible with cacheComponents.</span>
                <span class="s2">const </span><span class="s1">pendingResponse = doOriginalFetch(</span><span class="s2">true</span><span class="s1">, cacheReasonOverride)</span><span class="s4">// We're cloning the response using this utility because there</span>
                <span class="s4">// exists a bug in the undici library around response cloning.</span>
                <span class="s4">// See the following pull request for more details:</span>
                <span class="s4">// https://github.com/vercel/next.js/pull/73274</span>
                <span class="s1">.then(_cloneresponse.cloneResponse);</span>
                <span class="s1">pendingRevalidate = pendingResponse.then(async (responses)=&gt;{</span>
                    <span class="s2">const </span><span class="s1">response = responses[</span><span class="s3">0</span><span class="s1">];</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s1">body: </span><span class="s2">await </span><span class="s1">response.arrayBuffer(),</span>
                        <span class="s1">headers: response.headers,</span>
                        <span class="s1">status: response.status,</span>
                        <span class="s1">statusText: response.statusText</span>
                    <span class="s1">};</span>
                <span class="s1">}).finally(()=&gt;{</span>
                    <span class="s2">var </span><span class="s1">_workStore_pendingRevalidates;</span>
                    <span class="s4">// If the pending revalidate is not present in the store, then</span>
                    <span class="s4">// we have nothing to delete.</span>
                    <span class="s2">if </span><span class="s1">(!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _workStore_pendingRevalidates[pendingRevalidateKey])) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">delete </span><span class="s1">workStore.pendingRevalidates[pendingRevalidateKey];</span>
                <span class="s1">});</span>
                <span class="s4">// Attach the empty catch here so we don't get a &quot;unhandled promise</span>
                <span class="s4">// rejection&quot; warning</span>
                <span class="s1">pendingRevalidate.catch(()=&gt;{});</span>
                <span class="s1">workStore.pendingRevalidates[pendingRevalidateKey] = pendingRevalidate;</span>
                <span class="s2">return </span><span class="s1">pendingResponse.then((responses)=&gt;responses[</span><span class="s3">1</span><span class="s1">]);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">doOriginalFetch(</span><span class="s2">false</span><span class="s1">, cacheReasonOverride);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">return await </span><span class="s1">result;</span>
            <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                    <span class="s1">cacheSignal.endRead();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">};</span>
    <span class="s4">// Attach the necessary properties to the patched fetch function.</span>
    <span class="s4">// We don't use this to determine if the fetch function has been patched,</span>
    <span class="s4">// but for external consumers to determine if the fetch function has been</span>
    <span class="s4">// patched.</span>
    <span class="s1">patched.__nextPatched = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">patched.__nextGetStaticStore = ()=&gt;workAsyncStorage;</span>
    <span class="s1">patched._nextOriginalFetch = originFetch;</span>
    <span class="s1">globalThis[NEXT_PATCH_SYMBOL] = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s4">// Assign the function name also as a name property, so that it's preserved</span>
    <span class="s4">// even when mangling is enabled.</span>
    <span class="s1">Object.defineProperty(patched, </span><span class="s0">'name'</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s0">'fetch'</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s2">false</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">patched;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchFetch(options) {</span>
    <span class="s4">// If we've already patched fetch, we should not patch it again.</span>
    <span class="s2">if </span><span class="s1">(isFetchPatched()) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s4">// Grab the original fetch function. We'll attach this so we can use it in</span>
    <span class="s4">// the patched fetch function.</span>
    <span class="s2">const </span><span class="s1">original = (</span><span class="s3">0</span><span class="s1">, _dedupefetch.createDedupeFetch)(globalThis.fetch);</span>
    <span class="s4">// Set the global fetch to the patched fetch.</span>
    <span class="s1">globalThis.fetch = createPatchedFetcher(original, options);</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=patch-fetch.js.map</span></pre>
</body>
</html>