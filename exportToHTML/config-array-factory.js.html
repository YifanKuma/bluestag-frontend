<html>
<head>
<title>config-array-factory.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
.s7 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
config-array-factory.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">The factory of `ConfigArray` objects.</span>
 <span class="s0">*</span>
 <span class="s0">* This class provides methods to create `ConfigArray` instance.</span>
 <span class="s0">*</span>
 <span class="s0">* - `create(configData, options)`</span>
 <span class="s0">*     Create a `ConfigArray` instance from a config data. This is to handle CLI</span>
 <span class="s0">*     options except `--config`.</span>
 <span class="s0">* - `loadFile(filePath, options)`</span>
 <span class="s0">*     Create a `ConfigArray` instance from a config file. This is to handle</span>
 <span class="s0">*     `--config` option. If the file was not found, throws the following error:</span>
 <span class="s0">*      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.</span>
 <span class="s0">*      - If the filename was `package.json`, an IO error or an</span>
 <span class="s0">*        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.</span>
 <span class="s0">*      - Otherwise, an IO error such as `ENOENT`.</span>
 <span class="s0">* - `loadInDirectory(directoryPath, options)`</span>
 <span class="s0">*     Create a `ConfigArray` instance from a config file which is on a given</span>
 <span class="s0">*     directory. This tries to load `.eslintrc.*` or `package.json`. If not</span>
 <span class="s0">*     found, returns an empty `ConfigArray`.</span>
 <span class="s0">* - `loadESLintIgnore(filePath)`</span>
 <span class="s0">*     Create a `ConfigArray` instance from a config file that is `.eslintignore`</span>
 <span class="s0">*     format. This is to handle `--ignore-path` option.</span>
 <span class="s0">* - `loadDefaultESLintIgnore()`</span>
 <span class="s0">*     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in</span>
 <span class="s0">*     the current working directory.</span>
 <span class="s0">*</span>
 <span class="s0">* `ConfigArrayFactory` class has the responsibility that loads configuration</span>
 <span class="s0">* files, including loading `extends`, `parser`, and `plugins`. The created</span>
 <span class="s0">* `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.</span>
 <span class="s0">*</span>
 <span class="s0">* But this class doesn't handle cascading. `CascadingConfigArrayFactory` class</span>
 <span class="s0">* handles cascading and hierarchy.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s0">*/</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s3">import </span><span class="s2">debugOrig from </span><span class="s4">&quot;debug&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">fs from </span><span class="s4">&quot;node:fs&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">importFresh from </span><span class="s4">&quot;import-fresh&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">{ createRequire } from </span><span class="s4">&quot;node:module&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">path from </span><span class="s4">&quot;node:path&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">stripComments from </span><span class="s4">&quot;strip-json-comments&quot;</span><span class="s2">;</span>

<span class="s3">import </span><span class="s2">{</span>
    <span class="s2">ConfigArray,</span>
    <span class="s2">ConfigDependency,</span>
    <span class="s2">IgnorePattern,</span>
    <span class="s2">OverrideTester</span>
<span class="s2">} from </span><span class="s4">&quot;./config-array/index.js&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">ConfigValidator from </span><span class="s4">&quot;./shared/config-validator.js&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">* as naming from </span><span class="s4">&quot;./shared/naming.js&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">* as ModuleResolver from </span><span class="s4">&quot;./shared/relative-module-resolver.js&quot;</span><span class="s2">;</span>

<span class="s3">const </span><span class="s2">require = createRequire(</span><span class="s3">import</span><span class="s2">.meta.url);</span>

<span class="s3">const </span><span class="s2">debug = debugOrig(</span><span class="s4">&quot;eslintrc:config-array-factory&quot;</span><span class="s2">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s3">const </span><span class="s2">configFilenames = [</span>
    <span class="s4">&quot;.eslintrc.js&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;.eslintrc.cjs&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;.eslintrc.yaml&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;.eslintrc.yml&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;.eslintrc.json&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;.eslintrc&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;package.json&quot;</span>
<span class="s2">];</span>

<span class="s0">// Define types for VSCode IntelliSense.</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./shared/types&quot;).ConfigData} ConfigData */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./shared/types&quot;).OverrideConfigData} OverrideConfigData */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./shared/types&quot;).Parser} Parser */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./shared/types&quot;).Plugin} Plugin */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./shared/types&quot;).Rule} Rule */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./config-array/config-dependency&quot;).DependentParser} DependentParser */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./config-array/config-dependency&quot;).DependentPlugin} DependentPlugin */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{ConfigArray[0]} ConfigArrayElement */</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} ConfigArrayFactoryOptions</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Map&lt;string,Plugin&gt;} [additionalPluginPool] The map for additional plugins.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} [cwd] The path to the current working directory.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Map&lt;string,Rule&gt;} builtInRules The rules that are built in to ESLint.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Object} [resolver=ModuleResolver] The module resolver object.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} eslintAllPath The path to the definitions for eslint:all.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} getEslintAllConfig Returns the config data for eslint:all.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} eslintRecommendedPath The path to the definitions for eslint:recommended.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} ConfigArrayFactoryInternalSlots</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Map&lt;string,Plugin&gt;} additionalPluginPool The map for additional plugins.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} cwd The path to the current working directory.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Map&lt;string,Rule&gt;} builtInRules The rules that are built in to ESLint.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Object} [resolver=ModuleResolver] The module resolver object.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} eslintAllPath The path to the definitions for eslint:all.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} getEslintAllConfig Returns the config data for eslint:all.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} eslintRecommendedPath The path to the definitions for eslint:recommended.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} ConfigArrayFactoryLoadingContext</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} filePath The path to the current configuration.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} name The name of the current configuration.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} pluginBasePath The base path to resolve plugins.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot;} type The type of the current configuration. This is `&quot;config&quot;` in normal. This is `&quot;ignore&quot;` if it came from `.eslintignore`. This is `&quot;implicit-processor&quot;` if it came from legacy file-extension processors.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} ConfigArrayFactoryLoadingContext</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} filePath The path to the current configuration.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} name The name of the current configuration.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot;} type The type of the current configuration. This is `&quot;config&quot;` in normal. This is `&quot;ignore&quot;` if it came from `.eslintignore`. This is `&quot;implicit-processor&quot;` if it came from legacy file-extension processors.</span>
 <span class="s0">*/</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{WeakMap&lt;ConfigArrayFactory, ConfigArrayFactoryInternalSlots&gt;} */</span>
<span class="s3">const </span><span class="s2">internalSlotsMap = </span><span class="s3">new </span><span class="s2">WeakMap();</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{WeakMap&lt;object, Plugin&gt;} */</span>
<span class="s3">const </span><span class="s2">normalizedPlugins = </span><span class="s3">new </span><span class="s2">WeakMap();</span>

<span class="s0">/**</span>
 <span class="s0">* Check if a given string is a file path.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} nameOrPath A module name or file path.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the `nameOrPath` is a file path.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">isFilePath(nameOrPath) {</span>
    <span class="s3">return </span><span class="s2">(</span>
        <span class="s5">/^\.{1,2}[/\\]/u</span><span class="s2">.test(nameOrPath) ||</span>
        <span class="s2">path.isAbsolute(nameOrPath)</span>
    <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Convenience wrapper for synchronously reading file contents.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The filename to read.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The file contents, with the BOM removed.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">readFile(filePath) {</span>
    <span class="s3">return </span><span class="s2">fs.readFileSync(filePath, </span><span class="s4">&quot;utf8&quot;</span><span class="s2">).replace(</span><span class="s5">/^\ufeff/u</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Loads a YAML configuration from a file.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The filename to load.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigData} The configuration object from the file.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">loadYAMLConfigFile(filePath) {</span>
    <span class="s2">debug(</span><span class="s4">`Loading YAML config file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>

    <span class="s0">// lazy load YAML to improve performance when not used</span>
    <span class="s3">const </span><span class="s2">yaml = require(</span><span class="s4">&quot;js-yaml&quot;</span><span class="s2">);</span>

    <span class="s3">try </span><span class="s2">{</span>

        <span class="s0">// empty YAML file can be null, so always use</span>
        <span class="s3">return </span><span class="s2">yaml.load(readFile(filePath)) || {};</span>
    <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
        <span class="s2">debug(</span><span class="s4">`Error reading YAML file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>
        <span class="s2">e.message = </span><span class="s4">`Cannot read config file: </span><span class="s2">${filePath}</span><span class="s6">\n</span><span class="s4">Error: </span><span class="s2">${e.message}</span><span class="s4">`</span><span class="s2">;</span>
        <span class="s3">throw </span><span class="s2">e;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Loads a JSON configuration from a file.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The filename to load.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigData} The configuration object from the file.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">loadJSONConfigFile(filePath) {</span>
    <span class="s2">debug(</span><span class="s4">`Loading JSON config file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>

    <span class="s3">try </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s2">JSON.parse(stripComments(readFile(filePath)));</span>
    <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
        <span class="s2">debug(</span><span class="s4">`Error reading JSON file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>
        <span class="s2">e.message = </span><span class="s4">`Cannot read config file: </span><span class="s2">${filePath}</span><span class="s6">\n</span><span class="s4">Error: </span><span class="s2">${e.message}</span><span class="s4">`</span><span class="s2">;</span>
        <span class="s2">e.messageTemplate = </span><span class="s4">&quot;failed-to-read-json&quot;</span><span class="s2">;</span>
        <span class="s2">e.messageData = {</span>
            <span class="s2">path: filePath,</span>
            <span class="s2">message: e.message</span>
        <span class="s2">};</span>
        <span class="s3">throw </span><span class="s2">e;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Loads a legacy (.eslintrc) configuration from a file.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The filename to load.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigData} The configuration object from the file.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">loadLegacyConfigFile(filePath) {</span>
    <span class="s2">debug(</span><span class="s4">`Loading legacy config file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>

    <span class="s0">// lazy load YAML to improve performance when not used</span>
    <span class="s3">const </span><span class="s2">yaml = require(</span><span class="s4">&quot;js-yaml&quot;</span><span class="s2">);</span>

    <span class="s3">try </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s2">yaml.load(stripComments(readFile(filePath))) || </span><span class="s0">/* istanbul ignore next */ </span><span class="s2">{};</span>
    <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
        <span class="s2">debug(</span><span class="s4">&quot;Error reading YAML file: %s</span><span class="s6">\n</span><span class="s4">%o&quot;</span><span class="s2">, filePath, e);</span>
        <span class="s2">e.message = </span><span class="s4">`Cannot read config file: </span><span class="s2">${filePath}</span><span class="s6">\n</span><span class="s4">Error: </span><span class="s2">${e.message}</span><span class="s4">`</span><span class="s2">;</span>
        <span class="s3">throw </span><span class="s2">e;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Loads a JavaScript configuration from a file.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The filename to load.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigData} The configuration object from the file.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">loadJSConfigFile(filePath) {</span>
    <span class="s2">debug(</span><span class="s4">`Loading JS config file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>
    <span class="s3">try </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s2">importFresh(filePath);</span>
    <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
        <span class="s2">debug(</span><span class="s4">`Error reading JavaScript file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>
        <span class="s2">e.message = </span><span class="s4">`Cannot read config file: </span><span class="s2">${filePath}</span><span class="s6">\n</span><span class="s4">Error: </span><span class="s2">${e.message}</span><span class="s4">`</span><span class="s2">;</span>
        <span class="s3">throw </span><span class="s2">e;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Loads a configuration from a package.json file.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The filename to load.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigData} The configuration object from the file.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">loadPackageJSONConfigFile(filePath) {</span>
    <span class="s2">debug(</span><span class="s4">`Loading package.json config file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>
    <span class="s3">try </span><span class="s2">{</span>
        <span class="s3">const </span><span class="s2">packageData = loadJSONConfigFile(filePath);</span>

        <span class="s3">if </span><span class="s2">(!Object.hasOwn(packageData, </span><span class="s4">&quot;eslintConfig&quot;</span><span class="s2">)) {</span>
            <span class="s3">throw </span><span class="s2">Object.assign(</span>
                <span class="s3">new </span><span class="s2">Error(</span><span class="s4">&quot;package.json file doesn't have 'eslintConfig' field.&quot;</span><span class="s2">),</span>
                <span class="s2">{ code: </span><span class="s4">&quot;ESLINT_CONFIG_FIELD_NOT_FOUND&quot; </span><span class="s2">}</span>
            <span class="s2">);</span>
        <span class="s2">}</span>

        <span class="s3">return </span><span class="s2">packageData.eslintConfig;</span>
    <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
        <span class="s2">debug(</span><span class="s4">`Error reading package.json file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>
        <span class="s2">e.message = </span><span class="s4">`Cannot read config file: </span><span class="s2">${filePath}</span><span class="s6">\n</span><span class="s4">Error: </span><span class="s2">${e.message}</span><span class="s4">`</span><span class="s2">;</span>
        <span class="s3">throw </span><span class="s2">e;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Loads a `.eslintignore` from a file.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The filename to load.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string[]} The ignore patterns from the file.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">loadESLintIgnoreFile(filePath) {</span>
    <span class="s2">debug(</span><span class="s4">`Loading .eslintignore file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>

    <span class="s3">try </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s2">readFile(filePath)</span>
            <span class="s2">.split(</span><span class="s5">/\r?\n/gu</span><span class="s2">)</span>
            <span class="s2">.filter(line =&gt; line.trim() !== </span><span class="s4">&quot;&quot; </span><span class="s2">&amp;&amp; !line.startsWith(</span><span class="s4">&quot;#&quot;</span><span class="s2">));</span>
    <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
        <span class="s2">debug(</span><span class="s4">`Error reading .eslintignore file: </span><span class="s2">${filePath}</span><span class="s4">`</span><span class="s2">);</span>
        <span class="s2">e.message = </span><span class="s4">`Cannot read .eslintignore file: </span><span class="s2">${filePath}</span><span class="s6">\n</span><span class="s4">Error: </span><span class="s2">${e.message}</span><span class="s4">`</span><span class="s2">;</span>
        <span class="s3">throw </span><span class="s2">e;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates an error to notify about a missing config to extend from.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} configName The name of the missing config.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} importerName The name of the config that imported the missing config</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} messageTemplate The text template to source error strings from.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Error} The error object to throw</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">configInvalidError(configName, importerName, messageTemplate) {</span>
    <span class="s3">return </span><span class="s2">Object.assign(</span>
        <span class="s3">new </span><span class="s2">Error(</span><span class="s4">`Failed to load config &quot;</span><span class="s2">${configName}</span><span class="s4">&quot; to extend from.`</span><span class="s2">),</span>
        <span class="s2">{</span>
            <span class="s2">messageTemplate,</span>
            <span class="s2">messageData: { configName, importerName }</span>
        <span class="s2">}</span>
    <span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Loads a configuration file regardless of the source. Inspects the file path</span>
 <span class="s0">* to determine the correctly way to load the config file.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The path to the configuration.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigData|null} The configuration information.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">loadConfigFile(filePath) {</span>
    <span class="s3">switch </span><span class="s2">(path.extname(filePath)) {</span>
        <span class="s3">case </span><span class="s4">&quot;.js&quot;</span><span class="s2">:</span>
        <span class="s3">case </span><span class="s4">&quot;.cjs&quot;</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s2">loadJSConfigFile(filePath);</span>

        <span class="s3">case </span><span class="s4">&quot;.json&quot;</span><span class="s2">:</span>
            <span class="s3">if </span><span class="s2">(path.basename(filePath) === </span><span class="s4">&quot;package.json&quot;</span><span class="s2">) {</span>
                <span class="s3">return </span><span class="s2">loadPackageJSONConfigFile(filePath);</span>
            <span class="s2">}</span>
            <span class="s3">return </span><span class="s2">loadJSONConfigFile(filePath);</span>

        <span class="s3">case </span><span class="s4">&quot;.yaml&quot;</span><span class="s2">:</span>
        <span class="s3">case </span><span class="s4">&quot;.yml&quot;</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s2">loadYAMLConfigFile(filePath);</span>

        <span class="s3">default</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s2">loadLegacyConfigFile(filePath);</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Write debug log.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} request The requested module name.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} relativeTo The file path to resolve the request relative to.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The resolved file path.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">writeDebugLogForLoading(request, relativeTo, filePath) {</span>
    <span class="s0">/* istanbul ignore next */</span>
    <span class="s3">if </span><span class="s2">(debug.enabled) {</span>
        <span class="s3">let </span><span class="s2">nameAndVersion = </span><span class="s3">null</span><span class="s2">; </span><span class="s0">// eslint-disable-line no-useless-assignment -- known bug in the rule</span>

        <span class="s3">try </span><span class="s2">{</span>
            <span class="s3">const </span><span class="s2">packageJsonPath = ModuleResolver.resolve(</span>
                <span class="s4">`</span><span class="s2">${request}</span><span class="s4">/package.json`</span><span class="s2">,</span>
                <span class="s2">relativeTo</span>
            <span class="s2">);</span>
            <span class="s3">const </span><span class="s2">{ version = </span><span class="s4">&quot;unknown&quot; </span><span class="s2">} = require(packageJsonPath);</span>

            <span class="s2">nameAndVersion = </span><span class="s4">`</span><span class="s2">${request}</span><span class="s4">@</span><span class="s2">${version}</span><span class="s4">`</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>
            <span class="s2">debug(</span><span class="s4">&quot;package.json was not found:&quot;</span><span class="s2">, error.message);</span>
            <span class="s2">nameAndVersion = request;</span>
        <span class="s2">}</span>

        <span class="s2">debug(</span><span class="s4">&quot;Loaded: %s (%s)&quot;</span><span class="s2">, nameAndVersion, filePath);</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Create a new context with default values.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryInternalSlots} slots The internal slots.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot; | undefined} providedType The type of the current configuration. Default is `&quot;config&quot;`.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string | undefined} providedFilePath The path to the current configuration. Default is empty string.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigArrayFactoryLoadingContext} The created context.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">createContext(</span>
    <span class="s2">{ cwd, resolvePluginsRelativeTo },</span>
    <span class="s2">providedType,</span>
    <span class="s2">providedName,</span>
    <span class="s2">providedFilePath,</span>
    <span class="s2">providedMatchBasePath</span>
<span class="s2">) {</span>
    <span class="s3">const </span><span class="s2">filePath = providedFilePath</span>
        <span class="s2">? path.resolve(cwd, providedFilePath)</span>
        <span class="s2">: </span><span class="s4">&quot;&quot;</span><span class="s2">;</span>
    <span class="s3">const </span><span class="s2">matchBasePath =</span>
        <span class="s2">(providedMatchBasePath &amp;&amp; path.resolve(cwd, providedMatchBasePath)) ||</span>
        <span class="s2">(filePath &amp;&amp; path.dirname(filePath)) ||</span>
        <span class="s2">cwd;</span>
    <span class="s3">const </span><span class="s2">name =</span>
        <span class="s2">providedName ||</span>
        <span class="s2">(filePath &amp;&amp; path.relative(cwd, filePath)) ||</span>
        <span class="s4">&quot;&quot;</span><span class="s2">;</span>
    <span class="s3">const </span><span class="s2">pluginBasePath =</span>
        <span class="s2">resolvePluginsRelativeTo ||</span>
        <span class="s2">(filePath &amp;&amp; path.dirname(filePath)) ||</span>
        <span class="s2">cwd;</span>
    <span class="s3">const </span><span class="s2">type = providedType || </span><span class="s4">&quot;config&quot;</span><span class="s2">;</span>

    <span class="s3">return </span><span class="s2">{ filePath, matchBasePath, name, pluginBasePath, type };</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Normalize a given plugin.</span>
 <span class="s0">* - Ensure the object to have four properties: configs, environments, processors, and rules.</span>
 <span class="s0">* - Ensure the object to not have other properties.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Plugin} plugin The plugin to normalize.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Plugin} The normalized plugin.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">normalizePlugin(plugin) {</span>

    <span class="s0">// first check the cache</span>
    <span class="s3">let </span><span class="s2">normalizedPlugin = normalizedPlugins.get(plugin);</span>

    <span class="s3">if </span><span class="s2">(normalizedPlugin) {</span>
        <span class="s3">return </span><span class="s2">normalizedPlugin;</span>
    <span class="s2">}</span>

    <span class="s2">normalizedPlugin = {</span>
        <span class="s2">configs: plugin.configs || {},</span>
        <span class="s2">environments: plugin.environments || {},</span>
        <span class="s2">processors: plugin.processors || {},</span>
        <span class="s2">rules: plugin.rules || {}</span>
    <span class="s2">};</span>

    <span class="s0">// save the reference for later</span>
    <span class="s2">normalizedPlugins.set(plugin, normalizedPlugin);</span>

    <span class="s3">return </span><span class="s2">normalizedPlugin;</span>
<span class="s2">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Public Interface</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* The factory of `ConfigArray` objects.</span>
 <span class="s0">*/</span>
<span class="s3">class </span><span class="s2">ConfigArrayFactory {</span>

    <span class="s0">/**</span>
     <span class="s0">* Initialize this instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryOptions} [options] The map for additional plugins.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor({</span>
        <span class="s2">additionalPluginPool = </span><span class="s3">new </span><span class="s2">Map(),</span>
        <span class="s2">cwd = process.cwd(),</span>
        <span class="s2">resolvePluginsRelativeTo,</span>
        <span class="s2">builtInRules,</span>
        <span class="s2">resolver = ModuleResolver,</span>
        <span class="s2">eslintAllPath,</span>
        <span class="s2">getEslintAllConfig,</span>
        <span class="s2">eslintRecommendedPath,</span>
        <span class="s2">getEslintRecommendedConfig</span>
    <span class="s2">} = {}) {</span>
        <span class="s2">internalSlotsMap.set(</span><span class="s3">this</span><span class="s2">, {</span>
            <span class="s2">additionalPluginPool,</span>
            <span class="s2">cwd,</span>
            <span class="s2">resolvePluginsRelativeTo:</span>
                <span class="s2">resolvePluginsRelativeTo &amp;&amp;</span>
                <span class="s2">path.resolve(cwd, resolvePluginsRelativeTo),</span>
            <span class="s2">builtInRules,</span>
            <span class="s2">resolver,</span>
            <span class="s2">eslintAllPath,</span>
            <span class="s2">getEslintAllConfig,</span>
            <span class="s2">eslintRecommendedPath,</span>
            <span class="s2">getEslintRecommendedConfig</span>
        <span class="s2">});</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Create `ConfigArray` instance from a config data.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigData|null} configData The config data to create.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} [options] The options.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} [options.filePath] The path to this config data.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} [options.name] The config name.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigArray} Loaded config.</span>
     <span class="s0">*/</span>
    <span class="s2">create(configData, { basePath, filePath, name } = {}) {</span>
        <span class="s3">if </span><span class="s2">(!configData) {</span>
            <span class="s3">return new </span><span class="s2">ConfigArray();</span>
        <span class="s2">}</span>

        <span class="s3">const </span><span class="s2">slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">ctx = createContext(slots, </span><span class="s4">&quot;config&quot;</span><span class="s2">, name, filePath, basePath);</span>
        <span class="s3">const </span><span class="s2">elements = </span><span class="s3">this</span><span class="s2">._normalizeConfigData(configData, ctx);</span>

        <span class="s3">return new </span><span class="s2">ConfigArray(...elements);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load a config file.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The path to a config file.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} [options] The options.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} [options.name] The config name.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigArray} Loaded config.</span>
     <span class="s0">*/</span>
    <span class="s2">loadFile(filePath, { basePath, name } = {}) {</span>
        <span class="s3">const </span><span class="s2">slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">ctx = createContext(slots, </span><span class="s4">&quot;config&quot;</span><span class="s2">, name, filePath, basePath);</span>

        <span class="s3">return new </span><span class="s2">ConfigArray(...</span><span class="s3">this</span><span class="s2">._loadConfigData(ctx));</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load the config file on a given directory if exists.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} directoryPath The path to a directory.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} [options] The options.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} [options.name] The config name.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the config file is invalid.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.</span>
     <span class="s0">*/</span>
    <span class="s2">loadInDirectory(directoryPath, { basePath, name } = {}) {</span>
        <span class="s3">const </span><span class="s2">slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>

        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">filename of configFilenames) {</span>
            <span class="s3">const </span><span class="s2">ctx = createContext(</span>
                <span class="s2">slots,</span>
                <span class="s4">&quot;config&quot;</span><span class="s2">,</span>
                <span class="s2">name,</span>
                <span class="s2">path.join(directoryPath, filename),</span>
                <span class="s2">basePath</span>
            <span class="s2">);</span>

            <span class="s3">if </span><span class="s2">(fs.existsSync(ctx.filePath) &amp;&amp; fs.statSync(ctx.filePath).isFile()) {</span>
                <span class="s3">let </span><span class="s2">configData;</span>

                <span class="s3">try </span><span class="s2">{</span>
                    <span class="s2">configData = loadConfigFile(ctx.filePath);</span>
                <span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>
                    <span class="s3">if </span><span class="s2">(!error || error.code !== </span><span class="s4">&quot;ESLINT_CONFIG_FIELD_NOT_FOUND&quot;</span><span class="s2">) {</span>
                        <span class="s3">throw </span><span class="s2">error;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>

                <span class="s3">if </span><span class="s2">(configData) {</span>
                    <span class="s2">debug(</span><span class="s4">`Config file found: </span><span class="s2">${ctx.filePath}</span><span class="s4">`</span><span class="s2">);</span>
                    <span class="s3">return new </span><span class="s2">ConfigArray(</span>
                        <span class="s2">...</span><span class="s3">this</span><span class="s2">._normalizeConfigData(configData, ctx)</span>
                    <span class="s2">);</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>

        <span class="s2">debug(</span><span class="s4">`Config file not found on </span><span class="s2">${directoryPath}</span><span class="s4">`</span><span class="s2">);</span>
        <span class="s3">return new </span><span class="s2">ConfigArray();</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Check if a config file on a given directory exists or not.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} directoryPath The path to a directory.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string | null} The path to the found config file. If not found then null.</span>
     <span class="s0">*/</span>
    <span class="s3">static </span><span class="s2">getPathToConfigFileInDirectory(directoryPath) {</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">filename of configFilenames) {</span>
            <span class="s3">const </span><span class="s2">filePath = path.join(directoryPath, filename);</span>

            <span class="s3">if </span><span class="s2">(fs.existsSync(filePath)) {</span>
                <span class="s3">if </span><span class="s2">(filename === </span><span class="s4">&quot;package.json&quot;</span><span class="s2">) {</span>
                    <span class="s3">try </span><span class="s2">{</span>
                        <span class="s2">loadPackageJSONConfigFile(filePath);</span>
                        <span class="s3">return </span><span class="s2">filePath;</span>
                    <span class="s2">} </span><span class="s3">catch </span><span class="s2">{ </span><span class="s0">/* ignore */ </span><span class="s2">}</span>
                <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                    <span class="s3">return </span><span class="s2">filePath;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">return null</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load `.eslintignore` file.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The path to a `.eslintignore` file to load.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.</span>
     <span class="s0">*/</span>
    <span class="s2">loadESLintIgnore(filePath) {</span>
        <span class="s3">const </span><span class="s2">slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">ctx = createContext(</span>
            <span class="s2">slots,</span>
            <span class="s4">&quot;ignore&quot;</span><span class="s2">,</span>
            <span class="s3">void </span><span class="s7">0</span><span class="s2">,</span>
            <span class="s2">filePath,</span>
            <span class="s2">slots.cwd</span>
        <span class="s2">);</span>
        <span class="s3">const </span><span class="s2">ignorePatterns = loadESLintIgnoreFile(ctx.filePath);</span>

        <span class="s3">return new </span><span class="s2">ConfigArray(</span>
            <span class="s2">...</span><span class="s3">this</span><span class="s2">._normalizeESLintIgnoreData(ignorePatterns, ctx)</span>
        <span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load `.eslintignore` file in the current working directory.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the ignore file is invalid.</span>
     <span class="s0">*/</span>
    <span class="s2">loadDefaultESLintIgnore() {</span>
        <span class="s3">const </span><span class="s2">slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">eslintIgnorePath = path.resolve(slots.cwd, </span><span class="s4">&quot;.eslintignore&quot;</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">packageJsonPath = path.resolve(slots.cwd, </span><span class="s4">&quot;package.json&quot;</span><span class="s2">);</span>

        <span class="s3">if </span><span class="s2">(fs.existsSync(eslintIgnorePath)) {</span>
            <span class="s3">return this</span><span class="s2">.loadESLintIgnore(eslintIgnorePath);</span>
        <span class="s2">}</span>
        <span class="s3">if </span><span class="s2">(fs.existsSync(packageJsonPath)) {</span>
            <span class="s3">const </span><span class="s2">data = loadJSONConfigFile(packageJsonPath);</span>

            <span class="s3">if </span><span class="s2">(Object.hasOwn(data, </span><span class="s4">&quot;eslintIgnore&quot;</span><span class="s2">)) {</span>
                <span class="s3">if </span><span class="s2">(!Array.isArray(data.eslintIgnore)) {</span>
                    <span class="s3">throw new </span><span class="s2">Error(</span><span class="s4">&quot;Package.json eslintIgnore property requires an array of paths&quot;</span><span class="s2">);</span>
                <span class="s2">}</span>
                <span class="s3">const </span><span class="s2">ctx = createContext(</span>
                    <span class="s2">slots,</span>
                    <span class="s4">&quot;ignore&quot;</span><span class="s2">,</span>
                    <span class="s4">&quot;eslintIgnore in package.json&quot;</span><span class="s2">,</span>
                    <span class="s2">packageJsonPath,</span>
                    <span class="s2">slots.cwd</span>
                <span class="s2">);</span>

                <span class="s3">return new </span><span class="s2">ConfigArray(</span>
                    <span class="s2">...</span><span class="s3">this</span><span class="s2">._normalizeESLintIgnoreData(data.eslintIgnore, ctx)</span>
                <span class="s2">);</span>
            <span class="s2">}</span>
        <span class="s2">}</span>

        <span class="s3">return new </span><span class="s2">ConfigArray();</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load a given config file.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} Loaded config.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">_loadConfigData(ctx) {</span>
        <span class="s3">return this</span><span class="s2">._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Normalize a given `.eslintignore` data to config array elements.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string[]} ignorePatterns The patterns to ignore files.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">*_normalizeESLintIgnoreData(ignorePatterns, ctx) {</span>
        <span class="s3">const </span><span class="s2">elements = </span><span class="s3">this</span><span class="s2">._normalizeObjectConfigData(</span>
            <span class="s2">{ ignorePatterns },</span>
            <span class="s2">ctx</span>
        <span class="s2">);</span>

        <span class="s0">// Set `ignorePattern.loose` flag for backward compatibility.</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">element of elements) {</span>
            <span class="s3">if </span><span class="s2">(element.ignorePattern) {</span>
                <span class="s2">element.ignorePattern.loose = </span><span class="s3">true</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s3">yield </span><span class="s2">element;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Normalize a given config to an array.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigData} configData The config data to normalize.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">_normalizeConfigData(configData, ctx) {</span>
        <span class="s3">const </span><span class="s2">validator = </span><span class="s3">new </span><span class="s2">ConfigValidator();</span>

        <span class="s2">validator.validateConfigSchema(configData, ctx.name || ctx.filePath);</span>
        <span class="s3">return this</span><span class="s2">._normalizeObjectConfigData(configData, ctx);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Normalize a given config to an array.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigData|OverrideConfigData} configData The config data to normalize.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">*_normalizeObjectConfigData(configData, ctx) {</span>
        <span class="s3">const </span><span class="s2">{ files, excludedFiles, ...configBody } = configData;</span>
        <span class="s3">const </span><span class="s2">criteria = OverrideTester.create(</span>
            <span class="s2">files,</span>
            <span class="s2">excludedFiles,</span>
            <span class="s2">ctx.matchBasePath</span>
        <span class="s2">);</span>
        <span class="s3">const </span><span class="s2">elements = </span><span class="s3">this</span><span class="s2">._normalizeObjectConfigDataBody(configBody, ctx);</span>

        <span class="s0">// Apply the criteria to every element.</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">element of elements) {</span>

            <span class="s0">/* 
             * Merge the criteria. 
             * This is for the `overrides` entries that came from the 
             * configurations of `overrides[].extends`. 
             */</span>
            <span class="s2">element.criteria = OverrideTester.and(criteria, element.criteria);</span>

            <span class="s0">/* 
             * Remove `root` property to ignore `root` settings which came from 
             * `extends` in `overrides`. 
             */</span>
            <span class="s3">if </span><span class="s2">(element.criteria) {</span>
                <span class="s2">element.root = </span><span class="s3">void </span><span class="s7">0</span><span class="s2">;</span>
            <span class="s2">}</span>

            <span class="s3">yield </span><span class="s2">element;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Normalize a given config to an array.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigData} configData The config data to normalize.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">*_normalizeObjectConfigDataBody(</span>
        <span class="s2">{</span>
            <span class="s2">env,</span>
            <span class="s3">extends</span><span class="s2">: extend,</span>
            <span class="s2">globals,</span>
            <span class="s2">ignorePatterns,</span>
            <span class="s2">noInlineConfig,</span>
            <span class="s2">parser: parserName,</span>
            <span class="s2">parserOptions,</span>
            <span class="s2">plugins: pluginList,</span>
            <span class="s2">processor,</span>
            <span class="s2">reportUnusedDisableDirectives,</span>
            <span class="s2">root,</span>
            <span class="s2">rules,</span>
            <span class="s2">settings,</span>
            <span class="s2">overrides: overrideList = []</span>
        <span class="s2">},</span>
        <span class="s2">ctx</span>
    <span class="s2">) {</span>
        <span class="s3">const </span><span class="s2">extendList = Array.isArray(extend) ? extend : [extend];</span>
        <span class="s3">const </span><span class="s2">ignorePattern = ignorePatterns &amp;&amp; </span><span class="s3">new </span><span class="s2">IgnorePattern(</span>
            <span class="s2">Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],</span>
            <span class="s2">ctx.matchBasePath</span>
        <span class="s2">);</span>

        <span class="s0">// Flatten `extends`.</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">extendName of extendList.filter(Boolean)) {</span>
            <span class="s3">yield</span><span class="s2">* </span><span class="s3">this</span><span class="s2">._loadExtends(extendName, ctx);</span>
        <span class="s2">}</span>

        <span class="s0">// Load parser &amp; plugins.</span>
        <span class="s3">const </span><span class="s2">parser = parserName &amp;&amp; </span><span class="s3">this</span><span class="s2">._loadParser(parserName, ctx);</span>
        <span class="s3">const </span><span class="s2">plugins = pluginList &amp;&amp; </span><span class="s3">this</span><span class="s2">._loadPlugins(pluginList, ctx);</span>

        <span class="s0">// Yield pseudo config data for file extension processors.</span>
        <span class="s3">if </span><span class="s2">(plugins) {</span>
            <span class="s3">yield</span><span class="s2">* </span><span class="s3">this</span><span class="s2">._takeFileExtensionProcessors(plugins, ctx);</span>
        <span class="s2">}</span>

        <span class="s0">// Yield the config data except `extends` and `overrides`.</span>
        <span class="s3">yield </span><span class="s2">{</span>

            <span class="s0">// Debug information.</span>
            <span class="s2">type: ctx.type,</span>
            <span class="s2">name: ctx.name,</span>
            <span class="s2">filePath: ctx.filePath,</span>

            <span class="s0">// Config data.</span>
            <span class="s2">criteria: </span><span class="s3">null</span><span class="s2">,</span>
            <span class="s2">env,</span>
            <span class="s2">globals,</span>
            <span class="s2">ignorePattern,</span>
            <span class="s2">noInlineConfig,</span>
            <span class="s2">parser,</span>
            <span class="s2">parserOptions,</span>
            <span class="s2">plugins,</span>
            <span class="s2">processor,</span>
            <span class="s2">reportUnusedDisableDirectives,</span>
            <span class="s2">root,</span>
            <span class="s2">rules,</span>
            <span class="s2">settings</span>
        <span class="s2">};</span>

        <span class="s0">// Flatten `overries`.</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s7">0</span><span class="s2">; i &lt; overrideList.length; ++i) {</span>
            <span class="s3">yield</span><span class="s2">* </span><span class="s3">this</span><span class="s2">._normalizeObjectConfigData(</span>
                <span class="s2">overrideList[i],</span>
                <span class="s2">{ ...ctx, name: </span><span class="s4">`</span><span class="s2">${ctx.name}</span><span class="s4">#overrides[</span><span class="s2">${i}</span><span class="s4">]` </span><span class="s2">}</span>
            <span class="s2">);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load configs of an element in `extends`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} extendName The name of a base config.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the extended config file can't be loaded.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">_loadExtends(extendName, ctx) {</span>
        <span class="s2">debug(</span><span class="s4">&quot;Loading {extends:%j} relative to %s&quot;</span><span class="s2">, extendName, ctx.filePath);</span>
        <span class="s3">try </span><span class="s2">{</span>
            <span class="s3">if </span><span class="s2">(extendName.startsWith(</span><span class="s4">&quot;eslint:&quot;</span><span class="s2">)) {</span>
                <span class="s3">return this</span><span class="s2">._loadExtendedBuiltInConfig(extendName, ctx);</span>
            <span class="s2">}</span>
            <span class="s3">if </span><span class="s2">(extendName.startsWith(</span><span class="s4">&quot;plugin:&quot;</span><span class="s2">)) {</span>
                <span class="s3">return this</span><span class="s2">._loadExtendedPluginConfig(extendName, ctx);</span>
            <span class="s2">}</span>
            <span class="s3">return this</span><span class="s2">._loadExtendedShareableConfig(extendName, ctx);</span>
        <span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>
            <span class="s2">error.message += </span><span class="s4">`</span><span class="s6">\n</span><span class="s4">Referenced from: </span><span class="s2">${ctx.filePath || ctx.name}</span><span class="s4">`</span><span class="s2">;</span>
            <span class="s3">throw </span><span class="s2">error;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load configs of an element in `extends`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} extendName The name of a base config.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the extended config file can't be loaded.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">_loadExtendedBuiltInConfig(extendName, ctx) {</span>
        <span class="s3">const </span><span class="s2">{</span>
            <span class="s2">eslintAllPath,</span>
            <span class="s2">getEslintAllConfig,</span>
            <span class="s2">eslintRecommendedPath,</span>
            <span class="s2">getEslintRecommendedConfig</span>
        <span class="s2">} = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>

        <span class="s3">if </span><span class="s2">(extendName === </span><span class="s4">&quot;eslint:recommended&quot;</span><span class="s2">) {</span>
            <span class="s3">const </span><span class="s2">name = </span><span class="s4">`</span><span class="s2">${ctx.name} </span><span class="s4"> </span><span class="s2">${extendName}</span><span class="s4">`</span><span class="s2">;</span>

            <span class="s3">if </span><span class="s2">(getEslintRecommendedConfig) {</span>
                <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">getEslintRecommendedConfig !== </span><span class="s4">&quot;function&quot;</span><span class="s2">) {</span>
                    <span class="s3">throw new </span><span class="s2">Error(</span><span class="s4">`getEslintRecommendedConfig must be a function instead of '</span><span class="s2">${getEslintRecommendedConfig}</span><span class="s4">'`</span><span class="s2">);</span>
                <span class="s2">}</span>
                <span class="s3">return this</span><span class="s2">._normalizeConfigData(getEslintRecommendedConfig(), { ...ctx, name, filePath: </span><span class="s4">&quot;&quot; </span><span class="s2">});</span>
            <span class="s2">}</span>
            <span class="s3">return this</span><span class="s2">._loadConfigData({</span>
                <span class="s2">...ctx,</span>
                <span class="s2">name,</span>
                <span class="s2">filePath: eslintRecommendedPath</span>
            <span class="s2">});</span>
        <span class="s2">}</span>
        <span class="s3">if </span><span class="s2">(extendName === </span><span class="s4">&quot;eslint:all&quot;</span><span class="s2">) {</span>
            <span class="s3">const </span><span class="s2">name = </span><span class="s4">`</span><span class="s2">${ctx.name} </span><span class="s4"> </span><span class="s2">${extendName}</span><span class="s4">`</span><span class="s2">;</span>

            <span class="s3">if </span><span class="s2">(getEslintAllConfig) {</span>
                <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">getEslintAllConfig !== </span><span class="s4">&quot;function&quot;</span><span class="s2">) {</span>
                    <span class="s3">throw new </span><span class="s2">Error(</span><span class="s4">`getEslintAllConfig must be a function instead of '</span><span class="s2">${getEslintAllConfig}</span><span class="s4">'`</span><span class="s2">);</span>
                <span class="s2">}</span>
                <span class="s3">return this</span><span class="s2">._normalizeConfigData(getEslintAllConfig(), { ...ctx, name, filePath: </span><span class="s4">&quot;&quot; </span><span class="s2">});</span>
            <span class="s2">}</span>
            <span class="s3">return this</span><span class="s2">._loadConfigData({</span>
                <span class="s2">...ctx,</span>
                <span class="s2">name,</span>
                <span class="s2">filePath: eslintAllPath</span>
            <span class="s2">});</span>
        <span class="s2">}</span>

        <span class="s3">throw </span><span class="s2">configInvalidError(extendName, ctx.name, </span><span class="s4">&quot;extend-config-missing&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load configs of an element in `extends`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} extendName The name of a base config.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the extended config file can't be loaded.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">_loadExtendedPluginConfig(extendName, ctx) {</span>
        <span class="s3">const </span><span class="s2">slashIndex = extendName.lastIndexOf(</span><span class="s4">&quot;/&quot;</span><span class="s2">);</span>

        <span class="s3">if </span><span class="s2">(slashIndex === -</span><span class="s7">1</span><span class="s2">) {</span>
            <span class="s3">throw </span><span class="s2">configInvalidError(extendName, ctx.filePath, </span><span class="s4">&quot;plugin-invalid&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>

        <span class="s3">const </span><span class="s2">pluginName = extendName.slice(</span><span class="s4">&quot;plugin:&quot;</span><span class="s2">.length, slashIndex);</span>
        <span class="s3">const </span><span class="s2">configName = extendName.slice(slashIndex + </span><span class="s7">1</span><span class="s2">);</span>

        <span class="s3">if </span><span class="s2">(isFilePath(pluginName)) {</span>
            <span class="s3">throw new </span><span class="s2">Error(</span><span class="s4">&quot;'extends' cannot use a file path for plugins.&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>

        <span class="s3">const </span><span class="s2">plugin = </span><span class="s3">this</span><span class="s2">._loadPlugin(pluginName, ctx);</span>
        <span class="s3">const </span><span class="s2">configData =</span>
            <span class="s2">plugin.definition &amp;&amp;</span>
            <span class="s2">plugin.definition.configs[configName];</span>

        <span class="s3">if </span><span class="s2">(configData) {</span>
            <span class="s3">return this</span><span class="s2">._normalizeConfigData(configData, {</span>
                <span class="s2">...ctx,</span>
                <span class="s2">filePath: plugin.filePath || ctx.filePath,</span>
                <span class="s2">name: </span><span class="s4">`</span><span class="s2">${ctx.name} </span><span class="s4"> plugin:</span><span class="s2">${plugin.id}</span><span class="s4">/</span><span class="s2">${configName}</span><span class="s4">`</span>
            <span class="s2">});</span>
        <span class="s2">}</span>

        <span class="s3">throw </span><span class="s2">plugin.error || configInvalidError(extendName, ctx.filePath, </span><span class="s4">&quot;extend-config-missing&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load configs of an element in `extends`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} extendName The name of a base config.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the extended config file can't be loaded.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">_loadExtendedShareableConfig(extendName, ctx) {</span>
        <span class="s3">const </span><span class="s2">{ cwd, resolver } = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">relativeTo = ctx.filePath || path.join(cwd, </span><span class="s4">&quot;__placeholder__.js&quot;</span><span class="s2">);</span>
        <span class="s3">let </span><span class="s2">request;</span>

        <span class="s3">if </span><span class="s2">(isFilePath(extendName)) {</span>
            <span class="s2">request = extendName;</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(extendName.startsWith(</span><span class="s4">&quot;.&quot;</span><span class="s2">)) {</span>
            <span class="s2">request = </span><span class="s4">`./</span><span class="s2">${extendName}</span><span class="s4">`</span><span class="s2">; </span><span class="s0">// For backward compatibility. A ton of tests depended on this behavior.</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s2">request = naming.normalizePackageName(</span>
                <span class="s2">extendName,</span>
                <span class="s4">&quot;eslint-config&quot;</span>
            <span class="s2">);</span>
        <span class="s2">}</span>

        <span class="s3">let </span><span class="s2">filePath;</span>

        <span class="s3">try </span><span class="s2">{</span>
            <span class="s2">filePath = resolver.resolve(request, relativeTo);</span>
        <span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>
            <span class="s0">/* istanbul ignore else */</span>
            <span class="s3">if </span><span class="s2">(error &amp;&amp; error.code === </span><span class="s4">&quot;MODULE_NOT_FOUND&quot;</span><span class="s2">) {</span>
                <span class="s3">throw </span><span class="s2">configInvalidError(extendName, ctx.filePath, </span><span class="s4">&quot;extend-config-missing&quot;</span><span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s3">throw </span><span class="s2">error;</span>
        <span class="s2">}</span>

        <span class="s2">writeDebugLogForLoading(request, relativeTo, filePath);</span>
        <span class="s3">return this</span><span class="s2">._loadConfigData({</span>
            <span class="s2">...ctx,</span>
            <span class="s2">filePath,</span>
            <span class="s2">name: </span><span class="s4">`</span><span class="s2">${ctx.name} </span><span class="s4"> </span><span class="s2">${request}</span><span class="s4">`</span>
        <span class="s2">});</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load given plugins.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string[]} names The plugin names to load.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Record&lt;string,DependentPlugin&gt;} The loaded parser.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">_loadPlugins(names, ctx) {</span>
        <span class="s3">return </span><span class="s2">names.reduce((map, name) =&gt; {</span>
            <span class="s3">if </span><span class="s2">(isFilePath(name)) {</span>
                <span class="s3">throw new </span><span class="s2">Error(</span><span class="s4">&quot;Plugins array cannot includes file paths.&quot;</span><span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s3">const </span><span class="s2">plugin = </span><span class="s3">this</span><span class="s2">._loadPlugin(name, ctx);</span>

            <span class="s2">map[plugin.id] = plugin;</span>

            <span class="s3">return </span><span class="s2">map;</span>
        <span class="s2">}, {});</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load a given parser.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} nameOrPath The package name or the path to a parser file.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{DependentParser} The loaded parser.</span>
     <span class="s0">*/</span>
    <span class="s2">_loadParser(nameOrPath, ctx) {</span>
        <span class="s2">debug(</span><span class="s4">&quot;Loading parser %j from %s&quot;</span><span class="s2">, nameOrPath, ctx.filePath);</span>

        <span class="s3">const </span><span class="s2">{ cwd, resolver } = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">relativeTo = ctx.filePath || path.join(cwd, </span><span class="s4">&quot;__placeholder__.js&quot;</span><span class="s2">);</span>

        <span class="s3">try </span><span class="s2">{</span>
            <span class="s3">const </span><span class="s2">filePath = resolver.resolve(nameOrPath, relativeTo);</span>

            <span class="s2">writeDebugLogForLoading(nameOrPath, relativeTo, filePath);</span>

            <span class="s3">return new </span><span class="s2">ConfigDependency({</span>
                <span class="s2">definition: require(filePath),</span>
                <span class="s2">filePath,</span>
                <span class="s2">id: nameOrPath,</span>
                <span class="s2">importerName: ctx.name,</span>
                <span class="s2">importerPath: ctx.filePath</span>
            <span class="s2">});</span>
        <span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>

            <span class="s0">// If the parser name is &quot;espree&quot;, load the espree of ESLint.</span>
            <span class="s3">if </span><span class="s2">(nameOrPath === </span><span class="s4">&quot;espree&quot;</span><span class="s2">) {</span>
                <span class="s2">debug(</span><span class="s4">&quot;Fallback espree.&quot;</span><span class="s2">);</span>
                <span class="s3">return new </span><span class="s2">ConfigDependency({</span>
                    <span class="s2">definition: require(</span><span class="s4">&quot;espree&quot;</span><span class="s2">),</span>
                    <span class="s2">filePath: require.resolve(</span><span class="s4">&quot;espree&quot;</span><span class="s2">),</span>
                    <span class="s2">id: nameOrPath,</span>
                    <span class="s2">importerName: ctx.name,</span>
                    <span class="s2">importerPath: ctx.filePath</span>
                <span class="s2">});</span>
            <span class="s2">}</span>

            <span class="s2">debug(</span><span class="s4">&quot;Failed to load parser '%s' declared in '%s'.&quot;</span><span class="s2">, nameOrPath, ctx.name);</span>
            <span class="s2">error.message = </span><span class="s4">`Failed to load parser '</span><span class="s2">${nameOrPath}</span><span class="s4">' declared in '</span><span class="s2">${ctx.name}</span><span class="s4">': </span><span class="s2">${error.message}</span><span class="s4">`</span><span class="s2">;</span>

            <span class="s3">return new </span><span class="s2">ConfigDependency({</span>
                <span class="s2">error,</span>
                <span class="s2">id: nameOrPath,</span>
                <span class="s2">importerName: ctx.name,</span>
                <span class="s2">importerPath: ctx.filePath</span>
            <span class="s2">});</span>
        <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Load a given plugin.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name The plugin name to load.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{DependentPlugin} The loaded plugin.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">_loadPlugin(name, ctx) {</span>
        <span class="s2">debug(</span><span class="s4">&quot;Loading plugin %j from %s&quot;</span><span class="s2">, name, ctx.filePath);</span>

        <span class="s3">const </span><span class="s2">{ additionalPluginPool, resolver } = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">request = naming.normalizePackageName(name, </span><span class="s4">&quot;eslint-plugin&quot;</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">id = naming.getShorthandName(request, </span><span class="s4">&quot;eslint-plugin&quot;</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">relativeTo = path.join(ctx.pluginBasePath, </span><span class="s4">&quot;__placeholder__.js&quot;</span><span class="s2">);</span>

        <span class="s3">if </span><span class="s2">(name.match(</span><span class="s5">/\s+/u</span><span class="s2">)) {</span>
            <span class="s3">const </span><span class="s2">error = Object.assign(</span>
                <span class="s3">new </span><span class="s2">Error(</span><span class="s4">`Whitespace found in plugin name '</span><span class="s2">${name}</span><span class="s4">'`</span><span class="s2">),</span>
                <span class="s2">{</span>
                    <span class="s2">messageTemplate: </span><span class="s4">&quot;whitespace-found&quot;</span><span class="s2">,</span>
                    <span class="s2">messageData: { pluginName: request }</span>
                <span class="s2">}</span>
            <span class="s2">);</span>

            <span class="s3">return new </span><span class="s2">ConfigDependency({</span>
                <span class="s2">error,</span>
                <span class="s2">id,</span>
                <span class="s2">importerName: ctx.name,</span>
                <span class="s2">importerPath: ctx.filePath</span>
            <span class="s2">});</span>
        <span class="s2">}</span>

        <span class="s0">// Check for additional pool.</span>
        <span class="s3">const </span><span class="s2">plugin =</span>
            <span class="s2">additionalPluginPool.get(request) ||</span>
            <span class="s2">additionalPluginPool.get(id);</span>

        <span class="s3">if </span><span class="s2">(plugin) {</span>
            <span class="s3">return new </span><span class="s2">ConfigDependency({</span>
                <span class="s2">definition: normalizePlugin(plugin),</span>
                <span class="s2">original: plugin,</span>
                <span class="s2">filePath: </span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s0">// It's unknown where the plugin came from.</span>
                <span class="s2">id,</span>
                <span class="s2">importerName: ctx.name,</span>
                <span class="s2">importerPath: ctx.filePath</span>
            <span class="s2">});</span>
        <span class="s2">}</span>

        <span class="s3">let </span><span class="s2">filePath;</span>
        <span class="s3">let </span><span class="s2">error;</span>

        <span class="s3">try </span><span class="s2">{</span>
            <span class="s2">filePath = resolver.resolve(request, relativeTo);</span>
        <span class="s2">} </span><span class="s3">catch </span><span class="s2">(resolveError) {</span>
            <span class="s2">error = resolveError;</span>
            <span class="s0">/* istanbul ignore else */</span>
            <span class="s3">if </span><span class="s2">(error &amp;&amp; error.code === </span><span class="s4">&quot;MODULE_NOT_FOUND&quot;</span><span class="s2">) {</span>
                <span class="s2">error.messageTemplate = </span><span class="s4">&quot;plugin-missing&quot;</span><span class="s2">;</span>
                <span class="s2">error.messageData = {</span>
                    <span class="s2">pluginName: request,</span>
                    <span class="s2">resolvePluginsRelativeTo: ctx.pluginBasePath,</span>
                    <span class="s2">importerName: ctx.name</span>
                <span class="s2">};</span>
            <span class="s2">}</span>
        <span class="s2">}</span>

        <span class="s3">if </span><span class="s2">(filePath) {</span>
            <span class="s3">try </span><span class="s2">{</span>
                <span class="s2">writeDebugLogForLoading(request, relativeTo, filePath);</span>

                <span class="s3">const </span><span class="s2">startTime = Date.now();</span>
                <span class="s3">const </span><span class="s2">pluginDefinition = require(filePath);</span>

                <span class="s2">debug(</span><span class="s4">`Plugin </span><span class="s2">${filePath} </span><span class="s4">loaded in: </span><span class="s2">${Date.now() - startTime}</span><span class="s4">ms`</span><span class="s2">);</span>

                <span class="s3">return new </span><span class="s2">ConfigDependency({</span>
                    <span class="s2">definition: normalizePlugin(pluginDefinition),</span>
                    <span class="s2">original: pluginDefinition,</span>
                    <span class="s2">filePath,</span>
                    <span class="s2">id,</span>
                    <span class="s2">importerName: ctx.name,</span>
                    <span class="s2">importerPath: ctx.filePath</span>
                <span class="s2">});</span>
            <span class="s2">} </span><span class="s3">catch </span><span class="s2">(loadError) {</span>
                <span class="s2">error = loadError;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>

        <span class="s2">debug(</span><span class="s4">&quot;Failed to load plugin '%s' declared in '%s'.&quot;</span><span class="s2">, name, ctx.name);</span>
        <span class="s2">error.message = </span><span class="s4">`Failed to load plugin '</span><span class="s2">${name}</span><span class="s4">' declared in '</span><span class="s2">${ctx.name}</span><span class="s4">': </span><span class="s2">${error.message}</span><span class="s4">`</span><span class="s2">;</span>
        <span class="s3">return new </span><span class="s2">ConfigDependency({</span>
            <span class="s2">error,</span>
            <span class="s2">id,</span>
            <span class="s2">importerName: ctx.name,</span>
            <span class="s2">importerPath: ctx.filePath</span>
        <span class="s2">});</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Take file expression processors as config array elements.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Record&lt;string,DependentPlugin&gt;} plugins The plugin definitions.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{IterableIterator&lt;ConfigArrayElement&gt;} The config array elements of file expression processors.</span>
     <span class="s0">* </span><span class="s1">@private</span>
     <span class="s0">*/</span>
    <span class="s2">*_takeFileExtensionProcessors(plugins, ctx) {</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">pluginId of Object.keys(plugins)) {</span>
            <span class="s3">const </span><span class="s2">processors =</span>
                <span class="s2">plugins[pluginId] &amp;&amp;</span>
                <span class="s2">plugins[pluginId].definition &amp;&amp;</span>
                <span class="s2">plugins[pluginId].definition.processors;</span>

            <span class="s3">if </span><span class="s2">(!processors) {</span>
                <span class="s3">continue</span><span class="s2">;</span>
            <span class="s2">}</span>

            <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">processorId of Object.keys(processors)) {</span>
                <span class="s3">if </span><span class="s2">(processorId.startsWith(</span><span class="s4">&quot;.&quot;</span><span class="s2">)) {</span>
                    <span class="s3">yield</span><span class="s2">* </span><span class="s3">this</span><span class="s2">._normalizeObjectConfigData(</span>
                        <span class="s2">{</span>
                            <span class="s2">files: [</span><span class="s4">`*</span><span class="s2">${processorId}</span><span class="s4">`</span><span class="s2">],</span>
                            <span class="s2">processor: </span><span class="s4">`</span><span class="s2">${pluginId}</span><span class="s4">/</span><span class="s2">${processorId}</span><span class="s4">`</span>
                        <span class="s2">},</span>
                        <span class="s2">{</span>
                            <span class="s2">...ctx,</span>
                            <span class="s2">type: </span><span class="s4">&quot;implicit-processor&quot;</span><span class="s2">,</span>
                            <span class="s2">name: </span><span class="s4">`</span><span class="s2">${ctx.name}</span><span class="s4">#processors[&quot;</span><span class="s2">${pluginId}</span><span class="s4">/</span><span class="s2">${processorId}</span><span class="s4">&quot;]`</span>
                        <span class="s2">}</span>
                    <span class="s2">);</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s3">export </span><span class="s2">{</span>
    <span class="s2">ConfigArrayFactory,</span>
    <span class="s2">createContext,</span>
    <span class="s2">loadConfigFile</span>
<span class="s2">};</span>
</pre>
</body>
</html>