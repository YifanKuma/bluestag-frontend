<html>
<head>
<title>parseIncompletePhoneNumber.test.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parseIncompletePhoneNumber.test.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">parseIncompletePhoneNumber, { parsePhoneNumberCharacter } from </span><span class="s2">'./parseIncompletePhoneNumber.js'</span>

<span class="s1">describe(</span><span class="s2">'parseIncompletePhoneNumber'</span><span class="s1">, () =&gt; {</span>
	<span class="s1">it(</span><span class="s2">'should fix `for ... of` loop coverage'</span><span class="s1">, () =&gt; {</span>
		<span class="s3">// For some weird reason, &quot;istanbul&quot; doesn't know how to properly cover</span>
		<span class="s3">// a `for ... of` loop that has been transpiled with Babel.</span>
		<span class="s3">// For some reason, it attempts to cover the `for ... of` polyfill coode too,</span>
		<span class="s3">// meaning that it complains if that polyfill's edge case is not covered.</span>
		<span class="s3">// This test case works around that weird bug by covering that edge case of the polyfill.</span>
		<span class="s3">//</span>
		<span class="s3">// When it runs `npm test` command, it does so without `babel` transpilation,</span>
		<span class="s3">// so the error is gonna be &quot;string.split is not a function or its return value is not iterable&quot;.</span>
		<span class="s3">//</span>
		<span class="s3">// When it runs `npm run test-coverage` command, it does so with `babel` transpilation,</span>
		<span class="s3">// so the error is gonna be &quot;Invalid attempt to iterate non-iterable instance.&quot;.</span>
		<span class="s3">//</span>
		<span class="s1">expect(() =&gt; {</span>
			<span class="s1">parseIncompletePhoneNumber({</span>
				<span class="s1">split: () =&gt; </span><span class="s4">123</span>
			<span class="s1">})</span>
		<span class="s1">}).to.throw(</span><span class="s5">/(not iterable|non-iterable)/</span><span class="s1">)</span>
	<span class="s1">})</span>

	<span class="s1">it(</span><span class="s2">'should parse phone number character'</span><span class="s1">, () =&gt; {</span>
		<span class="s3">// Accepts leading `+`.</span>
		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'+'</span><span class="s1">)).to.equal(</span><span class="s2">'+'</span><span class="s1">)</span>

		<span class="s3">// Doesn't accept non-leading `+`.</span>
		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'+'</span><span class="s1">, </span><span class="s2">'+'</span><span class="s1">)).to.be.undefined</span>

		<span class="s3">// Parses digits.</span>
		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'1'</span><span class="s1">)).to.equal(</span><span class="s2">'1'</span><span class="s1">)</span>

		<span class="s3">// Parses non-European digits.</span>
		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'٤'</span><span class="s1">)).to.equal(</span><span class="s2">'4'</span><span class="s1">)</span>

		<span class="s3">// Dismisses other characters.</span>
		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'-'</span><span class="s1">)).to.be.undefined</span>
	<span class="s1">})</span>

	<span class="s1">it(</span><span class="s2">'should parse incomplete phone number'</span><span class="s1">, () =&gt; {</span>
		<span class="s1">expect(parseIncompletePhoneNumber(</span><span class="s2">''</span><span class="s1">)).to.equal(</span><span class="s2">''</span><span class="s1">)</span>

		<span class="s3">// Doesn't accept non-leading `+`.</span>
		<span class="s1">expect(parseIncompletePhoneNumber(</span><span class="s2">'++'</span><span class="s1">)).to.equal(</span><span class="s2">'+'</span><span class="s1">)</span>

		<span class="s3">// Accepts leading `+`.</span>
		<span class="s1">expect(parseIncompletePhoneNumber(</span><span class="s2">'+7 800 555'</span><span class="s1">)).to.equal(</span><span class="s2">'+7800555'</span><span class="s1">)</span>

		<span class="s3">// Parses digits.</span>
		<span class="s1">expect(parseIncompletePhoneNumber(</span><span class="s2">'8 (800) 555'</span><span class="s1">)).to.equal(</span><span class="s2">'8800555'</span><span class="s1">)</span>

		<span class="s3">// Parses non-European digits.</span>
		<span class="s1">expect(parseIncompletePhoneNumber(</span><span class="s2">'+٤٤٢٣٢٣٢٣٤'</span><span class="s1">)).to.equal(</span><span class="s2">'+442323234'</span><span class="s1">)</span>
	<span class="s1">})</span>

	<span class="s1">it(</span><span class="s2">'should work with a new `context` argument in `parsePhoneNumberCharacter()` function (international number)'</span><span class="s1">, () =&gt; {</span>
		<span class="s0">let </span><span class="s1">stopped = </span><span class="s0">false</span>

		<span class="s0">const </span><span class="s1">emit = (event) =&gt; {</span>
			<span class="s0">switch </span><span class="s1">(event) {</span>
				<span class="s0">case </span><span class="s2">'end'</span><span class="s1">:</span>
					<span class="s1">stopped = </span><span class="s0">true</span>
					<span class="s0">break</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'+'</span><span class="s1">, undefined, emit)).to.equal(</span><span class="s2">'+'</span><span class="s1">)</span>
		<span class="s1">expect(stopped).to.equal(</span><span class="s0">false</span><span class="s1">)</span>

		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'1'</span><span class="s1">, </span><span class="s2">'+'</span><span class="s1">, emit)).to.equal(</span><span class="s2">'1'</span><span class="s1">)</span>
		<span class="s1">expect(stopped).to.equal(</span><span class="s0">false</span><span class="s1">)</span>

		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'+'</span><span class="s1">, </span><span class="s2">'+1'</span><span class="s1">, emit)).to.be.undefined</span>
		<span class="s1">expect(stopped).to.equal(</span><span class="s0">true</span><span class="s1">)</span>

		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'2'</span><span class="s1">, </span><span class="s2">'+1'</span><span class="s1">, emit)).to.equal(</span><span class="s2">'2'</span><span class="s1">)</span>
		<span class="s1">expect(stopped).to.equal(</span><span class="s0">true</span><span class="s1">)</span>
	<span class="s1">})</span>

	<span class="s1">it(</span><span class="s2">'should work with a new `context` argument in `parsePhoneNumberCharacter()` function (national number)'</span><span class="s1">, () =&gt; {</span>
		<span class="s0">let </span><span class="s1">stopped = </span><span class="s0">false</span>

		<span class="s0">const </span><span class="s1">emit = (event) =&gt; {</span>
			<span class="s0">switch </span><span class="s1">(event) {</span>
				<span class="s0">case </span><span class="s2">'end'</span><span class="s1">:</span>
					<span class="s1">stopped = </span><span class="s0">true</span>
					<span class="s0">break</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'2'</span><span class="s1">, undefined, emit)).to.equal(</span><span class="s2">'2'</span><span class="s1">)</span>
		<span class="s1">expect(stopped).to.equal(</span><span class="s0">false</span><span class="s1">)</span>

		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'+'</span><span class="s1">, </span><span class="s2">'2'</span><span class="s1">, emit)).to.be.undefined</span>
		<span class="s1">expect(stopped).to.equal(</span><span class="s0">true</span><span class="s1">)</span>

		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'1'</span><span class="s1">, </span><span class="s2">'2'</span><span class="s1">, emit)).to.equal(</span><span class="s2">'1'</span><span class="s1">)</span>
		<span class="s1">expect(stopped).to.equal(</span><span class="s0">true</span><span class="s1">)</span>
	<span class="s1">})</span>

	<span class="s1">it(</span><span class="s2">'should call `eventListener` when the input ends abruptly'</span><span class="s1">, () =&gt; {</span>
		<span class="s0">let </span><span class="s1">parsingEnded = </span><span class="s0">false</span>
		<span class="s0">const </span><span class="s1">eventListener = (event) =&gt; {</span>
			<span class="s1">parsingEnded = </span><span class="s0">true</span><span class="s1">;</span>
			<span class="s0">if </span><span class="s1">(event !== </span><span class="s2">'end'</span><span class="s1">) {</span>
				<span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Unexpected event: </span><span class="s1">${event}</span><span class="s2">`</span><span class="s1">)</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s3">// Doesn't accept non-leading `+`.</span>
		<span class="s1">expect(parsePhoneNumberCharacter(</span><span class="s2">'+'</span><span class="s1">, </span><span class="s2">'+123'</span><span class="s1">, eventListener)).to.be.undefined</span>
		<span class="s1">expect(parsingEnded).to.equal(</span><span class="s0">true</span><span class="s1">)</span>
	<span class="s1">})</span>
<span class="s1">})</span></pre>
</body>
</html>