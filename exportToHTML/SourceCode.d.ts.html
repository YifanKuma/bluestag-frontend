<html>
<head>
<title>SourceCode.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
SourceCode.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { ParserServices, TSESTree } from </span><span class="s2">'../ts-estree'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { Parser } from </span><span class="s2">'./Parser'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { Scope } from </span><span class="s2">'./Scope'</span><span class="s1">;</span>
<span class="s1">declare </span><span class="s0">class </span><span class="s1">TokenStore {</span>
    <span class="s3">/**</span>
     <span class="s3">* Checks whether any comments exist or not between the given 2 nodes.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">left The node to check.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">right The node to check.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">`true` if one or more comments exist.</span>
     <span class="s3">*/</span>
    <span class="s1">commentsExistBetween(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token): boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets all comment tokens directly after the given node or token.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">nodeOrToken The AST node or token to check for adjacent comment tokens.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An array of comments in occurrence order.</span>
     <span class="s3">*/</span>
    <span class="s1">getCommentsAfter(nodeOrToken: TSESTree.Node | TSESTree.Token): TSESTree.Comment[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets all comment tokens directly before the given node or token.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">nodeOrToken The AST node or token to check for adjacent comment tokens.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An array of comments in occurrence order.</span>
     <span class="s3">*/</span>
    <span class="s1">getCommentsBefore(nodeOrToken: TSESTree.Node | TSESTree.Token): TSESTree.Comment[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets all comment tokens inside the given node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node to get the comments for.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An array of comments in occurrence order.</span>
     <span class="s3">*/</span>
    <span class="s1">getCommentsInside(node: TSESTree.Node): TSESTree.Comment[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the first token of the given node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An object representing the token.</span>
     <span class="s3">*/</span>
    <span class="s1">getFirstToken&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithSkipOptions&gt;(node: TSESTree.Node, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the first token between two non-overlapping nodes.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">left Node before the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">right Node after the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An object representing the token.</span>
     <span class="s3">*/</span>
    <span class="s1">getFirstTokenBetween&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithSkipOptions&gt;(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the first `count` tokens of the given node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.</span>
     <span class="s3">*/</span>
    <span class="s1">getFirstTokens&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithCountOptions&gt;(node: TSESTree.Node, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt;[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the first `count` tokens between two non-overlapping nodes.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">left Node before the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">right Node after the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">Tokens between left and right.</span>
     <span class="s3">*/</span>
    <span class="s1">getFirstTokensBetween&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithCountOptions&gt;(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt;[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the last token of the given node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An object representing the token.</span>
     <span class="s3">*/</span>
    <span class="s1">getLastToken&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithSkipOptions&gt;(node: TSESTree.Node, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the last token between two non-overlapping nodes.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">left Node before the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">right Node after the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An object representing the token.</span>
     <span class="s3">*/</span>
    <span class="s1">getLastTokenBetween&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithSkipOptions&gt;(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the last `count` tokens of the given node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.</span>
     <span class="s3">*/</span>
    <span class="s1">getLastTokens&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithCountOptions&gt;(node: TSESTree.Node, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt;[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the last `count` tokens between two non-overlapping nodes.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">left Node before the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">right Node after the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">Tokens between left and right.</span>
     <span class="s3">*/</span>
    <span class="s1">getLastTokensBetween&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithCountOptions&gt;(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt;[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the token that follows a given node or token.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node or token.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An object representing the token.</span>
     <span class="s3">*/</span>
    <span class="s1">getTokenAfter&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithSkipOptions&gt;(node: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the token that precedes a given node or token.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node or token.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An object representing the token.</span>
     <span class="s3">*/</span>
    <span class="s1">getTokenBefore&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithSkipOptions&gt;(node: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the token starting at the specified index.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">offset Index of the start of the token's range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The token starting at index, or null if no such token.</span>
     <span class="s3">*/</span>
    <span class="s1">getTokenByRangeStart&lt;T </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s1">includeComments?: boolean;</span>
    <span class="s1">}&gt;(offset: number, options?: T): SourceCode.ReturnTypeFromOptions&lt;T&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets all tokens that are related to the given node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">beforeCount The number of tokens before the node to retrieve.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">afterCount The number of tokens after the node to retrieve.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">Array of objects representing tokens.</span>
     <span class="s3">*/</span>
    <span class="s1">getTokens(node: TSESTree.Node, beforeCount?: number, afterCount?: number): TSESTree.Token[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets all tokens that are related to the given node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">Array of objects representing tokens.</span>
     <span class="s3">*/</span>
    <span class="s1">getTokens&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithCountOptions&gt;(node: TSESTree.Node, options: T): SourceCode.ReturnTypeFromOptions&lt;T&gt;[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the `count` tokens that follows a given node or token.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.</span>
     <span class="s3">*/</span>
    <span class="s1">getTokensAfter&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithCountOptions&gt;(node: TSESTree.Node | TSESTree.Token, options?: number | T): SourceCode.ReturnTypeFromOptions&lt;T&gt;[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the `count` tokens that precedes a given node or token.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.</span>
     <span class="s3">*/</span>
    <span class="s1">getTokensBefore&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithCountOptions&gt;(node: TSESTree.Node | TSESTree.Token, options?: number | T): SourceCode.ReturnTypeFromOptions&lt;T&gt;[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets all of the tokens between two non-overlapping nodes.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">left Node before the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">right Node after the desired token range.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">Tokens between left and right.</span>
     <span class="s3">*/</span>
    <span class="s1">getTokensBetween&lt;T </span><span class="s0">extends </span><span class="s1">SourceCode.CursorWithCountOptions&gt;(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: number | T): SourceCode.ReturnTypeFromOptions&lt;T&gt;[];</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s0">class </span><span class="s1">SourceCodeBase </span><span class="s0">extends </span><span class="s1">TokenStore {</span>
    <span class="s3">/**</span>
     <span class="s3">* Represents parsed source code.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor(text: string, ast: SourceCode.Program);</span>
    <span class="s3">/**</span>
     <span class="s3">* Represents parsed source code.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">config The config object.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor(config: SourceCode.SourceCodeConfig);</span>
    <span class="s3">/**</span>
     <span class="s3">* The parsed AST for the source code.</span>
     <span class="s3">*/</span>
    <span class="s1">ast: SourceCode.Program;</span>
    <span class="s1">applyInlineConfig(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">applyLanguageOptions(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">finalize(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Retrieves an array containing all comments in the source code.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">An array of comment nodes.</span>
     <span class="s3">*/</span>
    <span class="s1">getAllComments(): TSESTree.Comment[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Converts a (line, column) pair into a range index.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">location A line/column location</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The range index of the location in the file.</span>
     <span class="s3">*/</span>
    <span class="s1">getIndexFromLoc(location: TSESTree.Position): number;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the entire source text split into an array of lines.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The source text as an array of lines.</span>
     <span class="s3">*/</span>
    <span class="s1">getLines(): string[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Converts a source text index into a (line, column) pair.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">index The index of a character in a file</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">A {line, column} location object with a 0-indexed column</span>
     <span class="s3">*/</span>
    <span class="s1">getLocFromIndex(index: number): TSESTree.Position;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the deepest node containing a range index.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">index Range index of the desired node.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The node if found or `null` if not found.</span>
     <span class="s3">*/</span>
    <span class="s1">getNodeByRangeIndex(index: number): TSESTree.Node | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the source code for the given node.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The AST node to get the text for.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">beforeCount The number of characters before the node to retrieve.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">afterCount The number of characters after the node to retrieve.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The text representing the AST node.</span>
     <span class="s3">*/</span>
    <span class="s1">getText(node?: TSESTree.Node | TSESTree.Token, beforeCount?: number, afterCount?: number): string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The flag to indicate that the source code has Unicode BOM.</span>
     <span class="s3">*/</span>
    <span class="s1">hasBOM: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Determines if two nodes or tokens have at least one whitespace character</span>
     <span class="s3">* between them. Order does not matter. Returns false if the given nodes or</span>
     <span class="s3">* tokens overlap.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">first The first node or token to check between.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">second The second node or token to check between.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">True if there is a whitespace character between any of the tokens found between the two given nodes or tokens.</span>
     <span class="s3">*/</span>
    <span class="s1">isSpaceBetween(first: TSESTree.Node | TSESTree.Token, second: TSESTree.Node | TSESTree.Token): boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Determines if two nodes or tokens have at least one whitespace character</span>
     <span class="s3">* between them. Order does not matter. Returns false if the given nodes or</span>
     <span class="s3">* tokens overlap.</span>
     <span class="s3">* For backward compatibility, this method returns true if there are</span>
     <span class="s3">* `JSXText` tokens that contain whitespace between the two.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">first The first node or token to check between.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">second The second node or token to check between.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} True if there is a whitespace character between</span>
     <span class="s3">* any of the tokens found between the two given nodes or tokens.</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">in favor of isSpaceBetween</span>
     <span class="s3">*/</span>
    <span class="s1">isSpaceBetweenTokens(first: TSESTree.Token, second: TSESTree.Token): boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns the scope of the given node.</span>
     <span class="s3">* This information can be used track references to variables.</span>
     <span class="s3">*/</span>
    <span class="s1">getScope(node: TSESTree.Node): Scope.Scope;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns an array of the ancestors of the given node, starting at</span>
     <span class="s3">* the root of the AST and continuing through the direct parent of the current node.</span>
     <span class="s3">* This array does not include the currently-traversed node itself.</span>
     <span class="s3">*/</span>
    <span class="s1">getAncestors(node: TSESTree.Node): TSESTree.Node[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns a list of variables declared by the given node.</span>
     <span class="s3">* This information can be used to track references to variables.</span>
     <span class="s3">*/</span>
    <span class="s1">getDeclaredVariables(node: TSESTree.Node): readonly Scope.Variable[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Marks a variable with the given name in the current scope as used.</span>
     <span class="s3">* This affects the no-unused-vars rule.</span>
     <span class="s3">*/</span>
    <span class="s1">markVariableAsUsed(name: string, node: TSESTree.Node): boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* The source code split into lines according to ECMA-262 specification.</span>
     <span class="s3">* This is done to avoid each rule needing to do so separately.</span>
     <span class="s3">*/</span>
    <span class="s1">lines: string[];</span>
    <span class="s3">/**</span>
     <span class="s3">* The indexes in `text` that each line starts</span>
     <span class="s3">*/</span>
    <span class="s1">lineStartIndices: number[];</span>
    <span class="s3">/**</span>
     <span class="s3">* The parser services of this source code.</span>
     <span class="s3">*/</span>
    <span class="s1">parserServices?: Partial&lt;ParserServices&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* The scope of this source code.</span>
     <span class="s3">*/</span>
    <span class="s1">scopeManager: Scope.ScopeManager | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The original text source code. BOM was stripped from this text.</span>
     <span class="s3">*/</span>
    <span class="s1">text: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* All of the tokens and comments in the AST.</span>
     <span class="s3">*</span>
     <span class="s3">* TODO: rename to 'tokens'</span>
     <span class="s3">*/</span>
    <span class="s1">tokensAndComments: TSESTree.Token[];</span>
    <span class="s3">/**</span>
     <span class="s3">* The visitor keys to traverse AST.</span>
     <span class="s3">*/</span>
    <span class="s1">visitorKeys: SourceCode.VisitorKeys;</span>
    <span class="s3">/**</span>
     <span class="s3">* Split the source code into multiple lines based on the line delimiters.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">text Source code as a string.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">Array of source code lines.</span>
     <span class="s3">*/</span>
    <span class="s0">static </span><span class="s1">splitLines(text: string): string[];</span>
<span class="s1">}</span>
<span class="s1">declare namespace SourceCode {</span>
    <span class="s0">interface </span><span class="s1">Program </span><span class="s0">extends </span><span class="s1">TSESTree.Program {</span>
        <span class="s1">comments: TSESTree.Comment[];</span>
        <span class="s1">tokens: TSESTree.Token[];</span>
    <span class="s1">}</span>
    <span class="s0">interface </span><span class="s1">SourceCodeConfig {</span>
        <span class="s3">/**</span>
         <span class="s3">* The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.</span>
         <span class="s3">*/</span>
        <span class="s1">ast: Program;</span>
        <span class="s3">/**</span>
         <span class="s3">* The parser services.</span>
         <span class="s3">*/</span>
        <span class="s1">parserServices: ParserServices | </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* The scope of this source code.</span>
         <span class="s3">*/</span>
        <span class="s1">scopeManager: Scope.ScopeManager | </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* The source code text.</span>
         <span class="s3">*/</span>
        <span class="s1">text: string;</span>
        <span class="s3">/**</span>
         <span class="s3">* The visitor keys to traverse AST.</span>
         <span class="s3">*/</span>
        <span class="s1">visitorKeys: VisitorKeys | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">type VisitorKeys = Parser.VisitorKeys;</span>
    <span class="s1">type FilterPredicate = (token: TSESTree.Token) =&gt; boolean;</span>
    <span class="s1">type GetFilterPredicate&lt;Filter, Default&gt; = Filter </span><span class="s0">extends </span><span class="s1">((token: TSESTree.Token) =&gt; token is infer U </span><span class="s0">extends </span><span class="s1">TSESTree.Token) ? U : Default;</span>
    <span class="s1">type GetFilterPredicateFromOptions&lt;Options, Default&gt; = Options </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s1">filter?: FilterPredicate;</span>
    <span class="s1">} ? GetFilterPredicate&lt;Options[</span><span class="s2">'filter'</span><span class="s1">], Default&gt; : GetFilterPredicate&lt;Options, Default&gt;;</span>
    <span class="s1">type ReturnTypeFromOptions&lt;T&gt; = T </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s1">includeComments: </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s1">} ? GetFilterPredicateFromOptions&lt;T, TSESTree.Token&gt; : GetFilterPredicateFromOptions&lt;T, Exclude&lt;TSESTree.Token, TSESTree.Comment&gt;&gt;;</span>
    <span class="s1">type CursorWithSkipOptions = number | FilterPredicate | {</span>
        <span class="s3">/**</span>
         <span class="s3">* The predicate function to choose tokens.</span>
         <span class="s3">*/</span>
        <span class="s1">filter?: FilterPredicate;</span>
        <span class="s3">/**</span>
         <span class="s3">* The flag to iterate comments as well.</span>
         <span class="s3">*/</span>
        <span class="s1">includeComments?: boolean;</span>
        <span class="s3">/**</span>
         <span class="s3">* The count of tokens the cursor skips.</span>
         <span class="s3">*/</span>
        <span class="s1">skip?: number;</span>
    <span class="s1">};</span>
    <span class="s1">type CursorWithCountOptions = number | FilterPredicate | {</span>
        <span class="s3">/**</span>
         <span class="s3">* The maximum count of tokens the cursor iterates.</span>
         <span class="s3">*/</span>
        <span class="s1">count?: number;</span>
        <span class="s3">/**</span>
         <span class="s3">* The predicate function to choose tokens.</span>
         <span class="s3">*/</span>
        <span class="s1">filter?: FilterPredicate;</span>
        <span class="s3">/**</span>
         <span class="s3">* The flag to iterate comments as well.</span>
         <span class="s3">*/</span>
        <span class="s1">includeComments?: boolean;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s0">const </span><span class="s1">SourceCode_base: </span><span class="s0">typeof </span><span class="s1">SourceCodeBase;</span>
<span class="s1">declare </span><span class="s0">class </span><span class="s1">SourceCode </span><span class="s0">extends </span><span class="s1">SourceCode_base {</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">{ SourceCode };</span>
</pre>
</body>
</html>