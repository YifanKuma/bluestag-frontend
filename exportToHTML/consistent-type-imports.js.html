<html>
<head>
<title>consistent-type-imports.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
consistent-type-imports.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s1">exports.default = (</span><span class="s3">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'consistent-type-imports'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Enforce consistent usage of type imports'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">avoidImportType: </span><span class="s0">'Use an `import` instead of an `import type`.'</span><span class="s1">,</span>
            <span class="s1">noImportTypeAnnotations: </span><span class="s0">'`import()` type annotations are forbidden.'</span><span class="s1">,</span>
            <span class="s1">someImportsAreOnlyTypes: </span><span class="s0">'Imports {{typeImports}} are only used as type.'</span><span class="s1">,</span>
            <span class="s1">typeOverValue: </span><span class="s0">'All imports in the declaration are only used as types. Use `import type`.'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">disallowTypeAnnotations: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to disallow type imports in type annotations (`import()`).'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">fixStyle: {</span>
                        <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'The expected type modifier to be added when an import is detected as used only in the type position.'</span><span class="s1">,</span>
                        <span class="s2">enum</span><span class="s1">: [</span><span class="s0">'separate-type-imports'</span><span class="s1">, </span><span class="s0">'inline-type-imports'</span><span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">prefer: {</span>
                        <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'The expected import kind for type-only imports.'</span><span class="s1">,</span>
                        <span class="s2">enum</span><span class="s1">: [</span><span class="s0">'type-imports'</span><span class="s1">, </span><span class="s0">'no-type-imports'</span><span class="s1">],</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s1">disallowTypeAnnotations: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">fixStyle: </span><span class="s0">'separate-type-imports'</span><span class="s1">,</span>
            <span class="s1">prefer: </span><span class="s0">'type-imports'</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [option]) {</span>
        <span class="s2">const </span><span class="s1">prefer = option.prefer ?? </span><span class="s0">'type-imports'</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">disallowTypeAnnotations = option.disallowTypeAnnotations !== </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">selectors = {};</span>
        <span class="s2">if </span><span class="s1">(disallowTypeAnnotations) {</span>
            <span class="s1">selectors.TSImportType = (node) =&gt; {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: </span><span class="s0">'noImportTypeAnnotations'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(prefer === </span><span class="s0">'no-type-imports'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">...selectors,</span>
                <span class="s0">'ImportDeclaration[importKind = &quot;type&quot;]'</span><span class="s1">(node) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node,</span>
                        <span class="s1">messageId: </span><span class="s0">'avoidImportType'</span><span class="s1">,</span>
                        <span class="s1">fix(fixer) {</span>
                            <span class="s2">return </span><span class="s1">fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);</span>
                        <span class="s1">},</span>
                    <span class="s1">});</span>
                <span class="s1">},</span>
                <span class="s0">'ImportSpecifier[importKind = &quot;type&quot;]'</span><span class="s1">(node) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node,</span>
                        <span class="s1">messageId: </span><span class="s0">'avoidImportType'</span><span class="s1">,</span>
                        <span class="s1">fix(fixer) {</span>
                            <span class="s2">return </span><span class="s1">fixRemoveTypeSpecifierFromImportSpecifier(fixer, node);</span>
                        <span class="s1">},</span>
                    <span class="s1">});</span>
                <span class="s1">},</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">// prefer type imports</span>
        <span class="s2">const </span><span class="s1">fixStyle = option.fixStyle ?? </span><span class="s0">'separate-type-imports'</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">hasDecoratorMetadata = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">sourceImportsMap = {};</span>
        <span class="s2">const </span><span class="s1">emitDecoratorMetadata = (</span><span class="s3">0</span><span class="s1">, util_1.getParserServices)(context, </span><span class="s2">true</span><span class="s1">).emitDecoratorMetadata ?? </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">experimentalDecorators = (</span><span class="s3">0</span><span class="s1">, util_1.getParserServices)(context, </span><span class="s2">true</span><span class="s1">).experimentalDecorators ?? </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(experimentalDecorators &amp;&amp; emitDecoratorMetadata) {</span>
            <span class="s1">selectors.Decorator = () =&gt; {</span>
                <span class="s1">hasDecoratorMetadata = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">...selectors,</span>
            <span class="s1">ImportDeclaration(node) {</span>
                <span class="s2">const </span><span class="s1">source = node.source.value;</span>
                <span class="s4">// sourceImports is the object containing all the specifics for a particular import source, type or value</span>
                <span class="s1">sourceImportsMap[source] ??= {</span>
                    <span class="s1">reportValueImports: [], </span><span class="s4">// if there is a mismatch where type importKind but value specifiers</span>
                    <span class="s1">source,</span>
                    <span class="s1">typeOnlyNamedImport: </span><span class="s2">null</span><span class="s1">, </span><span class="s4">// if only type imports</span>
                    <span class="s1">valueImport: </span><span class="s2">null</span><span class="s1">, </span><span class="s4">// if only value imports</span>
                    <span class="s1">valueOnlyNamedImport: </span><span class="s2">null</span><span class="s1">, </span><span class="s4">// if only value imports with named specifiers</span>
                <span class="s1">};</span>
                <span class="s2">const </span><span class="s1">sourceImports = sourceImportsMap[source];</span>
                <span class="s2">if </span><span class="s1">(node.importKind === </span><span class="s0">'type'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(!sourceImports.typeOnlyNamedImport &amp;&amp;</span>
                        <span class="s1">node.specifiers.every(specifier =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {</span>
                        <span class="s4">// definitely import type { TypeX }</span>
                        <span class="s1">sourceImports.typeOnlyNamedImport = node;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(!sourceImports.valueOnlyNamedImport &amp;&amp;</span>
                    <span class="s1">node.specifiers.length &amp;&amp;</span>
                    <span class="s1">node.specifiers.every(specifier =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {</span>
                    <span class="s1">sourceImports.valueOnlyNamedImport = node;</span>
                    <span class="s1">sourceImports.valueImport = node;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(!sourceImports.valueImport &amp;&amp;</span>
                    <span class="s1">node.specifiers.some(specifier =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier)) {</span>
                    <span class="s1">sourceImports.valueImport = node;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">typeSpecifiers = [];</span>
                <span class="s2">const </span><span class="s1">inlineTypeSpecifiers = [];</span>
                <span class="s2">const </span><span class="s1">valueSpecifiers = [];</span>
                <span class="s2">const </span><span class="s1">unusedSpecifiers = [];</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of node.specifiers) {</span>
                    <span class="s2">if </span><span class="s1">(specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &amp;&amp;</span>
                        <span class="s1">specifier.importKind === </span><span class="s0">'type'</span><span class="s1">) {</span>
                        <span class="s1">inlineTypeSpecifiers.push(specifier);</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">[variable] = context.sourceCode.getDeclaredVariables(specifier);</span>
                    <span class="s2">if </span><span class="s1">(variable.references.length === </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s1">unusedSpecifiers.push(specifier);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">onlyHasTypeReferences = variable.references.every(ref =&gt; {</span>
                            <span class="s4">/**</span>
                             <span class="s4">* keep origin import kind when export</span>
                             <span class="s4">* export { Type }</span>
                             <span class="s4">* export default Type;</span>
                             <span class="s4">* export = Type;</span>
                             <span class="s4">*/</span>
                            <span class="s2">if </span><span class="s1">((ref.identifier.parent.type ===</span>
                                <span class="s1">utils_1.AST_NODE_TYPES.ExportSpecifier ||</span>
                                <span class="s1">ref.identifier.parent.type ===</span>
                                    <span class="s1">utils_1.AST_NODE_TYPES.ExportDefaultDeclaration ||</span>
                                <span class="s1">ref.identifier.parent.type ===</span>
                                    <span class="s1">utils_1.AST_NODE_TYPES.TSExportAssignment) &amp;&amp;</span>
                                <span class="s1">ref.isValueReference &amp;&amp;</span>
                                <span class="s1">ref.isTypeReference) {</span>
                                <span class="s2">return </span><span class="s1">node.importKind === </span><span class="s0">'type'</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s2">if </span><span class="s1">(ref.isValueReference) {</span>
                                <span class="s2">let </span><span class="s1">parent = ref.identifier.parent;</span>
                                <span class="s2">let </span><span class="s1">child = ref.identifier;</span>
                                <span class="s2">while </span><span class="s1">(parent) {</span>
                                    <span class="s2">switch </span><span class="s1">(parent.type) {</span>
                                        <span class="s4">// CASE 1:</span>
                                        <span class="s4">// `type T = typeof foo` will create a value reference because &quot;foo&quot; must be a value type</span>
                                        <span class="s4">// however this value reference is safe to use with type-only imports</span>
                                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSTypeQuery:</span>
                                            <span class="s2">return true</span><span class="s1">;</span>
                                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSQualifiedName:</span>
                                            <span class="s4">// TSTypeQuery must have a TSESTree.EntityName as its child, so we can filter here and break early</span>
                                            <span class="s2">if </span><span class="s1">(parent.left !== child) {</span>
                                                <span class="s2">return false</span><span class="s1">;</span>
                                            <span class="s1">}</span>
                                            <span class="s1">child = parent;</span>
                                            <span class="s1">parent = parent.parent;</span>
                                            <span class="s2">continue</span><span class="s1">;</span>
                                        <span class="s4">// END CASE 1</span>
                                        <span class="s4">//////////////</span>
                                        <span class="s4">// CASE 2:</span>
                                        <span class="s4">// `type T = { [foo]: string }` will create a value reference because &quot;foo&quot; must be a value type</span>
                                        <span class="s4">// however this value reference is safe to use with type-only imports.</span>
                                        <span class="s4">// Also this is represented as a non-type AST - hence it uses MemberExpression</span>
                                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSPropertySignature:</span>
                                            <span class="s2">return </span><span class="s1">parent.key === child;</span>
                                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MemberExpression:</span>
                                            <span class="s2">if </span><span class="s1">(parent.object !== child) {</span>
                                                <span class="s2">return false</span><span class="s1">;</span>
                                            <span class="s1">}</span>
                                            <span class="s1">child = parent;</span>
                                            <span class="s1">parent = parent.parent;</span>
                                            <span class="s2">continue</span><span class="s1">;</span>
                                        <span class="s4">// END CASE 2</span>
                                        <span class="s2">default</span><span class="s1">:</span>
                                            <span class="s2">return false</span><span class="s1">;</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s2">return </span><span class="s1">ref.isTypeReference;</span>
                        <span class="s1">});</span>
                        <span class="s2">if </span><span class="s1">(onlyHasTypeReferences) {</span>
                            <span class="s1">typeSpecifiers.push(specifier);</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">valueSpecifiers.push(specifier);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.importKind === </span><span class="s0">'value' </span><span class="s1">&amp;&amp; typeSpecifiers.length) {</span>
                    <span class="s1">sourceImports.reportValueImports.push({</span>
                        <span class="s1">node,</span>
                        <span class="s1">inlineTypeSpecifiers,</span>
                        <span class="s1">typeSpecifiers,</span>
                        <span class="s1">unusedSpecifiers,</span>
                        <span class="s1">valueSpecifiers,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s0">'Program:exit'</span><span class="s1">() {</span>
                <span class="s2">if </span><span class="s1">(hasDecoratorMetadata) {</span>
                    <span class="s4">// Experimental decorator metadata is bowl of poop that cannot be</span>
                    <span class="s4">// supported based on pure syntactic analysis.</span>
                    <span class="s4">//</span>
                    <span class="s4">// So we can do one of two things:</span>
                    <span class="s4">// 1) add type-information to the rule in a breaking change and</span>
                    <span class="s4">//    prevent users from using it so that we can fully support this</span>
                    <span class="s4">//    case.</span>
                    <span class="s4">// 2) make the rule ignore all imports that are used in a file that</span>
                    <span class="s4">//    might have decorator metadata.</span>
                    <span class="s4">//</span>
                    <span class="s4">// (1) is has huge impact and prevents the rule from being used by 99%</span>
                    <span class="s4">// of users Frankly - it's a straight-up bad option. So instead we</span>
                    <span class="s4">// choose with option (2) and just avoid reporting on any imports in a</span>
                    <span class="s4">// file with both emitDecoratorMetadata AND decorators</span>
                    <span class="s4">//</span>
                    <span class="s4">// For more context see the discussion in this issue and its linked</span>
                    <span class="s4">// issues:</span>
                    <span class="s4">// https://github.com/typescript-eslint/typescript-eslint/issues/5468</span>
                    <span class="s4">//</span>
                    <span class="s4">//</span>
                    <span class="s4">// NOTE - in TS 5.0 `experimentalDecorators` became the legacy option,</span>
                    <span class="s4">// replaced with un-flagged, stable decorators and thus the type-aware</span>
                    <span class="s4">// emitDecoratorMetadata implementation also became legacy. in TS 5.2</span>
                    <span class="s4">// support for the new, stable decorator metadata proposal was added -</span>
                    <span class="s4">// however this proposal does not include type information</span>
                    <span class="s4">//</span>
                    <span class="s4">//</span>
                    <span class="s4">// PHEW. So TL;DR what does all this mean?</span>
                    <span class="s4">// - if you use experimentalDecorators:true,</span>
                    <span class="s4">//   emitDecoratorMetadata:true, and have a decorator in the file -</span>
                    <span class="s4">//   the rule will do nothing in the file out of an abundance of</span>
                    <span class="s4">//   caution.</span>
                    <span class="s4">// - else the rule will work as normal.</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">sourceImports of Object.values(sourceImportsMap)) {</span>
                    <span class="s2">if </span><span class="s1">(sourceImports.reportValueImports.length === </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s4">// nothing to fix. value specifiers and type specifiers are correctly written</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">report of sourceImports.reportValueImports) {</span>
                        <span class="s2">if </span><span class="s1">(report.valueSpecifiers.length === </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">report.unusedSpecifiers.length === </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">report.node.importKind !== </span><span class="s0">'type'</span><span class="s1">) {</span>
                            <span class="s4">/**</span>
                             <span class="s4">* checks if import has type assertions</span>
                             <span class="s4">* </span><span class="s5">@example</span>
                             <span class="s4">* ```ts</span>
                             <span class="s4">* import * as type from 'mod' assert \{ type: 'json' \};</span>
                             <span class="s4">* ```</span>
                             <span class="s4">* https://github.com/typescript-eslint/typescript-eslint/issues/7527</span>
                             <span class="s4">*/</span>
                            <span class="s2">if </span><span class="s1">(report.node.attributes.length === </span><span class="s3">0</span><span class="s1">) {</span>
                                <span class="s1">context.report({</span>
                                    <span class="s1">node: report.node,</span>
                                    <span class="s1">messageId: </span><span class="s0">'typeOverValue'</span><span class="s1">,</span>
                                    <span class="s1">*fix(fixer) {</span>
                                        <span class="s2">yield</span><span class="s1">* fixToTypeImportDeclaration(fixer, report, sourceImports);</span>
                                    <span class="s1">},</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s4">// we have a mixed type/value import or just value imports, so we need to split them out into multiple imports if separate-type-imports is configured</span>
                            <span class="s2">const </span><span class="s1">importNames = report.typeSpecifiers.map(specifier =&gt; </span><span class="s0">`&quot;</span><span class="s1">${specifier.local.name}</span><span class="s0">&quot;`</span><span class="s1">);</span>
                            <span class="s2">const </span><span class="s1">message = (() =&gt; {</span>
                                <span class="s2">const </span><span class="s1">typeImports = (</span><span class="s3">0</span><span class="s1">, util_1.formatWordList)(importNames);</span>
                                <span class="s2">if </span><span class="s1">(importNames.length === </span><span class="s3">1</span><span class="s1">) {</span>
                                    <span class="s2">return </span><span class="s1">{</span>
                                        <span class="s1">messageId: </span><span class="s0">'someImportsAreOnlyTypes'</span><span class="s1">,</span>
                                        <span class="s1">data: {</span>
                                            <span class="s1">typeImports,</span>
                                        <span class="s1">},</span>
                                    <span class="s1">};</span>
                                <span class="s1">}</span>
                                <span class="s2">return </span><span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'someImportsAreOnlyTypes'</span><span class="s1">,</span>
                                    <span class="s1">data: {</span>
                                        <span class="s1">typeImports,</span>
                                    <span class="s1">},</span>
                                <span class="s1">};</span>
                            <span class="s1">})();</span>
                            <span class="s1">context.report({</span>
                                <span class="s1">node: report.node,</span>
                                <span class="s1">...message,</span>
                                <span class="s1">*fix(fixer) {</span>
                                    <span class="s4">// take all the typeSpecifiers and put them on a new line</span>
                                    <span class="s2">yield</span><span class="s1">* fixToTypeImportDeclaration(fixer, report, sourceImports);</span>
                                <span class="s1">},</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
        <span class="s2">function </span><span class="s1">classifySpecifier(node) {</span>
            <span class="s2">const </span><span class="s1">defaultSpecifier = node.specifiers[</span><span class="s3">0</span><span class="s1">].type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier</span>
                <span class="s1">? node.specifiers[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">namespaceSpecifier = node.specifiers.find((specifier) =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier) ?? </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">namedSpecifiers = node.specifiers.filter((specifier) =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier);</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">defaultSpecifier,</span>
                <span class="s1">namedSpecifiers,</span>
                <span class="s1">namespaceSpecifier,</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Returns information for fixing named specifiers, type or value</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">getFixesNamedSpecifiers(fixer, node, subsetNamedSpecifiers, allNamedSpecifiers) {</span>
            <span class="s2">if </span><span class="s1">(allNamedSpecifiers.length === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">removeTypeNamedSpecifiers: [],</span>
                    <span class="s1">typeNamedSpecifiersText: </span><span class="s0">''</span><span class="s1">,</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">typeNamedSpecifiersTexts = [];</span>
            <span class="s2">const </span><span class="s1">removeTypeNamedSpecifiers = [];</span>
            <span class="s2">if </span><span class="s1">(subsetNamedSpecifiers.length === allNamedSpecifiers.length) {</span>
                <span class="s4">// import Foo, {Type1, Type2} from 'foo'</span>
                <span class="s4">// import DefType, {Type1, Type2} from 'foo'</span>
                <span class="s2">const </span><span class="s1">openingBraceToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenBefore(subsetNamedSpecifiers[</span><span class="s3">0</span><span class="s1">], util_1.isOpeningBraceToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'{'</span><span class="s1">, node.type));</span>
                <span class="s2">const </span><span class="s1">commaToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenBefore(openingBraceToken, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">','</span><span class="s1">, node.type));</span>
                <span class="s2">const </span><span class="s1">closingBraceToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'}'</span><span class="s1">, node.type));</span>
                <span class="s4">// import DefType, {...} from 'foo'</span>
                <span class="s4">//               ^^^^^^^ remove</span>
                <span class="s1">removeTypeNamedSpecifiers.push(fixer.removeRange([commaToken.range[</span><span class="s3">0</span><span class="s1">], closingBraceToken.range[</span><span class="s3">1</span><span class="s1">]]));</span>
                <span class="s1">typeNamedSpecifiersTexts.push(context.sourceCode.text.slice(openingBraceToken.range[</span><span class="s3">1</span><span class="s1">], closingBraceToken.range[</span><span class="s3">0</span><span class="s1">]));</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">namedSpecifierGroups = [];</span>
                <span class="s2">let </span><span class="s1">group = [];</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">namedSpecifier of allNamedSpecifiers) {</span>
                    <span class="s2">if </span><span class="s1">(subsetNamedSpecifiers.includes(namedSpecifier)) {</span>
                        <span class="s1">group.push(namedSpecifier);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(group.length) {</span>
                        <span class="s1">namedSpecifierGroups.push(group);</span>
                        <span class="s1">group = [];</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(group.length) {</span>
                    <span class="s1">namedSpecifierGroups.push(group);</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">namedSpecifiers of namedSpecifierGroups) {</span>
                    <span class="s2">const </span><span class="s1">{ removeRange, textRange } = getNamedSpecifierRanges(namedSpecifiers, allNamedSpecifiers);</span>
                    <span class="s1">removeTypeNamedSpecifiers.push(fixer.removeRange(removeRange));</span>
                    <span class="s1">typeNamedSpecifiersTexts.push(context.sourceCode.text.slice(...textRange));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">removeTypeNamedSpecifiers,</span>
                <span class="s1">typeNamedSpecifiersText: typeNamedSpecifiersTexts.join(</span><span class="s0">','</span><span class="s1">),</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Returns ranges for fixing named specifier.</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">getNamedSpecifierRanges(namedSpecifierGroup, allNamedSpecifiers) {</span>
            <span class="s2">const </span><span class="s1">first = namedSpecifierGroup[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s2">const </span><span class="s1">last = namedSpecifierGroup[namedSpecifierGroup.length - </span><span class="s3">1</span><span class="s1">];</span>
            <span class="s2">const </span><span class="s1">removeRange = [first.range[</span><span class="s3">0</span><span class="s1">], last.range[</span><span class="s3">1</span><span class="s1">]];</span>
            <span class="s2">const </span><span class="s1">textRange = [...removeRange];</span>
            <span class="s2">const </span><span class="s1">before = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenBefore(first), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'token'</span><span class="s1">, </span><span class="s0">'first specifier'</span><span class="s1">));</span>
            <span class="s1">textRange[</span><span class="s3">0</span><span class="s1">] = before.range[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.isCommaToken)(before)) {</span>
                <span class="s1">removeRange[</span><span class="s3">0</span><span class="s1">] = before.range[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">removeRange[</span><span class="s3">0</span><span class="s1">] = before.range[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">isFirst = allNamedSpecifiers[</span><span class="s3">0</span><span class="s1">] === first;</span>
            <span class="s2">const </span><span class="s1">isLast = allNamedSpecifiers[allNamedSpecifiers.length - </span><span class="s3">1</span><span class="s1">] === last;</span>
            <span class="s2">const </span><span class="s1">after = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenAfter(last), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'token'</span><span class="s1">, </span><span class="s0">'last specifier'</span><span class="s1">));</span>
            <span class="s1">textRange[</span><span class="s3">1</span><span class="s1">] = after.range[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">((isFirst || isLast) &amp;&amp; (</span><span class="s3">0</span><span class="s1">, util_1.isCommaToken)(after)) {</span>
                <span class="s1">removeRange[</span><span class="s3">1</span><span class="s1">] = after.range[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">removeRange,</span>
                <span class="s1">textRange,</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* insert specifiers to named import node.</span>
         <span class="s4">* e.g.</span>
         <span class="s4">* import type { Already, Type1, Type2 } from 'foo'</span>
         <span class="s4">*                        ^^^^^^^^^^^^^ insert</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">fixInsertNamedSpecifiersInNamedSpecifierList(fixer, target, insertText) {</span>
            <span class="s2">const </span><span class="s1">closingBraceToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween((</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstToken(target), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'token before'</span><span class="s1">, </span><span class="s0">'import'</span><span class="s1">)), target.source, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'}'</span><span class="s1">, target.type));</span>
            <span class="s2">const </span><span class="s1">before = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenBefore(closingBraceToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'token before'</span><span class="s1">, </span><span class="s0">'closing brace'</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, util_1.isCommaToken)(before) &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, util_1.isOpeningBraceToken)(before)) {</span>
                <span class="s1">insertText = </span><span class="s0">`,</span><span class="s1">${insertText}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">fixer.insertTextBefore(closingBraceToken, insertText);</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* insert type keyword to named import node.</span>
         <span class="s4">* e.g.</span>
         <span class="s4">* import ADefault, { Already, type Type1, type Type2 } from 'foo'</span>
         <span class="s4">*                             ^^^^ insert</span>
         <span class="s4">*/</span>
        <span class="s2">function</span><span class="s1">* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeSpecifiers) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">spec of typeSpecifiers) {</span>
                <span class="s2">const </span><span class="s1">insertText = context.sourceCode.text.slice(...spec.range);</span>
                <span class="s2">yield </span><span class="s1">fixer.replaceTextRange(spec.range, </span><span class="s0">`type </span><span class="s1">${insertText}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixInlineTypeImportDeclaration(fixer, report, sourceImports) {</span>
            <span class="s2">const </span><span class="s1">{ node } = report;</span>
            <span class="s4">// For a value import, will only add an inline type to named specifiers</span>
            <span class="s2">const </span><span class="s1">{ namedSpecifiers } = classifySpecifier(node);</span>
            <span class="s2">const </span><span class="s1">typeNamedSpecifiers = namedSpecifiers.filter(specifier =&gt; report.typeSpecifiers.includes(specifier));</span>
            <span class="s2">if </span><span class="s1">(sourceImports.valueImport) {</span>
                <span class="s4">// add import named type specifiers to its value import</span>
                <span class="s4">// import ValueA, { type A }</span>
                <span class="s4">//                  ^^^^ insert</span>
                <span class="s2">const </span><span class="s1">{ namedSpecifiers: valueImportNamedSpecifiers } = classifySpecifier(sourceImports.valueImport);</span>
                <span class="s2">if </span><span class="s1">(sourceImports.valueOnlyNamedImport ||</span>
                    <span class="s1">valueImportNamedSpecifiers.length) {</span>
                    <span class="s2">yield</span><span class="s1">* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeNamedSpecifiers);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixToTypeImportDeclaration(fixer, report, sourceImports) {</span>
            <span class="s2">const </span><span class="s1">{ node } = report;</span>
            <span class="s2">const </span><span class="s1">{ defaultSpecifier, namedSpecifiers, namespaceSpecifier } = classifySpecifier(node);</span>
            <span class="s2">if </span><span class="s1">(namespaceSpecifier &amp;&amp; !defaultSpecifier) {</span>
                <span class="s4">// import * as types from 'foo'</span>
                <span class="s4">// checks for presence of import assertions</span>
                <span class="s2">if </span><span class="s1">(node.attributes.length === </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s2">yield</span><span class="s1">* fixInsertTypeSpecifierForImportDeclaration(fixer, node, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(defaultSpecifier) {</span>
                <span class="s2">if </span><span class="s1">(report.typeSpecifiers.includes(defaultSpecifier) &amp;&amp;</span>
                    <span class="s1">namedSpecifiers.length === </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!namespaceSpecifier) {</span>
                    <span class="s4">// import Type from 'foo'</span>
                    <span class="s2">yield</span><span class="s1">* fixInsertTypeSpecifierForImportDeclaration(fixer, node, </span><span class="s2">true</span><span class="s1">);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(fixStyle === </span><span class="s0">'inline-type-imports' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!report.typeSpecifiers.includes(defaultSpecifier) &amp;&amp;</span>
                    <span class="s1">namedSpecifiers.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!namespaceSpecifier) {</span>
                    <span class="s4">// if there is a default specifier but it isn't a type specifier, then just add the inline type modifier to the named specifiers</span>
                    <span class="s4">// import AValue, {BValue, Type1, Type2} from 'foo'</span>
                    <span class="s2">yield</span><span class="s1">* fixInlineTypeImportDeclaration(fixer, report, sourceImports);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!namespaceSpecifier) {</span>
                <span class="s2">if </span><span class="s1">(fixStyle === </span><span class="s0">'inline-type-imports' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">namedSpecifiers.some(specifier =&gt; report.typeSpecifiers.includes(specifier))) {</span>
                    <span class="s4">// import {AValue, Type1, Type2} from 'foo'</span>
                    <span class="s2">yield</span><span class="s1">* fixInlineTypeImportDeclaration(fixer, report, sourceImports);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(namedSpecifiers.every(specifier =&gt; report.typeSpecifiers.includes(specifier))) {</span>
                    <span class="s4">// import {Type1, Type2} from 'foo'</span>
                    <span class="s2">yield</span><span class="s1">* fixInsertTypeSpecifierForImportDeclaration(fixer, node, </span><span class="s2">false</span><span class="s1">);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">typeNamedSpecifiers = namedSpecifiers.filter(specifier =&gt; report.typeSpecifiers.includes(specifier));</span>
            <span class="s2">const </span><span class="s1">fixesNamedSpecifiers = getFixesNamedSpecifiers(fixer, node, typeNamedSpecifiers, namedSpecifiers);</span>
            <span class="s2">const </span><span class="s1">afterFixes = [];</span>
            <span class="s2">if </span><span class="s1">(typeNamedSpecifiers.length) {</span>
                <span class="s2">if </span><span class="s1">(sourceImports.typeOnlyNamedImport) {</span>
                    <span class="s2">const </span><span class="s1">insertTypeNamedSpecifiers = fixInsertNamedSpecifiersInNamedSpecifierList(fixer, sourceImports.typeOnlyNamedImport, fixesNamedSpecifiers.typeNamedSpecifiersText);</span>
                    <span class="s2">if </span><span class="s1">(sourceImports.typeOnlyNamedImport.range[</span><span class="s3">1</span><span class="s1">] &lt;= node.range[</span><span class="s3">0</span><span class="s1">]) {</span>
                        <span class="s2">yield </span><span class="s1">insertTypeNamedSpecifiers;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">afterFixes.push(insertTypeNamedSpecifiers);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// The import is both default and named.  Insert named on new line because can't mix default type import and named type imports</span>
                    <span class="s4">// eslint-disable-next-line no-lonely-if</span>
                    <span class="s2">if </span><span class="s1">(fixStyle === </span><span class="s0">'inline-type-imports'</span><span class="s1">) {</span>
                        <span class="s2">yield </span><span class="s1">fixer.insertTextBefore(node, </span><span class="s0">`import {</span><span class="s1">${typeNamedSpecifiers</span>
                            <span class="s1">.map(spec =&gt; {</span>
                            <span class="s2">const </span><span class="s1">insertText = context.sourceCode.text.slice(...spec.range);</span>
                            <span class="s2">return </span><span class="s0">`type </span><span class="s1">${insertText}</span><span class="s0">`</span><span class="s1">;</span>
                        <span class="s1">})</span>
                            <span class="s1">.join(</span><span class="s0">', '</span><span class="s1">)}</span><span class="s0">} from </span><span class="s1">${context.sourceCode.getText(node.source)}</span><span class="s0">;</span><span class="s6">\n</span><span class="s0">`</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">yield </span><span class="s1">fixer.insertTextBefore(node, </span><span class="s0">`import type {</span><span class="s1">${fixesNamedSpecifiers.typeNamedSpecifiersText}</span><span class="s0">} from </span><span class="s1">${context.sourceCode.getText(node.source)}</span><span class="s0">;</span><span class="s6">\n</span><span class="s0">`</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">fixesRemoveTypeNamespaceSpecifier = [];</span>
            <span class="s2">if </span><span class="s1">(namespaceSpecifier &amp;&amp;</span>
                <span class="s1">report.typeSpecifiers.includes(namespaceSpecifier)) {</span>
                <span class="s4">// import Foo, * as Type from 'foo'</span>
                <span class="s4">// import DefType, * as Type from 'foo'</span>
                <span class="s4">// import DefType, * as Type from 'foo'</span>
                <span class="s2">const </span><span class="s1">commaToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenBefore(namespaceSpecifier, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">','</span><span class="s1">, node.type));</span>
                <span class="s4">// import Def, * as Ns from 'foo'</span>
                <span class="s4">//           ^^^^^^^^^ remove</span>
                <span class="s1">fixesRemoveTypeNamespaceSpecifier.push(fixer.removeRange([commaToken.range[</span><span class="s3">0</span><span class="s1">], namespaceSpecifier.range[</span><span class="s3">1</span><span class="s1">]]));</span>
                <span class="s4">// import type * as Ns from 'foo'</span>
                <span class="s4">// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ insert</span>
                <span class="s2">yield </span><span class="s1">fixer.insertTextBefore(node, </span><span class="s0">`import type </span><span class="s1">${context.sourceCode.getText(namespaceSpecifier)} </span><span class="s0">from </span><span class="s1">${context.sourceCode.getText(node.source)}</span><span class="s0">;</span><span class="s6">\n</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(defaultSpecifier &amp;&amp;</span>
                <span class="s1">report.typeSpecifiers.includes(defaultSpecifier)) {</span>
                <span class="s2">if </span><span class="s1">(report.typeSpecifiers.length === node.specifiers.length) {</span>
                    <span class="s2">const </span><span class="s1">importToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'import'</span><span class="s1">, node.type));</span>
                    <span class="s4">// import type Type from 'foo'</span>
                    <span class="s4">//        ^^^^ insert</span>
                    <span class="s2">yield </span><span class="s1">fixer.insertTextAfter(importToken, </span><span class="s0">' type'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">const </span><span class="s1">commaToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenAfter(defaultSpecifier, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">','</span><span class="s1">, defaultSpecifier.type));</span>
                    <span class="s4">// import Type , {...} from 'foo'</span>
                    <span class="s4">//        ^^^^^ pick</span>
                    <span class="s2">const </span><span class="s1">defaultText = context.sourceCode.text</span>
                        <span class="s1">.slice(defaultSpecifier.range[</span><span class="s3">0</span><span class="s1">], commaToken.range[</span><span class="s3">0</span><span class="s1">])</span>
                        <span class="s1">.trim();</span>
                    <span class="s2">yield </span><span class="s1">fixer.insertTextBefore(node, </span><span class="s0">`import type </span><span class="s1">${defaultText} </span><span class="s0">from </span><span class="s1">${context.sourceCode.getText(node.source)}</span><span class="s0">;</span><span class="s6">\n</span><span class="s0">`</span><span class="s1">);</span>
                    <span class="s2">const </span><span class="s1">afterToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenAfter(commaToken, {</span>
                        <span class="s1">includeComments: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">}), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'any token'</span><span class="s1">, node.type));</span>
                    <span class="s4">// import Type , {...} from 'foo'</span>
                    <span class="s4">//        ^^^^^^^ remove</span>
                    <span class="s2">yield </span><span class="s1">fixer.removeRange([</span>
                        <span class="s1">defaultSpecifier.range[</span><span class="s3">0</span><span class="s1">],</span>
                        <span class="s1">afterToken.range[</span><span class="s3">0</span><span class="s1">],</span>
                    <span class="s1">]);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">yield</span><span class="s1">* fixesNamedSpecifiers.removeTypeNamedSpecifiers;</span>
            <span class="s2">yield</span><span class="s1">* fixesRemoveTypeNamespaceSpecifier;</span>
            <span class="s2">yield</span><span class="s1">* afterFixes;</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixInsertTypeSpecifierForImportDeclaration(fixer, node, isDefaultImport) {</span>
            <span class="s4">// import type Foo from 'foo'</span>
            <span class="s4">//       ^^^^^ insert</span>
            <span class="s2">const </span><span class="s1">importToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'import'</span><span class="s1">, node.type));</span>
            <span class="s2">yield </span><span class="s1">fixer.insertTextAfter(importToken, </span><span class="s0">' type'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(isDefaultImport) {</span>
                <span class="s4">// Has default import</span>
                <span class="s2">const </span><span class="s1">openingBraceToken = context.sourceCode.getFirstTokenBetween(importToken, node.source, util_1.isOpeningBraceToken);</span>
                <span class="s2">if </span><span class="s1">(openingBraceToken) {</span>
                    <span class="s4">// Only braces. e.g. import Foo, {} from 'foo'</span>
                    <span class="s2">const </span><span class="s1">commaToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenBefore(openingBraceToken, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">','</span><span class="s1">, node.type));</span>
                    <span class="s2">const </span><span class="s1">closingBraceToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'}'</span><span class="s1">, node.type));</span>
                    <span class="s4">// import type Foo, {} from 'foo'</span>
                    <span class="s4">//                  ^^ remove</span>
                    <span class="s2">yield </span><span class="s1">fixer.removeRange([</span>
                        <span class="s1">commaToken.range[</span><span class="s3">0</span><span class="s1">],</span>
                        <span class="s1">closingBraceToken.range[</span><span class="s3">1</span><span class="s1">],</span>
                    <span class="s1">]);</span>
                    <span class="s2">const </span><span class="s1">specifiersText = context.sourceCode.text.slice(commaToken.range[</span><span class="s3">1</span><span class="s1">], closingBraceToken.range[</span><span class="s3">1</span><span class="s1">]);</span>
                    <span class="s2">if </span><span class="s1">(node.specifiers.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                        <span class="s2">yield </span><span class="s1">fixer.insertTextAfter(node, </span><span class="s0">`</span><span class="s6">\n</span><span class="s0">import type</span><span class="s1">${specifiersText} </span><span class="s0">from </span><span class="s1">${context.sourceCode.getText(node.source)}</span><span class="s0">;`</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// make sure we don't do anything like `import type {type T} from 'foo';`</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of node.specifiers) {</span>
                <span class="s2">if </span><span class="s1">(specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &amp;&amp;</span>
                    <span class="s1">specifier.importKind === </span><span class="s0">'type'</span><span class="s1">) {</span>
                    <span class="s2">yield</span><span class="s1">* fixRemoveTypeSpecifierFromImportSpecifier(fixer, specifier);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node) {</span>
            <span class="s4">// import type Foo from 'foo'</span>
            <span class="s4">//        ^^^^ remove</span>
            <span class="s2">const </span><span class="s1">importToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'import'</span><span class="s1">, node.type));</span>
            <span class="s2">const </span><span class="s1">typeToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween(importToken, node.specifiers[</span><span class="s3">0</span><span class="s1">]?.local ?? node.source, util_1.isTypeKeyword), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'type'</span><span class="s1">, node.type));</span>
            <span class="s2">const </span><span class="s1">afterToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenAfter(typeToken, { includeComments: </span><span class="s2">true </span><span class="s1">}), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'any token'</span><span class="s1">, node.type));</span>
            <span class="s2">yield </span><span class="s1">fixer.removeRange([typeToken.range[</span><span class="s3">0</span><span class="s1">], afterToken.range[</span><span class="s3">0</span><span class="s1">]]);</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixRemoveTypeSpecifierFromImportSpecifier(fixer, node) {</span>
            <span class="s4">// import { type Foo } from 'foo'</span>
            <span class="s4">//          ^^^^ remove</span>
            <span class="s2">const </span><span class="s1">typeToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isTypeKeyword), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'type'</span><span class="s1">, node.type));</span>
            <span class="s2">const </span><span class="s1">afterToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenAfter(typeToken, { includeComments: </span><span class="s2">true </span><span class="s1">}), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'any token'</span><span class="s1">, node.type));</span>
            <span class="s2">yield </span><span class="s1">fixer.removeRange([typeToken.range[</span><span class="s3">0</span><span class="s1">], afterToken.range[</span><span class="s3">0</span><span class="s1">]]);</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
<span class="s1">});</span>
</pre>
</body>
</html>