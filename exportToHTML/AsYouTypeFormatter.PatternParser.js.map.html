<html>
<head>
<title>AsYouTypeFormatter.PatternParser.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
AsYouTypeFormatter.PatternParser.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;AsYouTypeFormatter.PatternParser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;PatternParser&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;_classCallCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;_createClass&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;or&quot;</span><span class="s0">,</span><span class="s1">&quot;instructions&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePattern&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;_this$context$&quot;</span><span class="s0">,</span><span class="s1">&quot;branches&quot;</span><span class="s0">,</span><span class="s1">&quot;op&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;expandSingleElementArray&quot;</span><span class="s0">,</span><span class="s1">&quot;startContext&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;endContext&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;getContext&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;OPERATOR&quot;</span><span class="s0">,</span><span class="s1">&quot;ILLEGAL_CHARACTER_REGEXP&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;before&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;rightPart&quot;</span><span class="s0">,</span><span class="s1">&quot;_this$getContext&quot;</span><span class="s0">,</span><span class="s1">&quot;oneOfSet&quot;</span><span class="s0">,</span><span class="s1">&quot;parseOneOfSet&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;prevValue&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;nextValue&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;array&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../source/AsYouTypeFormatter.PatternParser.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export default class PatternParser {</span><span class="s3">\r\n\t</span><span class="s1">parse(pattern) {</span><span class="s3">\r\n\t\t</span><span class="s1">this.context = [{</span><span class="s3">\r\n\t\t\t</span><span class="s1">or: true,</span><span class="s3">\r\n\t\t\t</span><span class="s1">instructions: []</span><span class="s3">\r\n\t\t</span><span class="s1">}]</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">this.parsePattern(pattern)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (this.context.length !== 1) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">throw new Error('Non-finalized contexts left when pattern parse ended')</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">const { branches, instructions } = this.context[0]</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (branches) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">op: '|',</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">args: branches.concat([</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">expandSingleElementArray(instructions)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">])</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">/* istanbul ignore if */</span><span class="s3">\r\n\t\t</span><span class="s1">if (instructions.length === 0) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">throw new Error('Pattern is required')</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (instructions.length === 1) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return instructions[0]</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">return instructions</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">startContext(context) {</span><span class="s3">\r\n\t\t</span><span class="s1">this.context.push(context)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">endContext() {</span><span class="s3">\r\n\t\t</span><span class="s1">this.context.pop()</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">getContext() {</span><span class="s3">\r\n\t\t</span><span class="s1">return this.context[this.context.length - 1]</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">parsePattern(pattern) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (!pattern) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">throw new Error('Pattern is required')</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">const match = pattern.match(OPERATOR)</span><span class="s3">\r\n\t\t</span><span class="s1">if (!match) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">throw new Error(`Illegal characters found in a pattern: ${pattern}`)</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.getContext().instructions = this.getContext().instructions.concat(</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">pattern.split('')</span><span class="s3">\r\n\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t</span><span class="s1">return</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">const operator = match[1]</span><span class="s3">\r\n\t\t</span><span class="s1">const before = pattern.slice(0, match.index)</span><span class="s3">\r\n\t\t</span><span class="s1">const rightPart = pattern.slice(match.index + operator.length)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">switch (operator) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">case '(?:':</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (before) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.parsePattern(before)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.startContext({</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">or: true,</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">instructions: [],</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">branches: []</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">break</span><span class="s3">\r\n\r\n\t\t\t</span><span class="s1">case ')':</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (!this.getContext().or) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">operator must be preceded by </span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot; </span><span class="s1">operator')</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (before) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.parsePattern(before)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (this.getContext().instructions.length === 0) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">throw new Error('No instructions found after </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">operator in an </span><span class="s3">\&quot;</span><span class="s1">or</span><span class="s3">\&quot; </span><span class="s1">group')</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">const { branches } = this.getContext()</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">branches.push(</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">expandSingleElementArray(</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">this.getContext().instructions</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.endContext()</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.getContext().instructions.push({</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">op: '|',</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">args: branches</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">break</span><span class="s3">\r\n\r\n\t\t\t</span><span class="s1">case '|':</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (!this.getContext().or) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">operator can only be used inside </span><span class="s3">\&quot;</span><span class="s1">or</span><span class="s3">\&quot; </span><span class="s1">groups')</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (before) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.parsePattern(before)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// The top-level is an implicit </span><span class="s3">\&quot;</span><span class="s1">or</span><span class="s3">\&quot; </span><span class="s1">group, if required.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (!this.getContext().branches) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">// `branches` are not defined only for the root implicit </span><span class="s3">\&quot;</span><span class="s1">or</span><span class="s3">\&quot; </span><span class="s1">operator.</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">/* istanbul ignore else */</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">if (this.context.length === 1) {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">this.getContext().branches = []</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">branches</span><span class="s3">\&quot; </span><span class="s1">not found in an </span><span class="s3">\&quot;</span><span class="s1">or</span><span class="s3">\&quot; </span><span class="s1">group context')</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.getContext().branches.push(</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">expandSingleElementArray(</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">this.getContext().instructions</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.getContext().instructions = []</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">break</span><span class="s3">\r\n\r\n\t\t\t</span><span class="s1">case '[':</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (before) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">this.parsePattern(before)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.startContext({</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">oneOfSet: true</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">break</span><span class="s3">\r\n\r\n\t\t\t</span><span class="s1">case ']':</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (!this.getContext().oneOfSet) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot; </span><span class="s1">operator must be preceded by </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">operator')</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.endContext()</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">this.getContext().instructions.push({</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">op: '[]',</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">args: parseOneOfSet(before)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">})</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">break</span><span class="s3">\r\n\r\n\t\t\t</span><span class="s1">/* istanbul ignore next */</span><span class="s3">\r\n\t\t\t</span><span class="s1">default:</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">throw new Error(`Unknown operator: ${operator}`)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (rightPart) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">this.parsePattern(rightPart)</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">function parseOneOfSet(pattern) {</span><span class="s3">\r\n\t</span><span class="s1">const values = []</span><span class="s3">\r\n\t</span><span class="s1">let i = 0</span><span class="s3">\r\n\t</span><span class="s1">while (i &lt; pattern.length) {</span><span class="s3">\r\n\t\t</span><span class="s1">if (pattern[i] === '-') {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (i === 0 || i === pattern.length - 1) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">throw new Error(`Couldn't parse a one-of set pattern: ${pattern}`)</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">const prevValue = pattern[i - 1].charCodeAt(0) + 1</span><span class="s3">\r\n\t\t\t</span><span class="s1">const nextValue = pattern[i + 1].charCodeAt(0) - 1</span><span class="s3">\r\n\t\t\t</span><span class="s1">let value = prevValue</span><span class="s3">\r\n\t\t\t</span><span class="s1">while (value &lt;= nextValue) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">values.push(String.fromCharCode(value))</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">value++</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t</span><span class="s1">values.push(pattern[i])</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">i++</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">return values</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">const ILLEGAL_CHARACTER_REGEXP = /[</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">?</span><span class="s3">\\</span><span class="s1">:</span><span class="s3">\\</span><span class="s1">|]/</span><span class="s3">\r\n\r\n</span><span class="s1">const OPERATOR = new RegExp(</span><span class="s3">\r\n\t</span><span class="s1">// any of:</span><span class="s3">\r\n\t</span><span class="s1">'(' +</span><span class="s3">\r\n\t\t</span><span class="s1">// or operator</span><span class="s3">\r\n\t\t</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">|' +</span><span class="s3">\r\n\t\t</span><span class="s1">// or</span><span class="s3">\r\n\t\t</span><span class="s1">'|' +</span><span class="s3">\r\n\t\t</span><span class="s1">// or group start</span><span class="s3">\r\n\t\t</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:' +</span><span class="s3">\r\n\t\t</span><span class="s1">// or</span><span class="s3">\r\n\t\t</span><span class="s1">'|' +</span><span class="s3">\r\n\t\t</span><span class="s1">// or group end</span><span class="s3">\r\n\t\t</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">)' +</span><span class="s3">\r\n\t\t</span><span class="s1">// or</span><span class="s3">\r\n\t\t</span><span class="s1">'|' +</span><span class="s3">\r\n\t\t</span><span class="s1">// one-of set start</span><span class="s3">\r\n\t\t</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">[' +</span><span class="s3">\r\n\t\t</span><span class="s1">// or</span><span class="s3">\r\n\t\t</span><span class="s1">'|' +</span><span class="s3">\r\n\t\t</span><span class="s1">// one-of set end</span><span class="s3">\r\n\t\t</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">]' +</span><span class="s3">\r\n\t</span><span class="s1">')'</span><span class="s3">\r\n</span><span class="s1">)</span><span class="s3">\r\n\r\n</span><span class="s1">function expandSingleElementArray(array) {</span><span class="s3">\r\n\t</span><span class="s1">if (array.length === 1) {</span><span class="s3">\r\n\t\t</span><span class="s1">return array[0]</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">return array</span><span class="s3">\r\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>