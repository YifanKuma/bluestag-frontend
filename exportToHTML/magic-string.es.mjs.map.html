<html>
<head>
<title>magic-string.es.mjs.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
magic-string.es.mjs.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;magic-string.es.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/BitSet.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/Chunk.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/SourceMap.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/guessIndent.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/getRelativePath.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/isObject.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/getLocator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/Mappings.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/MagicString.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/Bundle.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export default class BitSet {</span><span class="s3">\n\t</span><span class="s1">constructor(arg) {</span><span class="s3">\n\t\t</span><span class="s1">this.bits = arg instanceof BitSet ? arg.bits.slice() : [];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">add(n) {</span><span class="s3">\n\t\t</span><span class="s1">this.bits[n &gt;&gt; 5] |= 1 &lt;&lt; (n &amp; 31);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">has(n) {</span><span class="s3">\n\t\t</span><span class="s1">return !!(this.bits[n &gt;&gt; 5] &amp; (1 &lt;&lt; (n &amp; 31)));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default class Chunk {</span><span class="s3">\n\t</span><span class="s1">constructor(start, end, content) {</span><span class="s3">\n\t\t</span><span class="s1">this.start = start;</span><span class="s3">\n\t\t</span><span class="s1">this.end = end;</span><span class="s3">\n\t\t</span><span class="s1">this.original = content;</span><span class="s3">\n\n\t\t</span><span class="s1">this.intro = '';</span><span class="s3">\n\t\t</span><span class="s1">this.outro = '';</span><span class="s3">\n\n\t\t</span><span class="s1">this.content = content;</span><span class="s3">\n\t\t</span><span class="s1">this.storeName = false;</span><span class="s3">\n\t\t</span><span class="s1">this.edited = false;</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) {</span><span class="s3">\n\t\t\t</span><span class="s1">// we make these non-enumerable, for sanity while debugging</span><span class="s3">\n\t\t\t</span><span class="s1">Object.defineProperties(this, {</span><span class="s3">\n\t\t\t\t</span><span class="s1">previous: { writable: true, value: null },</span><span class="s3">\n\t\t\t\t</span><span class="s1">next: { writable: true, value: null },</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.previous = null;</span><span class="s3">\n\t\t\t</span><span class="s1">this.next = null;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">appendLeft(content) {</span><span class="s3">\n\t\t</span><span class="s1">this.outro += content;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">appendRight(content) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = this.intro + content;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">clone() {</span><span class="s3">\n\t\t</span><span class="s1">const chunk = new Chunk(this.start, this.end, this.original);</span><span class="s3">\n\n\t\t</span><span class="s1">chunk.intro = this.intro;</span><span class="s3">\n\t\t</span><span class="s1">chunk.outro = this.outro;</span><span class="s3">\n\t\t</span><span class="s1">chunk.content = this.content;</span><span class="s3">\n\t\t</span><span class="s1">chunk.storeName = this.storeName;</span><span class="s3">\n\t\t</span><span class="s1">chunk.edited = this.edited;</span><span class="s3">\n\n\t\t</span><span class="s1">return chunk;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">contains(index) {</span><span class="s3">\n\t\t</span><span class="s1">return this.start &lt; index &amp;&amp; index &lt; this.end;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">eachNext(fn) {</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">fn(chunk);</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">eachPrevious(fn) {</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">fn(chunk);</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.previous;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">edit(content, storeName, contentOnly) {</span><span class="s3">\n\t\t</span><span class="s1">this.content = content;</span><span class="s3">\n\t\t</span><span class="s1">if (!contentOnly) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro = '';</span><span class="s3">\n\t\t\t</span><span class="s1">this.outro = '';</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">this.storeName = storeName;</span><span class="s3">\n\n\t\t</span><span class="s1">this.edited = true;</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prependLeft(content) {</span><span class="s3">\n\t\t</span><span class="s1">this.outro = content + this.outro;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prependRight(content) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = content + this.intro;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">reset() {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = '';</span><span class="s3">\n\t\t</span><span class="s1">this.outro = '';</span><span class="s3">\n\t\t</span><span class="s1">if (this.edited) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.content = this.original;</span><span class="s3">\n\t\t\t</span><span class="s1">this.storeName = false;</span><span class="s3">\n\t\t\t</span><span class="s1">this.edited = false;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">split(index) {</span><span class="s3">\n\t\t</span><span class="s1">const sliceIndex = index - this.start;</span><span class="s3">\n\n\t\t</span><span class="s1">const originalBefore = this.original.slice(0, sliceIndex);</span><span class="s3">\n\t\t</span><span class="s1">const originalAfter = this.original.slice(sliceIndex);</span><span class="s3">\n\n\t\t</span><span class="s1">this.original = originalBefore;</span><span class="s3">\n\n\t\t</span><span class="s1">const newChunk = new Chunk(index, this.end, originalAfter);</span><span class="s3">\n\t\t</span><span class="s1">newChunk.outro = this.outro;</span><span class="s3">\n\t\t</span><span class="s1">this.outro = '';</span><span class="s3">\n\n\t\t</span><span class="s1">this.end = index;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.edited) {</span><span class="s3">\n\t\t\t</span><span class="s1">// after split we should save the edit content record into the correct chunk</span><span class="s3">\n\t\t\t</span><span class="s1">// to make sure sourcemap correct</span><span class="s3">\n\t\t\t</span><span class="s1">// For example:</span><span class="s3">\n\t\t\t</span><span class="s1">// '  test'.trim()</span><span class="s3">\n\t\t\t</span><span class="s1">//     split   -&gt; '  ' + 'test'</span><span class="s3">\n\t\t\t</span><span class="s1">//   ✔️ edit    -&gt; '' + 'test'</span><span class="s3">\n\t\t\t</span><span class="s1">//   ✖️ edit    -&gt; 'test' + ''</span><span class="s3">\n\t\t\t</span><span class="s1">// TODO is this block necessary?...</span><span class="s3">\n\t\t\t</span><span class="s1">newChunk.edit('', false);</span><span class="s3">\n\t\t\t</span><span class="s1">this.content = '';</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.content = originalBefore;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">newChunk.next = this.next;</span><span class="s3">\n\t\t</span><span class="s1">if (newChunk.next) newChunk.next.previous = newChunk;</span><span class="s3">\n\t\t</span><span class="s1">newChunk.previous = this;</span><span class="s3">\n\t\t</span><span class="s1">this.next = newChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">return newChunk;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toString() {</span><span class="s3">\n\t\t</span><span class="s1">return this.intro + this.content + this.outro;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimEnd(rx) {</span><span class="s3">\n\t\t</span><span class="s1">this.outro = this.outro.replace(rx, '');</span><span class="s3">\n\t\t</span><span class="s1">if (this.outro.length) return true;</span><span class="s3">\n\n\t\t</span><span class="s1">const trimmed = this.content.replace(rx, '');</span><span class="s3">\n\n\t\t</span><span class="s1">if (trimmed.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (trimmed !== this.content) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.split(this.start + trimmed.length).edit('', undefined, true);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (this.edited) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">// save the change, if it has been edited</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">this.edit(trimmed, this.storeName, true);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">return true;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.edit('', undefined, true);</span><span class="s3">\n\n\t\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\t\t\t</span><span class="s1">if (this.intro.length) return true;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimStart(rx) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\t\t</span><span class="s1">if (this.intro.length) return true;</span><span class="s3">\n\n\t\t</span><span class="s1">const trimmed = this.content.replace(rx, '');</span><span class="s3">\n\n\t\t</span><span class="s1">if (trimmed.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (trimmed !== this.content) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const newChunk = this.split(this.end - trimmed.length);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (this.edited) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">// save the change, if it has been edited</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">newChunk.edit(trimmed, this.storeName, true);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.edit('', undefined, true);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">return true;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.edit('', undefined, true);</span><span class="s3">\n\n\t\t\t</span><span class="s1">this.outro = this.outro.replace(rx, '');</span><span class="s3">\n\t\t\t</span><span class="s1">if (this.outro.length) return true;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { encode } from '@jridgewell/sourcemap-codec';</span><span class="s3">\n\n</span><span class="s1">function getBtoa() {</span><span class="s3">\n\t</span><span class="s1">if (typeof globalThis !== 'undefined' &amp;&amp; typeof globalThis.btoa === 'function') {</span><span class="s3">\n\t\t</span><span class="s1">return (str) =&gt; globalThis.btoa(unescape(encodeURIComponent(str)));</span><span class="s3">\n\t</span><span class="s1">} else if (typeof Buffer === 'function') {</span><span class="s3">\n\t\t</span><span class="s1">return (str) =&gt; Buffer.from(str, 'utf-8').toString('base64');</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">return () =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');</span><span class="s3">\n\t\t</span><span class="s1">};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const btoa = /*#__PURE__*/ getBtoa();</span><span class="s3">\n\n</span><span class="s1">export default class SourceMap {</span><span class="s3">\n\t</span><span class="s1">constructor(properties) {</span><span class="s3">\n\t\t</span><span class="s1">this.version = 3;</span><span class="s3">\n\t\t</span><span class="s1">this.file = properties.file;</span><span class="s3">\n\t\t</span><span class="s1">this.sources = properties.sources;</span><span class="s3">\n\t\t</span><span class="s1">this.sourcesContent = properties.sourcesContent;</span><span class="s3">\n\t\t</span><span class="s1">this.names = properties.names;</span><span class="s3">\n\t\t</span><span class="s1">this.mappings = encode(properties.mappings);</span><span class="s3">\n\t\t</span><span class="s1">if (typeof properties.x_google_ignoreList !== 'undefined') {</span><span class="s3">\n\t\t\t</span><span class="s1">this.x_google_ignoreList = properties.x_google_ignoreList;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">if (typeof properties.debugId !== 'undefined') {</span><span class="s3">\n\t\t\t</span><span class="s1">this.debugId = properties.debugId;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toString() {</span><span class="s3">\n\t\t</span><span class="s1">return JSON.stringify(this);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toUrl() {</span><span class="s3">\n\t\t</span><span class="s1">return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function guessIndent(code) {</span><span class="s3">\n\t</span><span class="s1">const lines = code.split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n\n\t</span><span class="s1">const tabbed = lines.filter((line) =&gt; /^</span><span class="s3">\\</span><span class="s1">t+/.test(line));</span><span class="s3">\n\t</span><span class="s1">const spaced = lines.filter((line) =&gt; /^ {2,}/.test(line));</span><span class="s3">\n\n\t</span><span class="s1">if (tabbed.length === 0 &amp;&amp; spaced.length === 0) {</span><span class="s3">\n\t\t</span><span class="s1">return null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// More lines tabbed than spaced? Assume tabs, and</span><span class="s3">\n\t</span><span class="s1">// default to tabs in the case of a tie (or nothing</span><span class="s3">\n\t</span><span class="s1">// to go on)</span><span class="s3">\n\t</span><span class="s1">if (tabbed.length &gt;= spaced.length) {</span><span class="s3">\n\t\t</span><span class="s1">return '</span><span class="s3">\\</span><span class="s1">t';</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Otherwise, we need to guess the multiple</span><span class="s3">\n\t</span><span class="s1">const min = spaced.reduce((previous, current) =&gt; {</span><span class="s3">\n\t\t</span><span class="s1">const numSpaces = /^ +/.exec(current)[0].length;</span><span class="s3">\n\t\t</span><span class="s1">return Math.min(numSpaces, previous);</span><span class="s3">\n\t</span><span class="s1">}, Infinity);</span><span class="s3">\n\n\t</span><span class="s1">return new Array(min + 1).join(' ');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function getRelativePath(from, to) {</span><span class="s3">\n\t</span><span class="s1">const fromParts = from.split(/[/</span><span class="s3">\\\\</span><span class="s1">]/);</span><span class="s3">\n\t</span><span class="s1">const toParts = to.split(/[/</span><span class="s3">\\\\</span><span class="s1">]/);</span><span class="s3">\n\n\t</span><span class="s1">fromParts.pop(); // get dirname</span><span class="s3">\n\n\t</span><span class="s1">while (fromParts[0] === toParts[0]) {</span><span class="s3">\n\t\t</span><span class="s1">fromParts.shift();</span><span class="s3">\n\t\t</span><span class="s1">toParts.shift();</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (fromParts.length) {</span><span class="s3">\n\t\t</span><span class="s1">let i = fromParts.length;</span><span class="s3">\n\t\t</span><span class="s1">while (i--) fromParts[i] = '..';</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return fromParts.concat(toParts).join('/');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const toString = Object.prototype.toString;</span><span class="s3">\n\n</span><span class="s1">export default function isObject(thing) {</span><span class="s3">\n\t</span><span class="s1">return toString.call(thing) === '[object Object]';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function getLocator(source) {</span><span class="s3">\n\t</span><span class="s1">const originalLines = source.split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n\t</span><span class="s1">const lineOffsets = [];</span><span class="s3">\n\n\t</span><span class="s1">for (let i = 0, pos = 0; i &lt; originalLines.length; i++) {</span><span class="s3">\n\t\t</span><span class="s1">lineOffsets.push(pos);</span><span class="s3">\n\t\t</span><span class="s1">pos += originalLines[i].length + 1;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return function locate(index) {</span><span class="s3">\n\t\t</span><span class="s1">let i = 0;</span><span class="s3">\n\t\t</span><span class="s1">let j = lineOffsets.length;</span><span class="s3">\n\t\t</span><span class="s1">while (i &lt; j) {</span><span class="s3">\n\t\t\t</span><span class="s1">const m = (i + j) &gt;&gt; 1;</span><span class="s3">\n\t\t\t</span><span class="s1">if (index &lt; lineOffsets[m]) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">j = m;</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">i = m + 1;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">const line = i - 1;</span><span class="s3">\n\t\t</span><span class="s1">const column = index - lineOffsets[line];</span><span class="s3">\n\t\t</span><span class="s1">return { line, column };</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const wordRegex = /</span><span class="s3">\\</span><span class="s1">w/;</span><span class="s3">\n\n</span><span class="s1">export default class Mappings {</span><span class="s3">\n\t</span><span class="s1">constructor(hires) {</span><span class="s3">\n\t\t</span><span class="s1">this.hires = hires;</span><span class="s3">\n\t\t</span><span class="s1">this.generatedCodeLine = 0;</span><span class="s3">\n\t\t</span><span class="s1">this.generatedCodeColumn = 0;</span><span class="s3">\n\t\t</span><span class="s1">this.raw = [];</span><span class="s3">\n\t\t</span><span class="s1">this.rawSegments = this.raw[this.generatedCodeLine] = [];</span><span class="s3">\n\t\t</span><span class="s1">this.pending = null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">addEdit(sourceIndex, content, loc, nameIndex) {</span><span class="s3">\n\t\t</span><span class="s1">if (content.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">const contentLengthMinusOne = content.length - 1;</span><span class="s3">\n\t\t\t</span><span class="s1">let contentLineEnd = content.indexOf('</span><span class="s3">\\</span><span class="s1">n', 0);</span><span class="s3">\n\t\t\t</span><span class="s1">let previousContentLineEnd = -1;</span><span class="s3">\n\t\t\t</span><span class="s1">// Loop through each line in the content and add a segment, but stop if the last line is empty,</span><span class="s3">\n\t\t\t</span><span class="s1">// else code afterwards would fill one line too many</span><span class="s3">\n\t\t\t</span><span class="s1">while (contentLineEnd &gt;= 0 &amp;&amp; contentLengthMinusOne &gt; contentLineEnd) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (nameIndex &gt;= 0) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">segment.push(nameIndex);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">this.generatedCodeLine += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.raw[this.generatedCodeLine] = this.rawSegments = [];</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeColumn = 0;</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">previousContentLineEnd = contentLineEnd;</span><span class="s3">\n\t\t\t\t</span><span class="s1">contentLineEnd = content.indexOf('</span><span class="s3">\\</span><span class="s1">n', contentLineEnd + 1);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];</span><span class="s3">\n\t\t\t</span><span class="s1">if (nameIndex &gt;= 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">segment.push(nameIndex);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\n\t\t\t</span><span class="s1">this.advance(content.slice(previousContentLineEnd + 1));</span><span class="s3">\n\t\t</span><span class="s1">} else if (this.pending) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.rawSegments.push(this.pending);</span><span class="s3">\n\t\t\t</span><span class="s1">this.advance(content);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.pending = null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {</span><span class="s3">\n\t\t</span><span class="s1">let originalCharIndex = chunk.start;</span><span class="s3">\n\t\t</span><span class="s1">let first = true;</span><span class="s3">\n\t\t</span><span class="s1">// when iterating each char, check if it's in a word boundary</span><span class="s3">\n\t\t</span><span class="s1">let charInHiresBoundary = false;</span><span class="s3">\n\n\t\t</span><span class="s1">while (originalCharIndex &lt; chunk.end) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (original[originalCharIndex] === '</span><span class="s3">\\</span><span class="s1">n') {</span><span class="s3">\n\t\t\t\t</span><span class="s1">loc.line += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">loc.column = 0;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeLine += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.raw[this.generatedCodeLine] = this.rawSegments = [];</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeColumn = 0;</span><span class="s3">\n\t\t\t\t</span><span class="s1">first = true;</span><span class="s3">\n\t\t\t\t</span><span class="s1">charInHiresBoundary = false;</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];</span><span class="s3">\n\n\t\t\t\t\t</span><span class="s1">if (this.hires === 'boundary') {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">// in hires </span><span class="s3">\&quot;</span><span class="s1">boundary</span><span class="s3">\&quot;</span><span class="s1">, group segments per word boundary than per char</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">if (wordRegex.test(original[originalCharIndex])) {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">// for first char in the boundary found, start the boundary by pushing a segment</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">if (!charInHiresBoundary) {</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">charInHiresBoundary = true;</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">// for non-word char, end the boundary by pushing a segment</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">charInHiresBoundary = false;</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">this.rawSegments.push(segment);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">loc.column += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeColumn += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">first = false;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">originalCharIndex += 1;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.pending = null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">advance(str) {</span><span class="s3">\n\t\t</span><span class="s1">if (!str) return;</span><span class="s3">\n\n\t\t</span><span class="s1">const lines = str.split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n\n\t\t</span><span class="s1">if (lines.length &gt; 1) {</span><span class="s3">\n\t\t\t</span><span class="s1">for (let i = 0; i &lt; lines.length - 1; i++) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.generatedCodeLine++;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.raw[this.generatedCodeLine] = this.rawSegments = [];</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">this.generatedCodeColumn = 0;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.generatedCodeColumn += lines[lines.length - 1].length;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import BitSet from './BitSet.js';</span><span class="s3">\n</span><span class="s1">import Chunk from './Chunk.js';</span><span class="s3">\n</span><span class="s1">import SourceMap from './SourceMap.js';</span><span class="s3">\n</span><span class="s1">import guessIndent from './utils/guessIndent.js';</span><span class="s3">\n</span><span class="s1">import getRelativePath from './utils/getRelativePath.js';</span><span class="s3">\n</span><span class="s1">import isObject from './utils/isObject.js';</span><span class="s3">\n</span><span class="s1">import getLocator from './utils/getLocator.js';</span><span class="s3">\n</span><span class="s1">import Mappings from './utils/Mappings.js';</span><span class="s3">\n</span><span class="s1">import Stats from './utils/Stats.js';</span><span class="s3">\n\n</span><span class="s1">const n = '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\n</span><span class="s1">const warned = {</span><span class="s3">\n\t</span><span class="s1">insertLeft: false,</span><span class="s3">\n\t</span><span class="s1">insertRight: false,</span><span class="s3">\n\t</span><span class="s1">storeName: false,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default class MagicString {</span><span class="s3">\n\t</span><span class="s1">constructor(string, options = {}) {</span><span class="s3">\n\t\t</span><span class="s1">const chunk = new Chunk(0, string.length, string);</span><span class="s3">\n\n\t\t</span><span class="s1">Object.defineProperties(this, {</span><span class="s3">\n\t\t\t</span><span class="s1">original: { writable: true, value: string },</span><span class="s3">\n\t\t\t</span><span class="s1">outro: { writable: true, value: '' },</span><span class="s3">\n\t\t\t</span><span class="s1">intro: { writable: true, value: '' },</span><span class="s3">\n\t\t\t</span><span class="s1">firstChunk: { writable: true, value: chunk },</span><span class="s3">\n\t\t\t</span><span class="s1">lastChunk: { writable: true, value: chunk },</span><span class="s3">\n\t\t\t</span><span class="s1">lastSearchedChunk: { writable: true, value: chunk },</span><span class="s3">\n\t\t\t</span><span class="s1">byStart: { writable: true, value: {} },</span><span class="s3">\n\t\t\t</span><span class="s1">byEnd: { writable: true, value: {} },</span><span class="s3">\n\t\t\t</span><span class="s1">filename: { writable: true, value: options.filename },</span><span class="s3">\n\t\t\t</span><span class="s1">indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },</span><span class="s3">\n\t\t\t</span><span class="s1">sourcemapLocations: { writable: true, value: new BitSet() },</span><span class="s3">\n\t\t\t</span><span class="s1">storedNames: { writable: true, value: {} },</span><span class="s3">\n\t\t\t</span><span class="s1">indentStr: { writable: true, value: undefined },</span><span class="s3">\n\t\t\t</span><span class="s1">ignoreList: { writable: true, value: options.ignoreList },</span><span class="s3">\n\t\t\t</span><span class="s1">offset: { writable: true, value: options.offset || 0 },</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) {</span><span class="s3">\n\t\t\t</span><span class="s1">Object.defineProperty(this, 'stats', { value: new Stats() });</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.byStart[0] = chunk;</span><span class="s3">\n\t\t</span><span class="s1">this.byEnd[string.length] = chunk;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">addSourcemapLocation(char) {</span><span class="s3">\n\t\t</span><span class="s1">this.sourcemapLocations.add(char);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">append(content) {</span><span class="s3">\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('outro content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">this.outro += content;</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">appendLeft(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('inserted content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('appendLeft');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const chunk = this.byEnd[index];</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.appendLeft(content);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro += content;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('appendLeft');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">appendRight(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('inserted content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('appendRight');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const chunk = this.byStart[index];</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.appendRight(content);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.outro += content;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('appendRight');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">clone() {</span><span class="s3">\n\t\t</span><span class="s1">const cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });</span><span class="s3">\n\n\t\t</span><span class="s1">let originalChunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());</span><span class="s3">\n\n\t\t</span><span class="s1">while (originalChunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">cloned.byStart[clonedChunk.start] = clonedChunk;</span><span class="s3">\n\t\t\t</span><span class="s1">cloned.byEnd[clonedChunk.end] = clonedChunk;</span><span class="s3">\n\n\t\t\t</span><span class="s1">const nextOriginalChunk = originalChunk.next;</span><span class="s3">\n\t\t\t</span><span class="s1">const nextClonedChunk = nextOriginalChunk &amp;&amp; nextOriginalChunk.clone();</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (nextClonedChunk) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">clonedChunk.next = nextClonedChunk;</span><span class="s3">\n\t\t\t\t</span><span class="s1">nextClonedChunk.previous = clonedChunk;</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">clonedChunk = nextClonedChunk;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">originalChunk = nextOriginalChunk;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">cloned.lastChunk = clonedChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.indentExclusionRanges) {</span><span class="s3">\n\t\t\t</span><span class="s1">cloned.indentExclusionRanges = this.indentExclusionRanges.slice();</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);</span><span class="s3">\n\n\t\t</span><span class="s1">cloned.intro = this.intro;</span><span class="s3">\n\t\t</span><span class="s1">cloned.outro = this.outro;</span><span class="s3">\n\n\t\t</span><span class="s1">return cloned;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">generateDecodedMap(options) {</span><span class="s3">\n\t\t</span><span class="s1">options = options || {};</span><span class="s3">\n\n\t\t</span><span class="s1">const sourceIndex = 0;</span><span class="s3">\n\t\t</span><span class="s1">const names = Object.keys(this.storedNames);</span><span class="s3">\n\t\t</span><span class="s1">const mappings = new Mappings(options.hires);</span><span class="s3">\n\n\t\t</span><span class="s1">const locate = getLocator(this.original);</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.intro) {</span><span class="s3">\n\t\t\t</span><span class="s1">mappings.advance(this.intro);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.firstChunk.eachNext((chunk) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">const loc = locate(chunk.start);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.intro.length) mappings.advance(chunk.intro);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.edited) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.addEdit(</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">sourceIndex,</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">chunk.content,</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">loc,</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">chunk.storeName ? names.indexOf(chunk.original) : -1,</span><span class="s3">\n\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.outro.length) mappings.advance(chunk.outro);</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.outro) {</span><span class="s3">\n\t\t\t</span><span class="s1">mappings.advance(this.outro);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return {</span><span class="s3">\n\t\t\t</span><span class="s1">file: options.file ? options.file.split(/[/</span><span class="s3">\\\\</span><span class="s1">]/).pop() : undefined,</span><span class="s3">\n\t\t\t</span><span class="s1">sources: [</span><span class="s3">\n\t\t\t\t</span><span class="s1">options.source ? getRelativePath(options.file || '', options.source) : options.file || '',</span><span class="s3">\n\t\t\t</span><span class="s1">],</span><span class="s3">\n\t\t\t</span><span class="s1">sourcesContent: options.includeContent ? [this.original] : undefined,</span><span class="s3">\n\t\t\t</span><span class="s1">names,</span><span class="s3">\n\t\t\t</span><span class="s1">mappings: mappings.raw,</span><span class="s3">\n\t\t\t</span><span class="s1">x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,</span><span class="s3">\n\t\t</span><span class="s1">};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">generateMap(options) {</span><span class="s3">\n\t\t</span><span class="s1">return new SourceMap(this.generateDecodedMap(options));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_ensureindentStr() {</span><span class="s3">\n\t\t</span><span class="s1">if (this.indentStr === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.indentStr = guessIndent(this.original);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_getRawIndentString() {</span><span class="s3">\n\t\t</span><span class="s1">this._ensureindentStr();</span><span class="s3">\n\t\t</span><span class="s1">return this.indentStr;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">getIndentString() {</span><span class="s3">\n\t\t</span><span class="s1">this._ensureindentStr();</span><span class="s3">\n\t\t</span><span class="s1">return this.indentStr === null ? '</span><span class="s3">\\</span><span class="s1">t' : this.indentStr;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">indent(indentStr, options) {</span><span class="s3">\n\t\t</span><span class="s1">const pattern = /^[^</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n]/gm;</span><span class="s3">\n\n\t\t</span><span class="s1">if (isObject(indentStr)) {</span><span class="s3">\n\t\t\t</span><span class="s1">options = indentStr;</span><span class="s3">\n\t\t\t</span><span class="s1">indentStr = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (indentStr === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">this._ensureindentStr();</span><span class="s3">\n\t\t\t</span><span class="s1">indentStr = this.indentStr || '</span><span class="s3">\\</span><span class="s1">t';</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (indentStr === '') return this; // noop</span><span class="s3">\n\n\t\t</span><span class="s1">options = options || {};</span><span class="s3">\n\n\t\t</span><span class="s1">// Process exclusion ranges</span><span class="s3">\n\t\t</span><span class="s1">const isExcluded = {};</span><span class="s3">\n\n\t\t</span><span class="s1">if (options.exclude) {</span><span class="s3">\n\t\t\t</span><span class="s1">const exclusions =</span><span class="s3">\n\t\t\t\t</span><span class="s1">typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;</span><span class="s3">\n\t\t\t</span><span class="s1">exclusions.forEach((exclusion) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">for (let i = exclusion[0]; i &lt; exclusion[1]; i += 1) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">isExcluded[i] = true;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">let shouldIndentNextCharacter = options.indentStart !== false;</span><span class="s3">\n\t\t</span><span class="s1">const replacer = (match) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">if (shouldIndentNextCharacter) return `${indentStr}${match}`;</span><span class="s3">\n\t\t\t</span><span class="s1">shouldIndentNextCharacter = true;</span><span class="s3">\n\t\t\t</span><span class="s1">return match;</span><span class="s3">\n\t\t</span><span class="s1">};</span><span class="s3">\n\n\t\t</span><span class="s1">this.intro = this.intro.replace(pattern, replacer);</span><span class="s3">\n\n\t\t</span><span class="s1">let charIndex = 0;</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">const end = chunk.end;</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.edited) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (!isExcluded[charIndex]) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">chunk.content = chunk.content.replace(pattern, replacer);</span><span class="s3">\n\n\t\t\t\t\t</span><span class="s1">if (chunk.content.length) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">charIndex = chunk.start;</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">while (charIndex &lt; end) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (!isExcluded[charIndex]) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">const char = this.original[charIndex];</span><span class="s3">\n\n\t\t\t\t\t\t</span><span class="s1">if (char === '</span><span class="s3">\\</span><span class="s1">n') {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">shouldIndentNextCharacter = true;</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">} else if (char !== '</span><span class="s3">\\</span><span class="s1">r' &amp;&amp; shouldIndentNextCharacter) {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">shouldIndentNextCharacter = false;</span><span class="s3">\n\n\t\t\t\t\t\t\t</span><span class="s1">if (charIndex === chunk.start) {</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">chunk.prependRight(indentStr);</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">this._splitChunk(chunk, charIndex);</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t\t\t\t\t\t\t</span><span class="s1">chunk.prependRight(indentStr);</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t\t</span><span class="s1">charIndex += 1;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">charIndex = chunk.end;</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.outro = this.outro.replace(pattern, replacer);</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">insert() {</span><span class="s3">\n\t\t</span><span class="s1">throw new Error(</span><span class="s3">\n\t\t\t</span><span class="s1">'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',</span><span class="s3">\n\t\t</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">insertLeft(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">if (!warned.insertLeft) {</span><span class="s3">\n\t\t\t</span><span class="s1">console.warn(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">warned.insertLeft = true;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this.appendLeft(index, content);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">insertRight(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">if (!warned.insertRight) {</span><span class="s3">\n\t\t\t</span><span class="s1">console.warn(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">warned.insertRight = true;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this.prependRight(index, content);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">move(start, end, index) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (index &gt;= start &amp;&amp; index &lt;= end) throw new Error('Cannot move a selection inside itself');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('move');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(start);</span><span class="s3">\n\t\t</span><span class="s1">this._split(end);</span><span class="s3">\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const first = this.byStart[start];</span><span class="s3">\n\t\t</span><span class="s1">const last = this.byEnd[end];</span><span class="s3">\n\n\t\t</span><span class="s1">const oldLeft = first.previous;</span><span class="s3">\n\t\t</span><span class="s1">const oldRight = last.next;</span><span class="s3">\n\n\t\t</span><span class="s1">const newRight = this.byStart[index];</span><span class="s3">\n\t\t</span><span class="s1">if (!newRight &amp;&amp; last === this.lastChunk) return this;</span><span class="s3">\n\t\t</span><span class="s1">const newLeft = newRight ? newRight.previous : this.lastChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">if (oldLeft) oldLeft.next = oldRight;</span><span class="s3">\n\t\t</span><span class="s1">if (oldRight) oldRight.previous = oldLeft;</span><span class="s3">\n\n\t\t</span><span class="s1">if (newLeft) newLeft.next = first;</span><span class="s3">\n\t\t</span><span class="s1">if (newRight) newRight.previous = last;</span><span class="s3">\n\n\t\t</span><span class="s1">if (!first.previous) this.firstChunk = last.next;</span><span class="s3">\n\t\t</span><span class="s1">if (!last.next) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.lastChunk = first.previous;</span><span class="s3">\n\t\t\t</span><span class="s1">this.lastChunk.next = null;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">first.previous = newLeft;</span><span class="s3">\n\t\t</span><span class="s1">last.next = newRight || null;</span><span class="s3">\n\n\t\t</span><span class="s1">if (!newLeft) this.firstChunk = first;</span><span class="s3">\n\t\t</span><span class="s1">if (!newRight) this.lastChunk = last;</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('move');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">overwrite(start, end, content, options) {</span><span class="s3">\n\t\t</span><span class="s1">options = options || {};</span><span class="s3">\n\t\t</span><span class="s1">return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">update(start, end, content, options) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('replacement content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.original.length !== 0) {</span><span class="s3">\n\t\t\t</span><span class="s1">while (start &lt; 0) start += this.original.length;</span><span class="s3">\n\t\t\t</span><span class="s1">while (end &lt; 0) end += this.original.length;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (end &gt; this.original.length) throw new Error('end is out of bounds');</span><span class="s3">\n\t\t</span><span class="s1">if (start === end)</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('overwrite');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(start);</span><span class="s3">\n\t\t</span><span class="s1">this._split(end);</span><span class="s3">\n\n\t\t</span><span class="s1">if (options === true) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!warned.storeName) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">console.warn(</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',</span><span class="s3">\n\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t\t</span><span class="s1">warned.storeName = true;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">options = { storeName: true };</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">const storeName = options !== undefined ? options.storeName : false;</span><span class="s3">\n\t\t</span><span class="s1">const overwrite = options !== undefined ? options.overwrite : false;</span><span class="s3">\n\n\t\t</span><span class="s1">if (storeName) {</span><span class="s3">\n\t\t\t</span><span class="s1">const original = this.original.slice(start, end);</span><span class="s3">\n\t\t\t</span><span class="s1">Object.defineProperty(this.storedNames, original, {</span><span class="s3">\n\t\t\t\t</span><span class="s1">writable: true,</span><span class="s3">\n\t\t\t\t</span><span class="s1">value: true,</span><span class="s3">\n\t\t\t\t</span><span class="s1">enumerable: true,</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const first = this.byStart[start];</span><span class="s3">\n\t\t</span><span class="s1">const last = this.byEnd[end];</span><span class="s3">\n\n\t\t</span><span class="s1">if (first) {</span><span class="s3">\n\t\t\t</span><span class="s1">let chunk = first;</span><span class="s3">\n\t\t\t</span><span class="s1">while (chunk !== last) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (chunk.next !== this.byStart[chunk.end]) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">throw new Error('Cannot overwrite across a split point');</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t\t\t</span><span class="s1">chunk.edit('', false);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">first.edit(content, storeName, !overwrite);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">// must be inserting at the end</span><span class="s3">\n\t\t\t</span><span class="s1">const newChunk = new Chunk(start, end, '').edit(content, storeName);</span><span class="s3">\n\n\t\t\t</span><span class="s1">// TODO last chunk in the array may not be the last chunk, if it's moved...</span><span class="s3">\n\t\t\t</span><span class="s1">last.next = newChunk;</span><span class="s3">\n\t\t\t</span><span class="s1">newChunk.previous = last;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('overwrite');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prepend(content) {</span><span class="s3">\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('outro content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">this.intro = content + this.intro;</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prependLeft(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('inserted content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('insertRight');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const chunk = this.byEnd[index];</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.prependLeft(content);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro = content + this.intro;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('insertRight');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prependRight(index, content) {</span><span class="s3">\n\t\t</span><span class="s1">index = index + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (typeof content !== 'string') throw new TypeError('inserted content must be a string');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('insertRight');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">const chunk = this.byStart[index];</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.prependRight(content);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">this.outro = content + this.outro;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('insertRight');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">remove(start, end) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.original.length !== 0) {</span><span class="s3">\n\t\t\t</span><span class="s1">while (start &lt; 0) start += this.original.length;</span><span class="s3">\n\t\t\t</span><span class="s1">while (end &lt; 0) end += this.original.length;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (start === end) return this;</span><span class="s3">\n\n\t\t</span><span class="s1">if (start &lt; 0 || end &gt; this.original.length) throw new Error('Character is out of bounds');</span><span class="s3">\n\t\t</span><span class="s1">if (start &gt; end) throw new Error('end must be greater than start');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('remove');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(start);</span><span class="s3">\n\t\t</span><span class="s1">this._split(end);</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.byStart[start];</span><span class="s3">\n\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.intro = '';</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.outro = '';</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.edit('');</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = end &gt; chunk.end ? this.byStart[chunk.end] : null;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('remove');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">reset(start, end) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.original.length !== 0) {</span><span class="s3">\n\t\t\t</span><span class="s1">while (start &lt; 0) start += this.original.length;</span><span class="s3">\n\t\t\t</span><span class="s1">while (end &lt; 0) end += this.original.length;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (start === end) return this;</span><span class="s3">\n\n\t\t</span><span class="s1">if (start &lt; 0 || end &gt; this.original.length) throw new Error('Character is out of bounds');</span><span class="s3">\n\t\t</span><span class="s1">if (start &gt; end) throw new Error('end must be greater than start');</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('reset');</span><span class="s3">\n\n\t\t</span><span class="s1">this._split(start);</span><span class="s3">\n\t\t</span><span class="s1">this._split(end);</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.byStart[start];</span><span class="s3">\n\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">chunk.reset();</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = end &gt; chunk.end ? this.byStart[chunk.end] : null;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('reset');</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">lastChar() {</span><span class="s3">\n\t\t</span><span class="s1">if (this.outro.length) return this.outro[this.outro.length - 1];</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.lastChunk;</span><span class="s3">\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.content.length) return chunk.content[chunk.content.length - 1];</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];</span><span class="s3">\n\t\t</span><span class="s1">} while ((chunk = chunk.previous));</span><span class="s3">\n\t\t</span><span class="s1">if (this.intro.length) return this.intro[this.intro.length - 1];</span><span class="s3">\n\t\t</span><span class="s1">return '';</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">lastLine() {</span><span class="s3">\n\t\t</span><span class="s1">let lineIndex = this.outro.lastIndexOf(n);</span><span class="s3">\n\t\t</span><span class="s1">if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);</span><span class="s3">\n\t\t</span><span class="s1">let lineStr = this.outro;</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.lastChunk;</span><span class="s3">\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.outro.length &gt; 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineIndex = chunk.outro.lastIndexOf(n);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineStr = chunk.outro + lineStr;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.content.length &gt; 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineIndex = chunk.content.lastIndexOf(n);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineStr = chunk.content + lineStr;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.intro.length &gt; 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineIndex = chunk.intro.lastIndexOf(n);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;</span><span class="s3">\n\t\t\t\t</span><span class="s1">lineStr = chunk.intro + lineStr;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} while ((chunk = chunk.previous));</span><span class="s3">\n\t\t</span><span class="s1">lineIndex = this.intro.lastIndexOf(n);</span><span class="s3">\n\t\t</span><span class="s1">if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;</span><span class="s3">\n\t\t</span><span class="s1">return this.intro + lineStr;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">slice(start = 0, end = this.original.length - this.offset) {</span><span class="s3">\n\t\t</span><span class="s1">start = start + this.offset;</span><span class="s3">\n\t\t</span><span class="s1">end = end + this.offset;</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.original.length !== 0) {</span><span class="s3">\n\t\t\t</span><span class="s1">while (start &lt; 0) start += this.original.length;</span><span class="s3">\n\t\t\t</span><span class="s1">while (end &lt; 0) end += this.original.length;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">let result = '';</span><span class="s3">\n\n\t\t</span><span class="s1">// find start chunk</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk &amp;&amp; (chunk.start &gt; start || chunk.end &lt;= start)) {</span><span class="s3">\n\t\t\t</span><span class="s1">// found end chunk before start</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.start &lt; end &amp;&amp; chunk.end &gt;= end) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return result;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk &amp;&amp; chunk.edited &amp;&amp; chunk.start !== start)</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);</span><span class="s3">\n\n\t\t</span><span class="s1">const startChunk = chunk;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.intro &amp;&amp; (startChunk !== chunk || chunk.start === start)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">result += chunk.intro;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const containsEnd = chunk.start &lt; end &amp;&amp; chunk.end &gt;= end;</span><span class="s3">\n\t\t\t</span><span class="s1">if (containsEnd &amp;&amp; chunk.edited &amp;&amp; chunk.end !== end)</span><span class="s3">\n\t\t\t\t</span><span class="s1">throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);</span><span class="s3">\n\n\t\t\t</span><span class="s1">const sliceStart = startChunk === chunk ? start - chunk.start : 0;</span><span class="s3">\n\t\t\t</span><span class="s1">const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;</span><span class="s3">\n\n\t\t\t</span><span class="s1">result += chunk.content.slice(sliceStart, sliceEnd);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.outro &amp;&amp; (!containsEnd || chunk.end === end)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">result += chunk.outro;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (containsEnd) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// TODO deprecate this? not really very useful</span><span class="s3">\n\t</span><span class="s1">snip(start, end) {</span><span class="s3">\n\t\t</span><span class="s1">const clone = this.clone();</span><span class="s3">\n\t\t</span><span class="s1">clone.remove(0, start);</span><span class="s3">\n\t\t</span><span class="s1">clone.remove(end, clone.original.length);</span><span class="s3">\n\n\t\t</span><span class="s1">return clone;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_split(index) {</span><span class="s3">\n\t\t</span><span class="s1">if (this.byStart[index] || this.byEnd[index]) return;</span><span class="s3">\n\n\t\t</span><span class="s1">if (DEBUG) this.stats.time('_split');</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.lastSearchedChunk;</span><span class="s3">\n\t\t</span><span class="s1">let previousChunk = chunk;</span><span class="s3">\n\t\t</span><span class="s1">const searchForward = index &gt; chunk.end;</span><span class="s3">\n\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.contains(index)) return this._splitChunk(chunk, index);</span><span class="s3">\n\n\t\t\t</span><span class="s1">chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];</span><span class="s3">\n\n\t\t\t</span><span class="s1">// Prevent infinite loop (e.g. via empty chunks, where start === end)</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk === previousChunk) return;</span><span class="s3">\n\n\t\t\t</span><span class="s1">previousChunk = chunk;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_splitChunk(chunk, index) {</span><span class="s3">\n\t\t</span><span class="s1">if (chunk.edited &amp;&amp; chunk.content.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">// zero-length edited chunks are a special case (overlapping replacements)</span><span class="s3">\n\t\t\t</span><span class="s1">const loc = getLocator(this.original)(index);</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error(</span><span class="s3">\n\t\t\t\t</span><span class="s1">`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – </span><span class="s3">\&quot;</span><span class="s1">${chunk.original}</span><span class="s3">\&quot;</span><span class="s1">)`,</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const newChunk = chunk.split(index);</span><span class="s3">\n\n\t\t</span><span class="s1">this.byEnd[index] = chunk;</span><span class="s3">\n\t\t</span><span class="s1">this.byStart[index] = newChunk;</span><span class="s3">\n\t\t</span><span class="s1">this.byEnd[newChunk.end] = newChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">if (chunk === this.lastChunk) this.lastChunk = newChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">this.lastSearchedChunk = chunk;</span><span class="s3">\n\t\t</span><span class="s1">if (DEBUG) this.stats.timeEnd('_split');</span><span class="s3">\n\t\t</span><span class="s1">return true;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toString() {</span><span class="s3">\n\t\t</span><span class="s1">let str = this.intro;</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">while (chunk) {</span><span class="s3">\n\t\t\t</span><span class="s1">str += chunk.toString();</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return str + this.outro;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">isEmpty() {</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">if (</span><span class="s3">\n\t\t\t\t</span><span class="s1">(chunk.intro.length &amp;&amp; chunk.intro.trim()) ||</span><span class="s3">\n\t\t\t\t</span><span class="s1">(chunk.content.length &amp;&amp; chunk.content.trim()) ||</span><span class="s3">\n\t\t\t\t</span><span class="s1">(chunk.outro.length &amp;&amp; chunk.outro.trim())</span><span class="s3">\n\t\t\t</span><span class="s1">)</span><span class="s3">\n\t\t\t\t</span><span class="s1">return false;</span><span class="s3">\n\t\t</span><span class="s1">} while ((chunk = chunk.next));</span><span class="s3">\n\t\t</span><span class="s1">return true;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">length() {</span><span class="s3">\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\t\t</span><span class="s1">let length = 0;</span><span class="s3">\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">length += chunk.intro.length + chunk.content.length + chunk.outro.length;</span><span class="s3">\n\t\t</span><span class="s1">} while ((chunk = chunk.next));</span><span class="s3">\n\t\t</span><span class="s1">return length;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimLines() {</span><span class="s3">\n\t\t</span><span class="s1">return this.trim('[</span><span class="s3">\\\\</span><span class="s1">r</span><span class="s3">\\\\</span><span class="s1">n]');</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trim(charType) {</span><span class="s3">\n\t\t</span><span class="s1">return this.trimStart(charType).trimEnd(charType);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimEndAborted(charType) {</span><span class="s3">\n\t\t</span><span class="s1">const rx = new RegExp((charType || '</span><span class="s3">\\\\</span><span class="s1">s') + '+$');</span><span class="s3">\n\n\t\t</span><span class="s1">this.outro = this.outro.replace(rx, '');</span><span class="s3">\n\t\t</span><span class="s1">if (this.outro.length) return true;</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.lastChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">const end = chunk.end;</span><span class="s3">\n\t\t\t</span><span class="s1">const aborted = chunk.trimEnd(rx);</span><span class="s3">\n\n\t\t\t</span><span class="s1">// if chunk was trimmed, we have a new lastChunk</span><span class="s3">\n\t\t\t</span><span class="s1">if (chunk.end !== end) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (this.lastChunk === chunk) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">this.lastChunk = chunk.next;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">this.byEnd[chunk.end] = chunk;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.byStart[chunk.next.start] = chunk.next;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.byEnd[chunk.next.end] = chunk.next;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (aborted) return true;</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.previous;</span><span class="s3">\n\t\t</span><span class="s1">} while (chunk);</span><span class="s3">\n\n\t\t</span><span class="s1">return false;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimEnd(charType) {</span><span class="s3">\n\t\t</span><span class="s1">this.trimEndAborted(charType);</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">trimStartAborted(charType) {</span><span class="s3">\n\t\t</span><span class="s1">const rx = new RegExp('^' + (charType || '</span><span class="s3">\\\\</span><span class="s1">s') + '+');</span><span class="s3">\n\n\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\t\t</span><span class="s1">if (this.intro.length) return true;</span><span class="s3">\n\n\t\t</span><span class="s1">let chunk = this.firstChunk;</span><span class="s3">\n\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">const end = chunk.end;</span><span class="s3">\n\t\t\t</span><span class="s1">const aborted = chunk.trimStart(rx);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (chunk.end !== end) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">// special case...</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (chunk === this.lastChunk) this.lastChunk = chunk.next;</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">this.byEnd[chunk.end] = chunk;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.byStart[chunk.next.start] = chunk.next;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.byEnd[chunk.next.end] = chunk.next;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (aborted) return true;</span><span class="s3">\n\t\t\t</span><span class="s1">chunk = chunk.next;</span><span class="s3">\n\t\t</span><span class="s1">} while (chunk);</span><span class="s3">\n\n\t\t</span><span class="s1">return false;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimStart(charType) {</span><span class="s3">\n\t\t</span><span class="s1">this.trimStartAborted(charType);</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">hasChanged() {</span><span class="s3">\n\t\t</span><span class="s1">return this.original !== this.toString();</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_replaceRegexp(searchValue, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">function getReplacement(match, str) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (typeof replacement === 'string') {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return replacement.replace(/</span><span class="s3">\\</span><span class="s1">$(</span><span class="s3">\\</span><span class="s1">$|&amp;|</span><span class="s3">\\</span><span class="s1">d+)/g, (_, i) =&gt; {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (i === '$') return '$';</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (i === '&amp;') return match[0];</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const num = +i;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (num &lt; match.length) return match[+i];</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">return `$${i}`;</span><span class="s3">\n\t\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return replacement(...match, match.index, str, match.groups);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">function matchAll(re, str) {</span><span class="s3">\n\t\t\t</span><span class="s1">let match;</span><span class="s3">\n\t\t\t</span><span class="s1">const matches = [];</span><span class="s3">\n\t\t\t</span><span class="s1">while ((match = re.exec(str))) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">matches.push(match);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">return matches;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">if (searchValue.global) {</span><span class="s3">\n\t\t\t</span><span class="s1">const matches = matchAll(searchValue, this.original);</span><span class="s3">\n\t\t\t</span><span class="s1">matches.forEach((match) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (match.index != null) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const replacement = getReplacement(match, this.original);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (replacement !== match[0]) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">this.overwrite(match.index, match.index + match[0].length, replacement);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">const match = this.original.match(searchValue);</span><span class="s3">\n\t\t\t</span><span class="s1">if (match &amp;&amp; match.index != null) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const replacement = getReplacement(match, this.original);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (replacement !== match[0]) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">this.overwrite(match.index, match.index + match[0].length, replacement);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_replaceString(string, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">const { original } = this;</span><span class="s3">\n\t\t</span><span class="s1">const index = original.indexOf(string);</span><span class="s3">\n\n\t\t</span><span class="s1">if (index !== -1) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (typeof replacement === 'function') {</span><span class="s3">\n\t\t\t\t</span><span class="s1">replacement = replacement(string, index, original);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (string !== replacement) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.overwrite(index, index + string.length, replacement);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">replace(searchValue, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">if (typeof searchValue === 'string') {</span><span class="s3">\n\t\t\t</span><span class="s1">return this._replaceString(searchValue, replacement);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this._replaceRegexp(searchValue, replacement);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">_replaceAllString(string, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">const { original } = this;</span><span class="s3">\n\t\t</span><span class="s1">const stringLength = string.length;</span><span class="s3">\n\t\t</span><span class="s1">for (</span><span class="s3">\n\t\t\t</span><span class="s1">let index = original.indexOf(string);</span><span class="s3">\n\t\t\t</span><span class="s1">index !== -1;</span><span class="s3">\n\t\t\t</span><span class="s1">index = original.indexOf(string, index + stringLength)</span><span class="s3">\n\t\t</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">const previous = original.slice(index, index + stringLength);</span><span class="s3">\n\t\t\t</span><span class="s1">let _replacement = replacement;</span><span class="s3">\n\t\t\t</span><span class="s1">if (typeof replacement === 'function') {</span><span class="s3">\n\t\t\t\t</span><span class="s1">_replacement = replacement(previous, index, original);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">replaceAll(searchValue, replacement) {</span><span class="s3">\n\t\t</span><span class="s1">if (typeof searchValue === 'string') {</span><span class="s3">\n\t\t\t</span><span class="s1">return this._replaceAllString(searchValue, replacement);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (!searchValue.global) {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new TypeError(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'MagicString.prototype.replaceAll called with a non-global RegExp argument',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this._replaceRegexp(searchValue, replacement);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import MagicString from './MagicString.js';</span><span class="s3">\n</span><span class="s1">import SourceMap from './SourceMap.js';</span><span class="s3">\n</span><span class="s1">import getRelativePath from './utils/getRelativePath.js';</span><span class="s3">\n</span><span class="s1">import isObject from './utils/isObject.js';</span><span class="s3">\n</span><span class="s1">import getLocator from './utils/getLocator.js';</span><span class="s3">\n</span><span class="s1">import Mappings from './utils/Mappings.js';</span><span class="s3">\n\n</span><span class="s1">const hasOwnProp = Object.prototype.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">export default class Bundle {</span><span class="s3">\n\t</span><span class="s1">constructor(options = {}) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = options.intro || '';</span><span class="s3">\n\t\t</span><span class="s1">this.separator = options.separator !== undefined ? options.separator : '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\t\t</span><span class="s1">this.sources = [];</span><span class="s3">\n\t\t</span><span class="s1">this.uniqueSources = [];</span><span class="s3">\n\t\t</span><span class="s1">this.uniqueSourceIndexByFilename = {};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">addSource(source) {</span><span class="s3">\n\t\t</span><span class="s1">if (source instanceof MagicString) {</span><span class="s3">\n\t\t\t</span><span class="s1">return this.addSource({</span><span class="s3">\n\t\t\t\t</span><span class="s1">content: source,</span><span class="s3">\n\t\t\t\t</span><span class="s1">filename: source.filename,</span><span class="s3">\n\t\t\t\t</span><span class="s1">separator: this.separator,</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (!isObject(source) || !source.content) {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new Error(</span><span class="s3">\n\t\t\t\t</span><span class="s1">'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',</span><span class="s3">\n\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!hasOwnProp.call(source, option)) source[option] = source.content[option];</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">if (source.separator === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">// TODO there's a bunch of this sort of thing, needs cleaning up</span><span class="s3">\n\t\t\t</span><span class="s1">source.separator = this.separator;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (source.filename) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.uniqueSources.push({ filename: source.filename, content: source.content.original });</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (source.content.original !== uniqueSource.content) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">throw new Error(`Illegal source: same filename (${source.filename}), different contents`);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.push(source);</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">append(str, options) {</span><span class="s3">\n\t\t</span><span class="s1">this.addSource({</span><span class="s3">\n\t\t\t</span><span class="s1">content: new MagicString(str),</span><span class="s3">\n\t\t\t</span><span class="s1">separator: (options &amp;&amp; options.separator) || '',</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">clone() {</span><span class="s3">\n\t\t</span><span class="s1">const bundle = new Bundle({</span><span class="s3">\n\t\t\t</span><span class="s1">intro: this.intro,</span><span class="s3">\n\t\t\t</span><span class="s1">separator: this.separator,</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.forEach((source) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">bundle.addSource({</span><span class="s3">\n\t\t\t\t</span><span class="s1">filename: source.filename,</span><span class="s3">\n\t\t\t\t</span><span class="s1">content: source.content.clone(),</span><span class="s3">\n\t\t\t\t</span><span class="s1">separator: source.separator,</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">return bundle;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">generateDecodedMap(options = {}) {</span><span class="s3">\n\t\t</span><span class="s1">const names = [];</span><span class="s3">\n\t\t</span><span class="s1">let x_google_ignoreList = undefined;</span><span class="s3">\n\t\t</span><span class="s1">this.sources.forEach((source) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">Object.keys(source.content.storedNames).forEach((name) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (!~names.indexOf(name)) names.push(name);</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">const mappings = new Mappings(options.hires);</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.intro) {</span><span class="s3">\n\t\t\t</span><span class="s1">mappings.advance(this.intro);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.forEach((source, i) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">if (i &gt; 0) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.advance(this.separator);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;</span><span class="s3">\n\t\t\t</span><span class="s1">const magicString = source.content;</span><span class="s3">\n\t\t\t</span><span class="s1">const locate = getLocator(magicString.original);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (magicString.intro) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.advance(magicString.intro);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">magicString.firstChunk.eachNext((chunk) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const loc = locate(chunk.start);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if (chunk.intro.length) mappings.advance(chunk.intro);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if (source.filename) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (chunk.edited) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">mappings.addEdit(</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">sourceIndex,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">chunk.content,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">loc,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">chunk.storeName ? names.indexOf(chunk.original) : -1,</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">mappings.addUneditedChunk(</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">sourceIndex,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">chunk,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">magicString.original,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">loc,</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">magicString.sourcemapLocations,</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">mappings.advance(chunk.content);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">if (chunk.outro.length) mappings.advance(chunk.outro);</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (magicString.outro) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">mappings.advance(magicString.outro);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (source.ignoreList &amp;&amp; sourceIndex !== -1) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (x_google_ignoreList === undefined) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">x_google_ignoreList = [];</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">x_google_ignoreList.push(sourceIndex);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">return {</span><span class="s3">\n\t\t\t</span><span class="s1">file: options.file ? options.file.split(/[/</span><span class="s3">\\\\</span><span class="s1">]/).pop() : undefined,</span><span class="s3">\n\t\t\t</span><span class="s1">sources: this.uniqueSources.map((source) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return options.file ? getRelativePath(options.file, source.filename) : source.filename;</span><span class="s3">\n\t\t\t</span><span class="s1">}),</span><span class="s3">\n\t\t\t</span><span class="s1">sourcesContent: this.uniqueSources.map((source) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return options.includeContent ? source.content : null;</span><span class="s3">\n\t\t\t</span><span class="s1">}),</span><span class="s3">\n\t\t\t</span><span class="s1">names,</span><span class="s3">\n\t\t\t</span><span class="s1">mappings: mappings.raw,</span><span class="s3">\n\t\t\t</span><span class="s1">x_google_ignoreList,</span><span class="s3">\n\t\t</span><span class="s1">};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">generateMap(options) {</span><span class="s3">\n\t\t</span><span class="s1">return new SourceMap(this.generateDecodedMap(options));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">getIndentString() {</span><span class="s3">\n\t\t</span><span class="s1">const indentStringCounts = {};</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.forEach((source) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">const indentStr = source.content._getRawIndentString();</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (indentStr === null) return;</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;</span><span class="s3">\n\t\t\t</span><span class="s1">indentStringCounts[indentStr] += 1;</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">return (</span><span class="s3">\n\t\t\t</span><span class="s1">Object.keys(indentStringCounts).sort((a, b) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return indentStringCounts[a] - indentStringCounts[b];</span><span class="s3">\n\t\t\t</span><span class="s1">})[0] || '</span><span class="s3">\\</span><span class="s1">t'</span><span class="s3">\n\t\t</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">indent(indentStr) {</span><span class="s3">\n\t\t</span><span class="s1">if (!arguments.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">indentStr = this.getIndentString();</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (indentStr === '') return this; // noop</span><span class="s3">\n\n\t\t</span><span class="s1">let trailingNewline = !this.intro || this.intro.slice(-1) === '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\n\t\t</span><span class="s1">this.sources.forEach((source, i) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">const separator = source.separator !== undefined ? source.separator : this.separator;</span><span class="s3">\n\t\t\t</span><span class="s1">const indentStart = trailingNewline || (i &gt; 0 &amp;&amp; /</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n$/.test(separator));</span><span class="s3">\n\n\t\t\t</span><span class="s1">source.content.indent(indentStr, {</span><span class="s3">\n\t\t\t\t</span><span class="s1">exclude: source.indentExclusionRanges,</span><span class="s3">\n\t\t\t\t</span><span class="s1">indentStart, //: trailingNewline || /</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n$/.test( separator )  //true///</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n/.test( separator )</span><span class="s3">\n\t\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t\t</span><span class="s1">trailingNewline = source.content.lastChar() === '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n\t\t</span><span class="s1">});</span><span class="s3">\n\n\t\t</span><span class="s1">if (this.intro) {</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro =</span><span class="s3">\n\t\t\t\t</span><span class="s1">indentStr +</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.intro.replace(/^[^</span><span class="s3">\\</span><span class="s1">n]/gm, (match, index) =&gt; {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">return index &gt; 0 ? indentStr + match : match;</span><span class="s3">\n\t\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">prepend(str) {</span><span class="s3">\n\t\t</span><span class="s1">this.intro = str + this.intro;</span><span class="s3">\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">toString() {</span><span class="s3">\n\t\t</span><span class="s1">const body = this.sources</span><span class="s3">\n\t\t\t</span><span class="s1">.map((source, i) =&gt; {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const separator = source.separator !== undefined ? source.separator : this.separator;</span><span class="s3">\n\t\t\t\t</span><span class="s1">const str = (i &gt; 0 ? separator : '') + source.content.toString();</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">return str;</span><span class="s3">\n\t\t\t</span><span class="s1">})</span><span class="s3">\n\t\t\t</span><span class="s1">.join('');</span><span class="s3">\n\n\t\t</span><span class="s1">return this.intro + body;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">isEmpty() {</span><span class="s3">\n\t\t</span><span class="s1">if (this.intro.length &amp;&amp; this.intro.trim()) return false;</span><span class="s3">\n\t\t</span><span class="s1">if (this.sources.some((source) =&gt; !source.content.isEmpty())) return false;</span><span class="s3">\n\t\t</span><span class="s1">return true;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">length() {</span><span class="s3">\n\t\t</span><span class="s1">return this.sources.reduce(</span><span class="s3">\n\t\t\t</span><span class="s1">(length, source) =&gt; length + source.content.length(),</span><span class="s3">\n\t\t\t</span><span class="s1">this.intro.length,</span><span class="s3">\n\t\t</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimLines() {</span><span class="s3">\n\t\t</span><span class="s1">return this.trim('[</span><span class="s3">\\\\</span><span class="s1">r</span><span class="s3">\\\\</span><span class="s1">n]');</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trim(charType) {</span><span class="s3">\n\t\t</span><span class="s1">return this.trimStart(charType).trimEnd(charType);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimStart(charType) {</span><span class="s3">\n\t\t</span><span class="s1">const rx = new RegExp('^' + (charType || '</span><span class="s3">\\\\</span><span class="s1">s') + '+');</span><span class="s3">\n\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\n\t\t</span><span class="s1">if (!this.intro) {</span><span class="s3">\n\t\t\t</span><span class="s1">let source;</span><span class="s3">\n\t\t\t</span><span class="s1">let i = 0;</span><span class="s3">\n\n\t\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t\t</span><span class="s1">source = this.sources[i++];</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (!source) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} while (!source.content.trimStartAborted(charType));</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">trimEnd(charType) {</span><span class="s3">\n\t\t</span><span class="s1">const rx = new RegExp((charType || '</span><span class="s3">\\\\</span><span class="s1">s') + '+$');</span><span class="s3">\n\n\t\t</span><span class="s1">let source;</span><span class="s3">\n\t\t</span><span class="s1">let i = this.sources.length - 1;</span><span class="s3">\n\n\t\t</span><span class="s1">do {</span><span class="s3">\n\t\t\t</span><span class="s1">source = this.sources[i--];</span><span class="s3">\n\t\t\t</span><span class="s1">if (!source) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">this.intro = this.intro.replace(rx, '');</span><span class="s3">\n\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} while (!source.content.trimEndAborted(charType));</span><span class="s3">\n\n\t\t</span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>