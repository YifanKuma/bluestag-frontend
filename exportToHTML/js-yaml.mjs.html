<html>
<head>
<title>js-yaml.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
js-yaml.mjs</font>
</center></td></tr></table>
<pre>
<span class="s1">/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */</span>
<span class="s2">function </span><span class="s0">isNothing(subject) {</span>
  <span class="s2">return </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">subject === </span><span class="s3">'undefined'</span><span class="s0">) || (subject === </span><span class="s2">null</span><span class="s0">);</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">isObject(subject) {</span>
  <span class="s2">return </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">subject === </span><span class="s3">'object'</span><span class="s0">) &amp;&amp; (subject !== </span><span class="s2">null</span><span class="s0">);</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">toArray(sequence) {</span>
  <span class="s2">if </span><span class="s0">(Array.isArray(sequence)) </span><span class="s2">return </span><span class="s0">sequence;</span>
  <span class="s2">else if </span><span class="s0">(isNothing(sequence)) </span><span class="s2">return </span><span class="s0">[];</span>

  <span class="s2">return </span><span class="s0">[ sequence ];</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">extend(target, source) {</span>
  <span class="s2">var </span><span class="s0">index, length, key, sourceKeys;</span>

  <span class="s2">if </span><span class="s0">(source) {</span>
    <span class="s0">sourceKeys = Object.keys(source);</span>

    <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = sourceKeys.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">key = sourceKeys[index];</span>
      <span class="s0">target[key] = source[key];</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">target;</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">repeat(string, count) {</span>
  <span class="s2">var </span><span class="s0">result = </span><span class="s3">''</span><span class="s0">, cycle;</span>

  <span class="s2">for </span><span class="s0">(cycle = </span><span class="s4">0</span><span class="s0">; cycle &lt; count; cycle += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">result += string;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">isNegativeZero(number) {</span>
  <span class="s2">return </span><span class="s0">(number === </span><span class="s4">0</span><span class="s0">) &amp;&amp; (Number.NEGATIVE_INFINITY === </span><span class="s4">1 </span><span class="s0">/ number);</span>
<span class="s0">}</span>


<span class="s2">var </span><span class="s0">isNothing_1      = isNothing;</span>
<span class="s2">var </span><span class="s0">isObject_1       = isObject;</span>
<span class="s2">var </span><span class="s0">toArray_1        = toArray;</span>
<span class="s2">var </span><span class="s0">repeat_1         = repeat;</span>
<span class="s2">var </span><span class="s0">isNegativeZero_1 = isNegativeZero;</span>
<span class="s2">var </span><span class="s0">extend_1         = extend;</span>

<span class="s2">var </span><span class="s0">common = {</span>
	<span class="s0">isNothing: isNothing_1,</span>
	<span class="s0">isObject: isObject_1,</span>
	<span class="s0">toArray: toArray_1,</span>
	<span class="s0">repeat: repeat_1,</span>
	<span class="s0">isNegativeZero: isNegativeZero_1,</span>
	<span class="s0">extend: extend_1</span>
<span class="s0">};</span>

<span class="s1">// YAML error class. http://stackoverflow.com/questions/8458984</span>


<span class="s2">function </span><span class="s0">formatError(exception, compact) {</span>
  <span class="s2">var </span><span class="s0">where = </span><span class="s3">''</span><span class="s0">, message = exception.reason || </span><span class="s3">'(unknown reason)'</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(!exception.mark) </span><span class="s2">return </span><span class="s0">message;</span>

  <span class="s2">if </span><span class="s0">(exception.mark.name) {</span>
    <span class="s0">where += </span><span class="s3">'in &quot;' </span><span class="s0">+ exception.mark.name + </span><span class="s3">'&quot; '</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">where += </span><span class="s3">'(' </span><span class="s0">+ (exception.mark.line + </span><span class="s4">1</span><span class="s0">) + </span><span class="s3">':' </span><span class="s0">+ (exception.mark.column + </span><span class="s4">1</span><span class="s0">) + </span><span class="s3">')'</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(!compact &amp;&amp; exception.mark.snippet) {</span>
    <span class="s0">where += </span><span class="s3">'</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s0">+ exception.mark.snippet;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">message + </span><span class="s3">' ' </span><span class="s0">+ where;</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">YAMLException$1(reason, mark) {</span>
  <span class="s1">// Super constructor</span>
  <span class="s0">Error.call(</span><span class="s2">this</span><span class="s0">);</span>

  <span class="s2">this</span><span class="s0">.name = </span><span class="s3">'YAMLException'</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.reason = reason;</span>
  <span class="s2">this</span><span class="s0">.mark = mark;</span>
  <span class="s2">this</span><span class="s0">.message = formatError(</span><span class="s2">this</span><span class="s0">, </span><span class="s2">false</span><span class="s0">);</span>

  <span class="s1">// Include stack trace in error object</span>
  <span class="s2">if </span><span class="s0">(Error.captureStackTrace) {</span>
    <span class="s1">// Chrome and NodeJS</span>
    <span class="s0">Error.captureStackTrace(</span><span class="s2">this</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.constructor);</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s1">// FF, IE 10+ and Safari 6+. Fallback for others</span>
    <span class="s2">this</span><span class="s0">.stack = (</span><span class="s2">new </span><span class="s0">Error()).stack || </span><span class="s3">''</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>


<span class="s1">// Inherit from Error</span>
<span class="s0">YAMLException$1.prototype = Object.create(Error.prototype);</span>
<span class="s0">YAMLException$1.prototype.constructor = YAMLException$1;</span>


<span class="s0">YAMLException$1.prototype.toString = </span><span class="s2">function </span><span class="s0">toString(compact) {</span>
  <span class="s2">return this</span><span class="s0">.name + </span><span class="s3">': ' </span><span class="s0">+ formatError(</span><span class="s2">this</span><span class="s0">, compact);</span>
<span class="s0">};</span>


<span class="s2">var </span><span class="s0">exception = YAMLException$1;</span>

<span class="s1">// get snippet for a single line, respecting maxLength</span>
<span class="s2">function </span><span class="s0">getLine(buffer, lineStart, lineEnd, position, maxLineLength) {</span>
  <span class="s2">var </span><span class="s0">head = </span><span class="s3">''</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">tail = </span><span class="s3">''</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">maxHalfLength = Math.floor(maxLineLength / </span><span class="s4">2</span><span class="s0">) - </span><span class="s4">1</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(position - lineStart &gt; maxHalfLength) {</span>
    <span class="s0">head = </span><span class="s3">' ... '</span><span class="s0">;</span>
    <span class="s0">lineStart = position - maxHalfLength + head.length;</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(lineEnd - position &gt; maxHalfLength) {</span>
    <span class="s0">tail = </span><span class="s3">' ...'</span><span class="s0">;</span>
    <span class="s0">lineEnd = position + maxHalfLength - tail.length;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">{</span>
    <span class="s0">str: head + buffer.slice(lineStart, lineEnd).replace(</span><span class="s6">/\t/g</span><span class="s0">, </span><span class="s3">'â†’'</span><span class="s0">) + tail,</span>
    <span class="s0">pos: position - lineStart + head.length </span><span class="s1">// relative position</span>
  <span class="s0">};</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">padStart(string, max) {</span>
  <span class="s2">return </span><span class="s0">common.repeat(</span><span class="s3">' '</span><span class="s0">, max - string.length) + string;</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">makeSnippet(mark, options) {</span>
  <span class="s0">options = Object.create(options || </span><span class="s2">null</span><span class="s0">);</span>

  <span class="s2">if </span><span class="s0">(!mark.buffer) </span><span class="s2">return null</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(!options.maxLength) options.maxLength = </span><span class="s4">79</span><span class="s0">;</span>
  <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">options.indent      !== </span><span class="s3">'number'</span><span class="s0">) options.indent      = </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">options.linesBefore !== </span><span class="s3">'number'</span><span class="s0">) options.linesBefore = </span><span class="s4">3</span><span class="s0">;</span>
  <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">options.linesAfter  !== </span><span class="s3">'number'</span><span class="s0">) options.linesAfter  = </span><span class="s4">2</span><span class="s0">;</span>

  <span class="s2">var </span><span class="s0">re = </span><span class="s6">/\r?\n|\r|\0/g</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">lineStarts = [ </span><span class="s4">0 </span><span class="s0">];</span>
  <span class="s2">var </span><span class="s0">lineEnds = [];</span>
  <span class="s2">var </span><span class="s0">match;</span>
  <span class="s2">var </span><span class="s0">foundLineNo = -</span><span class="s4">1</span><span class="s0">;</span>

  <span class="s2">while </span><span class="s0">((match = re.exec(mark.buffer))) {</span>
    <span class="s0">lineEnds.push(match.index);</span>
    <span class="s0">lineStarts.push(match.index + match[</span><span class="s4">0</span><span class="s0">].length);</span>

    <span class="s2">if </span><span class="s0">(mark.position &lt;= match.index &amp;&amp; foundLineNo &lt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s0">foundLineNo = lineStarts.length - </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(foundLineNo &lt; </span><span class="s4">0</span><span class="s0">) foundLineNo = lineStarts.length - </span><span class="s4">1</span><span class="s0">;</span>

  <span class="s2">var </span><span class="s0">result = </span><span class="s3">''</span><span class="s0">, i, line;</span>
  <span class="s2">var </span><span class="s0">lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;</span>
  <span class="s2">var </span><span class="s0">maxLineLength = options.maxLength - (options.indent + lineNoLength + </span><span class="s4">3</span><span class="s0">);</span>

  <span class="s2">for </span><span class="s0">(i = </span><span class="s4">1</span><span class="s0">; i &lt;= options.linesBefore; i++) {</span>
    <span class="s2">if </span><span class="s0">(foundLineNo - i &lt; </span><span class="s4">0</span><span class="s0">) </span><span class="s2">break</span><span class="s0">;</span>
    <span class="s0">line = getLine(</span>
      <span class="s0">mark.buffer,</span>
      <span class="s0">lineStarts[foundLineNo - i],</span>
      <span class="s0">lineEnds[foundLineNo - i],</span>
      <span class="s0">mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),</span>
      <span class="s0">maxLineLength</span>
    <span class="s0">);</span>
    <span class="s0">result = common.repeat(</span><span class="s3">' '</span><span class="s0">, options.indent) + padStart((mark.line - i + </span><span class="s4">1</span><span class="s0">).toString(), lineNoLength) +</span>
      <span class="s3">' | ' </span><span class="s0">+ line.str + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s0">+ result;</span>
  <span class="s0">}</span>

  <span class="s0">line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);</span>
  <span class="s0">result += common.repeat(</span><span class="s3">' '</span><span class="s0">, options.indent) + padStart((mark.line + </span><span class="s4">1</span><span class="s0">).toString(), lineNoLength) +</span>
    <span class="s3">' | ' </span><span class="s0">+ line.str + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">;</span>
  <span class="s0">result += common.repeat(</span><span class="s3">'-'</span><span class="s0">, options.indent + lineNoLength + </span><span class="s4">3 </span><span class="s0">+ line.pos) + </span><span class="s3">'^' </span><span class="s0">+ </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">;</span>

  <span class="s2">for </span><span class="s0">(i = </span><span class="s4">1</span><span class="s0">; i &lt;= options.linesAfter; i++) {</span>
    <span class="s2">if </span><span class="s0">(foundLineNo + i &gt;= lineEnds.length) </span><span class="s2">break</span><span class="s0">;</span>
    <span class="s0">line = getLine(</span>
      <span class="s0">mark.buffer,</span>
      <span class="s0">lineStarts[foundLineNo + i],</span>
      <span class="s0">lineEnds[foundLineNo + i],</span>
      <span class="s0">mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),</span>
      <span class="s0">maxLineLength</span>
    <span class="s0">);</span>
    <span class="s0">result += common.repeat(</span><span class="s3">' '</span><span class="s0">, options.indent) + padStart((mark.line + i + </span><span class="s4">1</span><span class="s0">).toString(), lineNoLength) +</span>
      <span class="s3">' | ' </span><span class="s0">+ line.str + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result.replace(</span><span class="s6">/\n$/</span><span class="s0">, </span><span class="s3">''</span><span class="s0">);</span>
<span class="s0">}</span>


<span class="s2">var </span><span class="s0">snippet = makeSnippet;</span>

<span class="s2">var </span><span class="s0">TYPE_CONSTRUCTOR_OPTIONS = [</span>
  <span class="s3">'kind'</span><span class="s0">,</span>
  <span class="s3">'multi'</span><span class="s0">,</span>
  <span class="s3">'resolve'</span><span class="s0">,</span>
  <span class="s3">'construct'</span><span class="s0">,</span>
  <span class="s3">'instanceOf'</span><span class="s0">,</span>
  <span class="s3">'predicate'</span><span class="s0">,</span>
  <span class="s3">'represent'</span><span class="s0">,</span>
  <span class="s3">'representName'</span><span class="s0">,</span>
  <span class="s3">'defaultStyle'</span><span class="s0">,</span>
  <span class="s3">'styleAliases'</span>
<span class="s0">];</span>

<span class="s2">var </span><span class="s0">YAML_NODE_KINDS = [</span>
  <span class="s3">'scalar'</span><span class="s0">,</span>
  <span class="s3">'sequence'</span><span class="s0">,</span>
  <span class="s3">'mapping'</span>
<span class="s0">];</span>

<span class="s2">function </span><span class="s0">compileStyleAliases(map) {</span>
  <span class="s2">var </span><span class="s0">result = {};</span>

  <span class="s2">if </span><span class="s0">(map !== </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s0">Object.keys(map).forEach(</span><span class="s2">function </span><span class="s0">(style) {</span>
      <span class="s0">map[style].forEach(</span><span class="s2">function </span><span class="s0">(alias) {</span>
        <span class="s0">result[String(alias)] = style;</span>
      <span class="s0">});</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">Type$1(tag, options) {</span>
  <span class="s0">options = options || {};</span>

  <span class="s0">Object.keys(options).forEach(</span><span class="s2">function </span><span class="s0">(name) {</span>
    <span class="s2">if </span><span class="s0">(TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -</span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'Unknown option &quot;' </span><span class="s0">+ name + </span><span class="s3">'&quot; is met in definition of &quot;' </span><span class="s0">+ tag + </span><span class="s3">'&quot; YAML type.'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">});</span>

  <span class="s1">// TODO: Add tag format check.</span>
  <span class="s2">this</span><span class="s0">.options       = options; </span><span class="s1">// keep original options in case user wants to extend this type later</span>
  <span class="s2">this</span><span class="s0">.tag           = tag;</span>
  <span class="s2">this</span><span class="s0">.kind          = options[</span><span class="s3">'kind'</span><span class="s0">]          || </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.resolve       = options[</span><span class="s3">'resolve'</span><span class="s0">]       || </span><span class="s2">function </span><span class="s0">() { </span><span class="s2">return true</span><span class="s0">; };</span>
  <span class="s2">this</span><span class="s0">.construct     = options[</span><span class="s3">'construct'</span><span class="s0">]     || </span><span class="s2">function </span><span class="s0">(data) { </span><span class="s2">return </span><span class="s0">data; };</span>
  <span class="s2">this</span><span class="s0">.instanceOf    = options[</span><span class="s3">'instanceOf'</span><span class="s0">]    || </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.predicate     = options[</span><span class="s3">'predicate'</span><span class="s0">]     || </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.represent     = options[</span><span class="s3">'represent'</span><span class="s0">]     || </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.representName = options[</span><span class="s3">'representName'</span><span class="s0">] || </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.defaultStyle  = options[</span><span class="s3">'defaultStyle'</span><span class="s0">]  || </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.multi         = options[</span><span class="s3">'multi'</span><span class="s0">]         || </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.styleAliases  = compileStyleAliases(options[</span><span class="s3">'styleAliases'</span><span class="s0">] || </span><span class="s2">null</span><span class="s0">);</span>

  <span class="s2">if </span><span class="s0">(YAML_NODE_KINDS.indexOf(</span><span class="s2">this</span><span class="s0">.kind) === -</span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'Unknown kind &quot;' </span><span class="s0">+ </span><span class="s2">this</span><span class="s0">.kind + </span><span class="s3">'&quot; is specified for &quot;' </span><span class="s0">+ tag + </span><span class="s3">'&quot; YAML type.'</span><span class="s0">);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">type = Type$1;</span>

<span class="s1">/*eslint-disable max-len*/</span>





<span class="s2">function </span><span class="s0">compileList(schema, name) {</span>
  <span class="s2">var </span><span class="s0">result = [];</span>

  <span class="s0">schema[name].forEach(</span><span class="s2">function </span><span class="s0">(currentType) {</span>
    <span class="s2">var </span><span class="s0">newIndex = result.length;</span>

    <span class="s0">result.forEach(</span><span class="s2">function </span><span class="s0">(previousType, previousIndex) {</span>
      <span class="s2">if </span><span class="s0">(previousType.tag === currentType.tag &amp;&amp;</span>
          <span class="s0">previousType.kind === currentType.kind &amp;&amp;</span>
          <span class="s0">previousType.multi === currentType.multi) {</span>

        <span class="s0">newIndex = previousIndex;</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">result[newIndex] = currentType;</span>
  <span class="s0">});</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">compileMap(</span><span class="s1">/* lists... */</span><span class="s0">) {</span>
  <span class="s2">var </span><span class="s0">result = {</span>
        <span class="s0">scalar: {},</span>
        <span class="s0">sequence: {},</span>
        <span class="s0">mapping: {},</span>
        <span class="s0">fallback: {},</span>
        <span class="s0">multi: {</span>
          <span class="s0">scalar: [],</span>
          <span class="s0">sequence: [],</span>
          <span class="s0">mapping: [],</span>
          <span class="s0">fallback: []</span>
        <span class="s0">}</span>
      <span class="s0">}, index, length;</span>

  <span class="s2">function </span><span class="s0">collectType(type) {</span>
    <span class="s2">if </span><span class="s0">(type.multi) {</span>
      <span class="s0">result.multi[type.kind].push(type);</span>
      <span class="s0">result.multi[</span><span class="s3">'fallback'</span><span class="s0">].push(type);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">result[type.kind][type.tag] = result[</span><span class="s3">'fallback'</span><span class="s0">][type.tag] = type;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = arguments.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">arguments[index].forEach(collectType);</span>
  <span class="s0">}</span>
  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">Schema$1(definition) {</span>
  <span class="s2">return this</span><span class="s0">.extend(definition);</span>
<span class="s0">}</span>


<span class="s0">Schema$1.prototype.extend = </span><span class="s2">function </span><span class="s0">extend(definition) {</span>
  <span class="s2">var </span><span class="s0">implicit = [];</span>
  <span class="s2">var </span><span class="s0">explicit = [];</span>

  <span class="s2">if </span><span class="s0">(definition </span><span class="s2">instanceof </span><span class="s0">type) {</span>
    <span class="s1">// Schema.extend(type)</span>
    <span class="s0">explicit.push(definition);</span>

  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(Array.isArray(definition)) {</span>
    <span class="s1">// Schema.extend([ type1, type2, ... ])</span>
    <span class="s0">explicit = explicit.concat(definition);</span>

  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(definition &amp;&amp; (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {</span>
    <span class="s1">// Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })</span>
    <span class="s2">if </span><span class="s0">(definition.implicit) implicit = implicit.concat(definition.implicit);</span>
    <span class="s2">if </span><span class="s0">(definition.explicit) explicit = explicit.concat(definition.explicit);</span>

  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'Schema.extend argument should be a Type, [ Type ], ' </span><span class="s0">+</span>
      <span class="s3">'or a schema definition ({ implicit: [...], explicit: [...] })'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">implicit.forEach(</span><span class="s2">function </span><span class="s0">(type$1) {</span>
    <span class="s2">if </span><span class="s0">(!(type$1 </span><span class="s2">instanceof </span><span class="s0">type)) {</span>
      <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'Specified list of YAML types (or a single Type object) contains a non-Type object.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(type$1.loadKind &amp;&amp; type$1.loadKind !== </span><span class="s3">'scalar'</span><span class="s0">) {</span>
      <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(type$1.multi) {</span>
      <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">});</span>

  <span class="s0">explicit.forEach(</span><span class="s2">function </span><span class="s0">(type$1) {</span>
    <span class="s2">if </span><span class="s0">(!(type$1 </span><span class="s2">instanceof </span><span class="s0">type)) {</span>
      <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'Specified list of YAML types (or a single Type object) contains a non-Type object.'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">});</span>

  <span class="s2">var </span><span class="s0">result = Object.create(Schema$1.prototype);</span>

  <span class="s0">result.implicit = (</span><span class="s2">this</span><span class="s0">.implicit || []).concat(implicit);</span>
  <span class="s0">result.explicit = (</span><span class="s2">this</span><span class="s0">.explicit || []).concat(explicit);</span>

  <span class="s0">result.compiledImplicit = compileList(result, </span><span class="s3">'implicit'</span><span class="s0">);</span>
  <span class="s0">result.compiledExplicit = compileList(result, </span><span class="s3">'explicit'</span><span class="s0">);</span>
  <span class="s0">result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">};</span>


<span class="s2">var </span><span class="s0">schema = Schema$1;</span>

<span class="s2">var </span><span class="s0">str = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:str'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'scalar'</span><span class="s0">,</span>
  <span class="s0">construct: </span><span class="s2">function </span><span class="s0">(data) { </span><span class="s2">return </span><span class="s0">data !== </span><span class="s2">null </span><span class="s0">? data : </span><span class="s3">''</span><span class="s0">; }</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">seq = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:seq'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'sequence'</span><span class="s0">,</span>
  <span class="s0">construct: </span><span class="s2">function </span><span class="s0">(data) { </span><span class="s2">return </span><span class="s0">data !== </span><span class="s2">null </span><span class="s0">? data : []; }</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">map = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:map'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'mapping'</span><span class="s0">,</span>
  <span class="s0">construct: </span><span class="s2">function </span><span class="s0">(data) { </span><span class="s2">return </span><span class="s0">data !== </span><span class="s2">null </span><span class="s0">? data : {}; }</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">failsafe = </span><span class="s2">new </span><span class="s0">schema({</span>
  <span class="s0">explicit: [</span>
    <span class="s0">str,</span>
    <span class="s0">seq,</span>
    <span class="s0">map</span>
  <span class="s0">]</span>
<span class="s0">});</span>

<span class="s2">function </span><span class="s0">resolveYamlNull(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return true</span><span class="s0">;</span>

  <span class="s2">var </span><span class="s0">max = data.length;</span>

  <span class="s2">return </span><span class="s0">(max === </span><span class="s4">1 </span><span class="s0">&amp;&amp; data === </span><span class="s3">'~'</span><span class="s0">) ||</span>
         <span class="s0">(max === </span><span class="s4">4 </span><span class="s0">&amp;&amp; (data === </span><span class="s3">'null' </span><span class="s0">|| data === </span><span class="s3">'Null' </span><span class="s0">|| data === </span><span class="s3">'NULL'</span><span class="s0">));</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">constructYamlNull() {</span>
  <span class="s2">return null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">isNull(object) {</span>
  <span class="s2">return </span><span class="s0">object === </span><span class="s2">null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">_null = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:null'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'scalar'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlNull,</span>
  <span class="s0">construct: constructYamlNull,</span>
  <span class="s0">predicate: isNull,</span>
  <span class="s0">represent: {</span>
    <span class="s0">canonical: </span><span class="s2">function </span><span class="s0">() { </span><span class="s2">return </span><span class="s3">'~'</span><span class="s0">;    },</span>
    <span class="s0">lowercase: </span><span class="s2">function </span><span class="s0">() { </span><span class="s2">return </span><span class="s3">'null'</span><span class="s0">; },</span>
    <span class="s0">uppercase: </span><span class="s2">function </span><span class="s0">() { </span><span class="s2">return </span><span class="s3">'NULL'</span><span class="s0">; },</span>
    <span class="s0">camelcase: </span><span class="s2">function </span><span class="s0">() { </span><span class="s2">return </span><span class="s3">'Null'</span><span class="s0">; },</span>
    <span class="s0">empty:     </span><span class="s2">function </span><span class="s0">() { </span><span class="s2">return </span><span class="s3">''</span><span class="s0">;     }</span>
  <span class="s0">},</span>
  <span class="s0">defaultStyle: </span><span class="s3">'lowercase'</span>
<span class="s0">});</span>

<span class="s2">function </span><span class="s0">resolveYamlBoolean(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">var </span><span class="s0">max = data.length;</span>

  <span class="s2">return </span><span class="s0">(max === </span><span class="s4">4 </span><span class="s0">&amp;&amp; (data === </span><span class="s3">'true' </span><span class="s0">|| data === </span><span class="s3">'True' </span><span class="s0">|| data === </span><span class="s3">'TRUE'</span><span class="s0">)) ||</span>
         <span class="s0">(max === </span><span class="s4">5 </span><span class="s0">&amp;&amp; (data === </span><span class="s3">'false' </span><span class="s0">|| data === </span><span class="s3">'False' </span><span class="s0">|| data === </span><span class="s3">'FALSE'</span><span class="s0">));</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">constructYamlBoolean(data) {</span>
  <span class="s2">return </span><span class="s0">data === </span><span class="s3">'true' </span><span class="s0">||</span>
         <span class="s0">data === </span><span class="s3">'True' </span><span class="s0">||</span>
         <span class="s0">data === </span><span class="s3">'TRUE'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">isBoolean(object) {</span>
  <span class="s2">return </span><span class="s0">Object.prototype.toString.call(object) === </span><span class="s3">'[object Boolean]'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">bool = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:bool'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'scalar'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlBoolean,</span>
  <span class="s0">construct: constructYamlBoolean,</span>
  <span class="s0">predicate: isBoolean,</span>
  <span class="s0">represent: {</span>
    <span class="s0">lowercase: </span><span class="s2">function </span><span class="s0">(object) { </span><span class="s2">return </span><span class="s0">object ? </span><span class="s3">'true' </span><span class="s0">: </span><span class="s3">'false'</span><span class="s0">; },</span>
    <span class="s0">uppercase: </span><span class="s2">function </span><span class="s0">(object) { </span><span class="s2">return </span><span class="s0">object ? </span><span class="s3">'TRUE' </span><span class="s0">: </span><span class="s3">'FALSE'</span><span class="s0">; },</span>
    <span class="s0">camelcase: </span><span class="s2">function </span><span class="s0">(object) { </span><span class="s2">return </span><span class="s0">object ? </span><span class="s3">'True' </span><span class="s0">: </span><span class="s3">'False'</span><span class="s0">; }</span>
  <span class="s0">},</span>
  <span class="s0">defaultStyle: </span><span class="s3">'lowercase'</span>
<span class="s0">});</span>

<span class="s2">function </span><span class="s0">isHexCode(c) {</span>
  <span class="s2">return </span><span class="s0">((</span><span class="s4">0x30</span><span class="s1">/* 0 */ </span><span class="s0">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0x39</span><span class="s1">/* 9 */</span><span class="s0">)) ||</span>
         <span class="s0">((</span><span class="s4">0x41</span><span class="s1">/* A */ </span><span class="s0">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0x46</span><span class="s1">/* F */</span><span class="s0">)) ||</span>
         <span class="s0">((</span><span class="s4">0x61</span><span class="s1">/* a */ </span><span class="s0">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0x66</span><span class="s1">/* f */</span><span class="s0">));</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">isOctCode(c) {</span>
  <span class="s2">return </span><span class="s0">((</span><span class="s4">0x30</span><span class="s1">/* 0 */ </span><span class="s0">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0x37</span><span class="s1">/* 7 */</span><span class="s0">));</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">isDecCode(c) {</span>
  <span class="s2">return </span><span class="s0">((</span><span class="s4">0x30</span><span class="s1">/* 0 */ </span><span class="s0">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0x39</span><span class="s1">/* 9 */</span><span class="s0">));</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">resolveYamlInteger(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">var </span><span class="s0">max = data.length,</span>
      <span class="s0">index = </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">hasDigits = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">ch;</span>

  <span class="s2">if </span><span class="s0">(!max) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s0">ch = data[index];</span>

  <span class="s1">// sign</span>
  <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'-' </span><span class="s0">|| ch === </span><span class="s3">'+'</span><span class="s0">) {</span>
    <span class="s0">ch = data[++index];</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'0'</span><span class="s0">) {</span>
    <span class="s1">// 0</span>
    <span class="s2">if </span><span class="s0">(index + </span><span class="s4">1 </span><span class="s0">=== max) </span><span class="s2">return true</span><span class="s0">;</span>
    <span class="s0">ch = data[++index];</span>

    <span class="s1">// base 2, base 8, base 16</span>

    <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'b'</span><span class="s0">) {</span>
      <span class="s1">// base 2</span>
      <span class="s0">index++;</span>

      <span class="s2">for </span><span class="s0">(; index &lt; max; index++) {</span>
        <span class="s0">ch = data[index];</span>
        <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'_'</span><span class="s0">) </span><span class="s2">continue</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(ch !== </span><span class="s3">'0' </span><span class="s0">&amp;&amp; ch !== </span><span class="s3">'1'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>
        <span class="s0">hasDigits = </span><span class="s2">true</span><span class="s0">;</span>
      <span class="s0">}</span>
      <span class="s2">return </span><span class="s0">hasDigits &amp;&amp; ch !== </span><span class="s3">'_'</span><span class="s0">;</span>
    <span class="s0">}</span>


    <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'x'</span><span class="s0">) {</span>
      <span class="s1">// base 16</span>
      <span class="s0">index++;</span>

      <span class="s2">for </span><span class="s0">(; index &lt; max; index++) {</span>
        <span class="s0">ch = data[index];</span>
        <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'_'</span><span class="s0">) </span><span class="s2">continue</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(!isHexCode(data.charCodeAt(index))) </span><span class="s2">return false</span><span class="s0">;</span>
        <span class="s0">hasDigits = </span><span class="s2">true</span><span class="s0">;</span>
      <span class="s0">}</span>
      <span class="s2">return </span><span class="s0">hasDigits &amp;&amp; ch !== </span><span class="s3">'_'</span><span class="s0">;</span>
    <span class="s0">}</span>


    <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'o'</span><span class="s0">) {</span>
      <span class="s1">// base 8</span>
      <span class="s0">index++;</span>

      <span class="s2">for </span><span class="s0">(; index &lt; max; index++) {</span>
        <span class="s0">ch = data[index];</span>
        <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'_'</span><span class="s0">) </span><span class="s2">continue</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(!isOctCode(data.charCodeAt(index))) </span><span class="s2">return false</span><span class="s0">;</span>
        <span class="s0">hasDigits = </span><span class="s2">true</span><span class="s0">;</span>
      <span class="s0">}</span>
      <span class="s2">return </span><span class="s0">hasDigits &amp;&amp; ch !== </span><span class="s3">'_'</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">// base 10 (except 0)</span>

  <span class="s1">// value should not start with `_`;</span>
  <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'_'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">for </span><span class="s0">(; index &lt; max; index++) {</span>
    <span class="s0">ch = data[index];</span>
    <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'_'</span><span class="s0">) </span><span class="s2">continue</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(!isDecCode(data.charCodeAt(index))) {</span>
      <span class="s2">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">hasDigits = </span><span class="s2">true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">// Should have digits and should not end with `_`</span>
  <span class="s2">if </span><span class="s0">(!hasDigits || ch === </span><span class="s3">'_'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">constructYamlInteger(data) {</span>
  <span class="s2">var </span><span class="s0">value = data, sign = </span><span class="s4">1</span><span class="s0">, ch;</span>

  <span class="s2">if </span><span class="s0">(value.indexOf(</span><span class="s3">'_'</span><span class="s0">) !== -</span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">value = value.replace(</span><span class="s6">/_/g</span><span class="s0">, </span><span class="s3">''</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">ch = value[</span><span class="s4">0</span><span class="s0">];</span>

  <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'-' </span><span class="s0">|| ch === </span><span class="s3">'+'</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'-'</span><span class="s0">) sign = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">value = value.slice(</span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">ch = value[</span><span class="s4">0</span><span class="s0">];</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(value === </span><span class="s3">'0'</span><span class="s0">) </span><span class="s2">return </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(ch === </span><span class="s3">'0'</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(value[</span><span class="s4">1</span><span class="s0">] === </span><span class="s3">'b'</span><span class="s0">) </span><span class="s2">return </span><span class="s0">sign * parseInt(value.slice(</span><span class="s4">2</span><span class="s0">), </span><span class="s4">2</span><span class="s0">);</span>
    <span class="s2">if </span><span class="s0">(value[</span><span class="s4">1</span><span class="s0">] === </span><span class="s3">'x'</span><span class="s0">) </span><span class="s2">return </span><span class="s0">sign * parseInt(value.slice(</span><span class="s4">2</span><span class="s0">), </span><span class="s4">16</span><span class="s0">);</span>
    <span class="s2">if </span><span class="s0">(value[</span><span class="s4">1</span><span class="s0">] === </span><span class="s3">'o'</span><span class="s0">) </span><span class="s2">return </span><span class="s0">sign * parseInt(value.slice(</span><span class="s4">2</span><span class="s0">), </span><span class="s4">8</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">sign * parseInt(value, </span><span class="s4">10</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">isInteger(object) {</span>
  <span class="s2">return </span><span class="s0">(Object.prototype.toString.call(object)) === </span><span class="s3">'[object Number]' </span><span class="s0">&amp;&amp;</span>
         <span class="s0">(object % </span><span class="s4">1 </span><span class="s0">=== </span><span class="s4">0 </span><span class="s0">&amp;&amp; !common.isNegativeZero(object));</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">int = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:int'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'scalar'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlInteger,</span>
  <span class="s0">construct: constructYamlInteger,</span>
  <span class="s0">predicate: isInteger,</span>
  <span class="s0">represent: {</span>
    <span class="s0">binary:      </span><span class="s2">function </span><span class="s0">(obj) { </span><span class="s2">return </span><span class="s0">obj &gt;= </span><span class="s4">0 </span><span class="s0">? </span><span class="s3">'0b' </span><span class="s0">+ obj.toString(</span><span class="s4">2</span><span class="s0">) : </span><span class="s3">'-0b' </span><span class="s0">+ obj.toString(</span><span class="s4">2</span><span class="s0">).slice(</span><span class="s4">1</span><span class="s0">); },</span>
    <span class="s0">octal:       </span><span class="s2">function </span><span class="s0">(obj) { </span><span class="s2">return </span><span class="s0">obj &gt;= </span><span class="s4">0 </span><span class="s0">? </span><span class="s3">'0o'  </span><span class="s0">+ obj.toString(</span><span class="s4">8</span><span class="s0">) : </span><span class="s3">'-0o'  </span><span class="s0">+ obj.toString(</span><span class="s4">8</span><span class="s0">).slice(</span><span class="s4">1</span><span class="s0">); },</span>
    <span class="s0">decimal:     </span><span class="s2">function </span><span class="s0">(obj) { </span><span class="s2">return </span><span class="s0">obj.toString(</span><span class="s4">10</span><span class="s0">); },</span>
    <span class="s1">/* eslint-disable max-len */</span>
    <span class="s0">hexadecimal: </span><span class="s2">function </span><span class="s0">(obj) { </span><span class="s2">return </span><span class="s0">obj &gt;= </span><span class="s4">0 </span><span class="s0">? </span><span class="s3">'0x' </span><span class="s0">+ obj.toString(</span><span class="s4">16</span><span class="s0">).toUpperCase() :  </span><span class="s3">'-0x' </span><span class="s0">+ obj.toString(</span><span class="s4">16</span><span class="s0">).toUpperCase().slice(</span><span class="s4">1</span><span class="s0">); }</span>
  <span class="s0">},</span>
  <span class="s0">defaultStyle: </span><span class="s3">'decimal'</span><span class="s0">,</span>
  <span class="s0">styleAliases: {</span>
    <span class="s0">binary:      [ </span><span class="s4">2</span><span class="s0">,  </span><span class="s3">'bin' </span><span class="s0">],</span>
    <span class="s0">octal:       [ </span><span class="s4">8</span><span class="s0">,  </span><span class="s3">'oct' </span><span class="s0">],</span>
    <span class="s0">decimal:     [ </span><span class="s4">10</span><span class="s0">, </span><span class="s3">'dec' </span><span class="s0">],</span>
    <span class="s0">hexadecimal: [ </span><span class="s4">16</span><span class="s0">, </span><span class="s3">'hex' </span><span class="s0">]</span>
  <span class="s0">}</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">YAML_FLOAT_PATTERN = </span><span class="s2">new </span><span class="s0">RegExp(</span>
  <span class="s1">// 2.5e4, 2.5 and integers</span>
  <span class="s3">'^(?:[-+]?(?:[0-9][0-9_]*)(?:</span><span class="s5">\\</span><span class="s3">.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' </span><span class="s0">+</span>
  <span class="s1">// .2e4, .2</span>
  <span class="s1">// special case, seems not from spec</span>
  <span class="s3">'|</span><span class="s5">\\</span><span class="s3">.[0-9_]+(?:[eE][-+]?[0-9]+)?' </span><span class="s0">+</span>
  <span class="s1">// .inf</span>
  <span class="s3">'|[-+]?</span><span class="s5">\\</span><span class="s3">.(?:inf|Inf|INF)' </span><span class="s0">+</span>
  <span class="s1">// .nan</span>
  <span class="s3">'|</span><span class="s5">\\</span><span class="s3">.(?:nan|NaN|NAN))$'</span><span class="s0">);</span>

<span class="s2">function </span><span class="s0">resolveYamlFloat(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(!YAML_FLOAT_PATTERN.test(data) ||</span>
      <span class="s1">// Quick hack to not allow integers end with `_`</span>
      <span class="s1">// Probably should update regexp &amp; check speed</span>
      <span class="s0">data[data.length - </span><span class="s4">1</span><span class="s0">] === </span><span class="s3">'_'</span><span class="s0">) {</span>
    <span class="s2">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">constructYamlFloat(data) {</span>
  <span class="s2">var </span><span class="s0">value, sign;</span>

  <span class="s0">value  = data.replace(</span><span class="s6">/_/g</span><span class="s0">, </span><span class="s3">''</span><span class="s0">).toLowerCase();</span>
  <span class="s0">sign   = value[</span><span class="s4">0</span><span class="s0">] === </span><span class="s3">'-' </span><span class="s0">? -</span><span class="s4">1 </span><span class="s0">: </span><span class="s4">1</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(</span><span class="s3">'+-'</span><span class="s0">.indexOf(value[</span><span class="s4">0</span><span class="s0">]) &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">value = value.slice(</span><span class="s4">1</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(value === </span><span class="s3">'.inf'</span><span class="s0">) {</span>
    <span class="s2">return </span><span class="s0">(sign === </span><span class="s4">1</span><span class="s0">) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;</span>

  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(value === </span><span class="s3">'.nan'</span><span class="s0">) {</span>
    <span class="s2">return </span><span class="s0">NaN;</span>
  <span class="s0">}</span>
  <span class="s2">return </span><span class="s0">sign * parseFloat(value, </span><span class="s4">10</span><span class="s0">);</span>
<span class="s0">}</span>


<span class="s2">var </span><span class="s0">SCIENTIFIC_WITHOUT_DOT = </span><span class="s6">/^[-+]?[0-9]+e/</span><span class="s0">;</span>

<span class="s2">function </span><span class="s0">representYamlFloat(object, style) {</span>
  <span class="s2">var </span><span class="s0">res;</span>

  <span class="s2">if </span><span class="s0">(isNaN(object)) {</span>
    <span class="s2">switch </span><span class="s0">(style) {</span>
      <span class="s2">case </span><span class="s3">'lowercase'</span><span class="s0">: </span><span class="s2">return </span><span class="s3">'.nan'</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s3">'uppercase'</span><span class="s0">: </span><span class="s2">return </span><span class="s3">'.NAN'</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s3">'camelcase'</span><span class="s0">: </span><span class="s2">return </span><span class="s3">'.NaN'</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(Number.POSITIVE_INFINITY === object) {</span>
    <span class="s2">switch </span><span class="s0">(style) {</span>
      <span class="s2">case </span><span class="s3">'lowercase'</span><span class="s0">: </span><span class="s2">return </span><span class="s3">'.inf'</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s3">'uppercase'</span><span class="s0">: </span><span class="s2">return </span><span class="s3">'.INF'</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s3">'camelcase'</span><span class="s0">: </span><span class="s2">return </span><span class="s3">'.Inf'</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(Number.NEGATIVE_INFINITY === object) {</span>
    <span class="s2">switch </span><span class="s0">(style) {</span>
      <span class="s2">case </span><span class="s3">'lowercase'</span><span class="s0">: </span><span class="s2">return </span><span class="s3">'-.inf'</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s3">'uppercase'</span><span class="s0">: </span><span class="s2">return </span><span class="s3">'-.INF'</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s3">'camelcase'</span><span class="s0">: </span><span class="s2">return </span><span class="s3">'-.Inf'</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(common.isNegativeZero(object)) {</span>
    <span class="s2">return </span><span class="s3">'-0.0'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">res = object.toString(</span><span class="s4">10</span><span class="s0">);</span>

  <span class="s1">// JS stringifier can build scientific format without dots: 5e-100,</span>
  <span class="s1">// while YAML requres dot: 5.e-100. Fix it with simple hack</span>

  <span class="s2">return </span><span class="s0">SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace(</span><span class="s3">'e'</span><span class="s0">, </span><span class="s3">'.e'</span><span class="s0">) : res;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">isFloat(object) {</span>
  <span class="s2">return </span><span class="s0">(Object.prototype.toString.call(object) === </span><span class="s3">'[object Number]'</span><span class="s0">) &amp;&amp;</span>
         <span class="s0">(object % </span><span class="s4">1 </span><span class="s0">!== </span><span class="s4">0 </span><span class="s0">|| common.isNegativeZero(object));</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">float = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:float'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'scalar'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlFloat,</span>
  <span class="s0">construct: constructYamlFloat,</span>
  <span class="s0">predicate: isFloat,</span>
  <span class="s0">represent: representYamlFloat,</span>
  <span class="s0">defaultStyle: </span><span class="s3">'lowercase'</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">json = failsafe.extend({</span>
  <span class="s0">implicit: [</span>
    <span class="s0">_null,</span>
    <span class="s0">bool,</span>
    <span class="s0">int,</span>
    <span class="s0">float</span>
  <span class="s0">]</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">core = json;</span>

<span class="s2">var </span><span class="s0">YAML_DATE_REGEXP = </span><span class="s2">new </span><span class="s0">RegExp(</span>
  <span class="s3">'^([0-9][0-9][0-9][0-9])'          </span><span class="s0">+ </span><span class="s1">// [1] year</span>
  <span class="s3">'-([0-9][0-9])'                    </span><span class="s0">+ </span><span class="s1">// [2] month</span>
  <span class="s3">'-([0-9][0-9])$'</span><span class="s0">);                   </span><span class="s1">// [3] day</span>

<span class="s2">var </span><span class="s0">YAML_TIMESTAMP_REGEXP = </span><span class="s2">new </span><span class="s0">RegExp(</span>
  <span class="s3">'^([0-9][0-9][0-9][0-9])'          </span><span class="s0">+ </span><span class="s1">// [1] year</span>
  <span class="s3">'-([0-9][0-9]?)'                   </span><span class="s0">+ </span><span class="s1">// [2] month</span>
  <span class="s3">'-([0-9][0-9]?)'                   </span><span class="s0">+ </span><span class="s1">// [3] day</span>
  <span class="s3">'(?:[Tt]|[ </span><span class="s5">\\</span><span class="s3">t]+)'                 </span><span class="s0">+ </span><span class="s1">// ...</span>
  <span class="s3">'([0-9][0-9]?)'                    </span><span class="s0">+ </span><span class="s1">// [4] hour</span>
  <span class="s3">':([0-9][0-9])'                    </span><span class="s0">+ </span><span class="s1">// [5] minute</span>
  <span class="s3">':([0-9][0-9])'                    </span><span class="s0">+ </span><span class="s1">// [6] second</span>
  <span class="s3">'(?:</span><span class="s5">\\</span><span class="s3">.([0-9]*))?'                 </span><span class="s0">+ </span><span class="s1">// [7] fraction</span>
  <span class="s3">'(?:[ </span><span class="s5">\\</span><span class="s3">t]*(Z|([-+])([0-9][0-9]?)' </span><span class="s0">+ </span><span class="s1">// [8] tz [9] tz_sign [10] tz_hour</span>
  <span class="s3">'(?::([0-9][0-9]))?))?$'</span><span class="s0">);           </span><span class="s1">// [11] tz_minute</span>

<span class="s2">function </span><span class="s0">resolveYamlTimestamp(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>
  <span class="s2">if </span><span class="s0">(YAML_DATE_REGEXP.exec(data) !== </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return true</span><span class="s0">;</span>
  <span class="s2">if </span><span class="s0">(YAML_TIMESTAMP_REGEXP.exec(data) !== </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return true</span><span class="s0">;</span>
  <span class="s2">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">constructYamlTimestamp(data) {</span>
  <span class="s2">var </span><span class="s0">match, year, month, day, hour, minute, second, fraction = </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">delta = </span><span class="s2">null</span><span class="s0">, tz_hour, tz_minute, date;</span>

  <span class="s0">match = YAML_DATE_REGEXP.exec(data);</span>
  <span class="s2">if </span><span class="s0">(match === </span><span class="s2">null</span><span class="s0">) match = YAML_TIMESTAMP_REGEXP.exec(data);</span>

  <span class="s2">if </span><span class="s0">(match === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">throw new </span><span class="s0">Error(</span><span class="s3">'Date resolve error'</span><span class="s0">);</span>

  <span class="s1">// match: [1] year [2] month [3] day</span>

  <span class="s0">year = +(match[</span><span class="s4">1</span><span class="s0">]);</span>
  <span class="s0">month = +(match[</span><span class="s4">2</span><span class="s0">]) - </span><span class="s4">1</span><span class="s0">; </span><span class="s1">// JS month starts with 0</span>
  <span class="s0">day = +(match[</span><span class="s4">3</span><span class="s0">]);</span>

  <span class="s2">if </span><span class="s0">(!match[</span><span class="s4">4</span><span class="s0">]) { </span><span class="s1">// no hour</span>
    <span class="s2">return new </span><span class="s0">Date(Date.UTC(year, month, day));</span>
  <span class="s0">}</span>

  <span class="s1">// match: [4] hour [5] minute [6] second [7] fraction</span>

  <span class="s0">hour = +(match[</span><span class="s4">4</span><span class="s0">]);</span>
  <span class="s0">minute = +(match[</span><span class="s4">5</span><span class="s0">]);</span>
  <span class="s0">second = +(match[</span><span class="s4">6</span><span class="s0">]);</span>

  <span class="s2">if </span><span class="s0">(match[</span><span class="s4">7</span><span class="s0">]) {</span>
    <span class="s0">fraction = match[</span><span class="s4">7</span><span class="s0">].slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">3</span><span class="s0">);</span>
    <span class="s2">while </span><span class="s0">(fraction.length &lt; </span><span class="s4">3</span><span class="s0">) { </span><span class="s1">// milli-seconds</span>
      <span class="s0">fraction += </span><span class="s3">'0'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">fraction = +fraction;</span>
  <span class="s0">}</span>

  <span class="s1">// match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute</span>

  <span class="s2">if </span><span class="s0">(match[</span><span class="s4">9</span><span class="s0">]) {</span>
    <span class="s0">tz_hour = +(match[</span><span class="s4">10</span><span class="s0">]);</span>
    <span class="s0">tz_minute = +(match[</span><span class="s4">11</span><span class="s0">] || </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s0">delta = (tz_hour * </span><span class="s4">60 </span><span class="s0">+ tz_minute) * </span><span class="s4">60000</span><span class="s0">; </span><span class="s1">// delta in mili-seconds</span>
    <span class="s2">if </span><span class="s0">(match[</span><span class="s4">9</span><span class="s0">] === </span><span class="s3">'-'</span><span class="s0">) delta = -delta;</span>
  <span class="s0">}</span>

  <span class="s0">date = </span><span class="s2">new </span><span class="s0">Date(Date.UTC(year, month, day, hour, minute, second, fraction));</span>

  <span class="s2">if </span><span class="s0">(delta) date.setTime(date.getTime() - delta);</span>

  <span class="s2">return </span><span class="s0">date;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">representYamlTimestamp(object </span><span class="s1">/*, style*/</span><span class="s0">) {</span>
  <span class="s2">return </span><span class="s0">object.toISOString();</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">timestamp = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:timestamp'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'scalar'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlTimestamp,</span>
  <span class="s0">construct: constructYamlTimestamp,</span>
  <span class="s0">instanceOf: Date,</span>
  <span class="s0">represent: representYamlTimestamp</span>
<span class="s0">});</span>

<span class="s2">function </span><span class="s0">resolveYamlMerge(data) {</span>
  <span class="s2">return </span><span class="s0">data === </span><span class="s3">'&lt;&lt;' </span><span class="s0">|| data === </span><span class="s2">null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">merge = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:merge'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'scalar'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlMerge</span>
<span class="s0">});</span>

<span class="s1">/*eslint-disable no-bitwise*/</span>





<span class="s1">// [ 64, 65, 66 ] -&gt; [ padding, CR, LF ]</span>
<span class="s2">var </span><span class="s0">BASE64_MAP = </span><span class="s3">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=</span><span class="s5">\n\r</span><span class="s3">'</span><span class="s0">;</span>


<span class="s2">function </span><span class="s0">resolveYamlBinary(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">var </span><span class="s0">code, idx, bitlen = </span><span class="s4">0</span><span class="s0">, max = data.length, map = BASE64_MAP;</span>

  <span class="s1">// Convert one by one.</span>
  <span class="s2">for </span><span class="s0">(idx = </span><span class="s4">0</span><span class="s0">; idx &lt; max; idx++) {</span>
    <span class="s0">code = map.indexOf(data.charAt(idx));</span>

    <span class="s1">// Skip CR/LF</span>
    <span class="s2">if </span><span class="s0">(code &gt; </span><span class="s4">64</span><span class="s0">) </span><span class="s2">continue</span><span class="s0">;</span>

    <span class="s1">// Fail on illegal characters</span>
    <span class="s2">if </span><span class="s0">(code &lt; </span><span class="s4">0</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

    <span class="s0">bitlen += </span><span class="s4">6</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">// If there are any bits left, source was corrupted</span>
  <span class="s2">return </span><span class="s0">(bitlen % </span><span class="s4">8</span><span class="s0">) === </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">constructYamlBinary(data) {</span>
  <span class="s2">var </span><span class="s0">idx, tailbits,</span>
      <span class="s0">input = data.replace(</span><span class="s6">/[\r\n=]/g</span><span class="s0">, </span><span class="s3">''</span><span class="s0">), </span><span class="s1">// remove CR/LF &amp; padding to simplify scan</span>
      <span class="s0">max = input.length,</span>
      <span class="s0">map = BASE64_MAP,</span>
      <span class="s0">bits = </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">result = [];</span>

  <span class="s1">// Collect by 6*4 bits (3 bytes)</span>

  <span class="s2">for </span><span class="s0">(idx = </span><span class="s4">0</span><span class="s0">; idx &lt; max; idx++) {</span>
    <span class="s2">if </span><span class="s0">((idx % </span><span class="s4">4 </span><span class="s0">=== </span><span class="s4">0</span><span class="s0">) &amp;&amp; idx) {</span>
      <span class="s0">result.push((bits &gt;&gt; </span><span class="s4">16</span><span class="s0">) &amp; </span><span class="s4">0xFF</span><span class="s0">);</span>
      <span class="s0">result.push((bits &gt;&gt; </span><span class="s4">8</span><span class="s0">) &amp; </span><span class="s4">0xFF</span><span class="s0">);</span>
      <span class="s0">result.push(bits &amp; </span><span class="s4">0xFF</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">bits = (bits &lt;&lt; </span><span class="s4">6</span><span class="s0">) | map.indexOf(input.charAt(idx));</span>
  <span class="s0">}</span>

  <span class="s1">// Dump tail</span>

  <span class="s0">tailbits = (max % </span><span class="s4">4</span><span class="s0">) * </span><span class="s4">6</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(tailbits === </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">result.push((bits &gt;&gt; </span><span class="s4">16</span><span class="s0">) &amp; </span><span class="s4">0xFF</span><span class="s0">);</span>
    <span class="s0">result.push((bits &gt;&gt; </span><span class="s4">8</span><span class="s0">) &amp; </span><span class="s4">0xFF</span><span class="s0">);</span>
    <span class="s0">result.push(bits &amp; </span><span class="s4">0xFF</span><span class="s0">);</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(tailbits === </span><span class="s4">18</span><span class="s0">) {</span>
    <span class="s0">result.push((bits &gt;&gt; </span><span class="s4">10</span><span class="s0">) &amp; </span><span class="s4">0xFF</span><span class="s0">);</span>
    <span class="s0">result.push((bits &gt;&gt; </span><span class="s4">2</span><span class="s0">) &amp; </span><span class="s4">0xFF</span><span class="s0">);</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(tailbits === </span><span class="s4">12</span><span class="s0">) {</span>
    <span class="s0">result.push((bits &gt;&gt; </span><span class="s4">4</span><span class="s0">) &amp; </span><span class="s4">0xFF</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">return new </span><span class="s0">Uint8Array(result);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">representYamlBinary(object </span><span class="s1">/*, style*/</span><span class="s0">) {</span>
  <span class="s2">var </span><span class="s0">result = </span><span class="s3">''</span><span class="s0">, bits = </span><span class="s4">0</span><span class="s0">, idx, tail,</span>
      <span class="s0">max = object.length,</span>
      <span class="s0">map = BASE64_MAP;</span>

  <span class="s1">// Convert every three bytes to 4 ASCII characters.</span>

  <span class="s2">for </span><span class="s0">(idx = </span><span class="s4">0</span><span class="s0">; idx &lt; max; idx++) {</span>
    <span class="s2">if </span><span class="s0">((idx % </span><span class="s4">3 </span><span class="s0">=== </span><span class="s4">0</span><span class="s0">) &amp;&amp; idx) {</span>
      <span class="s0">result += map[(bits &gt;&gt; </span><span class="s4">18</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
      <span class="s0">result += map[(bits &gt;&gt; </span><span class="s4">12</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
      <span class="s0">result += map[(bits &gt;&gt; </span><span class="s4">6</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
      <span class="s0">result += map[bits &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s0">bits = (bits &lt;&lt; </span><span class="s4">8</span><span class="s0">) + object[idx];</span>
  <span class="s0">}</span>

  <span class="s1">// Dump tail</span>

  <span class="s0">tail = max % </span><span class="s4">3</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(tail === </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">result += map[(bits &gt;&gt; </span><span class="s4">18</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
    <span class="s0">result += map[(bits &gt;&gt; </span><span class="s4">12</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
    <span class="s0">result += map[(bits &gt;&gt; </span><span class="s4">6</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
    <span class="s0">result += map[bits &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(tail === </span><span class="s4">2</span><span class="s0">) {</span>
    <span class="s0">result += map[(bits &gt;&gt; </span><span class="s4">10</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
    <span class="s0">result += map[(bits &gt;&gt; </span><span class="s4">4</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
    <span class="s0">result += map[(bits &lt;&lt; </span><span class="s4">2</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
    <span class="s0">result += map[</span><span class="s4">64</span><span class="s0">];</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(tail === </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">result += map[(bits &gt;&gt; </span><span class="s4">2</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
    <span class="s0">result += map[(bits &lt;&lt; </span><span class="s4">4</span><span class="s0">) &amp; </span><span class="s4">0x3F</span><span class="s0">];</span>
    <span class="s0">result += map[</span><span class="s4">64</span><span class="s0">];</span>
    <span class="s0">result += map[</span><span class="s4">64</span><span class="s0">];</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">isBinary(obj) {</span>
  <span class="s2">return </span><span class="s0">Object.prototype.toString.call(obj) ===  </span><span class="s3">'[object Uint8Array]'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">binary = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:binary'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'scalar'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlBinary,</span>
  <span class="s0">construct: constructYamlBinary,</span>
  <span class="s0">predicate: isBinary,</span>
  <span class="s0">represent: representYamlBinary</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">_hasOwnProperty$3 = Object.prototype.hasOwnProperty;</span>
<span class="s2">var </span><span class="s0">_toString$2       = Object.prototype.toString;</span>

<span class="s2">function </span><span class="s0">resolveYamlOmap(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return true</span><span class="s0">;</span>

  <span class="s2">var </span><span class="s0">objectKeys = [], index, length, pair, pairKey, pairHasKey,</span>
      <span class="s0">object = data;</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">pair = object[index];</span>
    <span class="s0">pairHasKey = </span><span class="s2">false</span><span class="s0">;</span>

    <span class="s2">if </span><span class="s0">(_toString$2.call(pair) !== </span><span class="s3">'[object Object]'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

    <span class="s2">for </span><span class="s0">(pairKey </span><span class="s2">in </span><span class="s0">pair) {</span>
      <span class="s2">if </span><span class="s0">(_hasOwnProperty$3.call(pair, pairKey)) {</span>
        <span class="s2">if </span><span class="s0">(!pairHasKey) pairHasKey = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s2">else return false</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(!pairHasKey) </span><span class="s2">return false</span><span class="s0">;</span>

    <span class="s2">if </span><span class="s0">(objectKeys.indexOf(pairKey) === -</span><span class="s4">1</span><span class="s0">) objectKeys.push(pairKey);</span>
    <span class="s2">else return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">constructYamlOmap(data) {</span>
  <span class="s2">return </span><span class="s0">data !== </span><span class="s2">null </span><span class="s0">? data : [];</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">omap = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:omap'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'sequence'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlOmap,</span>
  <span class="s0">construct: constructYamlOmap</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">_toString$1 = Object.prototype.toString;</span>

<span class="s2">function </span><span class="s0">resolveYamlPairs(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return true</span><span class="s0">;</span>

  <span class="s2">var </span><span class="s0">index, length, pair, keys, result,</span>
      <span class="s0">object = data;</span>

  <span class="s0">result = </span><span class="s2">new </span><span class="s0">Array(object.length);</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">pair = object[index];</span>

    <span class="s2">if </span><span class="s0">(_toString$1.call(pair) !== </span><span class="s3">'[object Object]'</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

    <span class="s0">keys = Object.keys(pair);</span>

    <span class="s2">if </span><span class="s0">(keys.length !== </span><span class="s4">1</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

    <span class="s0">result[index] = [ keys[</span><span class="s4">0</span><span class="s0">], pair[keys[</span><span class="s4">0</span><span class="s0">]] ];</span>
  <span class="s0">}</span>

  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">constructYamlPairs(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return </span><span class="s0">[];</span>

  <span class="s2">var </span><span class="s0">index, length, pair, keys, result,</span>
      <span class="s0">object = data;</span>

  <span class="s0">result = </span><span class="s2">new </span><span class="s0">Array(object.length);</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">pair = object[index];</span>

    <span class="s0">keys = Object.keys(pair);</span>

    <span class="s0">result[index] = [ keys[</span><span class="s4">0</span><span class="s0">], pair[keys[</span><span class="s4">0</span><span class="s0">]] ];</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">pairs = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:pairs'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'sequence'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlPairs,</span>
  <span class="s0">construct: constructYamlPairs</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">_hasOwnProperty$2 = Object.prototype.hasOwnProperty;</span>

<span class="s2">function </span><span class="s0">resolveYamlSet(data) {</span>
  <span class="s2">if </span><span class="s0">(data === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return true</span><span class="s0">;</span>

  <span class="s2">var </span><span class="s0">key, object = data;</span>

  <span class="s2">for </span><span class="s0">(key </span><span class="s2">in </span><span class="s0">object) {</span>
    <span class="s2">if </span><span class="s0">(_hasOwnProperty$2.call(object, key)) {</span>
      <span class="s2">if </span><span class="s0">(object[key] !== </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">constructYamlSet(data) {</span>
  <span class="s2">return </span><span class="s0">data !== </span><span class="s2">null </span><span class="s0">? data : {};</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">set = </span><span class="s2">new </span><span class="s0">type(</span><span class="s3">'tag:yaml.org,2002:set'</span><span class="s0">, {</span>
  <span class="s0">kind: </span><span class="s3">'mapping'</span><span class="s0">,</span>
  <span class="s0">resolve: resolveYamlSet,</span>
  <span class="s0">construct: constructYamlSet</span>
<span class="s0">});</span>

<span class="s2">var </span><span class="s0">_default = core.extend({</span>
  <span class="s0">implicit: [</span>
    <span class="s0">timestamp,</span>
    <span class="s0">merge</span>
  <span class="s0">],</span>
  <span class="s0">explicit: [</span>
    <span class="s0">binary,</span>
    <span class="s0">omap,</span>
    <span class="s0">pairs,</span>
    <span class="s0">set</span>
  <span class="s0">]</span>
<span class="s0">});</span>

<span class="s1">/*eslint-disable max-len,no-use-before-define*/</span>







<span class="s2">var </span><span class="s0">_hasOwnProperty$1 = Object.prototype.hasOwnProperty;</span>


<span class="s2">var </span><span class="s0">CONTEXT_FLOW_IN   = </span><span class="s4">1</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">CONTEXT_FLOW_OUT  = </span><span class="s4">2</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">CONTEXT_BLOCK_IN  = </span><span class="s4">3</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">CONTEXT_BLOCK_OUT = </span><span class="s4">4</span><span class="s0">;</span>


<span class="s2">var </span><span class="s0">CHOMPING_CLIP  = </span><span class="s4">1</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">CHOMPING_STRIP = </span><span class="s4">2</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">CHOMPING_KEEP  = </span><span class="s4">3</span><span class="s0">;</span>


<span class="s2">var </span><span class="s0">PATTERN_NON_PRINTABLE         = </span><span class="s6">/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">PATTERN_NON_ASCII_LINE_BREAKS = </span><span class="s6">/[\x85\u2028\u2029]/</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">PATTERN_FLOW_INDICATORS       = </span><span class="s6">/[,\[\]\{\}]/</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">PATTERN_TAG_HANDLE            = </span><span class="s6">/^(?:!|!!|![a-z\-]+!)$/i</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">PATTERN_TAG_URI               = </span><span class="s6">/^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&amp;=\+\$,_\.!~\*'\(\)\[\]])*$/i</span><span class="s0">;</span>


<span class="s2">function </span><span class="s0">_class(obj) { </span><span class="s2">return </span><span class="s0">Object.prototype.toString.call(obj); }</span>

<span class="s2">function </span><span class="s0">is_EOL(c) {</span>
  <span class="s2">return </span><span class="s0">(c === </span><span class="s4">0x0A</span><span class="s1">/* LF */</span><span class="s0">) || (c === </span><span class="s4">0x0D</span><span class="s1">/* CR */</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">is_WHITE_SPACE(c) {</span>
  <span class="s2">return </span><span class="s0">(c === </span><span class="s4">0x09</span><span class="s1">/* Tab */</span><span class="s0">) || (c === </span><span class="s4">0x20</span><span class="s1">/* Space */</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">is_WS_OR_EOL(c) {</span>
  <span class="s2">return </span><span class="s0">(c === </span><span class="s4">0x09</span><span class="s1">/* Tab */</span><span class="s0">) ||</span>
         <span class="s0">(c === </span><span class="s4">0x20</span><span class="s1">/* Space */</span><span class="s0">) ||</span>
         <span class="s0">(c === </span><span class="s4">0x0A</span><span class="s1">/* LF */</span><span class="s0">) ||</span>
         <span class="s0">(c === </span><span class="s4">0x0D</span><span class="s1">/* CR */</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">is_FLOW_INDICATOR(c) {</span>
  <span class="s2">return </span><span class="s0">c === </span><span class="s4">0x2C</span><span class="s1">/* , */ </span><span class="s0">||</span>
         <span class="s0">c === </span><span class="s4">0x5B</span><span class="s1">/* [ */ </span><span class="s0">||</span>
         <span class="s0">c === </span><span class="s4">0x5D</span><span class="s1">/* ] */ </span><span class="s0">||</span>
         <span class="s0">c === </span><span class="s4">0x7B</span><span class="s1">/* { */ </span><span class="s0">||</span>
         <span class="s0">c === </span><span class="s4">0x7D</span><span class="s1">/* } */</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">fromHexCode(c) {</span>
  <span class="s2">var </span><span class="s0">lc;</span>

  <span class="s2">if </span><span class="s0">((</span><span class="s4">0x30</span><span class="s1">/* 0 */ </span><span class="s0">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0x39</span><span class="s1">/* 9 */</span><span class="s0">)) {</span>
    <span class="s2">return </span><span class="s0">c - </span><span class="s4">0x30</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">/*eslint-disable no-bitwise*/</span>
  <span class="s0">lc = c | </span><span class="s4">0x20</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">((</span><span class="s4">0x61</span><span class="s1">/* a */ </span><span class="s0">&lt;= lc) &amp;&amp; (lc &lt;= </span><span class="s4">0x66</span><span class="s1">/* f */</span><span class="s0">)) {</span>
    <span class="s2">return </span><span class="s0">lc - </span><span class="s4">0x61 </span><span class="s0">+ </span><span class="s4">10</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">escapedHexLen(c) {</span>
  <span class="s2">if </span><span class="s0">(c === </span><span class="s4">0x78</span><span class="s1">/* x */</span><span class="s0">) { </span><span class="s2">return </span><span class="s4">2</span><span class="s0">; }</span>
  <span class="s2">if </span><span class="s0">(c === </span><span class="s4">0x75</span><span class="s1">/* u */</span><span class="s0">) { </span><span class="s2">return </span><span class="s4">4</span><span class="s0">; }</span>
  <span class="s2">if </span><span class="s0">(c === </span><span class="s4">0x55</span><span class="s1">/* U */</span><span class="s0">) { </span><span class="s2">return </span><span class="s4">8</span><span class="s0">; }</span>
  <span class="s2">return </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">fromDecimalCode(c) {</span>
  <span class="s2">if </span><span class="s0">((</span><span class="s4">0x30</span><span class="s1">/* 0 */ </span><span class="s0">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0x39</span><span class="s1">/* 9 */</span><span class="s0">)) {</span>
    <span class="s2">return </span><span class="s0">c - </span><span class="s4">0x30</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">simpleEscapeSequence(c) {</span>
  <span class="s1">/* eslint-disable indent */</span>
  <span class="s2">return </span><span class="s0">(c === </span><span class="s4">0x30</span><span class="s1">/* 0 */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x00</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x61</span><span class="s1">/* a */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x07</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x62</span><span class="s1">/* b */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x08</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x74</span><span class="s1">/* t */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x09</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x09</span><span class="s1">/* Tab */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x09</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x6E</span><span class="s1">/* n */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x0A</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x76</span><span class="s1">/* v */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x0B</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x66</span><span class="s1">/* f */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x0C</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x72</span><span class="s1">/* r */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x0D</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x65</span><span class="s1">/* e */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x1B</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x20</span><span class="s1">/* Space */</span><span class="s0">) ? </span><span class="s3">' ' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x22</span><span class="s1">/* &quot; */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x22</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x2F</span><span class="s1">/* / */</span><span class="s0">) ? </span><span class="s3">'/' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x5C</span><span class="s1">/* \ */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x5C</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x4E</span><span class="s1">/* N */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\x85</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x5F</span><span class="s1">/* _ */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\xA0</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x4C</span><span class="s1">/* L */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\u2028</span><span class="s3">' </span><span class="s0">:</span>
        <span class="s0">(c === </span><span class="s4">0x50</span><span class="s1">/* P */</span><span class="s0">) ? </span><span class="s3">'</span><span class="s5">\u2029</span><span class="s3">' </span><span class="s0">: </span><span class="s3">''</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">charFromCodepoint(c) {</span>
  <span class="s2">if </span><span class="s0">(c &lt;= </span><span class="s4">0xFFFF</span><span class="s0">) {</span>
    <span class="s2">return </span><span class="s0">String.fromCharCode(c);</span>
  <span class="s0">}</span>
  <span class="s1">// Encode UTF-16 surrogate pair</span>
  <span class="s1">// https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF</span>
  <span class="s2">return </span><span class="s0">String.fromCharCode(</span>
    <span class="s0">((c - </span><span class="s4">0x010000</span><span class="s0">) &gt;&gt; </span><span class="s4">10</span><span class="s0">) + </span><span class="s4">0xD800</span><span class="s0">,</span>
    <span class="s0">((c - </span><span class="s4">0x010000</span><span class="s0">) &amp; </span><span class="s4">0x03FF</span><span class="s0">) + </span><span class="s4">0xDC00</span>
  <span class="s0">);</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">simpleEscapeCheck = </span><span class="s2">new </span><span class="s0">Array(</span><span class="s4">256</span><span class="s0">); </span><span class="s1">// integer, for fast access</span>
<span class="s2">var </span><span class="s0">simpleEscapeMap = </span><span class="s2">new </span><span class="s0">Array(</span><span class="s4">256</span><span class="s0">);</span>
<span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s4">256</span><span class="s0">; i++) {</span>
  <span class="s0">simpleEscapeCheck[i] = simpleEscapeSequence(i) ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">simpleEscapeMap[i] = simpleEscapeSequence(i);</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">State$1(input, options) {</span>
  <span class="s2">this</span><span class="s0">.input = input;</span>

  <span class="s2">this</span><span class="s0">.filename  = options[</span><span class="s3">'filename'</span><span class="s0">]  || </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.schema    = options[</span><span class="s3">'schema'</span><span class="s0">]    || _default;</span>
  <span class="s2">this</span><span class="s0">.onWarning = options[</span><span class="s3">'onWarning'</span><span class="s0">] || </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s1">// (Hidden) Remove? makes the loader to expect YAML 1.1 documents</span>
  <span class="s1">// if such documents have no explicit %YAML directive</span>
  <span class="s2">this</span><span class="s0">.legacy    = options[</span><span class="s3">'legacy'</span><span class="s0">]    || </span><span class="s2">false</span><span class="s0">;</span>

  <span class="s2">this</span><span class="s0">.json      = options[</span><span class="s3">'json'</span><span class="s0">]      || </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.listener  = options[</span><span class="s3">'listener'</span><span class="s0">]  || </span><span class="s2">null</span><span class="s0">;</span>

  <span class="s2">this</span><span class="s0">.implicitTypes = </span><span class="s2">this</span><span class="s0">.schema.compiledImplicit;</span>
  <span class="s2">this</span><span class="s0">.typeMap       = </span><span class="s2">this</span><span class="s0">.schema.compiledTypeMap;</span>

  <span class="s2">this</span><span class="s0">.length     = input.length;</span>
  <span class="s2">this</span><span class="s0">.position   = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.line       = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.lineStart  = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.lineIndent = </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">// position of first leading tab in the current line,</span>
  <span class="s1">// used to make sure there are no tabs in the indentation</span>
  <span class="s2">this</span><span class="s0">.firstTabInLine = -</span><span class="s4">1</span><span class="s0">;</span>

  <span class="s2">this</span><span class="s0">.documents = [];</span>

  <span class="s1">/* 
  this.version; 
  this.checkLineBreaks; 
  this.tagMap; 
  this.anchorMap; 
  this.tag; 
  this.anchor; 
  this.kind; 
  this.result;*/</span>

<span class="s0">}</span>


<span class="s2">function </span><span class="s0">generateError(state, message) {</span>
  <span class="s2">var </span><span class="s0">mark = {</span>
    <span class="s0">name:     state.filename,</span>
    <span class="s0">buffer:   state.input.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">), </span><span class="s1">// omit trailing \0</span>
    <span class="s0">position: state.position,</span>
    <span class="s0">line:     state.line,</span>
    <span class="s0">column:   state.position - state.lineStart</span>
  <span class="s0">};</span>

  <span class="s0">mark.snippet = snippet(mark);</span>

  <span class="s2">return new </span><span class="s0">exception(message, mark);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">throwError(state, message) {</span>
  <span class="s2">throw </span><span class="s0">generateError(state, message);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">throwWarning(state, message) {</span>
  <span class="s2">if </span><span class="s0">(state.onWarning) {</span>
    <span class="s0">state.onWarning.call(</span><span class="s2">null</span><span class="s0">, generateError(state, message));</span>
  <span class="s0">}</span>
<span class="s0">}</span>


<span class="s2">var </span><span class="s0">directiveHandlers = {</span>

  <span class="s0">YAML: </span><span class="s2">function </span><span class="s0">handleYamlDirective(state, name, args) {</span>

    <span class="s2">var </span><span class="s0">match, major, minor;</span>

    <span class="s2">if </span><span class="s0">(state.version !== </span><span class="s2">null</span><span class="s0">) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'duplication of %YAML directive'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(args.length !== </span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'YAML directive accepts exactly one argument'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">match = </span><span class="s6">/^([0-9]+)\.([0-9]+)$/</span><span class="s0">.exec(args[</span><span class="s4">0</span><span class="s0">]);</span>

    <span class="s2">if </span><span class="s0">(match === </span><span class="s2">null</span><span class="s0">) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'ill-formed argument of the YAML directive'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">major = parseInt(match[</span><span class="s4">1</span><span class="s0">], </span><span class="s4">10</span><span class="s0">);</span>
    <span class="s0">minor = parseInt(match[</span><span class="s4">2</span><span class="s0">], </span><span class="s4">10</span><span class="s0">);</span>

    <span class="s2">if </span><span class="s0">(major !== </span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'unacceptable YAML version of the document'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">state.version = args[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s0">state.checkLineBreaks = (minor &lt; </span><span class="s4">2</span><span class="s0">);</span>

    <span class="s2">if </span><span class="s0">(minor !== </span><span class="s4">1 </span><span class="s0">&amp;&amp; minor !== </span><span class="s4">2</span><span class="s0">) {</span>
      <span class="s0">throwWarning(state, </span><span class="s3">'unsupported YAML version of the document'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">},</span>

  <span class="s0">TAG: </span><span class="s2">function </span><span class="s0">handleTagDirective(state, name, args) {</span>

    <span class="s2">var </span><span class="s0">handle, prefix;</span>

    <span class="s2">if </span><span class="s0">(args.length !== </span><span class="s4">2</span><span class="s0">) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'TAG directive accepts exactly two arguments'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">handle = args[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s0">prefix = args[</span><span class="s4">1</span><span class="s0">];</span>

    <span class="s2">if </span><span class="s0">(!PATTERN_TAG_HANDLE.test(handle)) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'ill-formed tag handle (first argument) of the TAG directive'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(_hasOwnProperty$1.call(state.tagMap, handle)) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'there is a previously declared suffix for &quot;' </span><span class="s0">+ handle + </span><span class="s3">'&quot; tag handle'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(!PATTERN_TAG_URI.test(prefix)) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'ill-formed tag prefix (second argument) of the TAG directive'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">try </span><span class="s0">{</span>
      <span class="s0">prefix = decodeURIComponent(prefix);</span>
    <span class="s0">} </span><span class="s2">catch </span><span class="s0">(err) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'tag prefix is malformed: ' </span><span class="s0">+ prefix);</span>
    <span class="s0">}</span>

    <span class="s0">state.tagMap[handle] = prefix;</span>
  <span class="s0">}</span>
<span class="s0">};</span>


<span class="s2">function </span><span class="s0">captureSegment(state, start, end, checkJson) {</span>
  <span class="s2">var </span><span class="s0">_position, _length, _character, _result;</span>

  <span class="s2">if </span><span class="s0">(start &lt; end) {</span>
    <span class="s0">_result = state.input.slice(start, end);</span>

    <span class="s2">if </span><span class="s0">(checkJson) {</span>
      <span class="s2">for </span><span class="s0">(_position = </span><span class="s4">0</span><span class="s0">, _length = _result.length; _position &lt; _length; _position += </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s0">_character = _result.charCodeAt(_position);</span>
        <span class="s2">if </span><span class="s0">(!(_character === </span><span class="s4">0x09 </span><span class="s0">||</span>
              <span class="s0">(</span><span class="s4">0x20 </span><span class="s0">&lt;= _character &amp;&amp; _character &lt;= </span><span class="s4">0x10FFFF</span><span class="s0">))) {</span>
          <span class="s0">throwError(state, </span><span class="s3">'expected valid JSON character'</span><span class="s0">);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(PATTERN_NON_PRINTABLE.test(_result)) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'the stream contains non-printable characters'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">state.result += _result;</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">mergeMappings(state, destination, source, overridableKeys) {</span>
  <span class="s2">var </span><span class="s0">sourceKeys, key, index, quantity;</span>

  <span class="s2">if </span><span class="s0">(!common.isObject(source)) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'cannot merge mappings; the provided source object is unacceptable'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">sourceKeys = Object.keys(source);</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, quantity = sourceKeys.length; index &lt; quantity; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">key = sourceKeys[index];</span>

    <span class="s2">if </span><span class="s0">(!_hasOwnProperty$1.call(destination, key)) {</span>
      <span class="s0">destination[key] = source[key];</span>
      <span class="s0">overridableKeys[key] = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,</span>
  <span class="s0">startLine, startLineStart, startPos) {</span>

  <span class="s2">var </span><span class="s0">index, quantity;</span>

  <span class="s1">// The output is a plain object here, so keys can only be strings.</span>
  <span class="s1">// We need to convert keyNode to a string, but doing so can hang the process</span>
  <span class="s1">// (deeply nested arrays that explode exponentially using aliases).</span>
  <span class="s2">if </span><span class="s0">(Array.isArray(keyNode)) {</span>
    <span class="s0">keyNode = Array.prototype.slice.call(keyNode);</span>

    <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, quantity = keyNode.length; index &lt; quantity; index += </span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s2">if </span><span class="s0">(Array.isArray(keyNode[index])) {</span>
        <span class="s0">throwError(state, </span><span class="s3">'nested arrays are not supported inside keys'</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">keyNode === </span><span class="s3">'object' </span><span class="s0">&amp;&amp; _class(keyNode[index]) === </span><span class="s3">'[object Object]'</span><span class="s0">) {</span>
        <span class="s0">keyNode[index] = </span><span class="s3">'[object Object]'</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">// Avoid code execution in load() via toString property</span>
  <span class="s1">// (still use its own toString for arrays, timestamps,</span>
  <span class="s1">// and whatever user schema extensions happen to have @@toStringTag)</span>
  <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">keyNode === </span><span class="s3">'object' </span><span class="s0">&amp;&amp; _class(keyNode) === </span><span class="s3">'[object Object]'</span><span class="s0">) {</span>
    <span class="s0">keyNode = </span><span class="s3">'[object Object]'</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s0">keyNode = String(keyNode);</span>

  <span class="s2">if </span><span class="s0">(_result === </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s0">_result = {};</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(keyTag === </span><span class="s3">'tag:yaml.org,2002:merge'</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(Array.isArray(valueNode)) {</span>
      <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, quantity = valueNode.length; index &lt; quantity; index += </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s0">mergeMappings(state, _result, valueNode[index], overridableKeys);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">mergeMappings(state, _result, valueNode, overridableKeys);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s2">if </span><span class="s0">(!state.json &amp;&amp;</span>
        <span class="s0">!_hasOwnProperty$1.call(overridableKeys, keyNode) &amp;&amp;</span>
        <span class="s0">_hasOwnProperty$1.call(_result, keyNode)) {</span>
      <span class="s0">state.line = startLine || state.line;</span>
      <span class="s0">state.lineStart = startLineStart || state.lineStart;</span>
      <span class="s0">state.position = startPos || state.position;</span>
      <span class="s0">throwError(state, </span><span class="s3">'duplicated mapping key'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">// used for this specific key only because Object.defineProperty is slow</span>
    <span class="s2">if </span><span class="s0">(keyNode === </span><span class="s3">'__proto__'</span><span class="s0">) {</span>
      <span class="s0">Object.defineProperty(_result, keyNode, {</span>
        <span class="s0">configurable: </span><span class="s2">true</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s2">true</span><span class="s0">,</span>
        <span class="s0">writable: </span><span class="s2">true</span><span class="s0">,</span>
        <span class="s0">value: valueNode</span>
      <span class="s0">});</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">_result[keyNode] = valueNode;</span>
    <span class="s0">}</span>
    <span class="s2">delete </span><span class="s0">overridableKeys[keyNode];</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">_result;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readLineBreak(state) {</span>
  <span class="s2">var </span><span class="s0">ch;</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x0A</span><span class="s1">/* LF */</span><span class="s0">) {</span>
    <span class="s0">state.position++;</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(ch === </span><span class="s4">0x0D</span><span class="s1">/* CR */</span><span class="s0">) {</span>
    <span class="s0">state.position++;</span>
    <span class="s2">if </span><span class="s0">(state.input.charCodeAt(state.position) === </span><span class="s4">0x0A</span><span class="s1">/* LF */</span><span class="s0">) {</span>
      <span class="s0">state.position++;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s0">throwError(state, </span><span class="s3">'a line break is expected'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">state.line += </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">state.lineStart = state.position;</span>
  <span class="s0">state.firstTabInLine = -</span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">skipSeparationSpace(state, allowComments, checkIndent) {</span>
  <span class="s2">var </span><span class="s0">lineBreaks = </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s2">while </span><span class="s0">(is_WHITE_SPACE(ch)) {</span>
      <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x09</span><span class="s1">/* Tab */ </span><span class="s0">&amp;&amp; state.firstTabInLine === -</span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s0">state.firstTabInLine = state.position;</span>
      <span class="s0">}</span>
      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(allowComments &amp;&amp; ch === </span><span class="s4">0x23</span><span class="s1">/* # */</span><span class="s0">) {</span>
      <span class="s2">do </span><span class="s0">{</span>
        <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s0">} </span><span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0x0A</span><span class="s1">/* LF */ </span><span class="s0">&amp;&amp; ch !== </span><span class="s4">0x0D</span><span class="s1">/* CR */ </span><span class="s0">&amp;&amp; ch !== </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(is_EOL(ch)) {</span>
      <span class="s0">readLineBreak(state);</span>

      <span class="s0">ch = state.input.charCodeAt(state.position);</span>
      <span class="s0">lineBreaks++;</span>
      <span class="s0">state.lineIndent = </span><span class="s4">0</span><span class="s0">;</span>

      <span class="s2">while </span><span class="s0">(ch === </span><span class="s4">0x20</span><span class="s1">/* Space */</span><span class="s0">) {</span>
        <span class="s0">state.lineIndent++;</span>
        <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s2">break</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(checkIndent !== -</span><span class="s4">1 </span><span class="s0">&amp;&amp; lineBreaks !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; state.lineIndent &lt; checkIndent) {</span>
    <span class="s0">throwWarning(state, </span><span class="s3">'deficient indentation'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">lineBreaks;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">testDocumentSeparator(state) {</span>
  <span class="s2">var </span><span class="s0">_position = state.position,</span>
      <span class="s0">ch;</span>

  <span class="s0">ch = state.input.charCodeAt(_position);</span>

  <span class="s1">// Condition state.position === state.lineStart is tested</span>
  <span class="s1">// in parent on each call, for efficiency. No needs to test here again.</span>
  <span class="s2">if </span><span class="s0">((ch === </span><span class="s4">0x2D</span><span class="s1">/* - */ </span><span class="s0">|| ch === </span><span class="s4">0x2E</span><span class="s1">/* . */</span><span class="s0">) &amp;&amp;</span>
      <span class="s0">ch === state.input.charCodeAt(_position + </span><span class="s4">1</span><span class="s0">) &amp;&amp;</span>
      <span class="s0">ch === state.input.charCodeAt(_position + </span><span class="s4">2</span><span class="s0">)) {</span>

    <span class="s0">_position += </span><span class="s4">3</span><span class="s0">;</span>

    <span class="s0">ch = state.input.charCodeAt(_position);</span>

    <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0 </span><span class="s0">|| is_WS_OR_EOL(ch)) {</span>
      <span class="s2">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">writeFoldedLines(state, count) {</span>
  <span class="s2">if </span><span class="s0">(count === </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">state.result += </span><span class="s3">' '</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(count &gt; </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">, count - </span><span class="s4">1</span><span class="s0">);</span>
  <span class="s0">}</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">readPlainScalar(state, nodeIndent, withinFlowCollection) {</span>
  <span class="s2">var </span><span class="s0">preceding,</span>
      <span class="s0">following,</span>
      <span class="s0">captureStart,</span>
      <span class="s0">captureEnd,</span>
      <span class="s0">hasPendingContent,</span>
      <span class="s0">_line,</span>
      <span class="s0">_lineStart,</span>
      <span class="s0">_lineIndent,</span>
      <span class="s0">_kind = state.kind,</span>
      <span class="s0">_result = state.result,</span>
      <span class="s0">ch;</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s0">(is_WS_OR_EOL(ch)      ||</span>
      <span class="s0">is_FLOW_INDICATOR(ch) ||</span>
      <span class="s0">ch === </span><span class="s4">0x23</span><span class="s1">/* # */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x26</span><span class="s1">/* &amp; */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x2A</span><span class="s1">/* * */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x21</span><span class="s1">/* ! */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x7C</span><span class="s1">/* | */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x3E</span><span class="s1">/* &gt; */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x27</span><span class="s1">/* ' */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x22</span><span class="s1">/* &quot; */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x25</span><span class="s1">/* % */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x40</span><span class="s1">/* @ */    </span><span class="s0">||</span>
      <span class="s0">ch === </span><span class="s4">0x60</span><span class="s1">/* ` */</span><span class="s0">) {</span>
    <span class="s2">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x3F</span><span class="s1">/* ? */ </span><span class="s0">|| ch === </span><span class="s4">0x2D</span><span class="s1">/* - */</span><span class="s0">) {</span>
    <span class="s0">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s0">);</span>

    <span class="s2">if </span><span class="s0">(is_WS_OR_EOL(following) ||</span>
        <span class="s0">withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {</span>
      <span class="s2">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">state.kind = </span><span class="s3">'scalar'</span><span class="s0">;</span>
  <span class="s0">state.result = </span><span class="s3">''</span><span class="s0">;</span>
  <span class="s0">captureStart = captureEnd = state.position;</span>
  <span class="s0">hasPendingContent = </span><span class="s2">false</span><span class="s0">;</span>

  <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x3A</span><span class="s1">/* : */</span><span class="s0">) {</span>
      <span class="s0">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s0">);</span>

      <span class="s2">if </span><span class="s0">(is_WS_OR_EOL(following) ||</span>
          <span class="s0">withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s0">}</span>

    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(ch === </span><span class="s4">0x23</span><span class="s1">/* # */</span><span class="s0">) {</span>
      <span class="s0">preceding = state.input.charCodeAt(state.position - </span><span class="s4">1</span><span class="s0">);</span>

      <span class="s2">if </span><span class="s0">(is_WS_OR_EOL(preceding)) {</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s0">}</span>

    <span class="s0">} </span><span class="s2">else if </span><span class="s0">((state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) ||</span>
               <span class="s0">withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(ch)) {</span>
      <span class="s2">break</span><span class="s0">;</span>

    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(is_EOL(ch)) {</span>
      <span class="s0">_line = state.line;</span>
      <span class="s0">_lineStart = state.lineStart;</span>
      <span class="s0">_lineIndent = state.lineIndent;</span>
      <span class="s0">skipSeparationSpace(state, </span><span class="s2">false</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>

      <span class="s2">if </span><span class="s0">(state.lineIndent &gt;= nodeIndent) {</span>
        <span class="s0">hasPendingContent = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s0">ch = state.input.charCodeAt(state.position);</span>
        <span class="s2">continue</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">state.position = captureEnd;</span>
        <span class="s0">state.line = _line;</span>
        <span class="s0">state.lineStart = _lineStart;</span>
        <span class="s0">state.lineIndent = _lineIndent;</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(hasPendingContent) {</span>
      <span class="s0">captureSegment(state, captureStart, captureEnd, </span><span class="s2">false</span><span class="s0">);</span>
      <span class="s0">writeFoldedLines(state, state.line - _line);</span>
      <span class="s0">captureStart = captureEnd = state.position;</span>
      <span class="s0">hasPendingContent = </span><span class="s2">false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(!is_WHITE_SPACE(ch)) {</span>
      <span class="s0">captureEnd = state.position + </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s0">}</span>

  <span class="s0">captureSegment(state, captureStart, captureEnd, </span><span class="s2">false</span><span class="s0">);</span>

  <span class="s2">if </span><span class="s0">(state.result) {</span>
    <span class="s2">return true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">state.kind = _kind;</span>
  <span class="s0">state.result = _result;</span>
  <span class="s2">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readSingleQuotedScalar(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s0">ch,</span>
      <span class="s0">captureStart, captureEnd;</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s0">(ch !== </span><span class="s4">0x27</span><span class="s1">/* ' */</span><span class="s0">) {</span>
    <span class="s2">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">state.kind = </span><span class="s3">'scalar'</span><span class="s0">;</span>
  <span class="s0">state.result = </span><span class="s3">''</span><span class="s0">;</span>
  <span class="s0">state.position++;</span>
  <span class="s0">captureStart = captureEnd = state.position;</span>

  <span class="s2">while </span><span class="s0">((ch = state.input.charCodeAt(state.position)) !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x27</span><span class="s1">/* ' */</span><span class="s0">) {</span>
      <span class="s0">captureSegment(state, captureStart, state.position, </span><span class="s2">true</span><span class="s0">);</span>
      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>

      <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x27</span><span class="s1">/* ' */</span><span class="s0">) {</span>
        <span class="s0">captureStart = state.position;</span>
        <span class="s0">state.position++;</span>
        <span class="s0">captureEnd = state.position;</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">return true</span><span class="s0">;</span>
      <span class="s0">}</span>

    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(is_EOL(ch)) {</span>
      <span class="s0">captureSegment(state, captureStart, captureEnd, </span><span class="s2">true</span><span class="s0">);</span>
      <span class="s0">writeFoldedLines(state, skipSeparationSpace(state, </span><span class="s2">false</span><span class="s0">, nodeIndent));</span>
      <span class="s0">captureStart = captureEnd = state.position;</span>

    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'unexpected end of the document within a single quoted scalar'</span><span class="s0">);</span>

    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">state.position++;</span>
      <span class="s0">captureEnd = state.position;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">throwError(state, </span><span class="s3">'unexpected end of the stream within a single quoted scalar'</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readDoubleQuotedScalar(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s0">captureStart,</span>
      <span class="s0">captureEnd,</span>
      <span class="s0">hexLength,</span>
      <span class="s0">hexResult,</span>
      <span class="s0">tmp,</span>
      <span class="s0">ch;</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s0">(ch !== </span><span class="s4">0x22</span><span class="s1">/* &quot; */</span><span class="s0">) {</span>
    <span class="s2">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">state.kind = </span><span class="s3">'scalar'</span><span class="s0">;</span>
  <span class="s0">state.result = </span><span class="s3">''</span><span class="s0">;</span>
  <span class="s0">state.position++;</span>
  <span class="s0">captureStart = captureEnd = state.position;</span>

  <span class="s2">while </span><span class="s0">((ch = state.input.charCodeAt(state.position)) !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x22</span><span class="s1">/* &quot; */</span><span class="s0">) {</span>
      <span class="s0">captureSegment(state, captureStart, state.position, </span><span class="s2">true</span><span class="s0">);</span>
      <span class="s0">state.position++;</span>
      <span class="s2">return true</span><span class="s0">;</span>

    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(ch === </span><span class="s4">0x5C</span><span class="s1">/* \ */</span><span class="s0">) {</span>
      <span class="s0">captureSegment(state, captureStart, state.position, </span><span class="s2">true</span><span class="s0">);</span>
      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>

      <span class="s2">if </span><span class="s0">(is_EOL(ch)) {</span>
        <span class="s0">skipSeparationSpace(state, </span><span class="s2">false</span><span class="s0">, nodeIndent);</span>

        <span class="s1">// TODO: rework to inline fn with no type cast?</span>
      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(ch &lt; </span><span class="s4">256 </span><span class="s0">&amp;&amp; simpleEscapeCheck[ch]) {</span>
        <span class="s0">state.result += simpleEscapeMap[ch];</span>
        <span class="s0">state.position++;</span>

      <span class="s0">} </span><span class="s2">else if </span><span class="s0">((tmp = escapedHexLen(ch)) &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">hexLength = tmp;</span>
        <span class="s0">hexResult = </span><span class="s4">0</span><span class="s0">;</span>

        <span class="s2">for </span><span class="s0">(; hexLength &gt; </span><span class="s4">0</span><span class="s0">; hexLength--) {</span>
          <span class="s0">ch = state.input.charCodeAt(++state.position);</span>

          <span class="s2">if </span><span class="s0">((tmp = fromHexCode(ch)) &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">hexResult = (hexResult &lt;&lt; </span><span class="s4">4</span><span class="s0">) + tmp;</span>

          <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s0">throwError(state, </span><span class="s3">'expected hexadecimal character'</span><span class="s0">);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s0">state.result += charFromCodepoint(hexResult);</span>

        <span class="s0">state.position++;</span>

      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">throwError(state, </span><span class="s3">'unknown escape sequence'</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s0">captureStart = captureEnd = state.position;</span>

    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(is_EOL(ch)) {</span>
      <span class="s0">captureSegment(state, captureStart, captureEnd, </span><span class="s2">true</span><span class="s0">);</span>
      <span class="s0">writeFoldedLines(state, skipSeparationSpace(state, </span><span class="s2">false</span><span class="s0">, nodeIndent));</span>
      <span class="s0">captureStart = captureEnd = state.position;</span>

    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'unexpected end of the document within a double quoted scalar'</span><span class="s0">);</span>

    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">state.position++;</span>
      <span class="s0">captureEnd = state.position;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">throwError(state, </span><span class="s3">'unexpected end of the stream within a double quoted scalar'</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readFlowCollection(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s0">readNext = </span><span class="s2">true</span><span class="s0">,</span>
      <span class="s0">_line,</span>
      <span class="s0">_lineStart,</span>
      <span class="s0">_pos,</span>
      <span class="s0">_tag     = state.tag,</span>
      <span class="s0">_result,</span>
      <span class="s0">_anchor  = state.anchor,</span>
      <span class="s0">following,</span>
      <span class="s0">terminator,</span>
      <span class="s0">isPair,</span>
      <span class="s0">isExplicitPair,</span>
      <span class="s0">isMapping,</span>
      <span class="s0">overridableKeys = Object.create(</span><span class="s2">null</span><span class="s0">),</span>
      <span class="s0">keyNode,</span>
      <span class="s0">keyTag,</span>
      <span class="s0">valueNode,</span>
      <span class="s0">ch;</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x5B</span><span class="s1">/* [ */</span><span class="s0">) {</span>
    <span class="s0">terminator = </span><span class="s4">0x5D</span><span class="s0">;</span><span class="s1">/* ] */</span>
    <span class="s0">isMapping = </span><span class="s2">false</span><span class="s0">;</span>
    <span class="s0">_result = [];</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(ch === </span><span class="s4">0x7B</span><span class="s1">/* { */</span><span class="s0">) {</span>
    <span class="s0">terminator = </span><span class="s4">0x7D</span><span class="s0">;</span><span class="s1">/* } */</span>
    <span class="s0">isMapping = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">_result = {};</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s2">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(state.anchor !== </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s0">state.anchorMap[state.anchor] = _result;</span>
  <span class="s0">}</span>

  <span class="s0">ch = state.input.charCodeAt(++state.position);</span>

  <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, nodeIndent);</span>

    <span class="s0">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s0">(ch === terminator) {</span>
      <span class="s0">state.position++;</span>
      <span class="s0">state.tag = _tag;</span>
      <span class="s0">state.anchor = _anchor;</span>
      <span class="s0">state.kind = isMapping ? </span><span class="s3">'mapping' </span><span class="s0">: </span><span class="s3">'sequence'</span><span class="s0">;</span>
      <span class="s0">state.result = _result;</span>
      <span class="s2">return true</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(!readNext) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'missed comma between flow collection entries'</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(ch === </span><span class="s4">0x2C</span><span class="s1">/* , */</span><span class="s0">) {</span>
      <span class="s1">// &quot;flow collection entries can never be completely empty&quot;, as per YAML 1.2, section 7.4</span>
      <span class="s0">throwError(state, </span><span class="s3">&quot;expected the node content, but found ','&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">keyTag = keyNode = valueNode = </span><span class="s2">null</span><span class="s0">;</span>
    <span class="s0">isPair = isExplicitPair = </span><span class="s2">false</span><span class="s0">;</span>

    <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x3F</span><span class="s1">/* ? */</span><span class="s0">) {</span>
      <span class="s0">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s0">);</span>

      <span class="s2">if </span><span class="s0">(is_WS_OR_EOL(following)) {</span>
        <span class="s0">isPair = isExplicitPair = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s0">state.position++;</span>
        <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, nodeIndent);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">_line = state.line; </span><span class="s1">// Save the current line.</span>
    <span class="s0">_lineStart = state.lineStart;</span>
    <span class="s0">_pos = state.position;</span>
    <span class="s0">composeNode(state, nodeIndent, CONTEXT_FLOW_IN, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">true</span><span class="s0">);</span>
    <span class="s0">keyTag = state.tag;</span>
    <span class="s0">keyNode = state.result;</span>
    <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, nodeIndent);</span>

    <span class="s0">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s0">((isExplicitPair || state.line === _line) &amp;&amp; ch === </span><span class="s4">0x3A</span><span class="s1">/* : */</span><span class="s0">) {</span>
      <span class="s0">isPair = </span><span class="s2">true</span><span class="s0">;</span>
      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, nodeIndent);</span>
      <span class="s0">composeNode(state, nodeIndent, CONTEXT_FLOW_IN, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">true</span><span class="s0">);</span>
      <span class="s0">valueNode = state.result;</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(isMapping) {</span>
      <span class="s0">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(isPair) {</span>
      <span class="s0">_result.push(storeMappingPair(state, </span><span class="s2">null</span><span class="s0">, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">_result.push(keyNode);</span>
    <span class="s0">}</span>

    <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, nodeIndent);</span>

    <span class="s0">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x2C</span><span class="s1">/* , */</span><span class="s0">) {</span>
      <span class="s0">readNext = </span><span class="s2">true</span><span class="s0">;</span>
      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">readNext = </span><span class="s2">false</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">throwError(state, </span><span class="s3">'unexpected end of the stream within a flow collection'</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readBlockScalar(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s0">captureStart,</span>
      <span class="s0">folding,</span>
      <span class="s0">chomping       = CHOMPING_CLIP,</span>
      <span class="s0">didReadContent = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">detectedIndent = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">textIndent     = nodeIndent,</span>
      <span class="s0">emptyLines     = </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">atMoreIndented = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">tmp,</span>
      <span class="s0">ch;</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x7C</span><span class="s1">/* | */</span><span class="s0">) {</span>
    <span class="s0">folding = </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(ch === </span><span class="s4">0x3E</span><span class="s1">/* &gt; */</span><span class="s0">) {</span>
    <span class="s0">folding = </span><span class="s2">true</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s2">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">state.kind = </span><span class="s3">'scalar'</span><span class="s0">;</span>
  <span class="s0">state.result = </span><span class="s3">''</span><span class="s0">;</span>

  <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">ch = state.input.charCodeAt(++state.position);</span>

    <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x2B</span><span class="s1">/* + */ </span><span class="s0">|| ch === </span><span class="s4">0x2D</span><span class="s1">/* - */</span><span class="s0">) {</span>
      <span class="s2">if </span><span class="s0">(CHOMPING_CLIP === chomping) {</span>
        <span class="s0">chomping = (ch === </span><span class="s4">0x2B</span><span class="s1">/* + */</span><span class="s0">) ? CHOMPING_KEEP : CHOMPING_STRIP;</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">throwError(state, </span><span class="s3">'repeat of a chomping mode identifier'</span><span class="s0">);</span>
      <span class="s0">}</span>

    <span class="s0">} </span><span class="s2">else if </span><span class="s0">((tmp = fromDecimalCode(ch)) &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s2">if </span><span class="s0">(tmp === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">throwError(state, </span><span class="s3">'bad explicit indentation width of a block scalar; it cannot be less than one'</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(!detectedIndent) {</span>
        <span class="s0">textIndent = nodeIndent + tmp - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">detectedIndent = </span><span class="s2">true</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">throwError(state, </span><span class="s3">'repeat of an indentation width identifier'</span><span class="s0">);</span>
      <span class="s0">}</span>

    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s2">break</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(is_WHITE_SPACE(ch)) {</span>
    <span class="s2">do </span><span class="s0">{ ch = state.input.charCodeAt(++state.position); }</span>
    <span class="s2">while </span><span class="s0">(is_WHITE_SPACE(ch));</span>

    <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x23</span><span class="s1">/* # */</span><span class="s0">) {</span>
      <span class="s2">do </span><span class="s0">{ ch = state.input.charCodeAt(++state.position); }</span>
      <span class="s2">while </span><span class="s0">(!is_EOL(ch) &amp;&amp; (ch !== </span><span class="s4">0</span><span class="s0">));</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">readLineBreak(state);</span>
    <span class="s0">state.lineIndent = </span><span class="s4">0</span><span class="s0">;</span>

    <span class="s0">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">while </span><span class="s0">((!detectedIndent || state.lineIndent &lt; textIndent) &amp;&amp;</span>
           <span class="s0">(ch === </span><span class="s4">0x20</span><span class="s1">/* Space */</span><span class="s0">)) {</span>
      <span class="s0">state.lineIndent++;</span>
      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(!detectedIndent &amp;&amp; state.lineIndent &gt; textIndent) {</span>
      <span class="s0">textIndent = state.lineIndent;</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(is_EOL(ch)) {</span>
      <span class="s0">emptyLines++;</span>
      <span class="s2">continue</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">// End of the scalar.</span>
    <span class="s2">if </span><span class="s0">(state.lineIndent &lt; textIndent) {</span>

      <span class="s1">// Perform the chomping.</span>
      <span class="s2">if </span><span class="s0">(chomping === CHOMPING_KEEP) {</span>
        <span class="s0">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">, didReadContent ? </span><span class="s4">1 </span><span class="s0">+ emptyLines : emptyLines);</span>
      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(chomping === CHOMPING_CLIP) {</span>
        <span class="s2">if </span><span class="s0">(didReadContent) { </span><span class="s1">// i.e. only if the scalar is not empty.</span>
          <span class="s0">state.result += </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">// Break this `while` cycle and go to the funciton's epilogue.</span>
      <span class="s2">break</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">// Folded style: use fancy rules to handle line breaks.</span>
    <span class="s2">if </span><span class="s0">(folding) {</span>

      <span class="s1">// Lines starting with white space characters (more-indented lines) are not folded.</span>
      <span class="s2">if </span><span class="s0">(is_WHITE_SPACE(ch)) {</span>
        <span class="s0">atMoreIndented = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s1">// except for the first content line (cf. Example 8.1)</span>
        <span class="s0">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">, didReadContent ? </span><span class="s4">1 </span><span class="s0">+ emptyLines : emptyLines);</span>

      <span class="s1">// End of more-indented block.</span>
      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(atMoreIndented) {</span>
        <span class="s0">atMoreIndented = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s0">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">, emptyLines + </span><span class="s4">1</span><span class="s0">);</span>

      <span class="s1">// Just one line break - perceive as the same line.</span>
      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(emptyLines === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s2">if </span><span class="s0">(didReadContent) { </span><span class="s1">// i.e. only if we have already read some scalar content.</span>
          <span class="s0">state.result += </span><span class="s3">' '</span><span class="s0">;</span>
        <span class="s0">}</span>

      <span class="s1">// Several line breaks - perceive as different lines.</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">, emptyLines);</span>
      <span class="s0">}</span>

    <span class="s1">// Literal style: just add exact number of line breaks between content lines.</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s1">// Keep all line breaks except the header line break.</span>
      <span class="s0">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">, didReadContent ? </span><span class="s4">1 </span><span class="s0">+ emptyLines : emptyLines);</span>
    <span class="s0">}</span>

    <span class="s0">didReadContent = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">detectedIndent = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">emptyLines = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">captureStart = state.position;</span>

    <span class="s2">while </span><span class="s0">(!is_EOL(ch) &amp;&amp; (ch !== </span><span class="s4">0</span><span class="s0">)) {</span>
      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s0">}</span>

    <span class="s0">captureSegment(state, captureStart, state.position, </span><span class="s2">false</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readBlockSequence(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s0">_line,</span>
      <span class="s0">_tag      = state.tag,</span>
      <span class="s0">_anchor   = state.anchor,</span>
      <span class="s0">_result   = [],</span>
      <span class="s0">following,</span>
      <span class="s0">detected  = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">ch;</span>

  <span class="s1">// there is a leading tab before this token, so it can't be a block sequence/mapping;</span>
  <span class="s1">// it can still be flow sequence/mapping or a scalar</span>
  <span class="s2">if </span><span class="s0">(state.firstTabInLine !== -</span><span class="s4">1</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(state.anchor !== </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s0">state.anchorMap[state.anchor] = _result;</span>
  <span class="s0">}</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(state.firstTabInLine !== -</span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">state.position = state.firstTabInLine;</span>
      <span class="s0">throwError(state, </span><span class="s3">'tab characters must not be used in indentation'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(ch !== </span><span class="s4">0x2D</span><span class="s1">/* - */</span><span class="s0">) {</span>
      <span class="s2">break</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s0">);</span>

    <span class="s2">if </span><span class="s0">(!is_WS_OR_EOL(following)) {</span>
      <span class="s2">break</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">detected = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">state.position++;</span>

    <span class="s2">if </span><span class="s0">(skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">)) {</span>
      <span class="s2">if </span><span class="s0">(state.lineIndent &lt;= nodeIndent) {</span>
        <span class="s0">_result.push(</span><span class="s2">null</span><span class="s0">);</span>
        <span class="s0">ch = state.input.charCodeAt(state.position);</span>
        <span class="s2">continue</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">_line = state.line;</span>
    <span class="s0">composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">true</span><span class="s0">);</span>
    <span class="s0">_result.push(state.result);</span>
    <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>

    <span class="s0">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s0">((state.line === _line || state.lineIndent &gt; nodeIndent) &amp;&amp; (ch !== </span><span class="s4">0</span><span class="s0">)) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'bad indentation of a sequence entry'</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.lineIndent &lt; nodeIndent) {</span>
      <span class="s2">break</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(detected) {</span>
    <span class="s0">state.tag = _tag;</span>
    <span class="s0">state.anchor = _anchor;</span>
    <span class="s0">state.kind = </span><span class="s3">'sequence'</span><span class="s0">;</span>
    <span class="s0">state.result = _result;</span>
    <span class="s2">return true</span><span class="s0">;</span>
  <span class="s0">}</span>
  <span class="s2">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readBlockMapping(state, nodeIndent, flowIndent) {</span>
  <span class="s2">var </span><span class="s0">following,</span>
      <span class="s0">allowCompact,</span>
      <span class="s0">_line,</span>
      <span class="s0">_keyLine,</span>
      <span class="s0">_keyLineStart,</span>
      <span class="s0">_keyPos,</span>
      <span class="s0">_tag          = state.tag,</span>
      <span class="s0">_anchor       = state.anchor,</span>
      <span class="s0">_result       = {},</span>
      <span class="s0">overridableKeys = Object.create(</span><span class="s2">null</span><span class="s0">),</span>
      <span class="s0">keyTag        = </span><span class="s2">null</span><span class="s0">,</span>
      <span class="s0">keyNode       = </span><span class="s2">null</span><span class="s0">,</span>
      <span class="s0">valueNode     = </span><span class="s2">null</span><span class="s0">,</span>
      <span class="s0">atExplicitKey = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">detected      = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">ch;</span>

  <span class="s1">// there is a leading tab before this token, so it can't be a block sequence/mapping;</span>
  <span class="s1">// it can still be flow sequence/mapping or a scalar</span>
  <span class="s2">if </span><span class="s0">(state.firstTabInLine !== -</span><span class="s4">1</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(state.anchor !== </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s0">state.anchorMap[state.anchor] = _result;</span>
  <span class="s0">}</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(!atExplicitKey &amp;&amp; state.firstTabInLine !== -</span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">state.position = state.firstTabInLine;</span>
      <span class="s0">throwError(state, </span><span class="s3">'tab characters must not be used in indentation'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">_line = state.line; </span><span class="s1">// Save the current line.</span>

    <span class="s1">//</span>
    <span class="s1">// Explicit notation case. There are two separate blocks:</span>
    <span class="s1">// first for the key (denoted by &quot;?&quot;) and second for the value (denoted by &quot;:&quot;)</span>
    <span class="s1">//</span>
    <span class="s2">if </span><span class="s0">((ch === </span><span class="s4">0x3F</span><span class="s1">/* ? */ </span><span class="s0">|| ch === </span><span class="s4">0x3A</span><span class="s1">/* : */</span><span class="s0">) &amp;&amp; is_WS_OR_EOL(following)) {</span>

      <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x3F</span><span class="s1">/* ? */</span><span class="s0">) {</span>
        <span class="s2">if </span><span class="s0">(atExplicitKey) {</span>
          <span class="s0">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, </span><span class="s2">null</span><span class="s0">, _keyLine, _keyLineStart, _keyPos);</span>
          <span class="s0">keyTag = keyNode = valueNode = </span><span class="s2">null</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s0">detected = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s0">atExplicitKey = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s0">allowCompact = </span><span class="s2">true</span><span class="s0">;</span>

      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(atExplicitKey) {</span>
        <span class="s1">// i.e. 0x3A/* : */ === character after the explicit key.</span>
        <span class="s0">atExplicitKey = </span><span class="s2">false</span><span class="s0">;</span>
        <span class="s0">allowCompact = </span><span class="s2">true</span><span class="s0">;</span>

      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">throwError(state, </span><span class="s3">'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line'</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s0">state.position += </span><span class="s4">1</span><span class="s0">;</span>
      <span class="s0">ch = following;</span>

    <span class="s1">//</span>
    <span class="s1">// Implicit notation case. Flow-style node as the key first, then &quot;:&quot;, and the value.</span>
    <span class="s1">//</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">_keyLine = state.line;</span>
      <span class="s0">_keyLineStart = state.lineStart;</span>
      <span class="s0">_keyPos = state.position;</span>

      <span class="s2">if </span><span class="s0">(!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">true</span><span class="s0">)) {</span>
        <span class="s1">// Neither implicit nor explicit notation.</span>
        <span class="s1">// Reading is done. Go to the epilogue.</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">if </span><span class="s0">(state.line === _line) {</span>
        <span class="s0">ch = state.input.charCodeAt(state.position);</span>

        <span class="s2">while </span><span class="s0">(is_WHITE_SPACE(ch)) {</span>
          <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
        <span class="s0">}</span>

        <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x3A</span><span class="s1">/* : */</span><span class="s0">) {</span>
          <span class="s0">ch = state.input.charCodeAt(++state.position);</span>

          <span class="s2">if </span><span class="s0">(!is_WS_OR_EOL(ch)) {</span>
            <span class="s0">throwError(state, </span><span class="s3">'a whitespace character is expected after the key-value separator within a block mapping'</span><span class="s0">);</span>
          <span class="s0">}</span>

          <span class="s2">if </span><span class="s0">(atExplicitKey) {</span>
            <span class="s0">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, </span><span class="s2">null</span><span class="s0">, _keyLine, _keyLineStart, _keyPos);</span>
            <span class="s0">keyTag = keyNode = valueNode = </span><span class="s2">null</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s0">detected = </span><span class="s2">true</span><span class="s0">;</span>
          <span class="s0">atExplicitKey = </span><span class="s2">false</span><span class="s0">;</span>
          <span class="s0">allowCompact = </span><span class="s2">false</span><span class="s0">;</span>
          <span class="s0">keyTag = state.tag;</span>
          <span class="s0">keyNode = state.result;</span>

        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(detected) {</span>
          <span class="s0">throwError(state, </span><span class="s3">'can not read an implicit mapping pair; a colon is missed'</span><span class="s0">);</span>

        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
          <span class="s0">state.tag = _tag;</span>
          <span class="s0">state.anchor = _anchor;</span>
          <span class="s2">return true</span><span class="s0">; </span><span class="s1">// Keep the result of `composeNode`.</span>
        <span class="s0">}</span>

      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(detected) {</span>
        <span class="s0">throwError(state, </span><span class="s3">'can not read a block mapping entry; a multiline key may not be an implicit key'</span><span class="s0">);</span>

      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">state.tag = _tag;</span>
        <span class="s0">state.anchor = _anchor;</span>
        <span class="s2">return true</span><span class="s0">; </span><span class="s1">// Keep the result of `composeNode`.</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">//</span>
    <span class="s1">// Common reading code for both explicit and implicit notations.</span>
    <span class="s1">//</span>
    <span class="s2">if </span><span class="s0">(state.line === _line || state.lineIndent &gt; nodeIndent) {</span>
      <span class="s2">if </span><span class="s0">(atExplicitKey) {</span>
        <span class="s0">_keyLine = state.line;</span>
        <span class="s0">_keyLineStart = state.lineStart;</span>
        <span class="s0">_keyPos = state.position;</span>
      <span class="s0">}</span>

      <span class="s2">if </span><span class="s0">(composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, </span><span class="s2">true</span><span class="s0">, allowCompact)) {</span>
        <span class="s2">if </span><span class="s0">(atExplicitKey) {</span>
          <span class="s0">keyNode = state.result;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
          <span class="s0">valueNode = state.result;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">if </span><span class="s0">(!atExplicitKey) {</span>
        <span class="s0">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);</span>
        <span class="s0">keyTag = keyNode = valueNode = </span><span class="s2">null</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>
      <span class="s0">ch = state.input.charCodeAt(state.position);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">((state.line === _line || state.lineIndent &gt; nodeIndent) &amp;&amp; (ch !== </span><span class="s4">0</span><span class="s0">)) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'bad indentation of a mapping entry'</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.lineIndent &lt; nodeIndent) {</span>
      <span class="s2">break</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">//</span>
  <span class="s1">// Epilogue.</span>
  <span class="s1">//</span>

  <span class="s1">// Special case: last mapping's node contains only the key in explicit notation.</span>
  <span class="s2">if </span><span class="s0">(atExplicitKey) {</span>
    <span class="s0">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, </span><span class="s2">null</span><span class="s0">, _keyLine, _keyLineStart, _keyPos);</span>
  <span class="s0">}</span>

  <span class="s1">// Expose the resulting mapping.</span>
  <span class="s2">if </span><span class="s0">(detected) {</span>
    <span class="s0">state.tag = _tag;</span>
    <span class="s0">state.anchor = _anchor;</span>
    <span class="s0">state.kind = </span><span class="s3">'mapping'</span><span class="s0">;</span>
    <span class="s0">state.result = _result;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">detected;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readTagProperty(state) {</span>
  <span class="s2">var </span><span class="s0">_position,</span>
      <span class="s0">isVerbatim = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">isNamed    = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">tagHandle,</span>
      <span class="s0">tagName,</span>
      <span class="s0">ch;</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s0">(ch !== </span><span class="s4">0x21</span><span class="s1">/* ! */</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(state.tag !== </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'duplication of a tag property'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">ch = state.input.charCodeAt(++state.position);</span>

  <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x3C</span><span class="s1">/* &lt; */</span><span class="s0">) {</span>
    <span class="s0">isVerbatim = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">ch = state.input.charCodeAt(++state.position);</span>

  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(ch === </span><span class="s4">0x21</span><span class="s1">/* ! */</span><span class="s0">) {</span>
    <span class="s0">isNamed = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">tagHandle = </span><span class="s3">'!!'</span><span class="s0">;</span>
    <span class="s0">ch = state.input.charCodeAt(++state.position);</span>

  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s0">tagHandle = </span><span class="s3">'!'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">_position = state.position;</span>

  <span class="s2">if </span><span class="s0">(isVerbatim) {</span>
    <span class="s2">do </span><span class="s0">{ ch = state.input.charCodeAt(++state.position); }</span>
    <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; ch !== </span><span class="s4">0x3E</span><span class="s1">/* &gt; */</span><span class="s0">);</span>

    <span class="s2">if </span><span class="s0">(state.position &lt; state.length) {</span>
      <span class="s0">tagName = state.input.slice(_position, state.position);</span>
      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">throwError(state, </span><span class="s3">'unexpected end of the stream within a verbatim tag'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; !is_WS_OR_EOL(ch)) {</span>

      <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x21</span><span class="s1">/* ! */</span><span class="s0">) {</span>
        <span class="s2">if </span><span class="s0">(!isNamed) {</span>
          <span class="s0">tagHandle = state.input.slice(_position - </span><span class="s4">1</span><span class="s0">, state.position + </span><span class="s4">1</span><span class="s0">);</span>

          <span class="s2">if </span><span class="s0">(!PATTERN_TAG_HANDLE.test(tagHandle)) {</span>
            <span class="s0">throwError(state, </span><span class="s3">'named tag handle cannot contain such characters'</span><span class="s0">);</span>
          <span class="s0">}</span>

          <span class="s0">isNamed = </span><span class="s2">true</span><span class="s0">;</span>
          <span class="s0">_position = state.position + </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
          <span class="s0">throwError(state, </span><span class="s3">'tag suffix cannot contain exclamation marks'</span><span class="s0">);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s0">}</span>

    <span class="s0">tagName = state.input.slice(_position, state.position);</span>

    <span class="s2">if </span><span class="s0">(PATTERN_FLOW_INDICATORS.test(tagName)) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'tag suffix cannot contain flow indicator characters'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(tagName &amp;&amp; !PATTERN_TAG_URI.test(tagName)) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'tag name cannot contain such characters: ' </span><span class="s0">+ tagName);</span>
  <span class="s0">}</span>

  <span class="s2">try </span><span class="s0">{</span>
    <span class="s0">tagName = decodeURIComponent(tagName);</span>
  <span class="s0">} </span><span class="s2">catch </span><span class="s0">(err) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'tag name is malformed: ' </span><span class="s0">+ tagName);</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(isVerbatim) {</span>
    <span class="s0">state.tag = tagName;</span>

  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(_hasOwnProperty$1.call(state.tagMap, tagHandle)) {</span>
    <span class="s0">state.tag = state.tagMap[tagHandle] + tagName;</span>

  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(tagHandle === </span><span class="s3">'!'</span><span class="s0">) {</span>
    <span class="s0">state.tag = </span><span class="s3">'!' </span><span class="s0">+ tagName;</span>

  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(tagHandle === </span><span class="s3">'!!'</span><span class="s0">) {</span>
    <span class="s0">state.tag = </span><span class="s3">'tag:yaml.org,2002:' </span><span class="s0">+ tagName;</span>

  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s0">throwError(state, </span><span class="s3">'undeclared tag handle &quot;' </span><span class="s0">+ tagHandle + </span><span class="s3">'&quot;'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readAnchorProperty(state) {</span>
  <span class="s2">var </span><span class="s0">_position,</span>
      <span class="s0">ch;</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s0">(ch !== </span><span class="s4">0x26</span><span class="s1">/* &amp; */</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s2">if </span><span class="s0">(state.anchor !== </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'duplication of an anchor property'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s0">_position = state.position;</span>

  <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {</span>
    <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(state.position === _position) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'name of an anchor node must contain at least one character'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">state.anchor = state.input.slice(_position, state.position);</span>
  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readAlias(state) {</span>
  <span class="s2">var </span><span class="s0">_position, alias,</span>
      <span class="s0">ch;</span>

  <span class="s0">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s0">(ch !== </span><span class="s4">0x2A</span><span class="s1">/* * */</span><span class="s0">) </span><span class="s2">return false</span><span class="s0">;</span>

  <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s0">_position = state.position;</span>

  <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {</span>
    <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(state.position === _position) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'name of an alias node must contain at least one character'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">alias = state.input.slice(_position, state.position);</span>

  <span class="s2">if </span><span class="s0">(!_hasOwnProperty$1.call(state.anchorMap, alias)) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'unidentified alias &quot;' </span><span class="s0">+ alias + </span><span class="s3">'&quot;'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">state.result = state.anchorMap[alias];</span>
  <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>
  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {</span>
  <span class="s2">var </span><span class="s0">allowBlockStyles,</span>
      <span class="s0">allowBlockScalars,</span>
      <span class="s0">allowBlockCollections,</span>
      <span class="s0">indentStatus = </span><span class="s4">1</span><span class="s0">, </span><span class="s1">// 1: this&gt;parent, 0: this=parent, -1: this&lt;parent</span>
      <span class="s0">atNewLine  = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">hasContent = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">typeIndex,</span>
      <span class="s0">typeQuantity,</span>
      <span class="s0">typeList,</span>
      <span class="s0">type,</span>
      <span class="s0">flowIndent,</span>
      <span class="s0">blockIndent;</span>

  <span class="s2">if </span><span class="s0">(state.listener !== </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s0">state.listener(</span><span class="s3">'open'</span><span class="s0">, state);</span>
  <span class="s0">}</span>

  <span class="s0">state.tag    = </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s0">state.anchor = </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s0">state.kind   = </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s0">state.result = </span><span class="s2">null</span><span class="s0">;</span>

  <span class="s0">allowBlockStyles = allowBlockScalars = allowBlockCollections =</span>
    <span class="s0">CONTEXT_BLOCK_OUT === nodeContext ||</span>
    <span class="s0">CONTEXT_BLOCK_IN  === nodeContext;</span>

  <span class="s2">if </span><span class="s0">(allowToSeek) {</span>
    <span class="s2">if </span><span class="s0">(skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">)) {</span>
      <span class="s0">atNewLine = </span><span class="s2">true</span><span class="s0">;</span>

      <span class="s2">if </span><span class="s0">(state.lineIndent &gt; parentIndent) {</span>
        <span class="s0">indentStatus = </span><span class="s4">1</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.lineIndent === parentIndent) {</span>
        <span class="s0">indentStatus = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.lineIndent &lt; parentIndent) {</span>
        <span class="s0">indentStatus = -</span><span class="s4">1</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(indentStatus === </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s2">while </span><span class="s0">(readTagProperty(state) || readAnchorProperty(state)) {</span>
      <span class="s2">if </span><span class="s0">(skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">)) {</span>
        <span class="s0">atNewLine = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s0">allowBlockCollections = allowBlockStyles;</span>

        <span class="s2">if </span><span class="s0">(state.lineIndent &gt; parentIndent) {</span>
          <span class="s0">indentStatus = </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.lineIndent === parentIndent) {</span>
          <span class="s0">indentStatus = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.lineIndent &lt; parentIndent) {</span>
          <span class="s0">indentStatus = -</span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">allowBlockCollections = </span><span class="s2">false</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(allowBlockCollections) {</span>
    <span class="s0">allowBlockCollections = atNewLine || allowCompact;</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(indentStatus === </span><span class="s4">1 </span><span class="s0">|| CONTEXT_BLOCK_OUT === nodeContext) {</span>
    <span class="s2">if </span><span class="s0">(CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {</span>
      <span class="s0">flowIndent = parentIndent;</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">flowIndent = parentIndent + </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">blockIndent = state.position - state.lineStart;</span>

    <span class="s2">if </span><span class="s0">(indentStatus === </span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s2">if </span><span class="s0">(allowBlockCollections &amp;&amp;</span>
          <span class="s0">(readBlockSequence(state, blockIndent) ||</span>
           <span class="s0">readBlockMapping(state, blockIndent, flowIndent)) ||</span>
          <span class="s0">readFlowCollection(state, flowIndent)) {</span>
        <span class="s0">hasContent = </span><span class="s2">true</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">if </span><span class="s0">((allowBlockScalars &amp;&amp; readBlockScalar(state, flowIndent)) ||</span>
            <span class="s0">readSingleQuotedScalar(state, flowIndent) ||</span>
            <span class="s0">readDoubleQuotedScalar(state, flowIndent)) {</span>
          <span class="s0">hasContent = </span><span class="s2">true</span><span class="s0">;</span>

        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(readAlias(state)) {</span>
          <span class="s0">hasContent = </span><span class="s2">true</span><span class="s0">;</span>

          <span class="s2">if </span><span class="s0">(state.tag !== </span><span class="s2">null </span><span class="s0">|| state.anchor !== </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">throwError(state, </span><span class="s3">'alias node should not have any properties'</span><span class="s0">);</span>
          <span class="s0">}</span>

        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {</span>
          <span class="s0">hasContent = </span><span class="s2">true</span><span class="s0">;</span>

          <span class="s2">if </span><span class="s0">(state.tag === </span><span class="s2">null</span><span class="s0">) {</span>
            <span class="s0">state.tag = </span><span class="s3">'?'</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s2">if </span><span class="s0">(state.anchor !== </span><span class="s2">null</span><span class="s0">) {</span>
          <span class="s0">state.anchorMap[state.anchor] = state.result;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(indentStatus === </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s1">// Special case: block sequences are allowed to have same indentation level as the parent.</span>
      <span class="s1">// http://www.yaml.org/spec/1.2/spec.html#id2799784</span>
      <span class="s0">hasContent = allowBlockCollections &amp;&amp; readBlockSequence(state, blockIndent);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(state.tag === </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(state.anchor !== </span><span class="s2">null</span><span class="s0">) {</span>
      <span class="s0">state.anchorMap[state.anchor] = state.result;</span>
    <span class="s0">}</span>

  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.tag === </span><span class="s3">'?'</span><span class="s0">) {</span>
    <span class="s1">// Implicit resolving is not allowed for non-scalar types, and '?'</span>
    <span class="s1">// non-specific tag is only automatically assigned to plain scalars.</span>
    <span class="s1">//</span>
    <span class="s1">// We only need to check kind conformity in case user explicitly assigns '?'</span>
    <span class="s1">// tag, for example like this: &quot;!&lt;?&gt; [0]&quot;</span>
    <span class="s1">//</span>
    <span class="s2">if </span><span class="s0">(state.result !== </span><span class="s2">null </span><span class="s0">&amp;&amp; state.kind !== </span><span class="s3">'scalar'</span><span class="s0">) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'unacceptable node kind for !&lt;?&gt; tag; it should be &quot;scalar&quot;, not &quot;' </span><span class="s0">+ state.kind + </span><span class="s3">'&quot;'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">for </span><span class="s0">(typeIndex = </span><span class="s4">0</span><span class="s0">, typeQuantity = state.implicitTypes.length; typeIndex &lt; typeQuantity; typeIndex += </span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">type = state.implicitTypes[typeIndex];</span>

      <span class="s2">if </span><span class="s0">(type.resolve(state.result)) { </span><span class="s1">// `state.result` updated in resolver if matched</span>
        <span class="s0">state.result = type.construct(state.result);</span>
        <span class="s0">state.tag = type.tag;</span>
        <span class="s2">if </span><span class="s0">(state.anchor !== </span><span class="s2">null</span><span class="s0">) {</span>
          <span class="s0">state.anchorMap[state.anchor] = state.result;</span>
        <span class="s0">}</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.tag !== </span><span class="s3">'!'</span><span class="s0">) {</span>
    <span class="s2">if </span><span class="s0">(_hasOwnProperty$1.call(state.typeMap[state.kind || </span><span class="s3">'fallback'</span><span class="s0">], state.tag)) {</span>
      <span class="s0">type = state.typeMap[state.kind || </span><span class="s3">'fallback'</span><span class="s0">][state.tag];</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s1">// looking for multi type</span>
      <span class="s0">type = </span><span class="s2">null</span><span class="s0">;</span>
      <span class="s0">typeList = state.typeMap.multi[state.kind || </span><span class="s3">'fallback'</span><span class="s0">];</span>

      <span class="s2">for </span><span class="s0">(typeIndex = </span><span class="s4">0</span><span class="s0">, typeQuantity = typeList.length; typeIndex &lt; typeQuantity; typeIndex += </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s2">if </span><span class="s0">(state.tag.slice(</span><span class="s4">0</span><span class="s0">, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {</span>
          <span class="s0">type = typeList[typeIndex];</span>
          <span class="s2">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(!type) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'unknown tag !&lt;' </span><span class="s0">+ state.tag + </span><span class="s3">'&gt;'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(state.result !== </span><span class="s2">null </span><span class="s0">&amp;&amp; type.kind !== state.kind) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'unacceptable node kind for !&lt;' </span><span class="s0">+ state.tag + </span><span class="s3">'&gt; tag; it should be &quot;' </span><span class="s0">+ type.kind + </span><span class="s3">'&quot;, not &quot;' </span><span class="s0">+ state.kind + </span><span class="s3">'&quot;'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(!type.resolve(state.result, state.tag)) { </span><span class="s1">// `state.result` updated in resolver if matched</span>
      <span class="s0">throwError(state, </span><span class="s3">'cannot resolve a node with !&lt;' </span><span class="s0">+ state.tag + </span><span class="s3">'&gt; explicit tag'</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">state.result = type.construct(state.result, state.tag);</span>
      <span class="s2">if </span><span class="s0">(state.anchor !== </span><span class="s2">null</span><span class="s0">) {</span>
        <span class="s0">state.anchorMap[state.anchor] = state.result;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(state.listener !== </span><span class="s2">null</span><span class="s0">) {</span>
    <span class="s0">state.listener(</span><span class="s3">'close'</span><span class="s0">, state);</span>
  <span class="s0">}</span>
  <span class="s2">return </span><span class="s0">state.tag !== </span><span class="s2">null </span><span class="s0">||  state.anchor !== </span><span class="s2">null </span><span class="s0">|| hasContent;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">readDocument(state) {</span>
  <span class="s2">var </span><span class="s0">documentStart = state.position,</span>
      <span class="s0">_position,</span>
      <span class="s0">directiveName,</span>
      <span class="s0">directiveArgs,</span>
      <span class="s0">hasDirectives = </span><span class="s2">false</span><span class="s0">,</span>
      <span class="s0">ch;</span>

  <span class="s0">state.version = </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s0">state.checkLineBreaks = state.legacy;</span>
  <span class="s0">state.tagMap = Object.create(</span><span class="s2">null</span><span class="s0">);</span>
  <span class="s0">state.anchorMap = Object.create(</span><span class="s2">null</span><span class="s0">);</span>

  <span class="s2">while </span><span class="s0">((ch = state.input.charCodeAt(state.position)) !== </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>

    <span class="s0">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s0">(state.lineIndent &gt; </span><span class="s4">0 </span><span class="s0">|| ch !== </span><span class="s4">0x25</span><span class="s1">/* % */</span><span class="s0">) {</span>
      <span class="s2">break</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">hasDirectives = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s0">_position = state.position;</span>

    <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; !is_WS_OR_EOL(ch)) {</span>
      <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s0">}</span>

    <span class="s0">directiveName = state.input.slice(_position, state.position);</span>
    <span class="s0">directiveArgs = [];</span>

    <span class="s2">if </span><span class="s0">(directiveName.length &lt; </span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">throwError(state, </span><span class="s3">'directive name must not be less than one character in length'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s2">while </span><span class="s0">(is_WHITE_SPACE(ch)) {</span>
        <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s0">}</span>

      <span class="s2">if </span><span class="s0">(ch === </span><span class="s4">0x23</span><span class="s1">/* # */</span><span class="s0">) {</span>
        <span class="s2">do </span><span class="s0">{ ch = state.input.charCodeAt(++state.position); }</span>
        <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; !is_EOL(ch));</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">if </span><span class="s0">(is_EOL(ch)) </span><span class="s2">break</span><span class="s0">;</span>

      <span class="s0">_position = state.position;</span>

      <span class="s2">while </span><span class="s0">(ch !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; !is_WS_OR_EOL(ch)) {</span>
        <span class="s0">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s0">}</span>

      <span class="s0">directiveArgs.push(state.input.slice(_position, state.position));</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(ch !== </span><span class="s4">0</span><span class="s0">) readLineBreak(state);</span>

    <span class="s2">if </span><span class="s0">(_hasOwnProperty$1.call(directiveHandlers, directiveName)) {</span>
      <span class="s0">directiveHandlers[directiveName](state, directiveName, directiveArgs);</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">throwWarning(state, </span><span class="s3">'unknown document directive &quot;' </span><span class="s0">+ directiveName + </span><span class="s3">'&quot;'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>

  <span class="s2">if </span><span class="s0">(state.lineIndent === </span><span class="s4">0 </span><span class="s0">&amp;&amp;</span>
      <span class="s0">state.input.charCodeAt(state.position)     === </span><span class="s4">0x2D</span><span class="s1">/* - */ </span><span class="s0">&amp;&amp;</span>
      <span class="s0">state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s0">) === </span><span class="s4">0x2D</span><span class="s1">/* - */ </span><span class="s0">&amp;&amp;</span>
      <span class="s0">state.input.charCodeAt(state.position + </span><span class="s4">2</span><span class="s0">) === </span><span class="s4">0x2D</span><span class="s1">/* - */</span><span class="s0">) {</span>
    <span class="s0">state.position += </span><span class="s4">3</span><span class="s0">;</span>
    <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>

  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(hasDirectives) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'directives end mark is expected'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">composeNode(state, state.lineIndent - </span><span class="s4">1</span><span class="s0">, CONTEXT_BLOCK_OUT, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">true</span><span class="s0">);</span>
  <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>

  <span class="s2">if </span><span class="s0">(state.checkLineBreaks &amp;&amp;</span>
      <span class="s0">PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {</span>
    <span class="s0">throwWarning(state, </span><span class="s3">'non-ASCII line breaks are interpreted as content'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">state.documents.push(state.result);</span>

  <span class="s2">if </span><span class="s0">(state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {</span>

    <span class="s2">if </span><span class="s0">(state.input.charCodeAt(state.position) === </span><span class="s4">0x2E</span><span class="s1">/* . */</span><span class="s0">) {</span>
      <span class="s0">state.position += </span><span class="s4">3</span><span class="s0">;</span>
      <span class="s0">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s2">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(state.position &lt; (state.length - </span><span class="s4">1</span><span class="s0">)) {</span>
    <span class="s0">throwError(state, </span><span class="s3">'end of the stream or a document separator is expected'</span><span class="s0">);</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s2">return</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">loadDocuments(input, options) {</span>
  <span class="s0">input = String(input);</span>
  <span class="s0">options = options || {};</span>

  <span class="s2">if </span><span class="s0">(input.length !== </span><span class="s4">0</span><span class="s0">) {</span>

    <span class="s1">// Add tailing `\n` if not exists</span>
    <span class="s2">if </span><span class="s0">(input.charCodeAt(input.length - </span><span class="s4">1</span><span class="s0">) !== </span><span class="s4">0x0A</span><span class="s1">/* LF */ </span><span class="s0">&amp;&amp;</span>
        <span class="s0">input.charCodeAt(input.length - </span><span class="s4">1</span><span class="s0">) !== </span><span class="s4">0x0D</span><span class="s1">/* CR */</span><span class="s0">) {</span>
      <span class="s0">input += </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">// Strip BOM</span>
    <span class="s2">if </span><span class="s0">(input.charCodeAt(</span><span class="s4">0</span><span class="s0">) === </span><span class="s4">0xFEFF</span><span class="s0">) {</span>
      <span class="s0">input = input.slice(</span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">var </span><span class="s0">state = </span><span class="s2">new </span><span class="s0">State$1(input, options);</span>

  <span class="s2">var </span><span class="s0">nullpos = input.indexOf(</span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s0">);</span>

  <span class="s2">if </span><span class="s0">(nullpos !== -</span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">state.position = nullpos;</span>
    <span class="s0">throwError(state, </span><span class="s3">'null byte is not allowed in input'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">// Use 0 as string terminator. That significantly simplifies bounds check.</span>
  <span class="s0">state.input += </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s0">;</span>

  <span class="s2">while </span><span class="s0">(state.input.charCodeAt(state.position) === </span><span class="s4">0x20</span><span class="s1">/* Space */</span><span class="s0">) {</span>
    <span class="s0">state.lineIndent += </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">state.position += </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">while </span><span class="s0">(state.position &lt; (state.length - </span><span class="s4">1</span><span class="s0">)) {</span>
    <span class="s0">readDocument(state);</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">state.documents;</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">loadAll$1(input, iterator, options) {</span>
  <span class="s2">if </span><span class="s0">(iterator !== </span><span class="s2">null </span><span class="s0">&amp;&amp; </span><span class="s2">typeof </span><span class="s0">iterator === </span><span class="s3">'object' </span><span class="s0">&amp;&amp; </span><span class="s2">typeof </span><span class="s0">options === </span><span class="s3">'undefined'</span><span class="s0">) {</span>
    <span class="s0">options = iterator;</span>
    <span class="s0">iterator = </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">var </span><span class="s0">documents = loadDocuments(input, options);</span>

  <span class="s2">if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">iterator !== </span><span class="s3">'function'</span><span class="s0">) {</span>
    <span class="s2">return </span><span class="s0">documents;</span>
  <span class="s0">}</span>

  <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">index = </span><span class="s4">0</span><span class="s0">, length = documents.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">iterator(documents[index]);</span>
  <span class="s0">}</span>
<span class="s0">}</span>


<span class="s2">function </span><span class="s0">load$1(input, options) {</span>
  <span class="s2">var </span><span class="s0">documents = loadDocuments(input, options);</span>

  <span class="s2">if </span><span class="s0">(documents.length === </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s1">/*eslint-disable no-undefined*/</span>
    <span class="s2">return </span><span class="s0">undefined;</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(documents.length === </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s2">return </span><span class="s0">documents[</span><span class="s4">0</span><span class="s0">];</span>
  <span class="s0">}</span>
  <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'expected a single document in the stream, but found more'</span><span class="s0">);</span>
<span class="s0">}</span>


<span class="s2">var </span><span class="s0">loadAll_1 = loadAll$1;</span>
<span class="s2">var </span><span class="s0">load_1    = load$1;</span>

<span class="s2">var </span><span class="s0">loader = {</span>
	<span class="s0">loadAll: loadAll_1,</span>
	<span class="s0">load: load_1</span>
<span class="s0">};</span>

<span class="s1">/*eslint-disable no-use-before-define*/</span>





<span class="s2">var </span><span class="s0">_toString       = Object.prototype.toString;</span>
<span class="s2">var </span><span class="s0">_hasOwnProperty = Object.prototype.hasOwnProperty;</span>

<span class="s2">var </span><span class="s0">CHAR_BOM                  = </span><span class="s4">0xFEFF</span><span class="s0">;</span>
<span class="s2">var </span><span class="s0">CHAR_TAB                  = </span><span class="s4">0x09</span><span class="s0">; </span><span class="s1">/* Tab */</span>
<span class="s2">var </span><span class="s0">CHAR_LINE_FEED            = </span><span class="s4">0x0A</span><span class="s0">; </span><span class="s1">/* LF */</span>
<span class="s2">var </span><span class="s0">CHAR_CARRIAGE_RETURN      = </span><span class="s4">0x0D</span><span class="s0">; </span><span class="s1">/* CR */</span>
<span class="s2">var </span><span class="s0">CHAR_SPACE                = </span><span class="s4">0x20</span><span class="s0">; </span><span class="s1">/* Space */</span>
<span class="s2">var </span><span class="s0">CHAR_EXCLAMATION          = </span><span class="s4">0x21</span><span class="s0">; </span><span class="s1">/* ! */</span>
<span class="s2">var </span><span class="s0">CHAR_DOUBLE_QUOTE         = </span><span class="s4">0x22</span><span class="s0">; </span><span class="s1">/* &quot; */</span>
<span class="s2">var </span><span class="s0">CHAR_SHARP                = </span><span class="s4">0x23</span><span class="s0">; </span><span class="s1">/* # */</span>
<span class="s2">var </span><span class="s0">CHAR_PERCENT              = </span><span class="s4">0x25</span><span class="s0">; </span><span class="s1">/* % */</span>
<span class="s2">var </span><span class="s0">CHAR_AMPERSAND            = </span><span class="s4">0x26</span><span class="s0">; </span><span class="s1">/* &amp; */</span>
<span class="s2">var </span><span class="s0">CHAR_SINGLE_QUOTE         = </span><span class="s4">0x27</span><span class="s0">; </span><span class="s1">/* ' */</span>
<span class="s2">var </span><span class="s0">CHAR_ASTERISK             = </span><span class="s4">0x2A</span><span class="s0">; </span><span class="s1">/* * */</span>
<span class="s2">var </span><span class="s0">CHAR_COMMA                = </span><span class="s4">0x2C</span><span class="s0">; </span><span class="s1">/* , */</span>
<span class="s2">var </span><span class="s0">CHAR_MINUS                = </span><span class="s4">0x2D</span><span class="s0">; </span><span class="s1">/* - */</span>
<span class="s2">var </span><span class="s0">CHAR_COLON                = </span><span class="s4">0x3A</span><span class="s0">; </span><span class="s1">/* : */</span>
<span class="s2">var </span><span class="s0">CHAR_EQUALS               = </span><span class="s4">0x3D</span><span class="s0">; </span><span class="s1">/* = */</span>
<span class="s2">var </span><span class="s0">CHAR_GREATER_THAN         = </span><span class="s4">0x3E</span><span class="s0">; </span><span class="s1">/* &gt; */</span>
<span class="s2">var </span><span class="s0">CHAR_QUESTION             = </span><span class="s4">0x3F</span><span class="s0">; </span><span class="s1">/* ? */</span>
<span class="s2">var </span><span class="s0">CHAR_COMMERCIAL_AT        = </span><span class="s4">0x40</span><span class="s0">; </span><span class="s1">/* @ */</span>
<span class="s2">var </span><span class="s0">CHAR_LEFT_SQUARE_BRACKET  = </span><span class="s4">0x5B</span><span class="s0">; </span><span class="s1">/* [ */</span>
<span class="s2">var </span><span class="s0">CHAR_RIGHT_SQUARE_BRACKET = </span><span class="s4">0x5D</span><span class="s0">; </span><span class="s1">/* ] */</span>
<span class="s2">var </span><span class="s0">CHAR_GRAVE_ACCENT         = </span><span class="s4">0x60</span><span class="s0">; </span><span class="s1">/* ` */</span>
<span class="s2">var </span><span class="s0">CHAR_LEFT_CURLY_BRACKET   = </span><span class="s4">0x7B</span><span class="s0">; </span><span class="s1">/* { */</span>
<span class="s2">var </span><span class="s0">CHAR_VERTICAL_LINE        = </span><span class="s4">0x7C</span><span class="s0">; </span><span class="s1">/* | */</span>
<span class="s2">var </span><span class="s0">CHAR_RIGHT_CURLY_BRACKET  = </span><span class="s4">0x7D</span><span class="s0">; </span><span class="s1">/* } */</span>

<span class="s2">var </span><span class="s0">ESCAPE_SEQUENCES = {};</span>

<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x00</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">0'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x07</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">a'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x08</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">b'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x09</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">t'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x0A</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">n'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x0B</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">v'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x0C</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">f'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x0D</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">r'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x1B</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">e'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x22</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">&quot;'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x5C</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\\\</span><span class="s3">'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x85</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">N'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0xA0</span><span class="s0">]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">_'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x2028</span><span class="s0">] = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">L'</span><span class="s0">;</span>
<span class="s0">ESCAPE_SEQUENCES[</span><span class="s4">0x2029</span><span class="s0">] = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">P'</span><span class="s0">;</span>

<span class="s2">var </span><span class="s0">DEPRECATED_BOOLEANS_SYNTAX = [</span>
  <span class="s3">'y'</span><span class="s0">, </span><span class="s3">'Y'</span><span class="s0">, </span><span class="s3">'yes'</span><span class="s0">, </span><span class="s3">'Yes'</span><span class="s0">, </span><span class="s3">'YES'</span><span class="s0">, </span><span class="s3">'on'</span><span class="s0">, </span><span class="s3">'On'</span><span class="s0">, </span><span class="s3">'ON'</span><span class="s0">,</span>
  <span class="s3">'n'</span><span class="s0">, </span><span class="s3">'N'</span><span class="s0">, </span><span class="s3">'no'</span><span class="s0">, </span><span class="s3">'No'</span><span class="s0">, </span><span class="s3">'NO'</span><span class="s0">, </span><span class="s3">'off'</span><span class="s0">, </span><span class="s3">'Off'</span><span class="s0">, </span><span class="s3">'OFF'</span>
<span class="s0">];</span>

<span class="s2">var </span><span class="s0">DEPRECATED_BASE60_SYNTAX = </span><span class="s6">/^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/</span><span class="s0">;</span>

<span class="s2">function </span><span class="s0">compileStyleMap(schema, map) {</span>
  <span class="s2">var </span><span class="s0">result, keys, index, length, tag, style, type;</span>

  <span class="s2">if </span><span class="s0">(map === </span><span class="s2">null</span><span class="s0">) </span><span class="s2">return </span><span class="s0">{};</span>

  <span class="s0">result = {};</span>
  <span class="s0">keys = Object.keys(map);</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = keys.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">tag = keys[index];</span>
    <span class="s0">style = String(map[tag]);</span>

    <span class="s2">if </span><span class="s0">(tag.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">) === </span><span class="s3">'!!'</span><span class="s0">) {</span>
      <span class="s0">tag = </span><span class="s3">'tag:yaml.org,2002:' </span><span class="s0">+ tag.slice(</span><span class="s4">2</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">type = schema.compiledTypeMap[</span><span class="s3">'fallback'</span><span class="s0">][tag];</span>

    <span class="s2">if </span><span class="s0">(type &amp;&amp; _hasOwnProperty.call(type.styleAliases, style)) {</span>
      <span class="s0">style = type.styleAliases[style];</span>
    <span class="s0">}</span>

    <span class="s0">result[tag] = style;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">encodeHex(character) {</span>
  <span class="s2">var </span><span class="s0">string, handle, length;</span>

  <span class="s0">string = character.toString(</span><span class="s4">16</span><span class="s0">).toUpperCase();</span>

  <span class="s2">if </span><span class="s0">(character &lt;= </span><span class="s4">0xFF</span><span class="s0">) {</span>
    <span class="s0">handle = </span><span class="s3">'x'</span><span class="s0">;</span>
    <span class="s0">length = </span><span class="s4">2</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(character &lt;= </span><span class="s4">0xFFFF</span><span class="s0">) {</span>
    <span class="s0">handle = </span><span class="s3">'u'</span><span class="s0">;</span>
    <span class="s0">length = </span><span class="s4">4</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(character &lt;= </span><span class="s4">0xFFFFFFFF</span><span class="s0">) {</span>
    <span class="s0">handle = </span><span class="s3">'U'</span><span class="s0">;</span>
    <span class="s0">length = </span><span class="s4">8</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'code point within a string may not be greater than 0xFFFFFFFF'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">' </span><span class="s0">+ handle + common.repeat(</span><span class="s3">'0'</span><span class="s0">, length - string.length) + string;</span>
<span class="s0">}</span>


<span class="s2">var </span><span class="s0">QUOTING_TYPE_SINGLE = </span><span class="s4">1</span><span class="s0">,</span>
    <span class="s0">QUOTING_TYPE_DOUBLE = </span><span class="s4">2</span><span class="s0">;</span>

<span class="s2">function </span><span class="s0">State(options) {</span>
  <span class="s2">this</span><span class="s0">.schema        = options[</span><span class="s3">'schema'</span><span class="s0">] || _default;</span>
  <span class="s2">this</span><span class="s0">.indent        = Math.max(</span><span class="s4">1</span><span class="s0">, (options[</span><span class="s3">'indent'</span><span class="s0">] || </span><span class="s4">2</span><span class="s0">));</span>
  <span class="s2">this</span><span class="s0">.noArrayIndent = options[</span><span class="s3">'noArrayIndent'</span><span class="s0">] || </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.skipInvalid   = options[</span><span class="s3">'skipInvalid'</span><span class="s0">] || </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.flowLevel     = (common.isNothing(options[</span><span class="s3">'flowLevel'</span><span class="s0">]) ? -</span><span class="s4">1 </span><span class="s0">: options[</span><span class="s3">'flowLevel'</span><span class="s0">]);</span>
  <span class="s2">this</span><span class="s0">.styleMap      = compileStyleMap(</span><span class="s2">this</span><span class="s0">.schema, options[</span><span class="s3">'styles'</span><span class="s0">] || </span><span class="s2">null</span><span class="s0">);</span>
  <span class="s2">this</span><span class="s0">.sortKeys      = options[</span><span class="s3">'sortKeys'</span><span class="s0">] || </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.lineWidth     = options[</span><span class="s3">'lineWidth'</span><span class="s0">] || </span><span class="s4">80</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.noRefs        = options[</span><span class="s3">'noRefs'</span><span class="s0">] || </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.noCompatMode  = options[</span><span class="s3">'noCompatMode'</span><span class="s0">] || </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.condenseFlow  = options[</span><span class="s3">'condenseFlow'</span><span class="s0">] || </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.quotingType   = options[</span><span class="s3">'quotingType'</span><span class="s0">] === </span><span class="s3">'&quot;' </span><span class="s0">? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;</span>
  <span class="s2">this</span><span class="s0">.forceQuotes   = options[</span><span class="s3">'forceQuotes'</span><span class="s0">] || </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.replacer      = </span><span class="s2">typeof </span><span class="s0">options[</span><span class="s3">'replacer'</span><span class="s0">] === </span><span class="s3">'function' </span><span class="s0">? options[</span><span class="s3">'replacer'</span><span class="s0">] : </span><span class="s2">null</span><span class="s0">;</span>

  <span class="s2">this</span><span class="s0">.implicitTypes = </span><span class="s2">this</span><span class="s0">.schema.compiledImplicit;</span>
  <span class="s2">this</span><span class="s0">.explicitTypes = </span><span class="s2">this</span><span class="s0">.schema.compiledExplicit;</span>

  <span class="s2">this</span><span class="s0">.tag = </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s2">this</span><span class="s0">.result = </span><span class="s3">''</span><span class="s0">;</span>

  <span class="s2">this</span><span class="s0">.duplicates = [];</span>
  <span class="s2">this</span><span class="s0">.usedDuplicates = </span><span class="s2">null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">// Indents every line in a string. Empty lines (\n only) are not indented.</span>
<span class="s2">function </span><span class="s0">indentString(string, spaces) {</span>
  <span class="s2">var </span><span class="s0">ind = common.repeat(</span><span class="s3">' '</span><span class="s0">, spaces),</span>
      <span class="s0">position = </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">next = -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">result = </span><span class="s3">''</span><span class="s0">,</span>
      <span class="s0">line,</span>
      <span class="s0">length = string.length;</span>

  <span class="s2">while </span><span class="s0">(position &lt; length) {</span>
    <span class="s0">next = string.indexOf(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">, position);</span>
    <span class="s2">if </span><span class="s0">(next === -</span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">line = string.slice(position);</span>
      <span class="s0">position = length;</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">line = string.slice(position, next + </span><span class="s4">1</span><span class="s0">);</span>
      <span class="s0">position = next + </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(line.length &amp;&amp; line !== </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">) result += ind;</span>

    <span class="s0">result += line;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">generateNextLine(state, level) {</span>
  <span class="s2">return </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s0">+ common.repeat(</span><span class="s3">' '</span><span class="s0">, state.indent * level);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">testImplicitResolving(state, str) {</span>
  <span class="s2">var </span><span class="s0">index, length, type;</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = state.implicitTypes.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">type = state.implicitTypes[index];</span>

    <span class="s2">if </span><span class="s0">(type.resolve(str)) {</span>
      <span class="s2">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">// [33] s-white ::= s-space | s-tab</span>
<span class="s2">function </span><span class="s0">isWhitespace(c) {</span>
  <span class="s2">return </span><span class="s0">c === CHAR_SPACE || c === CHAR_TAB;</span>
<span class="s0">}</span>

<span class="s1">// Returns true if the character can be printed without escaping.</span>
<span class="s1">// From YAML 1.2: &quot;any allowed characters known to be non-printable</span>
<span class="s1">// should also be escaped. [However,] This isnâ€™t mandatory&quot;</span>
<span class="s1">// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.</span>
<span class="s2">function </span><span class="s0">isPrintable(c) {</span>
  <span class="s2">return  </span><span class="s0">(</span><span class="s4">0x00020 </span><span class="s0">&lt;= c &amp;&amp; c &lt;= </span><span class="s4">0x00007E</span><span class="s0">)</span>
      <span class="s0">|| ((</span><span class="s4">0x000A1 </span><span class="s0">&lt;= c &amp;&amp; c &lt;= </span><span class="s4">0x00D7FF</span><span class="s0">) &amp;&amp; c !== </span><span class="s4">0x2028 </span><span class="s0">&amp;&amp; c !== </span><span class="s4">0x2029</span><span class="s0">)</span>
      <span class="s0">|| ((</span><span class="s4">0x0E000 </span><span class="s0">&lt;= c &amp;&amp; c &lt;= </span><span class="s4">0x00FFFD</span><span class="s0">) &amp;&amp; c !== CHAR_BOM)</span>
      <span class="s0">||  (</span><span class="s4">0x10000 </span><span class="s0">&lt;= c &amp;&amp; c &lt;= </span><span class="s4">0x10FFFF</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">// [34] ns-char ::= nb-char - s-white</span>
<span class="s1">// [27] nb-char ::= c-printable - b-char - c-byte-order-mark</span>
<span class="s1">// [26] b-char  ::= b-line-feed | b-carriage-return</span>
<span class="s1">// Including s-white (for some reason, examples doesn't match specs in this aspect)</span>
<span class="s1">// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark</span>
<span class="s2">function </span><span class="s0">isNsCharOrWhitespace(c) {</span>
  <span class="s2">return </span><span class="s0">isPrintable(c)</span>
    <span class="s0">&amp;&amp; c !== CHAR_BOM</span>
    <span class="s1">// - b-char</span>
    <span class="s0">&amp;&amp; c !== CHAR_CARRIAGE_RETURN</span>
    <span class="s0">&amp;&amp; c !== CHAR_LINE_FEED;</span>
<span class="s0">}</span>

<span class="s1">// [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out</span>
<span class="s1">//                             c = flow-in   â‡’ ns-plain-safe-in</span>
<span class="s1">//                             c = block-key â‡’ ns-plain-safe-out</span>
<span class="s1">//                             c = flow-key  â‡’ ns-plain-safe-in</span>
<span class="s1">// [128] ns-plain-safe-out ::= ns-char</span>
<span class="s1">// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator</span>
<span class="s1">// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )</span>
<span class="s1">//                            | ( /* An ns-char preceding */ â€œ#â€ )</span>
<span class="s1">//                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )</span>
<span class="s2">function </span><span class="s0">isPlainSafe(c, prev, inblock) {</span>
  <span class="s2">var </span><span class="s0">cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);</span>
  <span class="s2">var </span><span class="s0">cIsNsChar = cIsNsCharOrWhitespace &amp;&amp; !isWhitespace(c);</span>
  <span class="s2">return </span><span class="s0">(</span>
    <span class="s1">// ns-plain-safe</span>
    <span class="s0">inblock ? </span><span class="s1">// c = flow-in</span>
      <span class="s0">cIsNsCharOrWhitespace</span>
      <span class="s0">: cIsNsCharOrWhitespace</span>
        <span class="s1">// - c-flow-indicator</span>
        <span class="s0">&amp;&amp; c !== CHAR_COMMA</span>
        <span class="s0">&amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET</span>
        <span class="s0">&amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET</span>
        <span class="s0">&amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET</span>
        <span class="s0">&amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET</span>
  <span class="s0">)</span>
    <span class="s1">// ns-plain-char</span>
    <span class="s0">&amp;&amp; c !== CHAR_SHARP </span><span class="s1">// false on '#'</span>
    <span class="s0">&amp;&amp; !(prev === CHAR_COLON &amp;&amp; !cIsNsChar) </span><span class="s1">// false on ': '</span>
    <span class="s0">|| (isNsCharOrWhitespace(prev) &amp;&amp; !isWhitespace(prev) &amp;&amp; c === CHAR_SHARP) </span><span class="s1">// change to true on '[^ ]#'</span>
    <span class="s0">|| (prev === CHAR_COLON &amp;&amp; cIsNsChar); </span><span class="s1">// change to true on ':[^ ]'</span>
<span class="s0">}</span>

<span class="s1">// Simplified test for values allowed as the first character in plain style.</span>
<span class="s2">function </span><span class="s0">isPlainSafeFirst(c) {</span>
  <span class="s1">// Uses a subset of ns-char - c-indicator</span>
  <span class="s1">// where ns-char = nb-char - s-white.</span>
  <span class="s1">// No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part</span>
  <span class="s2">return </span><span class="s0">isPrintable(c) &amp;&amp; c !== CHAR_BOM</span>
    <span class="s0">&amp;&amp; !isWhitespace(c) </span><span class="s1">// - s-white</span>
    <span class="s1">// - (c-indicator ::=</span>
    <span class="s1">// â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€</span>
    <span class="s0">&amp;&amp; c !== CHAR_MINUS</span>
    <span class="s0">&amp;&amp; c !== CHAR_QUESTION</span>
    <span class="s0">&amp;&amp; c !== CHAR_COLON</span>
    <span class="s0">&amp;&amp; c !== CHAR_COMMA</span>
    <span class="s0">&amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET</span>
    <span class="s0">&amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET</span>
    <span class="s0">&amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET</span>
    <span class="s0">&amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET</span>
    <span class="s1">// | â€œ#â€ | â€œ&amp;â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ&gt;â€ | â€œ'â€ | â€œ&quot;â€</span>
    <span class="s0">&amp;&amp; c !== CHAR_SHARP</span>
    <span class="s0">&amp;&amp; c !== CHAR_AMPERSAND</span>
    <span class="s0">&amp;&amp; c !== CHAR_ASTERISK</span>
    <span class="s0">&amp;&amp; c !== CHAR_EXCLAMATION</span>
    <span class="s0">&amp;&amp; c !== CHAR_VERTICAL_LINE</span>
    <span class="s0">&amp;&amp; c !== CHAR_EQUALS</span>
    <span class="s0">&amp;&amp; c !== CHAR_GREATER_THAN</span>
    <span class="s0">&amp;&amp; c !== CHAR_SINGLE_QUOTE</span>
    <span class="s0">&amp;&amp; c !== CHAR_DOUBLE_QUOTE</span>
    <span class="s1">// | â€œ%â€ | â€œ@â€ | â€œ`â€)</span>
    <span class="s0">&amp;&amp; c !== CHAR_PERCENT</span>
    <span class="s0">&amp;&amp; c !== CHAR_COMMERCIAL_AT</span>
    <span class="s0">&amp;&amp; c !== CHAR_GRAVE_ACCENT;</span>
<span class="s0">}</span>

<span class="s1">// Simplified test for values allowed as the last character in plain style.</span>
<span class="s2">function </span><span class="s0">isPlainSafeLast(c) {</span>
  <span class="s1">// just not whitespace or colon, it will be checked to be plain character later</span>
  <span class="s2">return </span><span class="s0">!isWhitespace(c) &amp;&amp; c !== CHAR_COLON;</span>
<span class="s0">}</span>

<span class="s1">// Same as 'string'.codePointAt(pos), but works in older browsers.</span>
<span class="s2">function </span><span class="s0">codePointAt(string, pos) {</span>
  <span class="s2">var </span><span class="s0">first = string.charCodeAt(pos), second;</span>
  <span class="s2">if </span><span class="s0">(first &gt;= </span><span class="s4">0xD800 </span><span class="s0">&amp;&amp; first &lt;= </span><span class="s4">0xDBFF </span><span class="s0">&amp;&amp; pos + </span><span class="s4">1 </span><span class="s0">&lt; string.length) {</span>
    <span class="s0">second = string.charCodeAt(pos + </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s2">if </span><span class="s0">(second &gt;= </span><span class="s4">0xDC00 </span><span class="s0">&amp;&amp; second &lt;= </span><span class="s4">0xDFFF</span><span class="s0">) {</span>
      <span class="s1">// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae</span>
      <span class="s2">return </span><span class="s0">(first - </span><span class="s4">0xD800</span><span class="s0">) * </span><span class="s4">0x400 </span><span class="s0">+ second - </span><span class="s4">0xDC00 </span><span class="s0">+ </span><span class="s4">0x10000</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s2">return </span><span class="s0">first;</span>
<span class="s0">}</span>

<span class="s1">// Determines whether block indentation indicator is required.</span>
<span class="s2">function </span><span class="s0">needIndentIndicator(string) {</span>
  <span class="s2">var </span><span class="s0">leadingSpaceRe = </span><span class="s6">/^\n* /</span><span class="s0">;</span>
  <span class="s2">return </span><span class="s0">leadingSpaceRe.test(string);</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">STYLE_PLAIN   = </span><span class="s4">1</span><span class="s0">,</span>
    <span class="s0">STYLE_SINGLE  = </span><span class="s4">2</span><span class="s0">,</span>
    <span class="s0">STYLE_LITERAL = </span><span class="s4">3</span><span class="s0">,</span>
    <span class="s0">STYLE_FOLDED  = </span><span class="s4">4</span><span class="s0">,</span>
    <span class="s0">STYLE_DOUBLE  = </span><span class="s4">5</span><span class="s0">;</span>

<span class="s1">// Determines which scalar styles are possible and returns the preferred style.</span>
<span class="s1">// lineWidth = -1 =&gt; no limit.</span>
<span class="s1">// Pre-conditions: str.length &gt; 0.</span>
<span class="s1">// Post-conditions:</span>
<span class="s1">//    STYLE_PLAIN or STYLE_SINGLE =&gt; no \n are in the string.</span>
<span class="s1">//    STYLE_LITERAL =&gt; no lines are suitable for folding (or lineWidth is -1).</span>
<span class="s1">//    STYLE_FOLDED =&gt; a line &gt; lineWidth and can be folded (and lineWidth != -1).</span>
<span class="s2">function </span><span class="s0">chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,</span>
  <span class="s0">testAmbiguousType, quotingType, forceQuotes, inblock) {</span>

  <span class="s2">var </span><span class="s0">i;</span>
  <span class="s2">var </span><span class="s0">char = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">prevChar = </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">hasLineBreak = </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">hasFoldableLine = </span><span class="s2">false</span><span class="s0">; </span><span class="s1">// only checked if shouldTrackWidth</span>
  <span class="s2">var </span><span class="s0">shouldTrackWidth = lineWidth !== -</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">previousLineBreak = -</span><span class="s4">1</span><span class="s0">; </span><span class="s1">// count the first line correctly</span>
  <span class="s2">var </span><span class="s0">plain = isPlainSafeFirst(codePointAt(string, </span><span class="s4">0</span><span class="s0">))</span>
          <span class="s0">&amp;&amp; isPlainSafeLast(codePointAt(string, string.length - </span><span class="s4">1</span><span class="s0">));</span>

  <span class="s2">if </span><span class="s0">(singleLineOnly || forceQuotes) {</span>
    <span class="s1">// Case: no block styles.</span>
    <span class="s1">// Check for disallowed characters to rule out plain and single.</span>
    <span class="s2">for </span><span class="s0">(i = </span><span class="s4">0</span><span class="s0">; i &lt; string.length; char &gt;= </span><span class="s4">0x10000 </span><span class="s0">? i += </span><span class="s4">2 </span><span class="s0">: i++) {</span>
      <span class="s0">char = codePointAt(string, i);</span>
      <span class="s2">if </span><span class="s0">(!isPrintable(char)) {</span>
        <span class="s2">return </span><span class="s0">STYLE_DOUBLE;</span>
      <span class="s0">}</span>
      <span class="s0">plain = plain &amp;&amp; isPlainSafe(char, prevChar, inblock);</span>
      <span class="s0">prevChar = char;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s1">// Case: block styles permitted.</span>
    <span class="s2">for </span><span class="s0">(i = </span><span class="s4">0</span><span class="s0">; i &lt; string.length; char &gt;= </span><span class="s4">0x10000 </span><span class="s0">? i += </span><span class="s4">2 </span><span class="s0">: i++) {</span>
      <span class="s0">char = codePointAt(string, i);</span>
      <span class="s2">if </span><span class="s0">(char === CHAR_LINE_FEED) {</span>
        <span class="s0">hasLineBreak = </span><span class="s2">true</span><span class="s0">;</span>
        <span class="s1">// Check if any line can be folded.</span>
        <span class="s2">if </span><span class="s0">(shouldTrackWidth) {</span>
          <span class="s0">hasFoldableLine = hasFoldableLine ||</span>
            <span class="s1">// Foldable line = too long, and not more-indented.</span>
            <span class="s0">(i - previousLineBreak - </span><span class="s4">1 </span><span class="s0">&gt; lineWidth &amp;&amp;</span>
             <span class="s0">string[previousLineBreak + </span><span class="s4">1</span><span class="s0">] !== </span><span class="s3">' '</span><span class="s0">);</span>
          <span class="s0">previousLineBreak = i;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(!isPrintable(char)) {</span>
        <span class="s2">return </span><span class="s0">STYLE_DOUBLE;</span>
      <span class="s0">}</span>
      <span class="s0">plain = plain &amp;&amp; isPlainSafe(char, prevChar, inblock);</span>
      <span class="s0">prevChar = char;</span>
    <span class="s0">}</span>
    <span class="s1">// in case the end is missing a \n</span>
    <span class="s0">hasFoldableLine = hasFoldableLine || (shouldTrackWidth &amp;&amp;</span>
      <span class="s0">(i - previousLineBreak - </span><span class="s4">1 </span><span class="s0">&gt; lineWidth &amp;&amp;</span>
       <span class="s0">string[previousLineBreak + </span><span class="s4">1</span><span class="s0">] !== </span><span class="s3">' '</span><span class="s0">));</span>
  <span class="s0">}</span>
  <span class="s1">// Although every style can represent \n without escaping, prefer block styles</span>
  <span class="s1">// for multiline, since they're more readable and they don't add empty lines.</span>
  <span class="s1">// Also prefer folding a super-long line.</span>
  <span class="s2">if </span><span class="s0">(!hasLineBreak &amp;&amp; !hasFoldableLine) {</span>
    <span class="s1">// Strings interpretable as another type have to be quoted;</span>
    <span class="s1">// e.g. the string 'true' vs. the boolean true.</span>
    <span class="s2">if </span><span class="s0">(plain &amp;&amp; !forceQuotes &amp;&amp; !testAmbiguousType(string)) {</span>
      <span class="s2">return </span><span class="s0">STYLE_PLAIN;</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;</span>
  <span class="s0">}</span>
  <span class="s1">// Edge case: block indentation indicator can only have one digit.</span>
  <span class="s2">if </span><span class="s0">(indentPerLevel &gt; </span><span class="s4">9 </span><span class="s0">&amp;&amp; needIndentIndicator(string)) {</span>
    <span class="s2">return </span><span class="s0">STYLE_DOUBLE;</span>
  <span class="s0">}</span>
  <span class="s1">// At this point we know block styles are valid.</span>
  <span class="s1">// Prefer literal style unless we want to fold.</span>
  <span class="s2">if </span><span class="s0">(!forceQuotes) {</span>
    <span class="s2">return </span><span class="s0">hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;</span>
  <span class="s0">}</span>
  <span class="s2">return </span><span class="s0">quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;</span>
<span class="s0">}</span>

<span class="s1">// Note: line breaking/folding is implemented for only the folded style.</span>
<span class="s1">// NB. We drop the last trailing newline (if any) of a returned block scalar</span>
<span class="s1">//  since the dumper adds its own newline. This always works:</span>
<span class="s1">//    â€¢ No ending newline =&gt; unaffected; already using strip &quot;-&quot; chomping.</span>
<span class="s1">//    â€¢ Ending newline    =&gt; removed then restored.</span>
<span class="s1">//  Importantly, this keeps the &quot;+&quot; chomp indicator from gaining an extra line.</span>
<span class="s2">function </span><span class="s0">writeScalar(state, string, level, iskey, inblock) {</span>
  <span class="s0">state.dump = (</span><span class="s2">function </span><span class="s0">() {</span>
    <span class="s2">if </span><span class="s0">(string.length === </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s2">return </span><span class="s0">state.quotingType === QUOTING_TYPE_DOUBLE ? </span><span class="s3">'&quot;&quot;' </span><span class="s0">: </span><span class="s3">&quot;''&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(!state.noCompatMode) {</span>
      <span class="s2">if </span><span class="s0">(DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -</span><span class="s4">1 </span><span class="s0">|| DEPRECATED_BASE60_SYNTAX.test(string)) {</span>
        <span class="s2">return </span><span class="s0">state.quotingType === QUOTING_TYPE_DOUBLE ? (</span><span class="s3">'&quot;' </span><span class="s0">+ string + </span><span class="s3">'&quot;'</span><span class="s0">) : (</span><span class="s3">&quot;'&quot; </span><span class="s0">+ string + </span><span class="s3">&quot;'&quot;</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">var </span><span class="s0">indent = state.indent * Math.max(</span><span class="s4">1</span><span class="s0">, level); </span><span class="s1">// no 0-indent scalars</span>
    <span class="s1">// As indentation gets deeper, let the width decrease monotonically</span>
    <span class="s1">// to the lower bound min(state.lineWidth, 40).</span>
    <span class="s1">// Note that this implies</span>
    <span class="s1">//  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.</span>
    <span class="s1">//  state.lineWidth &gt; 40 + state.indent: width decreases until the lower bound.</span>
    <span class="s1">// This behaves better than a constant minimum width which disallows narrower options,</span>
    <span class="s1">// or an indent threshold which causes the width to suddenly increase.</span>
    <span class="s2">var </span><span class="s0">lineWidth = state.lineWidth === -</span><span class="s4">1</span>
      <span class="s0">? -</span><span class="s4">1 </span><span class="s0">: Math.max(Math.min(state.lineWidth, </span><span class="s4">40</span><span class="s0">), state.lineWidth - indent);</span>

    <span class="s1">// Without knowing if keys are implicit/explicit, assume implicit for safety.</span>
    <span class="s2">var </span><span class="s0">singleLineOnly = iskey</span>
      <span class="s1">// No block styles in flow mode.</span>
      <span class="s0">|| (state.flowLevel &gt; -</span><span class="s4">1 </span><span class="s0">&amp;&amp; level &gt;= state.flowLevel);</span>
    <span class="s2">function </span><span class="s0">testAmbiguity(string) {</span>
      <span class="s2">return </span><span class="s0">testImplicitResolving(state, string);</span>
    <span class="s0">}</span>

    <span class="s2">switch </span><span class="s0">(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,</span>
      <span class="s0">testAmbiguity, state.quotingType, state.forceQuotes &amp;&amp; !iskey, inblock)) {</span>

      <span class="s2">case </span><span class="s0">STYLE_PLAIN:</span>
        <span class="s2">return </span><span class="s0">string;</span>
      <span class="s2">case </span><span class="s0">STYLE_SINGLE:</span>
        <span class="s2">return </span><span class="s3">&quot;'&quot; </span><span class="s0">+ string.replace(</span><span class="s6">/'/g</span><span class="s0">, </span><span class="s3">&quot;''&quot;</span><span class="s0">) + </span><span class="s3">&quot;'&quot;</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s0">STYLE_LITERAL:</span>
        <span class="s2">return </span><span class="s3">'|' </span><span class="s0">+ blockHeader(string, state.indent)</span>
          <span class="s0">+ dropEndingNewline(indentString(string, indent));</span>
      <span class="s2">case </span><span class="s0">STYLE_FOLDED:</span>
        <span class="s2">return </span><span class="s3">'&gt;' </span><span class="s0">+ blockHeader(string, state.indent)</span>
          <span class="s0">+ dropEndingNewline(indentString(foldString(string, lineWidth), indent));</span>
      <span class="s2">case </span><span class="s0">STYLE_DOUBLE:</span>
        <span class="s2">return </span><span class="s3">'&quot;' </span><span class="s0">+ escapeString(string) + </span><span class="s3">'&quot;'</span><span class="s0">;</span>
      <span class="s2">default</span><span class="s0">:</span>
        <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'impossible error: invalid scalar style'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}());</span>
<span class="s0">}</span>

<span class="s1">// Pre-conditions: string is valid for a block scalar, 1 &lt;= indentPerLevel &lt;= 9.</span>
<span class="s2">function </span><span class="s0">blockHeader(string, indentPerLevel) {</span>
  <span class="s2">var </span><span class="s0">indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : </span><span class="s3">''</span><span class="s0">;</span>

  <span class="s1">// note the special case: the string '\n' counts as a &quot;trailing&quot; empty line.</span>
  <span class="s2">var </span><span class="s0">clip =          string[string.length - </span><span class="s4">1</span><span class="s0">] === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">keep = clip &amp;&amp; (string[string.length - </span><span class="s4">2</span><span class="s0">] === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s0">|| string === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">);</span>
  <span class="s2">var </span><span class="s0">chomp = keep ? </span><span class="s3">'+' </span><span class="s0">: (clip ? </span><span class="s3">'' </span><span class="s0">: </span><span class="s3">'-'</span><span class="s0">);</span>

  <span class="s2">return </span><span class="s0">indentIndicator + chomp + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">// (See the note for writeScalar.)</span>
<span class="s2">function </span><span class="s0">dropEndingNewline(string) {</span>
  <span class="s2">return </span><span class="s0">string[string.length - </span><span class="s4">1</span><span class="s0">] === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s0">? string.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">) : string;</span>
<span class="s0">}</span>

<span class="s1">// Note: a long line without a suitable break point will exceed the width limit.</span>
<span class="s1">// Pre-conditions: every char in str isPrintable, str.length &gt; 0, width &gt; 0.</span>
<span class="s2">function </span><span class="s0">foldString(string, width) {</span>
  <span class="s1">// In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”</span>
  <span class="s1">// unless they're before or after a more-indented line, or at the very</span>
  <span class="s1">// beginning or end, in which case $k$ maps to $k$.</span>
  <span class="s1">// Therefore, parse each chunk as newline(s) followed by a content line.</span>
  <span class="s2">var </span><span class="s0">lineRe = </span><span class="s6">/(\n+)([^\n]*)/g</span><span class="s0">;</span>

  <span class="s1">// first line (possibly an empty line)</span>
  <span class="s2">var </span><span class="s0">result = (</span><span class="s2">function </span><span class="s0">() {</span>
    <span class="s2">var </span><span class="s0">nextLF = string.indexOf(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">);</span>
    <span class="s0">nextLF = nextLF !== -</span><span class="s4">1 </span><span class="s0">? nextLF : string.length;</span>
    <span class="s0">lineRe.lastIndex = nextLF;</span>
    <span class="s2">return </span><span class="s0">foldLine(string.slice(</span><span class="s4">0</span><span class="s0">, nextLF), width);</span>
  <span class="s0">}());</span>
  <span class="s1">// If we haven't reached the first content line yet, don't add an extra \n.</span>
  <span class="s2">var </span><span class="s0">prevMoreIndented = string[</span><span class="s4">0</span><span class="s0">] === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s0">|| string[</span><span class="s4">0</span><span class="s0">] === </span><span class="s3">' '</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">moreIndented;</span>

  <span class="s1">// rest of the lines</span>
  <span class="s2">var </span><span class="s0">match;</span>
  <span class="s2">while </span><span class="s0">((match = lineRe.exec(string))) {</span>
    <span class="s2">var </span><span class="s0">prefix = match[</span><span class="s4">1</span><span class="s0">], line = match[</span><span class="s4">2</span><span class="s0">];</span>
    <span class="s0">moreIndented = (line[</span><span class="s4">0</span><span class="s0">] === </span><span class="s3">' '</span><span class="s0">);</span>
    <span class="s0">result += prefix</span>
      <span class="s0">+ (!prevMoreIndented &amp;&amp; !moreIndented &amp;&amp; line !== </span><span class="s3">''</span>
        <span class="s0">? </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s0">: </span><span class="s3">''</span><span class="s0">)</span>
      <span class="s0">+ foldLine(line, width);</span>
    <span class="s0">prevMoreIndented = moreIndented;</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>

<span class="s1">// Greedy line breaking.</span>
<span class="s1">// Picks the longest line under the limit each time,</span>
<span class="s1">// otherwise settles for the shortest line over the limit.</span>
<span class="s1">// NB. More-indented lines *cannot* be folded, as that would add an extra \n.</span>
<span class="s2">function </span><span class="s0">foldLine(line, width) {</span>
  <span class="s2">if </span><span class="s0">(line === </span><span class="s3">'' </span><span class="s0">|| line[</span><span class="s4">0</span><span class="s0">] === </span><span class="s3">' '</span><span class="s0">) </span><span class="s2">return </span><span class="s0">line;</span>

  <span class="s1">// Since a more-indented line adds a \n, breaks can't be followed by a space.</span>
  <span class="s2">var </span><span class="s0">breakRe = </span><span class="s6">/ [^ ]/g</span><span class="s0">; </span><span class="s1">// note: the match index will always be &lt;= length-2.</span>
  <span class="s2">var </span><span class="s0">match;</span>
  <span class="s1">// start is an inclusive index. end, curr, and next are exclusive.</span>
  <span class="s2">var </span><span class="s0">start = </span><span class="s4">0</span><span class="s0">, end, curr = </span><span class="s4">0</span><span class="s0">, next = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">result = </span><span class="s3">''</span><span class="s0">;</span>

  <span class="s1">// Invariants: 0 &lt;= start &lt;= length-1.</span>
  <span class="s1">//   0 &lt;= curr &lt;= next &lt;= max(0, length-2). curr - start &lt;= width.</span>
  <span class="s1">// Inside the loop:</span>
  <span class="s1">//   A match implies length &gt;= 2, so curr and next are &lt;= length-2.</span>
  <span class="s2">while </span><span class="s0">((match = breakRe.exec(line))) {</span>
    <span class="s0">next = match.index;</span>
    <span class="s1">// maintain invariant: curr - start &lt;= width</span>
    <span class="s2">if </span><span class="s0">(next - start &gt; width) {</span>
      <span class="s0">end = (curr &gt; start) ? curr : next; </span><span class="s1">// derive end &lt;= length-2</span>
      <span class="s0">result += </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s0">+ line.slice(start, end);</span>
      <span class="s1">// skip the space that was output as \n</span>
      <span class="s0">start = end + </span><span class="s4">1</span><span class="s0">;                    </span><span class="s1">// derive start &lt;= length-1</span>
    <span class="s0">}</span>
    <span class="s0">curr = next;</span>
  <span class="s0">}</span>

  <span class="s1">// By the invariants, start &lt;= length-1, so there is something left over.</span>
  <span class="s1">// It is either the whole string or a part starting from non-whitespace.</span>
  <span class="s0">result += </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">;</span>
  <span class="s1">// Insert a break if the remainder is too long and there is a break available.</span>
  <span class="s2">if </span><span class="s0">(line.length - start &gt; width &amp;&amp; curr &gt; start) {</span>
    <span class="s0">result += line.slice(start, curr) + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s0">+ line.slice(curr + </span><span class="s4">1</span><span class="s0">);</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s0">result += line.slice(start);</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result.slice(</span><span class="s4">1</span><span class="s0">); </span><span class="s1">// drop extra \n joiner</span>
<span class="s0">}</span>

<span class="s1">// Escapes a double-quoted string.</span>
<span class="s2">function </span><span class="s0">escapeString(string) {</span>
  <span class="s2">var </span><span class="s0">result = </span><span class="s3">''</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">char = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s2">var </span><span class="s0">escapeSeq;</span>

  <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; string.length; char &gt;= </span><span class="s4">0x10000 </span><span class="s0">? i += </span><span class="s4">2 </span><span class="s0">: i++) {</span>
    <span class="s0">char = codePointAt(string, i);</span>
    <span class="s0">escapeSeq = ESCAPE_SEQUENCES[char];</span>

    <span class="s2">if </span><span class="s0">(!escapeSeq &amp;&amp; isPrintable(char)) {</span>
      <span class="s0">result += string[i];</span>
      <span class="s2">if </span><span class="s0">(char &gt;= </span><span class="s4">0x10000</span><span class="s0">) result += string[i + </span><span class="s4">1</span><span class="s0">];</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">result += escapeSeq || encodeHex(char);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">return </span><span class="s0">result;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">writeFlowSequence(state, level, object) {</span>
  <span class="s2">var </span><span class="s0">_result = </span><span class="s3">''</span><span class="s0">,</span>
      <span class="s0">_tag    = state.tag,</span>
      <span class="s0">index,</span>
      <span class="s0">length,</span>
      <span class="s0">value;</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">value = object[index];</span>

    <span class="s2">if </span><span class="s0">(state.replacer) {</span>
      <span class="s0">value = state.replacer.call(object, String(index), value);</span>
    <span class="s0">}</span>

    <span class="s1">// Write only valid elements, put null instead of invalid elements.</span>
    <span class="s2">if </span><span class="s0">(writeNode(state, level, value, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">false</span><span class="s0">) ||</span>
        <span class="s0">(</span><span class="s2">typeof </span><span class="s0">value === </span><span class="s3">'undefined' </span><span class="s0">&amp;&amp;</span>
         <span class="s0">writeNode(state, level, </span><span class="s2">null</span><span class="s0">, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">false</span><span class="s0">))) {</span>

      <span class="s2">if </span><span class="s0">(_result !== </span><span class="s3">''</span><span class="s0">) _result += </span><span class="s3">',' </span><span class="s0">+ (!state.condenseFlow ? </span><span class="s3">' ' </span><span class="s0">: </span><span class="s3">''</span><span class="s0">);</span>
      <span class="s0">_result += state.dump;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">state.tag = _tag;</span>
  <span class="s0">state.dump = </span><span class="s3">'[' </span><span class="s0">+ _result + </span><span class="s3">']'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">writeBlockSequence(state, level, object, compact) {</span>
  <span class="s2">var </span><span class="s0">_result = </span><span class="s3">''</span><span class="s0">,</span>
      <span class="s0">_tag    = state.tag,</span>
      <span class="s0">index,</span>
      <span class="s0">length,</span>
      <span class="s0">value;</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">value = object[index];</span>

    <span class="s2">if </span><span class="s0">(state.replacer) {</span>
      <span class="s0">value = state.replacer.call(object, String(index), value);</span>
    <span class="s0">}</span>

    <span class="s1">// Write only valid elements, put null instead of invalid elements.</span>
    <span class="s2">if </span><span class="s0">(writeNode(state, level + </span><span class="s4">1</span><span class="s0">, value, </span><span class="s2">true</span><span class="s0">, </span><span class="s2">true</span><span class="s0">, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">true</span><span class="s0">) ||</span>
        <span class="s0">(</span><span class="s2">typeof </span><span class="s0">value === </span><span class="s3">'undefined' </span><span class="s0">&amp;&amp;</span>
         <span class="s0">writeNode(state, level + </span><span class="s4">1</span><span class="s0">, </span><span class="s2">null</span><span class="s0">, </span><span class="s2">true</span><span class="s0">, </span><span class="s2">true</span><span class="s0">, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">true</span><span class="s0">))) {</span>

      <span class="s2">if </span><span class="s0">(!compact || _result !== </span><span class="s3">''</span><span class="s0">) {</span>
        <span class="s0">_result += generateNextLine(state, level);</span>
      <span class="s0">}</span>

      <span class="s2">if </span><span class="s0">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s0">)) {</span>
        <span class="s0">_result += </span><span class="s3">'-'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">_result += </span><span class="s3">'- '</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s0">_result += state.dump;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">state.tag = _tag;</span>
  <span class="s0">state.dump = _result || </span><span class="s3">'[]'</span><span class="s0">; </span><span class="s1">// Empty sequence if no valid values.</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">writeFlowMapping(state, level, object) {</span>
  <span class="s2">var </span><span class="s0">_result       = </span><span class="s3">''</span><span class="s0">,</span>
      <span class="s0">_tag          = state.tag,</span>
      <span class="s0">objectKeyList = Object.keys(object),</span>
      <span class="s0">index,</span>
      <span class="s0">length,</span>
      <span class="s0">objectKey,</span>
      <span class="s0">objectValue,</span>
      <span class="s0">pairBuffer;</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>

    <span class="s0">pairBuffer = </span><span class="s3">''</span><span class="s0">;</span>
    <span class="s2">if </span><span class="s0">(_result !== </span><span class="s3">''</span><span class="s0">) pairBuffer += </span><span class="s3">', '</span><span class="s0">;</span>

    <span class="s2">if </span><span class="s0">(state.condenseFlow) pairBuffer += </span><span class="s3">'&quot;'</span><span class="s0">;</span>

    <span class="s0">objectKey = objectKeyList[index];</span>
    <span class="s0">objectValue = object[objectKey];</span>

    <span class="s2">if </span><span class="s0">(state.replacer) {</span>
      <span class="s0">objectValue = state.replacer.call(object, objectKey, objectValue);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(!writeNode(state, level, objectKey, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">false</span><span class="s0">)) {</span>
      <span class="s2">continue</span><span class="s0">; </span><span class="s1">// Skip this pair because of invalid key;</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(state.dump.length &gt; </span><span class="s4">1024</span><span class="s0">) pairBuffer += </span><span class="s3">'? '</span><span class="s0">;</span>

    <span class="s0">pairBuffer += state.dump + (state.condenseFlow ? </span><span class="s3">'&quot;' </span><span class="s0">: </span><span class="s3">''</span><span class="s0">) + </span><span class="s3">':' </span><span class="s0">+ (state.condenseFlow ? </span><span class="s3">'' </span><span class="s0">: </span><span class="s3">' '</span><span class="s0">);</span>

    <span class="s2">if </span><span class="s0">(!writeNode(state, level, objectValue, </span><span class="s2">false</span><span class="s0">, </span><span class="s2">false</span><span class="s0">)) {</span>
      <span class="s2">continue</span><span class="s0">; </span><span class="s1">// Skip this pair because of invalid value.</span>
    <span class="s0">}</span>

    <span class="s0">pairBuffer += state.dump;</span>

    <span class="s1">// Both key and value are valid.</span>
    <span class="s0">_result += pairBuffer;</span>
  <span class="s0">}</span>

  <span class="s0">state.tag = _tag;</span>
  <span class="s0">state.dump = </span><span class="s3">'{' </span><span class="s0">+ _result + </span><span class="s3">'}'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">writeBlockMapping(state, level, object, compact) {</span>
  <span class="s2">var </span><span class="s0">_result       = </span><span class="s3">''</span><span class="s0">,</span>
      <span class="s0">_tag          = state.tag,</span>
      <span class="s0">objectKeyList = Object.keys(object),</span>
      <span class="s0">index,</span>
      <span class="s0">length,</span>
      <span class="s0">objectKey,</span>
      <span class="s0">objectValue,</span>
      <span class="s0">explicitPair,</span>
      <span class="s0">pairBuffer;</span>

  <span class="s1">// Allow sorting keys so that the output file is deterministic</span>
  <span class="s2">if </span><span class="s0">(state.sortKeys === </span><span class="s2">true</span><span class="s0">) {</span>
    <span class="s1">// Default sorting</span>
    <span class="s0">objectKeyList.sort();</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s2">typeof </span><span class="s0">state.sortKeys === </span><span class="s3">'function'</span><span class="s0">) {</span>
    <span class="s1">// Custom sort function</span>
    <span class="s0">objectKeyList.sort(state.sortKeys);</span>
  <span class="s0">} </span><span class="s2">else if </span><span class="s0">(state.sortKeys) {</span>
    <span class="s1">// Something is wrong</span>
    <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'sortKeys must be a boolean or a function'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">pairBuffer = </span><span class="s3">''</span><span class="s0">;</span>

    <span class="s2">if </span><span class="s0">(!compact || _result !== </span><span class="s3">''</span><span class="s0">) {</span>
      <span class="s0">pairBuffer += generateNextLine(state, level);</span>
    <span class="s0">}</span>

    <span class="s0">objectKey = objectKeyList[index];</span>
    <span class="s0">objectValue = object[objectKey];</span>

    <span class="s2">if </span><span class="s0">(state.replacer) {</span>
      <span class="s0">objectValue = state.replacer.call(object, objectKey, objectValue);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(!writeNode(state, level + </span><span class="s4">1</span><span class="s0">, objectKey, </span><span class="s2">true</span><span class="s0">, </span><span class="s2">true</span><span class="s0">, </span><span class="s2">true</span><span class="s0">)) {</span>
      <span class="s2">continue</span><span class="s0">; </span><span class="s1">// Skip this pair because of invalid key.</span>
    <span class="s0">}</span>

    <span class="s0">explicitPair = (state.tag !== </span><span class="s2">null </span><span class="s0">&amp;&amp; state.tag !== </span><span class="s3">'?'</span><span class="s0">) ||</span>
                   <span class="s0">(state.dump &amp;&amp; state.dump.length &gt; </span><span class="s4">1024</span><span class="s0">);</span>

    <span class="s2">if </span><span class="s0">(explicitPair) {</span>
      <span class="s2">if </span><span class="s0">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s0">)) {</span>
        <span class="s0">pairBuffer += </span><span class="s3">'?'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">pairBuffer += </span><span class="s3">'? '</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">pairBuffer += state.dump;</span>

    <span class="s2">if </span><span class="s0">(explicitPair) {</span>
      <span class="s0">pairBuffer += generateNextLine(state, level);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(!writeNode(state, level + </span><span class="s4">1</span><span class="s0">, objectValue, </span><span class="s2">true</span><span class="s0">, explicitPair)) {</span>
      <span class="s2">continue</span><span class="s0">; </span><span class="s1">// Skip this pair because of invalid value.</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s0">)) {</span>
      <span class="s0">pairBuffer += </span><span class="s3">':'</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">pairBuffer += </span><span class="s3">': '</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">pairBuffer += state.dump;</span>

    <span class="s1">// Both key and value are valid.</span>
    <span class="s0">_result += pairBuffer;</span>
  <span class="s0">}</span>

  <span class="s0">state.tag = _tag;</span>
  <span class="s0">state.dump = _result || </span><span class="s3">'{}'</span><span class="s0">; </span><span class="s1">// Empty mapping if no valid pairs.</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">detectType(state, object, explicit) {</span>
  <span class="s2">var </span><span class="s0">_result, typeList, index, length, type, style;</span>

  <span class="s0">typeList = explicit ? state.explicitTypes : state.implicitTypes;</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = typeList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">type = typeList[index];</span>

    <span class="s2">if </span><span class="s0">((type.instanceOf  || type.predicate) &amp;&amp;</span>
        <span class="s0">(!type.instanceOf || ((</span><span class="s2">typeof </span><span class="s0">object === </span><span class="s3">'object'</span><span class="s0">) &amp;&amp; (object </span><span class="s2">instanceof </span><span class="s0">type.instanceOf))) &amp;&amp;</span>
        <span class="s0">(!type.predicate  || type.predicate(object))) {</span>

      <span class="s2">if </span><span class="s0">(explicit) {</span>
        <span class="s2">if </span><span class="s0">(type.multi &amp;&amp; type.representName) {</span>
          <span class="s0">state.tag = type.representName(object);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
          <span class="s0">state.tag = type.tag;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">state.tag = </span><span class="s3">'?'</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">if </span><span class="s0">(type.represent) {</span>
        <span class="s0">style = state.styleMap[type.tag] || type.defaultStyle;</span>

        <span class="s2">if </span><span class="s0">(_toString.call(type.represent) === </span><span class="s3">'[object Function]'</span><span class="s0">) {</span>
          <span class="s0">_result = type.represent(object, style);</span>
        <span class="s0">} </span><span class="s2">else if </span><span class="s0">(_hasOwnProperty.call(type.represent, style)) {</span>
          <span class="s0">_result = type.represent[style](object, style);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
          <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'!&lt;' </span><span class="s0">+ type.tag + </span><span class="s3">'&gt; tag resolver accepts not &quot;' </span><span class="s0">+ style + </span><span class="s3">'&quot; style'</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s0">state.dump = _result;</span>
      <span class="s0">}</span>

      <span class="s2">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">// Serializes `object` and writes it to global `result`.</span>
<span class="s1">// Returns true on success, or false on invalid object.</span>
<span class="s1">//</span>
<span class="s2">function </span><span class="s0">writeNode(state, level, object, block, compact, iskey, isblockseq) {</span>
  <span class="s0">state.tag = </span><span class="s2">null</span><span class="s0">;</span>
  <span class="s0">state.dump = object;</span>

  <span class="s2">if </span><span class="s0">(!detectType(state, object, </span><span class="s2">false</span><span class="s0">)) {</span>
    <span class="s0">detectType(state, object, </span><span class="s2">true</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">var </span><span class="s0">type = _toString.call(state.dump);</span>
  <span class="s2">var </span><span class="s0">inblock = block;</span>
  <span class="s2">var </span><span class="s0">tagStr;</span>

  <span class="s2">if </span><span class="s0">(block) {</span>
    <span class="s0">block = (state.flowLevel &lt; </span><span class="s4">0 </span><span class="s0">|| state.flowLevel &gt; level);</span>
  <span class="s0">}</span>

  <span class="s2">var </span><span class="s0">objectOrArray = type === </span><span class="s3">'[object Object]' </span><span class="s0">|| type === </span><span class="s3">'[object Array]'</span><span class="s0">,</span>
      <span class="s0">duplicateIndex,</span>
      <span class="s0">duplicate;</span>

  <span class="s2">if </span><span class="s0">(objectOrArray) {</span>
    <span class="s0">duplicateIndex = state.duplicates.indexOf(object);</span>
    <span class="s0">duplicate = duplicateIndex !== -</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">((state.tag !== </span><span class="s2">null </span><span class="s0">&amp;&amp; state.tag !== </span><span class="s3">'?'</span><span class="s0">) || duplicate || (state.indent !== </span><span class="s4">2 </span><span class="s0">&amp;&amp; level &gt; </span><span class="s4">0</span><span class="s0">)) {</span>
    <span class="s0">compact = </span><span class="s2">false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(duplicate &amp;&amp; state.usedDuplicates[duplicateIndex]) {</span>
    <span class="s0">state.dump = </span><span class="s3">'*ref_' </span><span class="s0">+ duplicateIndex;</span>
  <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
    <span class="s2">if </span><span class="s0">(objectOrArray &amp;&amp; duplicate &amp;&amp; !state.usedDuplicates[duplicateIndex]) {</span>
      <span class="s0">state.usedDuplicates[duplicateIndex] = </span><span class="s2">true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(type === </span><span class="s3">'[object Object]'</span><span class="s0">) {</span>
      <span class="s2">if </span><span class="s0">(block &amp;&amp; (Object.keys(state.dump).length !== </span><span class="s4">0</span><span class="s0">)) {</span>
        <span class="s0">writeBlockMapping(state, level, state.dump, compact);</span>
        <span class="s2">if </span><span class="s0">(duplicate) {</span>
          <span class="s0">state.dump = </span><span class="s3">'&amp;ref_' </span><span class="s0">+ duplicateIndex + state.dump;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">writeFlowMapping(state, level, state.dump);</span>
        <span class="s2">if </span><span class="s0">(duplicate) {</span>
          <span class="s0">state.dump = </span><span class="s3">'&amp;ref_' </span><span class="s0">+ duplicateIndex + </span><span class="s3">' ' </span><span class="s0">+ state.dump;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s3">'[object Array]'</span><span class="s0">) {</span>
      <span class="s2">if </span><span class="s0">(block &amp;&amp; (state.dump.length !== </span><span class="s4">0</span><span class="s0">)) {</span>
        <span class="s2">if </span><span class="s0">(state.noArrayIndent &amp;&amp; !isblockseq &amp;&amp; level &gt; </span><span class="s4">0</span><span class="s0">) {</span>
          <span class="s0">writeBlockSequence(state, level - </span><span class="s4">1</span><span class="s0">, state.dump, compact);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
          <span class="s0">writeBlockSequence(state, level, state.dump, compact);</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(duplicate) {</span>
          <span class="s0">state.dump = </span><span class="s3">'&amp;ref_' </span><span class="s0">+ duplicateIndex + state.dump;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">writeFlowSequence(state, level, state.dump);</span>
        <span class="s2">if </span><span class="s0">(duplicate) {</span>
          <span class="s0">state.dump = </span><span class="s3">'&amp;ref_' </span><span class="s0">+ duplicateIndex + </span><span class="s3">' ' </span><span class="s0">+ state.dump;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s3">'[object String]'</span><span class="s0">) {</span>
      <span class="s2">if </span><span class="s0">(state.tag !== </span><span class="s3">'?'</span><span class="s0">) {</span>
        <span class="s0">writeScalar(state, state.dump, level, iskey, inblock);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(type === </span><span class="s3">'[object Undefined]'</span><span class="s0">) {</span>
      <span class="s2">return false</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s2">if </span><span class="s0">(state.skipInvalid) </span><span class="s2">return false</span><span class="s0">;</span>
      <span class="s2">throw new </span><span class="s0">exception(</span><span class="s3">'unacceptable kind of an object to dump ' </span><span class="s0">+ type);</span>
    <span class="s0">}</span>

    <span class="s2">if </span><span class="s0">(state.tag !== </span><span class="s2">null </span><span class="s0">&amp;&amp; state.tag !== </span><span class="s3">'?'</span><span class="s0">) {</span>
      <span class="s1">// Need to encode all characters except those allowed by the spec:</span>
      <span class="s1">//</span>
      <span class="s1">// [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */</span>
      <span class="s1">// [36] ns-hex-digit    ::=  ns-dec-digit</span>
      <span class="s1">//                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */</span>
      <span class="s1">// [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */</span>
      <span class="s1">// [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€</span>
      <span class="s1">// [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€</span>
      <span class="s1">//                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&amp;â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€</span>
      <span class="s1">//                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€</span>
      <span class="s1">//</span>
      <span class="s1">// Also need to encode '!' because it has special meaning (end of tag prefix).</span>
      <span class="s1">//</span>
      <span class="s0">tagStr = encodeURI(</span>
        <span class="s0">state.tag[</span><span class="s4">0</span><span class="s0">] === </span><span class="s3">'!' </span><span class="s0">? state.tag.slice(</span><span class="s4">1</span><span class="s0">) : state.tag</span>
      <span class="s0">).replace(</span><span class="s6">/!/g</span><span class="s0">, </span><span class="s3">'%21'</span><span class="s0">);</span>

      <span class="s2">if </span><span class="s0">(state.tag[</span><span class="s4">0</span><span class="s0">] === </span><span class="s3">'!'</span><span class="s0">) {</span>
        <span class="s0">tagStr = </span><span class="s3">'!' </span><span class="s0">+ tagStr;</span>
      <span class="s0">} </span><span class="s2">else if </span><span class="s0">(tagStr.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">18</span><span class="s0">) === </span><span class="s3">'tag:yaml.org,2002:'</span><span class="s0">) {</span>
        <span class="s0">tagStr = </span><span class="s3">'!!' </span><span class="s0">+ tagStr.slice(</span><span class="s4">18</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">tagStr = </span><span class="s3">'!&lt;' </span><span class="s0">+ tagStr + </span><span class="s3">'&gt;'</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s0">state.dump = tagStr + </span><span class="s3">' ' </span><span class="s0">+ state.dump;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">getDuplicateReferences(object, state) {</span>
  <span class="s2">var </span><span class="s0">objects = [],</span>
      <span class="s0">duplicatesIndexes = [],</span>
      <span class="s0">index,</span>
      <span class="s0">length;</span>

  <span class="s0">inspectNode(object, objects, duplicatesIndexes);</span>

  <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = duplicatesIndexes.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">state.duplicates.push(objects[duplicatesIndexes[index]]);</span>
  <span class="s0">}</span>
  <span class="s0">state.usedDuplicates = </span><span class="s2">new </span><span class="s0">Array(length);</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">inspectNode(object, objects, duplicatesIndexes) {</span>
  <span class="s2">var </span><span class="s0">objectKeyList,</span>
      <span class="s0">index,</span>
      <span class="s0">length;</span>

  <span class="s2">if </span><span class="s0">(object !== </span><span class="s2">null </span><span class="s0">&amp;&amp; </span><span class="s2">typeof </span><span class="s0">object === </span><span class="s3">'object'</span><span class="s0">) {</span>
    <span class="s0">index = objects.indexOf(object);</span>
    <span class="s2">if </span><span class="s0">(index !== -</span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s2">if </span><span class="s0">(duplicatesIndexes.indexOf(index) === -</span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s0">duplicatesIndexes.push(index);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
      <span class="s0">objects.push(object);</span>

      <span class="s2">if </span><span class="s0">(Array.isArray(object)) {</span>
        <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s0">inspectNode(object[index], objects, duplicatesIndexes);</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s0">objectKeyList = Object.keys(object);</span>

        <span class="s2">for </span><span class="s0">(index = </span><span class="s4">0</span><span class="s0">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s0">inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">function </span><span class="s0">dump$1(input, options) {</span>
  <span class="s0">options = options || {};</span>

  <span class="s2">var </span><span class="s0">state = </span><span class="s2">new </span><span class="s0">State(options);</span>

  <span class="s2">if </span><span class="s0">(!state.noRefs) getDuplicateReferences(input, state);</span>

  <span class="s2">var </span><span class="s0">value = input;</span>

  <span class="s2">if </span><span class="s0">(state.replacer) {</span>
    <span class="s0">value = state.replacer.call({ </span><span class="s3">''</span><span class="s0">: value }, </span><span class="s3">''</span><span class="s0">, value);</span>
  <span class="s0">}</span>

  <span class="s2">if </span><span class="s0">(writeNode(state, </span><span class="s4">0</span><span class="s0">, value, </span><span class="s2">true</span><span class="s0">, </span><span class="s2">true</span><span class="s0">)) </span><span class="s2">return </span><span class="s0">state.dump + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s0">;</span>

  <span class="s2">return </span><span class="s3">''</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">var </span><span class="s0">dump_1 = dump$1;</span>

<span class="s2">var </span><span class="s0">dumper = {</span>
	<span class="s0">dump: dump_1</span>
<span class="s0">};</span>

<span class="s2">function </span><span class="s0">renamed(from, to) {</span>
  <span class="s2">return function </span><span class="s0">() {</span>
    <span class="s2">throw new </span><span class="s0">Error(</span><span class="s3">'Function yaml.' </span><span class="s0">+ from + </span><span class="s3">' is removed in js-yaml 4. ' </span><span class="s0">+</span>
      <span class="s3">'Use yaml.' </span><span class="s0">+ to + </span><span class="s3">' instead, which is now safe by default.'</span><span class="s0">);</span>
  <span class="s0">};</span>
<span class="s0">}</span>


<span class="s2">var </span><span class="s0">Type                = type;</span>
<span class="s2">var </span><span class="s0">Schema              = schema;</span>
<span class="s2">var </span><span class="s0">FAILSAFE_SCHEMA     = failsafe;</span>
<span class="s2">var </span><span class="s0">JSON_SCHEMA         = json;</span>
<span class="s2">var </span><span class="s0">CORE_SCHEMA         = core;</span>
<span class="s2">var </span><span class="s0">DEFAULT_SCHEMA      = _default;</span>
<span class="s2">var </span><span class="s0">load                = loader.load;</span>
<span class="s2">var </span><span class="s0">loadAll             = loader.loadAll;</span>
<span class="s2">var </span><span class="s0">dump                = dumper.dump;</span>
<span class="s2">var </span><span class="s0">YAMLException       = exception;</span>

<span class="s1">// Re-export all types in case user wants to create custom schema</span>
<span class="s2">var </span><span class="s0">types = {</span>
  <span class="s0">binary:    binary,</span>
  <span class="s0">float:     float,</span>
  <span class="s0">map:       map,</span>
  <span class="s2">null</span><span class="s0">:      _null,</span>
  <span class="s0">pairs:     pairs,</span>
  <span class="s0">set:       set,</span>
  <span class="s0">timestamp: timestamp,</span>
  <span class="s0">bool:      bool,</span>
  <span class="s0">int:       int,</span>
  <span class="s0">merge:     merge,</span>
  <span class="s0">omap:      omap,</span>
  <span class="s0">seq:       seq,</span>
  <span class="s0">str:       str</span>
<span class="s0">};</span>

<span class="s1">// Removed functions from JS-YAML 3.0.x</span>
<span class="s2">var </span><span class="s0">safeLoad            = renamed(</span><span class="s3">'safeLoad'</span><span class="s0">, </span><span class="s3">'load'</span><span class="s0">);</span>
<span class="s2">var </span><span class="s0">safeLoadAll         = renamed(</span><span class="s3">'safeLoadAll'</span><span class="s0">, </span><span class="s3">'loadAll'</span><span class="s0">);</span>
<span class="s2">var </span><span class="s0">safeDump            = renamed(</span><span class="s3">'safeDump'</span><span class="s0">, </span><span class="s3">'dump'</span><span class="s0">);</span>

<span class="s2">var </span><span class="s0">jsYaml = {</span>
	<span class="s0">Type: Type,</span>
	<span class="s0">Schema: Schema,</span>
	<span class="s0">FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,</span>
	<span class="s0">JSON_SCHEMA: JSON_SCHEMA,</span>
	<span class="s0">CORE_SCHEMA: CORE_SCHEMA,</span>
	<span class="s0">DEFAULT_SCHEMA: DEFAULT_SCHEMA,</span>
	<span class="s0">load: load,</span>
	<span class="s0">loadAll: loadAll,</span>
	<span class="s0">dump: dump,</span>
	<span class="s0">YAMLException: YAMLException,</span>
	<span class="s0">types: types,</span>
	<span class="s0">safeLoad: safeLoad,</span>
	<span class="s0">safeLoadAll: safeLoadAll,</span>
	<span class="s0">safeDump: safeDump</span>
<span class="s0">};</span>

<span class="s2">export default </span><span class="s0">jsYaml;</span>
<span class="s2">export </span><span class="s0">{ CORE_SCHEMA, DEFAULT_SCHEMA, FAILSAFE_SCHEMA, JSON_SCHEMA, Schema, Type, YAMLException, dump, load, loadAll, safeDump, safeLoad, safeLoadAll, types };</span>
</pre>
</body>
</html>