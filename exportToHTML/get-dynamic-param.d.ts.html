<html>
<head>
<title>get-dynamic-param.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
get-dynamic-param.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { DynamicParam } from </span><span class="s2">'../../../../server/app-render/app-render'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { DynamicParamTypesShort } from </span><span class="s2">'../../../../server/app-render/types'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FallbackRouteParams } from </span><span class="s2">'../../../../server/request/fallback-params'</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">*</span>
 <span class="s3">* Shared logic on client and server for creating a dynamic param value.</span>
 <span class="s3">*</span>
 <span class="s3">* This code needs to be shared with the client so it can extract dynamic route</span>
 <span class="s3">* params from the URL without a server request.</span>
 <span class="s3">*</span>
 <span class="s3">* Because everything in this module is sent to the client, we should aim to</span>
 <span class="s3">* keep this code as simple as possible. The special case handling for catchall</span>
 <span class="s3">* and optional is, alas, unfortunate.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getDynamicParam(params: {</span>
    <span class="s1">[key: string]: any;</span>
<span class="s1">}, segmentKey: string, dynamicParamType: DynamicParamTypesShort, pagePath: string, fallbackRouteParams: FallbackRouteParams | </span><span class="s0">null</span><span class="s1">): DynamicParam;</span>
<span class="s3">/**</span>
 <span class="s3">* Regular expression pattern used to match route parameters.</span>
 <span class="s3">* Matches both single parameters and parameter groups.</span>
 <span class="s3">* Examples:</span>
 <span class="s3">*   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true</span>
 <span class="s3">*   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false</span>
 <span class="s3">*   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true</span>
 <span class="s3">*   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">PARAMETER_PATTERN: RegExp;</span>
<span class="s3">/**</span>
 <span class="s3">* Parses a given parameter from a route to a data structure that can be used</span>
 <span class="s3">* to generate the parametrized route.</span>
 <span class="s3">* Examples:</span>
 <span class="s3">*   - `[[...slug]]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span>
 <span class="s3">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span>
 <span class="s3">*   - `[[foo]]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span>
 <span class="s3">*   - `[bar]` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span>
 <span class="s3">*   - `fizz` -&gt; `{ key: 'fizz', repeat: false, optional: false }`</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">param - The parameter to parse.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The parsed parameter as a data structure.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">parseParameter(param: string): {</span>
    <span class="s1">key: string;</span>
    <span class="s1">repeat: boolean;</span>
    <span class="s1">optional: boolean;</span>
<span class="s1">};</span>
<span class="s3">/**</span>
 <span class="s3">* Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used</span>
 <span class="s3">* to generate the parametrized route.</span>
 <span class="s3">* Examples:</span>
 <span class="s3">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span>
 <span class="s3">*   - `...slug` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span>
 <span class="s3">*   - `[foo]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span>
 <span class="s3">*   - `bar` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">param - The matched parameter to parse.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The parsed parameter as a data structure.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">parseMatchedParameter(param: string): {</span>
    <span class="s1">key: string;</span>
    <span class="s1">repeat: boolean;</span>
    <span class="s1">optional: boolean;</span>
<span class="s1">};</span>
</pre>
</body>
</html>