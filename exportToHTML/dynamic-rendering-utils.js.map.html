<html>
<head>
<title>dynamic-rendering-utils.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dynamic-rendering-utils.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/server/dynamic-rendering-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export function isHangingPromiseRejectionError(</span><span class="s3">\n  </span><span class="s1">err: unknown</span><span class="s3">\n</span><span class="s1">): err is HangingPromiseRejectionError {</span><span class="s3">\n  </span><span class="s1">if (typeof err !== 'object' || err === null || !('digest' in err)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return err.digest === HANGING_PROMISE_REJECTION</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'</span><span class="s3">\n\n</span><span class="s1">class HangingPromiseRejectionError extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly digest = HANGING_PROMISE_REJECTION</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">public readonly route: string,</span><span class="s3">\n    </span><span class="s1">public readonly expression: string</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using </span><span class="s3">\\</span><span class="s1">`setTimeout</span><span class="s3">\\</span><span class="s1">`, </span><span class="s3">\\</span><span class="s1">`after</span><span class="s3">\\</span><span class="s1">`, or similar functions you may observe this error and you should handle it in that context. This occurred at route </span><span class="s3">\&quot;</span><span class="s1">${route}</span><span class="s3">\&quot;</span><span class="s1">.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type AbortListeners = Array&lt;(err: unknown) =&gt; void&gt;</span><span class="s3">\n</span><span class="s1">const abortListenersBySignal = new WeakMap&lt;AbortSignal, AbortListeners&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function constructs a promise that will never resolve. This is primarily</span><span class="s3">\n </span><span class="s1">* useful for cacheComponents where we use promise resolution timing to determine which</span><span class="s3">\n </span><span class="s1">* parts of a render can be included in a prerender.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function makeHangingPromise&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">signal: AbortSignal,</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">): Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (signal.aborted) {</span><span class="s3">\n    </span><span class="s1">return Promise.reject(new HangingPromiseRejectionError(route, expression))</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const hangingPromise = new Promise&lt;T&gt;((_, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">const boundRejection = reject.bind(</span><span class="s3">\n        </span><span class="s1">null,</span><span class="s3">\n        </span><span class="s1">new HangingPromiseRejectionError(route, expression)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">let currentListeners = abortListenersBySignal.get(signal)</span><span class="s3">\n      </span><span class="s1">if (currentListeners) {</span><span class="s3">\n        </span><span class="s1">currentListeners.push(boundRejection)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const listeners = [boundRejection]</span><span class="s3">\n        </span><span class="s1">abortListenersBySignal.set(signal, listeners)</span><span class="s3">\n        </span><span class="s1">signal.addEventListener(</span><span class="s3">\n          </span><span class="s1">'abort',</span><span class="s3">\n          </span><span class="s1">() =&gt; {</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; listeners.length; i++) {</span><span class="s3">\n              </span><span class="s1">listeners[i]()</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">{ once: true }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">// We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so</span><span class="s3">\n    </span><span class="s1">// we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct</span><span class="s3">\n    </span><span class="s1">// your own promise out of it you'll need to ensure you handle the error when it rejects.</span><span class="s3">\n    </span><span class="s1">hangingPromise.catch(ignoreReject)</span><span class="s3">\n    </span><span class="s1">return hangingPromise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ignoreReject() {}</span><span class="s3">\n\n</span><span class="s1">export function makeDevtoolsIOAwarePromise&lt;T&gt;(underlying: T): Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">// in React DevTools if we resolve in a setTimeout we will observe</span><span class="s3">\n  </span><span class="s1">// the promise resolution as something that can suspend a boundary or root.</span><span class="s3">\n  </span><span class="s1">return new Promise&lt;T&gt;((resolve) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Must use setTimeout to be considered IO React DevTools. setImmediate will not work.</span><span class="s3">\n    </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n      </span><span class="s1">resolve(underlying)</span><span class="s3">\n    </span><span class="s1">}, 0)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;isHangingPromiseRejectionError&quot;</span><span class="s0">,</span><span class="s1">&quot;makeDevtoolsIOAwarePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;makeHangingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;HANGING_PROMISE_REJECTION&quot;</span><span class="s0">,</span><span class="s1">&quot;HangingPromiseRejectionError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;abortListenersBySignal&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;hangingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;boundRejection&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;currentListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;listeners&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreReject&quot;</span><span class="s0">,</span><span class="s1">&quot;underlying&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;IAAgBA,8BAA8B;eAA9BA;;IA2EAC,0BAA0B;eAA1BA;;IAxCAC,kBAAkB;eAAlBA;;;AAnCT,SAASF,+BACdG,GAAY;IAEZ,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAIC,MAAM,KAAKC;AACxB;AAEA,MAAMA,4BAA4B;AAElC,MAAMC,qCAAqCC;IAGzCC,YACE,AAAgBC,KAAa,EAC7B,AAAgBC,UAAkB,CAClC;QACA,KAAK,CACH,CAAC,qBAAqB,EAAEA,WAAW,qGAAqG,EAAEA,WAAW,8KAA8K,EAAED,MAAM,EAAE,CAAC,QAJhUA,QAAAA,YACAC,aAAAA,iBAJFN,SAASC;IASzB;AACF;AAGA,MAAMM,yBAAyB,IAAIC;AAS5B,SAASV,mBACdW,MAAmB,EACnBJ,KAAa,EACbC,UAAkB;IAElB,IAAIG,OAAOC,OAAO,EAAE;QAClB,OAAOC,QAAQC,MAAM,CAAC,IAAIV,6BAA6BG,OAAOC;IAChE,OAAO;QACL,MAAMO,iBAAiB,IAAIF,QAAW,CAACG,GAAGF;YACxC,MAAMG,iBAAiBH,OAAOI,IAAI,CAChC,MACA,IAAId,6BAA6BG,OAAOC;YAE1C,IAAIW,mBAAmBV,uBAAuBW,GAAG,CAACT;YAClD,IAAIQ,kBAAkB;gBACpBA,iBAAiBE,IAAI,CAACJ;YACxB,OAAO;gBACL,MAAMK,YAAY;oBAACL;iBAAe;gBAClCR,uBAAuBc,GAAG,CAACZ,QAAQW;gBACnCX,OAAOa,gBAAgB,CACrB,SACA;oBACE,IAAK,IAAIC,IAAI,GAAGA,IAAIH,UAAUI,MAAM,EAAED,IAAK;wBACzCH,SAAS,CAACG,EAAE;oBACd;gBACF,GACA;oBAAEE,MAAM;gBAAK;YAEjB;QACF;QACA,2GAA2G;QAC3G,6GAA6G;QAC7G,yFAAyF;QACzFZ,eAAea,KAAK,CAACC;QACrB,OAAOd;IACT;AACF;AAEA,SAASc,gBAAgB;AAElB,SAAS9B,2BAA8B+B,UAAa;IACzD,kEAAkE;IAClE,2EAA2E;IAC3E,OAAO,IAAIjB,QAAW,CAACkB;QACrB,sFAAsF;QACtFC,WAAW;YACTD,QAAQD;QACV,GAAG;IACL;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>