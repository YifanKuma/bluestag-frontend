<html>
<head>
<title>sorted-routes.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sorted-routes.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">getSortedRouteObjects: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getSortedRoutes: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">getSortedRouteObjects: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getSortedRouteObjects;</span>
    <span class="s1">},</span>
    <span class="s1">getSortedRoutes: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getSortedRoutes;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">class </span><span class="s1">UrlNode {</span>
    <span class="s1">insert(urlPath) {</span>
        <span class="s2">this</span><span class="s1">._insert(urlPath.split(</span><span class="s0">'/'</span><span class="s1">).filter(Boolean), [], </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">smoosh() {</span>
        <span class="s2">return this</span><span class="s1">._smoosh();</span>
    <span class="s1">}</span>
    <span class="s1">_smoosh(prefix) {</span>
        <span class="s2">if </span><span class="s1">(prefix === </span><span class="s2">void </span><span class="s3">0</span><span class="s1">) prefix = </span><span class="s0">'/'</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">childrenPaths = [</span>
            <span class="s1">...</span><span class="s2">this</span><span class="s1">.children.keys()</span>
        <span class="s1">].sort();</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.slugName !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">childrenPaths.splice(childrenPaths.indexOf(</span><span class="s0">'[]'</span><span class="s1">), </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.restSlugName !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">childrenPaths.splice(childrenPaths.indexOf(</span><span class="s0">'[...]'</span><span class="s1">), </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.optionalRestSlugName !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">childrenPaths.splice(childrenPaths.indexOf(</span><span class="s0">'[[...]]'</span><span class="s1">), </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">routes = childrenPaths.map((c)=&gt;</span><span class="s2">this</span><span class="s1">.children.get(c)._smoosh(</span><span class="s0">&quot;&quot; </span><span class="s1">+ prefix + c + </span><span class="s0">&quot;/&quot;</span><span class="s1">)).reduce((prev, curr)=&gt;[</span>
                <span class="s1">...prev,</span>
                <span class="s1">...curr</span>
            <span class="s1">], []);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.slugName !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">routes.push(...</span><span class="s2">this</span><span class="s1">.children.get(</span><span class="s0">'[]'</span><span class="s1">)._smoosh(prefix + </span><span class="s0">&quot;[&quot; </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.slugName + </span><span class="s0">&quot;]/&quot;</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.placeholder) {</span>
            <span class="s2">const </span><span class="s1">r = prefix === </span><span class="s0">'/' </span><span class="s1">? </span><span class="s0">'/' </span><span class="s1">: prefix.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.optionalRestSlugName != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'You cannot define a route with the same specificity as a optional catch-all route (&quot;' </span><span class="s1">+ r + </span><span class="s0">'&quot; and &quot;' </span><span class="s1">+ r + </span><span class="s0">&quot;[[...&quot; </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.optionalRestSlugName + </span><span class="s0">']]&quot;).'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E458&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">routes.unshift(r);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.restSlugName !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">routes.push(...</span><span class="s2">this</span><span class="s1">.children.get(</span><span class="s0">'[...]'</span><span class="s1">)._smoosh(prefix + </span><span class="s0">&quot;[...&quot; </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.restSlugName + </span><span class="s0">&quot;]/&quot;</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.optionalRestSlugName !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">routes.push(...</span><span class="s2">this</span><span class="s1">.children.get(</span><span class="s0">'[[...]]'</span><span class="s1">)._smoosh(prefix + </span><span class="s0">&quot;[[...&quot; </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.optionalRestSlugName + </span><span class="s0">&quot;]]/&quot;</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">routes;</span>
    <span class="s1">}</span>
    <span class="s1">_insert(urlPaths, slugNames, isCatchAll) {</span>
        <span class="s2">if </span><span class="s1">(urlPaths.length === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.placeholder = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isCatchAll) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;Catch-all must be the last part of the URL.&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E392&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">// The next segment in the urlPaths list</span>
        <span class="s2">let </span><span class="s1">nextSegment = urlPaths[</span><span class="s3">0</span><span class="s1">];</span>
        <span class="s4">// Check if the segment matches `[something]`</span>
        <span class="s2">if </span><span class="s1">(nextSegment.startsWith(</span><span class="s0">'['</span><span class="s1">) &amp;&amp; nextSegment.endsWith(</span><span class="s0">']'</span><span class="s1">)) {</span>
            <span class="s4">// Strip `[` and `]`, leaving only `something`</span>
            <span class="s2">let </span><span class="s1">segmentName = nextSegment.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">let </span><span class="s1">isOptional = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(segmentName.startsWith(</span><span class="s0">'['</span><span class="s1">) &amp;&amp; segmentName.endsWith(</span><span class="s0">']'</span><span class="s1">)) {</span>
                <span class="s4">// Strip optional `[` and `]`, leaving only `something`</span>
                <span class="s1">segmentName = segmentName.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">isOptional = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(segmentName.startsWith(</span><span class="s0">'…'</span><span class="s1">)) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;Detected a three-dot character ('…') at ('&quot; </span><span class="s1">+ segmentName + </span><span class="s0">&quot;'). Did you mean ('...')?&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E147&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(segmentName.startsWith(</span><span class="s0">'...'</span><span class="s1">)) {</span>
                <span class="s4">// Strip `...`, leaving only `something`</span>
                <span class="s1">segmentName = segmentName.substring(</span><span class="s3">3</span><span class="s1">);</span>
                <span class="s1">isCatchAll = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(segmentName.startsWith(</span><span class="s0">'['</span><span class="s1">) || segmentName.endsWith(</span><span class="s0">']'</span><span class="s1">)) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;Segment names may not start or end with extra brackets ('&quot; </span><span class="s1">+ segmentName + </span><span class="s0">&quot;').&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E421&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(segmentName.startsWith(</span><span class="s0">'.'</span><span class="s1">)) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;Segment names may not start with erroneous periods ('&quot; </span><span class="s1">+ segmentName + </span><span class="s0">&quot;').&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E288&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">function </span><span class="s1">handleSlug(previousSlug, nextSlug) {</span>
                <span class="s2">if </span><span class="s1">(previousSlug !== </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s4">// If the specific segment already has a slug but the slug is not `something`</span>
                    <span class="s4">// This prevents collisions like:</span>
                    <span class="s4">// pages/[post]/index.js</span>
                    <span class="s4">// pages/[id]/index.js</span>
                    <span class="s4">// Because currently multiple dynamic params on the same segment level are not supported</span>
                    <span class="s2">if </span><span class="s1">(previousSlug !== nextSlug) {</span>
                        <span class="s4">// TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;You cannot use different slug names for the same dynamic path ('&quot; </span><span class="s1">+ previousSlug + </span><span class="s0">&quot;' !== '&quot; </span><span class="s1">+ nextSlug + </span><span class="s0">&quot;').&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E337&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">slugNames.forEach((slug)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(slug === nextSlug) {</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'You cannot have the same slug name &quot;' </span><span class="s1">+ nextSlug + </span><span class="s0">'&quot; repeat within a single dynamic path'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E247&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(slug.replace(</span><span class="s5">/\W/g</span><span class="s1">, </span><span class="s0">''</span><span class="s1">) === nextSegment.replace(</span><span class="s5">/\W/g</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)) {</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'You cannot have the slug names &quot;' </span><span class="s1">+ slug + </span><span class="s0">'&quot; and &quot;' </span><span class="s1">+ nextSlug + </span><span class="s0">'&quot; differ only by non-word symbols within a single dynamic path'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E499&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s1">slugNames.push(nextSlug);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isCatchAll) {</span>
                <span class="s2">if </span><span class="s1">(isOptional) {</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.restSlugName != </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'You cannot use both an required and optional catch-all route at the same level (&quot;[...' </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.restSlugName + </span><span class="s0">']&quot; and &quot;' </span><span class="s1">+ urlPaths[</span><span class="s3">0</span><span class="s1">] + </span><span class="s0">'&quot; ).'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E299&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s1">handleSlug(</span><span class="s2">this</span><span class="s1">.optionalRestSlugName, segmentName);</span>
                    <span class="s4">// slugName is kept as it can only be one particular slugName</span>
                    <span class="s2">this</span><span class="s1">.optionalRestSlugName = segmentName;</span>
                    <span class="s4">// nextSegment is overwritten to [[...]] so that it can later be sorted specifically</span>
                    <span class="s1">nextSegment = </span><span class="s0">'[[...]]'</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.optionalRestSlugName != </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'You cannot use both an optional and required catch-all route at the same level (&quot;[[...' </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.optionalRestSlugName + </span><span class="s0">']]&quot; and &quot;' </span><span class="s1">+ urlPaths[</span><span class="s3">0</span><span class="s1">] + </span><span class="s0">'&quot;).'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E300&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s1">handleSlug(</span><span class="s2">this</span><span class="s1">.restSlugName, segmentName);</span>
                    <span class="s4">// slugName is kept as it can only be one particular slugName</span>
                    <span class="s2">this</span><span class="s1">.restSlugName = segmentName;</span>
                    <span class="s4">// nextSegment is overwritten to [...] so that it can later be sorted specifically</span>
                    <span class="s1">nextSegment = </span><span class="s0">'[...]'</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(isOptional) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Optional route parameters are not yet supported (&quot;' </span><span class="s1">+ urlPaths[</span><span class="s3">0</span><span class="s1">] + </span><span class="s0">'&quot;).'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E435&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">handleSlug(</span><span class="s2">this</span><span class="s1">.slugName, segmentName);</span>
                <span class="s4">// slugName is kept as it can only be one particular slugName</span>
                <span class="s2">this</span><span class="s1">.slugName = segmentName;</span>
                <span class="s4">// nextSegment is overwritten to [] so that it can later be sorted specifically</span>
                <span class="s1">nextSegment = </span><span class="s0">'[]'</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.children.has(nextSegment)) {</span>
            <span class="s2">this</span><span class="s1">.children.set(nextSegment, </span><span class="s2">new </span><span class="s1">UrlNode());</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.children.get(nextSegment)._insert(urlPaths.slice(</span><span class="s3">1</span><span class="s1">), slugNames, isCatchAll);</span>
    <span class="s1">}</span>
    <span class="s1">constructor(){</span>
        <span class="s2">this</span><span class="s1">.placeholder = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.children = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s2">this</span><span class="s1">.slugName = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.restSlugName = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.optionalRestSlugName = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSortedRoutes(normalizedPages) {</span>
    <span class="s4">// First the UrlNode is created, and every UrlNode can have only 1 dynamic segment</span>
    <span class="s4">// Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js</span>
    <span class="s4">// Only 1 dynamic segment per nesting level</span>
    <span class="s4">// So in the case that is test/integration/dynamic-routing it'll be this:</span>
    <span class="s4">// pages/[post]/comments.js</span>
    <span class="s4">// pages/blog/[post]/comment/[id].js</span>
    <span class="s4">// Both are fine because `pages/[post]` and `pages/blog` are on the same level</span>
    <span class="s4">// So in this case `UrlNode` created here has `this.slugName === 'post'`</span>
    <span class="s4">// And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities</span>
    <span class="s4">// Instead what has to be passed through is the upwards path's dynamic names</span>
    <span class="s2">const </span><span class="s1">root = </span><span class="s2">new </span><span class="s1">UrlNode();</span>
    <span class="s4">// Here the `root` gets injected multiple paths, and insert will break them up into sublevels</span>
    <span class="s1">normalizedPages.forEach((pagePath)=&gt;root.insert(pagePath));</span>
    <span class="s4">// Smoosh will then sort those sublevels up to the point where you get the correct route definition priority</span>
    <span class="s2">return </span><span class="s1">root.smoosh();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSortedRouteObjects(objects, getter) {</span>
    <span class="s4">// We're assuming here that all the pathnames are unique, that way we can</span>
    <span class="s4">// sort the list and use the index as the key.</span>
    <span class="s2">const </span><span class="s1">indexes = {};</span>
    <span class="s2">const </span><span class="s1">pathnames = [];</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; objects.length; i++){</span>
        <span class="s2">const </span><span class="s1">pathname = getter(objects[i]);</span>
        <span class="s1">indexes[pathname] = i;</span>
        <span class="s1">pathnames[i] = pathname;</span>
    <span class="s1">}</span>
    <span class="s4">// Sort the pathnames.</span>
    <span class="s2">const </span><span class="s1">sorted = getSortedRoutes(pathnames);</span>
    <span class="s4">// Map the sorted pathnames back to the original objects using the new sorted</span>
    <span class="s4">// index.</span>
    <span class="s2">return </span><span class="s1">sorted.map((pathname)=&gt;objects[indexes[pathname]]);</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=sorted-routes.js.map</span></pre>
</body>
</html>