<html>
<head>
<title>sourcemap-codec.umd.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sourcemap-codec.umd.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">factory(module);</span>
    <span class="s0">module.exports = def(module);</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd) {</span>
    <span class="s0">define([</span><span class="s2">'module'</span><span class="s0">], </span><span class="s1">function</span><span class="s0">(mod) {</span>
      <span class="s0">factory.apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
      <span class="s0">mod.exports = def(mod);</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">const </span><span class="s0">mod = { exports: {} };</span>
    <span class="s0">factory(mod);</span>
    <span class="s0">global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self;</span>
    <span class="s0">global.sourcemapCodec = def(mod);</span>
  <span class="s0">}</span>
  <span class="s1">function </span><span class="s0">def(m) { </span><span class="s1">return </span><span class="s2">'default' </span><span class="s1">in </span><span class="s0">m.exports ? m.exports.default : m.exports; }</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(module) {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">__defProp = Object.defineProperty;</span>
<span class="s1">var </span><span class="s0">__getOwnPropDesc = Object.getOwnPropertyDescriptor;</span>
<span class="s1">var </span><span class="s0">__getOwnPropNames = Object.getOwnPropertyNames;</span>
<span class="s1">var </span><span class="s0">__hasOwnProp = Object.prototype.hasOwnProperty;</span>
<span class="s1">var </span><span class="s0">__export = (target, all) =&gt; {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)</span>
    <span class="s0">__defProp(target, name, { get: all[name], enumerable: </span><span class="s1">true </span><span class="s0">});</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">__copyProps = (to, from, except, desc) =&gt; {</span>
  <span class="s1">if </span><span class="s0">(from &amp;&amp; </span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;object&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">key of __getOwnPropNames(from))</span>
      <span class="s1">if </span><span class="s0">(!__hasOwnProp.call(to, key) &amp;&amp; key !== except)</span>
        <span class="s0">__defProp(to, key, { get: () =&gt; from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">to;</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">__toCommonJS = (mod) =&gt; __copyProps(__defProp({}, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, { value: </span><span class="s1">true </span><span class="s0">}), mod);</span>

<span class="s3">// src/sourcemap-codec.ts</span>
<span class="s1">var </span><span class="s0">sourcemap_codec_exports = {};</span>
<span class="s0">__export(sourcemap_codec_exports, {</span>
  <span class="s0">decode: () =&gt; decode,</span>
  <span class="s0">decodeGeneratedRanges: () =&gt; decodeGeneratedRanges,</span>
  <span class="s0">decodeOriginalScopes: () =&gt; decodeOriginalScopes,</span>
  <span class="s0">encode: () =&gt; encode,</span>
  <span class="s0">encodeGeneratedRanges: () =&gt; encodeGeneratedRanges,</span>
  <span class="s0">encodeOriginalScopes: () =&gt; encodeOriginalScopes</span>
<span class="s0">});</span>
<span class="s0">module.exports = __toCommonJS(sourcemap_codec_exports);</span>

<span class="s3">// src/vlq.ts</span>
<span class="s1">var </span><span class="s0">comma = </span><span class="s2">&quot;,&quot;</span><span class="s0">.charCodeAt(</span><span class="s4">0</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">semicolon = </span><span class="s2">&quot;;&quot;</span><span class="s0">.charCodeAt(</span><span class="s4">0</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">chars = </span><span class="s2">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">intToChar = </span><span class="s1">new </span><span class="s0">Uint8Array(</span><span class="s4">64</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">charToInt = </span><span class="s1">new </span><span class="s0">Uint8Array(</span><span class="s4">128</span><span class="s0">);</span>
<span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; chars.length; i++) {</span>
  <span class="s1">const </span><span class="s0">c = chars.charCodeAt(i);</span>
  <span class="s0">intToChar[i] = c;</span>
  <span class="s0">charToInt[c] = i;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">decodeInteger(reader, relative) {</span>
  <span class="s1">let </span><span class="s0">value = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">shift = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">integer = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">do </span><span class="s0">{</span>
    <span class="s1">const </span><span class="s0">c = reader.next();</span>
    <span class="s0">integer = charToInt[c];</span>
    <span class="s0">value |= (integer &amp; </span><span class="s4">31</span><span class="s0">) &lt;&lt; shift;</span>
    <span class="s0">shift += </span><span class="s4">5</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">while </span><span class="s0">(integer &amp; </span><span class="s4">32</span><span class="s0">);</span>
  <span class="s1">const </span><span class="s0">shouldNegate = value &amp; </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">value &gt;&gt;&gt;= </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(shouldNegate) {</span>
    <span class="s0">value = -</span><span class="s4">2147483648 </span><span class="s0">| -value;</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">relative + value;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">encodeInteger(builder, num, relative) {</span>
  <span class="s1">let </span><span class="s0">delta = num - relative;</span>
  <span class="s0">delta = delta &lt; </span><span class="s4">0 </span><span class="s0">? -delta &lt;&lt; </span><span class="s4">1 </span><span class="s0">| </span><span class="s4">1 </span><span class="s0">: delta &lt;&lt; </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s1">do </span><span class="s0">{</span>
    <span class="s1">let </span><span class="s0">clamped = delta &amp; </span><span class="s4">31</span><span class="s0">;</span>
    <span class="s0">delta &gt;&gt;&gt;= </span><span class="s4">5</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(delta &gt; </span><span class="s4">0</span><span class="s0">) clamped |= </span><span class="s4">32</span><span class="s0">;</span>
    <span class="s0">builder.write(intToChar[clamped]);</span>
  <span class="s0">} </span><span class="s1">while </span><span class="s0">(delta &gt; </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">num;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">hasMoreVlq(reader, max) {</span>
  <span class="s1">if </span><span class="s0">(reader.pos &gt;= max) </span><span class="s1">return false</span><span class="s0">;</span>
  <span class="s1">return </span><span class="s0">reader.peek() !== comma;</span>
<span class="s0">}</span>

<span class="s3">// src/strings.ts</span>
<span class="s1">var </span><span class="s0">bufLength = </span><span class="s4">1024 </span><span class="s0">* </span><span class="s4">16</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">td = </span><span class="s1">typeof </span><span class="s0">TextDecoder !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? </span><span class="s3">/* @__PURE__ */ </span><span class="s1">new </span><span class="s0">TextDecoder() : </span><span class="s1">typeof </span><span class="s0">Buffer !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? {</span>
  <span class="s0">decode(buf) {</span>
    <span class="s1">const </span><span class="s0">out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);</span>
    <span class="s1">return </span><span class="s0">out.toString();</span>
  <span class="s0">}</span>
<span class="s0">} : {</span>
  <span class="s0">decode(buf) {</span>
    <span class="s1">let </span><span class="s0">out = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; buf.length; i++) {</span>
      <span class="s0">out += String.fromCharCode(buf[i]);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">out;</span>
  <span class="s0">}</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">StringWriter = </span><span class="s1">class </span><span class="s0">{</span>
  <span class="s0">constructor() {</span>
    <span class="s1">this</span><span class="s0">.pos = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.out = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.buffer = </span><span class="s1">new </span><span class="s0">Uint8Array(bufLength);</span>
  <span class="s0">}</span>
  <span class="s0">write(v) {</span>
    <span class="s1">const </span><span class="s0">{ buffer } = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">buffer[</span><span class="s1">this</span><span class="s0">.pos++] = v;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.pos === bufLength) {</span>
      <span class="s1">this</span><span class="s0">.out += td.decode(buffer);</span>
      <span class="s1">this</span><span class="s0">.pos = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s0">flush() {</span>
    <span class="s1">const </span><span class="s0">{ buffer, out, pos } = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">pos &gt; </span><span class="s4">0 </span><span class="s0">? out + td.decode(buffer.subarray(</span><span class="s4">0</span><span class="s0">, pos)) : out;</span>
  <span class="s0">}</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">StringReader = </span><span class="s1">class </span><span class="s0">{</span>
  <span class="s0">constructor(buffer) {</span>
    <span class="s1">this</span><span class="s0">.pos = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.buffer = buffer;</span>
  <span class="s0">}</span>
  <span class="s0">next() {</span>
    <span class="s1">return this</span><span class="s0">.buffer.charCodeAt(</span><span class="s1">this</span><span class="s0">.pos++);</span>
  <span class="s0">}</span>
  <span class="s0">peek() {</span>
    <span class="s1">return this</span><span class="s0">.buffer.charCodeAt(</span><span class="s1">this</span><span class="s0">.pos);</span>
  <span class="s0">}</span>
  <span class="s0">indexOf(char) {</span>
    <span class="s1">const </span><span class="s0">{ buffer, pos } = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">idx = buffer.indexOf(char, pos);</span>
    <span class="s1">return </span><span class="s0">idx === -</span><span class="s4">1 </span><span class="s0">? buffer.length : idx;</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s3">// src/scopes.ts</span>
<span class="s1">var </span><span class="s0">EMPTY = [];</span>
<span class="s1">function </span><span class="s0">decodeOriginalScopes(input) {</span>
  <span class="s1">const </span><span class="s0">{ length } = input;</span>
  <span class="s1">const </span><span class="s0">reader = </span><span class="s1">new </span><span class="s0">StringReader(input);</span>
  <span class="s1">const </span><span class="s0">scopes = [];</span>
  <span class="s1">const </span><span class="s0">stack = [];</span>
  <span class="s1">let </span><span class="s0">line = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">for </span><span class="s0">(; reader.pos &lt; length; reader.pos++) {</span>
    <span class="s0">line = decodeInteger(reader, line);</span>
    <span class="s1">const </span><span class="s0">column = decodeInteger(reader, </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(!hasMoreVlq(reader, length)) {</span>
      <span class="s1">const </span><span class="s0">last = stack.pop();</span>
      <span class="s0">last[</span><span class="s4">2</span><span class="s0">] = line;</span>
      <span class="s0">last[</span><span class="s4">3</span><span class="s0">] = column;</span>
      <span class="s1">continue</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">kind = decodeInteger(reader, </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">fields = decodeInteger(reader, </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">hasName = fields &amp; </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">scope = hasName ? [line, column, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, kind, decodeInteger(reader, </span><span class="s4">0</span><span class="s0">)] : [line, column, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, kind];</span>
    <span class="s1">let </span><span class="s0">vars = EMPTY;</span>
    <span class="s1">if </span><span class="s0">(hasMoreVlq(reader, length)) {</span>
      <span class="s0">vars = [];</span>
      <span class="s1">do </span><span class="s0">{</span>
        <span class="s1">const </span><span class="s0">varsIndex = decodeInteger(reader, </span><span class="s4">0</span><span class="s0">);</span>
        <span class="s0">vars.push(varsIndex);</span>
      <span class="s0">} </span><span class="s1">while </span><span class="s0">(hasMoreVlq(reader, length));</span>
    <span class="s0">}</span>
    <span class="s0">scope.vars = vars;</span>
    <span class="s0">scopes.push(scope);</span>
    <span class="s0">stack.push(scope);</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">scopes;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">encodeOriginalScopes(scopes) {</span>
  <span class="s1">const </span><span class="s0">writer = </span><span class="s1">new </span><span class="s0">StringWriter();</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; scopes.length; ) {</span>
    <span class="s0">i = _encodeOriginalScopes(scopes, i, writer, [</span><span class="s4">0</span><span class="s0">]);</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">writer.flush();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">_encodeOriginalScopes(scopes, index, writer, state) {</span>
  <span class="s1">const </span><span class="s0">scope = scopes[index];</span>
  <span class="s1">const </span><span class="s0">{ </span><span class="s4">0</span><span class="s0">: startLine, </span><span class="s4">1</span><span class="s0">: startColumn, </span><span class="s4">2</span><span class="s0">: endLine, </span><span class="s4">3</span><span class="s0">: endColumn, </span><span class="s4">4</span><span class="s0">: kind, vars } = scope;</span>
  <span class="s1">if </span><span class="s0">(index &gt; </span><span class="s4">0</span><span class="s0">) writer.write(comma);</span>
  <span class="s0">state[</span><span class="s4">0</span><span class="s0">] = encodeInteger(writer, startLine, state[</span><span class="s4">0</span><span class="s0">]);</span>
  <span class="s0">encodeInteger(writer, startColumn, </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s0">encodeInteger(writer, kind, </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s1">const </span><span class="s0">fields = scope.length === </span><span class="s4">6 </span><span class="s0">? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">encodeInteger(writer, fields, </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s1">if </span><span class="s0">(scope.length === </span><span class="s4">6</span><span class="s0">) encodeInteger(writer, scope[</span><span class="s4">5</span><span class="s0">], </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">v of vars) {</span>
    <span class="s0">encodeInteger(writer, v, </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s0">}</span>
  <span class="s1">for </span><span class="s0">(index++; index &lt; scopes.length; ) {</span>
    <span class="s1">const </span><span class="s0">next = scopes[index];</span>
    <span class="s1">const </span><span class="s0">{ </span><span class="s4">0</span><span class="s0">: l, </span><span class="s4">1</span><span class="s0">: c } = next;</span>
    <span class="s1">if </span><span class="s0">(l &gt; endLine || l === endLine &amp;&amp; c &gt;= endColumn) {</span>
      <span class="s1">break</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">index = _encodeOriginalScopes(scopes, index, writer, state);</span>
  <span class="s0">}</span>
  <span class="s0">writer.write(comma);</span>
  <span class="s0">state[</span><span class="s4">0</span><span class="s0">] = encodeInteger(writer, endLine, state[</span><span class="s4">0</span><span class="s0">]);</span>
  <span class="s0">encodeInteger(writer, endColumn, </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">index;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">decodeGeneratedRanges(input) {</span>
  <span class="s1">const </span><span class="s0">{ length } = input;</span>
  <span class="s1">const </span><span class="s0">reader = </span><span class="s1">new </span><span class="s0">StringReader(input);</span>
  <span class="s1">const </span><span class="s0">ranges = [];</span>
  <span class="s1">const </span><span class="s0">stack = [];</span>
  <span class="s1">let </span><span class="s0">genLine = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">definitionSourcesIndex = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">definitionScopeIndex = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">callsiteSourcesIndex = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">callsiteLine = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">callsiteColumn = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">bindingLine = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">bindingColumn = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">do </span><span class="s0">{</span>
    <span class="s1">const </span><span class="s0">semi = reader.indexOf(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
    <span class="s1">let </span><span class="s0">genColumn = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">for </span><span class="s0">(; reader.pos &lt; semi; reader.pos++) {</span>
      <span class="s0">genColumn = decodeInteger(reader, genColumn);</span>
      <span class="s1">if </span><span class="s0">(!hasMoreVlq(reader, semi)) {</span>
        <span class="s1">const </span><span class="s0">last = stack.pop();</span>
        <span class="s0">last[</span><span class="s4">2</span><span class="s0">] = genLine;</span>
        <span class="s0">last[</span><span class="s4">3</span><span class="s0">] = genColumn;</span>
        <span class="s1">continue</span><span class="s0">;</span>
      <span class="s0">}</span>
      <span class="s1">const </span><span class="s0">fields = decodeInteger(reader, </span><span class="s4">0</span><span class="s0">);</span>
      <span class="s1">const </span><span class="s0">hasDefinition = fields &amp; </span><span class="s4">1</span><span class="s0">;</span>
      <span class="s1">const </span><span class="s0">hasCallsite = fields &amp; </span><span class="s4">2</span><span class="s0">;</span>
      <span class="s1">const </span><span class="s0">hasScope = fields &amp; </span><span class="s4">4</span><span class="s0">;</span>
      <span class="s1">let </span><span class="s0">callsite = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s1">let </span><span class="s0">bindings = EMPTY;</span>
      <span class="s1">let </span><span class="s0">range;</span>
      <span class="s1">if </span><span class="s0">(hasDefinition) {</span>
        <span class="s1">const </span><span class="s0">defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);</span>
        <span class="s0">definitionScopeIndex = decodeInteger(</span>
          <span class="s0">reader,</span>
          <span class="s0">definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : </span><span class="s4">0</span>
        <span class="s0">);</span>
        <span class="s0">definitionSourcesIndex = defSourcesIndex;</span>
        <span class="s0">range = [genLine, genColumn, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, defSourcesIndex, definitionScopeIndex];</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">range = [genLine, genColumn, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">];</span>
      <span class="s0">}</span>
      <span class="s0">range.isScope = !!hasScope;</span>
      <span class="s1">if </span><span class="s0">(hasCallsite) {</span>
        <span class="s1">const </span><span class="s0">prevCsi = callsiteSourcesIndex;</span>
        <span class="s1">const </span><span class="s0">prevLine = callsiteLine;</span>
        <span class="s0">callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);</span>
        <span class="s1">const </span><span class="s0">sameSource = prevCsi === callsiteSourcesIndex;</span>
        <span class="s0">callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : </span><span class="s4">0</span><span class="s0">);</span>
        <span class="s0">callsiteColumn = decodeInteger(</span>
          <span class="s0">reader,</span>
          <span class="s0">sameSource &amp;&amp; prevLine === callsiteLine ? callsiteColumn : </span><span class="s4">0</span>
        <span class="s0">);</span>
        <span class="s0">callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];</span>
      <span class="s0">}</span>
      <span class="s0">range.callsite = callsite;</span>
      <span class="s1">if </span><span class="s0">(hasMoreVlq(reader, semi)) {</span>
        <span class="s0">bindings = [];</span>
        <span class="s1">do </span><span class="s0">{</span>
          <span class="s0">bindingLine = genLine;</span>
          <span class="s0">bindingColumn = genColumn;</span>
          <span class="s1">const </span><span class="s0">expressionsCount = decodeInteger(reader, </span><span class="s4">0</span><span class="s0">);</span>
          <span class="s1">let </span><span class="s0">expressionRanges;</span>
          <span class="s1">if </span><span class="s0">(expressionsCount &lt; -</span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s0">expressionRanges = [[decodeInteger(reader, </span><span class="s4">0</span><span class="s0">)]];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = -</span><span class="s4">1</span><span class="s0">; i &gt; expressionsCount; i--) {</span>
              <span class="s1">const </span><span class="s0">prevBl = bindingLine;</span>
              <span class="s0">bindingLine = decodeInteger(reader, bindingLine);</span>
              <span class="s0">bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : </span><span class="s4">0</span><span class="s0">);</span>
              <span class="s1">const </span><span class="s0">expression = decodeInteger(reader, </span><span class="s4">0</span><span class="s0">);</span>
              <span class="s0">expressionRanges.push([expression, bindingLine, bindingColumn]);</span>
            <span class="s0">}</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">expressionRanges = [[expressionsCount]];</span>
          <span class="s0">}</span>
          <span class="s0">bindings.push(expressionRanges);</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(hasMoreVlq(reader, semi));</span>
      <span class="s0">}</span>
      <span class="s0">range.bindings = bindings;</span>
      <span class="s0">ranges.push(range);</span>
      <span class="s0">stack.push(range);</span>
    <span class="s0">}</span>
    <span class="s0">genLine++;</span>
    <span class="s0">reader.pos = semi + </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">while </span><span class="s0">(reader.pos &lt; length);</span>
  <span class="s1">return </span><span class="s0">ranges;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">encodeGeneratedRanges(ranges) {</span>
  <span class="s1">if </span><span class="s0">(ranges.length === </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
  <span class="s1">const </span><span class="s0">writer = </span><span class="s1">new </span><span class="s0">StringWriter();</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; ranges.length; ) {</span>
    <span class="s0">i = _encodeGeneratedRanges(ranges, i, writer, [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">]);</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">writer.flush();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">_encodeGeneratedRanges(ranges, index, writer, state) {</span>
  <span class="s1">const </span><span class="s0">range = ranges[index];</span>
  <span class="s1">const </span><span class="s0">{</span>
    <span class="s4">0</span><span class="s0">: startLine,</span>
    <span class="s4">1</span><span class="s0">: startColumn,</span>
    <span class="s4">2</span><span class="s0">: endLine,</span>
    <span class="s4">3</span><span class="s0">: endColumn,</span>
    <span class="s0">isScope,</span>
    <span class="s0">callsite,</span>
    <span class="s0">bindings</span>
  <span class="s0">} = range;</span>
  <span class="s1">if </span><span class="s0">(state[</span><span class="s4">0</span><span class="s0">] &lt; startLine) {</span>
    <span class="s0">catchupLine(writer, state[</span><span class="s4">0</span><span class="s0">], startLine);</span>
    <span class="s0">state[</span><span class="s4">0</span><span class="s0">] = startLine;</span>
    <span class="s0">state[</span><span class="s4">1</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(index &gt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">writer.write(comma);</span>
  <span class="s0">}</span>
  <span class="s0">state[</span><span class="s4">1</span><span class="s0">] = encodeInteger(writer, range[</span><span class="s4">1</span><span class="s0">], state[</span><span class="s4">1</span><span class="s0">]);</span>
  <span class="s1">const </span><span class="s0">fields = (range.length === </span><span class="s4">6 </span><span class="s0">? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">) | (callsite ? </span><span class="s4">2 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">) | (isScope ? </span><span class="s4">4 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s0">encodeInteger(writer, fields, </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s1">if </span><span class="s0">(range.length === </span><span class="s4">6</span><span class="s0">) {</span>
    <span class="s1">const </span><span class="s0">{ </span><span class="s4">4</span><span class="s0">: sourcesIndex, </span><span class="s4">5</span><span class="s0">: scopesIndex } = range;</span>
    <span class="s1">if </span><span class="s0">(sourcesIndex !== state[</span><span class="s4">2</span><span class="s0">]) {</span>
      <span class="s0">state[</span><span class="s4">3</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">state[</span><span class="s4">2</span><span class="s0">] = encodeInteger(writer, sourcesIndex, state[</span><span class="s4">2</span><span class="s0">]);</span>
    <span class="s0">state[</span><span class="s4">3</span><span class="s0">] = encodeInteger(writer, scopesIndex, state[</span><span class="s4">3</span><span class="s0">]);</span>
  <span class="s0">}</span>
  <span class="s1">if </span><span class="s0">(callsite) {</span>
    <span class="s1">const </span><span class="s0">{ </span><span class="s4">0</span><span class="s0">: sourcesIndex, </span><span class="s4">1</span><span class="s0">: callLine, </span><span class="s4">2</span><span class="s0">: callColumn } = range.callsite;</span>
    <span class="s1">if </span><span class="s0">(sourcesIndex !== state[</span><span class="s4">4</span><span class="s0">]) {</span>
      <span class="s0">state[</span><span class="s4">5</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">state[</span><span class="s4">6</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(callLine !== state[</span><span class="s4">5</span><span class="s0">]) {</span>
      <span class="s0">state[</span><span class="s4">6</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">state[</span><span class="s4">4</span><span class="s0">] = encodeInteger(writer, sourcesIndex, state[</span><span class="s4">4</span><span class="s0">]);</span>
    <span class="s0">state[</span><span class="s4">5</span><span class="s0">] = encodeInteger(writer, callLine, state[</span><span class="s4">5</span><span class="s0">]);</span>
    <span class="s0">state[</span><span class="s4">6</span><span class="s0">] = encodeInteger(writer, callColumn, state[</span><span class="s4">6</span><span class="s0">]);</span>
  <span class="s0">}</span>
  <span class="s1">if </span><span class="s0">(bindings) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">binding of bindings) {</span>
      <span class="s1">if </span><span class="s0">(binding.length &gt; </span><span class="s4">1</span><span class="s0">) encodeInteger(writer, -binding.length, </span><span class="s4">0</span><span class="s0">);</span>
      <span class="s1">const </span><span class="s0">expression = binding[</span><span class="s4">0</span><span class="s0">][</span><span class="s4">0</span><span class="s0">];</span>
      <span class="s0">encodeInteger(writer, expression, </span><span class="s4">0</span><span class="s0">);</span>
      <span class="s1">let </span><span class="s0">bindingStartLine = startLine;</span>
      <span class="s1">let </span><span class="s0">bindingStartColumn = startColumn;</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; binding.length; i++) {</span>
        <span class="s1">const </span><span class="s0">expRange = binding[i];</span>
        <span class="s0">bindingStartLine = encodeInteger(writer, expRange[</span><span class="s4">1</span><span class="s0">], bindingStartLine);</span>
        <span class="s0">bindingStartColumn = encodeInteger(writer, expRange[</span><span class="s4">2</span><span class="s0">], bindingStartColumn);</span>
        <span class="s0">encodeInteger(writer, expRange[</span><span class="s4">0</span><span class="s0">], </span><span class="s4">0</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s1">for </span><span class="s0">(index++; index &lt; ranges.length; ) {</span>
    <span class="s1">const </span><span class="s0">next = ranges[index];</span>
    <span class="s1">const </span><span class="s0">{ </span><span class="s4">0</span><span class="s0">: l, </span><span class="s4">1</span><span class="s0">: c } = next;</span>
    <span class="s1">if </span><span class="s0">(l &gt; endLine || l === endLine &amp;&amp; c &gt;= endColumn) {</span>
      <span class="s1">break</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">index = _encodeGeneratedRanges(ranges, index, writer, state);</span>
  <span class="s0">}</span>
  <span class="s1">if </span><span class="s0">(state[</span><span class="s4">0</span><span class="s0">] &lt; endLine) {</span>
    <span class="s0">catchupLine(writer, state[</span><span class="s4">0</span><span class="s0">], endLine);</span>
    <span class="s0">state[</span><span class="s4">0</span><span class="s0">] = endLine;</span>
    <span class="s0">state[</span><span class="s4">1</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">writer.write(comma);</span>
  <span class="s0">}</span>
  <span class="s0">state[</span><span class="s4">1</span><span class="s0">] = encodeInteger(writer, endColumn, state[</span><span class="s4">1</span><span class="s0">]);</span>
  <span class="s1">return </span><span class="s0">index;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">catchupLine(writer, lastLine, line) {</span>
  <span class="s1">do </span><span class="s0">{</span>
    <span class="s0">writer.write(semicolon);</span>
  <span class="s0">} </span><span class="s1">while </span><span class="s0">(++lastLine &lt; line);</span>
<span class="s0">}</span>

<span class="s3">// src/sourcemap-codec.ts</span>
<span class="s1">function </span><span class="s0">decode(mappings) {</span>
  <span class="s1">const </span><span class="s0">{ length } = mappings;</span>
  <span class="s1">const </span><span class="s0">reader = </span><span class="s1">new </span><span class="s0">StringReader(mappings);</span>
  <span class="s1">const </span><span class="s0">decoded = [];</span>
  <span class="s1">let </span><span class="s0">genColumn = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">sourcesIndex = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">sourceLine = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">sourceColumn = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">namesIndex = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">do </span><span class="s0">{</span>
    <span class="s1">const </span><span class="s0">semi = reader.indexOf(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">line = [];</span>
    <span class="s1">let </span><span class="s0">sorted = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">lastCol = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">genColumn = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">while </span><span class="s0">(reader.pos &lt; semi) {</span>
      <span class="s1">let </span><span class="s0">seg;</span>
      <span class="s0">genColumn = decodeInteger(reader, genColumn);</span>
      <span class="s1">if </span><span class="s0">(genColumn &lt; lastCol) sorted = </span><span class="s1">false</span><span class="s0">;</span>
      <span class="s0">lastCol = genColumn;</span>
      <span class="s1">if </span><span class="s0">(hasMoreVlq(reader, semi)) {</span>
        <span class="s0">sourcesIndex = decodeInteger(reader, sourcesIndex);</span>
        <span class="s0">sourceLine = decodeInteger(reader, sourceLine);</span>
        <span class="s0">sourceColumn = decodeInteger(reader, sourceColumn);</span>
        <span class="s1">if </span><span class="s0">(hasMoreVlq(reader, semi)) {</span>
          <span class="s0">namesIndex = decodeInteger(reader, namesIndex);</span>
          <span class="s0">seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s0">seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">seg = [genColumn];</span>
      <span class="s0">}</span>
      <span class="s0">line.push(seg);</span>
      <span class="s0">reader.pos++;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!sorted) sort(line);</span>
    <span class="s0">decoded.push(line);</span>
    <span class="s0">reader.pos = semi + </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">while </span><span class="s0">(reader.pos &lt;= length);</span>
  <span class="s1">return </span><span class="s0">decoded;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sort(line) {</span>
  <span class="s0">line.sort(sortComparator);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sortComparator(a, b) {</span>
  <span class="s1">return </span><span class="s0">a[</span><span class="s4">0</span><span class="s0">] - b[</span><span class="s4">0</span><span class="s0">];</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">encode(decoded) {</span>
  <span class="s1">const </span><span class="s0">writer = </span><span class="s1">new </span><span class="s0">StringWriter();</span>
  <span class="s1">let </span><span class="s0">sourcesIndex = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">sourceLine = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">sourceColumn = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">let </span><span class="s0">namesIndex = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; decoded.length; i++) {</span>
    <span class="s1">const </span><span class="s0">line = decoded[i];</span>
    <span class="s1">if </span><span class="s0">(i &gt; </span><span class="s4">0</span><span class="s0">) writer.write(semicolon);</span>
    <span class="s1">if </span><span class="s0">(line.length === </span><span class="s4">0</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">genColumn = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">; j &lt; line.length; j++) {</span>
      <span class="s1">const </span><span class="s0">segment = line[j];</span>
      <span class="s1">if </span><span class="s0">(j &gt; </span><span class="s4">0</span><span class="s0">) writer.write(comma);</span>
      <span class="s0">genColumn = encodeInteger(writer, segment[</span><span class="s4">0</span><span class="s0">], genColumn);</span>
      <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s4">1</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
      <span class="s0">sourcesIndex = encodeInteger(writer, segment[</span><span class="s4">1</span><span class="s0">], sourcesIndex);</span>
      <span class="s0">sourceLine = encodeInteger(writer, segment[</span><span class="s4">2</span><span class="s0">], sourceLine);</span>
      <span class="s0">sourceColumn = encodeInteger(writer, segment[</span><span class="s4">3</span><span class="s0">], sourceColumn);</span>
      <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s4">4</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
      <span class="s0">namesIndex = encodeInteger(writer, segment[</span><span class="s4">4</span><span class="s0">], namesIndex);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">writer.flush();</span>
<span class="s0">}</span>
<span class="s0">}));</span>
<span class="s3">//# sourceMappingURL=sourcemap-codec.umd.js.map</span>
</pre>
</body>
</html>