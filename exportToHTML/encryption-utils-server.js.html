<html>
<head>
<title>encryption-utils-server.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
encryption-utils-server.js</font>
</center></td></tr></table>
<pre><span class="s0">// This file should never be bundled into application's runtime code and should</span>
<span class="s0">// stay in the Next.js server.</span>
<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;generateEncryptionKeyBase64&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">generateEncryptionKeyBase64;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">_path = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_fs = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_cachedir = require(</span><span class="s2">&quot;../cache-dir&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_encryptionutils = require(</span><span class="s2">&quot;./encryption-utils&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s3">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s3">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">// Keep the key in memory as it should never change during the lifetime of the server in</span>
<span class="s0">// both development and production.</span>
<span class="s3">let </span><span class="s1">__next_encryption_key_generation_promise = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">CONFIG_FILE = </span><span class="s2">'.rscinfo'</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">ENCRYPTION_KEY = </span><span class="s2">'encryption.key'</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">ENCRYPTION_EXPIRE_AT = </span><span class="s2">'encryption.expire_at'</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">EXPIRATION = </span><span class="s4">1000 </span><span class="s1">* </span><span class="s4">60 </span><span class="s1">* </span><span class="s4">60 </span><span class="s1">* </span><span class="s4">24 </span><span class="s1">* </span><span class="s4">14 </span><span class="s0">// 14 days</span>
<span class="s1">;</span>
<span class="s1">async </span><span class="s3">function </span><span class="s1">writeCache(distDir, configValue) {</span>
    <span class="s3">const </span><span class="s1">cacheBaseDir = (</span><span class="s4">0</span><span class="s1">, _cachedir.getStorageDirectory)(distDir);</span>
    <span class="s3">if </span><span class="s1">(!cacheBaseDir) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">configPath = _path.default.join(cacheBaseDir, CONFIG_FILE);</span>
    <span class="s3">if </span><span class="s1">(!_fs.default.existsSync(cacheBaseDir)) {</span>
        <span class="s3">await </span><span class="s1">_fs.default.promises.mkdir(cacheBaseDir, {</span>
            <span class="s1">recursive: </span><span class="s3">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">await </span><span class="s1">_fs.default.promises.writeFile(configPath, JSON.stringify({</span>
        <span class="s1">[ENCRYPTION_KEY]: configValue,</span>
        <span class="s1">[ENCRYPTION_EXPIRE_AT]: Date.now() + EXPIRATION</span>
    <span class="s1">}));</span>
<span class="s1">}</span>
<span class="s0">// This utility is used to get a key for the cache directory. If the</span>
<span class="s0">// key is not present, it will generate a new one and store it in the</span>
<span class="s0">// cache directory inside dist.</span>
<span class="s0">// The key will also expire after a certain amount of time. Once it</span>
<span class="s0">// expires, a new one will be generated.</span>
<span class="s0">// During the lifetime of the server, it will be reused and never refreshed.</span>
<span class="s1">async </span><span class="s3">function </span><span class="s1">loadOrGenerateKey(distDir, isBuild, generateKey) {</span>
    <span class="s3">const </span><span class="s1">cacheBaseDir = (</span><span class="s4">0</span><span class="s1">, _cachedir.getStorageDirectory)(distDir);</span>
    <span class="s3">if </span><span class="s1">(!cacheBaseDir) {</span>
        <span class="s0">// There's no persistent storage available. We generate a new key.</span>
        <span class="s0">// This also covers development time.</span>
        <span class="s3">return await </span><span class="s1">generateKey();</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">configPath = _path.default.join(cacheBaseDir, CONFIG_FILE);</span>
    <span class="s1">async </span><span class="s3">function </span><span class="s1">hasCachedKey() {</span>
        <span class="s3">if </span><span class="s1">(!_fs.default.existsSync(configPath)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">const </span><span class="s1">config = JSON.parse(</span><span class="s3">await </span><span class="s1">_fs.default.promises.readFile(configPath, </span><span class="s2">'utf8'</span><span class="s1">));</span>
            <span class="s3">if </span><span class="s1">(!config) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">config[ENCRYPTION_KEY] !== </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">config[ENCRYPTION_EXPIRE_AT] !== </span><span class="s2">'number'</span><span class="s1">) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">// For build time, we need to rotate the key if it's expired. Otherwise</span>
            <span class="s0">// (next start) we have to keep the key as it is so the runtime key matches</span>
            <span class="s0">// the build time key.</span>
            <span class="s3">if </span><span class="s1">(isBuild &amp;&amp; config[ENCRYPTION_EXPIRE_AT] &lt; Date.now()) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">cachedKey = config[ENCRYPTION_KEY];</span>
            <span class="s0">// If encryption key is provided via env, and it's not same as valid cache,</span>
            <span class="s0">//  we should not use the cached key and respect the env key.</span>
            <span class="s3">if </span><span class="s1">(cachedKey &amp;&amp; process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY &amp;&amp; cachedKey !== process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">cachedKey;</span>
        <span class="s1">} </span><span class="s3">catch  </span><span class="s1">{</span>
            <span class="s0">// Broken config file. We should generate a new key and overwrite it.</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">maybeValidKey = </span><span class="s3">await </span><span class="s1">hasCachedKey();</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">maybeValidKey === </span><span class="s2">'string'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">maybeValidKey;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">key = </span><span class="s3">await </span><span class="s1">generateKey();</span>
    <span class="s3">await </span><span class="s1">writeCache(distDir, key);</span>
    <span class="s3">return </span><span class="s1">key;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s3">function </span><span class="s1">generateEncryptionKeyBase64({ isBuild, distDir }) {</span>
    <span class="s0">// This avoids it being generated multiple times in parallel.</span>
    <span class="s3">if </span><span class="s1">(!__next_encryption_key_generation_promise) {</span>
        <span class="s1">__next_encryption_key_generation_promise = loadOrGenerateKey(distDir, isBuild, async ()=&gt;{</span>
            <span class="s3">const </span><span class="s1">providedKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY;</span>
            <span class="s3">if </span><span class="s1">(providedKey) {</span>
                <span class="s3">return </span><span class="s1">providedKey;</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">key = </span><span class="s3">await </span><span class="s1">crypto.subtle.generateKey({</span>
                <span class="s1">name: </span><span class="s2">'AES-GCM'</span><span class="s1">,</span>
                <span class="s1">length: </span><span class="s4">256</span>
            <span class="s1">}, </span><span class="s3">true</span><span class="s1">, [</span>
                <span class="s2">'encrypt'</span><span class="s1">,</span>
                <span class="s2">'decrypt'</span>
            <span class="s1">]);</span>
            <span class="s3">const </span><span class="s1">exported = </span><span class="s3">await </span><span class="s1">crypto.subtle.exportKey(</span><span class="s2">'raw'</span><span class="s1">, key);</span>
            <span class="s3">return </span><span class="s1">btoa((</span><span class="s4">0</span><span class="s1">, _encryptionutils.arrayBufferToString)(exported));</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">__next_encryption_key_generation_promise;</span>
<span class="s1">}</span>

<span class="s0">//# sourceMappingURL=encryption-utils-server.js.map</span></pre>
</body>
</html>