<html>
<head>
<title>getParserServices.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
getParserServices.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.getParserServices = getParserServices;</span>
<span class="s2">const </span><span class="s1">parserSeemsToBeTSESLint_1 = require(</span><span class="s0">&quot;./parserSeemsToBeTSESLint&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ERROR_MESSAGE_REQUIRES_PARSER_SERVICES = </span><span class="s0">&quot;You have used a rule which requires type information, but don't have parserOptions set to generate type information for this file. See https://typescript-eslint.io/getting-started/typed-linting for enabling linting with type information.&quot;</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">ERROR_MESSAGE_UNKNOWN_PARSER = </span><span class="s0">'Note: detected a parser other than @typescript-eslint/parser. Make sure the parser is configured to forward &quot;parserOptions.project&quot; to @typescript-eslint/parser.'</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">getParserServices(context, allowWithoutFullTypeInformation = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">parser = context.parserPath || context.languageOptions.parser?.meta?.name;</span>
    <span class="s3">// This check is unnecessary if the user is using the latest version of our parser.</span>
    <span class="s3">//</span>
    <span class="s3">// However the world isn't perfect:</span>
    <span class="s3">// - Users often use old parser versions.</span>
    <span class="s3">//   Old versions of the parser would not return any parserServices unless parserOptions.project was set.</span>
    <span class="s3">// - Users sometimes use parsers that aren't @typescript-eslint/parser</span>
    <span class="s3">//   Other parsers won't return the parser services we expect (if they return any at all).</span>
    <span class="s3">//</span>
    <span class="s3">// This check allows us to handle bad user setups whilst providing a nice user-facing</span>
    <span class="s3">// error message explaining the problem.</span>
    <span class="s2">if </span><span class="s1">(context.sourceCode.parserServices?.esTreeNodeToTSNodeMap == </span><span class="s2">null </span><span class="s1">||</span>
        <span class="s1">context.sourceCode.parserServices.tsNodeToESTreeNodeMap == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">throwError(parser);</span>
    <span class="s1">}</span>
    <span class="s3">// if a rule requires full type information, then hard fail if it doesn't exist</span>
    <span class="s3">// this forces the user to supply parserOptions.project</span>
    <span class="s2">if </span><span class="s1">(context.sourceCode.parserServices.program == </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!allowWithoutFullTypeInformation) {</span>
        <span class="s1">throwError(parser);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">context.sourceCode.parserServices;</span>
<span class="s1">}</span>
<span class="s3">/* eslint-enable @typescript-eslint/unified-signatures */</span>
<span class="s2">function </span><span class="s1">throwError(parser) {</span>
    <span class="s2">const </span><span class="s1">messages = [</span>
        <span class="s1">ERROR_MESSAGE_REQUIRES_PARSER_SERVICES,</span>
        <span class="s0">`Parser: </span><span class="s1">${parser || </span><span class="s0">'(unknown)'</span><span class="s1">}</span><span class="s0">`</span><span class="s1">,</span>
        <span class="s1">!(</span><span class="s4">0</span><span class="s1">, parserSeemsToBeTSESLint_1.parserSeemsToBeTSESLint)(parser) &amp;&amp; ERROR_MESSAGE_UNKNOWN_PARSER,</span>
    <span class="s1">].filter(Boolean);</span>
    <span class="s2">throw new </span><span class="s1">Error(messages.join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">));</span>
<span class="s1">}</span>
</pre>
</body>
</html>