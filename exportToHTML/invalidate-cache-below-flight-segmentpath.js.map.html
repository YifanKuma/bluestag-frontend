<html>
<head>
<title>invalidate-cache-below-flight-segmentpath.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
invalidate-cache-below-flight-segmentpath.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { FlightSegmentPath } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import { getNextFlightSegmentPath } from '../../flight-data-helpers'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Fill cache up to the end of the flightSegmentPath, invalidating anything below it.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function invalidateCacheBelowFlightSegmentPath(</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const isLastEntry = flightSegmentPath.length &lt;= 2</span><span class="s3">\n  </span><span class="s1">const [parallelRouteKey, segment] = flightSegmentPath</span><span class="s3">\n\n  </span><span class="s1">const cacheKey = createRouterCacheKey(segment)</span><span class="s3">\n\n  </span><span class="s1">const existingChildSegmentMap =</span><span class="s3">\n    </span><span class="s1">existingCache.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n\n  </span><span class="s1">if (!existingChildSegmentMap) {</span><span class="s3">\n    </span><span class="s1">// Bailout because the existing cache does not have the path to the leaf node</span><span class="s3">\n    </span><span class="s1">// Will trigger lazy fetch in layout-router because of missing segment</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n  </span><span class="s1">if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {</span><span class="s3">\n    </span><span class="s1">childSegmentMap = new Map(existingChildSegmentMap)</span><span class="s3">\n    </span><span class="s1">newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// In case of last entry don't copy further down.</span><span class="s3">\n  </span><span class="s1">if (isLastEntry) {</span><span class="s3">\n    </span><span class="s1">childSegmentMap.delete(cacheKey)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)</span><span class="s3">\n  </span><span class="s1">let childCacheNode = childSegmentMap.get(cacheKey)</span><span class="s3">\n\n  </span><span class="s1">if (!childCacheNode || !existingChildCacheNode) {</span><span class="s3">\n    </span><span class="s1">// Bailout because the existing cache does not have the path to the leaf node</span><span class="s3">\n    </span><span class="s1">// Will trigger lazy fetch in layout-router because of missing segment</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (childCacheNode === existingChildCacheNode) {</span><span class="s3">\n    </span><span class="s1">childCacheNode = {</span><span class="s3">\n      </span><span class="s1">lazyData: childCacheNode.lazyData,</span><span class="s3">\n      </span><span class="s1">rsc: childCacheNode.rsc,</span><span class="s3">\n      </span><span class="s1">prefetchRsc: childCacheNode.prefetchRsc,</span><span class="s3">\n      </span><span class="s1">head: childCacheNode.head,</span><span class="s3">\n      </span><span class="s1">prefetchHead: childCacheNode.prefetchHead,</span><span class="s3">\n      </span><span class="s1">parallelRoutes: new Map(childCacheNode.parallelRoutes),</span><span class="s3">\n    </span><span class="s1">} as CacheNode</span><span class="s3">\n    </span><span class="s1">childSegmentMap.set(cacheKey, childCacheNode)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">invalidateCacheBelowFlightSegmentPath(</span><span class="s3">\n    </span><span class="s1">childCacheNode,</span><span class="s3">\n    </span><span class="s1">existingChildCacheNode,</span><span class="s3">\n    </span><span class="s1">getNextFlightSegmentPath(flightSegmentPath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;invalidateCacheBelowFlightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;childCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFlightSegmentPath&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAQgBA;;;eAAAA;;;sCANqB;mCACI;AAKlC,SAASA,sCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAChD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IAEpC,MAAMK,WAAWC,IAAAA,0CAAoB,EAACF;IAEtC,MAAMG,0BACJR,cAAcS,cAAc,CAACC,GAAG,CAACN;IAEnC,IAAI,CAACI,yBAAyB;QAC5B,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIG,kBAAkBZ,SAASU,cAAc,CAACC,GAAG,CAACN;IAClD,IAAI,CAACO,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BT,SAASU,cAAc,CAACI,GAAG,CAACT,kBAAkBO;IAChD;IAEA,iDAAiD;IACjD,IAAIT,aAAa;QACfS,gBAAgBG,MAAM,CAACR;QACvB;IACF;IAEA,MAAMS,yBAAyBP,wBAAwBE,GAAG,CAACJ;IAC3D,IAAIU,iBAAiBL,gBAAgBD,GAAG,CAACJ;IAEzC,IAAI,CAACU,kBAAkB,CAACD,wBAAwB;QAC9C,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIC,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCZ,gBAAgB,IAAIG,IAAII,eAAeP,cAAc;QACvD;QACAE,gBAAgBE,GAAG,CAACP,UAAUU;IAChC;IAEAlB,sCACEkB,gBACAD,wBACAO,IAAAA,2CAAwB,EAACrB;AAE7B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>