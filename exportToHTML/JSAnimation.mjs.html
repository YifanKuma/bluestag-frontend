<html>
<head>
<title>JSAnimation.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
JSAnimation.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ invariant, pipe, clamp, millisecondsToSeconds, secondsToMilliseconds } from </span><span class="s2">'motion-utils'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ time } from </span><span class="s2">'../frameloop/sync-time.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ activeAnimations } from </span><span class="s2">'../stats/animation-count.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ mix } from </span><span class="s2">'../utils/mix/index.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ frameloopDriver } from </span><span class="s2">'./drivers/frame.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ inertia } from </span><span class="s2">'./generators/inertia.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ keyframes } from </span><span class="s2">'./generators/keyframes.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ calcGeneratorDuration } from </span><span class="s2">'./generators/utils/calc-duration.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ getFinalKeyframe } from </span><span class="s2">'./keyframes/get-final.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ replaceTransitionType } from </span><span class="s2">'./utils/replace-transition-type.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ WithPromise } from </span><span class="s2">'./utils/WithPromise.mjs'</span><span class="s1">;</span>

<span class="s0">const </span><span class="s1">percentToProgress = (percent) =&gt; percent / </span><span class="s3">100</span><span class="s1">;</span>
<span class="s0">class </span><span class="s1">JSAnimation </span><span class="s0">extends </span><span class="s1">WithPromise {</span>
    <span class="s1">constructor(options) {</span>
        <span class="s0">super</span><span class="s1">();</span>
        <span class="s0">this</span><span class="s1">.state = </span><span class="s2">&quot;idle&quot;</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.startTime = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.isStopped = </span><span class="s0">false</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The current time of the animation.</span>
         <span class="s4">*/</span>
        <span class="s0">this</span><span class="s1">.currentTime = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The time at which the animation was paused.</span>
         <span class="s4">*/</span>
        <span class="s0">this</span><span class="s1">.holdTime = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.</span>
         <span class="s4">*/</span>
        <span class="s0">this</span><span class="s1">.playbackSpeed = </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* This method is bound to the instance to fix a pattern where</span>
         <span class="s4">* animation.stop is returned as a reference from a useEffect.</span>
         <span class="s4">*/</span>
        <span class="s0">this</span><span class="s1">.stop = () =&gt; {</span>
            <span class="s0">const </span><span class="s1">{ motionValue } = </span><span class="s0">this</span><span class="s1">.options;</span>
            <span class="s0">if </span><span class="s1">(motionValue &amp;&amp; motionValue.updatedAt !== time.now()) {</span>
                <span class="s0">this</span><span class="s1">.tick(time.now());</span>
            <span class="s1">}</span>
            <span class="s0">this</span><span class="s1">.isStopped = </span><span class="s0">true</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.state === </span><span class="s2">&quot;idle&quot;</span><span class="s1">)</span>
                <span class="s0">return</span><span class="s1">;</span>
            <span class="s0">this</span><span class="s1">.teardown();</span>
            <span class="s0">this</span><span class="s1">.options.onStop?.();</span>
        <span class="s1">};</span>
        <span class="s1">activeAnimations.mainThread++;</span>
        <span class="s0">this</span><span class="s1">.options = options;</span>
        <span class="s0">this</span><span class="s1">.initAnimation();</span>
        <span class="s0">this</span><span class="s1">.play();</span>
        <span class="s0">if </span><span class="s1">(options.autoplay === </span><span class="s0">false</span><span class="s1">)</span>
            <span class="s0">this</span><span class="s1">.pause();</span>
    <span class="s1">}</span>
    <span class="s1">initAnimation() {</span>
        <span class="s0">const </span><span class="s1">{ options } = </span><span class="s0">this</span><span class="s1">;</span>
        <span class="s1">replaceTransitionType(options);</span>
        <span class="s0">const </span><span class="s1">{ type = keyframes, repeat = </span><span class="s3">0</span><span class="s1">, repeatDelay = </span><span class="s3">0</span><span class="s1">, repeatType, velocity = </span><span class="s3">0</span><span class="s1">, } = options;</span>
        <span class="s0">let </span><span class="s1">{ keyframes: keyframes$1 } = options;</span>
        <span class="s0">const </span><span class="s1">generatorFactory = type || keyframes;</span>
        <span class="s0">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">&quot;production&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s1">generatorFactory !== keyframes) {</span>
            <span class="s1">invariant(keyframes$1.length &lt;= </span><span class="s3">2</span><span class="s1">, </span><span class="s2">`Only two keyframes currently supported with spring and inertia animations. Trying to animate </span><span class="s1">${keyframes$1}</span><span class="s2">`</span><span class="s1">, </span><span class="s2">&quot;spring-two-frames&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(generatorFactory !== keyframes &amp;&amp;</span>
            <span class="s0">typeof </span><span class="s1">keyframes$1[</span><span class="s3">0</span><span class="s1">] !== </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[</span><span class="s3">0</span><span class="s1">], keyframes$1[</span><span class="s3">1</span><span class="s1">]));</span>
            <span class="s1">keyframes$1 = [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">100</span><span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">generator = generatorFactory({ ...options, keyframes: keyframes$1 });</span>
        <span class="s4">/**</span>
         <span class="s4">* If we have a mirror repeat type we need to create a second generator that outputs the</span>
         <span class="s4">* mirrored (not reversed) animation and later ping pong between the two generators.</span>
         <span class="s4">*/</span>
        <span class="s0">if </span><span class="s1">(repeatType === </span><span class="s2">&quot;mirror&quot;</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.mirroredGenerator = generatorFactory({</span>
                <span class="s1">...options,</span>
                <span class="s1">keyframes: [...keyframes$1].reverse(),</span>
                <span class="s1">velocity: -velocity,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* If duration is undefined and we have repeat options,</span>
         <span class="s4">* we need to calculate a duration from the generator.</span>
         <span class="s4">*</span>
         <span class="s4">* We set it to the generator itself to cache the duration.</span>
         <span class="s4">* Any timeline resolver will need to have already precalculated</span>
         <span class="s4">* the duration by this step.</span>
         <span class="s4">*/</span>
        <span class="s0">if </span><span class="s1">(generator.calculatedDuration === </span><span class="s0">null</span><span class="s1">) {</span>
            <span class="s1">generator.calculatedDuration = calcGeneratorDuration(generator);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">{ calculatedDuration } = generator;</span>
        <span class="s0">this</span><span class="s1">.calculatedDuration = calculatedDuration;</span>
        <span class="s0">this</span><span class="s1">.resolvedDuration = calculatedDuration + repeatDelay;</span>
        <span class="s0">this</span><span class="s1">.totalDuration = </span><span class="s0">this</span><span class="s1">.resolvedDuration * (repeat + </span><span class="s3">1</span><span class="s1">) - repeatDelay;</span>
        <span class="s0">this</span><span class="s1">.generator = generator;</span>
    <span class="s1">}</span>
    <span class="s1">updateTime(timestamp) {</span>
        <span class="s0">const </span><span class="s1">animationTime = Math.round(timestamp - </span><span class="s0">this</span><span class="s1">.startTime) * </span><span class="s0">this</span><span class="s1">.playbackSpeed;</span>
        <span class="s4">// Update currentTime</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.holdTime !== </span><span class="s0">null</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.currentTime = </span><span class="s0">this</span><span class="s1">.holdTime;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s4">// Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =</span>
            <span class="s4">// 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for</span>
            <span class="s4">// example.</span>
            <span class="s0">this</span><span class="s1">.currentTime = animationTime;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">tick(timestamp, sample = </span><span class="s0">false</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">{ generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = </span><span class="s0">this</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.startTime === </span><span class="s0">null</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">generator.next(</span><span class="s3">0</span><span class="s1">);</span>
        <span class="s0">const </span><span class="s1">{ delay = </span><span class="s3">0</span><span class="s1">, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = </span><span class="s0">this</span><span class="s1">.options;</span>
        <span class="s4">/**</span>
         <span class="s4">* requestAnimationFrame timestamps can come through as lower than</span>
         <span class="s4">* the startTime as set by performance.now(). Here we prevent this,</span>
         <span class="s4">* though in the future it could be possible to make setting startTime</span>
         <span class="s4">* a pending operation that gets resolved here.</span>
         <span class="s4">*/</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.speed &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.startTime = Math.min(</span><span class="s0">this</span><span class="s1">.startTime, timestamp);</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.speed &lt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.startTime = Math.min(timestamp - totalDuration / </span><span class="s0">this</span><span class="s1">.speed, </span><span class="s0">this</span><span class="s1">.startTime);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(sample) {</span>
            <span class="s0">this</span><span class="s1">.currentTime = timestamp;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">.updateTime(timestamp);</span>
        <span class="s1">}</span>
        <span class="s4">// Rebase on delay</span>
        <span class="s0">const </span><span class="s1">timeWithoutDelay = </span><span class="s0">this</span><span class="s1">.currentTime - delay * (</span><span class="s0">this</span><span class="s1">.playbackSpeed &gt;= </span><span class="s3">0 </span><span class="s1">? </span><span class="s3">1 </span><span class="s1">: -</span><span class="s3">1</span><span class="s1">);</span>
        <span class="s0">const </span><span class="s1">isInDelayPhase = </span><span class="s0">this</span><span class="s1">.playbackSpeed &gt;= </span><span class="s3">0</span>
            <span class="s1">? timeWithoutDelay &lt; </span><span class="s3">0</span>
            <span class="s1">: timeWithoutDelay &gt; totalDuration;</span>
        <span class="s0">this</span><span class="s1">.currentTime = Math.max(timeWithoutDelay, </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s4">// If this animation has finished, set the current time  to the total duration.</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.state === </span><span class="s2">&quot;finished&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">this</span><span class="s1">.holdTime === </span><span class="s0">null</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.currentTime = totalDuration;</span>
        <span class="s1">}</span>
        <span class="s0">let </span><span class="s1">elapsed = </span><span class="s0">this</span><span class="s1">.currentTime;</span>
        <span class="s0">let </span><span class="s1">frameGenerator = generator;</span>
        <span class="s0">if </span><span class="s1">(repeat) {</span>
            <span class="s4">/**</span>
             <span class="s4">* Get the current progress (0-1) of the animation. If t is &gt;</span>
             <span class="s4">* than duration we'll get values like 2.5 (midway through the</span>
             <span class="s4">* third iteration)</span>
             <span class="s4">*/</span>
            <span class="s0">const </span><span class="s1">progress = Math.min(</span><span class="s0">this</span><span class="s1">.currentTime, totalDuration) / resolvedDuration;</span>
            <span class="s4">/**</span>
             <span class="s4">* Get the current iteration (0 indexed). For instance the floor of</span>
             <span class="s4">* 2.5 is 2.</span>
             <span class="s4">*/</span>
            <span class="s0">let </span><span class="s1">currentIteration = Math.floor(progress);</span>
            <span class="s4">/**</span>
             <span class="s4">* Get the current progress of the iteration by taking the remainder</span>
             <span class="s4">* so 2.5 is 0.5 through iteration 2</span>
             <span class="s4">*/</span>
            <span class="s0">let </span><span class="s1">iterationProgress = progress % </span><span class="s3">1.0</span><span class="s1">;</span>
            <span class="s4">/**</span>
             <span class="s4">* If iteration progress is 1 we count that as the end</span>
             <span class="s4">* of the previous iteration.</span>
             <span class="s4">*/</span>
            <span class="s0">if </span><span class="s1">(!iterationProgress &amp;&amp; progress &gt;= </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">iterationProgress = </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">iterationProgress === </span><span class="s3">1 </span><span class="s1">&amp;&amp; currentIteration--;</span>
            <span class="s1">currentIteration = Math.min(currentIteration, repeat + </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s4">/**</span>
             <span class="s4">* Reverse progress if we're not running in &quot;normal&quot; direction</span>
             <span class="s4">*/</span>
            <span class="s0">const </span><span class="s1">isOddIteration = Boolean(currentIteration % </span><span class="s3">2</span><span class="s1">);</span>
            <span class="s0">if </span><span class="s1">(isOddIteration) {</span>
                <span class="s0">if </span><span class="s1">(repeatType === </span><span class="s2">&quot;reverse&quot;</span><span class="s1">) {</span>
                    <span class="s1">iterationProgress = </span><span class="s3">1 </span><span class="s1">- iterationProgress;</span>
                    <span class="s0">if </span><span class="s1">(repeatDelay) {</span>
                        <span class="s1">iterationProgress -= repeatDelay / resolvedDuration;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(repeatType === </span><span class="s2">&quot;mirror&quot;</span><span class="s1">) {</span>
                    <span class="s1">frameGenerator = mirroredGenerator;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">elapsed = clamp(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">1</span><span class="s1">, iterationProgress) * resolvedDuration;</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* If we're in negative time, set state as the initial keyframe.</span>
         <span class="s4">* This prevents delay: x, duration: 0 animations from finishing</span>
         <span class="s4">* instantly.</span>
         <span class="s4">*/</span>
        <span class="s0">const </span><span class="s1">state = isInDelayPhase</span>
            <span class="s1">? { done: </span><span class="s0">false</span><span class="s1">, value: keyframes[</span><span class="s3">0</span><span class="s1">] }</span>
            <span class="s1">: frameGenerator.next(elapsed);</span>
        <span class="s0">if </span><span class="s1">(mixKeyframes) {</span>
            <span class="s1">state.value = mixKeyframes(state.value);</span>
        <span class="s1">}</span>
        <span class="s0">let </span><span class="s1">{ done } = state;</span>
        <span class="s0">if </span><span class="s1">(!isInDelayPhase &amp;&amp; calculatedDuration !== </span><span class="s0">null</span><span class="s1">) {</span>
            <span class="s1">done =</span>
                <span class="s0">this</span><span class="s1">.playbackSpeed &gt;= </span><span class="s3">0</span>
                    <span class="s1">? </span><span class="s0">this</span><span class="s1">.currentTime &gt;= totalDuration</span>
                    <span class="s1">: </span><span class="s0">this</span><span class="s1">.currentTime &lt;= </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">isAnimationFinished = </span><span class="s0">this</span><span class="s1">.holdTime === </span><span class="s0">null </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(</span><span class="s0">this</span><span class="s1">.state === </span><span class="s2">&quot;finished&quot; </span><span class="s1">|| (</span><span class="s0">this</span><span class="s1">.state === </span><span class="s2">&quot;running&quot; </span><span class="s1">&amp;&amp; done));</span>
        <span class="s4">// TODO: The exception for inertia could be cleaner here</span>
        <span class="s0">if </span><span class="s1">(isAnimationFinished &amp;&amp; type !== inertia) {</span>
            <span class="s1">state.value = getFinalKeyframe(keyframes, </span><span class="s0">this</span><span class="s1">.options, finalKeyframe, </span><span class="s0">this</span><span class="s1">.speed);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(onUpdate) {</span>
            <span class="s1">onUpdate(state.value);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(isAnimationFinished) {</span>
            <span class="s0">this</span><span class="s1">.finish();</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">state;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Allows the returned animation to be awaited or promise-chained. Currently</span>
     <span class="s4">* resolves when the animation finishes at all but in a future update could/should</span>
     <span class="s4">* reject if its cancels.</span>
     <span class="s4">*/</span>
    <span class="s1">then(resolve, reject) {</span>
        <span class="s0">return this</span><span class="s1">.finished.then(resolve, reject);</span>
    <span class="s1">}</span>
    <span class="s1">get duration() {</span>
        <span class="s0">return </span><span class="s1">millisecondsToSeconds(</span><span class="s0">this</span><span class="s1">.calculatedDuration);</span>
    <span class="s1">}</span>
    <span class="s1">get iterationDuration() {</span>
        <span class="s0">const </span><span class="s1">{ delay = </span><span class="s3">0 </span><span class="s1">} = </span><span class="s0">this</span><span class="s1">.options || {};</span>
        <span class="s0">return this</span><span class="s1">.duration + millisecondsToSeconds(delay);</span>
    <span class="s1">}</span>
    <span class="s1">get time() {</span>
        <span class="s0">return </span><span class="s1">millisecondsToSeconds(</span><span class="s0">this</span><span class="s1">.currentTime);</span>
    <span class="s1">}</span>
    <span class="s1">set time(newTime) {</span>
        <span class="s1">newTime = secondsToMilliseconds(newTime);</span>
        <span class="s0">this</span><span class="s1">.currentTime = newTime;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.startTime === </span><span class="s0">null </span><span class="s1">||</span>
            <span class="s0">this</span><span class="s1">.holdTime !== </span><span class="s0">null </span><span class="s1">||</span>
            <span class="s0">this</span><span class="s1">.playbackSpeed === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.holdTime = newTime;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.driver) {</span>
            <span class="s0">this</span><span class="s1">.startTime = </span><span class="s0">this</span><span class="s1">.driver.now() - newTime / </span><span class="s0">this</span><span class="s1">.playbackSpeed;</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.driver?.start(</span><span class="s0">false</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">get speed() {</span>
        <span class="s0">return this</span><span class="s1">.playbackSpeed;</span>
    <span class="s1">}</span>
    <span class="s1">set speed(newSpeed) {</span>
        <span class="s0">this</span><span class="s1">.updateTime(time.now());</span>
        <span class="s0">const </span><span class="s1">hasChanged = </span><span class="s0">this</span><span class="s1">.playbackSpeed !== newSpeed;</span>
        <span class="s0">this</span><span class="s1">.playbackSpeed = newSpeed;</span>
        <span class="s0">if </span><span class="s1">(hasChanged) {</span>
            <span class="s0">this</span><span class="s1">.time = millisecondsToSeconds(</span><span class="s0">this</span><span class="s1">.currentTime);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">play() {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isStopped)</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s0">const </span><span class="s1">{ driver = frameloopDriver, startTime } = </span><span class="s0">this</span><span class="s1">.options;</span>
        <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.driver) {</span>
            <span class="s0">this</span><span class="s1">.driver = driver((timestamp) =&gt; </span><span class="s0">this</span><span class="s1">.tick(timestamp));</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.options.onPlay?.();</span>
        <span class="s0">const </span><span class="s1">now = </span><span class="s0">this</span><span class="s1">.driver.now();</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.state === </span><span class="s2">&quot;finished&quot;</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.updateFinished();</span>
            <span class="s0">this</span><span class="s1">.startTime = now;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.holdTime !== </span><span class="s0">null</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.startTime = now - </span><span class="s0">this</span><span class="s1">.holdTime;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.startTime) {</span>
            <span class="s0">this</span><span class="s1">.startTime = startTime ?? now;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.state === </span><span class="s2">&quot;finished&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">this</span><span class="s1">.speed &lt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.startTime += </span><span class="s0">this</span><span class="s1">.calculatedDuration;</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.holdTime = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* Set playState to running only after we've used it in</span>
         <span class="s4">* the previous logic.</span>
         <span class="s4">*/</span>
        <span class="s0">this</span><span class="s1">.state = </span><span class="s2">&quot;running&quot;</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.driver.start();</span>
    <span class="s1">}</span>
    <span class="s1">pause() {</span>
        <span class="s0">this</span><span class="s1">.state = </span><span class="s2">&quot;paused&quot;</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.updateTime(time.now());</span>
        <span class="s0">this</span><span class="s1">.holdTime = </span><span class="s0">this</span><span class="s1">.currentTime;</span>
    <span class="s1">}</span>
    <span class="s1">complete() {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.state !== </span><span class="s2">&quot;running&quot;</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.play();</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.state = </span><span class="s2">&quot;finished&quot;</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.holdTime = </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">finish() {</span>
        <span class="s0">this</span><span class="s1">.notifyFinished();</span>
        <span class="s0">this</span><span class="s1">.teardown();</span>
        <span class="s0">this</span><span class="s1">.state = </span><span class="s2">&quot;finished&quot;</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.options.onComplete?.();</span>
    <span class="s1">}</span>
    <span class="s1">cancel() {</span>
        <span class="s0">this</span><span class="s1">.holdTime = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.startTime = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.tick(</span><span class="s3">0</span><span class="s1">);</span>
        <span class="s0">this</span><span class="s1">.teardown();</span>
        <span class="s0">this</span><span class="s1">.options.onCancel?.();</span>
    <span class="s1">}</span>
    <span class="s1">teardown() {</span>
        <span class="s0">this</span><span class="s1">.state = </span><span class="s2">&quot;idle&quot;</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.stopDriver();</span>
        <span class="s0">this</span><span class="s1">.startTime = </span><span class="s0">this</span><span class="s1">.holdTime = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s1">activeAnimations.mainThread--;</span>
    <span class="s1">}</span>
    <span class="s1">stopDriver() {</span>
        <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.driver)</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.driver.stop();</span>
        <span class="s0">this</span><span class="s1">.driver = undefined;</span>
    <span class="s1">}</span>
    <span class="s1">sample(sampleTime) {</span>
        <span class="s0">this</span><span class="s1">.startTime = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s0">return this</span><span class="s1">.tick(sampleTime, </span><span class="s0">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">attachTimeline(timeline) {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.options.allowFlatten) {</span>
            <span class="s0">this</span><span class="s1">.options.type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s1">;</span>
            <span class="s0">this</span><span class="s1">.options.ease = </span><span class="s2">&quot;linear&quot;</span><span class="s1">;</span>
            <span class="s0">this</span><span class="s1">.initAnimation();</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.driver?.stop();</span>
        <span class="s0">return </span><span class="s1">timeline.observe(</span><span class="s0">this</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s4">// Legacy function support</span>
<span class="s0">function </span><span class="s1">animateValue(options) {</span>
    <span class="s0">return new </span><span class="s1">JSAnimation(options);</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ JSAnimation, animateValue };</span>
</pre>
</body>
</html>