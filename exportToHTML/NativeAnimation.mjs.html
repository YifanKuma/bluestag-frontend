<html>
<head>
<title>NativeAnimation.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
NativeAnimation.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from </span><span class="s2">'motion-utils'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ setStyle } from </span><span class="s2">'../render/dom/style-set.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ supportsScrollTimeline } from </span><span class="s2">'../utils/supports/scroll-timeline.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ getFinalKeyframe } from </span><span class="s2">'./keyframes/get-final.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ WithPromise } from </span><span class="s2">'./utils/WithPromise.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ startWaapiAnimation } from </span><span class="s2">'./waapi/start-waapi-animation.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ applyGeneratorOptions } from </span><span class="s2">'./waapi/utils/apply-generator.mjs'</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.</span>
 <span class="s3">*/</span>
<span class="s0">class </span><span class="s1">NativeAnimation </span><span class="s0">extends </span><span class="s1">WithPromise {</span>
    <span class="s1">constructor(options) {</span>
        <span class="s0">super</span><span class="s1">();</span>
        <span class="s0">this</span><span class="s1">.finishedTime = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.isStopped = </span><span class="s0">false</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(!options)</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s0">const </span><span class="s1">{ element, name, keyframes, pseudoElement, allowFlatten = </span><span class="s0">false</span><span class="s1">, finalKeyframe, onComplete, } = options;</span>
        <span class="s0">this</span><span class="s1">.isPseudoElement = Boolean(pseudoElement);</span>
        <span class="s0">this</span><span class="s1">.allowFlatten = allowFlatten;</span>
        <span class="s0">this</span><span class="s1">.options = options;</span>
        <span class="s1">invariant(</span><span class="s0">typeof </span><span class="s1">options.type !== </span><span class="s2">&quot;string&quot;</span><span class="s1">, </span><span class="s2">`Mini animate() doesn't support &quot;type&quot; as a string.`</span><span class="s1">, </span><span class="s2">&quot;mini-spring&quot;</span><span class="s1">);</span>
        <span class="s0">const </span><span class="s1">transition = applyGeneratorOptions(options);</span>
        <span class="s0">this</span><span class="s1">.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);</span>
        <span class="s0">if </span><span class="s1">(transition.autoplay === </span><span class="s0">false</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.animation.pause();</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.animation.onfinish = () =&gt; {</span>
            <span class="s0">this</span><span class="s1">.finishedTime = </span><span class="s0">this</span><span class="s1">.time;</span>
            <span class="s0">if </span><span class="s1">(!pseudoElement) {</span>
                <span class="s0">const </span><span class="s1">keyframe = getFinalKeyframe(keyframes, </span><span class="s0">this</span><span class="s1">.options, finalKeyframe, </span><span class="s0">this</span><span class="s1">.speed);</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.updateMotionValue) {</span>
                    <span class="s0">this</span><span class="s1">.updateMotionValue(keyframe);</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If we can, we want to commit the final style as set by the user,</span>
                     <span class="s3">* rather than the computed keyframe value supplied by the animation.</span>
                     <span class="s3">*/</span>
                    <span class="s1">setStyle(element, name, keyframe);</span>
                <span class="s1">}</span>
                <span class="s0">this</span><span class="s1">.animation.cancel();</span>
            <span class="s1">}</span>
            <span class="s1">onComplete?.();</span>
            <span class="s0">this</span><span class="s1">.notifyFinished();</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">play() {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isStopped)</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.animation.play();</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.state === </span><span class="s2">&quot;finished&quot;</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.updateFinished();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">pause() {</span>
        <span class="s0">this</span><span class="s1">.animation.pause();</span>
    <span class="s1">}</span>
    <span class="s1">complete() {</span>
        <span class="s0">this</span><span class="s1">.animation.finish?.();</span>
    <span class="s1">}</span>
    <span class="s1">cancel() {</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">.animation.cancel();</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(e) { }</span>
    <span class="s1">}</span>
    <span class="s1">stop() {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isStopped)</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.isStopped = </span><span class="s0">true</span><span class="s1">;</span>
        <span class="s0">const </span><span class="s1">{ state } = </span><span class="s0">this</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(state === </span><span class="s2">&quot;idle&quot; </span><span class="s1">|| state === </span><span class="s2">&quot;finished&quot;</span><span class="s1">) {</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.updateMotionValue) {</span>
            <span class="s0">this</span><span class="s1">.updateMotionValue();</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">.commitStyles();</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.isPseudoElement)</span>
            <span class="s0">this</span><span class="s1">.cancel();</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* WAAPI doesn't natively have any interruption capabilities.</span>
     <span class="s3">*</span>
     <span class="s3">* In this method, we commit styles back to the DOM before cancelling</span>
     <span class="s3">* the animation.</span>
     <span class="s3">*</span>
     <span class="s3">* This is designed to be overridden by NativeAnimationExtended, which</span>
     <span class="s3">* will create a renderless JS animation and sample it twice to calculate</span>
     <span class="s3">* its current value, &quot;previous&quot; value, and therefore allow</span>
     <span class="s3">* Motion to also correctly calculate velocity for any subsequent animation</span>
     <span class="s3">* while deferring the commit until the next animation frame.</span>
     <span class="s3">*/</span>
    <span class="s1">commitStyles() {</span>
        <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.isPseudoElement) {</span>
            <span class="s0">this</span><span class="s1">.animation.commitStyles?.();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">get duration() {</span>
        <span class="s0">const </span><span class="s1">duration = </span><span class="s0">this</span><span class="s1">.animation.effect?.getComputedTiming?.().duration || </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s0">return </span><span class="s1">millisecondsToSeconds(Number(duration));</span>
    <span class="s1">}</span>
    <span class="s1">get iterationDuration() {</span>
        <span class="s0">const </span><span class="s1">{ delay = </span><span class="s4">0 </span><span class="s1">} = </span><span class="s0">this</span><span class="s1">.options || {};</span>
        <span class="s0">return this</span><span class="s1">.duration + millisecondsToSeconds(delay);</span>
    <span class="s1">}</span>
    <span class="s1">get time() {</span>
        <span class="s0">return </span><span class="s1">millisecondsToSeconds(Number(</span><span class="s0">this</span><span class="s1">.animation.currentTime) || </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">set time(newTime) {</span>
        <span class="s0">this</span><span class="s1">.finishedTime = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.animation.currentTime = secondsToMilliseconds(newTime);</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* The playback speed of the animation.</span>
     <span class="s3">* 1 = normal speed, 2 = double speed, 0.5 = half speed.</span>
     <span class="s3">*/</span>
    <span class="s1">get speed() {</span>
        <span class="s0">return this</span><span class="s1">.animation.playbackRate;</span>
    <span class="s1">}</span>
    <span class="s1">set speed(newSpeed) {</span>
        <span class="s3">// Allow backwards playback after finishing</span>
        <span class="s0">if </span><span class="s1">(newSpeed &lt; </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">this</span><span class="s1">.finishedTime = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.animation.playbackRate = newSpeed;</span>
    <span class="s1">}</span>
    <span class="s1">get state() {</span>
        <span class="s0">return this</span><span class="s1">.finishedTime !== </span><span class="s0">null</span>
            <span class="s1">? </span><span class="s2">&quot;finished&quot;</span>
            <span class="s1">: </span><span class="s0">this</span><span class="s1">.animation.playState;</span>
    <span class="s1">}</span>
    <span class="s1">get startTime() {</span>
        <span class="s0">return </span><span class="s1">Number(</span><span class="s0">this</span><span class="s1">.animation.startTime);</span>
    <span class="s1">}</span>
    <span class="s1">set startTime(newStartTime) {</span>
        <span class="s0">this</span><span class="s1">.animation.startTime = newStartTime;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Attaches a timeline to the animation, for instance the `ScrollTimeline`.</span>
     <span class="s3">*/</span>
    <span class="s1">attachTimeline({ timeline, observe }) {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.allowFlatten) {</span>
            <span class="s0">this</span><span class="s1">.animation.effect?.updateTiming({ easing: </span><span class="s2">&quot;linear&quot; </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.animation.onfinish = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(timeline &amp;&amp; supportsScrollTimeline()) {</span>
            <span class="s0">this</span><span class="s1">.animation.timeline = timeline;</span>
            <span class="s0">return </span><span class="s1">noop;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">return </span><span class="s1">observe(</span><span class="s0">this</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ NativeAnimation };</span>
</pre>
</body>
</html>