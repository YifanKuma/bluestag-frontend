<html>
<head>
<title>source-maps.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-maps.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">devirtualizeReactServerURL: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">filterStackFrameDEV: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">findApplicableSourceMapPayload: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">findSourceMapURLDEV: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">ignoreListAnonymousStackFramesIfSandwiched: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">sourceMapIgnoreListsEverything: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">devirtualizeReactServerURL: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">devirtualizeReactServerURL;</span>
    <span class="s1">},</span>
    <span class="s1">filterStackFrameDEV: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">filterStackFrameDEV;</span>
    <span class="s1">},</span>
    <span class="s1">findApplicableSourceMapPayload: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">findApplicableSourceMapPayload;</span>
    <span class="s1">},</span>
    <span class="s1">findSourceMapURLDEV: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">findSourceMapURLDEV;</span>
    <span class="s1">},</span>
    <span class="s1">ignoreListAnonymousStackFramesIfSandwiched: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">ignoreListAnonymousStackFramesIfSandwiched;</span>
    <span class="s1">},</span>
    <span class="s1">sourceMapIgnoreListsEverything: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">sourceMapIgnoreListsEverything;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_lrucache = require(</span><span class="s0">&quot;./lru-cache&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_process_versions_node;</span>
<span class="s2">function </span><span class="s1">noSourceMap() {</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>
<span class="s4">// Edge runtime does not implement `module`</span>
<span class="s2">const </span><span class="s1">nativeFindSourceMap = process.env.NEXT_RUNTIME === </span><span class="s0">'edge' </span><span class="s1">? noSourceMap : require(</span><span class="s0">'module'</span><span class="s1">).findSourceMap;</span>
<span class="s2">function </span><span class="s1">sourceMapIgnoreListsEverything(sourceMap) {</span>
    <span class="s2">return </span><span class="s1">sourceMap.ignoreList !== undefined &amp;&amp; sourceMap.sources.length === sourceMap.ignoreList.length;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">findApplicableSourceMapPayload(line0, column0, payload) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">'sections' </span><span class="s2">in </span><span class="s1">payload) {</span>
        <span class="s2">if </span><span class="s1">(payload.sections.length === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s4">// Sections must not overlap and must be sorted: https://tc39.es/source-map/#section-object</span>
        <span class="s4">// Therefore the last section that has an offset less than or equal to the frame is the applicable one.</span>
        <span class="s2">const </span><span class="s1">sections = payload.sections;</span>
        <span class="s2">let </span><span class="s1">left = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">right = sections.length - </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">result = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">while</span><span class="s1">(left &lt;= right){</span>
            <span class="s4">// fast Math.floor</span>
            <span class="s2">const </span><span class="s1">middle = ~~((left + right) / </span><span class="s3">2</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">section = sections[middle];</span>
            <span class="s2">const </span><span class="s1">offset = section.offset;</span>
            <span class="s2">if </span><span class="s1">(offset.line &lt; line0 || offset.line === line0 &amp;&amp; offset.column &lt;= column0) {</span>
                <span class="s1">result = section;</span>
                <span class="s1">left = middle + </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">right = middle - </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result === </span><span class="s2">null </span><span class="s1">? undefined : result.map;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">payload;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">didWarnAboutInvalidSourceMapDEV = </span><span class="s2">new </span><span class="s1">Set();</span>
<span class="s2">const </span><span class="s1">findSourceMap = process.env.NEXT_RUNTIME === </span><span class="s0">'nodejs' </span><span class="s1">&amp;&amp; ((_process_versions_node = process.versions.node) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _process_versions_node.startsWith(</span><span class="s0">'18'</span><span class="s1">)) ? noSourceMap : nativeFindSourceMap;</span>
<span class="s2">function </span><span class="s1">filterStackFrameDEV(sourceURL, functionName, line1, column1) {</span>
    <span class="s2">if </span><span class="s1">(sourceURL === </span><span class="s0">''</span><span class="s1">) {</span>
        <span class="s4">// The default implementation filters out &lt;anonymous&gt; stack frames</span>
        <span class="s4">// but we want to retain them because current Server Components and</span>
        <span class="s4">// built-in Components in parent stacks don't have source location.</span>
        <span class="s4">// Filter out frames that show up in Promises to get good names in React's</span>
        <span class="s4">// Server Request track until we come up with a better heuristic.</span>
        <span class="s2">return </span><span class="s1">functionName !== </span><span class="s0">'new Promise'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(sourceURL.startsWith(</span><span class="s0">'node:'</span><span class="s1">) || sourceURL.includes(</span><span class="s0">'node_modules'</span><span class="s1">)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s4">// Node.js loads source maps eagerly so this call is cheap.</span>
        <span class="s4">// TODO: ESM sourcemaps are O(1) but CommonJS sourcemaps are O(Number of CJS modules).</span>
        <span class="s4">// Make sure this doesn't adversely affect performance when CJS is used by Next.js.</span>
        <span class="s2">const </span><span class="s1">sourceMap = findSourceMap(sourceURL);</span>
        <span class="s2">if </span><span class="s1">(sourceMap === undefined) {</span>
            <span class="s4">// No source map assoicated.</span>
            <span class="s4">// TODO: Node.js types should reflect that `findSourceMap` can return `undefined`.</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">sourceMapPayload = findApplicableSourceMapPayload(line1 - </span><span class="s3">1</span><span class="s1">, column1 - </span><span class="s3">1</span><span class="s1">, sourceMap.payload);</span>
        <span class="s2">if </span><span class="s1">(sourceMapPayload === undefined) {</span>
            <span class="s4">// No source map section applicable to the frame.</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">!sourceMapIgnoreListsEverything(sourceMapPayload);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(cause) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production'</span><span class="s1">) {</span>
            <span class="s4">// TODO: Share cache with patch-error-inspect</span>
            <span class="s2">if </span><span class="s1">(!didWarnAboutInvalidSourceMapDEV.has(sourceURL)) {</span>
                <span class="s1">didWarnAboutInvalidSourceMapDEV.add(sourceURL);</span>
                <span class="s4">// We should not log an actual error instance here because that will re-enter</span>
                <span class="s4">// this codepath during error inspection and could lead to infinite recursion.</span>
                <span class="s1">console.error(</span><span class="s0">`</span><span class="s1">${sourceURL}</span><span class="s0">: Invalid source map. Only conformant source maps can be used to filter stack frames. Cause: </span><span class="s1">${cause}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">invalidSourceMap = Symbol(</span><span class="s0">'invalid-source-map'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">sourceMapURLs = </span><span class="s2">new </span><span class="s1">_lrucache.LRUCache(</span><span class="s3">512 </span><span class="s1">* </span><span class="s3">1024 </span><span class="s1">* </span><span class="s3">1024</span><span class="s1">, (url)=&gt;url === invalidSourceMap ? </span><span class="s4">// so that we don't create a huge cache with empty source maps.</span>
    <span class="s3">8 </span><span class="s1">* </span><span class="s3">1024 </span><span class="s1">: url.length);</span>
<span class="s2">function </span><span class="s1">findSourceMapURLDEV(scriptNameOrSourceURL) {</span>
    <span class="s2">let </span><span class="s1">sourceMapURL = sourceMapURLs.get(scriptNameOrSourceURL);</span>
    <span class="s2">if </span><span class="s1">(sourceMapURL === undefined) {</span>
        <span class="s2">let </span><span class="s1">sourceMapPayload;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s1">_findSourceMap;</span>
            <span class="s1">sourceMapPayload = (_findSourceMap = findSourceMap(scriptNameOrSourceURL)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _findSourceMap.payload;</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(cause) {</span>
            <span class="s1">console.error(</span><span class="s0">`</span><span class="s1">${scriptNameOrSourceURL}</span><span class="s0">: Invalid source map. Only conformant source maps can be used to find the original code. Cause: </span><span class="s1">${cause}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(sourceMapPayload === undefined) {</span>
            <span class="s1">sourceMapURL = invalidSourceMap;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// TODO: Might be more efficient to extract the relevant section from Index Maps.</span>
            <span class="s4">// Unclear if that search is worth the smaller payload we have to stringify.</span>
            <span class="s2">const </span><span class="s1">sourceMapJSON = JSON.stringify(sourceMapPayload);</span>
            <span class="s2">const </span><span class="s1">sourceMapURLData = Buffer.from(sourceMapJSON, </span><span class="s0">'utf8'</span><span class="s1">).toString(</span><span class="s0">'base64'</span><span class="s1">);</span>
            <span class="s1">sourceMapURL = </span><span class="s0">`data:application/json;base64,</span><span class="s1">${sourceMapURLData}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">sourceMapURLs.set(scriptNameOrSourceURL, sourceMapURL);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">sourceMapURL === invalidSourceMap ? </span><span class="s2">null </span><span class="s1">: sourceMapURL;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">devirtualizeReactServerURL(sourceURL) {</span>
    <span class="s2">if </span><span class="s1">(sourceURL.startsWith(</span><span class="s0">'about://React/'</span><span class="s1">)) {</span>
        <span class="s4">// about://React/Server/file://&lt;filename&gt;?42 =&gt; file://&lt;filename&gt;</span>
        <span class="s2">const </span><span class="s1">envIdx = sourceURL.indexOf(</span><span class="s0">'/'</span><span class="s1">, </span><span class="s0">'about://React/'</span><span class="s1">.length);</span>
        <span class="s2">const </span><span class="s1">suffixIdx = sourceURL.lastIndexOf(</span><span class="s0">'?'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(envIdx &gt; -</span><span class="s3">1 </span><span class="s1">&amp;&amp; suffixIdx &gt; -</span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">decodeURI(sourceURL.slice(envIdx + </span><span class="s3">1</span><span class="s1">, suffixIdx));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">sourceURL;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isAnonymousFrameLikelyJSNative(methodName) {</span>
    <span class="s4">// Anonymous frames can also be produced in React parent stacks either from</span>
    <span class="s4">// host components or Server Components. We don't want to ignore those.</span>
    <span class="s4">// This could hide user-space methods that are named like native JS methods but</span>
    <span class="s4">// should you really do that?</span>
    <span class="s2">return</span><span class="s1">(</span><span class="s4">// e.g. JSON.parse</span>
    <span class="s1">methodName.startsWith(</span><span class="s0">'JSON.'</span><span class="s1">) || </span><span class="s4">// E.g. Promise.withResolves</span>
    <span class="s1">methodName.startsWith(</span><span class="s0">'Function.'</span><span class="s1">) || </span><span class="s4">// various JS built-ins</span>
    <span class="s1">methodName.startsWith(</span><span class="s0">'Promise.'</span><span class="s1">) || methodName.startsWith(</span><span class="s0">'Array.'</span><span class="s1">) || methodName.startsWith(</span><span class="s0">'Set.'</span><span class="s1">) || methodName.startsWith(</span><span class="s0">'Map.'</span><span class="s1">));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ignoreListAnonymousStackFramesIfSandwiched(frames, isAnonymousFrame, isIgnoredFrame, getMethodName, </span><span class="s4">/** only passes frames for which `isAnonymousFrame` and their method is a native JS method or `isIgnoredFrame` return true */ </span><span class="s1">ignoreFrame) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">1</span><span class="s1">; i &lt; frames.length; i++){</span>
        <span class="s2">const </span><span class="s1">currentFrame = frames[i];</span>
        <span class="s2">if </span><span class="s1">(!(isAnonymousFrame(currentFrame) &amp;&amp; isAnonymousFrameLikelyJSNative(getMethodName(currentFrame)))) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">previousFrameIsIgnored = isIgnoredFrame(frames[i - </span><span class="s3">1</span><span class="s1">]);</span>
        <span class="s2">if </span><span class="s1">(previousFrameIsIgnored &amp;&amp; i &lt; frames.length - </span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s2">let </span><span class="s1">ignoreSandwich = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">j = i + </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s2">for</span><span class="s1">(j; j &lt; frames.length; j++){</span>
                <span class="s2">const </span><span class="s1">nextFrame = frames[j];</span>
                <span class="s2">const </span><span class="s1">nextFrameIsAnonymous = isAnonymousFrame(nextFrame) &amp;&amp; isAnonymousFrameLikelyJSNative(getMethodName(nextFrame));</span>
                <span class="s2">if </span><span class="s1">(nextFrameIsAnonymous) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">nextFrameIsIgnored = isIgnoredFrame(nextFrame);</span>
                <span class="s2">if </span><span class="s1">(nextFrameIsIgnored) {</span>
                    <span class="s1">ignoreSandwich = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(ignoreSandwich) {</span>
                <span class="s2">for</span><span class="s1">(i; i &lt; j; i++){</span>
                    <span class="s1">ignoreFrame(frames[i]);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=source-maps.js.map</span></pre>
</body>
</html>