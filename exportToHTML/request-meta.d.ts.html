<html>
<head>
<title>request-meta.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
request-meta.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { IncomingMessage } from </span><span class="s2">'http'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ParsedUrlQuery } from </span><span class="s2">'querystring'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { UrlWithParsedQuery } from </span><span class="s2">'url'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { BaseNextRequest } from </span><span class="s2">'./base-http'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { CloneableBody } from </span><span class="s2">'./body-streams'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { RouteMatch } from </span><span class="s2">'./route-matches/route-match'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { NEXT_RSC_UNION_QUERY } from </span><span class="s2">'../client/components/app-router-headers'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ServerComponentsHmrCache } from </span><span class="s2">'./response-cache'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { PagesDevOverlayBridgeType } from </span><span class="s2">'../next-devtools/userspace/pages/pages-dev-overlay-setup'</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">NEXT_REQUEST_META: unique symbol;</span>
<span class="s0">export </span><span class="s1">type NextIncomingMessage = (BaseNextRequest | IncomingMessage) &amp; {</span>
    <span class="s1">[NEXT_REQUEST_META]?: RequestMeta;</span>
<span class="s1">};</span>
<span class="s0">export interface </span><span class="s1">RequestMeta {</span>
    <span class="s3">/**</span>
     <span class="s3">* The query that was used to make the request.</span>
     <span class="s3">*/</span>
    <span class="s1">initQuery?: ParsedUrlQuery;</span>
    <span class="s3">/**</span>
     <span class="s3">* The URL that was used to make the request.</span>
     <span class="s3">*/</span>
    <span class="s1">initURL?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The protocol that was used to make the request.</span>
     <span class="s3">*/</span>
    <span class="s1">initProtocol?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The body that was read from the request. This is used to allow the body to</span>
     <span class="s3">* be read multiple times.</span>
     <span class="s3">*/</span>
    <span class="s1">clonableBody?: CloneableBody;</span>
    <span class="s3">/**</span>
     <span class="s3">* True when the request matched a locale domain that was configured in the</span>
     <span class="s3">* next.config.js file.</span>
     <span class="s3">*/</span>
    <span class="s1">isLocaleDomain?: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* True when the request had locale information stripped from the pathname</span>
     <span class="s3">* part of the URL.</span>
     <span class="s3">*/</span>
    <span class="s1">didStripLocale?: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* If the request had it's URL rewritten, this is the URL it was rewritten to.</span>
     <span class="s3">*/</span>
    <span class="s1">rewroteURL?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The cookies that were added by middleware and were added to the response.</span>
     <span class="s3">*/</span>
    <span class="s1">middlewareCookie?: string[];</span>
    <span class="s3">/**</span>
     <span class="s3">* The match on the request for a given route.</span>
     <span class="s3">*/</span>
    <span class="s1">match?: RouteMatch;</span>
    <span class="s3">/**</span>
     <span class="s3">* The incremental cache to use for the request.</span>
     <span class="s3">*/</span>
    <span class="s1">incrementalCache?: any;</span>
    <span class="s3">/**</span>
     <span class="s3">* The server components HMR cache, only for dev.</span>
     <span class="s3">*/</span>
    <span class="s1">serverComponentsHmrCache?: ServerComponentsHmrCache;</span>
    <span class="s3">/**</span>
     <span class="s3">* Equals the segment path that was used for the prefetch RSC request.</span>
     <span class="s3">*/</span>
    <span class="s1">segmentPrefetchRSCRequest?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* True when the request is for the prefetch flight data.</span>
     <span class="s3">*/</span>
    <span class="s1">isPrefetchRSCRequest?: </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* True when the request is for the flight data.</span>
     <span class="s3">*/</span>
    <span class="s1">isRSCRequest?: </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* A search param set by the Next.js client when performing RSC requests.</span>
     <span class="s3">* Because some CDNs do not vary their cache entries on our custom headers,</span>
     <span class="s3">* this search param represents a hash of the header values. For any cached</span>
     <span class="s3">* RSC request, we should verify that the hash matches before responding.</span>
     <span class="s3">* Otherwise this can lead to cache poisoning.</span>
     <span class="s3">* TODO: Consider not using custom request headers at all, and instead encode</span>
     <span class="s3">* everything into the search param.</span>
     <span class="s3">*/</span>
    <span class="s1">cacheBustingSearchParam?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* True when the request is for the `/_next/data` route using the pages</span>
     <span class="s3">* router.</span>
     <span class="s3">*/</span>
    <span class="s1">isNextDataReq?: </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Postponed state to use for resumption. If present it's assumed that the</span>
     <span class="s3">* request is for a page that has postponed (there are no guarantees that the</span>
     <span class="s3">* page actually has postponed though as it would incur an additional cache</span>
     <span class="s3">* lookup).</span>
     <span class="s3">*/</span>
    <span class="s1">postponed?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* If provided, this will be called when a response cache entry was generated</span>
     <span class="s3">* or looked up in the cache.</span>
     <span class="s3">*/</span>
    <span class="s1">onCacheEntry?: (cacheEntry: any, requestMeta: any) =&gt; Promise&lt;boolean | </span><span class="s0">void</span><span class="s1">&gt; | boolean | </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The previous revalidate before rendering 404 page for notFound: true</span>
     <span class="s3">*/</span>
    <span class="s1">notFoundRevalidate?: number | </span><span class="s0">false</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* In development, the original source page that returned a 404.</span>
     <span class="s3">*/</span>
    <span class="s1">developmentNotFoundSourcePage?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The path we routed to and should be invoked</span>
     <span class="s3">*/</span>
    <span class="s1">invokePath?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The specific page output we should be matching</span>
     <span class="s3">*/</span>
    <span class="s1">invokeOutput?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The status we are invoking the request with from routing</span>
     <span class="s3">*/</span>
    <span class="s1">invokeStatus?: number;</span>
    <span class="s3">/**</span>
     <span class="s3">* The routing error we are invoking with</span>
     <span class="s3">*/</span>
    <span class="s1">invokeError?: Error;</span>
    <span class="s3">/**</span>
     <span class="s3">* The query parsed for the invocation</span>
     <span class="s3">*/</span>
    <span class="s1">invokeQuery?: Record&lt;string, undefined | string | string[]&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* Whether the request is a middleware invocation</span>
     <span class="s3">*/</span>
    <span class="s1">middlewareInvoke?: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Whether the request should render the fallback shell or not.</span>
     <span class="s3">*/</span>
    <span class="s1">renderFallbackShell?: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Whether the request is for the custom error page.</span>
     <span class="s3">*/</span>
    <span class="s1">customErrorRender?: </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Whether to bubble up the NoFallbackError to the caller when a 404 is</span>
     <span class="s3">* returned.</span>
     <span class="s3">*/</span>
    <span class="s1">bubbleNoFallback?: </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* True when the request had locale information inferred from the default</span>
     <span class="s3">* locale.</span>
     <span class="s3">*/</span>
    <span class="s1">localeInferredFromDefault?: </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The locale that was inferred or explicitly set for the request.</span>
     <span class="s3">*/</span>
    <span class="s1">locale?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The default locale that was inferred or explicitly set for the request.</span>
     <span class="s3">*/</span>
    <span class="s1">defaultLocale?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The relative project dir the server is running in from project root</span>
     <span class="s3">*/</span>
    <span class="s1">relativeProjectDir?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The dist directory the server is currently using</span>
     <span class="s3">*/</span>
    <span class="s1">distDir?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The query after resolving routes</span>
     <span class="s3">*/</span>
    <span class="s1">query?: ParsedUrlQuery;</span>
    <span class="s3">/**</span>
     <span class="s3">* The params after resolving routes</span>
     <span class="s3">*/</span>
    <span class="s1">params?: ParsedUrlQuery;</span>
    <span class="s3">/**</span>
     <span class="s3">* The AMP validator to use in development</span>
     <span class="s3">*/</span>
    <span class="s1">ampValidator?: (html: string, pathname: string) =&gt; Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* ErrorOverlay component to use in development for pages router</span>
     <span class="s3">*/</span>
    <span class="s1">PagesErrorDebug?: PagesDevOverlayBridgeType;</span>
    <span class="s3">/**</span>
     <span class="s3">* Whether server is in minimal mode (this will be replaced with more</span>
     <span class="s3">* specific flags in future)</span>
     <span class="s3">*/</span>
    <span class="s1">minimalMode?: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* DEV only: The fallback params that should be used when validating prerenders during dev</span>
     <span class="s3">*/</span>
    <span class="s1">devValidatingFallbackParams?: Map&lt;string, string&gt;;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Gets the request metadata. If no key is provided, the entire metadata object</span>
 <span class="s3">* is returned.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">req the request to get the metadata from</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">key the key to get from the metadata (optional)</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">the value for the key or the entire metadata object</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getRequestMeta(req: NextIncomingMessage, key?: undefined): RequestMeta;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getRequestMeta&lt;K </span><span class="s0">extends </span><span class="s1">keyof RequestMeta&gt;(req: NextIncomingMessage, key: K): RequestMeta[K];</span>
<span class="s3">/**</span>
 <span class="s3">* Sets the request metadata.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">req the request to set the metadata on</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">meta the metadata to set</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">the mutated request metadata</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">setRequestMeta(req: NextIncomingMessage, meta: RequestMeta): RequestMeta;</span>
<span class="s3">/**</span>
 <span class="s3">* Adds a value to the request metadata.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">request the request to mutate</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">key the key to set</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">value the value to set</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">the mutated request metadata</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">addRequestMeta&lt;K </span><span class="s0">extends </span><span class="s1">keyof RequestMeta&gt;(request: NextIncomingMessage, key: K, value: RequestMeta[K]): RequestMeta;</span>
<span class="s3">/**</span>
 <span class="s3">* Removes a key from the request metadata.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">request the request to mutate</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">key the key to remove</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">the mutated request metadata</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">removeRequestMeta&lt;K </span><span class="s0">extends </span><span class="s1">keyof RequestMeta&gt;(request: NextIncomingMessage, key: K): RequestMeta;</span>
<span class="s1">type NextQueryMetadata = {</span>
    <span class="s3">/**</span>
     <span class="s3">* The `_rsc` query parameter used for cache busting to ensure that the RSC</span>
     <span class="s3">* requests do not get cached by the browser explicitly.</span>
     <span class="s3">*/</span>
    <span class="s1">[NEXT_RSC_UNION_QUERY]?: string;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">type NextParsedUrlQuery = ParsedUrlQuery &amp; NextQueryMetadata &amp; {</span>
    <span class="s1">amp?: </span><span class="s2">'1'</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s0">export interface </span><span class="s1">NextUrlWithParsedQuery </span><span class="s0">extends </span><span class="s1">UrlWithParsedQuery {</span>
    <span class="s1">query: NextParsedUrlQuery;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">{};</span>
</pre>
</body>
</html>