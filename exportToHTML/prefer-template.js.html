<html>
<head>
<title>prefer-template.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
.s7 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prefer-template.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">A rule to suggest using template literals instead of string concatenation.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Toru Nagashima</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">astUtils = require(</span><span class="s3">&quot;./utils/ast-utils&quot;</span><span class="s2">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether or not a given node is a concatenation.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the node is a concatenation.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isConcatenation(node) {</span>
	<span class="s4">return </span><span class="s2">node.type === </span><span class="s3">&quot;BinaryExpression&quot; </span><span class="s2">&amp;&amp; node.operator === </span><span class="s3">&quot;+&quot;</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets the top binary expression node for concatenation in parents of a given node.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to get.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} the top binary expression node in parents of a given node.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getTopConcatBinaryExpression(node) {</span>
	<span class="s4">let </span><span class="s2">currentNode = node;</span>

	<span class="s4">while </span><span class="s2">(isConcatenation(currentNode.parent)) {</span>
		<span class="s2">currentNode = currentNode.parent;</span>
	<span class="s2">}</span>
	<span class="s4">return </span><span class="s2">currentNode;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether or not a node contains a string literal with an octal or non-octal decimal escape sequence</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to check</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if at least one string literal within the node contains</span>
 <span class="s0">* an octal or non-octal decimal escape sequence</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">hasOctalOrNonOctalDecimalEscapeSequence(node) {</span>
	<span class="s4">if </span><span class="s2">(isConcatenation(node)) {</span>
		<span class="s4">return </span><span class="s2">(</span>
			<span class="s2">hasOctalOrNonOctalDecimalEscapeSequence(node.left) ||</span>
			<span class="s2">hasOctalOrNonOctalDecimalEscapeSequence(node.right)</span>
		<span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s0">// No need to check TemplateLiterals â€“ would throw parsing error</span>
	<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;Literal&quot; </span><span class="s2">&amp;&amp; </span><span class="s4">typeof </span><span class="s2">node.value === </span><span class="s3">&quot;string&quot;</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s2">astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);</span>
	<span class="s2">}</span>

	<span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether or not a given binary expression has string literals.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the node has string literals.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">hasStringLiteral(node) {</span>
	<span class="s4">if </span><span class="s2">(isConcatenation(node)) {</span>
		<span class="s0">// `left` is deeper than `right` normally.</span>
		<span class="s4">return </span><span class="s2">hasStringLiteral(node.right) || hasStringLiteral(node.left);</span>
	<span class="s2">}</span>
	<span class="s4">return </span><span class="s2">astUtils.isStringLiteral(node);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether or not a given binary expression has non string literals.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the node has non string literals.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">hasNonStringLiteral(node) {</span>
	<span class="s4">if </span><span class="s2">(isConcatenation(node)) {</span>
		<span class="s0">// `left` is deeper than `right` normally.</span>
		<span class="s4">return </span><span class="s2">(</span>
			<span class="s2">hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left)</span>
		<span class="s2">);</span>
	<span class="s2">}</span>
	<span class="s4">return </span><span class="s2">!astUtils.isStringLiteral(node);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node that will be fixed to a template literal</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the node will start with a template curly.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">startsWithTemplateCurly(node) {</span>
	<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s2">startsWithTemplateCurly(node.left);</span>
	<span class="s2">}</span>
	<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s2">(</span>
			<span class="s2">node.expressions.length &amp;&amp;</span>
			<span class="s2">node.quasis.length &amp;&amp;</span>
			<span class="s2">node.quasis[</span><span class="s5">0</span><span class="s2">].range[</span><span class="s5">0</span><span class="s2">] === node.quasis[</span><span class="s5">0</span><span class="s2">].range[</span><span class="s5">1</span><span class="s2">]</span>
		<span class="s2">);</span>
	<span class="s2">}</span>
	<span class="s4">return </span><span class="s2">node.type !== </span><span class="s3">&quot;Literal&quot; </span><span class="s2">|| </span><span class="s4">typeof </span><span class="s2">node.value !== </span><span class="s3">&quot;string&quot;</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node that will be fixed to a template literal</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the node will end with a template curly.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">endsWithTemplateCurly(node) {</span>
	<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s2">startsWithTemplateCurly(node.right);</span>
	<span class="s2">}</span>
	<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s2">(</span>
			<span class="s2">node.expressions.length &amp;&amp;</span>
			<span class="s2">node.quasis.length &amp;&amp;</span>
			<span class="s2">node.quasis.at(-</span><span class="s5">1</span><span class="s2">).range[</span><span class="s5">0</span><span class="s2">] === node.quasis.at(-</span><span class="s5">1</span><span class="s2">).range[</span><span class="s5">1</span><span class="s2">]</span>
		<span class="s2">);</span>
	<span class="s2">}</span>
	<span class="s4">return </span><span class="s2">node.type !== </span><span class="s3">&quot;Literal&quot; </span><span class="s2">|| </span><span class="s4">typeof </span><span class="s2">node.value !== </span><span class="s3">&quot;string&quot;</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('../types').Rule.RuleModule} */</span>
<span class="s2">module.exports = {</span>
	<span class="s2">meta: {</span>
		<span class="s2">type: </span><span class="s3">&quot;suggestion&quot;</span><span class="s2">,</span>

		<span class="s2">docs: {</span>
			<span class="s2">description:</span>
				<span class="s3">&quot;Require template literals instead of string concatenation&quot;</span><span class="s2">,</span>
			<span class="s2">recommended: </span><span class="s4">false</span><span class="s2">,</span>
			<span class="s2">frozen: </span><span class="s4">true</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/docs/latest/rules/prefer-template&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>

		<span class="s2">schema: [],</span>
		<span class="s2">fixable: </span><span class="s3">&quot;code&quot;</span><span class="s2">,</span>

		<span class="s2">messages: {</span>
			<span class="s2">unexpectedStringConcatenation: </span><span class="s3">&quot;Unexpected string concatenation.&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>
	<span class="s2">},</span>

	<span class="s2">create(context) {</span>
		<span class="s4">const </span><span class="s2">sourceCode = context.sourceCode;</span>
		<span class="s4">let </span><span class="s2">done = Object.create(</span><span class="s4">null</span><span class="s2">);</span>

		<span class="s0">/**</span>
		 <span class="s0">* Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node1 The first node</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node2 The second node</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The text between the nodes, excluding other tokens</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getTextBetween(node1, node2) {</span>
			<span class="s4">const </span><span class="s2">allTokens = [node1]</span>
				<span class="s2">.concat(sourceCode.getTokensBetween(node1, node2))</span>
				<span class="s2">.concat(node2);</span>
			<span class="s4">const </span><span class="s2">sourceText = sourceCode.getText();</span>

			<span class="s4">return </span><span class="s2">allTokens</span>
				<span class="s2">.slice(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)</span>
				<span class="s2">.reduce(</span>
					<span class="s2">(accumulator, token, index) =&gt;</span>
						<span class="s2">accumulator +</span>
						<span class="s2">sourceText.slice(</span>
							<span class="s2">token.range[</span><span class="s5">1</span><span class="s2">],</span>
							<span class="s2">allTokens[index + </span><span class="s5">1</span><span class="s2">].range[</span><span class="s5">0</span><span class="s2">],</span>
						<span class="s2">),</span>
					<span class="s3">&quot;&quot;</span><span class="s2">,</span>
				<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Returns a template literal form of the given node.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} currentNode A node that should be converted to a template literal</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} textBeforeNode Text that should appear before the node</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} textAfterNode Text that should appear after the node</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} A string form of this node, represented as a template literal</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">getTemplateLiteral(</span>
			<span class="s2">currentNode,</span>
			<span class="s2">textBeforeNode,</span>
			<span class="s2">textAfterNode,</span>
		<span class="s2">) {</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">currentNode.type === </span><span class="s3">&quot;Literal&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s4">typeof </span><span class="s2">currentNode.value === </span><span class="s3">&quot;string&quot;</span>
			<span class="s2">) {</span>
				<span class="s0">/* 
                 * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted 
                 * as a template placeholder. However, if the code already contains a backslash before the ${ or ` 
                 * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause 
                 * an actual backslash character to appear before the dollar sign). 
                 */</span>
				<span class="s4">return </span><span class="s3">`</span><span class="s6">\`</span><span class="s2">${currentNode.raw</span>
					<span class="s2">.slice(</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)</span>
					<span class="s2">.replace(</span><span class="s7">/\\*(\$\{|`)/gu</span><span class="s2">, matched =&gt; {</span>
						<span class="s4">if </span><span class="s2">(matched.lastIndexOf(</span><span class="s3">&quot;</span><span class="s6">\\</span><span class="s3">&quot;</span><span class="s2">) % </span><span class="s5">2</span><span class="s2">) {</span>
							<span class="s4">return </span><span class="s3">`</span><span class="s6">\\</span><span class="s2">${matched}</span><span class="s3">`</span><span class="s2">;</span>
						<span class="s2">}</span>
						<span class="s4">return </span><span class="s2">matched;</span>

						<span class="s0">// Unescape any quotes that appear in the original Literal that no longer need to be escaped.</span>
					<span class="s2">})</span>
					<span class="s2">.replace(</span>
						<span class="s4">new </span><span class="s2">RegExp(</span><span class="s3">`</span><span class="s6">\\\\</span><span class="s2">${currentNode.raw[</span><span class="s5">0</span><span class="s2">]}</span><span class="s3">`</span><span class="s2">, </span><span class="s3">&quot;gu&quot;</span><span class="s2">),</span>
						<span class="s2">currentNode.raw[</span><span class="s5">0</span><span class="s2">],</span>
					<span class="s2">)}</span><span class="s6">\`</span><span class="s3">`</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(currentNode.type === </span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s2">) {</span>
				<span class="s4">return </span><span class="s2">sourceCode.getText(currentNode);</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(isConcatenation(currentNode) &amp;&amp; hasStringLiteral(currentNode)) {</span>
				<span class="s4">const </span><span class="s2">plusSign = sourceCode.getFirstTokenBetween(</span>
					<span class="s2">currentNode.left,</span>
					<span class="s2">currentNode.right,</span>
					<span class="s2">token =&gt; token.value === </span><span class="s3">&quot;+&quot;</span><span class="s2">,</span>
				<span class="s2">);</span>
				<span class="s4">const </span><span class="s2">textBeforePlus = getTextBetween(</span>
					<span class="s2">currentNode.left,</span>
					<span class="s2">plusSign,</span>
				<span class="s2">);</span>
				<span class="s4">const </span><span class="s2">textAfterPlus = getTextBetween(</span>
					<span class="s2">plusSign,</span>
					<span class="s2">currentNode.right,</span>
				<span class="s2">);</span>
				<span class="s4">const </span><span class="s2">leftEndsWithCurly = endsWithTemplateCurly(</span>
					<span class="s2">currentNode.left,</span>
				<span class="s2">);</span>
				<span class="s4">const </span><span class="s2">rightStartsWithCurly = startsWithTemplateCurly(</span>
					<span class="s2">currentNode.right,</span>
				<span class="s2">);</span>

				<span class="s4">if </span><span class="s2">(leftEndsWithCurly) {</span>
					<span class="s0">// If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.</span>
					<span class="s0">// `foo${bar}` /* comment */ + 'baz' --&gt; `foo${bar /* comment */  }${baz}`</span>
					<span class="s4">return </span><span class="s2">(</span>
						<span class="s2">getTemplateLiteral(</span>
							<span class="s2">currentNode.left,</span>
							<span class="s2">textBeforeNode,</span>
							<span class="s2">textBeforePlus + textAfterPlus,</span>
						<span class="s2">).slice(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">) +</span>
						<span class="s2">getTemplateLiteral(</span>
							<span class="s2">currentNode.right,</span>
							<span class="s4">null</span><span class="s2">,</span>
							<span class="s2">textAfterNode,</span>
						<span class="s2">).slice(</span><span class="s5">1</span><span class="s2">)</span>
					<span class="s2">);</span>
				<span class="s2">}</span>
				<span class="s4">if </span><span class="s2">(rightStartsWithCurly) {</span>
					<span class="s0">// Otherwise, if the right side of the expression starts with a template curly, add the text there.</span>
					<span class="s0">// 'foo' /* comment */ + `${bar}baz` --&gt; `foo${ /* comment */  bar}baz`</span>
					<span class="s4">return </span><span class="s2">(</span>
						<span class="s2">getTemplateLiteral(</span>
							<span class="s2">currentNode.left,</span>
							<span class="s2">textBeforeNode,</span>
							<span class="s4">null</span><span class="s2">,</span>
						<span class="s2">).slice(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">) +</span>
						<span class="s2">getTemplateLiteral(</span>
							<span class="s2">currentNode.right,</span>
							<span class="s2">textBeforePlus + textAfterPlus,</span>
							<span class="s2">textAfterNode,</span>
						<span class="s2">).slice(</span><span class="s5">1</span><span class="s2">)</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s0">/* 
                 * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put 
                 * the text between them. 
                 */</span>
				<span class="s4">return </span><span class="s3">`</span><span class="s2">${getTemplateLiteral(currentNode.left, textBeforeNode, </span><span class="s4">null</span><span class="s2">)}${textBeforePlus}</span><span class="s3">+</span><span class="s2">${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, </span><span class="s4">null</span><span class="s2">)}</span><span class="s3">`</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s3">`</span><span class="s6">\`\$</span><span class="s3">{</span><span class="s2">${textBeforeNode || </span><span class="s3">&quot;&quot;</span><span class="s2">}${sourceCode.getText(currentNode)}${textAfterNode || </span><span class="s3">&quot;&quot;</span><span class="s2">}</span><span class="s3">}</span><span class="s6">\`</span><span class="s3">`</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Returns a fixer object that converts a non-string binary expression to a template literal</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCodeFixer} fixer The fixer object</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node that should be converted to a template literal</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} A fix for this binary expression</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">fixNonStringBinaryExpression(fixer, node) {</span>
			<span class="s4">const </span><span class="s2">topBinaryExpr = getTopConcatBinaryExpression(node.parent);</span>

			<span class="s4">if </span><span class="s2">(hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {</span>
				<span class="s4">return null</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">fixer.replaceText(</span>
				<span class="s2">topBinaryExpr,</span>
				<span class="s2">getTemplateLiteral(topBinaryExpr, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">),</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Reports if a given node is string concatenation with non string literals.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A node to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkForStringConcat(node) {</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">!astUtils.isStringLiteral(node) ||</span>
				<span class="s2">!isConcatenation(node.parent)</span>
			<span class="s2">) {</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">topBinaryExpr = getTopConcatBinaryExpression(node.parent);</span>

			<span class="s0">// Checks whether or not this node had been checked already.</span>
			<span class="s4">if </span><span class="s2">(done[topBinaryExpr.range[</span><span class="s5">0</span><span class="s2">]]) {</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>
			<span class="s2">done[topBinaryExpr.range[</span><span class="s5">0</span><span class="s2">]] = </span><span class="s4">true</span><span class="s2">;</span>

			<span class="s4">if </span><span class="s2">(hasNonStringLiteral(topBinaryExpr)) {</span>
				<span class="s2">context.report({</span>
					<span class="s2">node: topBinaryExpr,</span>
					<span class="s2">messageId: </span><span class="s3">&quot;unexpectedStringConcatenation&quot;</span><span class="s2">,</span>
					<span class="s2">fix: fixer =&gt; fixNonStringBinaryExpression(fixer, node),</span>
				<span class="s2">});</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">{</span>
			<span class="s2">Program() {</span>
				<span class="s2">done = Object.create(</span><span class="s4">null</span><span class="s2">);</span>
			<span class="s2">},</span>

			<span class="s2">Literal: checkForStringConcat,</span>
			<span class="s2">TemplateLiteral: checkForStringConcat,</span>
		<span class="s2">};</span>
	<span class="s2">},</span>
<span class="s2">};</span>
</pre>
</body>
</html>