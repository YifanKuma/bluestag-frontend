<html>
<head>
<title>work-unit-async-storage.external.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
work-unit-async-storage.external.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { AsyncLocalStorage } from </span><span class="s2">'async_hooks'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { DraftModeProvider } from </span><span class="s2">'../async-storage/draft-mode-provider'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ResponseCookies } from </span><span class="s2">'../web/spec-extension/cookies'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ReadonlyHeaders } from </span><span class="s2">'../web/spec-extension/adapters/headers'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ReadonlyRequestCookies } from </span><span class="s2">'../web/spec-extension/adapters/request-cookies'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { CacheSignal } from </span><span class="s2">'./cache-signal'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { DynamicTrackingState } from </span><span class="s2">'./dynamic-rendering'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FallbackRouteParams } from </span><span class="s2">'../request/fallback-params'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ workUnitAsyncStorageInstance } from </span><span class="s2">'./work-unit-async-storage-instance'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ServerComponentsHmrCache } from </span><span class="s2">'../response-cache'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { RenderResumeDataCache, PrerenderResumeDataCache } from </span><span class="s2">'../resume-data-cache/resume-data-cache'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { Params } from </span><span class="s2">'../request/params'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { ImplicitTags } from </span><span class="s2">'../lib/implicit-tags'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { WorkStore } from </span><span class="s2">'./work-async-storage.external'</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">type WorkUnitPhase = </span><span class="s2">'action' </span><span class="s1">| </span><span class="s2">'render' </span><span class="s1">| </span><span class="s2">'after'</span><span class="s1">;</span>
<span class="s0">export interface </span><span class="s1">CommonWorkUnitStore {</span>
    <span class="s3">/** NOTE: Will be mutated as phases change */</span>
    <span class="s1">phase: WorkUnitPhase;</span>
    <span class="s1">readonly implicitTags: ImplicitTags;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">RequestStore </span><span class="s0">extends </span><span class="s1">CommonWorkUnitStore {</span>
    <span class="s1">readonly type: </span><span class="s2">'request'</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The URL of the request. This only specifies the pathname and the search</span>
     <span class="s3">* part of the URL.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly url: {</span>
        <span class="s3">/**</span>
         <span class="s3">* The pathname of the requested URL.</span>
         <span class="s3">*/</span>
        <span class="s1">readonly pathname: string;</span>
        <span class="s3">/**</span>
         <span class="s3">* The search part of the requested URL. If the request did not provide a</span>
         <span class="s3">* search part, this will be an empty string.</span>
         <span class="s3">*/</span>
        <span class="s1">readonly search: string;</span>
    <span class="s1">};</span>
    <span class="s1">readonly headers: ReadonlyHeaders;</span>
    <span class="s1">cookies: ReadonlyRequestCookies;</span>
    <span class="s1">readonly mutableCookies: ResponseCookies;</span>
    <span class="s1">readonly userspaceMutableCookies: ResponseCookies;</span>
    <span class="s1">readonly draftMode: DraftModeProvider;</span>
    <span class="s1">readonly isHmrRefresh?: boolean;</span>
    <span class="s1">readonly serverComponentsHmrCache?: ServerComponentsHmrCache;</span>
    <span class="s1">readonly rootParams: Params;</span>
    <span class="s3">/**</span>
     <span class="s3">* The resume data cache for this request. This will be a immutable cache.</span>
     <span class="s3">*/</span>
    <span class="s1">renderResumeDataCache: RenderResumeDataCache | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">usedDynamic?: boolean;</span>
    <span class="s1">prerenderPhase?: boolean;</span>
    <span class="s1">devFallbackParams?: FallbackRouteParams | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* The Prerender store is for tracking information related to prerenders.</span>
 <span class="s3">*</span>
 <span class="s3">* It can be used for both RSC and SSR prerendering and should be scoped as close</span>
 <span class="s3">* to the individual `renderTo...` API call as possible. To keep the type simple</span>
 <span class="s3">* we don't distinguish between RSC and SSR prerendering explicitly but instead</span>
 <span class="s3">* use conditional object properties to infer which mode we are in. For instance cache tracking</span>
 <span class="s3">* only needs to happen during the RSC prerender when we are prospectively prerendering</span>
 <span class="s3">* to fill all caches.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">type PrerenderStoreModern = PrerenderStoreModernClient | PrerenderStoreModernServer | PrerenderStoreModernRuntime;</span>
<span class="s3">/** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */</span>
<span class="s0">export </span><span class="s1">type StaticPrerenderStoreModern = Exclude&lt;PrerenderStoreModern, PrerenderStoreModernRuntime&gt;;</span>
<span class="s0">export interface </span><span class="s1">PrerenderStoreModernClient </span><span class="s0">extends </span><span class="s1">PrerenderStoreModernCommon, StaticPrerenderStoreCommon {</span>
    <span class="s1">readonly type: </span><span class="s2">'prerender-client'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">PrerenderStoreModernServer </span><span class="s0">extends </span><span class="s1">PrerenderStoreModernCommon, StaticPrerenderStoreCommon {</span>
    <span class="s1">readonly type: </span><span class="s2">'prerender'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">PrerenderStoreModernRuntime </span><span class="s0">extends </span><span class="s1">PrerenderStoreModernCommon {</span>
    <span class="s1">readonly type: </span><span class="s2">'prerender-runtime'</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* A runtime prerender resolves APIs in two tasks:</span>
     <span class="s3">*</span>
     <span class="s3">* 1. Static data (available in a static prerender)</span>
     <span class="s3">* 2. Runtime data (available in a runtime prerender)</span>
     <span class="s3">*</span>
     <span class="s3">* This separation is achieved by awaiting this promise in &quot;runtime&quot; APIs.</span>
     <span class="s3">* In the final prerender, the promise will be resolved during the second task,</span>
     <span class="s3">* and the render will be aborted in the task that follows it.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly runtimeStagePromise: Promise&lt;</span><span class="s0">void</span><span class="s1">&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">readonly cookies: RequestStore[</span><span class="s2">'cookies'</span><span class="s1">];</span>
    <span class="s1">readonly draftMode: RequestStore[</span><span class="s2">'draftMode'</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">RevalidateStore {</span>
    <span class="s1">revalidate: number;</span>
    <span class="s1">expire: number;</span>
    <span class="s1">stale: number;</span>
    <span class="s1">tags: </span><span class="s0">null </span><span class="s1">| string[];</span>
<span class="s1">}</span>
<span class="s0">interface </span><span class="s1">PrerenderStoreModernCommon </span><span class="s0">extends </span><span class="s1">CommonWorkUnitStore, RevalidateStore {</span>
    <span class="s3">/**</span>
     <span class="s3">* The render signal is aborted after React's `prerender` function is aborted</span>
     <span class="s3">* (using a separate signal), which happens in two cases:</span>
     <span class="s3">*</span>
     <span class="s3">* 1. When all caches are filled during the prospective prerender.</span>
     <span class="s3">* 2. When the final prerender is aborted immediately after the prerender was</span>
     <span class="s3">*    started.</span>
     <span class="s3">*</span>
     <span class="s3">* It can be used to reject any pending I/O, including hanging promises. This</span>
     <span class="s3">* allows React to properly track the async I/O in dev mode, which yields</span>
     <span class="s3">* better owner stacks for dynamic validation errors.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly renderSignal: AbortSignal;</span>
    <span class="s3">/**</span>
     <span class="s3">* This is the AbortController which represents the boundary between Prerender</span>
     <span class="s3">* and dynamic. In some renders it is the same as the controller for React,</span>
     <span class="s3">* but in others it is a separate controller. It should be aborted whenever we</span>
     <span class="s3">* are no longer in the prerender phase of rendering. Typically this is after</span>
     <span class="s3">* one task, or when you call a sync API which requires the prerender to end</span>
     <span class="s3">* immediately.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly controller: AbortController;</span>
    <span class="s3">/**</span>
     <span class="s3">* When not null, this signal is used to track cache reads during prerendering</span>
     <span class="s3">* and to await all cache reads completing, before aborting the prerender.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly cacheSignal: </span><span class="s0">null </span><span class="s1">| CacheSignal;</span>
    <span class="s3">/**</span>
     <span class="s3">* During some prerenders we want to track dynamic access.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly dynamicTracking: </span><span class="s0">null </span><span class="s1">| DynamicTrackingState;</span>
    <span class="s1">readonly rootParams: Params;</span>
    <span class="s3">/**</span>
     <span class="s3">* A mutable resume data cache for this prerender.</span>
     <span class="s3">*/</span>
    <span class="s1">prerenderResumeDataCache: PrerenderResumeDataCache | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* An immutable resume data cache for this prerender. This may be provided</span>
     <span class="s3">* instead of the `prerenderResumeDataCache` if the prerender is not supposed</span>
     <span class="s3">* to fill caches, and only read from prefilled caches, e.g. when prerendering</span>
     <span class="s3">* an optional fallback shell.</span>
     <span class="s3">*/</span>
    <span class="s1">renderResumeDataCache: RenderResumeDataCache | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The HMR refresh hash is only provided in dev mode. It is needed for the dev</span>
     <span class="s3">* warmup render to ensure that the cache keys will be identical for the</span>
     <span class="s3">* subsequent dynamic render.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly hmrRefreshHash: string | undefined;</span>
    <span class="s3">/**</span>
     <span class="s3">* Only available in dev mode.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly captureOwnerStack: undefined | (() =&gt; string | </span><span class="s0">null</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s0">interface </span><span class="s1">StaticPrerenderStoreCommon {</span>
    <span class="s3">/**</span>
     <span class="s3">* The set of unknown route parameters. Accessing these will be tracked as</span>
     <span class="s3">* a dynamic access.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly fallbackRouteParams: FallbackRouteParams | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* When true, the page is prerendered as a fallback shell, while allowing any</span>
     <span class="s3">* dynamic accesses to result in an empty shell. This is the case when there</span>
     <span class="s3">* are also routes prerendered with a more complete set of params.</span>
     <span class="s3">* Prerendering those routes would catch any invalid dynamic accesses.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly allowEmptyStaticShell: boolean;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">PrerenderStorePPR </span><span class="s0">extends </span><span class="s1">CommonWorkUnitStore, RevalidateStore {</span>
    <span class="s1">readonly type: </span><span class="s2">'prerender-ppr'</span><span class="s1">;</span>
    <span class="s1">readonly rootParams: Params;</span>
    <span class="s1">readonly dynamicTracking: </span><span class="s0">null </span><span class="s1">| DynamicTrackingState;</span>
    <span class="s3">/**</span>
     <span class="s3">* The set of unknown route parameters. Accessing these will be tracked as</span>
     <span class="s3">* a dynamic access.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly fallbackRouteParams: FallbackRouteParams | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The resume data cache for this prerender.</span>
     <span class="s3">*/</span>
    <span class="s1">prerenderResumeDataCache: PrerenderResumeDataCache;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">PrerenderStoreLegacy </span><span class="s0">extends </span><span class="s1">CommonWorkUnitStore, RevalidateStore {</span>
    <span class="s1">readonly type: </span><span class="s2">'prerender-legacy'</span><span class="s1">;</span>
    <span class="s1">readonly rootParams: Params;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type PrerenderStore = PrerenderStoreLegacy | PrerenderStorePPR | PrerenderStoreModern;</span>
<span class="s0">export </span><span class="s1">type StaticPrerenderStore = Exclude&lt;PrerenderStore, PrerenderStoreModernRuntime&gt;;</span>
<span class="s0">export interface </span><span class="s1">CommonCacheStore </span><span class="s0">extends </span><span class="s1">Omit&lt;CommonWorkUnitStore, </span><span class="s2">'implicitTags'</span><span class="s1">&gt; {</span>
    <span class="s3">/**</span>
     <span class="s3">* A cache work unit store might not always have an outer work unit store,</span>
     <span class="s3">* from which implicit tags could be inherited.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly implicitTags: ImplicitTags | undefined;</span>
    <span class="s3">/**</span>
     <span class="s3">* Draft mode is only available if the outer work unit store is a request</span>
     <span class="s3">* store and draft mode is enabled.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly draftMode: DraftModeProvider | undefined;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">CommonUseCacheStore </span><span class="s0">extends </span><span class="s1">CommonCacheStore, RevalidateStore {</span>
    <span class="s1">explicitRevalidate: undefined | number;</span>
    <span class="s1">explicitExpire: undefined | number;</span>
    <span class="s1">explicitStale: undefined | number;</span>
    <span class="s1">readonly hmrRefreshHash: string | undefined;</span>
    <span class="s1">readonly isHmrRefresh: boolean;</span>
    <span class="s1">readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined;</span>
    <span class="s1">readonly forceRevalidate: boolean;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">PublicUseCacheStore </span><span class="s0">extends </span><span class="s1">CommonUseCacheStore {</span>
    <span class="s1">readonly type: </span><span class="s2">'cache'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">PrivateUseCacheStore </span><span class="s0">extends </span><span class="s1">CommonUseCacheStore {</span>
    <span class="s1">readonly type: </span><span class="s2">'private-cache'</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* A runtime prerender resolves APIs in two tasks:</span>
     <span class="s3">*</span>
     <span class="s3">* 1. Static data (available in a static prerender)</span>
     <span class="s3">* 2. Runtime data (available in a runtime prerender)</span>
     <span class="s3">*</span>
     <span class="s3">* This separation is achieved by awaiting this promise in &quot;runtime&quot; APIs.</span>
     <span class="s3">* In the final prerender, the promise will be resolved during the second task,</span>
     <span class="s3">* and the render will be aborted in the task that follows it.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly runtimeStagePromise: Promise&lt;</span><span class="s0">void</span><span class="s1">&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* As opposed to the public cache store, the private cache store is allowed to</span>
     <span class="s3">* access the request cookies.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly cookies: ReadonlyRequestCookies;</span>
    <span class="s3">/**</span>
     <span class="s3">* Private caches don't currently need to track root params in the cache key</span>
     <span class="s3">* because they're not persisted anywhere, so we can allow root params access</span>
     <span class="s3">* (unlike public caches)</span>
     <span class="s3">*/</span>
    <span class="s1">readonly rootParams: Params;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type UseCacheStore = PublicUseCacheStore | PrivateUseCacheStore;</span>
<span class="s0">export interface </span><span class="s1">UnstableCacheStore </span><span class="s0">extends </span><span class="s1">CommonCacheStore {</span>
    <span class="s1">readonly type: </span><span class="s2">'unstable-cache'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* The Cache store is for tracking information inside a &quot;use cache&quot; or</span>
 <span class="s3">* unstable_cache context. A cache store shadows an outer request store (if</span>
 <span class="s3">* present) as a work unit, so that we never accidentally expose any request or</span>
 <span class="s3">* page specific information to cache functions, unless it's explicitly desired.</span>
 <span class="s3">* For those exceptions, the data is copied over from the request store to the</span>
 <span class="s3">* cache store, instead of generally making the request store available to cache</span>
 <span class="s3">* functions.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">type CacheStore = UseCacheStore | UnstableCacheStore;</span>
<span class="s0">export </span><span class="s1">type WorkUnitStore = RequestStore | CacheStore | PrerenderStore;</span>
<span class="s0">export </span><span class="s1">type WorkUnitAsyncStorage = AsyncLocalStorage&lt;WorkUnitStore&gt;;</span>
<span class="s0">export </span><span class="s1">{ workUnitAsyncStorageInstance as workUnitAsyncStorage };</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">throwForMissingRequestStore(callingExpression: string): never;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">throwInvariantForMissingStore(): never;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getPrerenderResumeDataCache(workUnitStore: WorkUnitStore): PrerenderResumeDataCache | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getRenderResumeDataCache(workUnitStore: WorkUnitStore): RenderResumeDataCache | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getHmrRefreshHash(workStore: WorkStore, workUnitStore: WorkUnitStore): string | undefined;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isHmrRefresh(workStore: WorkStore, workUnitStore: WorkUnitStore): boolean;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getServerComponentsHmrCache(workStore: WorkStore, workUnitStore: WorkUnitStore): ServerComponentsHmrCache | undefined;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns a draft mode provider only if draft mode is enabled.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getDraftModeProviderForCacheScope(workStore: WorkStore, workUnitStore: WorkUnitStore): DraftModeProvider | undefined;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getCacheSignal(workUnitStore: WorkUnitStore): CacheSignal | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getRuntimeStagePromise(workUnitStore: WorkUnitStore): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt; | </span><span class="s0">null</span><span class="s1">;</span>
</pre>
</body>
</html>