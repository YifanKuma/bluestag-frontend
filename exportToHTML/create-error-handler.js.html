<html>
<head>
<title>create-error-handler.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create-error-handler.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">createFlightReactServerErrorHandler: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createHTMLErrorHandler: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createHTMLReactServerErrorHandler: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getDigestForWellKnownError: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">isUserLandError: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">createFlightReactServerErrorHandler: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createFlightReactServerErrorHandler;</span>
    <span class="s1">},</span>
    <span class="s1">createHTMLErrorHandler: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createHTMLErrorHandler;</span>
    <span class="s1">},</span>
    <span class="s1">createHTMLReactServerErrorHandler: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createHTMLReactServerErrorHandler;</span>
    <span class="s1">},</span>
    <span class="s1">getDigestForWellKnownError: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getDigestForWellKnownError;</span>
    <span class="s1">},</span>
    <span class="s1">isUserLandError: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">isUserLandError;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_stringhash = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/string-hash&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_formatservererror = require(</span><span class="s0">&quot;../../lib/format-server-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_tracer = require(</span><span class="s0">&quot;../lib/trace/tracer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pipereadable = require(</span><span class="s0">&quot;../pipe-readable&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_bailouttocsr = require(</span><span class="s0">&quot;../../shared/lib/lazy-dynamic/bailout-to-csr&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hooksservercontext = require(</span><span class="s0">&quot;../../client/components/hooks-server-context&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isnextroutererror = require(</span><span class="s0">&quot;../../client/components/is-next-router-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrendering = require(</span><span class="s0">&quot;./dynamic-rendering&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_iserror = require(</span><span class="s0">&quot;../../lib/is-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_errortelemetryutils = require(</span><span class="s0">&quot;../../lib/error-telemetry-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_reactlargeshellerror = require(</span><span class="s0">&quot;./react-large-shell-error&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getDigestForWellKnownError(error) {</span>
    <span class="s4">// If we're bailing out to CSR, we don't need to log the error.</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _bailouttocsr.isBailoutToCSRError)(error)) </span><span class="s2">return </span><span class="s1">error.digest;</span>
    <span class="s4">// If this is a navigation error, we don't need to log the error.</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _isnextroutererror.isNextRouterError)(error)) </span><span class="s2">return </span><span class="s1">error.digest;</span>
    <span class="s4">// If this error occurs, we know that we should be stopping the static</span>
    <span class="s4">// render. This is only thrown in static generation when PPR is not enabled,</span>
    <span class="s4">// which causes the whole page to be marked as dynamic. We don't need to</span>
    <span class="s4">// tell the user about this error, as it's not actionable.</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _hooksservercontext.isDynamicServerError)(error)) </span><span class="s2">return </span><span class="s1">error.digest;</span>
    <span class="s4">// If this is a prerender interrupted error, we don't need to log the error.</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _dynamicrendering.isPrerenderInterruptedError)(error)) </span><span class="s2">return </span><span class="s1">error.digest;</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createFlightReactServerErrorHandler(shouldFormatError, onReactServerRenderError) {</span>
    <span class="s2">return </span><span class="s1">(thrownValue)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">thrownValue === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s4">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _stringhash.default)(thrownValue).toString();</span>
        <span class="s1">}</span>
        <span class="s4">// If the response was closed, we don't need to log the error.</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _pipereadable.isAbortError)(thrownValue)) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">digest = getDigestForWellKnownError(thrownValue);</span>
        <span class="s2">if </span><span class="s1">(digest) {</span>
            <span class="s2">return </span><span class="s1">digest;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(thrownValue)) {</span>
            <span class="s4">// TODO: Aggregate</span>
            <span class="s1">console.error(thrownValue);</span>
            <span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">err = (</span><span class="s3">0</span><span class="s1">, _iserror.getProperError)(thrownValue);</span>
        <span class="s4">// If the error already has a digest, respect the original digest,</span>
        <span class="s4">// so it won't get re-generated into another new error.</span>
        <span class="s2">if </span><span class="s1">(!err.digest) {</span>
            <span class="s4">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span>
            <span class="s1">err.digest = (</span><span class="s3">0</span><span class="s1">, _stringhash.default)(err.message + err.stack || </span><span class="s0">''</span><span class="s1">).toString();</span>
        <span class="s1">}</span>
        <span class="s4">// Format server errors in development to add more helpful error messages</span>
        <span class="s2">if </span><span class="s1">(shouldFormatError) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _formatservererror.formatServerError)(err);</span>
        <span class="s1">}</span>
        <span class="s4">// Record exception in an active span, if available.</span>
        <span class="s2">const </span><span class="s1">span = (</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().getActiveScopeSpan();</span>
        <span class="s2">if </span><span class="s1">(span) {</span>
            <span class="s1">span.recordException(err);</span>
            <span class="s1">span.setAttribute(</span><span class="s0">'error.type'</span><span class="s1">, err.name);</span>
            <span class="s1">span.setStatus({</span>
                <span class="s1">code: _tracer.SpanStatusCode.ERROR,</span>
                <span class="s1">message: err.message</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">onReactServerRenderError(err);</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _errortelemetryutils.createDigestWithErrorCode)(thrownValue, err.digest);</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createHTMLReactServerErrorHandler(shouldFormatError, isNextExport, reactServerErrors, silenceLogger, onReactServerRenderError) {</span>
    <span class="s2">return </span><span class="s1">(thrownValue)=&gt;{</span>
        <span class="s2">var </span><span class="s1">_err_message;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">thrownValue === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s4">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _stringhash.default)(thrownValue).toString();</span>
        <span class="s1">}</span>
        <span class="s4">// If the response was closed, we don't need to log the error.</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _pipereadable.isAbortError)(thrownValue)) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">digest = getDigestForWellKnownError(thrownValue);</span>
        <span class="s2">if </span><span class="s1">(digest) {</span>
            <span class="s2">return </span><span class="s1">digest;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(thrownValue)) {</span>
            <span class="s4">// TODO: Aggregate</span>
            <span class="s1">console.error(thrownValue);</span>
            <span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">err = (</span><span class="s3">0</span><span class="s1">, _iserror.getProperError)(thrownValue);</span>
        <span class="s4">// If the error already has a digest, respect the original digest,</span>
        <span class="s4">// so it won't get re-generated into another new error.</span>
        <span class="s2">if </span><span class="s1">(!err.digest) {</span>
            <span class="s4">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span>
            <span class="s1">err.digest = (</span><span class="s3">0</span><span class="s1">, _stringhash.default)(err.message + (err.stack || </span><span class="s0">''</span><span class="s1">)).toString();</span>
        <span class="s1">}</span>
        <span class="s4">// @TODO by putting this here and not at the top it is possible that</span>
        <span class="s4">// we don't error the build in places we actually expect to</span>
        <span class="s2">if </span><span class="s1">(!reactServerErrors.has(err.digest)) {</span>
            <span class="s1">reactServerErrors.set(err.digest, err);</span>
        <span class="s1">}</span>
        <span class="s4">// Format server errors in development to add more helpful error messages</span>
        <span class="s2">if </span><span class="s1">(shouldFormatError) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _formatservererror.formatServerError)(err);</span>
        <span class="s1">}</span>
        <span class="s4">// Don't log the suppressed error during export</span>
        <span class="s2">if </span><span class="s1">(!(isNextExport &amp;&amp; (err == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_err_message = err.message) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _err_message.includes(</span><span class="s0">'The specific message is omitted in production builds to avoid leaking sensitive details.'</span><span class="s1">)))) {</span>
            <span class="s4">// Record exception in an active span, if available.</span>
            <span class="s2">const </span><span class="s1">span = (</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().getActiveScopeSpan();</span>
            <span class="s2">if </span><span class="s1">(span) {</span>
                <span class="s1">span.recordException(err);</span>
                <span class="s1">span.setAttribute(</span><span class="s0">'error.type'</span><span class="s1">, err.name);</span>
                <span class="s1">span.setStatus({</span>
                    <span class="s1">code: _tracer.SpanStatusCode.ERROR,</span>
                    <span class="s1">message: err.message</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!silenceLogger) {</span>
                <span class="s1">onReactServerRenderError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: onReactServerRenderError(err);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _errortelemetryutils.createDigestWithErrorCode)(thrownValue, err.digest);</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createHTMLErrorHandler(shouldFormatError, isNextExport, reactServerErrors, allCapturedErrors, silenceLogger, onHTMLRenderSSRError) {</span>
    <span class="s2">return </span><span class="s1">(thrownValue, errorInfo)=&gt;{</span>
        <span class="s2">var </span><span class="s1">_err_message;</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(thrownValue)) {</span>
            <span class="s4">// TODO: Aggregate</span>
            <span class="s1">console.error(thrownValue);</span>
            <span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">isSSRError = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">allCapturedErrors.push(thrownValue);</span>
        <span class="s4">// If the response was closed, we don't need to log the error.</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _pipereadable.isAbortError)(thrownValue)) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">digest = getDigestForWellKnownError(thrownValue);</span>
        <span class="s2">if </span><span class="s1">(digest) {</span>
            <span class="s2">return </span><span class="s1">digest;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">err = (</span><span class="s3">0</span><span class="s1">, _iserror.getProperError)(thrownValue);</span>
        <span class="s4">// If the error already has a digest, respect the original digest,</span>
        <span class="s4">// so it won't get re-generated into another new error.</span>
        <span class="s2">if </span><span class="s1">(err.digest) {</span>
            <span class="s2">if </span><span class="s1">(reactServerErrors.has(err.digest)) {</span>
                <span class="s4">// This error is likely an obfuscated error from react-server.</span>
                <span class="s4">// We recover the original error here.</span>
                <span class="s1">thrownValue = reactServerErrors.get(err.digest);</span>
                <span class="s1">isSSRError = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// The error is not from react-server but has a digest</span>
            <span class="s4">// from other means so we don't need to produce a new one</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">err.digest = (</span><span class="s3">0</span><span class="s1">, _stringhash.default)(err.message + ((errorInfo == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: errorInfo.componentStack) || err.stack || </span><span class="s0">''</span><span class="s1">)).toString();</span>
        <span class="s1">}</span>
        <span class="s4">// Format server errors in development to add more helpful error messages</span>
        <span class="s2">if </span><span class="s1">(shouldFormatError) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _formatservererror.formatServerError)(err);</span>
        <span class="s1">}</span>
        <span class="s4">// Don't log the suppressed error during export</span>
        <span class="s2">if </span><span class="s1">(!(isNextExport &amp;&amp; (err == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_err_message = err.message) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _err_message.includes(</span><span class="s0">'The specific message is omitted in production builds to avoid leaking sensitive details.'</span><span class="s1">)))) {</span>
            <span class="s4">// Record exception in an active span, if available.</span>
            <span class="s2">const </span><span class="s1">span = (</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().getActiveScopeSpan();</span>
            <span class="s2">if </span><span class="s1">(span) {</span>
                <span class="s1">span.recordException(err);</span>
                <span class="s1">span.setAttribute(</span><span class="s0">'error.type'</span><span class="s1">, err.name);</span>
                <span class="s1">span.setStatus({</span>
                    <span class="s1">code: _tracer.SpanStatusCode.ERROR,</span>
                    <span class="s1">message: err.message</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!silenceLogger &amp;&amp; </span><span class="s4">// HTML errors contain RSC errors as well, filter them out before reporting</span>
            <span class="s1">isSSRError) {</span>
                <span class="s1">onHTMLRenderSSRError(err, errorInfo);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _errortelemetryutils.createDigestWithErrorCode)(thrownValue, err.digest);</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isUserLandError(err) {</span>
    <span class="s2">return </span><span class="s1">!(</span><span class="s3">0</span><span class="s1">, _pipereadable.isAbortError)(err) &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _bailouttocsr.isBailoutToCSRError)(err) &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _isnextroutererror.isNextRouterError)(err);</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=create-error-handler.js.map</span></pre>
</body>
</html>