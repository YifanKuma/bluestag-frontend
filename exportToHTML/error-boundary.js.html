<html>
<head>
<title>error-boundary.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
error-boundary.js</font>
</center></td></tr></table>
<pre><span class="s0">'use client'</span><span class="s1">;</span>
<span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;HTTPAccessFallbackBoundary&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">HTTPAccessFallbackBoundary;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_interop_require_wildcard = require(</span><span class="s0">&quot;@swc/helpers/_/_interop_require_wildcard&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_jsxruntime = require(</span><span class="s0">&quot;react/jsx-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard._(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_navigationuntracked = require(</span><span class="s0">&quot;../navigation-untracked&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_httpaccessfallback = require(</span><span class="s0">&quot;./http-access-fallback&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_warnonce = require(</span><span class="s0">&quot;../../../shared/lib/utils/warn-once&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approutercontextsharedruntime = require(</span><span class="s0">&quot;../../../shared/lib/app-router-context.shared-runtime&quot;</span><span class="s1">);</span>
<span class="s2">class </span><span class="s1">HTTPAccessFallbackErrorBoundary </span><span class="s2">extends </span><span class="s1">_react.default.Component {</span>
    <span class="s1">componentDidCatch() {</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.props.missingSlots &amp;&amp; </span><span class="s2">this</span><span class="s1">.props.missingSlots.size &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s3">// A missing children slot is the typical not-found case, so no need to warn</span>
        <span class="s1">!</span><span class="s2">this</span><span class="s1">.props.missingSlots.has(</span><span class="s0">'children'</span><span class="s1">)) {</span>
            <span class="s2">let </span><span class="s1">warningMessage = </span><span class="s0">'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ </span><span class="s0">'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs</span><span class="s5">\n\n</span><span class="s0">'</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">formattedSlots = Array.from(</span><span class="s2">this</span><span class="s1">.props.missingSlots).sort((a, b)=&gt;a.localeCompare(b)).map((slot)=&gt;</span><span class="s0">&quot;@&quot; </span><span class="s1">+ slot).join(</span><span class="s0">', '</span><span class="s1">);</span>
            <span class="s1">warningMessage += </span><span class="s0">'Missing slots: ' </span><span class="s1">+ formattedSlots;</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _warnonce.warnOnce)(warningMessage);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">static </span><span class="s1">getDerivedStateFromError(error) {</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {</span>
            <span class="s2">const </span><span class="s1">httpStatus = (</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">triggeredStatus: httpStatus</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s3">// Re-throw if error is not for 404</span>
        <span class="s2">throw </span><span class="s1">error;</span>
    <span class="s1">}</span>
    <span class="s2">static </span><span class="s1">getDerivedStateFromProps(props, state) {</span>
        <span class="s3">/**</span>
     <span class="s3">* Handles reset of the error boundary when a navigation happens.</span>
     <span class="s3">* Ensures the error boundary does not stay enabled when navigating to a new page.</span>
     <span class="s3">* Approach of setState in render is safe as it checks the previous pathname and then overrides</span>
     <span class="s3">* it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders</span>
     <span class="s3">*/ </span><span class="s2">if </span><span class="s1">(props.pathname !== state.previousPathname &amp;&amp; state.triggeredStatus) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">triggeredStatus: undefined,</span>
                <span class="s1">previousPathname: props.pathname</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">triggeredStatus: state.triggeredStatus,</span>
            <span class="s1">previousPathname: props.pathname</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">render() {</span>
        <span class="s2">const </span><span class="s1">{ notFound, forbidden, unauthorized, children } = </span><span class="s2">this</span><span class="s1">.props;</span>
        <span class="s2">const </span><span class="s1">{ triggeredStatus } = </span><span class="s2">this</span><span class="s1">.state;</span>
        <span class="s2">const </span><span class="s1">errorComponents = {</span>
            <span class="s1">[_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,</span>
            <span class="s1">[_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,</span>
            <span class="s1">[_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized</span>
        <span class="s1">};</span>
        <span class="s2">if </span><span class="s1">(triggeredStatus) {</span>
            <span class="s2">const </span><span class="s1">isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND &amp;&amp; notFound;</span>
            <span class="s2">const </span><span class="s1">isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN &amp;&amp; forbidden;</span>
            <span class="s2">const </span><span class="s1">isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED &amp;&amp; unauthorized;</span>
            <span class="s3">// If there's no matched boundary in this layer, keep throwing the error by rendering the children</span>
            <span class="s2">if </span><span class="s1">(!(isNotFound || isForbidden || isUnauthorized)) {</span>
                <span class="s2">return </span><span class="s1">children;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
                <span class="s1">children: [</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(</span><span class="s0">&quot;meta&quot;</span><span class="s1">, {</span>
                        <span class="s1">name: </span><span class="s0">&quot;robots&quot;</span><span class="s1">,</span>
                        <span class="s1">content: </span><span class="s0">&quot;noindex&quot;</span>
                    <span class="s1">}),</span>
                    <span class="s1">process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(</span><span class="s0">&quot;meta&quot;</span><span class="s1">, {</span>
                        <span class="s1">name: </span><span class="s0">&quot;boundary-next-error&quot;</span><span class="s1">,</span>
                        <span class="s1">content: (</span><span class="s4">0</span><span class="s1">, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)</span>
                    <span class="s1">}),</span>
                    <span class="s1">errorComponents[triggeredStatus]</span>
                <span class="s1">]</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">children;</span>
    <span class="s1">}</span>
    <span class="s1">constructor(props){</span>
        <span class="s2">super</span><span class="s1">(props);</span>
        <span class="s2">this</span><span class="s1">.state = {</span>
            <span class="s1">triggeredStatus: undefined,</span>
            <span class="s1">previousPathname: props.pathname</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">HTTPAccessFallbackBoundary(param) {</span>
    <span class="s2">let </span><span class="s1">{ notFound, forbidden, unauthorized, children } = param;</span>
    <span class="s3">// When we're rendering the missing params shell, this will return null. This</span>
    <span class="s3">// is because we won't be rendering any not found boundaries or error</span>
    <span class="s3">// boundaries for the missing params shell. When this runs on the client</span>
    <span class="s3">// (where these error can occur), we will get the correct pathname.</span>
    <span class="s2">const </span><span class="s1">pathname = (</span><span class="s4">0</span><span class="s1">, _navigationuntracked.useUntrackedPathname)();</span>
    <span class="s2">const </span><span class="s1">missingSlots = (</span><span class="s4">0</span><span class="s1">, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);</span>
    <span class="s2">const </span><span class="s1">hasErrorFallback = !!(notFound || forbidden || unauthorized);</span>
    <span class="s2">if </span><span class="s1">(hasErrorFallback) {</span>
        <span class="s2">return </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {</span>
            <span class="s1">pathname: pathname,</span>
            <span class="s1">notFound: notFound,</span>
            <span class="s1">forbidden: forbidden,</span>
            <span class="s1">unauthorized: unauthorized,</span>
            <span class="s1">missingSlots: missingSlots,</span>
            <span class="s1">children: children</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(_jsxruntime.Fragment, {</span>
        <span class="s1">children: children</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=error-boundary.js.map</span></pre>
</body>
</html>