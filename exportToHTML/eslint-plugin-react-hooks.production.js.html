<html>
<head>
<title>eslint-plugin-react-hooks.production.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
.s7 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
eslint-plugin-react-hooks.production.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@license </span><span class="s0">React</span>
 <span class="s0">* eslint-plugin-react-hooks.production.js</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s3">'use strict'</span><span class="s2">;</span>

<span class="s0">/*! ***************************************************************************** 
Copyright (c) Microsoft Corporation. 
 
Permission to use, copy, modify, and/or distribute this software for any 
purpose with or without fee is hereby granted. 
 
THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH 
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, 
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR 
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR 
PERFORMANCE OF THIS SOFTWARE. 
***************************************************************************** */</span>
<span class="s0">/* global Reflect, Promise */</span>


<span class="s4">function </span><span class="s2">__values(o) {</span>
    <span class="s4">var </span><span class="s2">s = </span><span class="s4">typeof </span><span class="s2">Symbol === </span><span class="s3">&quot;function&quot; </span><span class="s2">&amp;&amp; Symbol.iterator, m = s &amp;&amp; o[s], i = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(m) </span><span class="s4">return </span><span class="s2">m.call(o);</span>
    <span class="s4">if </span><span class="s2">(o &amp;&amp; </span><span class="s4">typeof </span><span class="s2">o.length === </span><span class="s3">&quot;number&quot;</span><span class="s2">) </span><span class="s4">return </span><span class="s2">{</span>
        <span class="s2">next: </span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s4">if </span><span class="s2">(o &amp;&amp; i &gt;= o.length) o = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s4">return </span><span class="s2">{ value: o &amp;&amp; o[i++], done: !o };</span>
        <span class="s2">}</span>
    <span class="s2">};</span>
    <span class="s4">throw new </span><span class="s2">TypeError(s ? </span><span class="s3">&quot;Object is not iterable.&quot; </span><span class="s2">: </span><span class="s3">&quot;Symbol.iterator is not defined.&quot;</span><span class="s2">);</span>
<span class="s2">}</span>

<span class="s4">function </span><span class="s2">__read(o, n) {</span>
    <span class="s4">var </span><span class="s2">m = </span><span class="s4">typeof </span><span class="s2">Symbol === </span><span class="s3">&quot;function&quot; </span><span class="s2">&amp;&amp; o[Symbol.iterator];</span>
    <span class="s4">if </span><span class="s2">(!m) </span><span class="s4">return </span><span class="s2">o;</span>
    <span class="s4">var </span><span class="s2">i = m.call(o), r, ar = [], e;</span>
    <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">while </span><span class="s2">((n === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">|| n-- &gt; </span><span class="s5">0</span><span class="s2">) &amp;&amp; !(r = i.next()).done) ar.push(r.value);</span>
    <span class="s2">}</span>
    <span class="s4">catch </span><span class="s2">(error) { e = { error: error }; }</span>
    <span class="s4">finally </span><span class="s2">{</span>
        <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">if </span><span class="s2">(r &amp;&amp; !r.done &amp;&amp; (m = i[</span><span class="s3">&quot;return&quot;</span><span class="s2">])) m.call(i);</span>
        <span class="s2">}</span>
        <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e) </span><span class="s4">throw </span><span class="s2">e.error; }</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">ar;</span>
<span class="s2">}</span>

<span class="s4">function </span><span class="s2">__spreadArray(to, from, pack) {</span>
    <span class="s4">if </span><span class="s2">(pack || arguments.length === </span><span class="s5">2</span><span class="s2">) </span><span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">, l = from.length, ar; i &lt; l; i++) {</span>
        <span class="s4">if </span><span class="s2">(ar || !(i </span><span class="s4">in </span><span class="s2">from)) {</span>
            <span class="s4">if </span><span class="s2">(!ar) ar = Array.prototype.slice.call(from, </span><span class="s5">0</span><span class="s2">, i);</span>
            <span class="s2">ar[i] = from[i];</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">to.concat(ar || from);</span>
<span class="s2">}</span>

<span class="s0">/* eslint-disable no-for-of-loops/no-for-of-loops */</span>
<span class="s0">/**</span>
 <span class="s0">* Catch all identifiers that begin with &quot;use&quot; followed by an uppercase Latin</span>
 <span class="s0">* character to exclude identifiers like &quot;user&quot;.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isHookName(s) {</span>
    <span class="s4">return </span><span class="s2">s === </span><span class="s3">'use' </span><span class="s2">|| </span><span class="s6">/^use[A-Z0-9]/</span><span class="s2">.test(s);</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* We consider hooks to be a hook name identifier or a member expression</span>
 <span class="s0">* containing a hook name.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isHook(node) {</span>
    <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
        <span class="s4">return </span><span class="s2">isHookName(node.name);</span>
    <span class="s2">}</span>
    <span class="s4">else if </span><span class="s2">(node.type === </span><span class="s3">'MemberExpression' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">!node.computed &amp;&amp;</span>
        <span class="s2">isHook(node.property)) {</span>
        <span class="s4">var </span><span class="s2">obj = node.object;</span>
        <span class="s4">var </span><span class="s2">isPascalCaseNameSpace = </span><span class="s6">/^[A-Z].*/</span><span class="s2">;</span>
        <span class="s4">return </span><span class="s2">obj.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp; isPascalCaseNameSpace.test(obj.name);</span>
    <span class="s2">}</span>
    <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">return false</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* Checks if the node is a React component name. React component names must</span>
 <span class="s0">* always start with an uppercase letter.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isComponentName(node) {</span>
    <span class="s4">return </span><span class="s2">node.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp; </span><span class="s6">/^[A-Z]/</span><span class="s2">.test(node.name);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isReactFunction(node, functionName) {</span>
    <span class="s4">return </span><span class="s2">((</span><span class="s3">'name' </span><span class="s4">in </span><span class="s2">node &amp;&amp; node.name === functionName) ||</span>
        <span class="s2">(node.type === </span><span class="s3">'MemberExpression' </span><span class="s2">&amp;&amp;</span>
            <span class="s3">'name' </span><span class="s4">in </span><span class="s2">node.object &amp;&amp;</span>
            <span class="s2">node.object.name === </span><span class="s3">'React' </span><span class="s2">&amp;&amp;</span>
            <span class="s3">'name' </span><span class="s4">in </span><span class="s2">node.property &amp;&amp;</span>
            <span class="s2">node.property.name === functionName));</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* Checks if the node is a callback argument of forwardRef. This render function</span>
 <span class="s0">* should follow the rules of hooks.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isForwardRefCallback(node) {</span>
    <span class="s4">return </span><span class="s2">!!(node.parent &amp;&amp;</span>
        <span class="s3">'callee' </span><span class="s4">in </span><span class="s2">node.parent &amp;&amp;</span>
        <span class="s2">node.parent.callee &amp;&amp;</span>
        <span class="s2">isReactFunction(node.parent.callee, </span><span class="s3">'forwardRef'</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* Checks if the node is a callback argument of React.memo. This anonymous</span>
 <span class="s0">* functional component should follow the rules of hooks.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isMemoCallback(node) {</span>
    <span class="s4">return </span><span class="s2">!!(node.parent &amp;&amp;</span>
        <span class="s3">'callee' </span><span class="s4">in </span><span class="s2">node.parent &amp;&amp;</span>
        <span class="s2">node.parent.callee &amp;&amp;</span>
        <span class="s2">isReactFunction(node.parent.callee, </span><span class="s3">'memo'</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isInsideComponentOrHook(node) {</span>
    <span class="s4">while </span><span class="s2">(node) {</span>
        <span class="s4">var </span><span class="s2">functionName = getFunctionName(node);</span>
        <span class="s4">if </span><span class="s2">(functionName) {</span>
            <span class="s4">if </span><span class="s2">(isComponentName(functionName) || isHook(functionName)) {</span>
                <span class="s4">return true</span><span class="s2">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(isForwardRefCallback(node) || isMemoCallback(node)) {</span>
            <span class="s4">return true</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">node = node.parent;</span>
    <span class="s2">}</span>
    <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isInsideDoWhileLoop(node) {</span>
    <span class="s4">while </span><span class="s2">(node) {</span>
        <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'DoWhileStatement'</span><span class="s2">) {</span>
            <span class="s4">return true</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s2">node = node.parent;</span>
    <span class="s2">}</span>
    <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isUseEffectEventIdentifier$1(node) {</span>
    <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isUseIdentifier(node) {</span>
    <span class="s4">return </span><span class="s2">isReactFunction(node, </span><span class="s3">'use'</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">rule$1 = {</span>
    <span class="s2">meta: {</span>
        <span class="s2">type: </span><span class="s3">'problem'</span><span class="s2">,</span>
        <span class="s2">docs: {</span>
            <span class="s2">description: </span><span class="s3">'enforces the Rules of Hooks'</span><span class="s2">,</span>
            <span class="s2">recommended: </span><span class="s4">true</span><span class="s2">,</span>
            <span class="s2">url: </span><span class="s3">'https://reactjs.org/docs/hooks-rules.html'</span><span class="s2">,</span>
        <span class="s2">},</span>
    <span class="s2">},</span>
    <span class="s2">create: </span><span class="s4">function </span><span class="s2">(context) {</span>
        <span class="s4">var </span><span class="s2">lastEffect = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">var </span><span class="s2">codePathReactHooksMapStack = [];</span>
        <span class="s4">var </span><span class="s2">codePathSegmentStack = [];</span>
        <span class="s4">var </span><span class="s2">useEffectEventFunctions = </span><span class="s4">new </span><span class="s2">WeakSet();</span>
        <span class="s0">// For a given scope, iterate through the references and add all useEffectEvent definitions. We can</span>
        <span class="s0">// do this in non-Program nodes because we can rely on the assumption that useEffectEvent functions</span>
        <span class="s0">// can only be declared within a component or hook at its top level.</span>
        <span class="s4">function </span><span class="s2">recordAllUseEffectEventFunctions(scope) {</span>
            <span class="s4">var </span><span class="s2">e_1, _a, e_2, _b;</span>
            <span class="s4">try </span><span class="s2">{</span>
                <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_c = __values(scope.references), _d = _c.next(); !_d.done; _d = _c.next()) {</span>
                    <span class="s4">var </span><span class="s2">reference = _d.value;</span>
                    <span class="s4">var </span><span class="s2">parent = reference.identifier.parent;</span>
                    <span class="s4">if </span><span class="s2">((parent === </span><span class="s4">null </span><span class="s2">|| parent === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: parent.type) === </span><span class="s3">'VariableDeclarator' </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">parent.init &amp;&amp;</span>
                        <span class="s2">parent.init.type === </span><span class="s3">'CallExpression' </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">parent.init.callee &amp;&amp;</span>
                        <span class="s2">isUseEffectEventIdentifier$1(parent.init.callee)) {</span>
                        <span class="s4">if </span><span class="s2">(reference.resolved === </span><span class="s4">null</span><span class="s2">) {</span>
                            <span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">'Unexpected null reference.resolved'</span><span class="s2">);</span>
                        <span class="s2">}</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_e = (e_2 = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">, __values(reference.resolved.references)), _f = _e.next(); !_f.done; _f = _e.next()) {</span>
                                <span class="s4">var </span><span class="s2">ref = _f.value;</span>
                                <span class="s4">if </span><span class="s2">(ref !== reference) {</span>
                                    <span class="s2">useEffectEventFunctions.add(ref.identifier);</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s4">catch </span><span class="s2">(e_2_1) { e_2 = { error: e_2_1 }; }</span>
                        <span class="s4">finally </span><span class="s2">{</span>
                            <span class="s4">try </span><span class="s2">{</span>
                                <span class="s4">if </span><span class="s2">(_f &amp;&amp; !_f.done &amp;&amp; (_b = _e.return)) _b.call(_e);</span>
                            <span class="s2">}</span>
                            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_2) </span><span class="s4">throw </span><span class="s2">e_2.error; }</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s4">catch </span><span class="s2">(e_1_1) { e_1 = { error: e_1_1 }; }</span>
            <span class="s4">finally </span><span class="s2">{</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s4">if </span><span class="s2">(_d &amp;&amp; !_d.done &amp;&amp; (_a = _c.return)) _a.call(_c);</span>
                <span class="s2">}</span>
                <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_1) </span><span class="s4">throw </span><span class="s2">e_1.error; }</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* SourceCode that also works down to ESLint 3.0.0</span>
         <span class="s0">*/</span>
        <span class="s4">var </span><span class="s2">getSourceCode = </span><span class="s4">typeof </span><span class="s2">context.getSourceCode === </span><span class="s3">'function'</span>
            <span class="s2">? </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">context.getSourceCode();</span>
            <span class="s2">}</span>
            <span class="s2">: </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">context.sourceCode;</span>
            <span class="s2">};</span>
        <span class="s0">/**</span>
         <span class="s0">* SourceCode#getScope that also works down to ESLint 3.0.0</span>
         <span class="s0">*/</span>
        <span class="s4">var </span><span class="s2">getScope = </span><span class="s4">typeof </span><span class="s2">context.getScope === </span><span class="s3">'function'</span>
            <span class="s2">? </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">context.getScope();</span>
            <span class="s2">}</span>
            <span class="s2">: </span><span class="s4">function </span><span class="s2">(node) {</span>
                <span class="s4">return </span><span class="s2">getSourceCode().getScope(node);</span>
            <span class="s2">};</span>
        <span class="s4">return </span><span class="s2">{</span>
            <span class="s0">// Maintain code segment path stack as we traverse.</span>
            <span class="s2">onCodePathSegmentStart: </span><span class="s4">function </span><span class="s2">(segment) { </span><span class="s4">return </span><span class="s2">codePathSegmentStack.push(segment); },</span>
            <span class="s2">onCodePathSegmentEnd: </span><span class="s4">function </span><span class="s2">() { </span><span class="s4">return </span><span class="s2">codePathSegmentStack.pop(); },</span>
            <span class="s0">// Maintain code path stack as we traverse.</span>
            <span class="s2">onCodePathStart: </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">codePathReactHooksMapStack.push(</span><span class="s4">new </span><span class="s2">Map());</span>
            <span class="s2">},</span>
            <span class="s0">// Process our code path.</span>
            <span class="s0">//</span>
            <span class="s0">// Everything is ok if all React Hooks are both reachable from the initial</span>
            <span class="s0">// segment and reachable from every final segment.</span>
            <span class="s2">onCodePathEnd: </span><span class="s4">function </span><span class="s2">(codePath, codePathNode) {</span>
                <span class="s4">var </span><span class="s2">e_3, _a, e_4, _b, e_5, _c;</span>
                <span class="s4">var </span><span class="s2">reactHooksMap = codePathReactHooksMapStack.pop();</span>
                <span class="s4">if </span><span class="s2">((reactHooksMap === </span><span class="s4">null </span><span class="s2">|| reactHooksMap === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: reactHooksMap.size) === </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s4">return</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">else if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">reactHooksMap === </span><span class="s3">'undefined'</span><span class="s2">) {</span>
                    <span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">'Unexpected undefined reactHooksMap'</span><span class="s2">);</span>
                <span class="s2">}</span>
                <span class="s0">// All of the segments which are cyclic are recorded in this set.</span>
                <span class="s4">var </span><span class="s2">cyclic = </span><span class="s4">new </span><span class="s2">Set();</span>
                <span class="s0">/**</span>
                 <span class="s0">* Count the number of code paths from the start of the function to this</span>
                 <span class="s0">* segment. For example:</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* function MyComponent() {</span>
                 <span class="s0">*   if (condition) {</span>
                 <span class="s0">*     // Segment 1</span>
                 <span class="s0">*   } else {</span>
                 <span class="s0">*     // Segment 2</span>
                 <span class="s0">*   }</span>
                 <span class="s0">*   // Segment 3</span>
                 <span class="s0">* }</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* Segments 1 and 2 have one path to the beginning of `MyComponent` and</span>
                 <span class="s0">* segment 3 has two paths to the beginning of `MyComponent` since we</span>
                 <span class="s0">* could have either taken the path of segment 1 or segment 2.</span>
                 <span class="s0">*</span>
                 <span class="s0">* Populates `cyclic` with cyclic segments.</span>
                 <span class="s0">*/</span>
                <span class="s4">function </span><span class="s2">countPathsFromStart(segment, pathHistory) {</span>
                    <span class="s4">var </span><span class="s2">e_6, _a, e_7, _b;</span>
                    <span class="s4">var </span><span class="s2">cache = countPathsFromStart.cache;</span>
                    <span class="s4">var </span><span class="s2">paths = cache.get(segment.id);</span>
                    <span class="s4">var </span><span class="s2">pathList = </span><span class="s4">new </span><span class="s2">Set(pathHistory);</span>
                    <span class="s0">// If `pathList` includes the current segment then we've found a cycle!</span>
                    <span class="s0">// We need to fill `cyclic` with all segments inside cycle</span>
                    <span class="s4">if </span><span class="s2">(pathList.has(segment.id)) {</span>
                        <span class="s4">var </span><span class="s2">pathArray = __spreadArray([], __read(pathList), </span><span class="s4">false</span><span class="s2">);</span>
                        <span class="s4">var </span><span class="s2">cyclicSegments = pathArray.slice(pathArray.indexOf(segment.id) + </span><span class="s5">1</span><span class="s2">);</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">cyclicSegments_1 = __values(cyclicSegments), cyclicSegments_1_1 = cyclicSegments_1.next(); !cyclicSegments_1_1.done; cyclicSegments_1_1 = cyclicSegments_1.next()) {</span>
                                <span class="s4">var </span><span class="s2">cyclicSegment = cyclicSegments_1_1.value;</span>
                                <span class="s2">cyclic.add(cyclicSegment);</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s4">catch </span><span class="s2">(e_6_1) { e_6 = { error: e_6_1 }; }</span>
                        <span class="s4">finally </span><span class="s2">{</span>
                            <span class="s4">try </span><span class="s2">{</span>
                                <span class="s4">if </span><span class="s2">(cyclicSegments_1_1 &amp;&amp; !cyclicSegments_1_1.done &amp;&amp; (_a = cyclicSegments_1.return)) _a.call(cyclicSegments_1);</span>
                            <span class="s2">}</span>
                            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_6) </span><span class="s4">throw </span><span class="s2">e_6.error; }</span>
                        <span class="s2">}</span>
                        <span class="s4">return </span><span class="s2">BigInt(</span><span class="s3">'0'</span><span class="s2">);</span>
                    <span class="s2">}</span>
                    <span class="s0">// add the current segment to pathList</span>
                    <span class="s2">pathList.add(segment.id);</span>
                    <span class="s0">// We have a cached `paths`. Return it.</span>
                    <span class="s4">if </span><span class="s2">(paths !== undefined) {</span>
                        <span class="s4">return </span><span class="s2">paths;</span>
                    <span class="s2">}</span>
                    <span class="s4">if </span><span class="s2">(codePath.thrownSegments.includes(segment)) {</span>
                        <span class="s2">paths = BigInt(</span><span class="s3">'0'</span><span class="s2">);</span>
                    <span class="s2">}</span>
                    <span class="s4">else if </span><span class="s2">(segment.prevSegments.length === </span><span class="s5">0</span><span class="s2">) {</span>
                        <span class="s2">paths = BigInt(</span><span class="s3">'1'</span><span class="s2">);</span>
                    <span class="s2">}</span>
                    <span class="s4">else </span><span class="s2">{</span>
                        <span class="s2">paths = BigInt(</span><span class="s3">'0'</span><span class="s2">);</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_c = __values(segment.prevSegments), _d = _c.next(); !_d.done; _d = _c.next()) {</span>
                                <span class="s4">var </span><span class="s2">prevSegment = _d.value;</span>
                                <span class="s2">paths += countPathsFromStart(prevSegment, pathList);</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s4">catch </span><span class="s2">(e_7_1) { e_7 = { error: e_7_1 }; }</span>
                        <span class="s4">finally </span><span class="s2">{</span>
                            <span class="s4">try </span><span class="s2">{</span>
                                <span class="s4">if </span><span class="s2">(_d &amp;&amp; !_d.done &amp;&amp; (_b = _c.return)) _b.call(_c);</span>
                            <span class="s2">}</span>
                            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_7) </span><span class="s4">throw </span><span class="s2">e_7.error; }</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s0">// If our segment is reachable then there should be at least one path</span>
                    <span class="s0">// to it from the start of our code path.</span>
                    <span class="s4">if </span><span class="s2">(segment.reachable &amp;&amp; paths === BigInt(</span><span class="s3">'0'</span><span class="s2">)) {</span>
                        <span class="s2">cache.delete(segment.id);</span>
                    <span class="s2">}</span>
                    <span class="s4">else </span><span class="s2">{</span>
                        <span class="s2">cache.set(segment.id, paths);</span>
                    <span class="s2">}</span>
                    <span class="s4">return </span><span class="s2">paths;</span>
                <span class="s2">}</span>
                <span class="s0">/**</span>
                 <span class="s0">* Count the number of code paths from this segment to the end of the</span>
                 <span class="s0">* function. For example:</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* function MyComponent() {</span>
                 <span class="s0">*   // Segment 1</span>
                 <span class="s0">*   if (condition) {</span>
                 <span class="s0">*     // Segment 2</span>
                 <span class="s0">*   } else {</span>
                 <span class="s0">*     // Segment 3</span>
                 <span class="s0">*   }</span>
                 <span class="s0">* }</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* Segments 2 and 3 have one path to the end of `MyComponent` and</span>
                 <span class="s0">* segment 1 has two paths to the end of `MyComponent` since we could</span>
                 <span class="s0">* either take the path of segment 1 or segment 2.</span>
                 <span class="s0">*</span>
                 <span class="s0">* Populates `cyclic` with cyclic segments.</span>
                 <span class="s0">*/</span>
                <span class="s4">function </span><span class="s2">countPathsToEnd(segment, pathHistory) {</span>
                    <span class="s4">var </span><span class="s2">e_8, _a, e_9, _b;</span>
                    <span class="s4">var </span><span class="s2">cache = countPathsToEnd.cache;</span>
                    <span class="s4">var </span><span class="s2">paths = cache.get(segment.id);</span>
                    <span class="s4">var </span><span class="s2">pathList = </span><span class="s4">new </span><span class="s2">Set(pathHistory);</span>
                    <span class="s0">// If `pathList` includes the current segment then we've found a cycle!</span>
                    <span class="s0">// We need to fill `cyclic` with all segments inside cycle</span>
                    <span class="s4">if </span><span class="s2">(pathList.has(segment.id)) {</span>
                        <span class="s4">var </span><span class="s2">pathArray = Array.from(pathList);</span>
                        <span class="s4">var </span><span class="s2">cyclicSegments = pathArray.slice(pathArray.indexOf(segment.id) + </span><span class="s5">1</span><span class="s2">);</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">cyclicSegments_2 = __values(cyclicSegments), cyclicSegments_2_1 = cyclicSegments_2.next(); !cyclicSegments_2_1.done; cyclicSegments_2_1 = cyclicSegments_2.next()) {</span>
                                <span class="s4">var </span><span class="s2">cyclicSegment = cyclicSegments_2_1.value;</span>
                                <span class="s2">cyclic.add(cyclicSegment);</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s4">catch </span><span class="s2">(e_8_1) { e_8 = { error: e_8_1 }; }</span>
                        <span class="s4">finally </span><span class="s2">{</span>
                            <span class="s4">try </span><span class="s2">{</span>
                                <span class="s4">if </span><span class="s2">(cyclicSegments_2_1 &amp;&amp; !cyclicSegments_2_1.done &amp;&amp; (_a = cyclicSegments_2.return)) _a.call(cyclicSegments_2);</span>
                            <span class="s2">}</span>
                            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_8) </span><span class="s4">throw </span><span class="s2">e_8.error; }</span>
                        <span class="s2">}</span>
                        <span class="s4">return </span><span class="s2">BigInt(</span><span class="s3">'0'</span><span class="s2">);</span>
                    <span class="s2">}</span>
                    <span class="s0">// add the current segment to pathList</span>
                    <span class="s2">pathList.add(segment.id);</span>
                    <span class="s0">// We have a cached `paths`. Return it.</span>
                    <span class="s4">if </span><span class="s2">(paths !== undefined) {</span>
                        <span class="s4">return </span><span class="s2">paths;</span>
                    <span class="s2">}</span>
                    <span class="s4">if </span><span class="s2">(codePath.thrownSegments.includes(segment)) {</span>
                        <span class="s2">paths = BigInt(</span><span class="s3">'0'</span><span class="s2">);</span>
                    <span class="s2">}</span>
                    <span class="s4">else if </span><span class="s2">(segment.nextSegments.length === </span><span class="s5">0</span><span class="s2">) {</span>
                        <span class="s2">paths = BigInt(</span><span class="s3">'1'</span><span class="s2">);</span>
                    <span class="s2">}</span>
                    <span class="s4">else </span><span class="s2">{</span>
                        <span class="s2">paths = BigInt(</span><span class="s3">'0'</span><span class="s2">);</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_c = __values(segment.nextSegments), _d = _c.next(); !_d.done; _d = _c.next()) {</span>
                                <span class="s4">var </span><span class="s2">nextSegment = _d.value;</span>
                                <span class="s2">paths += countPathsToEnd(nextSegment, pathList);</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s4">catch </span><span class="s2">(e_9_1) { e_9 = { error: e_9_1 }; }</span>
                        <span class="s4">finally </span><span class="s2">{</span>
                            <span class="s4">try </span><span class="s2">{</span>
                                <span class="s4">if </span><span class="s2">(_d &amp;&amp; !_d.done &amp;&amp; (_b = _c.return)) _b.call(_c);</span>
                            <span class="s2">}</span>
                            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_9) </span><span class="s4">throw </span><span class="s2">e_9.error; }</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s2">cache.set(segment.id, paths);</span>
                    <span class="s4">return </span><span class="s2">paths;</span>
                <span class="s2">}</span>
                <span class="s0">/**</span>
                 <span class="s0">* Gets the shortest path length to the start of a code path.</span>
                 <span class="s0">* For example:</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* function MyComponent() {</span>
                 <span class="s0">*   if (condition) {</span>
                 <span class="s0">*     // Segment 1</span>
                 <span class="s0">*   }</span>
                 <span class="s0">*   // Segment 2</span>
                 <span class="s0">* }</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* There is only one path from segment 1 to the code path start. Its</span>
                 <span class="s0">* length is one so that is the shortest path.</span>
                 <span class="s0">*</span>
                 <span class="s0">* There are two paths from segment 2 to the code path start. One</span>
                 <span class="s0">* through segment 1 with a length of two and another directly to the</span>
                 <span class="s0">* start with a length of one. The shortest path has a length of one</span>
                 <span class="s0">* so we would return that.</span>
                 <span class="s0">*/</span>
                <span class="s4">function </span><span class="s2">shortestPathLengthToStart(segment) {</span>
                    <span class="s4">var </span><span class="s2">e_10, _a;</span>
                    <span class="s4">var </span><span class="s2">cache = shortestPathLengthToStart.cache;</span>
                    <span class="s4">var </span><span class="s2">length = cache.get(segment.id);</span>
                    <span class="s0">// If `length` is null then we found a cycle! Return infinity since</span>
                    <span class="s0">// the shortest path is definitely not the one where we looped.</span>
                    <span class="s4">if </span><span class="s2">(length === </span><span class="s4">null</span><span class="s2">) {</span>
                        <span class="s4">return </span><span class="s2">Infinity;</span>
                    <span class="s2">}</span>
                    <span class="s0">// We have a cached `length`. Return it.</span>
                    <span class="s4">if </span><span class="s2">(length !== undefined) {</span>
                        <span class="s4">return </span><span class="s2">length;</span>
                    <span class="s2">}</span>
                    <span class="s0">// Compute `length` and cache it. Guarding against cycles.</span>
                    <span class="s2">cache.set(segment.id, </span><span class="s4">null</span><span class="s2">);</span>
                    <span class="s4">if </span><span class="s2">(segment.prevSegments.length === </span><span class="s5">0</span><span class="s2">) {</span>
                        <span class="s2">length = </span><span class="s5">1</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s4">else </span><span class="s2">{</span>
                        <span class="s2">length = Infinity;</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_b = __values(segment.prevSegments), _c = _b.next(); !_c.done; _c = _b.next()) {</span>
                                <span class="s4">var </span><span class="s2">prevSegment = _c.value;</span>
                                <span class="s4">var </span><span class="s2">prevLength = shortestPathLengthToStart(prevSegment);</span>
                                <span class="s4">if </span><span class="s2">(prevLength &lt; length) {</span>
                                    <span class="s2">length = prevLength;</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s4">catch </span><span class="s2">(e_10_1) { e_10 = { error: e_10_1 }; }</span>
                        <span class="s4">finally </span><span class="s2">{</span>
                            <span class="s4">try </span><span class="s2">{</span>
                                <span class="s4">if </span><span class="s2">(_c &amp;&amp; !_c.done &amp;&amp; (_a = _b.return)) _a.call(_b);</span>
                            <span class="s2">}</span>
                            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_10) </span><span class="s4">throw </span><span class="s2">e_10.error; }</span>
                        <span class="s2">}</span>
                        <span class="s2">length += </span><span class="s5">1</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s2">cache.set(segment.id, length);</span>
                    <span class="s4">return </span><span class="s2">length;</span>
                <span class="s2">}</span>
                <span class="s2">countPathsFromStart.cache = </span><span class="s4">new </span><span class="s2">Map();</span>
                <span class="s2">countPathsToEnd.cache = </span><span class="s4">new </span><span class="s2">Map();</span>
                <span class="s2">shortestPathLengthToStart.cache = </span><span class="s4">new </span><span class="s2">Map();</span>
                <span class="s0">// Count all code paths to the end of our component/hook. Also primes</span>
                <span class="s0">// the `countPathsToEnd` cache.</span>
                <span class="s4">var </span><span class="s2">allPathsFromStartToEnd = countPathsToEnd(codePath.initialSegment);</span>
                <span class="s0">// Gets the function name for our code path. If the function name is</span>
                <span class="s0">// `undefined` then we know either that we have an anonymous function</span>
                <span class="s0">// expression or our code path is not in a function. In both cases we</span>
                <span class="s0">// will want to error since neither are React function components or</span>
                <span class="s0">// hook functions - unless it is an anonymous function argument to</span>
                <span class="s0">// forwardRef or memo.</span>
                <span class="s4">var </span><span class="s2">codePathFunctionName = getFunctionName(codePathNode);</span>
                <span class="s0">// This is a valid code path for React hooks if we are directly in a React</span>
                <span class="s0">// function component or we are in a hook function.</span>
                <span class="s4">var </span><span class="s2">isSomewhereInsideComponentOrHook = isInsideComponentOrHook(codePathNode);</span>
                <span class="s4">var </span><span class="s2">isDirectlyInsideComponentOrHook = codePathFunctionName</span>
                    <span class="s2">? isComponentName(codePathFunctionName) ||</span>
                        <span class="s2">isHook(codePathFunctionName)</span>
                    <span class="s2">: isForwardRefCallback(codePathNode) || isMemoCallback(codePathNode);</span>
                <span class="s0">// Compute the earliest finalizer level using information from the</span>
                <span class="s0">// cache. We expect all reachable final segments to have a cache entry</span>
                <span class="s0">// after calling `visitSegment()`.</span>
                <span class="s4">var </span><span class="s2">shortestFinalPathLength = Infinity;</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_d = __values(codePath.finalSegments), _e = _d.next(); !_e.done; _e = _d.next()) {</span>
                        <span class="s4">var </span><span class="s2">finalSegment = _e.value;</span>
                        <span class="s4">if </span><span class="s2">(!finalSegment.reachable) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">var </span><span class="s2">length = shortestPathLengthToStart(finalSegment);</span>
                        <span class="s4">if </span><span class="s2">(length &lt; shortestFinalPathLength) {</span>
                            <span class="s2">shortestFinalPathLength = length;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(e_3_1) { e_3 = { error: e_3_1 }; }</span>
                <span class="s4">finally </span><span class="s2">{</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">if </span><span class="s2">(_e &amp;&amp; !_e.done &amp;&amp; (_a = _d.return)) _a.call(_d);</span>
                    <span class="s2">}</span>
                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_3) </span><span class="s4">throw </span><span class="s2">e_3.error; }</span>
                <span class="s2">}</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s0">// Make sure all React Hooks pass our lint invariants. Log warnings</span>
                    <span class="s0">// if not.</span>
                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">reactHooksMap_1 = __values(reactHooksMap), reactHooksMap_1_1 = reactHooksMap_1.next(); !reactHooksMap_1_1.done; reactHooksMap_1_1 = reactHooksMap_1.next()) {</span>
                        <span class="s4">var </span><span class="s2">_f = __read(reactHooksMap_1_1.value, </span><span class="s5">2</span><span class="s2">), segment = _f[</span><span class="s5">0</span><span class="s2">], reactHooks = _f[</span><span class="s5">1</span><span class="s2">];</span>
                        <span class="s0">// NOTE: We could report here that the hook is not reachable, but</span>
                        <span class="s0">// that would be redundant with more general &quot;no unreachable&quot;</span>
                        <span class="s0">// lint rules.</span>
                        <span class="s4">if </span><span class="s2">(!segment.reachable) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s0">// If there are any final segments with a shorter path to start then</span>
                        <span class="s0">// we possibly have an early return.</span>
                        <span class="s0">//</span>
                        <span class="s0">// If our segment is a final segment itself then siblings could</span>
                        <span class="s0">// possibly be early returns.</span>
                        <span class="s4">var </span><span class="s2">possiblyHasEarlyReturn = segment.nextSegments.length === </span><span class="s5">0</span>
                            <span class="s2">? shortestFinalPathLength &lt;= shortestPathLengthToStart(segment)</span>
                            <span class="s2">: shortestFinalPathLength &lt; shortestPathLengthToStart(segment);</span>
                        <span class="s0">// Count all the paths from the start of our code path to the end of</span>
                        <span class="s0">// our code path that go _through_ this segment. The critical piece</span>
                        <span class="s0">// of this is _through_. If we just call `countPathsToEnd(segment)`</span>
                        <span class="s0">// then we neglect that we may have gone through multiple paths to get</span>
                        <span class="s0">// to this point! Consider:</span>
                        <span class="s0">//</span>
                        <span class="s0">// ```js</span>
                        <span class="s0">// function MyComponent() {</span>
                        <span class="s0">//   if (a) {</span>
                        <span class="s0">//     // Segment 1</span>
                        <span class="s0">//   } else {</span>
                        <span class="s0">//     // Segment 2</span>
                        <span class="s0">//   }</span>
                        <span class="s0">//   // Segment 3</span>
                        <span class="s0">//   if (b) {</span>
                        <span class="s0">//     // Segment 4</span>
                        <span class="s0">//   } else {</span>
                        <span class="s0">//     // Segment 5</span>
                        <span class="s0">//   }</span>
                        <span class="s0">// }</span>
                        <span class="s0">// ```</span>
                        <span class="s0">//</span>
                        <span class="s0">// In this component we have four code paths:</span>
                        <span class="s0">//</span>
                        <span class="s0">// 1. `a = true; b = true`</span>
                        <span class="s0">// 2. `a = true; b = false`</span>
                        <span class="s0">// 3. `a = false; b = true`</span>
                        <span class="s0">// 4. `a = false; b = false`</span>
                        <span class="s0">//</span>
                        <span class="s0">// From segment 3 there are two code paths to the end through segment</span>
                        <span class="s0">// 4 and segment 5. However, we took two paths to get here through</span>
                        <span class="s0">// segment 1 and segment 2.</span>
                        <span class="s0">//</span>
                        <span class="s0">// If we multiply the paths from start (two) by the paths to end (two)</span>
                        <span class="s0">// for segment 3 we get four. Which is our desired count.</span>
                        <span class="s4">var </span><span class="s2">pathsFromStartToEnd = countPathsFromStart(segment) * countPathsToEnd(segment);</span>
                        <span class="s0">// Is this hook a part of a cyclic segment?</span>
                        <span class="s4">var </span><span class="s2">cycled = cyclic.has(segment.id);</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">reactHooks_1 = (e_5 = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">, __values(reactHooks)), reactHooks_1_1 = reactHooks_1.next(); !reactHooks_1_1.done; reactHooks_1_1 = reactHooks_1.next()) {</span>
                                <span class="s4">var </span><span class="s2">hook = reactHooks_1_1.value;</span>
                                <span class="s0">// Report an error if a hook may be called more then once.</span>
                                <span class="s0">// `use(...)` can be called in loops.</span>
                                <span class="s4">if </span><span class="s2">((cycled || isInsideDoWhileLoop(hook)) &amp;&amp;</span>
                                    <span class="s2">!isUseIdentifier(hook)) {</span>
                                    <span class="s2">context.report({</span>
                                        <span class="s2">node: hook,</span>
                                        <span class="s2">message: </span><span class="s3">&quot;React Hook </span><span class="s7">\&quot;</span><span class="s3">&quot;</span><span class="s2">.concat(getSourceCode().getText(hook), </span><span class="s3">&quot;</span><span class="s7">\&quot; </span><span class="s3">may be executed &quot;</span><span class="s2">) +</span>
                                            <span class="s3">'more than once. Possibly because it is called in a loop. ' </span><span class="s2">+</span>
                                            <span class="s3">'React Hooks must be called in the exact same order in ' </span><span class="s2">+</span>
                                            <span class="s3">'every component render.'</span><span class="s2">,</span>
                                    <span class="s2">});</span>
                                <span class="s2">}</span>
                                <span class="s0">// If this is not a valid code path for React hooks then we need to</span>
                                <span class="s0">// log a warning for every hook in this code path.</span>
                                <span class="s0">//</span>
                                <span class="s0">// Pick a special message depending on the scope this hook was</span>
                                <span class="s0">// called in.</span>
                                <span class="s4">if </span><span class="s2">(isDirectlyInsideComponentOrHook) {</span>
                                    <span class="s0">// Report an error if the hook is called inside an async function.</span>
                                    <span class="s0">// @ts-expect-error the above check hasn't properly type-narrowed `codePathNode` (async doesn't exist on Node)</span>
                                    <span class="s4">var </span><span class="s2">isAsyncFunction = codePathNode.async;</span>
                                    <span class="s4">if </span><span class="s2">(isAsyncFunction) {</span>
                                        <span class="s2">context.report({</span>
                                            <span class="s2">node: hook,</span>
                                            <span class="s2">message: </span><span class="s3">&quot;React Hook </span><span class="s7">\&quot;</span><span class="s3">&quot;</span><span class="s2">.concat(getSourceCode().getText(hook), </span><span class="s3">&quot;</span><span class="s7">\&quot; </span><span class="s3">cannot be &quot;</span><span class="s2">) +</span>
                                                <span class="s3">'called in an async function.'</span><span class="s2">,</span>
                                        <span class="s2">});</span>
                                    <span class="s2">}</span>
                                    <span class="s0">// Report an error if a hook does not reach all finalizing code</span>
                                    <span class="s0">// path segments.</span>
                                    <span class="s0">//</span>
                                    <span class="s0">// Special case when we think there might be an early return.</span>
                                    <span class="s4">if </span><span class="s2">(!cycled &amp;&amp;</span>
                                        <span class="s2">pathsFromStartToEnd !== allPathsFromStartToEnd &amp;&amp;</span>
                                        <span class="s2">!isUseIdentifier(hook) &amp;&amp; </span><span class="s0">// `use(...)` can be called conditionally.</span>
                                        <span class="s2">!isInsideDoWhileLoop(hook) </span><span class="s0">// wrapping do/while loops are checked separately.</span>
                                    <span class="s2">) {</span>
                                        <span class="s4">var </span><span class="s2">message = </span><span class="s3">&quot;React Hook </span><span class="s7">\&quot;</span><span class="s3">&quot;</span><span class="s2">.concat(getSourceCode().getText(hook), </span><span class="s3">&quot;</span><span class="s7">\&quot; </span><span class="s3">is called &quot;</span><span class="s2">) +</span>
                                            <span class="s3">'conditionally. React Hooks must be called in the exact ' </span><span class="s2">+</span>
                                            <span class="s3">'same order in every component render.' </span><span class="s2">+</span>
                                            <span class="s2">(possiblyHasEarlyReturn</span>
                                                <span class="s2">? </span><span class="s3">' Did you accidentally call a React Hook after an' </span><span class="s2">+</span>
                                                    <span class="s3">' early return?'</span>
                                                <span class="s2">: </span><span class="s3">''</span><span class="s2">);</span>
                                        <span class="s2">context.report({ node: hook, message: message });</span>
                                    <span class="s2">}</span>
                                <span class="s2">}</span>
                                <span class="s4">else if </span><span class="s2">(codePathNode.parent != </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
                                    <span class="s2">(codePathNode.parent.type === </span><span class="s3">'MethodDefinition' </span><span class="s2">||</span>
                                        <span class="s0">// @ts-expect-error `ClassProperty` was removed from typescript-estree in https://github.com/typescript-eslint/typescript-eslint/pull/3806</span>
                                        <span class="s2">codePathNode.parent.type === </span><span class="s3">'ClassProperty' </span><span class="s2">||</span>
                                        <span class="s2">codePathNode.parent.type === </span><span class="s3">'PropertyDefinition'</span><span class="s2">) &amp;&amp;</span>
                                    <span class="s2">codePathNode.parent.value === codePathNode) {</span>
                                    <span class="s0">// Custom message for hooks inside a class</span>
                                    <span class="s4">var </span><span class="s2">message = </span><span class="s3">&quot;React Hook </span><span class="s7">\&quot;</span><span class="s3">&quot;</span><span class="s2">.concat(getSourceCode().getText(hook), </span><span class="s3">&quot;</span><span class="s7">\&quot; </span><span class="s3">cannot be called &quot;</span><span class="s2">) +</span>
                                        <span class="s3">'in a class component. React Hooks must be called in a ' </span><span class="s2">+</span>
                                        <span class="s3">'React function component or a custom React Hook function.'</span><span class="s2">;</span>
                                    <span class="s2">context.report({ node: hook, message: message });</span>
                                <span class="s2">}</span>
                                <span class="s4">else if </span><span class="s2">(codePathFunctionName) {</span>
                                    <span class="s0">// Custom message if we found an invalid function name.</span>
                                    <span class="s4">var </span><span class="s2">message = </span><span class="s3">&quot;React Hook </span><span class="s7">\&quot;</span><span class="s3">&quot;</span><span class="s2">.concat(getSourceCode().getText(hook), </span><span class="s3">&quot;</span><span class="s7">\&quot; </span><span class="s3">is called in &quot;</span><span class="s2">) +</span>
                                        <span class="s3">&quot;function </span><span class="s7">\&quot;</span><span class="s3">&quot;</span><span class="s2">.concat(getSourceCode().getText(codePathFunctionName), </span><span class="s3">&quot;</span><span class="s7">\&quot; </span><span class="s3">&quot;</span><span class="s2">) +</span>
                                        <span class="s3">'that is neither a React function component nor a custom ' </span><span class="s2">+</span>
                                        <span class="s3">'React Hook function.' </span><span class="s2">+</span>
                                        <span class="s3">' React component names must start with an uppercase letter.' </span><span class="s2">+</span>
                                        <span class="s3">' React Hook names must start with the word &quot;use&quot;.'</span><span class="s2">;</span>
                                    <span class="s2">context.report({ node: hook, message: message });</span>
                                <span class="s2">}</span>
                                <span class="s4">else if </span><span class="s2">(codePathNode.type === </span><span class="s3">'Program'</span><span class="s2">) {</span>
                                    <span class="s0">// These are dangerous if you have inline requires enabled.</span>
                                    <span class="s4">var </span><span class="s2">message = </span><span class="s3">&quot;React Hook </span><span class="s7">\&quot;</span><span class="s3">&quot;</span><span class="s2">.concat(getSourceCode().getText(hook), </span><span class="s3">&quot;</span><span class="s7">\&quot; </span><span class="s3">cannot be called &quot;</span><span class="s2">) +</span>
                                        <span class="s3">'at the top level. React Hooks must be called in a ' </span><span class="s2">+</span>
                                        <span class="s3">'React function component or a custom React Hook function.'</span><span class="s2">;</span>
                                    <span class="s2">context.report({ node: hook, message: message });</span>
                                <span class="s2">}</span>
                                <span class="s4">else </span><span class="s2">{</span>
                                    <span class="s0">// Assume in all other cases the user called a hook in some</span>
                                    <span class="s0">// random function callback. This should usually be true for</span>
                                    <span class="s0">// anonymous function expressions. Hopefully this is clarifying</span>
                                    <span class="s0">// enough in the common case that the incorrect message in</span>
                                    <span class="s0">// uncommon cases doesn't matter.</span>
                                    <span class="s0">// `use(...)` can be called in callbacks.</span>
                                    <span class="s4">if </span><span class="s2">(isSomewhereInsideComponentOrHook &amp;&amp; !isUseIdentifier(hook)) {</span>
                                        <span class="s4">var </span><span class="s2">message = </span><span class="s3">&quot;React Hook </span><span class="s7">\&quot;</span><span class="s3">&quot;</span><span class="s2">.concat(getSourceCode().getText(hook), </span><span class="s3">&quot;</span><span class="s7">\&quot; </span><span class="s3">cannot be called &quot;</span><span class="s2">) +</span>
                                            <span class="s3">'inside a callback. React Hooks must be called in a ' </span><span class="s2">+</span>
                                            <span class="s3">'React function component or a custom React Hook function.'</span><span class="s2">;</span>
                                        <span class="s2">context.report({ node: hook, message: message });</span>
                                    <span class="s2">}</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s4">catch </span><span class="s2">(e_5_1) { e_5 = { error: e_5_1 }; }</span>
                        <span class="s4">finally </span><span class="s2">{</span>
                            <span class="s4">try </span><span class="s2">{</span>
                                <span class="s4">if </span><span class="s2">(reactHooks_1_1 &amp;&amp; !reactHooks_1_1.done &amp;&amp; (_c = reactHooks_1.return)) _c.call(reactHooks_1);</span>
                            <span class="s2">}</span>
                            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_5) </span><span class="s4">throw </span><span class="s2">e_5.error; }</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(e_4_1) { e_4 = { error: e_4_1 }; }</span>
                <span class="s4">finally </span><span class="s2">{</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">if </span><span class="s2">(reactHooksMap_1_1 &amp;&amp; !reactHooksMap_1_1.done &amp;&amp; (_b = reactHooksMap_1.return)) _b.call(reactHooksMap_1);</span>
                    <span class="s2">}</span>
                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_4) </span><span class="s4">throw </span><span class="s2">e_4.error; }</span>
                <span class="s2">}</span>
            <span class="s2">},</span>
            <span class="s0">// Missed opportunity...We could visit all `Identifier`s instead of all</span>
            <span class="s0">// `CallExpression`s and check that _every use_ of a hook name is valid.</span>
            <span class="s0">// But that gets complicated and enters type-system territory, so we're</span>
            <span class="s0">// only being strict about hook calls for now.</span>
            <span class="s2">CallExpression: </span><span class="s4">function </span><span class="s2">(node) {</span>
                <span class="s4">if </span><span class="s2">(isHook(node.callee)) {</span>
                    <span class="s0">// Add the hook node to a map keyed by the code path segment. We will</span>
                    <span class="s0">// do full code path analysis at the end of our code path.</span>
                    <span class="s4">var </span><span class="s2">reactHooksMap = last(codePathReactHooksMapStack);</span>
                    <span class="s4">var </span><span class="s2">codePathSegment = last(codePathSegmentStack);</span>
                    <span class="s4">var </span><span class="s2">reactHooks = reactHooksMap.get(codePathSegment);</span>
                    <span class="s4">if </span><span class="s2">(!reactHooks) {</span>
                        <span class="s2">reactHooks = [];</span>
                        <span class="s2">reactHooksMap.set(codePathSegment, reactHooks);</span>
                    <span class="s2">}</span>
                    <span class="s2">reactHooks.push(node.callee);</span>
                <span class="s2">}</span>
                <span class="s0">// useEffectEvent: useEffectEvent functions can be passed by reference within useEffect as well as in</span>
                <span class="s0">// another useEffectEvent</span>
                <span class="s4">if </span><span class="s2">(node.callee.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">(node.callee.name === </span><span class="s3">'useEffect' </span><span class="s2">||</span>
                        <span class="s2">isUseEffectEventIdentifier$1()) &amp;&amp;</span>
                    <span class="s2">node.arguments.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s0">// Denote that we have traversed into a useEffect call, and stash the CallExpr for</span>
                    <span class="s0">// comparison later when we exit</span>
                    <span class="s2">lastEffect = node;</span>
                <span class="s2">}</span>
            <span class="s2">},</span>
            <span class="s2">Identifier: </span><span class="s4">function </span><span class="s2">(node) {</span>
                <span class="s0">// This identifier resolves to a useEffectEvent function, but isn't being referenced in an</span>
                <span class="s0">// effect or another event function. It isn't being called either.</span>
                <span class="s4">if </span><span class="s2">(lastEffect == </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">useEffectEventFunctions.has(node) &amp;&amp;</span>
                    <span class="s2">node.parent.type !== </span><span class="s3">'CallExpression'</span><span class="s2">) {</span>
                    <span class="s2">context.report({</span>
                        <span class="s2">node: node,</span>
                        <span class="s2">message: </span><span class="s3">&quot;`&quot;</span><span class="s2">.concat(getSourceCode().getText(node), </span><span class="s3">&quot;` is a function created with React Hook </span><span class="s7">\&quot;</span><span class="s3">useEffectEvent</span><span class="s7">\&quot;</span><span class="s3">, and can only be called from &quot;</span><span class="s2">) +</span>
                            <span class="s3">'the same component. They cannot be assigned to variables or passed down.'</span><span class="s2">,</span>
                    <span class="s2">});</span>
                <span class="s2">}</span>
            <span class="s2">},</span>
            <span class="s3">'CallExpression:exit'</span><span class="s2">: </span><span class="s4">function </span><span class="s2">(node) {</span>
                <span class="s4">if </span><span class="s2">(node === lastEffect) {</span>
                    <span class="s2">lastEffect = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s2">}</span>
            <span class="s2">},</span>
            <span class="s2">FunctionDeclaration: </span><span class="s4">function </span><span class="s2">(node) {</span>
                <span class="s0">// function MyComponent() { const onClick = useEffectEvent(...) }</span>
                <span class="s4">if </span><span class="s2">(isInsideComponentOrHook(node)) {</span>
                    <span class="s2">recordAllUseEffectEventFunctions(getScope(node));</span>
                <span class="s2">}</span>
            <span class="s2">},</span>
            <span class="s2">ArrowFunctionExpression: </span><span class="s4">function </span><span class="s2">(node) {</span>
                <span class="s0">// const MyComponent = () =&gt; { const onClick = useEffectEvent(...) }</span>
                <span class="s4">if </span><span class="s2">(isInsideComponentOrHook(node)) {</span>
                    <span class="s2">recordAllUseEffectEventFunctions(getScope(node));</span>
                <span class="s2">}</span>
            <span class="s2">},</span>
        <span class="s2">};</span>
    <span class="s2">},</span>
<span class="s2">};</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the static name of a function AST node. For function declarations it is</span>
 <span class="s0">* easy. For anonymous function expressions it is much harder. If you search for</span>
 <span class="s0">* `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places</span>
 <span class="s0">* where JS gives anonymous function expressions names. We roughly detect the</span>
 <span class="s0">* same AST nodes with some exceptions to better fit our use case.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getFunctionName(node) {</span>
    <span class="s4">var </span><span class="s2">_a, _b, _c, _d;</span>
    <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'FunctionDeclaration' </span><span class="s2">||</span>
        <span class="s2">(node.type === </span><span class="s3">'FunctionExpression' </span><span class="s2">&amp;&amp; node.id)) {</span>
        <span class="s0">// function useHook() {}</span>
        <span class="s0">// const whatever = function useHook() {};</span>
        <span class="s0">//</span>
        <span class="s0">// Function declaration or function expression names win over any</span>
        <span class="s0">// assignment statements or other renames.</span>
        <span class="s4">return </span><span class="s2">node.id;</span>
    <span class="s2">}</span>
    <span class="s4">else if </span><span class="s2">(node.type === </span><span class="s3">'FunctionExpression' </span><span class="s2">||</span>
        <span class="s2">node.type === </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">) {</span>
        <span class="s4">if </span><span class="s2">(((_a = node.parent) === </span><span class="s4">null </span><span class="s2">|| _a === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _a.type) === </span><span class="s3">'VariableDeclarator' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">node.parent.init === node) {</span>
            <span class="s0">// const useHook = () =&gt; {};</span>
            <span class="s4">return </span><span class="s2">node.parent.id;</span>
        <span class="s2">}</span>
        <span class="s4">else if </span><span class="s2">(((_b = node.parent) === </span><span class="s4">null </span><span class="s2">|| _b === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _b.type) === </span><span class="s3">'AssignmentExpression' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">node.parent.right === node &amp;&amp;</span>
            <span class="s2">node.parent.operator === </span><span class="s3">'='</span><span class="s2">) {</span>
            <span class="s0">// useHook = () =&gt; {};</span>
            <span class="s4">return </span><span class="s2">node.parent.left;</span>
        <span class="s2">}</span>
        <span class="s4">else if </span><span class="s2">(((_c = node.parent) === </span><span class="s4">null </span><span class="s2">|| _c === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _c.type) === </span><span class="s3">'Property' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">node.parent.value === node &amp;&amp;</span>
            <span class="s2">!node.parent.computed) {</span>
            <span class="s0">// {useHook: () =&gt; {}}</span>
            <span class="s0">// {useHook() {}}</span>
            <span class="s4">return </span><span class="s2">node.parent.key;</span>
            <span class="s0">// NOTE: We could also support `ClassProperty` and `MethodDefinition`</span>
            <span class="s0">// here to be pedantic. However, hooks in a class are an anti-pattern. So</span>
            <span class="s0">// we don't allow it to error early.</span>
            <span class="s0">//</span>
            <span class="s0">// class {useHook = () =&gt; {}}</span>
            <span class="s0">// class {useHook() {}}</span>
        <span class="s2">}</span>
        <span class="s4">else if </span><span class="s2">(((_d = node.parent) === </span><span class="s4">null </span><span class="s2">|| _d === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _d.type) === </span><span class="s3">'AssignmentPattern' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">node.parent.right === node &amp;&amp;</span>
            <span class="s0">// @ts-expect-error Property computed does not exist on type `AssignmentPattern`.</span>
            <span class="s2">!node.parent.computed) {</span>
            <span class="s0">// const {useHook = () =&gt; {}} = {};</span>
            <span class="s0">// ({useHook = () =&gt; {}} = {});</span>
            <span class="s0">//</span>
            <span class="s0">// Kinda clowny, but we'd said we'd follow spec convention for</span>
            <span class="s0">// `IsAnonymousFunctionDefinition()` usage.</span>
            <span class="s4">return </span><span class="s2">node.parent.left;</span>
        <span class="s2">}</span>
        <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">return </span><span class="s2">undefined;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">return </span><span class="s2">undefined;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function for peeking the last item in a stack.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">last(array) {</span>
    <span class="s4">return </span><span class="s2">array[array.length - </span><span class="s5">1</span><span class="s2">];</span>
<span class="s2">}</span>

<span class="s4">var </span><span class="s2">rule = {</span>
    <span class="s2">meta: {</span>
        <span class="s2">type: </span><span class="s3">'suggestion'</span><span class="s2">,</span>
        <span class="s2">docs: {</span>
            <span class="s2">description: </span><span class="s3">'verifies the list of dependencies for Hooks like useEffect and similar'</span><span class="s2">,</span>
            <span class="s2">recommended: </span><span class="s4">true</span><span class="s2">,</span>
            <span class="s2">url: </span><span class="s3">'https://github.com/facebook/react/issues/14920'</span><span class="s2">,</span>
        <span class="s2">},</span>
        <span class="s2">fixable: </span><span class="s3">'code'</span><span class="s2">,</span>
        <span class="s2">hasSuggestions: </span><span class="s4">true</span><span class="s2">,</span>
        <span class="s2">schema: [</span>
            <span class="s2">{</span>
                <span class="s2">type: </span><span class="s3">'object'</span><span class="s2">,</span>
                <span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
                <span class="s2">enableDangerousAutofixThisMayCauseInfiniteLoops: </span><span class="s4">false</span><span class="s2">,</span>
                <span class="s2">properties: {</span>
                    <span class="s2">additionalHooks: {</span>
                        <span class="s2">type: </span><span class="s3">'string'</span><span class="s2">,</span>
                    <span class="s2">},</span>
                    <span class="s2">enableDangerousAutofixThisMayCauseInfiniteLoops: {</span>
                        <span class="s2">type: </span><span class="s3">'boolean'</span><span class="s2">,</span>
                    <span class="s2">},</span>
                <span class="s2">},</span>
            <span class="s2">},</span>
        <span class="s2">],</span>
    <span class="s2">},</span>
    <span class="s2">create: </span><span class="s4">function </span><span class="s2">(context) {</span>
        <span class="s0">// Parse the `additionalHooks` regex.</span>
        <span class="s4">var </span><span class="s2">additionalHooks = context.options &amp;&amp;</span>
            <span class="s2">context.options[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
            <span class="s2">context.options[</span><span class="s5">0</span><span class="s2">].additionalHooks</span>
            <span class="s2">? </span><span class="s4">new </span><span class="s2">RegExp(context.options[</span><span class="s5">0</span><span class="s2">].additionalHooks)</span>
            <span class="s2">: undefined;</span>
        <span class="s4">var </span><span class="s2">enableDangerousAutofixThisMayCauseInfiniteLoops = (context.options &amp;&amp;</span>
            <span class="s2">context.options[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
            <span class="s2">context.options[</span><span class="s5">0</span><span class="s2">].enableDangerousAutofixThisMayCauseInfiniteLoops) ||</span>
            <span class="s4">false</span><span class="s2">;</span>
        <span class="s4">var </span><span class="s2">options = {</span>
            <span class="s2">additionalHooks: additionalHooks,</span>
            <span class="s2">enableDangerousAutofixThisMayCauseInfiniteLoops: enableDangerousAutofixThisMayCauseInfiniteLoops,</span>
        <span class="s2">};</span>
        <span class="s4">function </span><span class="s2">reportProblem(problem) {</span>
            <span class="s4">if </span><span class="s2">(enableDangerousAutofixThisMayCauseInfiniteLoops) {</span>
                <span class="s0">// Used to enable legacy behavior. Dangerous.</span>
                <span class="s0">// Keep this as an option until major IDEs upgrade (including VSCode FB ESLint extension).</span>
                <span class="s4">if </span><span class="s2">(Array.isArray(problem.suggest) &amp;&amp;</span>
                    <span class="s2">problem.suggest.length &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">problem.suggest[</span><span class="s5">0</span><span class="s2">]) {</span>
                    <span class="s2">problem.fix = problem.suggest[</span><span class="s5">0</span><span class="s2">].fix;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">context.report(problem);</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* SourceCode that also works down to ESLint 3.0.0</span>
         <span class="s0">*/</span>
        <span class="s4">var </span><span class="s2">getSourceCode = </span><span class="s4">typeof </span><span class="s2">context.getSourceCode === </span><span class="s3">'function'</span>
            <span class="s2">? </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">context.getSourceCode();</span>
            <span class="s2">}</span>
            <span class="s2">: </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">context.sourceCode;</span>
            <span class="s2">};</span>
        <span class="s0">/**</span>
         <span class="s0">* SourceCode#getScope that also works down to ESLint 3.0.0</span>
         <span class="s0">*/</span>
        <span class="s4">var </span><span class="s2">getScope = </span><span class="s4">typeof </span><span class="s2">context.getScope === </span><span class="s3">'function'</span>
            <span class="s2">? </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">context.getScope();</span>
            <span class="s2">}</span>
            <span class="s2">: </span><span class="s4">function </span><span class="s2">(node) {</span>
                <span class="s4">return </span><span class="s2">context.sourceCode.getScope(node);</span>
            <span class="s2">};</span>
        <span class="s4">var </span><span class="s2">scopeManager = getSourceCode().scopeManager;</span>
        <span class="s0">// Should be shared between visitors.</span>
        <span class="s4">var </span><span class="s2">setStateCallSites = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
        <span class="s4">var </span><span class="s2">stateVariables = </span><span class="s4">new </span><span class="s2">WeakSet();</span>
        <span class="s4">var </span><span class="s2">stableKnownValueCache = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
        <span class="s4">var </span><span class="s2">functionWithoutCapturedValueCache = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
        <span class="s4">var </span><span class="s2">useEffectEventVariables = </span><span class="s4">new </span><span class="s2">WeakSet();</span>
        <span class="s4">function </span><span class="s2">memoizeWithWeakMap(fn, map) {</span>
            <span class="s4">return function </span><span class="s2">(arg) {</span>
                <span class="s4">if </span><span class="s2">(map.has(arg)) {</span>
                    <span class="s0">// to verify cache hits:</span>
                    <span class="s0">// console.log(arg.name)</span>
                    <span class="s4">return </span><span class="s2">map.get(arg);</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">result = fn(arg);</span>
                <span class="s2">map.set(arg, result);</span>
                <span class="s4">return </span><span class="s2">result;</span>
            <span class="s2">};</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Visitor for both function expressions and arrow function expressions.</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s2">visitFunctionWithDependencies(node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect) {</span>
            <span class="s4">var </span><span class="s2">e_1, _a, e_2, _b, e_3, _c;</span>
            <span class="s4">if </span><span class="s2">(isEffect &amp;&amp; node.async) {</span>
                <span class="s2">reportProblem({</span>
                    <span class="s2">node: node,</span>
                    <span class="s2">message: </span><span class="s3">&quot;Effect callbacks are synchronous to prevent race conditions. &quot; </span><span class="s2">+</span>
                        <span class="s3">&quot;Put the async function inside:</span><span class="s7">\n\n</span><span class="s3">&quot; </span><span class="s2">+</span>
                        <span class="s3">'useEffect(() =&gt; {</span><span class="s7">\n</span><span class="s3">' </span><span class="s2">+</span>
                        <span class="s3">'  async function fetchData() {</span><span class="s7">\n</span><span class="s3">' </span><span class="s2">+</span>
                        <span class="s3">'    // You can await here</span><span class="s7">\n</span><span class="s3">' </span><span class="s2">+</span>
                        <span class="s3">'    const response = await MyAPI.getData(someId);</span><span class="s7">\n</span><span class="s3">' </span><span class="s2">+</span>
                        <span class="s3">'    // ...</span><span class="s7">\n</span><span class="s3">' </span><span class="s2">+</span>
                        <span class="s3">'  }</span><span class="s7">\n</span><span class="s3">' </span><span class="s2">+</span>
                        <span class="s3">'  fetchData();</span><span class="s7">\n</span><span class="s3">' </span><span class="s2">+</span>
                        <span class="s3">&quot;}, [someId]); // Or [] if effect doesn't need props or state</span><span class="s7">\n\n</span><span class="s3">&quot; </span><span class="s2">+</span>
                        <span class="s3">'Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching'</span><span class="s2">,</span>
                <span class="s2">});</span>
            <span class="s2">}</span>
            <span class="s0">// Get the current scope.</span>
            <span class="s4">var </span><span class="s2">scope = scopeManager.acquire(node);</span>
            <span class="s4">if </span><span class="s2">(!scope) {</span>
                <span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">'Unable to acquire scope for the current node. This is a bug in eslint-plugin-react-hooks, please file an issue.'</span><span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s0">// Find all our &quot;pure scopes&quot;. On every re-render of a component these</span>
            <span class="s0">// pure scopes may have changes to the variables declared within. So all</span>
            <span class="s0">// variables used in our reactive hook callback but declared in a pure</span>
            <span class="s0">// scope need to be listed as dependencies of our reactive hook callback.</span>
            <span class="s0">//</span>
            <span class="s0">// According to the rules of React you can't read a mutable value in pure</span>
            <span class="s0">// scope. We can't enforce this in a lint so we trust that all variables</span>
            <span class="s0">// declared outside of pure scope are indeed frozen.</span>
            <span class="s4">var </span><span class="s2">pureScopes = </span><span class="s4">new </span><span class="s2">Set();</span>
            <span class="s4">var </span><span class="s2">componentScope = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">{</span>
                <span class="s4">var </span><span class="s2">currentScope = scope.upper;</span>
                <span class="s4">while </span><span class="s2">(currentScope) {</span>
                    <span class="s2">pureScopes.add(currentScope);</span>
                    <span class="s4">if </span><span class="s2">(currentScope.type === </span><span class="s3">'function'</span><span class="s2">) {</span>
                        <span class="s4">break</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s2">currentScope = currentScope.upper;</span>
                <span class="s2">}</span>
                <span class="s0">// If there is no parent function scope then there are no pure scopes.</span>
                <span class="s0">// The ones we've collected so far are incorrect. So don't continue with</span>
                <span class="s0">// the lint.</span>
                <span class="s4">if </span><span class="s2">(!currentScope) {</span>
                    <span class="s4">return</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s2">componentScope = currentScope;</span>
            <span class="s2">}</span>
            <span class="s4">var </span><span class="s2">isArray = Array.isArray;</span>
            <span class="s0">// Next we'll define a few helpers that helps us</span>
            <span class="s0">// tell if some values don't have to be declared as deps.</span>
            <span class="s0">// Some are known to be stable based on Hook calls.</span>
            <span class="s0">// const [state, setState] = useState() / React.useState()</span>
            <span class="s0">//               ^^^ true for this reference</span>
            <span class="s0">// const [state, dispatch] = useReducer() / React.useReducer()</span>
            <span class="s0">//               ^^^ true for this reference</span>
            <span class="s0">// const [state, dispatch] = useActionState() / React.useActionState()</span>
            <span class="s0">//               ^^^ true for this reference</span>
            <span class="s0">// const ref = useRef()</span>
            <span class="s0">//       ^^^ true for this reference</span>
            <span class="s0">// const onStuff = useEffectEvent(() =&gt; {})</span>
            <span class="s0">//       ^^^ true for this reference</span>
            <span class="s0">// False for everything else.</span>
            <span class="s4">function </span><span class="s2">isStableKnownHookValue(resolved) {</span>
                <span class="s4">var </span><span class="s2">e_4, _a, e_5, _b, e_6, _c;</span>
                <span class="s4">if </span><span class="s2">(!isArray(resolved.defs)) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">def = resolved.defs[</span><span class="s5">0</span><span class="s2">];</span>
                <span class="s4">if </span><span class="s2">(def == </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s0">// Look for `let stuff = ...`</span>
                <span class="s4">var </span><span class="s2">defNode = def.node;</span>
                <span class="s4">if </span><span class="s2">(defNode.type !== </span><span class="s3">'VariableDeclarator'</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">init = defNode.init;</span>
                <span class="s4">if </span><span class="s2">(init == </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">while </span><span class="s2">(init.type === </span><span class="s3">'TSAsExpression' </span><span class="s2">|| init.type === </span><span class="s3">'AsExpression'</span><span class="s2">) {</span>
                    <span class="s2">init = init.expression;</span>
                <span class="s2">}</span>
                <span class="s0">// Detect primitive constants</span>
                <span class="s0">// const foo = 42</span>
                <span class="s4">var </span><span class="s2">declaration = defNode.parent;</span>
                <span class="s4">if </span><span class="s2">(declaration == </span><span class="s4">null </span><span class="s2">&amp;&amp; componentScope != </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s0">// This might happen if variable is declared after the callback.</span>
                    <span class="s0">// In that case ESLint won't set up .parent refs.</span>
                    <span class="s0">// So we'll set them up manually.</span>
                    <span class="s2">fastFindReferenceWithParent(componentScope.block, def.node.id);</span>
                    <span class="s2">declaration = def.node.parent;</span>
                    <span class="s4">if </span><span class="s2">(declaration == </span><span class="s4">null</span><span class="s2">) {</span>
                        <span class="s4">return false</span><span class="s2">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">if </span><span class="s2">(declaration != </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
                    <span class="s3">'kind' </span><span class="s4">in </span><span class="s2">declaration &amp;&amp;</span>
                    <span class="s2">declaration.kind === </span><span class="s3">'const' </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">init.type === </span><span class="s3">'Literal' </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">(</span><span class="s4">typeof </span><span class="s2">init.value === </span><span class="s3">'string' </span><span class="s2">||</span>
                        <span class="s4">typeof </span><span class="s2">init.value === </span><span class="s3">'number' </span><span class="s2">||</span>
                        <span class="s2">init.value === </span><span class="s4">null</span><span class="s2">)) {</span>
                    <span class="s0">// Definitely stable</span>
                    <span class="s4">return true</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s0">// Detect known Hook calls</span>
                <span class="s0">// const [_, setState] = useState()</span>
                <span class="s4">if </span><span class="s2">(init.type !== </span><span class="s3">'CallExpression'</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">callee = init.callee;</span>
                <span class="s0">// Step into `= React.something` initializer.</span>
                <span class="s4">if </span><span class="s2">(callee.type === </span><span class="s3">'MemberExpression' </span><span class="s2">&amp;&amp;</span>
                    <span class="s3">'name' </span><span class="s4">in </span><span class="s2">callee.object &amp;&amp;</span>
                    <span class="s2">callee.object.name === </span><span class="s3">'React' </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">callee.property != </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">!callee.computed) {</span>
                    <span class="s2">callee = callee.property;</span>
                <span class="s2">}</span>
                <span class="s4">if </span><span class="s2">(callee.type !== </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">definitionNode = def.node;</span>
                <span class="s4">var </span><span class="s2">id = definitionNode.id;</span>
                <span class="s4">var </span><span class="s2">name = callee.name;</span>
                <span class="s4">if </span><span class="s2">(name === </span><span class="s3">'useRef' </span><span class="s2">&amp;&amp; id.type === </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
                    <span class="s0">// useRef() return value is stable.</span>
                    <span class="s4">return true</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">else if </span><span class="s2">(isUseEffectEventIdentifier() &amp;&amp;</span>
                    <span class="s2">id.type === </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_d = __values(resolved.references), _e = _d.next(); !_e.done; _e = _d.next()) {</span>
                            <span class="s4">var </span><span class="s2">ref = _e.value;</span>
                            <span class="s0">// @ts-expect-error These types are not compatible (Reference and Identifier)</span>
                            <span class="s4">if </span><span class="s2">(ref !== id) {</span>
                                <span class="s2">useEffectEventVariables.add(ref.identifier);</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s4">catch </span><span class="s2">(e_4_1) { e_4 = { error: e_4_1 }; }</span>
                    <span class="s4">finally </span><span class="s2">{</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">if </span><span class="s2">(_e &amp;&amp; !_e.done &amp;&amp; (_a = _d.return)) _a.call(_d);</span>
                        <span class="s2">}</span>
                        <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_4) </span><span class="s4">throw </span><span class="s2">e_4.error; }</span>
                    <span class="s2">}</span>
                    <span class="s0">// useEffectEvent() return value is always unstable.</span>
                    <span class="s4">return true</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">else if </span><span class="s2">(name === </span><span class="s3">'useState' </span><span class="s2">||</span>
                    <span class="s2">name === </span><span class="s3">'useReducer' </span><span class="s2">||</span>
                    <span class="s2">name === </span><span class="s3">'useActionState'</span><span class="s2">) {</span>
                    <span class="s0">// Only consider second value in initializing tuple stable.</span>
                    <span class="s4">if </span><span class="s2">(id.type === </span><span class="s3">'ArrayPattern' </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">id.elements.length === </span><span class="s5">2 </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">isArray(resolved.identifiers)) {</span>
                        <span class="s0">// Is second tuple value the same reference we're checking?</span>
                        <span class="s4">if </span><span class="s2">(id.elements[</span><span class="s5">1</span><span class="s2">] === resolved.identifiers[</span><span class="s5">0</span><span class="s2">]) {</span>
                            <span class="s4">if </span><span class="s2">(name === </span><span class="s3">'useState'</span><span class="s2">) {</span>
                                <span class="s4">var </span><span class="s2">references = resolved.references;</span>
                                <span class="s4">var </span><span class="s2">writeCount = </span><span class="s5">0</span><span class="s2">;</span>
                                <span class="s4">try </span><span class="s2">{</span>
                                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">references_2 = __values(references), references_2_1 = references_2.next(); !references_2_1.done; references_2_1 = references_2.next()) {</span>
                                        <span class="s4">var </span><span class="s2">reference = references_2_1.value;</span>
                                        <span class="s4">if </span><span class="s2">(reference.isWrite()) {</span>
                                            <span class="s2">writeCount++;</span>
                                        <span class="s2">}</span>
                                        <span class="s4">if </span><span class="s2">(writeCount &gt; </span><span class="s5">1</span><span class="s2">) {</span>
                                            <span class="s4">return false</span><span class="s2">;</span>
                                        <span class="s2">}</span>
                                        <span class="s2">setStateCallSites.set(reference.identifier, id.elements[</span><span class="s5">0</span><span class="s2">]);</span>
                                    <span class="s2">}</span>
                                <span class="s2">}</span>
                                <span class="s4">catch </span><span class="s2">(e_5_1) { e_5 = { error: e_5_1 }; }</span>
                                <span class="s4">finally </span><span class="s2">{</span>
                                    <span class="s4">try </span><span class="s2">{</span>
                                        <span class="s4">if </span><span class="s2">(references_2_1 &amp;&amp; !references_2_1.done &amp;&amp; (_b = references_2.return)) _b.call(references_2);</span>
                                    <span class="s2">}</span>
                                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_5) </span><span class="s4">throw </span><span class="s2">e_5.error; }</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                            <span class="s0">// Setter is stable.</span>
                            <span class="s4">return true</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">else if </span><span class="s2">(id.elements[</span><span class="s5">0</span><span class="s2">] === resolved.identifiers[</span><span class="s5">0</span><span class="s2">]) {</span>
                            <span class="s4">if </span><span class="s2">(name === </span><span class="s3">'useState'</span><span class="s2">) {</span>
                                <span class="s4">var </span><span class="s2">references = resolved.references;</span>
                                <span class="s4">try </span><span class="s2">{</span>
                                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">references_3 = __values(references), references_3_1 = references_3.next(); !references_3_1.done; references_3_1 = references_3.next()) {</span>
                                        <span class="s4">var </span><span class="s2">reference = references_3_1.value;</span>
                                        <span class="s2">stateVariables.add(reference.identifier);</span>
                                    <span class="s2">}</span>
                                <span class="s2">}</span>
                                <span class="s4">catch </span><span class="s2">(e_6_1) { e_6 = { error: e_6_1 }; }</span>
                                <span class="s4">finally </span><span class="s2">{</span>
                                    <span class="s4">try </span><span class="s2">{</span>
                                        <span class="s4">if </span><span class="s2">(references_3_1 &amp;&amp; !references_3_1.done &amp;&amp; (_c = references_3.return)) _c.call(references_3);</span>
                                    <span class="s2">}</span>
                                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_6) </span><span class="s4">throw </span><span class="s2">e_6.error; }</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                            <span class="s0">// State variable itself is dynamic.</span>
                            <span class="s4">return false</span><span class="s2">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">else if </span><span class="s2">(name === </span><span class="s3">'useTransition'</span><span class="s2">) {</span>
                    <span class="s0">// Only consider second value in initializing tuple stable.</span>
                    <span class="s4">if </span><span class="s2">(id.type === </span><span class="s3">'ArrayPattern' </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">id.elements.length === </span><span class="s5">2 </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">Array.isArray(resolved.identifiers)) {</span>
                        <span class="s0">// Is second tuple value the same reference we're checking?</span>
                        <span class="s4">if </span><span class="s2">(id.elements[</span><span class="s5">1</span><span class="s2">] === resolved.identifiers[</span><span class="s5">0</span><span class="s2">]) {</span>
                            <span class="s0">// Setter is stable.</span>
                            <span class="s4">return true</span><span class="s2">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s0">// By default assume it's dynamic.</span>
                <span class="s4">return false</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s0">// Some are just functions that don't reference anything dynamic.</span>
            <span class="s4">function </span><span class="s2">isFunctionWithoutCapturedValues(resolved) {</span>
                <span class="s4">var </span><span class="s2">e_7, _a, e_8, _b;</span>
                <span class="s4">if </span><span class="s2">(!isArray(resolved.defs)) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">def = resolved.defs[</span><span class="s5">0</span><span class="s2">];</span>
                <span class="s4">if </span><span class="s2">(def == </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">if </span><span class="s2">(def.node == </span><span class="s4">null </span><span class="s2">|| def.node.id == </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s0">// Search the direct component subscopes for</span>
                <span class="s0">// top-level function definitions matching this reference.</span>
                <span class="s4">var </span><span class="s2">fnNode = def.node;</span>
                <span class="s4">var </span><span class="s2">childScopes = (componentScope === </span><span class="s4">null </span><span class="s2">|| componentScope === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: componentScope.childScopes) || [];</span>
                <span class="s4">var </span><span class="s2">fnScope = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">childScopes_1 = __values(childScopes), childScopes_1_1 = childScopes_1.next(); !childScopes_1_1.done; childScopes_1_1 = childScopes_1.next()) {</span>
                        <span class="s4">var </span><span class="s2">childScope = childScopes_1_1.value;</span>
                        <span class="s4">var </span><span class="s2">childScopeBlock = childScope.block;</span>
                        <span class="s4">if </span><span class="s2">(</span>
                        <span class="s0">// function handleChange() {}</span>
                        <span class="s2">(fnNode.type === </span><span class="s3">'FunctionDeclaration' </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">childScopeBlock === fnNode) ||</span>
                            <span class="s0">// const handleChange = () =&gt; {}</span>
                            <span class="s0">// const handleChange = function() {}</span>
                            <span class="s2">(fnNode.type === </span><span class="s3">'VariableDeclarator' </span><span class="s2">&amp;&amp;</span>
                                <span class="s2">childScopeBlock.parent === fnNode)) {</span>
                            <span class="s0">// Found it!</span>
                            <span class="s2">fnScope = childScope;</span>
                            <span class="s4">break</span><span class="s2">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(e_7_1) { e_7 = { error: e_7_1 }; }</span>
                <span class="s4">finally </span><span class="s2">{</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">if </span><span class="s2">(childScopes_1_1 &amp;&amp; !childScopes_1_1.done &amp;&amp; (_a = childScopes_1.return)) _a.call(childScopes_1);</span>
                    <span class="s2">}</span>
                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_7) </span><span class="s4">throw </span><span class="s2">e_7.error; }</span>
                <span class="s2">}</span>
                <span class="s4">if </span><span class="s2">(fnScope == </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s4">return false</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s0">// Does this function capture any values</span>
                    <span class="s0">// that are in pure scopes (aka render)?</span>
                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_c = __values(fnScope.through), _d = _c.next(); !_d.done; _d = _c.next()) {</span>
                        <span class="s4">var </span><span class="s2">ref = _d.value;</span>
                        <span class="s4">if </span><span class="s2">(ref.resolved == </span><span class="s4">null</span><span class="s2">) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">if </span><span class="s2">(pureScopes.has(ref.resolved.scope) &amp;&amp;</span>
                            <span class="s0">// Stable values are fine though,</span>
                            <span class="s0">// although we won't check functions deeper.</span>
                            <span class="s2">!memoizedIsStableKnownHookValue(ref.resolved)) {</span>
                            <span class="s4">return false</span><span class="s2">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(e_8_1) { e_8 = { error: e_8_1 }; }</span>
                <span class="s4">finally </span><span class="s2">{</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">if </span><span class="s2">(_d &amp;&amp; !_d.done &amp;&amp; (_b = _c.return)) _b.call(_c);</span>
                    <span class="s2">}</span>
                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_8) </span><span class="s4">throw </span><span class="s2">e_8.error; }</span>
                <span class="s2">}</span>
                <span class="s0">// If we got here, this function doesn't capture anything</span>
                <span class="s0">// from render--or everything it captures is known stable.</span>
                <span class="s4">return true</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s0">// Remember such values. Avoid re-running extra checks on them.</span>
            <span class="s4">var </span><span class="s2">memoizedIsStableKnownHookValue = memoizeWithWeakMap(isStableKnownHookValue, stableKnownValueCache);</span>
            <span class="s4">var </span><span class="s2">memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(isFunctionWithoutCapturedValues, functionWithoutCapturedValueCache);</span>
            <span class="s0">// These are usually mistaken. Collect them.</span>
            <span class="s4">var </span><span class="s2">currentRefsInEffectCleanup = </span><span class="s4">new </span><span class="s2">Map();</span>
            <span class="s0">// Is this reference inside a cleanup function for this effect node?</span>
            <span class="s0">// We can check by traversing scopes upwards from the reference, and checking</span>
            <span class="s0">// if the last &quot;return () =&gt; &quot; we encounter is located directly inside the effect.</span>
            <span class="s4">function </span><span class="s2">isInsideEffectCleanup(reference) {</span>
                <span class="s4">var </span><span class="s2">curScope = reference.from;</span>
                <span class="s4">var </span><span class="s2">isInReturnedFunction = </span><span class="s4">false</span><span class="s2">;</span>
                <span class="s4">while </span><span class="s2">(curScope != </span><span class="s4">null </span><span class="s2">&amp;&amp; curScope.block !== node) {</span>
                    <span class="s4">if </span><span class="s2">(curScope.type === </span><span class="s3">'function'</span><span class="s2">) {</span>
                        <span class="s2">isInReturnedFunction =</span>
                            <span class="s2">curScope.block.parent != </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
                                <span class="s2">curScope.block.parent.type === </span><span class="s3">'ReturnStatement'</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s2">curScope = curScope.upper;</span>
                <span class="s2">}</span>
                <span class="s4">return </span><span class="s2">isInReturnedFunction;</span>
            <span class="s2">}</span>
            <span class="s0">// Get dependencies from all our resolved references in pure scopes.</span>
            <span class="s0">// Key is dependency string, value is whether it's stable.</span>
            <span class="s4">var </span><span class="s2">dependencies = </span><span class="s4">new </span><span class="s2">Map();</span>
            <span class="s4">var </span><span class="s2">optionalChains = </span><span class="s4">new </span><span class="s2">Map();</span>
            <span class="s2">gatherDependenciesRecursively(scope);</span>
            <span class="s4">function </span><span class="s2">gatherDependenciesRecursively(currentScope) {</span>
                <span class="s4">var </span><span class="s2">e_9, _a, e_10, _b;</span>
                <span class="s4">var </span><span class="s2">_c, _d, _e, _f, _g;</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_h = __values(currentScope.references), _j = _h.next(); !_j.done; _j = _h.next()) {</span>
                        <span class="s4">var </span><span class="s2">reference = _j.value;</span>
                        <span class="s0">// If this reference is not resolved or it is not declared in a pure</span>
                        <span class="s0">// scope then we don't care about this reference.</span>
                        <span class="s4">if </span><span class="s2">(!reference.resolved) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">if </span><span class="s2">(!pureScopes.has(reference.resolved.scope)) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s0">// Narrow the scope of a dependency if it is, say, a member expression.</span>
                        <span class="s0">// Then normalize the narrowed dependency.</span>
                        <span class="s4">var </span><span class="s2">referenceNode = fastFindReferenceWithParent(node, reference.identifier);</span>
                        <span class="s4">if </span><span class="s2">(referenceNode == </span><span class="s4">null</span><span class="s2">) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">var </span><span class="s2">dependencyNode = getDependency(referenceNode);</span>
                        <span class="s4">var </span><span class="s2">dependency = analyzePropertyChain(dependencyNode, optionalChains);</span>
                        <span class="s0">// Accessing ref.current inside effect cleanup is bad.</span>
                        <span class="s4">if </span><span class="s2">(</span>
                        <span class="s0">// We're in an effect...</span>
                        <span class="s2">isEffect &amp;&amp;</span>
                            <span class="s0">// ... and this look like accessing .current...</span>
                            <span class="s2">dependencyNode.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">(((_c = dependencyNode.parent) === </span><span class="s4">null </span><span class="s2">|| _c === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _c.type) === </span><span class="s3">'MemberExpression' </span><span class="s2">||</span>
                                <span class="s2">((_d = dependencyNode.parent) === </span><span class="s4">null </span><span class="s2">|| _d === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _d.type) === </span><span class="s3">'OptionalMemberExpression'</span><span class="s2">) &amp;&amp;</span>
                            <span class="s2">!dependencyNode.parent.computed &amp;&amp;</span>
                            <span class="s2">dependencyNode.parent.property.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">dependencyNode.parent.property.name === </span><span class="s3">'current' </span><span class="s2">&amp;&amp;</span>
                            <span class="s0">// ...in a cleanup function or below...</span>
                            <span class="s2">isInsideEffectCleanup(reference)) {</span>
                            <span class="s2">currentRefsInEffectCleanup.set(dependency, {</span>
                                <span class="s2">reference: reference,</span>
                                <span class="s2">dependencyNode: dependencyNode,</span>
                            <span class="s2">});</span>
                        <span class="s2">}</span>
                        <span class="s4">if </span><span class="s2">(((_e = dependencyNode.parent) === </span><span class="s4">null </span><span class="s2">|| _e === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _e.type) === </span><span class="s3">'TSTypeQuery' </span><span class="s2">||</span>
                            <span class="s2">((_f = dependencyNode.parent) === </span><span class="s4">null </span><span class="s2">|| _f === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _f.type) === </span><span class="s3">'TSTypeReference'</span><span class="s2">) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">var </span><span class="s2">def = reference.resolved.defs[</span><span class="s5">0</span><span class="s2">];</span>
                        <span class="s4">if </span><span class="s2">(def == </span><span class="s4">null</span><span class="s2">) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s0">// Ignore references to the function itself as it's not defined yet.</span>
                        <span class="s4">if </span><span class="s2">(def.node != </span><span class="s4">null </span><span class="s2">&amp;&amp; def.node.init === node.parent) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s0">// Ignore Flow type parameters</span>
                        <span class="s0">// @ts-expect-error We don't have flow types</span>
                        <span class="s4">if </span><span class="s2">(def.type === </span><span class="s3">'TypeParameter'</span><span class="s2">) {</span>
                            <span class="s4">continue</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s0">// Add the dependency to a map so we can make sure it is referenced</span>
                        <span class="s0">// again in our dependencies array. Remember whether it's stable.</span>
                        <span class="s4">if </span><span class="s2">(!dependencies.has(dependency)) {</span>
                            <span class="s4">var </span><span class="s2">resolved = reference.resolved;</span>
                            <span class="s4">var </span><span class="s2">isStable = memoizedIsStableKnownHookValue(resolved) ||</span>
                                <span class="s2">memoizedIsFunctionWithoutCapturedValues(resolved);</span>
                            <span class="s2">dependencies.set(dependency, {</span>
                                <span class="s2">isStable: isStable,</span>
                                <span class="s2">references: [reference],</span>
                            <span class="s2">});</span>
                        <span class="s2">}</span>
                        <span class="s4">else </span><span class="s2">{</span>
                            <span class="s2">(_g = dependencies.get(dependency)) === </span><span class="s4">null </span><span class="s2">|| _g === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _g.references.push(reference);</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(e_9_1) { e_9 = { error: e_9_1 }; }</span>
                <span class="s4">finally </span><span class="s2">{</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">if </span><span class="s2">(_j &amp;&amp; !_j.done &amp;&amp; (_a = _h.return)) _a.call(_h);</span>
                    <span class="s2">}</span>
                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_9) </span><span class="s4">throw </span><span class="s2">e_9.error; }</span>
                <span class="s2">}</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_k = __values(currentScope.childScopes), _l = _k.next(); !_l.done; _l = _k.next()) {</span>
                        <span class="s4">var </span><span class="s2">childScope = _l.value;</span>
                        <span class="s2">gatherDependenciesRecursively(childScope);</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(e_10_1) { e_10 = { error: e_10_1 }; }</span>
                <span class="s4">finally </span><span class="s2">{</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">if </span><span class="s2">(_l &amp;&amp; !_l.done &amp;&amp; (_b = _k.return)) _b.call(_k);</span>
                    <span class="s2">}</span>
                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_10) </span><span class="s4">throw </span><span class="s2">e_10.error; }</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s0">// Warn about accessing .current in cleanup effects.</span>
            <span class="s2">currentRefsInEffectCleanup.forEach(</span><span class="s4">function </span><span class="s2">(_a, dependency) {</span>
                <span class="s4">var </span><span class="s2">e_11, _b;</span>
                <span class="s4">var </span><span class="s2">_c, _d;</span>
                <span class="s4">var </span><span class="s2">reference = _a.reference, dependencyNode = _a.dependencyNode;</span>
                <span class="s4">var </span><span class="s2">references = ((_c = reference.resolved) === </span><span class="s4">null </span><span class="s2">|| _c === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _c.references) || [];</span>
                <span class="s0">// Is React managing this ref or us?</span>
                <span class="s0">// Let's see if we can find a .current assignment.</span>
                <span class="s4">var </span><span class="s2">foundCurrentAssignment = </span><span class="s4">false</span><span class="s2">;</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">references_4 = __values(references), references_4_1 = references_4.next(); !references_4_1.done; references_4_1 = references_4.next()) {</span>
                        <span class="s4">var </span><span class="s2">ref = references_4_1.value;</span>
                        <span class="s4">var </span><span class="s2">identifier = ref.identifier;</span>
                        <span class="s4">var </span><span class="s2">parent = identifier.parent;</span>
                        <span class="s4">if </span><span class="s2">(parent != </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
                            <span class="s0">// ref.current</span>
                            <span class="s0">// Note: no need to handle OptionalMemberExpression because it can't be LHS.</span>
                            <span class="s2">parent.type === </span><span class="s3">'MemberExpression' </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">!parent.computed &amp;&amp;</span>
                            <span class="s2">parent.property.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">parent.property.name === </span><span class="s3">'current' </span><span class="s2">&amp;&amp;</span>
                            <span class="s0">// ref.current = &lt;something&gt;</span>
                            <span class="s2">((_d = parent.parent) === </span><span class="s4">null </span><span class="s2">|| _d === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _d.type) === </span><span class="s3">'AssignmentExpression' </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">parent.parent.left === parent) {</span>
                            <span class="s2">foundCurrentAssignment = </span><span class="s4">true</span><span class="s2">;</span>
                            <span class="s4">break</span><span class="s2">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(e_11_1) { e_11 = { error: e_11_1 }; }</span>
                <span class="s4">finally </span><span class="s2">{</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">if </span><span class="s2">(references_4_1 &amp;&amp; !references_4_1.done &amp;&amp; (_b = references_4.return)) _b.call(references_4);</span>
                    <span class="s2">}</span>
                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_11) </span><span class="s4">throw </span><span class="s2">e_11.error; }</span>
                <span class="s2">}</span>
                <span class="s0">// We only want to warn about React-managed refs.</span>
                <span class="s4">if </span><span class="s2">(foundCurrentAssignment) {</span>
                    <span class="s4">return</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s2">reportProblem({</span>
                    <span class="s0">// @ts-expect-error We can do better here (dependencyNode.parent has not been type narrowed)</span>
                    <span class="s2">node: dependencyNode.parent.property,</span>
                    <span class="s2">message: </span><span class="s3">&quot;The ref value '&quot;</span><span class="s2">.concat(dependency, </span><span class="s3">&quot;.current' will likely have &quot;</span><span class="s2">) +</span>
                        <span class="s3">&quot;changed by the time this effect cleanup function runs. If &quot; </span><span class="s2">+</span>
                        <span class="s3">&quot;this ref points to a node rendered by React, copy &quot; </span><span class="s2">+</span>
                        <span class="s3">&quot;'&quot;</span><span class="s2">.concat(dependency, </span><span class="s3">&quot;.current' to a variable inside the effect, and &quot;</span><span class="s2">) +</span>
                        <span class="s3">&quot;use that variable in the cleanup function.&quot;</span><span class="s2">,</span>
                <span class="s2">});</span>
            <span class="s2">});</span>
            <span class="s0">// Warn about assigning to variables in the outer scope.</span>
            <span class="s0">// Those are usually bugs.</span>
            <span class="s4">var </span><span class="s2">staleAssignments = </span><span class="s4">new </span><span class="s2">Set();</span>
            <span class="s4">function </span><span class="s2">reportStaleAssignment(writeExpr, key) {</span>
                <span class="s4">if </span><span class="s2">(staleAssignments.has(key)) {</span>
                    <span class="s4">return</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s2">staleAssignments.add(key);</span>
                <span class="s2">reportProblem({</span>
                    <span class="s2">node: writeExpr,</span>
                    <span class="s2">message: </span><span class="s3">&quot;Assignments to the '&quot;</span><span class="s2">.concat(key, </span><span class="s3">&quot;' variable from inside React Hook &quot;</span><span class="s2">) +</span>
                        <span class="s3">&quot;&quot;</span><span class="s2">.concat(getSourceCode().getText(reactiveHook), </span><span class="s3">&quot; will be lost after each &quot;</span><span class="s2">) +</span>
                        <span class="s3">&quot;render. To preserve the value over time, store it in a useRef &quot; </span><span class="s2">+</span>
                        <span class="s3">&quot;Hook and keep the mutable value in the '.current' property. &quot; </span><span class="s2">+</span>
                        <span class="s3">&quot;Otherwise, you can move this variable directly inside &quot; </span><span class="s2">+</span>
                        <span class="s3">&quot;&quot;</span><span class="s2">.concat(getSourceCode().getText(reactiveHook), </span><span class="s3">&quot;.&quot;</span><span class="s2">),</span>
                <span class="s2">});</span>
            <span class="s2">}</span>
            <span class="s0">// Remember which deps are stable and report bad usage first.</span>
            <span class="s4">var </span><span class="s2">stableDependencies = </span><span class="s4">new </span><span class="s2">Set();</span>
            <span class="s2">dependencies.forEach(</span><span class="s4">function </span><span class="s2">(_a, key) {</span>
                <span class="s4">var </span><span class="s2">isStable = _a.isStable, references = _a.references;</span>
                <span class="s4">if </span><span class="s2">(isStable) {</span>
                    <span class="s2">stableDependencies.add(key);</span>
                <span class="s2">}</span>
                <span class="s2">references.forEach(</span><span class="s4">function </span><span class="s2">(reference) {</span>
                    <span class="s4">if </span><span class="s2">(reference.writeExpr) {</span>
                        <span class="s2">reportStaleAssignment(reference.writeExpr, key);</span>
                    <span class="s2">}</span>
                <span class="s2">});</span>
            <span class="s2">});</span>
            <span class="s4">if </span><span class="s2">(staleAssignments.size &gt; </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s0">// The intent isn't clear so we'll wait until you fix those first.</span>
                <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">if </span><span class="s2">(!declaredDependenciesNode) {</span>
                <span class="s0">// Check if there are any top-level setState() calls.</span>
                <span class="s0">// Those tend to lead to infinite loops.</span>
                <span class="s4">var </span><span class="s2">setStateInsideEffectWithoutDeps_1 = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s2">dependencies.forEach(</span><span class="s4">function </span><span class="s2">(_a, key) {</span>
                    <span class="s4">var </span><span class="s2">references = _a.references;</span>
                    <span class="s4">if </span><span class="s2">(setStateInsideEffectWithoutDeps_1) {</span>
                        <span class="s4">return</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s2">references.forEach(</span><span class="s4">function </span><span class="s2">(reference) {</span>
                        <span class="s4">if </span><span class="s2">(setStateInsideEffectWithoutDeps_1) {</span>
                            <span class="s4">return</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">var </span><span class="s2">id = reference.identifier;</span>
                        <span class="s4">var </span><span class="s2">isSetState = setStateCallSites.has(id);</span>
                        <span class="s4">if </span><span class="s2">(!isSetState) {</span>
                            <span class="s4">return</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">var </span><span class="s2">fnScope = reference.from;</span>
                        <span class="s4">while </span><span class="s2">(fnScope != </span><span class="s4">null </span><span class="s2">&amp;&amp; fnScope.type !== </span><span class="s3">'function'</span><span class="s2">) {</span>
                            <span class="s2">fnScope = fnScope.upper;</span>
                        <span class="s2">}</span>
                        <span class="s4">var </span><span class="s2">isDirectlyInsideEffect = (fnScope === </span><span class="s4">null </span><span class="s2">|| fnScope === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: fnScope.block) === node;</span>
                        <span class="s4">if </span><span class="s2">(isDirectlyInsideEffect) {</span>
                            <span class="s0">// TODO: we could potentially ignore early returns.</span>
                            <span class="s2">setStateInsideEffectWithoutDeps_1 = key;</span>
                        <span class="s2">}</span>
                    <span class="s2">});</span>
                <span class="s2">});</span>
                <span class="s4">if </span><span class="s2">(setStateInsideEffectWithoutDeps_1) {</span>
                    <span class="s4">var </span><span class="s2">suggestedDependencies_1 = collectRecommendations({</span>
                        <span class="s2">dependencies: dependencies,</span>
                        <span class="s2">declaredDependencies: [],</span>
                        <span class="s2">stableDependencies: stableDependencies,</span>
                        <span class="s2">externalDependencies: </span><span class="s4">new </span><span class="s2">Set(),</span>
                        <span class="s2">isEffect: </span><span class="s4">true</span><span class="s2">,</span>
                    <span class="s2">}).suggestedDependencies;</span>
                    <span class="s2">reportProblem({</span>
                        <span class="s2">node: reactiveHook,</span>
                        <span class="s2">message: </span><span class="s3">&quot;React Hook &quot;</span><span class="s2">.concat(reactiveHookName, </span><span class="s3">&quot; contains a call to '&quot;</span><span class="s2">).concat(setStateInsideEffectWithoutDeps_1, </span><span class="s3">&quot;'. &quot;</span><span class="s2">) +</span>
                            <span class="s3">&quot;Without a list of dependencies, this can lead to an infinite chain of updates. &quot; </span><span class="s2">+</span>
                            <span class="s3">&quot;To fix this, pass [&quot; </span><span class="s2">+</span>
                            <span class="s2">suggestedDependencies_1.join(</span><span class="s3">', '</span><span class="s2">) +</span>
                            <span class="s3">&quot;] as a second argument to the &quot;</span><span class="s2">.concat(reactiveHookName, </span><span class="s3">&quot; Hook.&quot;</span><span class="s2">),</span>
                        <span class="s2">suggest: [</span>
                            <span class="s2">{</span>
                                <span class="s2">desc: </span><span class="s3">&quot;Add dependencies array: [&quot;</span><span class="s2">.concat(suggestedDependencies_1.join(</span><span class="s3">', '</span><span class="s2">), </span><span class="s3">&quot;]&quot;</span><span class="s2">),</span>
                                <span class="s2">fix: </span><span class="s4">function </span><span class="s2">(fixer) {</span>
                                    <span class="s4">return </span><span class="s2">fixer.insertTextAfter(node, </span><span class="s3">&quot;, [&quot;</span><span class="s2">.concat(suggestedDependencies_1.join(</span><span class="s3">', '</span><span class="s2">), </span><span class="s3">&quot;]&quot;</span><span class="s2">));</span>
                                <span class="s2">},</span>
                            <span class="s2">},</span>
                        <span class="s2">],</span>
                    <span class="s2">});</span>
                <span class="s2">}</span>
                <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">var </span><span class="s2">declaredDependencies = [];</span>
            <span class="s4">var </span><span class="s2">externalDependencies = </span><span class="s4">new </span><span class="s2">Set();</span>
            <span class="s4">var </span><span class="s2">isArrayExpression = declaredDependenciesNode.type === </span><span class="s3">'ArrayExpression'</span><span class="s2">;</span>
            <span class="s4">var </span><span class="s2">isTSAsArrayExpression = declaredDependenciesNode.type === </span><span class="s3">'TSAsExpression' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">declaredDependenciesNode.expression.type === </span><span class="s3">'ArrayExpression'</span><span class="s2">;</span>
            <span class="s4">if </span><span class="s2">(!isArrayExpression &amp;&amp; !isTSAsArrayExpression) {</span>
                <span class="s0">// If the declared dependencies are not an array expression then we</span>
                <span class="s0">// can't verify that the user provided the correct dependencies. Tell</span>
                <span class="s0">// the user this in an error.</span>
                <span class="s2">reportProblem({</span>
                    <span class="s2">node: declaredDependenciesNode,</span>
                    <span class="s2">message: </span><span class="s3">&quot;React Hook &quot;</span><span class="s2">.concat(getSourceCode().getText(reactiveHook), </span><span class="s3">&quot; was passed a &quot;</span><span class="s2">) +</span>
                        <span class="s3">'dependency list that is not an array literal. This means we ' </span><span class="s2">+</span>
                        <span class="s3">&quot;can't statically verify whether you've passed the correct &quot; </span><span class="s2">+</span>
                        <span class="s3">'dependencies.'</span><span class="s2">,</span>
                <span class="s2">});</span>
            <span class="s2">}</span>
            <span class="s4">else </span><span class="s2">{</span>
                <span class="s4">var </span><span class="s2">arrayExpression = isTSAsArrayExpression</span>
                    <span class="s2">? declaredDependenciesNode.expression</span>
                    <span class="s2">: declaredDependenciesNode;</span>
                <span class="s2">arrayExpression.elements.forEach(</span><span class="s4">function </span><span class="s2">(declaredDependencyNode) {</span>
                    <span class="s0">// Skip elided elements.</span>
                    <span class="s4">if </span><span class="s2">(declaredDependencyNode === </span><span class="s4">null</span><span class="s2">) {</span>
                        <span class="s4">return</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s0">// If we see a spread element then add a special warning.</span>
                    <span class="s4">if </span><span class="s2">(declaredDependencyNode.type === </span><span class="s3">'SpreadElement'</span><span class="s2">) {</span>
                        <span class="s2">reportProblem({</span>
                            <span class="s2">node: declaredDependencyNode,</span>
                            <span class="s2">message: </span><span class="s3">&quot;React Hook &quot;</span><span class="s2">.concat(getSourceCode().getText(reactiveHook), </span><span class="s3">&quot; has a spread &quot;</span><span class="s2">) +</span>
                                <span class="s3">&quot;element in its dependency array. This means we can't &quot; </span><span class="s2">+</span>
                                <span class="s3">&quot;statically verify whether you've passed the &quot; </span><span class="s2">+</span>
                                <span class="s3">'correct dependencies.'</span><span class="s2">,</span>
                        <span class="s2">});</span>
                        <span class="s4">return</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s4">if </span><span class="s2">(useEffectEventVariables.has(declaredDependencyNode)) {</span>
                        <span class="s2">reportProblem({</span>
                            <span class="s2">node: declaredDependencyNode,</span>
                            <span class="s2">message: </span><span class="s3">'Functions returned from `useEffectEvent` must not be included in the dependency array. ' </span><span class="s2">+</span>
                                <span class="s3">&quot;Remove `&quot;</span><span class="s2">.concat(getSourceCode().getText(declaredDependencyNode), </span><span class="s3">&quot;` from the list.&quot;</span><span class="s2">),</span>
                            <span class="s2">suggest: [</span>
                                <span class="s2">{</span>
                                    <span class="s2">desc: </span><span class="s3">&quot;Remove the dependency `&quot;</span><span class="s2">.concat(getSourceCode().getText(declaredDependencyNode), </span><span class="s3">&quot;`&quot;</span><span class="s2">),</span>
                                    <span class="s2">fix: </span><span class="s4">function </span><span class="s2">(fixer) {</span>
                                        <span class="s4">return </span><span class="s2">fixer.removeRange(declaredDependencyNode.range);</span>
                                    <span class="s2">},</span>
                                <span class="s2">},</span>
                            <span class="s2">],</span>
                        <span class="s2">});</span>
                    <span class="s2">}</span>
                    <span class="s0">// Try to normalize the declared dependency. If we can't then an error</span>
                    <span class="s0">// will be thrown. We will catch that error and report an error.</span>
                    <span class="s4">var </span><span class="s2">declaredDependency;</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s2">declaredDependency = analyzePropertyChain(declaredDependencyNode, </span><span class="s4">null</span><span class="s2">);</span>
                    <span class="s2">}</span>
                    <span class="s4">catch </span><span class="s2">(error) {</span>
                        <span class="s4">if </span><span class="s2">(error </span><span class="s4">instanceof </span><span class="s2">Error &amp;&amp;</span>
                            <span class="s6">/Unsupported node type/</span><span class="s2">.test(error.message)) {</span>
                            <span class="s4">if </span><span class="s2">(declaredDependencyNode.type === </span><span class="s3">'Literal'</span><span class="s2">) {</span>
                                <span class="s4">if </span><span class="s2">(declaredDependencyNode.value &amp;&amp;</span>
                                    <span class="s2">dependencies.has(declaredDependencyNode.value)) {</span>
                                    <span class="s2">reportProblem({</span>
                                        <span class="s2">node: declaredDependencyNode,</span>
                                        <span class="s2">message: </span><span class="s3">&quot;The &quot;</span><span class="s2">.concat(declaredDependencyNode.raw, </span><span class="s3">&quot; literal is not a valid dependency &quot;</span><span class="s2">) +</span>
                                            <span class="s3">&quot;because it never changes. &quot; </span><span class="s2">+</span>
                                            <span class="s3">&quot;Did you mean to include &quot;</span><span class="s2">.concat(declaredDependencyNode.value, </span><span class="s3">&quot; in the array instead?&quot;</span><span class="s2">),</span>
                                    <span class="s2">});</span>
                                <span class="s2">}</span>
                                <span class="s4">else </span><span class="s2">{</span>
                                    <span class="s2">reportProblem({</span>
                                        <span class="s2">node: declaredDependencyNode,</span>
                                        <span class="s2">message: </span><span class="s3">&quot;The &quot;</span><span class="s2">.concat(declaredDependencyNode.raw, </span><span class="s3">&quot; literal is not a valid dependency &quot;</span><span class="s2">) +</span>
                                            <span class="s3">'because it never changes. You can safely remove it.'</span><span class="s2">,</span>
                                    <span class="s2">});</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                            <span class="s4">else </span><span class="s2">{</span>
                                <span class="s2">reportProblem({</span>
                                    <span class="s2">node: declaredDependencyNode,</span>
                                    <span class="s2">message: </span><span class="s3">&quot;React Hook &quot;</span><span class="s2">.concat(getSourceCode().getText(reactiveHook), </span><span class="s3">&quot; has a &quot;</span><span class="s2">) +</span>
                                        <span class="s3">&quot;complex expression in the dependency array. &quot; </span><span class="s2">+</span>
                                        <span class="s3">'Extract it to a separate variable so it can be statically checked.'</span><span class="s2">,</span>
                                <span class="s2">});</span>
                            <span class="s2">}</span>
                            <span class="s4">return</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">else </span><span class="s2">{</span>
                            <span class="s4">throw </span><span class="s2">error;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s4">var </span><span class="s2">maybeID = declaredDependencyNode;</span>
                    <span class="s4">while </span><span class="s2">(maybeID.type === </span><span class="s3">'MemberExpression' </span><span class="s2">||</span>
                        <span class="s2">maybeID.type === </span><span class="s3">'OptionalMemberExpression' </span><span class="s2">||</span>
                        <span class="s2">maybeID.type === </span><span class="s3">'ChainExpression'</span><span class="s2">) {</span>
                        <span class="s0">// @ts-expect-error This can be done better</span>
                        <span class="s2">maybeID = maybeID.object || maybeID.expression.object;</span>
                    <span class="s2">}</span>
                    <span class="s4">var </span><span class="s2">isDeclaredInComponent = !componentScope.through.some(</span><span class="s4">function </span><span class="s2">(ref) { </span><span class="s4">return </span><span class="s2">ref.identifier === maybeID; });</span>
                    <span class="s0">// Add the dependency to our declared dependency map.</span>
                    <span class="s2">declaredDependencies.push({</span>
                        <span class="s2">key: declaredDependency,</span>
                        <span class="s2">node: declaredDependencyNode,</span>
                    <span class="s2">});</span>
                    <span class="s4">if </span><span class="s2">(!isDeclaredInComponent) {</span>
                        <span class="s2">externalDependencies.add(declaredDependency);</span>
                    <span class="s2">}</span>
                <span class="s2">});</span>
            <span class="s2">}</span>
            <span class="s4">var </span><span class="s2">_d = collectRecommendations({</span>
                <span class="s2">dependencies: dependencies,</span>
                <span class="s2">declaredDependencies: declaredDependencies,</span>
                <span class="s2">stableDependencies: stableDependencies,</span>
                <span class="s2">externalDependencies: externalDependencies,</span>
                <span class="s2">isEffect: isEffect,</span>
            <span class="s2">}), suggestedDependencies = _d.suggestedDependencies, unnecessaryDependencies = _d.unnecessaryDependencies, missingDependencies = _d.missingDependencies, duplicateDependencies = _d.duplicateDependencies;</span>
            <span class="s4">var </span><span class="s2">suggestedDeps = suggestedDependencies;</span>
            <span class="s4">var </span><span class="s2">problemCount = duplicateDependencies.size +</span>
                <span class="s2">missingDependencies.size +</span>
                <span class="s2">unnecessaryDependencies.size;</span>
            <span class="s4">if </span><span class="s2">(problemCount === </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s0">// If nothing else to report, check if some dependencies would</span>
                <span class="s0">// invalidate on every render.</span>
                <span class="s4">var </span><span class="s2">constructions = scanForConstructions({</span>
                    <span class="s2">declaredDependencies: declaredDependencies,</span>
                    <span class="s2">declaredDependenciesNode: declaredDependenciesNode,</span>
                    <span class="s2">componentScope: componentScope,</span>
                    <span class="s2">scope: scope,</span>
                <span class="s2">});</span>
                <span class="s2">constructions.forEach(</span><span class="s4">function </span><span class="s2">(_a) {</span>
                    <span class="s4">var </span><span class="s2">_b;</span>
                    <span class="s4">var </span><span class="s2">construction = _a.construction, isUsedOutsideOfHook = _a.isUsedOutsideOfHook, depType = _a.depType;</span>
                    <span class="s4">var </span><span class="s2">wrapperHook = depType === </span><span class="s3">'function' </span><span class="s2">? </span><span class="s3">'useCallback' </span><span class="s2">: </span><span class="s3">'useMemo'</span><span class="s2">;</span>
                    <span class="s4">var </span><span class="s2">constructionType = depType === </span><span class="s3">'function' </span><span class="s2">? </span><span class="s3">'definition' </span><span class="s2">: </span><span class="s3">'initialization'</span><span class="s2">;</span>
                    <span class="s4">var </span><span class="s2">defaultAdvice = </span><span class="s3">&quot;wrap the &quot;</span><span class="s2">.concat(constructionType, </span><span class="s3">&quot; of '&quot;</span><span class="s2">).concat(construction.name.name, </span><span class="s3">&quot;' in its own &quot;</span><span class="s2">).concat(wrapperHook, </span><span class="s3">&quot;() Hook.&quot;</span><span class="s2">);</span>
                    <span class="s4">var </span><span class="s2">advice = isUsedOutsideOfHook</span>
                        <span class="s2">? </span><span class="s3">&quot;To fix this, &quot;</span><span class="s2">.concat(defaultAdvice)</span>
                        <span class="s2">: </span><span class="s3">&quot;Move it inside the &quot;</span><span class="s2">.concat(reactiveHookName, </span><span class="s3">&quot; callback. Alternatively, &quot;</span><span class="s2">).concat(defaultAdvice);</span>
                    <span class="s4">var </span><span class="s2">causation = depType === </span><span class="s3">'conditional' </span><span class="s2">|| depType === </span><span class="s3">'logical expression'</span>
                        <span class="s2">? </span><span class="s3">'could make'</span>
                        <span class="s2">: </span><span class="s3">'makes'</span><span class="s2">;</span>
                    <span class="s4">var </span><span class="s2">message = </span><span class="s3">&quot;The '&quot;</span><span class="s2">.concat(construction.name.name, </span><span class="s3">&quot;' &quot;</span><span class="s2">).concat(depType, </span><span class="s3">&quot; &quot;</span><span class="s2">).concat(causation, </span><span class="s3">&quot; the dependencies of &quot;</span><span class="s2">) +</span>
                        <span class="s3">&quot;&quot;</span><span class="s2">.concat(reactiveHookName, </span><span class="s3">&quot; Hook (at line &quot;</span><span class="s2">).concat((_b = declaredDependenciesNode.loc) === </span><span class="s4">null </span><span class="s2">|| _b === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _b.start.line, </span><span class="s3">&quot;) &quot;</span><span class="s2">) +</span>
                        <span class="s3">&quot;change on every render. &quot;</span><span class="s2">.concat(advice);</span>
                    <span class="s4">var </span><span class="s2">suggest;</span>
                    <span class="s0">// Only handle the simple case of variable assignments.</span>
                    <span class="s0">// Wrapping function declarations can mess up hoisting.</span>
                    <span class="s4">if </span><span class="s2">(isUsedOutsideOfHook &amp;&amp;</span>
                        <span class="s2">construction.type === </span><span class="s3">'Variable' </span><span class="s2">&amp;&amp;</span>
                        <span class="s0">// Objects may be mutated after construction, which would make this</span>
                        <span class="s0">// fix unsafe. Functions _probably_ won't be mutated, so we'll</span>
                        <span class="s0">// allow this fix for them.</span>
                        <span class="s2">depType === </span><span class="s3">'function'</span><span class="s2">) {</span>
                        <span class="s2">suggest = [</span>
                            <span class="s2">{</span>
                                <span class="s2">desc: </span><span class="s3">&quot;Wrap the &quot;</span><span class="s2">.concat(constructionType, </span><span class="s3">&quot; of '&quot;</span><span class="s2">).concat(construction.name.name, </span><span class="s3">&quot;' in its own &quot;</span><span class="s2">).concat(wrapperHook, </span><span class="s3">&quot;() Hook.&quot;</span><span class="s2">),</span>
                                <span class="s2">fix: </span><span class="s4">function </span><span class="s2">(fixer) {</span>
                                    <span class="s4">var </span><span class="s2">_a = __read(wrapperHook === </span><span class="s3">'useMemo'</span>
                                        <span class="s2">? [</span><span class="s3">&quot;useMemo(() =&gt; { return &quot;</span><span class="s2">, </span><span class="s3">'; })'</span><span class="s2">]</span>
                                        <span class="s2">: [</span><span class="s3">'useCallback('</span><span class="s2">, </span><span class="s3">')'</span><span class="s2">], </span><span class="s5">2</span><span class="s2">), before = _a[</span><span class="s5">0</span><span class="s2">], after = _a[</span><span class="s5">1</span><span class="s2">];</span>
                                    <span class="s4">return </span><span class="s2">[</span>
                                        <span class="s0">// TODO: also add an import?</span>
                                        <span class="s2">fixer.insertTextBefore(construction.node.init, before),</span>
                                        <span class="s0">// TODO: ideally we'd gather deps here but it would require</span>
                                        <span class="s0">// restructuring the rule code. This will cause a new lint</span>
                                        <span class="s0">// error to appear immediately for useCallback. Note we're</span>
                                        <span class="s0">// not adding [] because would that changes semantics.</span>
                                        <span class="s2">fixer.insertTextAfter(construction.node.init, after),</span>
                                    <span class="s2">];</span>
                                <span class="s2">},</span>
                            <span class="s2">},</span>
                        <span class="s2">];</span>
                    <span class="s2">}</span>
                    <span class="s0">// TODO: What if the function needs to change on every render anyway?</span>
                    <span class="s0">// Should we suggest removing effect deps as an appropriate fix too?</span>
                    <span class="s2">reportProblem({</span>
                        <span class="s0">// TODO: Why not report this at the dependency site?</span>
                        <span class="s2">node: construction.node,</span>
                        <span class="s2">message: message,</span>
                        <span class="s2">suggest: suggest,</span>
                    <span class="s2">});</span>
                <span class="s2">});</span>
                <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s0">// If we're going to report a missing dependency,</span>
            <span class="s0">// we might as well recalculate the list ignoring</span>
            <span class="s0">// the currently specified deps. This can result</span>
            <span class="s0">// in some extra deduplication. We can't do this</span>
            <span class="s0">// for effects though because those have legit</span>
            <span class="s0">// use cases for over-specifying deps.</span>
            <span class="s4">if </span><span class="s2">(!isEffect &amp;&amp; missingDependencies.size &gt; </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s2">suggestedDeps = collectRecommendations({</span>
                    <span class="s2">dependencies: dependencies,</span>
                    <span class="s2">declaredDependencies: [], </span><span class="s0">// Pretend we don't know</span>
                    <span class="s2">stableDependencies: stableDependencies,</span>
                    <span class="s2">externalDependencies: externalDependencies,</span>
                    <span class="s2">isEffect: isEffect,</span>
                <span class="s2">}).suggestedDependencies;</span>
            <span class="s2">}</span>
            <span class="s0">// Alphabetize the suggestions, but only if deps were already alphabetized.</span>
            <span class="s4">function </span><span class="s2">areDeclaredDepsAlphabetized() {</span>
                <span class="s4">if </span><span class="s2">(declaredDependencies.length === </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s4">return true</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">declaredDepKeys = declaredDependencies.map(</span><span class="s4">function </span><span class="s2">(dep) { </span><span class="s4">return </span><span class="s2">dep.key; });</span>
                <span class="s4">var </span><span class="s2">sortedDeclaredDepKeys = declaredDepKeys.slice().sort();</span>
                <span class="s4">return </span><span class="s2">declaredDepKeys.join(</span><span class="s3">','</span><span class="s2">) === sortedDeclaredDepKeys.join(</span><span class="s3">','</span><span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s4">if </span><span class="s2">(areDeclaredDepsAlphabetized()) {</span>
                <span class="s2">suggestedDeps.sort();</span>
            <span class="s2">}</span>
            <span class="s0">// Most of our algorithm deals with dependency paths with optional chaining stripped.</span>
            <span class="s0">// This function is the last step before printing a dependency, so now is a good time to</span>
            <span class="s0">// check whether any members in our path are always used as optional-only. In that case,</span>
            <span class="s0">// we will use ?. instead of . to concatenate those parts of the path.</span>
            <span class="s4">function </span><span class="s2">formatDependency(path) {</span>
                <span class="s4">var </span><span class="s2">members = path.split(</span><span class="s3">'.'</span><span class="s2">);</span>
                <span class="s4">var </span><span class="s2">finalPath = </span><span class="s3">''</span><span class="s2">;</span>
                <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; members.length; i++) {</span>
                    <span class="s4">if </span><span class="s2">(i !== </span><span class="s5">0</span><span class="s2">) {</span>
                        <span class="s4">var </span><span class="s2">pathSoFar = members.slice(</span><span class="s5">0</span><span class="s2">, i + </span><span class="s5">1</span><span class="s2">).join(</span><span class="s3">'.'</span><span class="s2">);</span>
                        <span class="s4">var </span><span class="s2">isOptional = optionalChains.get(pathSoFar) === </span><span class="s4">true</span><span class="s2">;</span>
                        <span class="s2">finalPath += isOptional ? </span><span class="s3">'?.' </span><span class="s2">: </span><span class="s3">'.'</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s2">finalPath += members[i];</span>
                <span class="s2">}</span>
                <span class="s4">return </span><span class="s2">finalPath;</span>
            <span class="s2">}</span>
            <span class="s4">function </span><span class="s2">getWarningMessage(deps, singlePrefix, label, fixVerb) {</span>
                <span class="s4">if </span><span class="s2">(deps.size === </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s4">return null</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">return </span><span class="s2">((deps.size &gt; </span><span class="s5">1 </span><span class="s2">? </span><span class="s3">'' </span><span class="s2">: singlePrefix + </span><span class="s3">' '</span><span class="s2">) +</span>
                    <span class="s2">label +</span>
                    <span class="s3">' ' </span><span class="s2">+</span>
                    <span class="s2">(deps.size &gt; </span><span class="s5">1 </span><span class="s2">? </span><span class="s3">'dependencies' </span><span class="s2">: </span><span class="s3">'dependency'</span><span class="s2">) +</span>
                    <span class="s3">': ' </span><span class="s2">+</span>
                    <span class="s2">joinEnglish(Array.from(deps)</span>
                        <span class="s2">.sort()</span>
                        <span class="s2">.map(</span><span class="s4">function </span><span class="s2">(name) { </span><span class="s4">return </span><span class="s3">&quot;'&quot; </span><span class="s2">+ formatDependency(name) + </span><span class="s3">&quot;'&quot;</span><span class="s2">; })) +</span>
                    <span class="s3">&quot;. Either &quot;</span><span class="s2">.concat(fixVerb, </span><span class="s3">&quot; &quot;</span><span class="s2">).concat(deps.size &gt; </span><span class="s5">1 </span><span class="s2">? </span><span class="s3">'them' </span><span class="s2">: </span><span class="s3">'it'</span><span class="s2">, </span><span class="s3">&quot; or remove the dependency array.&quot;</span><span class="s2">));</span>
            <span class="s2">}</span>
            <span class="s4">var </span><span class="s2">extraWarning = </span><span class="s3">''</span><span class="s2">;</span>
            <span class="s4">if </span><span class="s2">(unnecessaryDependencies.size &gt; </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s4">var </span><span class="s2">badRef_1 = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s2">Array.from(unnecessaryDependencies.keys()).forEach(</span><span class="s4">function </span><span class="s2">(key) {</span>
                    <span class="s4">if </span><span class="s2">(badRef_1 !== </span><span class="s4">null</span><span class="s2">) {</span>
                        <span class="s4">return</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s4">if </span><span class="s2">(key.endsWith(</span><span class="s3">'.current'</span><span class="s2">)) {</span>
                        <span class="s2">badRef_1 = key;</span>
                    <span class="s2">}</span>
                <span class="s2">});</span>
                <span class="s4">if </span><span class="s2">(badRef_1 !== </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s2">extraWarning =</span>
                        <span class="s3">&quot; Mutable values like '&quot;</span><span class="s2">.concat(badRef_1, </span><span class="s3">&quot;' aren't valid dependencies &quot;</span><span class="s2">) +</span>
                            <span class="s3">&quot;because mutating them doesn't re-render the component.&quot;</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">else if </span><span class="s2">(externalDependencies.size &gt; </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s4">var </span><span class="s2">dep = Array.from(externalDependencies)[</span><span class="s5">0</span><span class="s2">];</span>
                    <span class="s0">// Don't show this warning for things that likely just got moved *inside* the callback</span>
                    <span class="s0">// because in that case they're clearly not referring to globals.</span>
                    <span class="s4">if </span><span class="s2">(!scope.set.has(dep)) {</span>
                        <span class="s2">extraWarning =</span>
                            <span class="s3">&quot; Outer scope values like '&quot;</span><span class="s2">.concat(dep, </span><span class="s3">&quot;' aren't valid dependencies &quot;</span><span class="s2">) +</span>
                                <span class="s3">&quot;because mutating them doesn't re-render the component.&quot;</span><span class="s2">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s0">// `props.foo()` marks `props` as a dependency because it has</span>
            <span class="s0">// a `this` value. This warning can be confusing.</span>
            <span class="s0">// So if we're going to show it, append a clarification.</span>
            <span class="s4">if </span><span class="s2">(!extraWarning &amp;&amp; missingDependencies.has(</span><span class="s3">'props'</span><span class="s2">)) {</span>
                <span class="s4">var </span><span class="s2">propDep = dependencies.get(</span><span class="s3">'props'</span><span class="s2">);</span>
                <span class="s4">if </span><span class="s2">(propDep == </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s4">return</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">refs = propDep.references;</span>
                <span class="s4">if </span><span class="s2">(!Array.isArray(refs)) {</span>
                    <span class="s4">return</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">isPropsOnlyUsedInMembers = </span><span class="s4">true</span><span class="s2">;</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">refs_1 = __values(refs), refs_1_1 = refs_1.next(); !refs_1_1.done; refs_1_1 = refs_1.next()) {</span>
                        <span class="s4">var </span><span class="s2">ref = refs_1_1.value;</span>
                        <span class="s4">var </span><span class="s2">id = fastFindReferenceWithParent(componentScope.block, ref.identifier);</span>
                        <span class="s4">if </span><span class="s2">(!id) {</span>
                            <span class="s2">isPropsOnlyUsedInMembers = </span><span class="s4">false</span><span class="s2">;</span>
                            <span class="s4">break</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">var </span><span class="s2">parent = id.parent;</span>
                        <span class="s4">if </span><span class="s2">(parent == </span><span class="s4">null</span><span class="s2">) {</span>
                            <span class="s2">isPropsOnlyUsedInMembers = </span><span class="s4">false</span><span class="s2">;</span>
                            <span class="s4">break</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">if </span><span class="s2">(parent.type !== </span><span class="s3">'MemberExpression' </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">parent.type !== </span><span class="s3">'OptionalMemberExpression'</span><span class="s2">) {</span>
                            <span class="s2">isPropsOnlyUsedInMembers = </span><span class="s4">false</span><span class="s2">;</span>
                            <span class="s4">break</span><span class="s2">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(e_1_1) { e_1 = { error: e_1_1 }; }</span>
                <span class="s4">finally </span><span class="s2">{</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">if </span><span class="s2">(refs_1_1 &amp;&amp; !refs_1_1.done &amp;&amp; (_a = refs_1.return)) _a.call(refs_1);</span>
                    <span class="s2">}</span>
                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_1) </span><span class="s4">throw </span><span class="s2">e_1.error; }</span>
                <span class="s2">}</span>
                <span class="s4">if </span><span class="s2">(isPropsOnlyUsedInMembers) {</span>
                    <span class="s2">extraWarning =</span>
                        <span class="s3">&quot; However, 'props' will change when *any* prop changes, so the &quot; </span><span class="s2">+</span>
                            <span class="s3">&quot;preferred fix is to destructure the 'props' object outside of &quot; </span><span class="s2">+</span>
                            <span class="s3">&quot;the &quot;</span><span class="s2">.concat(reactiveHookName, </span><span class="s3">&quot; call and refer to those specific props &quot;</span><span class="s2">) +</span>
                            <span class="s3">&quot;inside &quot;</span><span class="s2">.concat(getSourceCode().getText(reactiveHook), </span><span class="s3">&quot;.&quot;</span><span class="s2">);</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s4">if </span><span class="s2">(!extraWarning &amp;&amp; missingDependencies.size &gt; </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s0">// See if the user is trying to avoid specifying a callable prop.</span>
                <span class="s0">// This usually means they're unaware of useCallback.</span>
                <span class="s4">var </span><span class="s2">missingCallbackDep_1 = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s2">missingDependencies.forEach(</span><span class="s4">function </span><span class="s2">(missingDep) {</span>
                    <span class="s4">var </span><span class="s2">e_12, _a;</span>
                    <span class="s4">var </span><span class="s2">_b;</span>
                    <span class="s4">if </span><span class="s2">(missingCallbackDep_1) {</span>
                        <span class="s4">return</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s0">// Is this a variable from top scope?</span>
                    <span class="s4">var </span><span class="s2">topScopeRef = componentScope.set.get(missingDep);</span>
                    <span class="s4">var </span><span class="s2">usedDep = dependencies.get(missingDep);</span>
                    <span class="s4">if </span><span class="s2">(!(usedDep === </span><span class="s4">null </span><span class="s2">|| usedDep === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: usedDep.references) ||</span>
                        <span class="s2">((_b = usedDep === </span><span class="s4">null </span><span class="s2">|| usedDep === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: usedDep.references[</span><span class="s5">0</span><span class="s2">]) === </span><span class="s4">null </span><span class="s2">|| _b === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: _b.resolved) !== topScopeRef) {</span>
                        <span class="s4">return</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s0">// Is this a destructured prop?</span>
                    <span class="s4">var </span><span class="s2">def = topScopeRef === </span><span class="s4">null </span><span class="s2">|| topScopeRef === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: topScopeRef.defs[</span><span class="s5">0</span><span class="s2">];</span>
                    <span class="s4">if </span><span class="s2">(def == </span><span class="s4">null </span><span class="s2">|| def.name == </span><span class="s4">null </span><span class="s2">|| def.type !== </span><span class="s3">'Parameter'</span><span class="s2">) {</span>
                        <span class="s4">return</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s0">// Was it called in at least one case? Then it's a function.</span>
                    <span class="s4">var </span><span class="s2">isFunctionCall = </span><span class="s4">false</span><span class="s2">;</span>
                    <span class="s4">var </span><span class="s2">id;</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_c = __values(usedDep.references), _d = _c.next(); !_d.done; _d = _c.next()) {</span>
                            <span class="s4">var </span><span class="s2">reference = _d.value;</span>
                            <span class="s2">id = reference.identifier;</span>
                            <span class="s4">if </span><span class="s2">(id != </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
                                <span class="s2">id.parent != </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
                                <span class="s2">(id.parent.type === </span><span class="s3">'CallExpression' </span><span class="s2">||</span>
                                    <span class="s2">id.parent.type === </span><span class="s3">'OptionalCallExpression'</span><span class="s2">) &amp;&amp;</span>
                                <span class="s2">id.parent.callee === id) {</span>
                                <span class="s2">isFunctionCall = </span><span class="s4">true</span><span class="s2">;</span>
                                <span class="s4">break</span><span class="s2">;</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s4">catch </span><span class="s2">(e_12_1) { e_12 = { error: e_12_1 }; }</span>
                    <span class="s4">finally </span><span class="s2">{</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">if </span><span class="s2">(_d &amp;&amp; !_d.done &amp;&amp; (_a = _c.return)) _a.call(_c);</span>
                        <span class="s2">}</span>
                        <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_12) </span><span class="s4">throw </span><span class="s2">e_12.error; }</span>
                    <span class="s2">}</span>
                    <span class="s4">if </span><span class="s2">(!isFunctionCall) {</span>
                        <span class="s4">return</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s0">// If it's missing (i.e. in component scope) *and* it's a parameter</span>
                    <span class="s0">// then it is definitely coming from props destructuring.</span>
                    <span class="s0">// (It could also be props itself but we wouldn't be calling it then.)</span>
                    <span class="s2">missingCallbackDep_1 = missingDep;</span>
                <span class="s2">});</span>
                <span class="s4">if </span><span class="s2">(missingCallbackDep_1 !== </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s2">extraWarning =</span>
                        <span class="s3">&quot; If '&quot;</span><span class="s2">.concat(missingCallbackDep_1, </span><span class="s3">&quot;' changes too often, &quot;</span><span class="s2">) +</span>
                            <span class="s3">&quot;find the parent component that defines it &quot; </span><span class="s2">+</span>
                            <span class="s3">&quot;and wrap that definition in useCallback.&quot;</span><span class="s2">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s4">if </span><span class="s2">(!extraWarning &amp;&amp; missingDependencies.size &gt; </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s4">var </span><span class="s2">setStateRecommendation = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">missingDependencies_1 = __values(missingDependencies), missingDependencies_1_1 = missingDependencies_1.next(); !missingDependencies_1_1.done; missingDependencies_1_1 = missingDependencies_1.next()) {</span>
                        <span class="s4">var </span><span class="s2">missingDep = missingDependencies_1_1.value;</span>
                        <span class="s4">if </span><span class="s2">(setStateRecommendation !== </span><span class="s4">null</span><span class="s2">) {</span>
                            <span class="s4">break</span><span class="s2">;</span>
                        <span class="s2">}</span>
                        <span class="s4">var </span><span class="s2">usedDep = dependencies.get(missingDep);</span>
                        <span class="s4">var </span><span class="s2">references = usedDep.references;</span>
                        <span class="s4">var </span><span class="s2">id = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
                        <span class="s4">var </span><span class="s2">maybeCall = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
                        <span class="s4">try </span><span class="s2">{</span>
                            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">references_1 = (e_3 = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">, __values(references)), references_1_1 = references_1.next(); !references_1_1.done; references_1_1 = references_1.next()) {</span>
                                <span class="s4">var </span><span class="s2">reference = references_1_1.value;</span>
                                <span class="s2">id = reference.identifier;</span>
                                <span class="s2">maybeCall = id.parent;</span>
                                <span class="s0">// Try to see if we have setState(someExpr(missingDep)).</span>
                                <span class="s4">while </span><span class="s2">(maybeCall != </span><span class="s4">null </span><span class="s2">&amp;&amp; maybeCall !== componentScope.block) {</span>
                                    <span class="s4">if </span><span class="s2">(maybeCall.type === </span><span class="s3">'CallExpression'</span><span class="s2">) {</span>
                                        <span class="s4">var </span><span class="s2">correspondingStateVariable = setStateCallSites.get(maybeCall.callee);</span>
                                        <span class="s4">if </span><span class="s2">(correspondingStateVariable != </span><span class="s4">null</span><span class="s2">) {</span>
                                            <span class="s4">if </span><span class="s2">(</span><span class="s3">'name' </span><span class="s4">in </span><span class="s2">correspondingStateVariable &amp;&amp;</span>
                                                <span class="s2">correspondingStateVariable.name === missingDep) {</span>
                                                <span class="s0">// setCount(count + 1)</span>
                                                <span class="s2">setStateRecommendation = {</span>
                                                    <span class="s2">missingDep: missingDep,</span>
                                                    <span class="s2">setter: </span><span class="s3">'name' </span><span class="s4">in </span><span class="s2">maybeCall.callee ? maybeCall.callee.name : </span><span class="s3">''</span><span class="s2">,</span>
                                                    <span class="s2">form: </span><span class="s3">'updater'</span><span class="s2">,</span>
                                                <span class="s2">};</span>
                                            <span class="s2">}</span>
                                            <span class="s4">else if </span><span class="s2">(stateVariables.has(id)) {</span>
                                                <span class="s0">// setCount(count + increment)</span>
                                                <span class="s2">setStateRecommendation = {</span>
                                                    <span class="s2">missingDep: missingDep,</span>
                                                    <span class="s2">setter: </span><span class="s3">'name' </span><span class="s4">in </span><span class="s2">maybeCall.callee ? maybeCall.callee.name : </span><span class="s3">''</span><span class="s2">,</span>
                                                    <span class="s2">form: </span><span class="s3">'reducer'</span><span class="s2">,</span>
                                                <span class="s2">};</span>
                                            <span class="s2">}</span>
                                            <span class="s4">else </span><span class="s2">{</span>
                                                <span class="s4">var </span><span class="s2">resolved = reference.resolved;</span>
                                                <span class="s4">if </span><span class="s2">(resolved != </span><span class="s4">null</span><span class="s2">) {</span>
                                                    <span class="s0">// If it's a parameter *and* a missing dep,</span>
                                                    <span class="s0">// it must be a prop or something inside a prop.</span>
                                                    <span class="s0">// Therefore, recommend an inline reducer.</span>
                                                    <span class="s4">var </span><span class="s2">def = resolved.defs[</span><span class="s5">0</span><span class="s2">];</span>
                                                    <span class="s4">if </span><span class="s2">(def != </span><span class="s4">null </span><span class="s2">&amp;&amp; def.type === </span><span class="s3">'Parameter'</span><span class="s2">) {</span>
                                                        <span class="s2">setStateRecommendation = {</span>
                                                            <span class="s2">missingDep: missingDep,</span>
                                                            <span class="s2">setter: </span><span class="s3">'name' </span><span class="s4">in </span><span class="s2">maybeCall.callee</span>
                                                                <span class="s2">? maybeCall.callee.name</span>
                                                                <span class="s2">: </span><span class="s3">''</span><span class="s2">,</span>
                                                            <span class="s2">form: </span><span class="s3">'inlineReducer'</span><span class="s2">,</span>
                                                        <span class="s2">};</span>
                                                    <span class="s2">}</span>
                                                <span class="s2">}</span>
                                            <span class="s2">}</span>
                                            <span class="s4">break</span><span class="s2">;</span>
                                        <span class="s2">}</span>
                                    <span class="s2">}</span>
                                    <span class="s2">maybeCall = maybeCall.parent;</span>
                                <span class="s2">}</span>
                                <span class="s4">if </span><span class="s2">(setStateRecommendation !== </span><span class="s4">null</span><span class="s2">) {</span>
                                    <span class="s4">break</span><span class="s2">;</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s4">catch </span><span class="s2">(e_3_1) { e_3 = { error: e_3_1 }; }</span>
                        <span class="s4">finally </span><span class="s2">{</span>
                            <span class="s4">try </span><span class="s2">{</span>
                                <span class="s4">if </span><span class="s2">(references_1_1 &amp;&amp; !references_1_1.done &amp;&amp; (_c = references_1.return)) _c.call(references_1);</span>
                            <span class="s2">}</span>
                            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_3) </span><span class="s4">throw </span><span class="s2">e_3.error; }</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(e_2_1) { e_2 = { error: e_2_1 }; }</span>
                <span class="s4">finally </span><span class="s2">{</span>
                    <span class="s4">try </span><span class="s2">{</span>
                        <span class="s4">if </span><span class="s2">(missingDependencies_1_1 &amp;&amp; !missingDependencies_1_1.done &amp;&amp; (_b = missingDependencies_1.return)) _b.call(missingDependencies_1);</span>
                    <span class="s2">}</span>
                    <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_2) </span><span class="s4">throw </span><span class="s2">e_2.error; }</span>
                <span class="s2">}</span>
                <span class="s4">if </span><span class="s2">(setStateRecommendation !== </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s4">switch </span><span class="s2">(setStateRecommendation.form) {</span>
                        <span class="s4">case </span><span class="s3">'reducer'</span><span class="s2">:</span>
                            <span class="s2">extraWarning =</span>
                                <span class="s3">&quot; You can also replace multiple useState variables with useReducer &quot; </span><span class="s2">+</span>
                                    <span class="s3">&quot;if '&quot;</span><span class="s2">.concat(setStateRecommendation.setter, </span><span class="s3">&quot;' needs the &quot;</span><span class="s2">) +</span>
                                    <span class="s3">&quot;current value of '&quot;</span><span class="s2">.concat(setStateRecommendation.missingDep, </span><span class="s3">&quot;'.&quot;</span><span class="s2">);</span>
                            <span class="s4">break</span><span class="s2">;</span>
                        <span class="s4">case </span><span class="s3">'inlineReducer'</span><span class="s2">:</span>
                            <span class="s2">extraWarning =</span>
                                <span class="s3">&quot; If '&quot;</span><span class="s2">.concat(setStateRecommendation.setter, </span><span class="s3">&quot;' needs the &quot;</span><span class="s2">) +</span>
                                    <span class="s3">&quot;current value of '&quot;</span><span class="s2">.concat(setStateRecommendation.missingDep, </span><span class="s3">&quot;', &quot;</span><span class="s2">) +</span>
                                    <span class="s3">&quot;you can also switch to useReducer instead of useState and &quot; </span><span class="s2">+</span>
                                    <span class="s3">&quot;read '&quot;</span><span class="s2">.concat(setStateRecommendation.missingDep, </span><span class="s3">&quot;' in the reducer.&quot;</span><span class="s2">);</span>
                            <span class="s4">break</span><span class="s2">;</span>
                        <span class="s4">case </span><span class="s3">'updater'</span><span class="s2">:</span>
                            <span class="s2">extraWarning =</span>
                                <span class="s3">&quot; You can also do a functional update '&quot;</span><span class="s2">.concat(setStateRecommendation.setter, </span><span class="s3">&quot;(&quot;</span><span class="s2">).concat(setStateRecommendation.missingDep.slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), </span><span class="s3">&quot; =&gt; ...)' if you only need '&quot;</span><span class="s2">).concat(setStateRecommendation.missingDep, </span><span class="s3">&quot;'&quot;</span><span class="s2">) + </span><span class="s3">&quot; in the '&quot;</span><span class="s2">.concat(setStateRecommendation.setter, </span><span class="s3">&quot;' call.&quot;</span><span class="s2">);</span>
                            <span class="s4">break</span><span class="s2">;</span>
                        <span class="s4">default</span><span class="s2">:</span>
                            <span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">'Unknown case.'</span><span class="s2">);</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">reportProblem({</span>
                <span class="s2">node: declaredDependenciesNode,</span>
                <span class="s2">message: </span><span class="s3">&quot;React Hook &quot;</span><span class="s2">.concat(getSourceCode().getText(reactiveHook), </span><span class="s3">&quot; has &quot;</span><span class="s2">) +</span>
                    <span class="s0">// To avoid a long message, show the next actionable item.</span>
                    <span class="s2">(getWarningMessage(missingDependencies, </span><span class="s3">'a'</span><span class="s2">, </span><span class="s3">'missing'</span><span class="s2">, </span><span class="s3">'include'</span><span class="s2">) ||</span>
                        <span class="s2">getWarningMessage(unnecessaryDependencies, </span><span class="s3">'an'</span><span class="s2">, </span><span class="s3">'unnecessary'</span><span class="s2">, </span><span class="s3">'exclude'</span><span class="s2">) ||</span>
                        <span class="s2">getWarningMessage(duplicateDependencies, </span><span class="s3">'a'</span><span class="s2">, </span><span class="s3">'duplicate'</span><span class="s2">, </span><span class="s3">'omit'</span><span class="s2">)) +</span>
                    <span class="s2">extraWarning,</span>
                <span class="s2">suggest: [</span>
                    <span class="s2">{</span>
                        <span class="s2">desc: </span><span class="s3">&quot;Update the dependencies array to be: [&quot;</span><span class="s2">.concat(suggestedDeps</span>
                            <span class="s2">.map(formatDependency)</span>
                            <span class="s2">.join(</span><span class="s3">', '</span><span class="s2">), </span><span class="s3">&quot;]&quot;</span><span class="s2">),</span>
                        <span class="s2">fix: </span><span class="s4">function </span><span class="s2">(fixer) {</span>
                            <span class="s0">// TODO: consider preserving the comments or formatting?</span>
                            <span class="s4">return </span><span class="s2">fixer.replaceText(declaredDependenciesNode, </span><span class="s3">&quot;[&quot;</span><span class="s2">.concat(suggestedDeps.map(formatDependency).join(</span><span class="s3">', '</span><span class="s2">), </span><span class="s3">&quot;]&quot;</span><span class="s2">));</span>
                        <span class="s2">},</span>
                    <span class="s2">},</span>
                <span class="s2">],</span>
            <span class="s2">});</span>
        <span class="s2">}</span>
        <span class="s4">function </span><span class="s2">visitCallExpression(node) {</span>
            <span class="s4">var </span><span class="s2">callbackIndex = getReactiveHookCallbackIndex(node.callee, options);</span>
            <span class="s4">if </span><span class="s2">(callbackIndex === -</span><span class="s5">1</span><span class="s2">) {</span>
                <span class="s0">// Not a React Hook call that needs deps.</span>
                <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">var </span><span class="s2">callback = node.arguments[callbackIndex];</span>
            <span class="s4">var </span><span class="s2">reactiveHook = node.callee;</span>
            <span class="s4">var </span><span class="s2">nodeWithoutNamespace = getNodeWithoutReactNamespace(reactiveHook);</span>
            <span class="s4">var </span><span class="s2">reactiveHookName = </span><span class="s3">'name' </span><span class="s4">in </span><span class="s2">nodeWithoutNamespace ? nodeWithoutNamespace.name : </span><span class="s3">''</span><span class="s2">;</span>
            <span class="s4">var </span><span class="s2">maybeNode = node.arguments[callbackIndex + </span><span class="s5">1</span><span class="s2">];</span>
            <span class="s4">var </span><span class="s2">declaredDependenciesNode = maybeNode &amp;&amp;</span>
                <span class="s2">!(maybeNode.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp; maybeNode.name === </span><span class="s3">'undefined'</span><span class="s2">)</span>
                <span class="s2">? maybeNode</span>
                <span class="s2">: undefined;</span>
            <span class="s4">var </span><span class="s2">isEffect = </span><span class="s6">/Effect($|[^a-z])/g</span><span class="s2">.test(reactiveHookName);</span>
            <span class="s0">// Check whether a callback is supplied. If there is no callback supplied</span>
            <span class="s0">// then the hook will not work and React will throw a TypeError.</span>
            <span class="s0">// So no need to check for dependency inclusion.</span>
            <span class="s4">if </span><span class="s2">(!callback) {</span>
                <span class="s2">reportProblem({</span>
                    <span class="s2">node: reactiveHook,</span>
                    <span class="s2">message: </span><span class="s3">&quot;React Hook &quot;</span><span class="s2">.concat(reactiveHookName, </span><span class="s3">&quot; requires an effect callback. &quot;</span><span class="s2">) +</span>
                        <span class="s3">&quot;Did you forget to pass a callback to the hook?&quot;</span><span class="s2">,</span>
                <span class="s2">});</span>
                <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s0">// Check the declared dependencies for this reactive hook. If there is no</span>
            <span class="s0">// second argument then the reactive callback will re-run on every render.</span>
            <span class="s0">// So no need to check for dependency inclusion.</span>
            <span class="s4">if </span><span class="s2">(!declaredDependenciesNode &amp;&amp; !isEffect) {</span>
                <span class="s0">// These are only used for optimization.</span>
                <span class="s4">if </span><span class="s2">(reactiveHookName === </span><span class="s3">'useMemo' </span><span class="s2">||</span>
                    <span class="s2">reactiveHookName === </span><span class="s3">'useCallback'</span><span class="s2">) {</span>
                    <span class="s0">// TODO: Can this have a suggestion?</span>
                    <span class="s2">reportProblem({</span>
                        <span class="s2">node: reactiveHook,</span>
                        <span class="s2">message: </span><span class="s3">&quot;React Hook &quot;</span><span class="s2">.concat(reactiveHookName, </span><span class="s3">&quot; does nothing when called with &quot;</span><span class="s2">) +</span>
                            <span class="s3">&quot;only one argument. Did you forget to pass an array of &quot; </span><span class="s2">+</span>
                            <span class="s3">&quot;dependencies?&quot;</span><span class="s2">,</span>
                    <span class="s2">});</span>
                <span class="s2">}</span>
                <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">while </span><span class="s2">(callback.type === </span><span class="s3">'TSAsExpression' </span><span class="s2">||</span>
                <span class="s2">callback.type === </span><span class="s3">'AsExpression'</span><span class="s2">) {</span>
                <span class="s2">callback = callback.expression;</span>
            <span class="s2">}</span>
            <span class="s4">switch </span><span class="s2">(callback.type) {</span>
                <span class="s4">case </span><span class="s3">'FunctionExpression'</span><span class="s2">:</span>
                <span class="s4">case </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">:</span>
                    <span class="s2">visitFunctionWithDependencies(callback, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);</span>
                    <span class="s4">return</span><span class="s2">; </span><span class="s0">// Handled</span>
                <span class="s4">case </span><span class="s3">'Identifier'</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s2">(!declaredDependenciesNode) {</span>
                        <span class="s0">// No deps, no problems.</span>
                        <span class="s4">return</span><span class="s2">; </span><span class="s0">// Handled</span>
                    <span class="s2">}</span>
                    <span class="s0">// The function passed as a callback is not written inline.</span>
                    <span class="s0">// But perhaps it's in the dependencies array?</span>
                    <span class="s4">if </span><span class="s2">(</span><span class="s3">'elements' </span><span class="s4">in </span><span class="s2">declaredDependenciesNode &amp;&amp;</span>
                        <span class="s2">declaredDependenciesNode.elements &amp;&amp;</span>
                        <span class="s2">declaredDependenciesNode.elements.some(</span><span class="s4">function </span><span class="s2">(el) { </span><span class="s4">return </span><span class="s2">el &amp;&amp; el.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp; el.name === callback.name; })) {</span>
                        <span class="s0">// If it's already in the list of deps, we don't care because</span>
                        <span class="s0">// this is valid regardless.</span>
                        <span class="s4">return</span><span class="s2">; </span><span class="s0">// Handled</span>
                    <span class="s2">}</span>
                    <span class="s0">// We'll do our best effort to find it, complain otherwise.</span>
                    <span class="s4">var </span><span class="s2">variable = getScope(callback).set.get(callback.name);</span>
                    <span class="s4">if </span><span class="s2">(variable == </span><span class="s4">null </span><span class="s2">|| variable.defs == </span><span class="s4">null</span><span class="s2">) {</span>
                        <span class="s0">// If it's not in scope, we don't care.</span>
                        <span class="s4">return</span><span class="s2">; </span><span class="s0">// Handled</span>
                    <span class="s2">}</span>
                    <span class="s0">// The function passed as a callback is not written inline.</span>
                    <span class="s0">// But it's defined somewhere in the render scope.</span>
                    <span class="s0">// We'll do our best effort to find and check it, complain otherwise.</span>
                    <span class="s4">var </span><span class="s2">def = variable.defs[</span><span class="s5">0</span><span class="s2">];</span>
                    <span class="s4">if </span><span class="s2">(!def || !def.node) {</span>
                        <span class="s4">break</span><span class="s2">; </span><span class="s0">// Unhandled</span>
                    <span class="s2">}</span>
                    <span class="s4">if </span><span class="s2">(def.type === </span><span class="s3">'Parameter'</span><span class="s2">) {</span>
                        <span class="s2">reportProblem({</span>
                            <span class="s2">node: reactiveHook,</span>
                            <span class="s2">message: getUnknownDependenciesMessage(reactiveHookName),</span>
                        <span class="s2">});</span>
                        <span class="s4">return</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s4">if </span><span class="s2">(def.type !== </span><span class="s3">'Variable' </span><span class="s2">&amp;&amp; def.type !== </span><span class="s3">'FunctionName'</span><span class="s2">) {</span>
                        <span class="s0">// Parameter or an unusual pattern. Bail out.</span>
                        <span class="s4">break</span><span class="s2">; </span><span class="s0">// Unhandled</span>
                    <span class="s2">}</span>
                    <span class="s4">switch </span><span class="s2">(def.node.type) {</span>
                        <span class="s4">case </span><span class="s3">'FunctionDeclaration'</span><span class="s2">:</span>
                            <span class="s0">// useEffect(() =&gt; { ... }, []);</span>
                            <span class="s2">visitFunctionWithDependencies(def.node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);</span>
                            <span class="s4">return</span><span class="s2">; </span><span class="s0">// Handled</span>
                        <span class="s4">case </span><span class="s3">'VariableDeclarator'</span><span class="s2">:</span>
                            <span class="s4">var </span><span class="s2">init = def.node.init;</span>
                            <span class="s4">if </span><span class="s2">(!init) {</span>
                                <span class="s4">break</span><span class="s2">; </span><span class="s0">// Unhandled</span>
                            <span class="s2">}</span>
                            <span class="s4">switch </span><span class="s2">(init.type) {</span>
                                <span class="s0">// const effectBody = () =&gt; {...};</span>
                                <span class="s0">// useEffect(effectBody, []);</span>
                                <span class="s4">case </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">:</span>
                                <span class="s4">case </span><span class="s3">'FunctionExpression'</span><span class="s2">:</span>
                                    <span class="s0">// We can inspect this function as if it were inline.</span>
                                    <span class="s2">visitFunctionWithDependencies(init, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);</span>
                                    <span class="s4">return</span><span class="s2">; </span><span class="s0">// Handled</span>
                            <span class="s2">}</span>
                            <span class="s4">break</span><span class="s2">; </span><span class="s0">// Unhandled</span>
                    <span class="s2">}</span>
                    <span class="s4">break</span><span class="s2">; </span><span class="s0">// Unhandled</span>
                <span class="s4">default</span><span class="s2">:</span>
                    <span class="s0">// useEffect(generateEffectBody(), []);</span>
                    <span class="s2">reportProblem({</span>
                        <span class="s2">node: reactiveHook,</span>
                        <span class="s2">message: getUnknownDependenciesMessage(reactiveHookName),</span>
                    <span class="s2">});</span>
                    <span class="s4">return</span><span class="s2">; </span><span class="s0">// Handled</span>
            <span class="s2">}</span>
            <span class="s0">// Something unusual. Fall back to suggesting to add the body itself as a dep.</span>
            <span class="s2">reportProblem({</span>
                <span class="s2">node: reactiveHook,</span>
                <span class="s2">message: </span><span class="s3">&quot;React Hook &quot;</span><span class="s2">.concat(reactiveHookName, </span><span class="s3">&quot; has a missing dependency: '&quot;</span><span class="s2">).concat(callback.name, </span><span class="s3">&quot;'. &quot;</span><span class="s2">) +</span>
                    <span class="s3">&quot;Either include it or remove the dependency array.&quot;</span><span class="s2">,</span>
                <span class="s2">suggest: [</span>
                    <span class="s2">{</span>
                        <span class="s2">desc: </span><span class="s3">&quot;Update the dependencies array to be: [&quot;</span><span class="s2">.concat(callback.name, </span><span class="s3">&quot;]&quot;</span><span class="s2">),</span>
                        <span class="s2">fix: </span><span class="s4">function </span><span class="s2">(fixer) {</span>
                            <span class="s4">return </span><span class="s2">fixer.replaceText(declaredDependenciesNode, </span><span class="s3">&quot;[&quot;</span><span class="s2">.concat(callback.name, </span><span class="s3">&quot;]&quot;</span><span class="s2">));</span>
                        <span class="s2">},</span>
                    <span class="s2">},</span>
                <span class="s2">],</span>
            <span class="s2">});</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">{</span>
            <span class="s2">CallExpression: visitCallExpression,</span>
        <span class="s2">};</span>
    <span class="s2">},</span>
<span class="s2">};</span>
<span class="s0">// The meat of the logic.</span>
<span class="s4">function </span><span class="s2">collectRecommendations(_a) {</span>
    <span class="s4">var </span><span class="s2">dependencies = _a.dependencies, declaredDependencies = _a.declaredDependencies, stableDependencies = _a.stableDependencies, externalDependencies = _a.externalDependencies, isEffect = _a.isEffect;</span>
    <span class="s0">// Our primary data structure.</span>
    <span class="s0">// It is a logical representation of property chains:</span>
    <span class="s0">// `props` -&gt; `props.foo` -&gt; `props.foo.bar` -&gt; `props.foo.bar.baz`</span>
    <span class="s0">//         -&gt; `props.lol`</span>
    <span class="s0">//         -&gt; `props.huh` -&gt; `props.huh.okay`</span>
    <span class="s0">//         -&gt; `props.wow`</span>
    <span class="s0">// We'll use it to mark nodes that are *used* by the programmer,</span>
    <span class="s0">// and the nodes that were *declared* as deps. Then we will</span>
    <span class="s0">// traverse it to learn which deps are missing or unnecessary.</span>
    <span class="s4">var </span><span class="s2">depTree = createDepTree();</span>
    <span class="s4">function </span><span class="s2">createDepTree() {</span>
        <span class="s4">return </span><span class="s2">{</span>
            <span class="s2">isUsed: </span><span class="s4">false</span><span class="s2">, </span><span class="s0">// True if used in code</span>
            <span class="s2">isSatisfiedRecursively: </span><span class="s4">false</span><span class="s2">, </span><span class="s0">// True if specified in deps</span>
            <span class="s2">isSubtreeUsed: </span><span class="s4">false</span><span class="s2">, </span><span class="s0">// True if something deeper is used by code</span>
            <span class="s2">children: </span><span class="s4">new </span><span class="s2">Map(), </span><span class="s0">// Nodes for properties</span>
        <span class="s2">};</span>
    <span class="s2">}</span>
    <span class="s0">// Mark all required nodes first.</span>
    <span class="s0">// Imagine exclamation marks next to each used deep property.</span>
    <span class="s2">dependencies.forEach(</span><span class="s4">function </span><span class="s2">(_, key) {</span>
        <span class="s4">var </span><span class="s2">node = getOrCreateNodeByPath(depTree, key);</span>
        <span class="s2">node.isUsed = </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s2">markAllParentsByPath(depTree, key, </span><span class="s4">function </span><span class="s2">(parent) {</span>
            <span class="s2">parent.isSubtreeUsed = </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s2">});</span>
    <span class="s2">});</span>
    <span class="s0">// Mark all satisfied nodes.</span>
    <span class="s0">// Imagine checkmarks next to each declared dependency.</span>
    <span class="s2">declaredDependencies.forEach(</span><span class="s4">function </span><span class="s2">(_a) {</span>
        <span class="s4">var </span><span class="s2">key = _a.key;</span>
        <span class="s4">var </span><span class="s2">node = getOrCreateNodeByPath(depTree, key);</span>
        <span class="s2">node.isSatisfiedRecursively = </span><span class="s4">true</span><span class="s2">;</span>
    <span class="s2">});</span>
    <span class="s2">stableDependencies.forEach(</span><span class="s4">function </span><span class="s2">(key) {</span>
        <span class="s4">var </span><span class="s2">node = getOrCreateNodeByPath(depTree, key);</span>
        <span class="s2">node.isSatisfiedRecursively = </span><span class="s4">true</span><span class="s2">;</span>
    <span class="s2">});</span>
    <span class="s0">// Tree manipulation helpers.</span>
    <span class="s4">function </span><span class="s2">getOrCreateNodeByPath(rootNode, path) {</span>
        <span class="s4">var </span><span class="s2">e_13, _a;</span>
        <span class="s4">var </span><span class="s2">keys = path.split(</span><span class="s3">'.'</span><span class="s2">);</span>
        <span class="s4">var </span><span class="s2">node = rootNode;</span>
        <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {</span>
                <span class="s4">var </span><span class="s2">key = keys_1_1.value;</span>
                <span class="s4">var </span><span class="s2">child = node.children.get(key);</span>
                <span class="s4">if </span><span class="s2">(!child) {</span>
                    <span class="s2">child = createDepTree();</span>
                    <span class="s2">node.children.set(key, child);</span>
                <span class="s2">}</span>
                <span class="s2">node = child;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">catch </span><span class="s2">(e_13_1) { e_13 = { error: e_13_1 }; }</span>
        <span class="s4">finally </span><span class="s2">{</span>
            <span class="s4">try </span><span class="s2">{</span>
                <span class="s4">if </span><span class="s2">(keys_1_1 &amp;&amp; !keys_1_1.done &amp;&amp; (_a = keys_1.return)) _a.call(keys_1);</span>
            <span class="s2">}</span>
            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_13) </span><span class="s4">throw </span><span class="s2">e_13.error; }</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">node;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">markAllParentsByPath(rootNode, path, fn) {</span>
        <span class="s4">var </span><span class="s2">e_14, _a;</span>
        <span class="s4">var </span><span class="s2">keys = path.split(</span><span class="s3">'.'</span><span class="s2">);</span>
        <span class="s4">var </span><span class="s2">node = rootNode;</span>
        <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {</span>
                <span class="s4">var </span><span class="s2">key = keys_2_1.value;</span>
                <span class="s4">var </span><span class="s2">child = node.children.get(key);</span>
                <span class="s4">if </span><span class="s2">(!child) {</span>
                    <span class="s4">return</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s2">fn(child);</span>
                <span class="s2">node = child;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">catch </span><span class="s2">(e_14_1) { e_14 = { error: e_14_1 }; }</span>
        <span class="s4">finally </span><span class="s2">{</span>
            <span class="s4">try </span><span class="s2">{</span>
                <span class="s4">if </span><span class="s2">(keys_2_1 &amp;&amp; !keys_2_1.done &amp;&amp; (_a = keys_2.return)) _a.call(keys_2);</span>
            <span class="s2">}</span>
            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_14) </span><span class="s4">throw </span><span class="s2">e_14.error; }</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s0">// Now we can learn which dependencies are missing or necessary.</span>
    <span class="s4">var </span><span class="s2">missingDependencies = </span><span class="s4">new </span><span class="s2">Set();</span>
    <span class="s4">var </span><span class="s2">satisfyingDependencies = </span><span class="s4">new </span><span class="s2">Set();</span>
    <span class="s2">scanTreeRecursively(depTree, missingDependencies, satisfyingDependencies, </span><span class="s4">function </span><span class="s2">(key) { </span><span class="s4">return </span><span class="s2">key; });</span>
    <span class="s4">function </span><span class="s2">scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {</span>
        <span class="s2">node.children.forEach(</span><span class="s4">function </span><span class="s2">(child, key) {</span>
            <span class="s4">var </span><span class="s2">path = keyToPath(key);</span>
            <span class="s4">if </span><span class="s2">(child.isSatisfiedRecursively) {</span>
                <span class="s4">if </span><span class="s2">(child.isSubtreeUsed) {</span>
                    <span class="s0">// Remember this dep actually satisfied something.</span>
                    <span class="s2">satisfyingPaths.add(path);</span>
                <span class="s2">}</span>
                <span class="s0">// It doesn't matter if there's something deeper.</span>
                <span class="s0">// It would be transitively satisfied since we assume immutability.</span>
                <span class="s0">// `props.foo` is enough if you read `props.foo.id`.</span>
                <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">if </span><span class="s2">(child.isUsed) {</span>
                <span class="s0">// Remember that no declared deps satisfied this node.</span>
                <span class="s2">missingPaths.add(path);</span>
                <span class="s0">// If we got here, nothing in its subtree was satisfied.</span>
                <span class="s0">// No need to search further.</span>
                <span class="s4">return</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s2">scanTreeRecursively(child, missingPaths, satisfyingPaths, </span><span class="s4">function </span><span class="s2">(childKey) { </span><span class="s4">return </span><span class="s2">path + </span><span class="s3">'.' </span><span class="s2">+ childKey; });</span>
        <span class="s2">});</span>
    <span class="s2">}</span>
    <span class="s0">// Collect suggestions in the order they were originally specified.</span>
    <span class="s4">var </span><span class="s2">suggestedDependencies = [];</span>
    <span class="s4">var </span><span class="s2">unnecessaryDependencies = </span><span class="s4">new </span><span class="s2">Set();</span>
    <span class="s4">var </span><span class="s2">duplicateDependencies = </span><span class="s4">new </span><span class="s2">Set();</span>
    <span class="s2">declaredDependencies.forEach(</span><span class="s4">function </span><span class="s2">(_a) {</span>
        <span class="s4">var </span><span class="s2">key = _a.key;</span>
        <span class="s0">// Does this declared dep satisfy a real need?</span>
        <span class="s4">if </span><span class="s2">(satisfyingDependencies.has(key)) {</span>
            <span class="s4">if </span><span class="s2">(suggestedDependencies.indexOf(key) === -</span><span class="s5">1</span><span class="s2">) {</span>
                <span class="s0">// Good one.</span>
                <span class="s2">suggestedDependencies.push(key);</span>
            <span class="s2">}</span>
            <span class="s4">else </span><span class="s2">{</span>
                <span class="s0">// Duplicate.</span>
                <span class="s2">duplicateDependencies.add(key);</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">if </span><span class="s2">(isEffect &amp;&amp;</span>
                <span class="s2">!key.endsWith(</span><span class="s3">'.current'</span><span class="s2">) &amp;&amp;</span>
                <span class="s2">!externalDependencies.has(key)) {</span>
                <span class="s0">// Effects are allowed extra &quot;unnecessary&quot; deps.</span>
                <span class="s0">// Such as resetting scroll when ID changes.</span>
                <span class="s0">// Consider them legit.</span>
                <span class="s0">// The exception is ref.current which is always wrong.</span>
                <span class="s4">if </span><span class="s2">(suggestedDependencies.indexOf(key) === -</span><span class="s5">1</span><span class="s2">) {</span>
                    <span class="s2">suggestedDependencies.push(key);</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s4">else </span><span class="s2">{</span>
                <span class="s0">// It's definitely not needed.</span>
                <span class="s2">unnecessaryDependencies.add(key);</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">});</span>
    <span class="s0">// Then add the missing ones at the end.</span>
    <span class="s2">missingDependencies.forEach(</span><span class="s4">function </span><span class="s2">(key) {</span>
        <span class="s2">suggestedDependencies.push(key);</span>
    <span class="s2">});</span>
    <span class="s4">return </span><span class="s2">{</span>
        <span class="s2">suggestedDependencies: suggestedDependencies,</span>
        <span class="s2">unnecessaryDependencies: unnecessaryDependencies,</span>
        <span class="s2">duplicateDependencies: duplicateDependencies,</span>
        <span class="s2">missingDependencies: missingDependencies,</span>
    <span class="s2">};</span>
<span class="s2">}</span>
<span class="s0">// If the node will result in constructing a referentially unique value, return</span>
<span class="s0">// its human readable type name, else return null.</span>
<span class="s4">function </span><span class="s2">getConstructionExpressionType(node) {</span>
    <span class="s4">switch </span><span class="s2">(node.type) {</span>
        <span class="s4">case </span><span class="s3">'ObjectExpression'</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s3">'object'</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'ArrayExpression'</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s3">'array'</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">'FunctionExpression'</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s3">'function'</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'ClassExpression'</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s3">'class'</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'ConditionalExpression'</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(getConstructionExpressionType(node.consequent) != </span><span class="s4">null </span><span class="s2">||</span>
                <span class="s2">getConstructionExpressionType(node.alternate) != </span><span class="s4">null</span><span class="s2">) {</span>
                <span class="s4">return </span><span class="s3">'conditional'</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">return null</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'LogicalExpression'</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(getConstructionExpressionType(node.left) != </span><span class="s4">null </span><span class="s2">||</span>
                <span class="s2">getConstructionExpressionType(node.right) != </span><span class="s4">null</span><span class="s2">) {</span>
                <span class="s4">return </span><span class="s3">'logical expression'</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">return null</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'JSXFragment'</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s3">'JSX fragment'</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'JSXElement'</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s3">'JSX element'</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'AssignmentExpression'</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(getConstructionExpressionType(node.right) != </span><span class="s4">null</span><span class="s2">) {</span>
                <span class="s4">return </span><span class="s3">'assignment expression'</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">return null</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'NewExpression'</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s3">'object construction'</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'Literal'</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(node.value </span><span class="s4">instanceof </span><span class="s2">RegExp) {</span>
                <span class="s4">return </span><span class="s3">'regular expression'</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">return null</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'TypeCastExpression'</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">'AsExpression'</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">'TSAsExpression'</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">getConstructionExpressionType(node.expression);</span>
    <span class="s2">}</span>
    <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">// Finds variables declared as dependencies</span>
<span class="s0">// that would invalidate on every render.</span>
<span class="s4">function </span><span class="s2">scanForConstructions(_a) {</span>
    <span class="s4">var </span><span class="s2">declaredDependencies = _a.declaredDependencies, declaredDependenciesNode = _a.declaredDependenciesNode, componentScope = _a.componentScope, scope = _a.scope;</span>
    <span class="s4">var </span><span class="s2">constructions = declaredDependencies</span>
        <span class="s2">.map(</span><span class="s4">function </span><span class="s2">(_a) {</span>
        <span class="s4">var </span><span class="s2">key = _a.key;</span>
        <span class="s4">var </span><span class="s2">ref = componentScope.variables.find(</span><span class="s4">function </span><span class="s2">(v) { </span><span class="s4">return </span><span class="s2">v.name === key; });</span>
        <span class="s4">if </span><span class="s2">(ref == </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s4">return null</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">var </span><span class="s2">node = ref.defs[</span><span class="s5">0</span><span class="s2">];</span>
        <span class="s4">if </span><span class="s2">(node == </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s4">return null</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s0">// const handleChange = function () {}</span>
        <span class="s0">// const handleChange = () =&gt; {}</span>
        <span class="s0">// const foo = {}</span>
        <span class="s0">// const foo = []</span>
        <span class="s0">// etc.</span>
        <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'Variable' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">node.node.type === </span><span class="s3">'VariableDeclarator' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">node.node.id.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp; </span><span class="s0">// Ensure this is not destructed assignment</span>
            <span class="s2">node.node.init != </span><span class="s4">null</span><span class="s2">) {</span>
            <span class="s4">var </span><span class="s2">constantExpressionType = getConstructionExpressionType(node.node.init);</span>
            <span class="s4">if </span><span class="s2">(constantExpressionType) {</span>
                <span class="s4">return </span><span class="s2">[ref, constantExpressionType];</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s0">// function handleChange() {}</span>
        <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'FunctionName' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">node.node.type === </span><span class="s3">'FunctionDeclaration'</span><span class="s2">) {</span>
            <span class="s4">return </span><span class="s2">[ref, </span><span class="s3">'function'</span><span class="s2">];</span>
        <span class="s2">}</span>
        <span class="s0">// class Foo {}</span>
        <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'ClassName' </span><span class="s2">&amp;&amp; node.node.type === </span><span class="s3">'ClassDeclaration'</span><span class="s2">) {</span>
            <span class="s4">return </span><span class="s2">[ref, </span><span class="s3">'class'</span><span class="s2">];</span>
        <span class="s2">}</span>
        <span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">})</span>
        <span class="s2">.filter(Boolean);</span>
    <span class="s4">function </span><span class="s2">isUsedOutsideOfHook(ref) {</span>
        <span class="s4">var </span><span class="s2">e_15, _a;</span>
        <span class="s4">var </span><span class="s2">foundWriteExpr = </span><span class="s4">false</span><span class="s2">;</span>
        <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_b = __values(ref.references), _c = _b.next(); !_c.done; _c = _b.next()) {</span>
                <span class="s4">var </span><span class="s2">reference = _c.value;</span>
                <span class="s4">if </span><span class="s2">(reference.writeExpr) {</span>
                    <span class="s4">if </span><span class="s2">(foundWriteExpr) {</span>
                        <span class="s0">// Two writes to the same function.</span>
                        <span class="s4">return true</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s4">else </span><span class="s2">{</span>
                        <span class="s0">// Ignore first write as it's not usage.</span>
                        <span class="s2">foundWriteExpr = </span><span class="s4">true</span><span class="s2">;</span>
                        <span class="s4">continue</span><span class="s2">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">var </span><span class="s2">currentScope = reference.from;</span>
                <span class="s4">while </span><span class="s2">(currentScope !== scope &amp;&amp; currentScope != </span><span class="s4">null</span><span class="s2">) {</span>
                    <span class="s2">currentScope = currentScope.upper;</span>
                <span class="s2">}</span>
                <span class="s4">if </span><span class="s2">(currentScope !== scope) {</span>
                    <span class="s0">// This reference is outside the Hook callback.</span>
                    <span class="s0">// It can only be legit if it's the deps array.</span>
                    <span class="s4">if </span><span class="s2">(!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {</span>
                        <span class="s4">return true</span><span class="s2">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">catch </span><span class="s2">(e_15_1) { e_15 = { error: e_15_1 }; }</span>
        <span class="s4">finally </span><span class="s2">{</span>
            <span class="s4">try </span><span class="s2">{</span>
                <span class="s4">if </span><span class="s2">(_c &amp;&amp; !_c.done &amp;&amp; (_a = _b.return)) _a.call(_b);</span>
            <span class="s2">}</span>
            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_15) </span><span class="s4">throw </span><span class="s2">e_15.error; }</span>
        <span class="s2">}</span>
        <span class="s4">return false</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">constructions.map(</span><span class="s4">function </span><span class="s2">(_a) {</span>
        <span class="s4">var </span><span class="s2">_b = __read(_a, </span><span class="s5">2</span><span class="s2">), ref = _b[</span><span class="s5">0</span><span class="s2">], depType = _b[</span><span class="s5">1</span><span class="s2">];</span>
        <span class="s4">return </span><span class="s2">({</span>
            <span class="s2">construction: ref.defs[</span><span class="s5">0</span><span class="s2">],</span>
            <span class="s2">depType: depType,</span>
            <span class="s2">isUsedOutsideOfHook: isUsedOutsideOfHook(ref),</span>
        <span class="s2">});</span>
    <span class="s2">});</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* Assuming () means the passed/returned node:</span>
 <span class="s0">* (props) =&gt; (props)</span>
 <span class="s0">* props.(foo) =&gt; (props.foo)</span>
 <span class="s0">* props.foo.(bar) =&gt; (props).foo.bar</span>
 <span class="s0">* props.foo.bar.(baz) =&gt; (props).foo.bar.baz</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getDependency(node) {</span>
    <span class="s4">if </span><span class="s2">(node.parent &amp;&amp;</span>
        <span class="s2">(node.parent.type === </span><span class="s3">'MemberExpression' </span><span class="s2">||</span>
            <span class="s2">node.parent.type === </span><span class="s3">'OptionalMemberExpression'</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">node.parent.object === node &amp;&amp;</span>
        <span class="s3">'name' </span><span class="s4">in </span><span class="s2">node.parent.property &amp;&amp;</span>
        <span class="s2">node.parent.property.name !== </span><span class="s3">'current' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">!node.parent.computed &amp;&amp;</span>
        <span class="s2">!(node.parent.parent != </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
            <span class="s2">(node.parent.parent.type === </span><span class="s3">'CallExpression' </span><span class="s2">||</span>
                <span class="s2">node.parent.parent.type === </span><span class="s3">'OptionalCallExpression'</span><span class="s2">) &amp;&amp;</span>
            <span class="s2">node.parent.parent.callee === node.parent)) {</span>
        <span class="s4">return </span><span class="s2">getDependency(node.parent);</span>
    <span class="s2">}</span>
    <span class="s4">else if </span><span class="s2">(</span>
    <span class="s0">// Note: we don't check OptionalMemberExpression because it can't be LHS.</span>
    <span class="s2">node.type === </span><span class="s3">'MemberExpression' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">node.parent &amp;&amp;</span>
        <span class="s2">node.parent.type === </span><span class="s3">'AssignmentExpression' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">node.parent.left === node) {</span>
        <span class="s4">return </span><span class="s2">node.object;</span>
    <span class="s2">}</span>
    <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">return </span><span class="s2">node;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* Mark a node as either optional or required.</span>
 <span class="s0">* Note: If the node argument is an OptionalMemberExpression, it doesn't necessarily mean it is optional.</span>
 <span class="s0">* It just means there is an optional member somewhere inside.</span>
 <span class="s0">* This particular node might still represent a required member, so check .optional field.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">markNode(node, optionalChains, result) {</span>
    <span class="s4">if </span><span class="s2">(optionalChains) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">'optional' </span><span class="s4">in </span><span class="s2">node &amp;&amp; node.optional) {</span>
            <span class="s0">// We only want to consider it optional if *all* usages were optional.</span>
            <span class="s4">if </span><span class="s2">(!optionalChains.has(result)) {</span>
                <span class="s0">// Mark as (maybe) optional. If there's a required usage, this will be overridden.</span>
                <span class="s2">optionalChains.set(result, </span><span class="s4">true</span><span class="s2">);</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">else </span><span class="s2">{</span>
            <span class="s0">// Mark as required.</span>
            <span class="s2">optionalChains.set(result, </span><span class="s4">false</span><span class="s2">);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* Assuming () means the passed node.</span>
 <span class="s0">* (foo) -&gt; 'foo'</span>
 <span class="s0">* foo(.)bar -&gt; 'foo.bar'</span>
 <span class="s0">* foo.bar(.)baz -&gt; 'foo.bar.baz'</span>
 <span class="s0">* Otherwise throw.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">analyzePropertyChain(node, optionalChains) {</span>
    <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'Identifier' </span><span class="s2">|| node.type === </span><span class="s3">'JSXIdentifier'</span><span class="s2">) {</span>
        <span class="s4">var </span><span class="s2">result = node.name;</span>
        <span class="s4">if </span><span class="s2">(optionalChains) {</span>
            <span class="s0">// Mark as required.</span>
            <span class="s2">optionalChains.set(result, </span><span class="s4">false</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">result;</span>
    <span class="s2">}</span>
    <span class="s4">else if </span><span class="s2">(node.type === </span><span class="s3">'MemberExpression' </span><span class="s2">&amp;&amp; !node.computed) {</span>
        <span class="s4">var </span><span class="s2">object = analyzePropertyChain(node.object, optionalChains);</span>
        <span class="s4">var </span><span class="s2">property = analyzePropertyChain(node.property, </span><span class="s4">null</span><span class="s2">);</span>
        <span class="s4">var </span><span class="s2">result = </span><span class="s3">&quot;&quot;</span><span class="s2">.concat(object, </span><span class="s3">&quot;.&quot;</span><span class="s2">).concat(property);</span>
        <span class="s2">markNode(node, optionalChains, result);</span>
        <span class="s4">return </span><span class="s2">result;</span>
    <span class="s2">}</span>
    <span class="s4">else if </span><span class="s2">(node.type === </span><span class="s3">'OptionalMemberExpression' </span><span class="s2">&amp;&amp; !node.computed) {</span>
        <span class="s4">var </span><span class="s2">object = analyzePropertyChain(node.object, optionalChains);</span>
        <span class="s4">var </span><span class="s2">property = analyzePropertyChain(node.property, </span><span class="s4">null</span><span class="s2">);</span>
        <span class="s4">var </span><span class="s2">result = </span><span class="s3">&quot;&quot;</span><span class="s2">.concat(object, </span><span class="s3">&quot;.&quot;</span><span class="s2">).concat(property);</span>
        <span class="s2">markNode(node, optionalChains, result);</span>
        <span class="s4">return </span><span class="s2">result;</span>
    <span class="s2">}</span>
    <span class="s4">else if </span><span class="s2">(node.type === </span><span class="s3">'ChainExpression' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(!(</span><span class="s3">'computed' </span><span class="s4">in </span><span class="s2">node) || !node.computed)) {</span>
        <span class="s4">var </span><span class="s2">expression = node.expression;</span>
        <span class="s4">if </span><span class="s2">(expression.type === </span><span class="s3">'CallExpression'</span><span class="s2">) {</span>
            <span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">&quot;Unsupported node type: &quot;</span><span class="s2">.concat(expression.type));</span>
        <span class="s2">}</span>
        <span class="s4">var </span><span class="s2">object = analyzePropertyChain(expression.object, optionalChains);</span>
        <span class="s4">var </span><span class="s2">property = analyzePropertyChain(expression.property, </span><span class="s4">null</span><span class="s2">);</span>
        <span class="s4">var </span><span class="s2">result = </span><span class="s3">&quot;&quot;</span><span class="s2">.concat(object, </span><span class="s3">&quot;.&quot;</span><span class="s2">).concat(property);</span>
        <span class="s2">markNode(expression, optionalChains, result);</span>
        <span class="s4">return </span><span class="s2">result;</span>
    <span class="s2">}</span>
    <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">&quot;Unsupported node type: &quot;</span><span class="s2">.concat(node.type));</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getNodeWithoutReactNamespace(node) {</span>
    <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'MemberExpression' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">node.object.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">node.object.name === </span><span class="s3">'React' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">node.property.type === </span><span class="s3">'Identifier' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">!node.computed) {</span>
        <span class="s4">return </span><span class="s2">node.property;</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">node;</span>
<span class="s2">}</span>
<span class="s0">// What's the index of callback that needs to be analyzed for a given Hook?</span>
<span class="s0">// -1 if it's not a Hook we care about (e.g. useState).</span>
<span class="s0">// 0 for useEffect/useMemo/useCallback(fn).</span>
<span class="s0">// 1 for useImperativeHandle(ref, fn).</span>
<span class="s0">// For additionally configured Hooks, assume that they're like useEffect (0).</span>
<span class="s4">function </span><span class="s2">getReactiveHookCallbackIndex(calleeNode, options) {</span>
    <span class="s4">var </span><span class="s2">node = getNodeWithoutReactNamespace(calleeNode);</span>
    <span class="s4">if </span><span class="s2">(node.type !== </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
        <span class="s4">return </span><span class="s2">-</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">switch </span><span class="s2">(node.name) {</span>
        <span class="s4">case </span><span class="s3">'useEffect'</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">'useLayoutEffect'</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">'useCallback'</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">'useMemo'</span><span class="s2">:</span>
            <span class="s0">// useEffect(fn)</span>
            <span class="s4">return </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">'useImperativeHandle'</span><span class="s2">:</span>
            <span class="s0">// useImperativeHandle(ref, fn)</span>
            <span class="s4">return </span><span class="s5">1</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(node === calleeNode &amp;&amp; options &amp;&amp; options.additionalHooks) {</span>
                <span class="s0">// Allow the user to provide a regular expression which enables the lint to</span>
                <span class="s0">// target custom reactive hooks.</span>
                <span class="s4">var </span><span class="s2">name = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>
                <span class="s4">try </span><span class="s2">{</span>
                    <span class="s2">name = analyzePropertyChain(node, </span><span class="s4">null</span><span class="s2">);</span>
                <span class="s2">}</span>
                <span class="s4">catch </span><span class="s2">(error) {</span>
                    <span class="s4">if </span><span class="s2">(error </span><span class="s4">instanceof </span><span class="s2">Error &amp;&amp;</span>
                        <span class="s6">/Unsupported node type/</span><span class="s2">.test(error.message)) {</span>
                        <span class="s4">return </span><span class="s5">0</span><span class="s2">;</span>
                    <span class="s2">}</span>
                    <span class="s4">else </span><span class="s2">{</span>
                        <span class="s4">throw </span><span class="s2">error;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s4">return </span><span class="s2">options.additionalHooks.test(name) ? </span><span class="s5">0 </span><span class="s2">: -</span><span class="s5">1</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s4">else </span><span class="s2">{</span>
                <span class="s4">return </span><span class="s2">-</span><span class="s5">1</span><span class="s2">;</span>
            <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* ESLint won't assign node.parent to references from context.getScope()</span>
 <span class="s0">*</span>
 <span class="s0">* So instead we search for the node from an ancestor assigning node.parent</span>
 <span class="s0">* as we go. This mutates the AST.</span>
 <span class="s0">*</span>
 <span class="s0">* This traversal is:</span>
 <span class="s0">* - optimized by only searching nodes with a range surrounding our target node</span>
 <span class="s0">* - agnostic to AST node types, it looks for `{ type: string, ... }`</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">fastFindReferenceWithParent(start, target) {</span>
    <span class="s4">var </span><span class="s2">e_16, _a;</span>
    <span class="s4">var </span><span class="s2">queue = [start];</span>
    <span class="s4">var </span><span class="s2">item;</span>
    <span class="s4">while </span><span class="s2">(queue.length) {</span>
        <span class="s2">item = queue.shift();</span>
        <span class="s4">if </span><span class="s2">(isSameIdentifier(item, target)) {</span>
            <span class="s4">return </span><span class="s2">item;</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(!isAncestorNodeOf(item, target)) {</span>
            <span class="s4">continue</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">_b = (e_16 = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">, __values(Object.entries(item))), _c = _b.next(); !_c.done; _c = _b.next()) {</span>
                <span class="s4">var </span><span class="s2">_d = __read(_c.value, </span><span class="s5">2</span><span class="s2">), key = _d[</span><span class="s5">0</span><span class="s2">], value = _d[</span><span class="s5">1</span><span class="s2">];</span>
                <span class="s4">if </span><span class="s2">(key === </span><span class="s3">'parent'</span><span class="s2">) {</span>
                    <span class="s4">continue</span><span class="s2">;</span>
                <span class="s2">}</span>
                <span class="s4">if </span><span class="s2">(isNodeLike(value)) {</span>
                    <span class="s2">value.parent = item;</span>
                    <span class="s2">queue.push(value);</span>
                <span class="s2">}</span>
                <span class="s4">else if </span><span class="s2">(Array.isArray(value)) {</span>
                    <span class="s2">value.forEach(</span><span class="s4">function </span><span class="s2">(val) {</span>
                        <span class="s4">if </span><span class="s2">(isNodeLike(val)) {</span>
                            <span class="s2">val.parent = item;</span>
                            <span class="s2">queue.push(val);</span>
                        <span class="s2">}</span>
                    <span class="s2">});</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">catch </span><span class="s2">(e_16_1) { e_16 = { error: e_16_1 }; }</span>
        <span class="s4">finally </span><span class="s2">{</span>
            <span class="s4">try </span><span class="s2">{</span>
                <span class="s4">if </span><span class="s2">(_c &amp;&amp; !_c.done &amp;&amp; (_a = _b.return)) _a.call(_b);</span>
            <span class="s2">}</span>
            <span class="s4">finally </span><span class="s2">{ </span><span class="s4">if </span><span class="s2">(e_16) </span><span class="s4">throw </span><span class="s2">e_16.error; }</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">joinEnglish(arr) {</span>
    <span class="s4">var </span><span class="s2">s = </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; arr.length; i++) {</span>
        <span class="s2">s += arr[i];</span>
        <span class="s4">if </span><span class="s2">(i === </span><span class="s5">0 </span><span class="s2">&amp;&amp; arr.length === </span><span class="s5">2</span><span class="s2">) {</span>
            <span class="s2">s += </span><span class="s3">' and '</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">else if </span><span class="s2">(i === arr.length - </span><span class="s5">2 </span><span class="s2">&amp;&amp; arr.length &gt; </span><span class="s5">2</span><span class="s2">) {</span>
            <span class="s2">s += </span><span class="s3">', and '</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s4">else if </span><span class="s2">(i &lt; arr.length - </span><span class="s5">1</span><span class="s2">) {</span>
            <span class="s2">s += </span><span class="s3">', '</span><span class="s2">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">return </span><span class="s2">s;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isNodeLike(val) {</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">val === </span><span class="s3">'object' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">val !== </span><span class="s4">null </span><span class="s2">&amp;&amp;</span>
        <span class="s2">!Array.isArray(val) &amp;&amp;</span>
        <span class="s3">'type' </span><span class="s4">in </span><span class="s2">val &amp;&amp;</span>
        <span class="s4">typeof </span><span class="s2">val.type === </span><span class="s3">'string'</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isSameIdentifier(a, b) {</span>
    <span class="s4">return </span><span class="s2">((a.type === </span><span class="s3">'Identifier' </span><span class="s2">|| a.type === </span><span class="s3">'JSXIdentifier'</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">a.type === b.type &amp;&amp;</span>
        <span class="s2">a.name === b.name &amp;&amp;</span>
        <span class="s2">!!a.range &amp;&amp;</span>
        <span class="s2">!!b.range &amp;&amp;</span>
        <span class="s2">a.range[</span><span class="s5">0</span><span class="s2">] === b.range[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
        <span class="s2">a.range[</span><span class="s5">1</span><span class="s2">] === b.range[</span><span class="s5">1</span><span class="s2">]);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isAncestorNodeOf(a, b) {</span>
    <span class="s4">return </span><span class="s2">(!!a.range &amp;&amp;</span>
        <span class="s2">!!b.range &amp;&amp;</span>
        <span class="s2">a.range[</span><span class="s5">0</span><span class="s2">] &lt;= b.range[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
        <span class="s2">a.range[</span><span class="s5">1</span><span class="s2">] &gt;= b.range[</span><span class="s5">1</span><span class="s2">]);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">isUseEffectEventIdentifier(node) {</span>
    <span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getUnknownDependenciesMessage(reactiveHookName) {</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s3">&quot;React Hook &quot;</span><span class="s2">.concat(reactiveHookName, </span><span class="s3">&quot; received a function whose dependencies &quot;</span><span class="s2">) +</span>
        <span class="s3">&quot;are unknown. Pass an inline function instead.&quot;</span><span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">// All rules</span>
<span class="s4">var </span><span class="s2">rules = {</span>
    <span class="s3">'rules-of-hooks'</span><span class="s2">: rule$1,</span>
    <span class="s3">'exhaustive-deps'</span><span class="s2">: rule,</span>
<span class="s2">};</span>
<span class="s0">// Config rules</span>
<span class="s4">var </span><span class="s2">configRules = {</span>
    <span class="s3">'react-hooks/rules-of-hooks'</span><span class="s2">: </span><span class="s3">'error'</span><span class="s2">,</span>
    <span class="s3">'react-hooks/exhaustive-deps'</span><span class="s2">: </span><span class="s3">'warn'</span><span class="s2">,</span>
<span class="s2">};</span>
<span class="s0">// Legacy config</span>
<span class="s4">var </span><span class="s2">legacyRecommendedConfig = {</span>
    <span class="s2">plugins: [</span><span class="s3">'react-hooks'</span><span class="s2">],</span>
    <span class="s2">rules: configRules,</span>
<span class="s2">};</span>
<span class="s0">// Plugin object</span>
<span class="s4">var </span><span class="s2">plugin = {</span>
    <span class="s0">// TODO: Make this more dynamic to populate version from package.json.</span>
    <span class="s0">// This can be done by injecting at build time, since importing the package.json isn't an option in Meta</span>
    <span class="s2">meta: { name: </span><span class="s3">'eslint-plugin-react-hooks' </span><span class="s2">},</span>
    <span class="s2">rules: rules,</span>
    <span class="s2">configs: {</span>
        <span class="s0">/** Legacy recommended config, to be used with rc-based configurations */</span>
        <span class="s3">'recommended-legacy'</span><span class="s2">: legacyRecommendedConfig,</span>
        <span class="s0">/**</span>
         <span class="s0">* 'recommended' is currently aliased to the legacy / rc recommended config) to maintain backwards compatibility.</span>
         <span class="s0">* This is deprecated and in v6, it will switch to alias the flat recommended config.</span>
         <span class="s0">*/</span>
        <span class="s2">recommended: legacyRecommendedConfig,</span>
        <span class="s0">/** Latest recommended config, to be used with flat configurations */</span>
        <span class="s3">'recommended-latest'</span><span class="s2">: {</span>
            <span class="s2">name: </span><span class="s3">'react-hooks/recommended'</span><span class="s2">,</span>
            <span class="s2">plugins: {</span>
                <span class="s2">get </span><span class="s3">'react-hooks'</span><span class="s2">() {</span>
                    <span class="s4">return </span><span class="s2">plugin;</span>
                <span class="s2">},</span>
            <span class="s2">},</span>
            <span class="s2">rules: configRules,</span>
        <span class="s2">},</span>
    <span class="s2">},</span>
<span class="s2">};</span>
<span class="s4">var </span><span class="s2">configs = plugin.configs;</span>
<span class="s4">var </span><span class="s2">meta = plugin.meta;</span>
<span class="s0">// TODO: If the plugin is ever updated to be pure ESM and drops support for rc-based configs, then it should be exporting the plugin as default</span>
<span class="s0">// instead of individual named exports.</span>
<span class="s0">// export default plugin;</span>

<span class="s2">exports.configs = configs;</span>
<span class="s2">exports.meta = meta;</span>
<span class="s2">exports.rules = rules;</span>
</pre>
</body>
</html>