<html>
<head>
<title>hot-reloader-turbopack.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hot-reloader-turbopack.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;createHotReloaderTurbopack&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createHotReloaderTurbopack;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_promises = require(</span><span class="s0">&quot;fs/promises&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_path = require(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_url = require(</span><span class="s0">&quot;url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ws = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/ws&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_store = require(</span><span class="s0">&quot;../../build/output/store&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hotreloadertypes = require(</span><span class="s0">&quot;./hot-reloader-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_swc = require(</span><span class="s0">&quot;../../build/swc&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../../build/output/log&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_hotreloaderwebpack = require(</span><span class="s0">&quot;./hot-reloader-webpack&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_middlewareturbopack = require(</span><span class="s0">&quot;./middleware-turbopack&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../../shared/lib/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;../utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requirecache = require(</span><span class="s0">&quot;./require-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_renderserver = require(</span><span class="s0">&quot;../lib/render-server&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_denormalizepagepath = require(</span><span class="s0">&quot;../../shared/lib/page-path/denormalize-page-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_trace = require(</span><span class="s0">&quot;../../trace&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_turbopackutils = require(</span><span class="s0">&quot;./turbopack-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_setupdevbundler = require(</span><span class="s0">&quot;../lib/router-utils/setup-dev-bundler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_manifestloader = require(</span><span class="s0">&quot;../../shared/lib/turbopack/manifest-loader&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ondemandentryhandler = require(</span><span class="s0">&quot;./on-demand-entry-handler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_entrykey = require(</span><span class="s0">&quot;../../shared/lib/turbopack/entry-key&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_messages = require(</span><span class="s0">&quot;./messages&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_encryptionutilsserver = require(</span><span class="s0">&quot;../app-render/encryption-utils-server&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppageroutedefinition = require(</span><span class="s0">&quot;../route-definitions/app-page-route-definition&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils2 = require(</span><span class="s0">&quot;../lib/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ismetadataroute = require(</span><span class="s0">&quot;../../lib/metadata/is-metadata-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_patcherrorinspect = require(</span><span class="s0">&quot;../patch-error-inspect&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getnexterrorfeedbackmiddleware = require(</span><span class="s0">&quot;../../next-devtools/server/get-next-error-feedback-middleware&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils3 = require(</span><span class="s0">&quot;../../shared/lib/turbopack/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getdevoverlayfontmiddleware = require(</span><span class="s0">&quot;../../next-devtools/server/font/get-dev-overlay-font-middleware&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_devindicatorserverstate = require(</span><span class="s0">&quot;./dev-indicator-server-state&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_devindicatormiddleware = require(</span><span class="s0">&quot;../../next-devtools/server/dev-indicator-middleware&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_restartdevservermiddleware = require(</span><span class="s0">&quot;../../next-devtools/server/restart-dev-server-middleware&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_compilationevents = require(</span><span class="s0">&quot;../../shared/lib/turbopack/compilation-events&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils4 = require(</span><span class="s0">&quot;../../build/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_receivelogs = require(</span><span class="s0">&quot;./browser-logs/receive-logs&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepath = require(</span><span class="s0">&quot;../../lib/normalize-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_devtoolsconfigmiddleware = require(</span><span class="s0">&quot;../../next-devtools/server/devtools-config-middleware&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">wsServer = </span><span class="s2">new </span><span class="s1">_ws.default.Server({</span>
    <span class="s1">noServer: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">isTestMode = !!(process.env.NEXT_TEST_MODE || process.env.__NEXT_TEST_MODE || process.env.DEBUG);</span>
<span class="s2">const </span><span class="s1">sessionId = Math.floor(Number.MAX_SAFE_INTEGER * Math.random());</span>
<span class="s3">/**</span>
 <span class="s3">* Replaces turbopack:///[project] with the specified project in the `source` field.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">rewriteTurbopackSources(projectRoot, sourceMap) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">'sections' </span><span class="s2">in </span><span class="s1">sourceMap) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">section of sourceMap.sections){</span>
            <span class="s1">rewriteTurbopackSources(projectRoot, section.map);</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; sourceMap.sources.length; i++){</span>
            <span class="s1">sourceMap.sources[i] = (</span><span class="s4">0</span><span class="s1">, _url.pathToFileURL)((</span><span class="s4">0</span><span class="s1">, _path.join)(projectRoot, sourceMap.sources[i].replace(</span><span class="s5">/turbopack:\/\/\/\[project\]/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">))).toString();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSourceMapFromTurbopack(project, projectRoot, sourceURL) {</span>
    <span class="s2">let </span><span class="s1">sourceMapJson = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">sourceMapJson = project.getSourceMapSync(sourceURL);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {}</span>
    <span class="s2">if </span><span class="s1">(sourceMapJson === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">payload = JSON.parse(sourceMapJson);</span>
        <span class="s3">// The sourcemap from Turbopack is not yet written to disk so its `sources`</span>
        <span class="s3">// are not absolute paths yet. We need to rewrite them to be absolute paths.</span>
        <span class="s1">rewriteTurbopackSources(projectRoot, payload);</span>
        <span class="s2">return </span><span class="s1">payload;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createHotReloaderTurbopack(opts, serverFields, distDir, resetFetch) {</span>
    <span class="s2">var </span><span class="s1">_opts_nextConfig_turbopack, _nextConfig_watchOptions, _opts_nextConfig_experimental;</span>
    <span class="s2">const </span><span class="s1">dev = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">buildId = </span><span class="s0">'development'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">{ nextConfig, dir: projectPath } = opts;</span>
    <span class="s2">const </span><span class="s1">{ loadBindings } = require(</span><span class="s0">'../../build/swc'</span><span class="s1">);</span>
    <span class="s2">let </span><span class="s1">bindings = </span><span class="s2">await </span><span class="s1">loadBindings();</span>
    <span class="s3">// For the debugging purpose, check if createNext or equivalent next instance setup in test cases</span>
    <span class="s3">// works correctly. Normally `run-test` hides output so only will be visible when `--debug` flag is used.</span>
    <span class="s2">if </span><span class="s1">(isTestMode) {</span>
        <span class="s1">;</span>
        <span class="s1">require(</span><span class="s0">'console'</span><span class="s1">).log(</span><span class="s0">'Creating turbopack project'</span><span class="s1">, {</span>
            <span class="s1">dir: projectPath,</span>
            <span class="s1">testMode: isTestMode</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">hasRewrites = opts.fsChecker.rewrites.afterFiles.length &gt; </span><span class="s4">0 </span><span class="s1">|| opts.fsChecker.rewrites.beforeFiles.length &gt; </span><span class="s4">0 </span><span class="s1">|| opts.fsChecker.rewrites.fallback.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">hotReloaderSpan = (</span><span class="s4">0</span><span class="s1">, _trace.trace)(</span><span class="s0">'hot-reloader'</span><span class="s1">, undefined, {</span>
        <span class="s1">version: </span><span class="s0">&quot;15.5.4&quot;</span>
    <span class="s1">});</span>
    <span class="s3">// Ensure the hotReloaderSpan is flushed immediately as it's the parentSpan for all processing</span>
    <span class="s3">// of the current `next dev` invocation.</span>
    <span class="s1">hotReloaderSpan.stop();</span>
    <span class="s2">const </span><span class="s1">encryptionKey = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _encryptionutilsserver.generateEncryptionKeyBase64)({</span>
        <span class="s1">isBuild: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">distDir</span>
    <span class="s1">});</span>
    <span class="s3">// TODO: Implement</span>
    <span class="s2">let </span><span class="s1">clientRouterFilters;</span>
    <span class="s2">if </span><span class="s1">(nextConfig.experimental.clientRouterFilter) {</span>
    <span class="s3">// TODO this need to be set correctly for persistent caching to work</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">supportedBrowsers = (</span><span class="s4">0</span><span class="s1">, _utils4.getSupportedBrowsers)(projectPath, dev);</span>
    <span class="s2">const </span><span class="s1">currentNodeJsVersion = process.versions.node;</span>
    <span class="s2">const </span><span class="s1">rootPath = ((_opts_nextConfig_turbopack = opts.nextConfig.turbopack) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _opts_nextConfig_turbopack.root) || opts.nextConfig.outputFileTracingRoot || projectPath;</span>
    <span class="s2">const </span><span class="s1">project = </span><span class="s2">await </span><span class="s1">bindings.turbo.createProject({</span>
        <span class="s1">rootPath,</span>
        <span class="s1">projectPath: (</span><span class="s4">0</span><span class="s1">, _normalizepath.normalizePath)((</span><span class="s4">0</span><span class="s1">, _path.relative)(rootPath, projectPath) || </span><span class="s0">'.'</span><span class="s1">),</span>
        <span class="s1">distDir,</span>
        <span class="s1">nextConfig: opts.nextConfig,</span>
        <span class="s1">jsConfig: </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils3.getTurbopackJsConfig)(projectPath, nextConfig),</span>
        <span class="s1">watch: {</span>
            <span class="s1">enable: dev,</span>
            <span class="s1">pollIntervalMs: (_nextConfig_watchOptions = nextConfig.watchOptions) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _nextConfig_watchOptions.pollIntervalMs</span>
        <span class="s1">},</span>
        <span class="s1">dev,</span>
        <span class="s1">env: process.env,</span>
        <span class="s1">defineEnv: (</span><span class="s4">0</span><span class="s1">, _swc.createDefineEnv)({</span>
            <span class="s1">isTurbopack: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">clientRouterFilters,</span>
            <span class="s1">config: nextConfig,</span>
            <span class="s1">dev,</span>
            <span class="s1">distDir,</span>
            <span class="s1">projectPath,</span>
            <span class="s1">fetchCacheKeyPrefix: opts.nextConfig.experimental.fetchCacheKeyPrefix,</span>
            <span class="s1">hasRewrites,</span>
            <span class="s3">// TODO: Implement</span>
            <span class="s1">middlewareMatchers: undefined,</span>
            <span class="s1">rewrites: opts.fsChecker.rewrites</span>
        <span class="s1">}),</span>
        <span class="s1">buildId,</span>
        <span class="s1">encryptionKey,</span>
        <span class="s1">previewProps: opts.fsChecker.prerenderManifest.preview,</span>
        <span class="s1">browserslistQuery: supportedBrowsers.join(</span><span class="s0">', '</span><span class="s1">),</span>
        <span class="s1">noMangling: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">currentNodeJsVersion</span>
    <span class="s1">}, {</span>
        <span class="s1">persistentCaching: (</span><span class="s4">0</span><span class="s1">, _utils3.isPersistentCachingEnabled)(opts.nextConfig),</span>
        <span class="s1">memoryLimit: (_opts_nextConfig_experimental = opts.nextConfig.experimental) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _opts_nextConfig_experimental.turbopackMemoryLimit,</span>
        <span class="s1">isShortSession: </span><span class="s2">false</span>
    <span class="s1">});</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _compilationevents.backgroundLogCompilationEvents)(project, {</span>
        <span class="s1">eventTypes: [</span>
            <span class="s0">'StartupCacheInvalidationEvent'</span><span class="s1">,</span>
            <span class="s0">'TimingEvent'</span>
        <span class="s1">]</span>
    <span class="s1">});</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _patcherrorinspect.setBundlerFindSourceMapImplementation)(getSourceMapFromTurbopack.bind(</span><span class="s2">null</span><span class="s1">, project, projectPath));</span>
    <span class="s1">opts.onDevServerCleanup == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: opts.onDevServerCleanup.call(opts, async ()=&gt;{</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _patcherrorinspect.setBundlerFindSourceMapImplementation)(()=&gt;undefined);</span>
        <span class="s2">await </span><span class="s1">project.onExit();</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">entrypointsSubscription = project.entrypointsSubscribe();</span>
    <span class="s2">const </span><span class="s1">currentWrittenEntrypoints = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">const </span><span class="s1">currentEntrypoints = {</span>
        <span class="s1">global: {</span>
            <span class="s1">app: undefined,</span>
            <span class="s1">document: undefined,</span>
            <span class="s1">error: undefined,</span>
            <span class="s1">middleware: undefined,</span>
            <span class="s1">instrumentation: undefined</span>
        <span class="s1">},</span>
        <span class="s1">page: </span><span class="s2">new </span><span class="s1">Map(),</span>
        <span class="s1">app: </span><span class="s2">new </span><span class="s1">Map()</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">currentTopLevelIssues = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">const </span><span class="s1">currentEntryIssues = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">const </span><span class="s1">manifestLoader = </span><span class="s2">new </span><span class="s1">_manifestloader.TurbopackManifestLoader({</span>
        <span class="s1">buildId,</span>
        <span class="s1">distDir,</span>
        <span class="s1">encryptionKey</span>
    <span class="s1">});</span>
    <span class="s3">// Dev specific</span>
    <span class="s2">const </span><span class="s1">changeSubscriptions = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">const </span><span class="s1">serverPathState = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">const </span><span class="s1">readyIds = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">let </span><span class="s1">currentEntriesHandlingResolve;</span>
    <span class="s2">let </span><span class="s1">currentEntriesHandling = </span><span class="s2">new </span><span class="s1">Promise((resolve)=&gt;currentEntriesHandlingResolve = resolve);</span>
    <span class="s2">const </span><span class="s1">assetMapper = </span><span class="s2">new </span><span class="s1">_turbopackutils.AssetMapper();</span>
    <span class="s2">function </span><span class="s1">clearRequireCache(key, writtenEndpoint, { force } = {}) {</span>
        <span class="s2">if </span><span class="s1">(force) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ path, contentHash } of writtenEndpoint.serverPaths){</span>
                <span class="s1">serverPathState.set(path, contentHash);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s3">// Figure out if the server files have changed</span>
            <span class="s2">let </span><span class="s1">hasChange = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ path, contentHash } of writtenEndpoint.serverPaths){</span>
                <span class="s3">// We ignore source maps</span>
                <span class="s2">if </span><span class="s1">(path.endsWith(</span><span class="s0">'.map'</span><span class="s1">)) </span><span class="s2">continue</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">localKey = </span><span class="s0">`</span><span class="s1">${key}</span><span class="s0">:</span><span class="s1">${path}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">localHash = serverPathState.get(localKey);</span>
                <span class="s2">const </span><span class="s1">globalHash = serverPathState.get(path);</span>
                <span class="s2">if </span><span class="s1">(localHash &amp;&amp; localHash !== contentHash || globalHash &amp;&amp; globalHash !== contentHash) {</span>
                    <span class="s1">hasChange = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">serverPathState.set(key, contentHash);</span>
                    <span class="s1">serverPathState.set(path, contentHash);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(!localHash) {</span>
                        <span class="s1">serverPathState.set(key, contentHash);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!globalHash) {</span>
                        <span class="s1">serverPathState.set(path, contentHash);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!hasChange) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">resetFetch();</span>
        <span class="s3">// Not available in:</span>
        <span class="s3">// - Pages Router (no server-side HMR)</span>
        <span class="s3">// - Edge Runtime (uses browser runtime which already disposes chunks individually)</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">__next__clear_chunk_cache__ === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">__next__clear_chunk_cache__();</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">serverPaths = writtenEndpoint.serverPaths.map(({ path: p })=&gt;(</span><span class="s4">0</span><span class="s1">, _path.join)(distDir, p));</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of serverPaths){</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _renderserver.clearModuleContext)(file);</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _requirecache.deleteCache)(file);</span>
        <span class="s1">}</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">buildingIds = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">const </span><span class="s1">startBuilding = (id, requestUrl, forceRebuild)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(!forceRebuild &amp;&amp; readyIds.has(id)) {</span>
            <span class="s2">return </span><span class="s1">()=&gt;{};</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(buildingIds.size === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">_store.store.setState({</span>
                <span class="s1">loading: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">trigger: id,</span>
                <span class="s1">url: requestUrl</span>
            <span class="s1">}, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">buildingIds.add(id);</span>
        <span class="s2">return function </span><span class="s1">finishBuilding() {</span>
            <span class="s2">if </span><span class="s1">(buildingIds.size === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">readyIds.add(id);</span>
            <span class="s1">buildingIds.delete(id);</span>
            <span class="s2">if </span><span class="s1">(buildingIds.size === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">hmrEventHappened = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">_store.store.setState({</span>
                    <span class="s1">loading: </span><span class="s2">false</span>
                <span class="s1">}, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
    <span class="s1">};</span>
    <span class="s2">let </span><span class="s1">hmrEventHappened = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">hmrHash = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">clients = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">const </span><span class="s1">clientStates = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">function </span><span class="s1">sendToClient(client, payload) {</span>
        <span class="s1">client.send(JSON.stringify(payload));</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">sendEnqueuedMessages() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[, issueMap] of currentEntryIssues){</span>
            <span class="s2">if </span><span class="s1">([</span>
                <span class="s1">...issueMap.values()</span>
            <span class="s1">].filter((i)=&gt;i.severity !== </span><span class="s0">'warning'</span><span class="s1">).length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">// During compilation errors we want to delay the HMR events until errors are fixed</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">client of clients){</span>
            <span class="s2">const </span><span class="s1">state = clientStates.get(client);</span>
            <span class="s2">if </span><span class="s1">(!state) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[, issueMap] of state.clientIssues){</span>
                <span class="s2">if </span><span class="s1">([</span>
                    <span class="s1">...issueMap.values()</span>
                <span class="s1">].filter((i)=&gt;i.severity !== </span><span class="s0">'warning'</span><span class="s1">).length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">// During compilation errors we want to delay the HMR events until errors are fixed</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">payload of state.hmrPayloads.values()){</span>
                <span class="s1">sendToClient(client, payload);</span>
            <span class="s1">}</span>
            <span class="s1">state.hmrPayloads.clear();</span>
            <span class="s2">if </span><span class="s1">(state.turbopackUpdates.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">sendToClient(client, {</span>
                    <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,</span>
                    <span class="s1">data: state.turbopackUpdates</span>
                <span class="s1">});</span>
                <span class="s1">state.turbopackUpdates.length = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">sendEnqueuedMessagesDebounce = (</span><span class="s4">0</span><span class="s1">, _utils1.debounce)(sendEnqueuedMessages, </span><span class="s4">2</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">sendHmr = (id, payload)=&gt;{</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">client of clients){</span>
            <span class="s2">var </span><span class="s1">_clientStates_get;</span>
            <span class="s1">(_clientStates_get = clientStates.get(client)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _clientStates_get.hmrPayloads.set(id, payload);</span>
        <span class="s1">}</span>
        <span class="s1">hmrEventHappened = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">sendEnqueuedMessagesDebounce();</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">sendTurbopackMessage(payload) {</span>
        <span class="s3">// TODO(PACK-2049): For some reason we end up emitting hundreds of issues messages on bigger apps,</span>
        <span class="s3">//   a lot of which are duplicates.</span>
        <span class="s3">//   They are currently not handled on the client at all, so might as well not send them for now.</span>
        <span class="s1">payload.diagnostics = [];</span>
        <span class="s1">payload.issues = [];</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">client of clients){</span>
            <span class="s2">var </span><span class="s1">_clientStates_get;</span>
            <span class="s1">(_clientStates_get = clientStates.get(client)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _clientStates_get.turbopackUpdates.push(payload);</span>
        <span class="s1">}</span>
        <span class="s1">hmrEventHappened = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">sendEnqueuedMessagesDebounce();</span>
    <span class="s1">}</span>
    <span class="s1">async </span><span class="s2">function </span><span class="s1">subscribeToChanges(key, includeIssues, endpoint, makePayload, onError) {</span>
        <span class="s2">if </span><span class="s1">(changeSubscriptions.has(key)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ side } = (</span><span class="s4">0</span><span class="s1">, _entrykey.splitEntryKey)(key);</span>
        <span class="s2">const </span><span class="s1">changedPromise = endpoint[</span><span class="s0">`</span><span class="s1">${side}</span><span class="s0">Changed`</span><span class="s1">](includeIssues);</span>
        <span class="s1">changeSubscriptions.set(key, changedPromise);</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">changed = </span><span class="s2">await </span><span class="s1">changedPromise;</span>
            <span class="s2">for await </span><span class="s1">(</span><span class="s2">const </span><span class="s1">change of changed){</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils3.processIssues)(currentEntryIssues, key, change, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s3">// TODO: Get an actual content hash from Turbopack.</span>
                <span class="s2">const </span><span class="s1">payload = </span><span class="s2">await </span><span class="s1">makePayload(change, String(++hmrHash));</span>
                <span class="s2">if </span><span class="s1">(payload) {</span>
                    <span class="s1">sendHmr(key, payload);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
            <span class="s1">changeSubscriptions.delete(key);</span>
            <span class="s2">const </span><span class="s1">payload = </span><span class="s2">await </span><span class="s1">(onError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: onError(e));</span>
            <span class="s2">if </span><span class="s1">(payload) {</span>
                <span class="s1">sendHmr(key, payload);</span>
            <span class="s1">}</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">changeSubscriptions.delete(key);</span>
    <span class="s1">}</span>
    <span class="s1">async </span><span class="s2">function </span><span class="s1">unsubscribeFromChanges(key) {</span>
        <span class="s2">const </span><span class="s1">subscription = </span><span class="s2">await </span><span class="s1">changeSubscriptions.get(key);</span>
        <span class="s2">if </span><span class="s1">(subscription) {</span>
            <span class="s2">await </span><span class="s1">(subscription.return == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: subscription.return.call(subscription));</span>
            <span class="s1">changeSubscriptions.delete(key);</span>
        <span class="s1">}</span>
        <span class="s1">currentEntryIssues.delete(key);</span>
    <span class="s1">}</span>
    <span class="s1">async </span><span class="s2">function </span><span class="s1">subscribeToHmrEvents(client, id) {</span>
        <span class="s2">const </span><span class="s1">key = (</span><span class="s4">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'assets'</span><span class="s1">, </span><span class="s0">'client'</span><span class="s1">, id);</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">, _turbopackutils.hasEntrypointForKey)(currentEntrypoints, key, assetMapper)) {</span>
            <span class="s3">// maybe throw an error / force the client to reload?</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">state = clientStates.get(client);</span>
        <span class="s2">if </span><span class="s1">(!state || state.subscriptions.has(id)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">subscription = project.hmrEvents(id);</span>
        <span class="s1">state.subscriptions.set(id, subscription);</span>
        <span class="s3">// The subscription will always emit once, which is the initial</span>
        <span class="s3">// computation. This is not a change, so swallow it.</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">await </span><span class="s1">subscription.next();</span>
            <span class="s2">for await </span><span class="s1">(</span><span class="s2">const </span><span class="s1">data of subscription){</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils3.processIssues)(state.clientIssues, key, data, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(data.type !== </span><span class="s0">'issues'</span><span class="s1">) {</span>
                    <span class="s1">sendTurbopackMessage(data);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
            <span class="s3">// The client might be using an HMR session from a previous server, tell them</span>
            <span class="s3">// to fully reload the page to resolve the issue. We can't use</span>
            <span class="s3">// `hotReloader.send` since that would force every connected client to</span>
            <span class="s3">// reload, only this client is out of date.</span>
            <span class="s2">const </span><span class="s1">reloadAction = {</span>
                <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                <span class="s1">data: </span><span class="s0">`error in HMR event subscription for </span><span class="s1">${id}</span><span class="s0">: </span><span class="s1">${e}</span><span class="s0">`</span>
            <span class="s1">};</span>
            <span class="s1">sendToClient(client, reloadAction);</span>
            <span class="s1">client.close();</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">unsubscribeFromHmrEvents(client, id) {</span>
        <span class="s2">const </span><span class="s1">state = clientStates.get(client);</span>
        <span class="s2">if </span><span class="s1">(!state) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">subscription = state.subscriptions.get(id);</span>
        <span class="s1">subscription == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: subscription.return();</span>
        <span class="s2">const </span><span class="s1">key = (</span><span class="s4">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'assets'</span><span class="s1">, </span><span class="s0">'client'</span><span class="s1">, id);</span>
        <span class="s1">state.clientIssues.delete(key);</span>
    <span class="s1">}</span>
    <span class="s1">async </span><span class="s2">function </span><span class="s1">handleEntrypointsSubscription() {</span>
        <span class="s2">for await </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entrypoints of entrypointsSubscription){</span>
            <span class="s2">if </span><span class="s1">(!currentEntriesHandlingResolve) {</span>
                <span class="s1">currentEntriesHandling = </span><span class="s2">new </span><span class="s1">Promise(</span><span class="s3">// eslint-disable-next-line no-loop-func</span>
                <span class="s1">(resolve)=&gt;currentEntriesHandlingResolve = resolve);</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _turbopackutils.processTopLevelIssues)(currentTopLevelIssues, entrypoints);</span>
            <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _turbopackutils.handleEntrypoints)({</span>
                <span class="s1">entrypoints,</span>
                <span class="s1">currentEntrypoints,</span>
                <span class="s1">currentEntryIssues,</span>
                <span class="s1">manifestLoader,</span>
                <span class="s1">devRewrites: opts.fsChecker.rewrites,</span>
                <span class="s1">productionRewrites: undefined,</span>
                <span class="s1">logErrors: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">dev: {</span>
                    <span class="s1">assetMapper,</span>
                    <span class="s1">changeSubscriptions,</span>
                    <span class="s1">clients,</span>
                    <span class="s1">clientStates,</span>
                    <span class="s1">serverFields,</span>
                    <span class="s1">hooks: {</span>
                        <span class="s1">handleWrittenEndpoint: (id, result, forceDeleteCache)=&gt;{</span>
                            <span class="s1">currentWrittenEntrypoints.set(id, result);</span>
                            <span class="s2">return </span><span class="s1">clearRequireCache(id, result, {</span>
                                <span class="s1">force: forceDeleteCache</span>
                            <span class="s1">});</span>
                        <span class="s1">},</span>
                        <span class="s1">propagateServerField: _setupdevbundler.propagateServerField.bind(</span><span class="s2">null</span><span class="s1">, opts),</span>
                        <span class="s1">sendHmr,</span>
                        <span class="s1">startBuilding,</span>
                        <span class="s1">subscribeToChanges,</span>
                        <span class="s1">unsubscribeFromChanges,</span>
                        <span class="s1">unsubscribeFromHmrEvents</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s1">currentEntriesHandlingResolve();</span>
            <span class="s1">currentEntriesHandlingResolve = undefined;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _promises.mkdir)((</span><span class="s4">0</span><span class="s1">, _path.join)(distDir, </span><span class="s0">'server'</span><span class="s1">), {</span>
        <span class="s1">recursive: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _promises.mkdir)((</span><span class="s4">0</span><span class="s1">, _path.join)(distDir, </span><span class="s0">'static'</span><span class="s1">, buildId), {</span>
        <span class="s1">recursive: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _promises.writeFile)((</span><span class="s4">0</span><span class="s1">, _path.join)(distDir, </span><span class="s0">'package.json'</span><span class="s1">), JSON.stringify({</span>
        <span class="s1">type: </span><span class="s0">'commonjs'</span>
    <span class="s1">}, </span><span class="s2">null</span><span class="s1">, </span><span class="s4">2</span><span class="s1">));</span>
    <span class="s2">const </span><span class="s1">middlewares = [</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _middlewareturbopack.getOverlayMiddleware)({</span>
            <span class="s1">project,</span>
            <span class="s1">projectPath,</span>
            <span class="s1">isSrcDir: opts.isSrcDir</span>
        <span class="s1">}),</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _middlewareturbopack.getSourceMapMiddleware)(project),</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _getnexterrorfeedbackmiddleware.getNextErrorFeedbackMiddleware)(opts.telemetry),</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _getdevoverlayfontmiddleware.getDevOverlayFontMiddleware)(),</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _devindicatormiddleware.getDisableDevIndicatorMiddleware)(),</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _restartdevservermiddleware.getRestartDevServerMiddleware)({</span>
            <span class="s1">telemetry: opts.telemetry,</span>
            <span class="s1">turbopackProject: project</span>
        <span class="s1">}),</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _devtoolsconfigmiddleware.devToolsConfigMiddleware)({</span>
            <span class="s1">distDir,</span>
            <span class="s1">sendUpdateSignal: (data)=&gt;{</span>
                <span class="s1">hotReloader.send({</span>
                    <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEVTOOLS_CONFIG,</span>
                    <span class="s1">data</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">})</span>
    <span class="s1">];</span>
    <span class="s2">const </span><span class="s1">versionInfoPromise = (</span><span class="s4">0</span><span class="s1">, _hotreloaderwebpack.getVersionInfo)();</span>
    <span class="s2">let </span><span class="s1">devtoolsFrontendUrl;</span>
    <span class="s2">const </span><span class="s1">nodeDebugType = (</span><span class="s4">0</span><span class="s1">, _utils2.getNodeDebugType)();</span>
    <span class="s2">if </span><span class="s1">(nodeDebugType) {</span>
        <span class="s2">const </span><span class="s1">debugPort = process.debugPort;</span>
        <span class="s2">let </span><span class="s1">debugInfo;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s3">// It requires to use 127.0.0.1 instead of localhost for server-side fetching.</span>
            <span class="s2">const </span><span class="s1">debugInfoList = </span><span class="s2">await </span><span class="s1">fetch(</span><span class="s0">`http://127.0.0.1:</span><span class="s1">${debugPort}</span><span class="s0">/json/list`</span><span class="s1">).then((res)=&gt;res.json());</span>
            <span class="s1">debugInfo = debugInfoList[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{}</span>
        <span class="s2">if </span><span class="s1">(debugInfo) {</span>
            <span class="s1">devtoolsFrontendUrl = debugInfo.devtoolsFrontendUrl;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">hotReloader = {</span>
        <span class="s1">turbopackProject: project,</span>
        <span class="s1">activeWebpackConfigs: undefined,</span>
        <span class="s1">serverStats: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">edgeServerStats: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">async run (req, res, _parsedUrl) {</span>
            <span class="s2">var </span><span class="s1">_req_url;</span>
            <span class="s3">// intercept page chunks request and ensure them with turbopack</span>
            <span class="s2">if </span><span class="s1">((_req_url = req.url) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _req_url.startsWith(</span><span class="s0">'/_next/static/chunks/pages/'</span><span class="s1">)) {</span>
                <span class="s2">const </span><span class="s1">params = (</span><span class="s4">0</span><span class="s1">, _hotreloaderwebpack.matchNextPageBundleRequest)(req.url);</span>
                <span class="s2">if </span><span class="s1">(params) {</span>
                    <span class="s2">const </span><span class="s1">decodedPagePath = </span><span class="s0">`/</span><span class="s1">${params.path.map((param)=&gt;decodeURIComponent(param)).join(</span><span class="s0">'/'</span><span class="s1">)}</span><span class="s0">`</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">denormalizedPagePath = (</span><span class="s4">0</span><span class="s1">, _denormalizepagepath.denormalizePagePath)(decodedPagePath);</span>
                    <span class="s2">await </span><span class="s1">hotReloader.ensurePage({</span>
                        <span class="s1">page: denormalizedPagePath,</span>
                        <span class="s1">clientOnly: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">definition: undefined,</span>
                        <span class="s1">url: req.url</span>
                    <span class="s1">}).catch(console.error);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">middleware of middlewares){</span>
                <span class="s2">let </span><span class="s1">calledNext = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">await </span><span class="s1">middleware(req, res, ()=&gt;{</span>
                    <span class="s1">calledNext = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(!calledNext) {</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s1">finished: </span><span class="s2">true</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">// Request was not finished.</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">finished: undefined</span>
            <span class="s1">};</span>
        <span class="s1">},</span>
        <span class="s3">// TODO: Figure out if socket type can match the NextJsHotReloaderInterface</span>
        <span class="s1">onHMR (req, socket, head, onUpgrade) {</span>
            <span class="s1">wsServer.handleUpgrade(req, socket, head, (client)=&gt;{</span>
                <span class="s1">onUpgrade(client);</span>
                <span class="s2">const </span><span class="s1">clientIssues = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s2">const </span><span class="s1">subscriptions = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s1">clients.add(client);</span>
                <span class="s1">clientStates.set(client, {</span>
                    <span class="s1">clientIssues,</span>
                    <span class="s1">hmrPayloads: </span><span class="s2">new </span><span class="s1">Map(),</span>
                    <span class="s1">turbopackUpdates: [],</span>
                    <span class="s1">subscriptions</span>
                <span class="s1">});</span>
                <span class="s1">client.on(</span><span class="s0">'close'</span><span class="s1">, ()=&gt;{</span>
                    <span class="s3">// Remove active subscriptions</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">subscription of subscriptions.values()){</span>
                        <span class="s1">subscription.return == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: subscription.return.call(subscription);</span>
                    <span class="s1">}</span>
                    <span class="s1">clientStates.delete(client);</span>
                    <span class="s1">clients.delete(client);</span>
                <span class="s1">});</span>
                <span class="s1">client.addEventListener(</span><span class="s0">'message'</span><span class="s1">, async ({ data })=&gt;{</span>
                    <span class="s2">const </span><span class="s1">parsedData = JSON.parse(</span><span class="s2">typeof </span><span class="s1">data !== </span><span class="s0">'string' </span><span class="s1">? data.toString() : data);</span>
                    <span class="s3">// Next.js messages</span>
                    <span class="s2">switch</span><span class="s1">(parsedData.event){</span>
                        <span class="s2">case </span><span class="s0">'span-end'</span><span class="s1">:</span>
                            <span class="s1">{</span>
                                <span class="s1">hotReloaderSpan.manualTraceChild(parsedData.spanName, (</span><span class="s4">0</span><span class="s1">, _turbopackutils.msToNs)(parsedData.startTime), (</span><span class="s4">0</span><span class="s1">, _turbopackutils.msToNs)(parsedData.endTime), parsedData.attributes);</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s2">case </span><span class="s0">'client-hmr-latency'</span><span class="s1">:</span>
                            <span class="s1">hotReloaderSpan.manualTraceChild(parsedData.event, (</span><span class="s4">0</span><span class="s1">, _turbopackutils.msToNs)(parsedData.startTime), (</span><span class="s4">0</span><span class="s1">, _turbopackutils.msToNs)(parsedData.endTime), {</span>
                                <span class="s1">updatedModules: parsedData.updatedModules,</span>
                                <span class="s1">page: parsedData.page,</span>
                                <span class="s1">isPageHidden: parsedData.isPageHidden</span>
                            <span class="s1">});</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">case </span><span class="s0">'client-error'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'client-warning'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'client-success'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'server-component-reload-page'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'client-reload-page'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'client-removed-page'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'client-full-reload'</span><span class="s1">:</span>
                            <span class="s2">const </span><span class="s1">{ hadRuntimeError, dependencyChain } = parsedData;</span>
                            <span class="s2">if </span><span class="s1">(hadRuntimeError) {</span>
                                <span class="s1">_log.warn(_messages.FAST_REFRESH_RUNTIME_RELOAD);</span>
                            <span class="s1">}</span>
                            <span class="s2">if </span><span class="s1">(Array.isArray(dependencyChain) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">dependencyChain[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'string'</span><span class="s1">) {</span>
                                <span class="s2">const </span><span class="s1">cleanedModulePath = dependencyChain[</span><span class="s4">0</span><span class="s1">].replace(</span><span class="s5">/^\[project\]/</span><span class="s1">, </span><span class="s0">'.'</span><span class="s1">).replace(</span><span class="s5">/ \[.*\] \(.*\)$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
                                <span class="s1">_log.warn(</span><span class="s0">`Fast Refresh had to perform a full reload when </span><span class="s1">${cleanedModulePath} </span><span class="s0">changed. Read more: https://nextjs.org/docs/messages/fast-refresh-reload`</span><span class="s1">);</span>
                            <span class="s1">}</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">case </span><span class="s0">'client-added-page'</span><span class="s1">:</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">case </span><span class="s0">'browser-logs'</span><span class="s1">:</span>
                            <span class="s1">{</span>
                                <span class="s2">if </span><span class="s1">(nextConfig.experimental.browserDebugInfoInTerminal) {</span>
                                    <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _receivelogs.receiveBrowserLogsTurbopack)({</span>
                                        <span class="s1">entries: parsedData.entries,</span>
                                        <span class="s1">router: parsedData.router,</span>
                                        <span class="s1">sourceType: parsedData.sourceType,</span>
                                        <span class="s1">project,</span>
                                        <span class="s1">projectPath,</span>
                                        <span class="s1">distDir,</span>
                                        <span class="s1">config: nextConfig.experimental.browserDebugInfoInTerminal</span>
                                    <span class="s1">});</span>
                                <span class="s1">}</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s2">default</span><span class="s1">:</span>
                            <span class="s3">// Might be a Turbopack message...</span>
                            <span class="s2">if </span><span class="s1">(!parsedData.type) {</span>
                                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`unrecognized HMR message &quot;</span><span class="s1">${data}</span><span class="s0">&quot;`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                                    <span class="s1">value: </span><span class="s0">&quot;E155&quot;</span><span class="s1">,</span>
                                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                                    <span class="s1">configurable: </span><span class="s2">true</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s3">// Turbopack messages</span>
                    <span class="s2">switch</span><span class="s1">(parsedData.type){</span>
                        <span class="s2">case </span><span class="s0">'turbopack-subscribe'</span><span class="s1">:</span>
                            <span class="s1">subscribeToHmrEvents(client, parsedData.path);</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">case </span><span class="s0">'turbopack-unsubscribe'</span><span class="s1">:</span>
                            <span class="s1">unsubscribeFromHmrEvents(client, parsedData.path);</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">default</span><span class="s1">:</span>
                            <span class="s2">if </span><span class="s1">(!parsedData.event) {</span>
                                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`unrecognized Turbopack HMR message &quot;</span><span class="s1">${data}</span><span class="s0">&quot;`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                                    <span class="s1">value: </span><span class="s0">&quot;E492&quot;</span><span class="s1">,</span>
                                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                                    <span class="s1">configurable: </span><span class="s2">true</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">turbopackConnected = {</span>
                    <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,</span>
                    <span class="s1">data: {</span>
                        <span class="s1">sessionId</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>
                <span class="s1">sendToClient(client, turbopackConnected);</span>
                <span class="s2">const </span><span class="s1">errors = [];</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIssues of currentEntryIssues.values()){</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">issue of entryIssues.values()){</span>
                        <span class="s2">if </span><span class="s1">(issue.severity !== </span><span class="s0">'warning'</span><span class="s1">) {</span>
                            <span class="s1">errors.push({</span>
                                <span class="s1">message: (</span><span class="s4">0</span><span class="s1">, _utils3.formatIssue)(issue)</span>
                            <span class="s1">});</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _turbopackutils.printNonFatalIssue)(issue);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(_devindicatorserverstate.devIndicatorServerState.disabledUntil &lt; Date.now()) {</span>
                    <span class="s1">_devindicatorserverstate.devIndicatorServerState.disabledUntil = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">;</span>
                <span class="s1">(async </span><span class="s2">function</span><span class="s1">() {</span>
                    <span class="s2">const </span><span class="s1">versionInfo = </span><span class="s2">await </span><span class="s1">versionInfoPromise;</span>
                    <span class="s2">const </span><span class="s1">devToolsConfig = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _devtoolsconfigmiddleware.getDevToolsConfig)(distDir);</span>
                    <span class="s2">const </span><span class="s1">sync = {</span>
                        <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC,</span>
                        <span class="s1">errors,</span>
                        <span class="s1">warnings: [],</span>
                        <span class="s1">hash: </span><span class="s0">''</span><span class="s1">,</span>
                        <span class="s1">versionInfo,</span>
                        <span class="s1">debug: {</span>
                            <span class="s1">devtoolsFrontendUrl</span>
                        <span class="s1">},</span>
                        <span class="s1">devIndicator: _devindicatorserverstate.devIndicatorServerState,</span>
                        <span class="s1">devToolsConfig</span>
                    <span class="s1">};</span>
                    <span class="s1">sendToClient(client, sync);</span>
                <span class="s1">})();</span>
            <span class="s1">});</span>
        <span class="s1">},</span>
        <span class="s1">send (action) {</span>
            <span class="s2">const </span><span class="s1">payload = JSON.stringify(action);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">client of clients){</span>
                <span class="s1">client.send(payload);</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">setHmrServerError (_error) {</span>
        <span class="s3">// Not implemented yet.</span>
        <span class="s1">},</span>
        <span class="s1">clearHmrServerError () {</span>
        <span class="s3">// Not implemented yet.</span>
        <span class="s1">},</span>
        <span class="s1">async start () {},</span>
        <span class="s1">async getCompilationErrors (page) {</span>
            <span class="s2">const </span><span class="s1">appEntryKey = (</span><span class="s4">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'app'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, page);</span>
            <span class="s2">const </span><span class="s1">pagesEntryKey = (</span><span class="s4">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, page);</span>
            <span class="s2">const </span><span class="s1">topLevelIssues = currentTopLevelIssues.values();</span>
            <span class="s2">const </span><span class="s1">thisEntryIssues = currentEntryIssues.get(appEntryKey) ?? currentEntryIssues.get(pagesEntryKey);</span>
            <span class="s2">if </span><span class="s1">(thisEntryIssues !== undefined &amp;&amp; thisEntryIssues.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">// If there is an error related to the requesting page we display it instead of the first error</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s1">...topLevelIssues,</span>
                    <span class="s1">...thisEntryIssues.values()</span>
                <span class="s1">].map((issue)=&gt;{</span>
                    <span class="s2">const </span><span class="s1">formattedIssue = (</span><span class="s4">0</span><span class="s1">, _utils3.formatIssue)(issue);</span>
                    <span class="s2">if </span><span class="s1">(issue.severity === </span><span class="s0">'warning'</span><span class="s1">) {</span>
                        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _turbopackutils.printNonFatalIssue)(issue);</span>
                        <span class="s2">return null</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _utils3.isWellKnownError)(issue)) {</span>
                        <span class="s1">_log.error(formattedIssue);</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(formattedIssue), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}).filter((error)=&gt;error !== </span><span class="s2">null</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">// Otherwise, return all errors across pages</span>
            <span class="s2">const </span><span class="s1">errors = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">issue of topLevelIssues){</span>
                <span class="s2">if </span><span class="s1">(issue.severity !== </span><span class="s0">'warning'</span><span class="s1">) {</span>
                    <span class="s1">errors.push(Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error((</span><span class="s4">0</span><span class="s1">, _utils3.formatIssue)(issue)), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">}));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIssues of currentEntryIssues.values()){</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">issue of entryIssues.values()){</span>
                    <span class="s2">if </span><span class="s1">(issue.severity !== </span><span class="s0">'warning'</span><span class="s1">) {</span>
                        <span class="s2">const </span><span class="s1">message = (</span><span class="s4">0</span><span class="s1">, _utils3.formatIssue)(issue);</span>
                        <span class="s1">errors.push(Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(message), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">}));</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _turbopackutils.printNonFatalIssue)(issue);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">errors;</span>
        <span class="s1">},</span>
        <span class="s1">async invalidate ({ </span><span class="s3">// .env files or tsconfig/jsconfig change</span>
        <span class="s1">reloadAfterInvalidation }) {</span>
            <span class="s2">if </span><span class="s1">(reloadAfterInvalidation) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, entrypoint] of currentWrittenEntrypoints){</span>
                    <span class="s1">clearRequireCache(key, entrypoint, {</span>
                        <span class="s1">force: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _renderserver.clearAllModuleContexts)();</span>
                <span class="s2">this</span><span class="s1">.send({</span>
                    <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES,</span>
                    <span class="s1">hash: String(++hmrHash)</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">async buildFallbackError () {</span>
        <span class="s3">// Not implemented yet.</span>
        <span class="s1">},</span>
        <span class="s1">async ensurePage ({ page: inputPage, </span><span class="s3">// Unused parameters</span>
        <span class="s3">// clientOnly,</span>
        <span class="s1">appPaths, definition, isApp, url: requestUrl }) {</span>
            <span class="s3">// When there is no route definition this is an internal file not a route the user added.</span>
            <span class="s3">// Middleware and instrumentation are handled in turbpack-utils.ts handleEntrypoints instead.</span>
            <span class="s2">if </span><span class="s1">(!definition) {</span>
                <span class="s2">if </span><span class="s1">(inputPage === </span><span class="s0">'/middleware'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(inputPage === </span><span class="s0">'/src/middleware'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(inputPage === </span><span class="s0">'/instrumentation'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(inputPage === </span><span class="s0">'/src/instrumentation'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">hotReloaderSpan.traceChild(</span><span class="s0">'ensure-page'</span><span class="s1">, {</span>
                <span class="s1">inputPage</span>
            <span class="s1">}).traceAsyncFn(async ()=&gt;{</span>
                <span class="s2">if </span><span class="s1">(_constants.BLOCKED_PAGES.includes(inputPage) &amp;&amp; inputPage !== </span><span class="s0">'/_error'</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">await </span><span class="s1">currentEntriesHandling;</span>
                <span class="s3">// TODO We shouldn't look into the filesystem again. This should use the information from entrypoints</span>
                <span class="s2">let </span><span class="s1">routeDef = definition ?? </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _ondemandentryhandler.findPagePathData)(projectPath, inputPage, nextConfig.pageExtensions, opts.pagesDir, opts.appDir, !!nextConfig.experimental.globalNotFound);</span>
                <span class="s3">// If the route is actually an app page route, then we should have access</span>
                <span class="s3">// to the app route definition, and therefore, the appPaths from it.</span>
                <span class="s2">if </span><span class="s1">(!appPaths &amp;&amp; definition &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _apppageroutedefinition.isAppPageRouteDefinition)(definition)) {</span>
                    <span class="s1">appPaths = definition.appPaths;</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">page = routeDef.page;</span>
                <span class="s2">if </span><span class="s1">(appPaths) {</span>
                    <span class="s2">const </span><span class="s1">normalizedPage = (</span><span class="s4">0</span><span class="s1">, _apppaths.normalizeAppPath)(page);</span>
                    <span class="s3">// filter out paths that are not exact matches (e.g. catchall)</span>
                    <span class="s2">const </span><span class="s1">matchingAppPaths = appPaths.filter((path)=&gt;(</span><span class="s4">0</span><span class="s1">, _apppaths.normalizeAppPath)(path) === normalizedPage);</span>
                    <span class="s3">// the last item in the array is the root page, if there are parallel routes</span>
                    <span class="s1">page = matchingAppPaths[matchingAppPaths.length - </span><span class="s4">1</span><span class="s1">];</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">pathname = (definition == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: definition.pathname) ?? inputPage;</span>
                <span class="s2">if </span><span class="s1">(page === </span><span class="s0">'/_error'</span><span class="s1">) {</span>
                    <span class="s2">let </span><span class="s1">finishBuilding = startBuilding(pathname, requestUrl, </span><span class="s2">false</span><span class="s1">);</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _turbopackutils.handlePagesErrorRoute)({</span>
                            <span class="s1">currentEntryIssues,</span>
                            <span class="s1">entrypoints: currentEntrypoints,</span>
                            <span class="s1">manifestLoader,</span>
                            <span class="s1">devRewrites: opts.fsChecker.rewrites,</span>
                            <span class="s1">productionRewrites: undefined,</span>
                            <span class="s1">logErrors: </span><span class="s2">true</span><span class="s1">,</span>
                            <span class="s1">hooks: {</span>
                                <span class="s1">subscribeToChanges,</span>
                                <span class="s1">handleWrittenEndpoint: (id, result, forceDeleteCache)=&gt;{</span>
                                    <span class="s1">currentWrittenEntrypoints.set(id, result);</span>
                                    <span class="s1">assetMapper.setPathsForKey(id, result.clientPaths);</span>
                                    <span class="s2">return </span><span class="s1">clearRequireCache(id, result, {</span>
                                        <span class="s1">force: forceDeleteCache</span>
                                    <span class="s1">});</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                        <span class="s1">finishBuilding();</span>
                    <span class="s1">}</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">isInsideAppDir = routeDef.bundlePath.startsWith(</span><span class="s0">'app/'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">isEntryMetadataRouteFile = (</span><span class="s4">0</span><span class="s1">, _ismetadataroute.isMetadataRouteFile)(routeDef.filename.replace(opts.appDir || </span><span class="s0">''</span><span class="s1">, </span><span class="s0">''</span><span class="s1">), nextConfig.pageExtensions, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">normalizedAppPage = isEntryMetadataRouteFile ? (</span><span class="s4">0</span><span class="s1">, _turbopackutils.normalizedPageToTurbopackStructureRoute)(page, (</span><span class="s4">0</span><span class="s1">, _path.extname)(routeDef.filename)) : page;</span>
                <span class="s2">const </span><span class="s1">route = isInsideAppDir ? currentEntrypoints.app.get(normalizedAppPage) : currentEntrypoints.page.get(page);</span>
                <span class="s2">if </span><span class="s1">(!route) {</span>
                    <span class="s3">// TODO: why is this entry missing in turbopack?</span>
                    <span class="s2">if </span><span class="s1">(page === </span><span class="s0">'/middleware'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(page === </span><span class="s0">'/src/middleware'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(page === </span><span class="s0">'/instrumentation'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(page === </span><span class="s0">'/src/instrumentation'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
                    <span class="s2">throw new </span><span class="s1">_utils.PageNotFoundError(</span><span class="s0">`route not found </span><span class="s1">${page}</span><span class="s0">`</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s3">// We don't throw on ensureOpts.isApp === true for page-api</span>
                <span class="s3">// since this can happen when app pages make</span>
                <span class="s3">// api requests to page API routes.</span>
                <span class="s2">if </span><span class="s1">(isApp &amp;&amp; route.type === </span><span class="s0">'page'</span><span class="s1">) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`mis-matched route type: isApp &amp;&amp; page for </span><span class="s1">${page}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E373&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">finishBuilding = startBuilding(pathname, requestUrl, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _turbopackutils.handleRouteType)({</span>
                        <span class="s1">dev,</span>
                        <span class="s1">page,</span>
                        <span class="s1">pathname,</span>
                        <span class="s1">route,</span>
                        <span class="s1">currentEntryIssues,</span>
                        <span class="s1">entrypoints: currentEntrypoints,</span>
                        <span class="s1">manifestLoader,</span>
                        <span class="s1">readyIds,</span>
                        <span class="s1">devRewrites: opts.fsChecker.rewrites,</span>
                        <span class="s1">productionRewrites: undefined,</span>
                        <span class="s1">logErrors: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">hooks: {</span>
                            <span class="s1">subscribeToChanges,</span>
                            <span class="s1">handleWrittenEndpoint: (id, result, forceDeleteCache)=&gt;{</span>
                                <span class="s1">currentWrittenEntrypoints.set(id, result);</span>
                                <span class="s1">assetMapper.setPathsForKey(id, result.clientPaths);</span>
                                <span class="s2">return </span><span class="s1">clearRequireCache(id, result, {</span>
                                    <span class="s1">force: forceDeleteCache</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                    <span class="s1">finishBuilding();</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">},</span>
        <span class="s1">close () {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">wsClient of clients){</span>
                <span class="s3">// it's okay to not cleanly close these websocket connections, this is dev</span>
                <span class="s1">wsClient.terminate();</span>
            <span class="s1">}</span>
            <span class="s1">clients.clear();</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">handleEntrypointsSubscription().catch((err)=&gt;{</span>
        <span class="s1">console.error(err);</span>
        <span class="s1">process.exit(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s3">// Write empty manifests</span>
    <span class="s2">await </span><span class="s1">currentEntriesHandling;</span>
    <span class="s2">await </span><span class="s1">manifestLoader.writeManifests({</span>
        <span class="s1">devRewrites: opts.fsChecker.rewrites,</span>
        <span class="s1">productionRewrites: undefined,</span>
        <span class="s1">entrypoints: currentEntrypoints</span>
    <span class="s1">});</span>
    <span class="s1">async </span><span class="s2">function </span><span class="s1">handleProjectUpdates() {</span>
        <span class="s2">for await </span><span class="s1">(</span><span class="s2">const </span><span class="s1">updateMessage of project.updateInfoSubscribe(</span><span class="s4">30</span><span class="s1">)){</span>
            <span class="s2">switch</span><span class="s1">(updateMessage.updateType){</span>
                <span class="s2">case </span><span class="s0">'start'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s1">hotReloader.send({</span>
                            <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING</span>
                        <span class="s1">});</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s2">case </span><span class="s0">'end'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s1">sendEnqueuedMessages();</span>
                        <span class="s2">function </span><span class="s1">addErrors(errorsMap, issues) {</span>
                            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">issueMap of issues.values()){</span>
                                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, issue] of issueMap){</span>
                                    <span class="s2">if </span><span class="s1">(issue.severity === </span><span class="s0">'warning'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
                                    <span class="s2">if </span><span class="s1">(errorsMap.has(key)) </span><span class="s2">continue</span><span class="s1">;</span>
                                    <span class="s2">const </span><span class="s1">message = (</span><span class="s4">0</span><span class="s1">, _utils3.formatIssue)(issue);</span>
                                    <span class="s1">errorsMap.set(key, {</span>
                                        <span class="s1">message,</span>
                                        <span class="s1">details: issue.detail ? (</span><span class="s4">0</span><span class="s1">, _utils3.renderStyledStringToErrorAnsi)(issue.detail) : undefined</span>
                                    <span class="s1">});</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">const </span><span class="s1">errors = </span><span class="s2">new </span><span class="s1">Map();</span>
                        <span class="s1">addErrors(errors, currentEntryIssues);</span>
                        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">client of clients){</span>
                            <span class="s2">const </span><span class="s1">state = clientStates.get(client);</span>
                            <span class="s2">if </span><span class="s1">(!state) {</span>
                                <span class="s2">continue</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s2">const </span><span class="s1">clientErrors = </span><span class="s2">new </span><span class="s1">Map(errors);</span>
                            <span class="s1">addErrors(clientErrors, state.clientIssues);</span>
                            <span class="s1">sendToClient(client, {</span>
                                <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT,</span>
                                <span class="s1">hash: String(++hmrHash),</span>
                                <span class="s1">errors: [</span>
                                    <span class="s1">...clientErrors.values()</span>
                                <span class="s1">],</span>
                                <span class="s1">warnings: []</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(hmrEventHappened) {</span>
                            <span class="s2">const </span><span class="s1">time = updateMessage.value.duration;</span>
                            <span class="s2">const </span><span class="s1">timeMessage = time &gt; </span><span class="s4">2000 </span><span class="s1">? </span><span class="s0">`</span><span class="s1">${Math.round(time / </span><span class="s4">100</span><span class="s1">) / </span><span class="s4">10</span><span class="s1">}</span><span class="s0">s` </span><span class="s1">: </span><span class="s0">`</span><span class="s1">${time}</span><span class="s0">ms`</span><span class="s1">;</span>
                            <span class="s1">_log.event(</span><span class="s0">`Compiled in </span><span class="s1">${timeMessage}</span><span class="s0">`</span><span class="s1">);</span>
                            <span class="s1">hmrEventHappened = </span><span class="s2">false</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">handleProjectUpdates().catch((err)=&gt;{</span>
        <span class="s1">console.error(err);</span>
        <span class="s1">process.exit(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">hotReloader;</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=hot-reloader-turbopack.js.map</span></pre>
</body>
</html>