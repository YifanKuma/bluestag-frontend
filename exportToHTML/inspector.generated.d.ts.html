<html>
<head>
<title>inspector.generated.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
inspector.generated.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">// These definitions are automatically generated by the generate-inspector script.</span>
<span class="s0">// Do not edit this file directly.</span>
<span class="s0">// See scripts/generate-inspector/README.md for information on how to update the protocol definitions.</span>
<span class="s0">// Changes to the module itself should be added to the generator template (scripts/generate-inspector/inspector.d.ts.template).</span>

<span class="s0">/**</span>
 <span class="s0">* The `node:inspector` module provides an API for interacting with the V8</span>
 <span class="s0">* inspector.</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">[source](https://github.com/nodejs/node/blob/v20.x/lib/inspector.js)</span>
 <span class="s0">*/</span>
<span class="s1">declare module </span><span class="s3">'inspector' </span><span class="s1">{</span>
    <span class="s4">import </span><span class="s1">EventEmitter = require(</span><span class="s3">'node:events'</span><span class="s1">);</span>

    <span class="s4">interface </span><span class="s1">InspectorNotification&lt;T&gt; {</span>
        <span class="s1">method: string;</span>
        <span class="s1">params: T;</span>
    <span class="s1">}</span>

    <span class="s1">namespace Schema {</span>
        <span class="s0">/**</span>
         <span class="s0">* Description of the protocol domain.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">Domain {</span>
            <span class="s0">/**</span>
             <span class="s0">* Domain name.</span>
             <span class="s0">*/</span>
            <span class="s1">name: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Domain version.</span>
             <span class="s0">*/</span>
            <span class="s1">version: string;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetDomainsReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* List of supported domains.</span>
             <span class="s0">*/</span>
            <span class="s1">domains: Domain[];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace Runtime {</span>
        <span class="s0">/**</span>
         <span class="s0">* Unique script identifier.</span>
         <span class="s0">*/</span>
        <span class="s1">type ScriptId = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Unique object identifier.</span>
         <span class="s0">*/</span>
        <span class="s1">type RemoteObjectId = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Primitive value which cannot be JSON-stringified.</span>
         <span class="s0">*/</span>
        <span class="s1">type UnserializableValue = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Mirror object referencing original JavaScript object.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">RemoteObject {</span>
            <span class="s0">/**</span>
             <span class="s0">* Object type.</span>
             <span class="s0">*/</span>
            <span class="s1">type: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Object subtype hint. Specified for &lt;code&gt;object&lt;/code&gt; type values only.</span>
             <span class="s0">*/</span>
            <span class="s1">subtype?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Object class (constructor) name. Specified for &lt;code&gt;object&lt;/code&gt; type values only.</span>
             <span class="s0">*/</span>
            <span class="s1">className?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Remote object value in case of primitive values or JSON values (if it was requested).</span>
             <span class="s0">*/</span>
            <span class="s1">value?: any;</span>
            <span class="s0">/**</span>
             <span class="s0">* Primitive value which can not be JSON-stringified does not have &lt;code&gt;value&lt;/code&gt;, but gets this property.</span>
             <span class="s0">*/</span>
            <span class="s1">unserializableValue?: UnserializableValue | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* String representation of the object.</span>
             <span class="s0">*/</span>
            <span class="s1">description?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Unique object identifier (for non-primitive values).</span>
             <span class="s0">*/</span>
            <span class="s1">objectId?: RemoteObjectId | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Preview containing abbreviated property values. Specified for &lt;code&gt;object&lt;/code&gt; type values only.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">preview?: ObjectPreview | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">customPreview?: CustomPreview | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">CustomPreview {</span>
            <span class="s1">header: string;</span>
            <span class="s1">hasBody: boolean;</span>
            <span class="s1">formatterObjectId: RemoteObjectId;</span>
            <span class="s1">bindRemoteObjectFunctionId: RemoteObjectId;</span>
            <span class="s1">configObjectId?: RemoteObjectId | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Object containing abbreviated remote object value.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">ObjectPreview {</span>
            <span class="s0">/**</span>
             <span class="s0">* Object type.</span>
             <span class="s0">*/</span>
            <span class="s1">type: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Object subtype hint. Specified for &lt;code&gt;object&lt;/code&gt; type values only.</span>
             <span class="s0">*/</span>
            <span class="s1">subtype?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* String representation of the object.</span>
             <span class="s0">*/</span>
            <span class="s1">description?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* True iff some of the properties or entries of the original object did not fit.</span>
             <span class="s0">*/</span>
            <span class="s1">overflow: boolean;</span>
            <span class="s0">/**</span>
             <span class="s0">* List of the properties.</span>
             <span class="s0">*/</span>
            <span class="s1">properties: PropertyPreview[];</span>
            <span class="s0">/**</span>
             <span class="s0">* List of the entries. Specified for &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; subtype values only.</span>
             <span class="s0">*/</span>
            <span class="s1">entries?: EntryPreview[] | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">PropertyPreview {</span>
            <span class="s0">/**</span>
             <span class="s0">* Property name.</span>
             <span class="s0">*/</span>
            <span class="s1">name: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Object type. Accessor means that the property itself is an accessor property.</span>
             <span class="s0">*/</span>
            <span class="s1">type: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* User-friendly property value string.</span>
             <span class="s0">*/</span>
            <span class="s1">value?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Nested value preview.</span>
             <span class="s0">*/</span>
            <span class="s1">valuePreview?: ObjectPreview | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Object subtype hint. Specified for &lt;code&gt;object&lt;/code&gt; type values only.</span>
             <span class="s0">*/</span>
            <span class="s1">subtype?: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">EntryPreview {</span>
            <span class="s0">/**</span>
             <span class="s0">* Preview of the key. Specified for map-like collection entries.</span>
             <span class="s0">*/</span>
            <span class="s1">key?: ObjectPreview | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Preview of the value.</span>
             <span class="s0">*/</span>
            <span class="s1">value: ObjectPreview;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Object property descriptor.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">PropertyDescriptor {</span>
            <span class="s0">/**</span>
             <span class="s0">* Property name or symbol description.</span>
             <span class="s0">*/</span>
            <span class="s1">name: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* The value associated with the property.</span>
             <span class="s0">*/</span>
            <span class="s1">value?: RemoteObject | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* True if the value associated with the property may be changed (data descriptors only).</span>
             <span class="s0">*/</span>
            <span class="s1">writable?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* A function which serves as a getter for the property, or &lt;code&gt;undefined&lt;/code&gt; if there is no getter (accessor descriptors only).</span>
             <span class="s0">*/</span>
            <span class="s1">get?: RemoteObject | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* A function which serves as a setter for the property, or &lt;code&gt;undefined&lt;/code&gt; if there is no setter (accessor descriptors only).</span>
             <span class="s0">*/</span>
            <span class="s1">set?: RemoteObject | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.</span>
             <span class="s0">*/</span>
            <span class="s1">configurable: boolean;</span>
            <span class="s0">/**</span>
             <span class="s0">* True if this property shows up during enumeration of the properties on the corresponding object.</span>
             <span class="s0">*/</span>
            <span class="s1">enumerable: boolean;</span>
            <span class="s0">/**</span>
             <span class="s0">* True if the result was thrown during the evaluation.</span>
             <span class="s0">*/</span>
            <span class="s1">wasThrown?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* True if the property is owned for the object.</span>
             <span class="s0">*/</span>
            <span class="s1">isOwn?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Property symbol object, if the property is of the &lt;code&gt;symbol&lt;/code&gt; type.</span>
             <span class="s0">*/</span>
            <span class="s1">symbol?: RemoteObject | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Object internal property descriptor. This property isn't normally visible in JavaScript code.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">InternalPropertyDescriptor {</span>
            <span class="s0">/**</span>
             <span class="s0">* Conventional property name.</span>
             <span class="s0">*/</span>
            <span class="s1">name: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* The value associated with the property.</span>
             <span class="s0">*/</span>
            <span class="s1">value?: RemoteObject | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Represents function call argument. Either remote object id &lt;code&gt;objectId&lt;/code&gt;, primitive &lt;code&gt;value&lt;/code&gt;, unserializable primitive value or neither of (for undefined) them should be specified.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">CallArgument {</span>
            <span class="s0">/**</span>
             <span class="s0">* Primitive value or serializable javascript object.</span>
             <span class="s0">*/</span>
            <span class="s1">value?: any;</span>
            <span class="s0">/**</span>
             <span class="s0">* Primitive value which can not be JSON-stringified.</span>
             <span class="s0">*/</span>
            <span class="s1">unserializableValue?: UnserializableValue | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Remote object handle.</span>
             <span class="s0">*/</span>
            <span class="s1">objectId?: RemoteObjectId | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Id of an execution context.</span>
         <span class="s0">*/</span>
        <span class="s1">type ExecutionContextId = number;</span>
        <span class="s0">/**</span>
         <span class="s0">* Description of an isolated world.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">ExecutionContextDescription {</span>
            <span class="s0">/**</span>
             <span class="s0">* Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.</span>
             <span class="s0">*/</span>
            <span class="s1">id: ExecutionContextId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Execution context origin.</span>
             <span class="s0">*/</span>
            <span class="s1">origin: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Human readable name describing given context.</span>
             <span class="s0">*/</span>
            <span class="s1">name: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Embedder-specific auxiliary data.</span>
             <span class="s0">*/</span>
            <span class="s1">auxData?: {} | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Detailed information about exception (or error) that was thrown during script compilation or execution.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">ExceptionDetails {</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception id.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionId: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception text, which should be used together with exception object when available.</span>
             <span class="s0">*/</span>
            <span class="s1">text: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Line number of the exception location (0-based).</span>
             <span class="s0">*/</span>
            <span class="s1">lineNumber: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Column number of the exception location (0-based).</span>
             <span class="s0">*/</span>
            <span class="s1">columnNumber: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Script ID of the exception location.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId?: ScriptId | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* URL of the exception location, to be used when the script was not reported.</span>
             <span class="s0">*/</span>
            <span class="s1">url?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript stack trace if available.</span>
             <span class="s0">*/</span>
            <span class="s1">stackTrace?: StackTrace | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception object if available.</span>
             <span class="s0">*/</span>
            <span class="s1">exception?: RemoteObject | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the context where exception happened.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextId?: ExecutionContextId | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Number of milliseconds since epoch.</span>
         <span class="s0">*/</span>
        <span class="s1">type Timestamp = number;</span>
        <span class="s0">/**</span>
         <span class="s0">* Stack entry for runtime errors and assertions.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">CallFrame {</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript function name.</span>
             <span class="s0">*/</span>
            <span class="s1">functionName: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript script id.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: ScriptId;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript script name or url.</span>
             <span class="s0">*/</span>
            <span class="s1">url: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript script line number (0-based).</span>
             <span class="s0">*/</span>
            <span class="s1">lineNumber: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript script column number (0-based).</span>
             <span class="s0">*/</span>
            <span class="s1">columnNumber: number;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Call frames for assertions or error messages.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">StackTrace {</span>
            <span class="s0">/**</span>
             <span class="s0">* String label of this stack trace. For async traces this may be a name of the function that initiated the async call.</span>
             <span class="s0">*/</span>
            <span class="s1">description?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript function name.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrames: CallFrame[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Asynchronous JavaScript stack trace that preceded this stack, if available.</span>
             <span class="s0">*/</span>
            <span class="s1">parent?: StackTrace | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Asynchronous JavaScript stack trace that preceded this stack, if available.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">parentId?: StackTraceId | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Unique identifier of current debugger.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">type UniqueDebuggerId = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* If &lt;code&gt;debuggerId&lt;/code&gt; is set stack trace comes from another debugger and can be resolved there. This allows to track cross-debugger calls. See &lt;code&gt;Runtime.StackTrace&lt;/code&gt; and &lt;code&gt;Debugger.paused&lt;/code&gt; for usages.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">StackTraceId {</span>
            <span class="s1">id: string;</span>
            <span class="s1">debuggerId?: UniqueDebuggerId | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">EvaluateParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Expression to evaluate.</span>
             <span class="s0">*/</span>
            <span class="s1">expression: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Symbolic group name that can be used to release multiple objects.</span>
             <span class="s0">*/</span>
            <span class="s1">objectGroup?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Determines whether Command Line API should be available during the evaluation.</span>
             <span class="s0">*/</span>
            <span class="s1">includeCommandLineAPI?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides &lt;code&gt;setPauseOnException&lt;/code&gt; state.</span>
             <span class="s0">*/</span>
            <span class="s1">silent?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page.</span>
             <span class="s0">*/</span>
            <span class="s1">contextId?: ExecutionContextId | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether the result is expected to be a JSON object that should be sent by value.</span>
             <span class="s0">*/</span>
            <span class="s1">returnByValue?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether preview should be generated for the result.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">generatePreview?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether execution should be treated as initiated by user in the UI.</span>
             <span class="s0">*/</span>
            <span class="s1">userGesture?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether execution should &lt;code&gt;await&lt;/code&gt; for resulting value and return once awaited promise is resolved.</span>
             <span class="s0">*/</span>
            <span class="s1">awaitPromise?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">AwaitPromiseParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the promise.</span>
             <span class="s0">*/</span>
            <span class="s1">promiseObjectId: RemoteObjectId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether the result is expected to be a JSON object that should be sent by value.</span>
             <span class="s0">*/</span>
            <span class="s1">returnByValue?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether preview should be generated for the result.</span>
             <span class="s0">*/</span>
            <span class="s1">generatePreview?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">CallFunctionOnParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Declaration of the function to call.</span>
             <span class="s0">*/</span>
            <span class="s1">functionDeclaration: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the object to call function on. Either objectId or executionContextId should be specified.</span>
             <span class="s0">*/</span>
            <span class="s1">objectId?: RemoteObjectId | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Call arguments. All call arguments must belong to the same JavaScript world as the target object.</span>
             <span class="s0">*/</span>
            <span class="s1">arguments?: CallArgument[] | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides &lt;code&gt;setPauseOnException&lt;/code&gt; state.</span>
             <span class="s0">*/</span>
            <span class="s1">silent?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether the result is expected to be a JSON object which should be sent by value.</span>
             <span class="s0">*/</span>
            <span class="s1">returnByValue?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether preview should be generated for the result.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">generatePreview?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether execution should be treated as initiated by user in the UI.</span>
             <span class="s0">*/</span>
            <span class="s1">userGesture?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether execution should &lt;code&gt;await&lt;/code&gt; for resulting value and return once awaited promise is resolved.</span>
             <span class="s0">*/</span>
            <span class="s1">awaitPromise?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextId?: ExecutionContextId | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.</span>
             <span class="s0">*/</span>
            <span class="s1">objectGroup?: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetPropertiesParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the object to return properties for.</span>
             <span class="s0">*/</span>
            <span class="s1">objectId: RemoteObjectId;</span>
            <span class="s0">/**</span>
             <span class="s0">* If true, returns properties belonging only to the element itself, not to its prototype chain.</span>
             <span class="s0">*/</span>
            <span class="s1">ownProperties?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">accessorPropertiesOnly?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether preview should be generated for the results.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">generatePreview?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ReleaseObjectParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the object to release.</span>
             <span class="s0">*/</span>
            <span class="s1">objectId: RemoteObjectId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ReleaseObjectGroupParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Symbolic object group name.</span>
             <span class="s0">*/</span>
            <span class="s1">objectGroup: string;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetCustomObjectFormatterEnabledParameterType {</span>
            <span class="s1">enabled: boolean;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">CompileScriptParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Expression to compile.</span>
             <span class="s0">*/</span>
            <span class="s1">expression: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Source url to be set for the script.</span>
             <span class="s0">*/</span>
            <span class="s1">sourceURL: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Specifies whether the compiled script should be persisted.</span>
             <span class="s0">*/</span>
            <span class="s1">persistScript: boolean;</span>
            <span class="s0">/**</span>
             <span class="s0">* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextId?: ExecutionContextId | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">RunScriptParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the script to run.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: ScriptId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextId?: ExecutionContextId | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Symbolic group name that can be used to release multiple objects.</span>
             <span class="s0">*/</span>
            <span class="s1">objectGroup?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides &lt;code&gt;setPauseOnException&lt;/code&gt; state.</span>
             <span class="s0">*/</span>
            <span class="s1">silent?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Determines whether Command Line API should be available during the evaluation.</span>
             <span class="s0">*/</span>
            <span class="s1">includeCommandLineAPI?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether the result is expected to be a JSON object which should be sent by value.</span>
             <span class="s0">*/</span>
            <span class="s1">returnByValue?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether preview should be generated for the result.</span>
             <span class="s0">*/</span>
            <span class="s1">generatePreview?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether execution should &lt;code&gt;await&lt;/code&gt; for resulting value and return once awaited promise is resolved.</span>
             <span class="s0">*/</span>
            <span class="s1">awaitPromise?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">QueryObjectsParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the prototype to return objects for.</span>
             <span class="s0">*/</span>
            <span class="s1">prototypeObjectId: RemoteObjectId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GlobalLexicalScopeNamesParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Specifies in which execution context to lookup global scope variables.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextId?: ExecutionContextId | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">EvaluateReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Evaluation result.</span>
             <span class="s0">*/</span>
            <span class="s1">result: RemoteObject;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception details.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionDetails?: ExceptionDetails | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">AwaitPromiseReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Promise result. Will contain rejected value if promise was rejected.</span>
             <span class="s0">*/</span>
            <span class="s1">result: RemoteObject;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception details if stack strace is available.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionDetails?: ExceptionDetails | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">CallFunctionOnReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Call result.</span>
             <span class="s0">*/</span>
            <span class="s1">result: RemoteObject;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception details.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionDetails?: ExceptionDetails | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetPropertiesReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Object properties.</span>
             <span class="s0">*/</span>
            <span class="s1">result: PropertyDescriptor[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Internal object properties (only of the element itself).</span>
             <span class="s0">*/</span>
            <span class="s1">internalProperties?: InternalPropertyDescriptor[] | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception details.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionDetails?: ExceptionDetails | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">CompileScriptReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the script.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId?: ScriptId | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception details.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionDetails?: ExceptionDetails | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">RunScriptReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Run result.</span>
             <span class="s0">*/</span>
            <span class="s1">result: RemoteObject;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception details.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionDetails?: ExceptionDetails | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">QueryObjectsReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Array with objects.</span>
             <span class="s0">*/</span>
            <span class="s1">objects: RemoteObject;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GlobalLexicalScopeNamesReturnType {</span>
            <span class="s1">names: string[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ExecutionContextCreatedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* A newly created execution context.</span>
             <span class="s0">*/</span>
            <span class="s1">context: ExecutionContextDescription;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ExecutionContextDestroyedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the destroyed context</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextId: ExecutionContextId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ExceptionThrownEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Timestamp of the exception.</span>
             <span class="s0">*/</span>
            <span class="s1">timestamp: Timestamp;</span>
            <span class="s1">exceptionDetails: ExceptionDetails;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ExceptionRevokedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Reason describing why exception was revoked.</span>
             <span class="s0">*/</span>
            <span class="s1">reason: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* The id of revoked exception, as reported in &lt;code&gt;exceptionThrown&lt;/code&gt;.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionId: number;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ConsoleAPICalledEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Type of the call.</span>
             <span class="s0">*/</span>
            <span class="s1">type: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Call arguments.</span>
             <span class="s0">*/</span>
            <span class="s1">args: RemoteObject[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the context where the call was made.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextId: ExecutionContextId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Call timestamp.</span>
             <span class="s0">*/</span>
            <span class="s1">timestamp: Timestamp;</span>
            <span class="s0">/**</span>
             <span class="s0">* Stack trace captured when the call was made.</span>
             <span class="s0">*/</span>
            <span class="s1">stackTrace?: StackTrace | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Console context descriptor for calls on non-default console context (not console.*): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">context?: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">InspectRequestedEventDataType {</span>
            <span class="s1">object: RemoteObject;</span>
            <span class="s1">hints: {};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace Debugger {</span>
        <span class="s0">/**</span>
         <span class="s0">* Breakpoint identifier.</span>
         <span class="s0">*/</span>
        <span class="s1">type BreakpointId = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Call frame identifier.</span>
         <span class="s0">*/</span>
        <span class="s1">type CallFrameId = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Location in the source code.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">Location {</span>
            <span class="s0">/**</span>
             <span class="s0">* Script identifier as reported in the &lt;code&gt;Debugger.scriptParsed&lt;/code&gt;.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: Runtime.ScriptId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Line number in the script (0-based).</span>
             <span class="s0">*/</span>
            <span class="s1">lineNumber: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Column number in the script (0-based).</span>
             <span class="s0">*/</span>
            <span class="s1">columnNumber?: number | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Location in the source code.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">ScriptPosition {</span>
            <span class="s1">lineNumber: number;</span>
            <span class="s1">columnNumber: number;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* JavaScript call frame. Array of call frames form the call stack.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">CallFrame {</span>
            <span class="s0">/**</span>
             <span class="s0">* Call frame identifier. This identifier is only valid while the virtual machine is paused.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrameId: CallFrameId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Name of the JavaScript function called on this call frame.</span>
             <span class="s0">*/</span>
            <span class="s1">functionName: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Location in the source code.</span>
             <span class="s0">*/</span>
            <span class="s1">functionLocation?: Location | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Location in the source code.</span>
             <span class="s0">*/</span>
            <span class="s1">location: Location;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript script name or url.</span>
             <span class="s0">*/</span>
            <span class="s1">url: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Scope chain for this call frame.</span>
             <span class="s0">*/</span>
            <span class="s1">scopeChain: Scope[];</span>
            <span class="s0">/**</span>
             <span class="s0">* &lt;code&gt;this&lt;/code&gt; object for this call frame.</span>
             <span class="s0">*/</span>
            <span class="s4">this</span><span class="s1">: Runtime.RemoteObject;</span>
            <span class="s0">/**</span>
             <span class="s0">* The value being returned, if the function is at return point.</span>
             <span class="s0">*/</span>
            <span class="s1">returnValue?: Runtime.RemoteObject | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Scope description.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">Scope {</span>
            <span class="s0">/**</span>
             <span class="s0">* Scope type.</span>
             <span class="s0">*/</span>
            <span class="s1">type: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Object representing the scope. For &lt;code&gt;global&lt;/code&gt; and &lt;code&gt;with&lt;/code&gt; scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.</span>
             <span class="s0">*/</span>
            <span class="s1">object: Runtime.RemoteObject;</span>
            <span class="s1">name?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Location in the source code where scope starts</span>
             <span class="s0">*/</span>
            <span class="s1">startLocation?: Location | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Location in the source code where scope ends</span>
             <span class="s0">*/</span>
            <span class="s1">endLocation?: Location | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Search match for resource.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">SearchMatch {</span>
            <span class="s0">/**</span>
             <span class="s0">* Line number in resource content.</span>
             <span class="s0">*/</span>
            <span class="s1">lineNumber: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Line with match content.</span>
             <span class="s0">*/</span>
            <span class="s1">lineContent: string;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">BreakLocation {</span>
            <span class="s0">/**</span>
             <span class="s0">* Script identifier as reported in the &lt;code&gt;Debugger.scriptParsed&lt;/code&gt;.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: Runtime.ScriptId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Line number in the script (0-based).</span>
             <span class="s0">*/</span>
            <span class="s1">lineNumber: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Column number in the script (0-based).</span>
             <span class="s0">*/</span>
            <span class="s1">columnNumber?: number | undefined;</span>
            <span class="s1">type?: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetBreakpointsActiveParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* New value for breakpoints active state.</span>
             <span class="s0">*/</span>
            <span class="s1">active: boolean;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetSkipAllPausesParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* New value for skip pauses state.</span>
             <span class="s0">*/</span>
            <span class="s1">skip: boolean;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetBreakpointByUrlParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Line number to set breakpoint at.</span>
             <span class="s0">*/</span>
            <span class="s1">lineNumber: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* URL of the resources to set breakpoint on.</span>
             <span class="s0">*/</span>
            <span class="s1">url?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Regex pattern for the URLs of the resources to set breakpoints on. Either &lt;code&gt;url&lt;/code&gt; or &lt;code&gt;urlRegex&lt;/code&gt; must be specified.</span>
             <span class="s0">*/</span>
            <span class="s1">urlRegex?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Script hash of the resources to set breakpoint on.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptHash?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Offset in the line to set breakpoint at.</span>
             <span class="s0">*/</span>
            <span class="s1">columnNumber?: number | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.</span>
             <span class="s0">*/</span>
            <span class="s1">condition?: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetBreakpointParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Location to set breakpoint in.</span>
             <span class="s0">*/</span>
            <span class="s1">location: Location;</span>
            <span class="s0">/**</span>
             <span class="s0">* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.</span>
             <span class="s0">*/</span>
            <span class="s1">condition?: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">RemoveBreakpointParameterType {</span>
            <span class="s1">breakpointId: BreakpointId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetPossibleBreakpointsParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Start of range to search possible breakpoint locations in.</span>
             <span class="s0">*/</span>
            <span class="s1">start: Location;</span>
            <span class="s0">/**</span>
             <span class="s0">* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.</span>
             <span class="s0">*/</span>
            <span class="s1">end?: Location | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Only consider locations which are in the same (non-nested) function as start.</span>
             <span class="s0">*/</span>
            <span class="s1">restrictToFunction?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ContinueToLocationParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Location to continue to.</span>
             <span class="s0">*/</span>
            <span class="s1">location: Location;</span>
            <span class="s1">targetCallFrames?: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">PauseOnAsyncCallParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Debugger will pause when async call with given stack trace is started.</span>
             <span class="s0">*/</span>
            <span class="s1">parentStackTraceId: Runtime.StackTraceId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">StepIntoParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">breakOnAsyncCall?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetStackTraceParameterType {</span>
            <span class="s1">stackTraceId: Runtime.StackTraceId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SearchInContentParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the script to search in.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: Runtime.ScriptId;</span>
            <span class="s0">/**</span>
             <span class="s0">* String to search for.</span>
             <span class="s0">*/</span>
            <span class="s1">query: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* If true, search is case sensitive.</span>
             <span class="s0">*/</span>
            <span class="s1">caseSensitive?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* If true, treats string parameter as regex.</span>
             <span class="s0">*/</span>
            <span class="s1">isRegex?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetScriptSourceParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the script to edit.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: Runtime.ScriptId;</span>
            <span class="s0">/**</span>
             <span class="s0">* New content of the script.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptSource: string;</span>
            <span class="s0">/**</span>
             <span class="s0">*  If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.</span>
             <span class="s0">*/</span>
            <span class="s1">dryRun?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">RestartFrameParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Call frame identifier to evaluate on.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrameId: CallFrameId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetScriptSourceParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the script to get source for.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: Runtime.ScriptId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetPauseOnExceptionsParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Pause on exceptions mode.</span>
             <span class="s0">*/</span>
            <span class="s1">state: string;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">EvaluateOnCallFrameParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Call frame identifier to evaluate on.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrameId: CallFrameId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Expression to evaluate.</span>
             <span class="s0">*/</span>
            <span class="s1">expression: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* String object group name to put result into (allows rapid releasing resulting object handles using &lt;code&gt;releaseObjectGroup&lt;/code&gt;).</span>
             <span class="s0">*/</span>
            <span class="s1">objectGroup?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Specifies whether command line API should be available to the evaluated expression, defaults to false.</span>
             <span class="s0">*/</span>
            <span class="s1">includeCommandLineAPI?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides &lt;code&gt;setPauseOnException&lt;/code&gt; state.</span>
             <span class="s0">*/</span>
            <span class="s1">silent?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether the result is expected to be a JSON object that should be sent by value.</span>
             <span class="s0">*/</span>
            <span class="s1">returnByValue?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether preview should be generated for the result.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">generatePreview?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether to throw an exception if side effect cannot be ruled out during evaluation.</span>
             <span class="s0">*/</span>
            <span class="s1">throwOnSideEffect?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetVariableValueParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.</span>
             <span class="s0">*/</span>
            <span class="s1">scopeNumber: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Variable name.</span>
             <span class="s0">*/</span>
            <span class="s1">variableName: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* New variable value.</span>
             <span class="s0">*/</span>
            <span class="s1">newValue: Runtime.CallArgument;</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of callframe that holds variable.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrameId: CallFrameId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetReturnValueParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* New return value.</span>
             <span class="s0">*/</span>
            <span class="s1">newValue: Runtime.CallArgument;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetAsyncCallStackDepthParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Maximum depth of async call stacks. Setting to &lt;code&gt;0&lt;/code&gt; will effectively disable collecting async call stacks (default).</span>
             <span class="s0">*/</span>
            <span class="s1">maxDepth: number;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetBlackboxPatternsParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Array of regexps that will be used to check script url for blackbox state.</span>
             <span class="s0">*/</span>
            <span class="s1">patterns: string[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetBlackboxedRangesParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the script.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: Runtime.ScriptId;</span>
            <span class="s1">positions: ScriptPosition[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">EnableReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Unique identifier of the debugger.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">debuggerId: Runtime.UniqueDebuggerId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetBreakpointByUrlReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the created breakpoint for further reference.</span>
             <span class="s0">*/</span>
            <span class="s1">breakpointId: BreakpointId;</span>
            <span class="s0">/**</span>
             <span class="s0">* List of the locations this breakpoint resolved into upon addition.</span>
             <span class="s0">*/</span>
            <span class="s1">locations: Location[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetBreakpointReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the created breakpoint for further reference.</span>
             <span class="s0">*/</span>
            <span class="s1">breakpointId: BreakpointId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Location this breakpoint resolved into.</span>
             <span class="s0">*/</span>
            <span class="s1">actualLocation: Location;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetPossibleBreakpointsReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* List of the possible breakpoint locations.</span>
             <span class="s0">*/</span>
            <span class="s1">locations: BreakLocation[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetStackTraceReturnType {</span>
            <span class="s1">stackTrace: Runtime.StackTrace;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SearchInContentReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* List of search matches.</span>
             <span class="s0">*/</span>
            <span class="s1">result: SearchMatch[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetScriptSourceReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* New stack trace in case editing has happened while VM was stopped.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrames?: CallFrame[] | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether current call stack  was modified after applying the changes.</span>
             <span class="s0">*/</span>
            <span class="s1">stackChanged?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Async stack trace, if any.</span>
             <span class="s0">*/</span>
            <span class="s1">asyncStackTrace?: Runtime.StackTrace | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Async stack trace, if any.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">asyncStackTraceId?: Runtime.StackTraceId | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception details if any.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionDetails?: Runtime.ExceptionDetails | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">RestartFrameReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* New stack trace.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrames: CallFrame[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Async stack trace, if any.</span>
             <span class="s0">*/</span>
            <span class="s1">asyncStackTrace?: Runtime.StackTrace | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Async stack trace, if any.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">asyncStackTraceId?: Runtime.StackTraceId | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetScriptSourceReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Script source.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptSource: string;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">EvaluateOnCallFrameReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Object wrapper for the evaluation result.</span>
             <span class="s0">*/</span>
            <span class="s1">result: Runtime.RemoteObject;</span>
            <span class="s0">/**</span>
             <span class="s0">* Exception details.</span>
             <span class="s0">*/</span>
            <span class="s1">exceptionDetails?: Runtime.ExceptionDetails | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ScriptParsedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the script parsed.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: Runtime.ScriptId;</span>
            <span class="s0">/**</span>
             <span class="s0">* URL or name of the script parsed (if any).</span>
             <span class="s0">*/</span>
            <span class="s1">url: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Line offset of the script within the resource with given URL (for script tags).</span>
             <span class="s0">*/</span>
            <span class="s1">startLine: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Column offset of the script within the resource with given URL.</span>
             <span class="s0">*/</span>
            <span class="s1">startColumn: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Last line of the script.</span>
             <span class="s0">*/</span>
            <span class="s1">endLine: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Length of the last line of the script.</span>
             <span class="s0">*/</span>
            <span class="s1">endColumn: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Specifies script creation context.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextId: Runtime.ExecutionContextId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Content hash of the script.</span>
             <span class="s0">*/</span>
            <span class="s1">hash: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Embedder-specific auxiliary data.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextAuxData?: {} | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* True, if this script is generated as a result of the live edit operation.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">isLiveEdit?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* URL of source map associated with script (if any).</span>
             <span class="s0">*/</span>
            <span class="s1">sourceMapURL?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* True, if this script has sourceURL.</span>
             <span class="s0">*/</span>
            <span class="s1">hasSourceURL?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* True, if this script is ES6 module.</span>
             <span class="s0">*/</span>
            <span class="s1">isModule?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* This script length.</span>
             <span class="s0">*/</span>
            <span class="s1">length?: number | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript top stack frame of where the script parsed event was triggered if available.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">stackTrace?: Runtime.StackTrace | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ScriptFailedToParseEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the script parsed.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: Runtime.ScriptId;</span>
            <span class="s0">/**</span>
             <span class="s0">* URL or name of the script parsed (if any).</span>
             <span class="s0">*/</span>
            <span class="s1">url: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Line offset of the script within the resource with given URL (for script tags).</span>
             <span class="s0">*/</span>
            <span class="s1">startLine: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Column offset of the script within the resource with given URL.</span>
             <span class="s0">*/</span>
            <span class="s1">startColumn: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Last line of the script.</span>
             <span class="s0">*/</span>
            <span class="s1">endLine: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Length of the last line of the script.</span>
             <span class="s0">*/</span>
            <span class="s1">endColumn: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Specifies script creation context.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextId: Runtime.ExecutionContextId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Content hash of the script.</span>
             <span class="s0">*/</span>
            <span class="s1">hash: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Embedder-specific auxiliary data.</span>
             <span class="s0">*/</span>
            <span class="s1">executionContextAuxData?: {} | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* URL of source map associated with script (if any).</span>
             <span class="s0">*/</span>
            <span class="s1">sourceMapURL?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* True, if this script has sourceURL.</span>
             <span class="s0">*/</span>
            <span class="s1">hasSourceURL?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* True, if this script is ES6 module.</span>
             <span class="s0">*/</span>
            <span class="s1">isModule?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* This script length.</span>
             <span class="s0">*/</span>
            <span class="s1">length?: number | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript top stack frame of where the script parsed event was triggered if available.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">stackTrace?: Runtime.StackTrace | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">BreakpointResolvedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Breakpoint unique identifier.</span>
             <span class="s0">*/</span>
            <span class="s1">breakpointId: BreakpointId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Actual breakpoint location.</span>
             <span class="s0">*/</span>
            <span class="s1">location: Location;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">PausedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Call stack the virtual machine stopped on.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrames: CallFrame[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Pause reason.</span>
             <span class="s0">*/</span>
            <span class="s1">reason: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Object containing break-specific auxiliary properties.</span>
             <span class="s0">*/</span>
            <span class="s1">data?: {} | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Hit breakpoints IDs</span>
             <span class="s0">*/</span>
            <span class="s1">hitBreakpoints?: string[] | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Async stack trace, if any.</span>
             <span class="s0">*/</span>
            <span class="s1">asyncStackTrace?: Runtime.StackTrace | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Async stack trace, if any.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">asyncStackTraceId?: Runtime.StackTraceId | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after &lt;code&gt;Debugger.stepInto&lt;/code&gt; call with &lt;code&gt;breakOnAsynCall&lt;/code&gt; flag.</span>
             <span class="s0">* </span><span class="s2">@experimental</span>
             <span class="s0">*/</span>
            <span class="s1">asyncCallStackTraceId?: Runtime.StackTraceId | undefined;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace Console {</span>
        <span class="s0">/**</span>
         <span class="s0">* Console message.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">ConsoleMessage {</span>
            <span class="s0">/**</span>
             <span class="s0">* Message source.</span>
             <span class="s0">*/</span>
            <span class="s1">source: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Message severity.</span>
             <span class="s0">*/</span>
            <span class="s1">level: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Message text.</span>
             <span class="s0">*/</span>
            <span class="s1">text: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* URL of the message origin.</span>
             <span class="s0">*/</span>
            <span class="s1">url?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Line number in the resource that generated this message (1-based).</span>
             <span class="s0">*/</span>
            <span class="s1">line?: number | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Column number in the resource that generated this message (1-based).</span>
             <span class="s0">*/</span>
            <span class="s1">column?: number | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">MessageAddedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Console message that has been added.</span>
             <span class="s0">*/</span>
            <span class="s1">message: ConsoleMessage;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace Profiler {</span>
        <span class="s0">/**</span>
         <span class="s0">* Profile node. Holds callsite information, execution statistics and child nodes.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">ProfileNode {</span>
            <span class="s0">/**</span>
             <span class="s0">* Unique id of the node.</span>
             <span class="s0">*/</span>
            <span class="s1">id: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Function location.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrame: Runtime.CallFrame;</span>
            <span class="s0">/**</span>
             <span class="s0">* Number of samples where this node was on top of the call stack.</span>
             <span class="s0">*/</span>
            <span class="s1">hitCount?: number | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Child node ids.</span>
             <span class="s0">*/</span>
            <span class="s1">children?: number[] | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* The reason of being not optimized. The function may be deoptimized or marked as don't optimize.</span>
             <span class="s0">*/</span>
            <span class="s1">deoptReason?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* An array of source position ticks.</span>
             <span class="s0">*/</span>
            <span class="s1">positionTicks?: PositionTickInfo[] | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Profile.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">Profile {</span>
            <span class="s0">/**</span>
             <span class="s0">* The list of profile nodes. First item is the root node.</span>
             <span class="s0">*/</span>
            <span class="s1">nodes: ProfileNode[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Profiling start timestamp in microseconds.</span>
             <span class="s0">*/</span>
            <span class="s1">startTime: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Profiling end timestamp in microseconds.</span>
             <span class="s0">*/</span>
            <span class="s1">endTime: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Ids of samples top nodes.</span>
             <span class="s0">*/</span>
            <span class="s1">samples?: number[] | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime.</span>
             <span class="s0">*/</span>
            <span class="s1">timeDeltas?: number[] | undefined;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Specifies a number of samples attributed to a certain source position.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">PositionTickInfo {</span>
            <span class="s0">/**</span>
             <span class="s0">* Source line number (1-based).</span>
             <span class="s0">*/</span>
            <span class="s1">line: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Number of samples attributed to the source line.</span>
             <span class="s0">*/</span>
            <span class="s1">ticks: number;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Coverage data for a source range.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">CoverageRange {</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript script source offset for the range start.</span>
             <span class="s0">*/</span>
            <span class="s1">startOffset: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript script source offset for the range end.</span>
             <span class="s0">*/</span>
            <span class="s1">endOffset: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Collected execution count of the source range.</span>
             <span class="s0">*/</span>
            <span class="s1">count: number;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Coverage data for a JavaScript function.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">FunctionCoverage {</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript function name.</span>
             <span class="s0">*/</span>
            <span class="s1">functionName: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Source ranges inside the function with coverage data.</span>
             <span class="s0">*/</span>
            <span class="s1">ranges: CoverageRange[];</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether coverage data for this function has block granularity.</span>
             <span class="s0">*/</span>
            <span class="s1">isBlockCoverage: boolean;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Coverage data for a JavaScript script.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">ScriptCoverage {</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript script id.</span>
             <span class="s0">*/</span>
            <span class="s1">scriptId: Runtime.ScriptId;</span>
            <span class="s0">/**</span>
             <span class="s0">* JavaScript script name or url.</span>
             <span class="s0">*/</span>
            <span class="s1">url: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Functions contained in the script that has coverage data.</span>
             <span class="s0">*/</span>
            <span class="s1">functions: FunctionCoverage[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SetSamplingIntervalParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* New sampling interval in microseconds.</span>
             <span class="s0">*/</span>
            <span class="s1">interval: number;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">StartPreciseCoverageParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Collect accurate call counts beyond simple 'covered' or 'not covered'.</span>
             <span class="s0">*/</span>
            <span class="s1">callCount?: boolean | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Collect block-based coverage.</span>
             <span class="s0">*/</span>
            <span class="s1">detailed?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">StopReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Recorded profile.</span>
             <span class="s0">*/</span>
            <span class="s1">profile: Profile;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">TakePreciseCoverageReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Coverage data for the current isolate.</span>
             <span class="s0">*/</span>
            <span class="s1">result: ScriptCoverage[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetBestEffortCoverageReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Coverage data for the current isolate.</span>
             <span class="s0">*/</span>
            <span class="s1">result: ScriptCoverage[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ConsoleProfileStartedEventDataType {</span>
            <span class="s1">id: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Location of console.profile().</span>
             <span class="s0">*/</span>
            <span class="s1">location: Debugger.Location;</span>
            <span class="s0">/**</span>
             <span class="s0">* Profile title passed as an argument to console.profile().</span>
             <span class="s0">*/</span>
            <span class="s1">title?: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ConsoleProfileFinishedEventDataType {</span>
            <span class="s1">id: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Location of console.profileEnd().</span>
             <span class="s0">*/</span>
            <span class="s1">location: Debugger.Location;</span>
            <span class="s1">profile: Profile;</span>
            <span class="s0">/**</span>
             <span class="s0">* Profile title passed as an argument to console.profile().</span>
             <span class="s0">*/</span>
            <span class="s1">title?: string | undefined;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace HeapProfiler {</span>
        <span class="s0">/**</span>
         <span class="s0">* Heap snapshot object id.</span>
         <span class="s0">*/</span>
        <span class="s1">type HeapSnapshotObjectId = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">SamplingHeapProfileNode {</span>
            <span class="s0">/**</span>
             <span class="s0">* Function location.</span>
             <span class="s0">*/</span>
            <span class="s1">callFrame: Runtime.CallFrame;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocations size in bytes for the node excluding children.</span>
             <span class="s0">*/</span>
            <span class="s1">selfSize: number;</span>
            <span class="s0">/**</span>
             <span class="s0">* Child nodes.</span>
             <span class="s0">*/</span>
            <span class="s1">children: SamplingHeapProfileNode[];</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Profile.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">SamplingHeapProfile {</span>
            <span class="s1">head: SamplingHeapProfileNode;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">StartTrackingHeapObjectsParameterType {</span>
            <span class="s1">trackAllocations?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">StopTrackingHeapObjectsParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.</span>
             <span class="s0">*/</span>
            <span class="s1">reportProgress?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">TakeHeapSnapshotParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.</span>
             <span class="s0">*/</span>
            <span class="s1">reportProgress?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetObjectByHeapObjectIdParameterType {</span>
            <span class="s1">objectId: HeapSnapshotObjectId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Symbolic group name that can be used to release multiple objects.</span>
             <span class="s0">*/</span>
            <span class="s1">objectGroup?: string | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">AddInspectedHeapObjectParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Heap snapshot object id to be accessible by means of $x command line API.</span>
             <span class="s0">*/</span>
            <span class="s1">heapObjectId: HeapSnapshotObjectId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetHeapObjectIdParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the object to get heap object id for.</span>
             <span class="s0">*/</span>
            <span class="s1">objectId: Runtime.RemoteObjectId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">StartSamplingParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.</span>
             <span class="s0">*/</span>
            <span class="s1">samplingInterval?: number | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetObjectByHeapObjectIdReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Evaluation result.</span>
             <span class="s0">*/</span>
            <span class="s1">result: Runtime.RemoteObject;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetHeapObjectIdReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Id of the heap snapshot object corresponding to the passed remote object id.</span>
             <span class="s0">*/</span>
            <span class="s1">heapSnapshotObjectId: HeapSnapshotObjectId;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">StopSamplingReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Recorded sampling heap profile.</span>
             <span class="s0">*/</span>
            <span class="s1">profile: SamplingHeapProfile;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetSamplingProfileReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Return the sampling profile being collected.</span>
             <span class="s0">*/</span>
            <span class="s1">profile: SamplingHeapProfile;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">AddHeapSnapshotChunkEventDataType {</span>
            <span class="s1">chunk: string;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ReportHeapSnapshotProgressEventDataType {</span>
            <span class="s1">done: number;</span>
            <span class="s1">total: number;</span>
            <span class="s1">finished?: boolean | undefined;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">LastSeenObjectIdEventDataType {</span>
            <span class="s1">lastSeenObjectId: number;</span>
            <span class="s1">timestamp: number;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">HeapStatsUpdateEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment.</span>
             <span class="s0">*/</span>
            <span class="s1">statsUpdate: number[];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace NodeTracing {</span>
        <span class="s4">interface </span><span class="s1">TraceConfig {</span>
            <span class="s0">/**</span>
             <span class="s0">* Controls how the trace buffer stores data.</span>
             <span class="s0">*/</span>
            <span class="s1">recordMode?: string | undefined;</span>
            <span class="s0">/**</span>
             <span class="s0">* Included category filters.</span>
             <span class="s0">*/</span>
            <span class="s1">includedCategories: string[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">StartParameterType {</span>
            <span class="s1">traceConfig: TraceConfig;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">GetCategoriesReturnType {</span>
            <span class="s0">/**</span>
             <span class="s0">* A list of supported tracing categories.</span>
             <span class="s0">*/</span>
            <span class="s1">categories: string[];</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">DataCollectedEventDataType {</span>
            <span class="s1">value: Array&lt;{}&gt;;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace NodeWorker {</span>
        <span class="s1">type WorkerID = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Unique identifier of attached debugging session.</span>
         <span class="s0">*/</span>
        <span class="s1">type SessionID = string;</span>
        <span class="s4">interface </span><span class="s1">WorkerInfo {</span>
            <span class="s1">workerId: WorkerID;</span>
            <span class="s1">type: string;</span>
            <span class="s1">title: string;</span>
            <span class="s1">url: string;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">SendMessageToWorkerParameterType {</span>
            <span class="s1">message: string;</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of the session.</span>
             <span class="s0">*/</span>
            <span class="s1">sessionId: SessionID;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">EnableParameterType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Whether to new workers should be paused until the frontend sends `Runtime.runIfWaitingForDebugger`</span>
             <span class="s0">* message to run them.</span>
             <span class="s0">*/</span>
            <span class="s1">waitForDebuggerOnStart: boolean;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">DetachParameterType {</span>
            <span class="s1">sessionId: SessionID;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">AttachedToWorkerEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier assigned to the session used to send/receive messages.</span>
             <span class="s0">*/</span>
            <span class="s1">sessionId: SessionID;</span>
            <span class="s1">workerInfo: WorkerInfo;</span>
            <span class="s1">waitingForDebugger: boolean;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">DetachedFromWorkerEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Detached session identifier.</span>
             <span class="s0">*/</span>
            <span class="s1">sessionId: SessionID;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ReceivedMessageFromWorkerEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Identifier of a session which sends a message.</span>
             <span class="s0">*/</span>
            <span class="s1">sessionId: SessionID;</span>
            <span class="s1">message: string;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace Network {</span>
        <span class="s0">/**</span>
         <span class="s0">* Resource type as it was perceived by the rendering engine.</span>
         <span class="s0">*/</span>
        <span class="s1">type ResourceType = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* Unique request identifier.</span>
         <span class="s0">*/</span>
        <span class="s1">type RequestId = string;</span>
        <span class="s0">/**</span>
         <span class="s0">* UTC time in seconds, counted from January 1, 1970.</span>
         <span class="s0">*/</span>
        <span class="s1">type TimeSinceEpoch = number;</span>
        <span class="s0">/**</span>
         <span class="s0">* Monotonically increasing time in seconds since an arbitrary point in the past.</span>
         <span class="s0">*/</span>
        <span class="s1">type MonotonicTime = number;</span>
        <span class="s0">/**</span>
         <span class="s0">* HTTP request data.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">Request {</span>
            <span class="s1">url: string;</span>
            <span class="s1">method: string;</span>
            <span class="s1">headers: Headers;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* HTTP response data.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">Response {</span>
            <span class="s1">url: string;</span>
            <span class="s1">status: number;</span>
            <span class="s1">statusText: string;</span>
            <span class="s1">headers: Headers;</span>
        <span class="s1">}</span>
        <span class="s0">/**</span>
         <span class="s0">* Request / response headers as keys / values of JSON object.</span>
         <span class="s0">*/</span>
        <span class="s4">interface </span><span class="s1">Headers {</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">RequestWillBeSentEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Request identifier.</span>
             <span class="s0">*/</span>
            <span class="s1">requestId: RequestId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Request data.</span>
             <span class="s0">*/</span>
            <span class="s1">request: Request;</span>
            <span class="s0">/**</span>
             <span class="s0">* Timestamp.</span>
             <span class="s0">*/</span>
            <span class="s1">timestamp: MonotonicTime;</span>
            <span class="s0">/**</span>
             <span class="s0">* Timestamp.</span>
             <span class="s0">*/</span>
            <span class="s1">wallTime: TimeSinceEpoch;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">ResponseReceivedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Request identifier.</span>
             <span class="s0">*/</span>
            <span class="s1">requestId: RequestId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Timestamp.</span>
             <span class="s0">*/</span>
            <span class="s1">timestamp: MonotonicTime;</span>
            <span class="s0">/**</span>
             <span class="s0">* Resource type.</span>
             <span class="s0">*/</span>
            <span class="s1">type: ResourceType;</span>
            <span class="s0">/**</span>
             <span class="s0">* Response data.</span>
             <span class="s0">*/</span>
            <span class="s1">response: Response;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">LoadingFailedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Request identifier.</span>
             <span class="s0">*/</span>
            <span class="s1">requestId: RequestId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Timestamp.</span>
             <span class="s0">*/</span>
            <span class="s1">timestamp: MonotonicTime;</span>
            <span class="s0">/**</span>
             <span class="s0">* Resource type.</span>
             <span class="s0">*/</span>
            <span class="s1">type: ResourceType;</span>
            <span class="s0">/**</span>
             <span class="s0">* Error message.</span>
             <span class="s0">*/</span>
            <span class="s1">errorText: string;</span>
        <span class="s1">}</span>
        <span class="s4">interface </span><span class="s1">LoadingFinishedEventDataType {</span>
            <span class="s0">/**</span>
             <span class="s0">* Request identifier.</span>
             <span class="s0">*/</span>
            <span class="s1">requestId: RequestId;</span>
            <span class="s0">/**</span>
             <span class="s0">* Timestamp.</span>
             <span class="s0">*/</span>
            <span class="s1">timestamp: MonotonicTime;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">namespace NodeRuntime {</span>
        <span class="s4">interface </span><span class="s1">NotifyWhenWaitingForDisconnectParameterType {</span>
            <span class="s1">enabled: boolean;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/**</span>
     <span class="s0">* The `inspector.Session` is used for dispatching messages to the V8 inspector</span>
     <span class="s0">* back-end and receiving message responses and notifications.</span>
     <span class="s0">*/</span>
    <span class="s4">class </span><span class="s1">Session </span><span class="s4">extends </span><span class="s1">EventEmitter {</span>
        <span class="s0">/**</span>
         <span class="s0">* Create a new instance of the inspector.Session class.</span>
         <span class="s0">* The inspector session needs to be connected through `session.connect()` before the messages can be dispatched to the inspector backend.</span>
         <span class="s0">*/</span>
        <span class="s1">constructor();</span>

        <span class="s0">/**</span>
         <span class="s0">* Connects a session to the inspector back-end.</span>
         <span class="s0">*/</span>
        <span class="s1">connect(): </span><span class="s4">void</span><span class="s1">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Connects a session to the inspector back-end.</span>
         <span class="s0">* An exception will be thrown if this API was not called on a Worker thread.</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v12.11.0</span>
         <span class="s0">*/</span>
        <span class="s1">connectToMainThread(): </span><span class="s4">void</span><span class="s1">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Immediately close the session. All pending message callbacks will be called with an error.</span>
         <span class="s0">* `session.connect()` will need to be called to be able to send messages again.</span>
         <span class="s0">* Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.</span>
         <span class="s0">*/</span>
        <span class="s1">disconnect(): </span><span class="s4">void</span><span class="s1">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Posts a message to the inspector back-end. `callback` will be notified when</span>
         <span class="s0">* a response is received. `callback` is a function that accepts two optional</span>
         <span class="s0">* arguments: error and message-specific result.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* session.post('Runtime.evaluate', { expression: '2 + 2' },</span>
         <span class="s0">*              (error, { result }) =&gt; console.log(result));</span>
         <span class="s0">* // Output: { type: 'number', value: 4, description: '4' }</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The latest version of the V8 inspector protocol is published on the</span>
         <span class="s0">* [Chrome DevTools Protocol Viewer](https://chromedevtools.github.io/devtools-protocol/v8/).</span>
         <span class="s0">*</span>
         <span class="s0">* Node.js inspector supports all the Chrome DevTools Protocol domains declared</span>
         <span class="s0">* by V8. Chrome DevTools Protocol domain provides an interface for interacting</span>
         <span class="s0">* with one of the runtime agents used to inspect the application state and listen</span>
         <span class="s0">* to the run-time events.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: string, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params?: object) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: string, params?: object, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params?: object) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns supported domains.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Schema.getDomains'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Schema.GetDomainsReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Evaluates expression on global object.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.evaluate'</span><span class="s1">, params?: Runtime.EvaluateParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.EvaluateReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.evaluate'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.EvaluateReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Add handler to promise with given promise object id.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.awaitPromise'</span><span class="s1">, params?: Runtime.AwaitPromiseParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.AwaitPromiseReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.awaitPromise'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.AwaitPromiseReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Calls function with given declaration on the given object. Object group of the result is inherited from the target object.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.callFunctionOn'</span><span class="s1">, params?: Runtime.CallFunctionOnParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.CallFunctionOnReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.callFunctionOn'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.CallFunctionOnReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns properties of a given object. Object group of the result is inherited from the target object.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.getProperties'</span><span class="s1">, params?: Runtime.GetPropertiesParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.GetPropertiesReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.getProperties'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.GetPropertiesReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Releases remote object with given id.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.releaseObject'</span><span class="s1">, params?: Runtime.ReleaseObjectParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.releaseObject'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Releases all remote objects that belong to a given group.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.releaseObjectGroup'</span><span class="s1">, params?: Runtime.ReleaseObjectGroupParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.releaseObjectGroup'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Tells inspected instance to run if it was waiting for debugger to attach.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.runIfWaitingForDebugger'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables reporting of execution contexts creation by means of &lt;code&gt;executionContextCreated&lt;/code&gt; event. When the reporting gets enabled the event will be sent immediately for each existing execution context.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.enable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables reporting of execution contexts creation.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.disable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Discards collected exceptions and console API calls.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.discardConsoleEntries'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.setCustomObjectFormatterEnabled'</span><span class="s1">, params?: Runtime.SetCustomObjectFormatterEnabledParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.setCustomObjectFormatterEnabled'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Compiles expression.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.compileScript'</span><span class="s1">, params?: Runtime.CompileScriptParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.CompileScriptReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.compileScript'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.CompileScriptReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Runs script with given id in a given context.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.runScript'</span><span class="s1">, params?: Runtime.RunScriptParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.RunScriptReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.runScript'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.RunScriptReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.queryObjects'</span><span class="s1">, params?: Runtime.QueryObjectsParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.QueryObjectsReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.queryObjects'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.QueryObjectsReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns all let, const and class variables from global scope.</span>
         <span class="s0">*/</span>
        <span class="s1">post(</span>
            <span class="s1">method: </span><span class="s3">'Runtime.globalLexicalScopeNames'</span><span class="s1">,</span>
            <span class="s1">params?: Runtime.GlobalLexicalScopeNamesParameterType,</span>
            <span class="s1">callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.GlobalLexicalScopeNamesReturnType) =&gt; </span><span class="s4">void</span>
        <span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.globalLexicalScopeNames'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Runtime.GlobalLexicalScopeNamesReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.enable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.EnableReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables debugger for given page.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.disable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Activates / deactivates all breakpoints on the page.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBreakpointsActive'</span><span class="s1">, params?: Debugger.SetBreakpointsActiveParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBreakpointsActive'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setSkipAllPauses'</span><span class="s1">, params?: Debugger.SetSkipAllPausesParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setSkipAllPauses'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in &lt;code&gt;locations&lt;/code&gt; property. Further matching script parsing will result in subsequent &lt;code&gt;breakpointResolved&lt;/code&gt; events issued. This logical breakpoint will survive page reloads.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBreakpointByUrl'</span><span class="s1">, params?: Debugger.SetBreakpointByUrlParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.SetBreakpointByUrlReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBreakpointByUrl'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.SetBreakpointByUrlReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets JavaScript breakpoint at a given location.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBreakpoint'</span><span class="s1">, params?: Debugger.SetBreakpointParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.SetBreakpointReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBreakpoint'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.SetBreakpointReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Removes JavaScript breakpoint.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.removeBreakpoint'</span><span class="s1">, params?: Debugger.RemoveBreakpointParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.removeBreakpoint'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.</span>
         <span class="s0">*/</span>
        <span class="s1">post(</span>
            <span class="s1">method: </span><span class="s3">'Debugger.getPossibleBreakpoints'</span><span class="s1">,</span>
            <span class="s1">params?: Debugger.GetPossibleBreakpointsParameterType,</span>
            <span class="s1">callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.GetPossibleBreakpointsReturnType) =&gt; </span><span class="s4">void</span>
        <span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.getPossibleBreakpoints'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.GetPossibleBreakpointsReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Continues execution until specific location is reached.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.continueToLocation'</span><span class="s1">, params?: Debugger.ContinueToLocationParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.continueToLocation'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.pauseOnAsyncCall'</span><span class="s1">, params?: Debugger.PauseOnAsyncCallParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.pauseOnAsyncCall'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Steps over the statement.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.stepOver'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Steps into the function call.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.stepInto'</span><span class="s1">, params?: Debugger.StepIntoParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.stepInto'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Steps out of the function call.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.stepOut'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Stops on the next JavaScript statement.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.pause'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.scheduleStepIntoAsync'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resumes JavaScript execution.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.resume'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns stack trace with given &lt;code&gt;stackTraceId&lt;/code&gt;.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.getStackTrace'</span><span class="s1">, params?: Debugger.GetStackTraceParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.GetStackTraceReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.getStackTrace'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.GetStackTraceReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Searches for given string in script content.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.searchInContent'</span><span class="s1">, params?: Debugger.SearchInContentParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.SearchInContentReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.searchInContent'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.SearchInContentReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Edits JavaScript source live.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setScriptSource'</span><span class="s1">, params?: Debugger.SetScriptSourceParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.SetScriptSourceReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setScriptSource'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.SetScriptSourceReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Restarts particular call frame from the beginning.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.restartFrame'</span><span class="s1">, params?: Debugger.RestartFrameParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.RestartFrameReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.restartFrame'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.RestartFrameReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns source for the script with given id.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.getScriptSource'</span><span class="s1">, params?: Debugger.GetScriptSourceParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.GetScriptSourceReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.getScriptSource'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.GetScriptSourceReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is &lt;code&gt;none&lt;/code&gt;.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setPauseOnExceptions'</span><span class="s1">, params?: Debugger.SetPauseOnExceptionsParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setPauseOnExceptions'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Evaluates expression on a given call frame.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.evaluateOnCallFrame'</span><span class="s1">, params?: Debugger.EvaluateOnCallFrameParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.EvaluateOnCallFrameReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.evaluateOnCallFrame'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Debugger.EvaluateOnCallFrameReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setVariableValue'</span><span class="s1">, params?: Debugger.SetVariableValueParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setVariableValue'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Changes return value in top frame. Available only at return break position.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setReturnValue'</span><span class="s1">, params?: Debugger.SetReturnValueParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setReturnValue'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables or disables async call stacks tracking.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setAsyncCallStackDepth'</span><span class="s1">, params?: Debugger.SetAsyncCallStackDepthParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setAsyncCallStackDepth'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBlackboxPatterns'</span><span class="s1">, params?: Debugger.SetBlackboxPatternsParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBlackboxPatterns'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBlackboxedRanges'</span><span class="s1">, params?: Debugger.SetBlackboxedRangesParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBlackboxedRanges'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables console domain, sends the messages collected so far to the client by means of the &lt;code&gt;messageAdded&lt;/code&gt; notification.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Console.enable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables console domain, prevents further console messages from being reported to the client.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Console.disable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Does nothing.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Console.clearMessages'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.enable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.disable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.setSamplingInterval'</span><span class="s1">, params?: Profiler.SetSamplingIntervalParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.setSamplingInterval'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.start'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.stop'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Profiler.StopReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.startPreciseCoverage'</span><span class="s1">, params?: Profiler.StartPreciseCoverageParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.startPreciseCoverage'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.stopPreciseCoverage'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.takePreciseCoverage'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Profiler.TakePreciseCoverageReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.getBestEffortCoverage'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: Profiler.GetBestEffortCoverageReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.enable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.disable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.startTrackingHeapObjects'</span><span class="s1">, params?: HeapProfiler.StartTrackingHeapObjectsParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.startTrackingHeapObjects'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.stopTrackingHeapObjects'</span><span class="s1">, params?: HeapProfiler.StopTrackingHeapObjectsParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.stopTrackingHeapObjects'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.takeHeapSnapshot'</span><span class="s1">, params?: HeapProfiler.TakeHeapSnapshotParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.takeHeapSnapshot'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.collectGarbage'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(</span>
            <span class="s1">method: </span><span class="s3">'HeapProfiler.getObjectByHeapObjectId'</span><span class="s1">,</span>
            <span class="s1">params?: HeapProfiler.GetObjectByHeapObjectIdParameterType,</span>
            <span class="s1">callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) =&gt; </span><span class="s4">void</span>
        <span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.getObjectByHeapObjectId'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.addInspectedHeapObject'</span><span class="s1">, params?: HeapProfiler.AddInspectedHeapObjectParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.addInspectedHeapObject'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.getHeapObjectId'</span><span class="s1">, params?: HeapProfiler.GetHeapObjectIdParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: HeapProfiler.GetHeapObjectIdReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.getHeapObjectId'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: HeapProfiler.GetHeapObjectIdReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.startSampling'</span><span class="s1">, params?: HeapProfiler.StartSamplingParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.startSampling'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.stopSampling'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: HeapProfiler.StopSamplingReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.getSamplingProfile'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: HeapProfiler.GetSamplingProfileReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets supported tracing categories.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeTracing.getCategories'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">, params: NodeTracing.GetCategoriesReturnType) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Start trace events collection.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeTracing.start'</span><span class="s1">, params?: NodeTracing.StartParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'NodeTracing.start'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Stop trace events collection. Remaining collected events will be sent as a sequence of</span>
         <span class="s0">* dataCollected events followed by tracingComplete event.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeTracing.stop'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends protocol message over session with given id.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.sendMessageToWorker'</span><span class="s1">, params?: NodeWorker.SendMessageToWorkerParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.sendMessageToWorker'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Instructs the inspector to attach to running workers. Will also attach to new workers</span>
         <span class="s0">* as they start</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.enable'</span><span class="s1">, params?: NodeWorker.EnableParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.enable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Detaches from all running workers and disables attaching to new workers as they are started.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.disable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Detached from the worker with given sessionId.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.detach'</span><span class="s1">, params?: NodeWorker.DetachParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.detach'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables network tracking, prevents network events from being sent to the client.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Network.disable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables network tracking, network events will now be delivered to the client.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Network.enable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enable the NodeRuntime events except by `NodeRuntime.waitingForDisconnect`.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeRuntime.enable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disable NodeRuntime events</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeRuntime.disable'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enable the `NodeRuntime.waitingForDisconnect`.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeRuntime.notifyWhenWaitingForDisconnect'</span><span class="s1">, params?: NodeRuntime.NotifyWhenWaitingForDisconnectParameterType, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">post(method: </span><span class="s3">'NodeRuntime.notifyWhenWaitingForDisconnect'</span><span class="s1">, callback?: (err: Error | </span><span class="s4">null</span><span class="s1">) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">void</span><span class="s1">;</span>

        <span class="s1">addListener(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, message: InspectorNotification&lt;object&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">): boolean;</span>
        <span class="s1">on(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Activate inspector on host and port. Equivalent to `node --inspect=[[host:]port]`, but can be done programmatically after node has</span>
     <span class="s0">* started.</span>
     <span class="s0">*</span>
     <span class="s0">* If wait is `true`, will block until a client has connected to the inspect port</span>
     <span class="s0">* and flow control has been passed to the debugger client.</span>
     <span class="s0">*</span>
     <span class="s0">* See the [security warning](https://nodejs.org/docs/latest-v20.x/api/cli.html#warning-binding-inspector-to-a-public-ipport-combination-is-insecure)</span>
     <span class="s0">* regarding the `host` parameter usage.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">port Port to listen on for inspector connections. Defaults to what was specified on the CLI.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">host Host to listen on for inspector connections. Defaults to what was specified on the CLI.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">wait Block until a client has connected. Defaults to what was specified on the CLI.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">Disposable that calls `inspector.close()`.</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s1">open(port?: number, host?: string, wait?: boolean): Disposable;</span>

    <span class="s0">/**</span>
     <span class="s0">* Deactivate the inspector. Blocks until there are no active connections.</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s1">close(): </span><span class="s4">void</span><span class="s1">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Return the URL of the active inspector, or `undefined` if there is none.</span>
     <span class="s0">*</span>
     <span class="s0">* ```console</span>
     <span class="s0">* $ node --inspect -p 'inspector.url()'</span>
     <span class="s0">* Debugger listening on ws://127.0.0.1:9229/166e272e-7a30-4d09-97ce-f1c012b43c34</span>
     <span class="s0">* For help, see: https://nodejs.org/en/docs/inspector</span>
     <span class="s0">* ws://127.0.0.1:9229/166e272e-7a30-4d09-97ce-f1c012b43c34</span>
     <span class="s0">*</span>
     <span class="s0">* $ node --inspect=localhost:3000 -p 'inspector.url()'</span>
     <span class="s0">* Debugger listening on ws://localhost:3000/51cf8d0e-3c36-4c59-8efd-54519839e56a</span>
     <span class="s0">* For help, see: https://nodejs.org/en/docs/inspector</span>
     <span class="s0">* ws://localhost:3000/51cf8d0e-3c36-4c59-8efd-54519839e56a</span>
     <span class="s0">*</span>
     <span class="s0">* $ node -p 'inspector.url()'</span>
     <span class="s0">* undefined</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s1">url(): string | undefined;</span>

    <span class="s0">/**</span>
     <span class="s0">* Blocks until a client (existing or connected later) has sent `Runtime.runIfWaitingForDebugger` command.</span>
     <span class="s0">* </span>
     <span class="s0">* An exception will be thrown if there is no active inspector.</span>
     <span class="s0">* </span><span class="s2">@since </span><span class="s0">v12.7.0</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s1">waitForDebugger(): </span><span class="s4">void</span><span class="s1">;</span>

    <span class="s0">// These methods are exposed by the V8 inspector console API (inspector/v8-console.h).</span>
    <span class="s0">// The method signatures differ from those of the Node.js console, and are deliberately</span>
    <span class="s0">// typed permissively.</span>
    <span class="s4">interface </span><span class="s1">InspectorConsole {</span>
        <span class="s1">debug(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">error(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">info(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">log(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">warn(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">dir(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">dirxml(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">table(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">trace(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">group(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">groupCollapsed(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">groupEnd(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">clear(...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">count(label?: any): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">countReset(label?: any): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">assert(value?: any, ...data: any[]): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">profile(label?: any): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">profileEnd(label?: any): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">time(label?: any): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">timeLog(label?: any): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s1">timeStamp(label?: any): </span><span class="s4">void</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/**</span>
     <span class="s0">* An object to send messages to the remote inspector console.</span>
     <span class="s0">* </span><span class="s2">@since </span><span class="s0">v11.0.0</span>
     <span class="s0">*/</span>
    <span class="s4">const </span><span class="s1">console: InspectorConsole;</span>

    <span class="s0">// DevTools protocol event broadcast methods</span>
    <span class="s1">namespace Network {</span>
        <span class="s0">/**</span>
         <span class="s0">* This feature is only available with the `--experimental-network-inspection` flag enabled.</span>
         <span class="s0">*</span>
         <span class="s0">* Broadcasts the `Network.requestWillBeSent` event to connected frontends. This event indicates that</span>
         <span class="s0">* the application is about to send an HTTP request.</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v22.6.0</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s1">requestWillBeSent(params: RequestWillBeSentEventDataType): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This feature is only available with the `--experimental-network-inspection` flag enabled.</span>
         <span class="s0">*</span>
         <span class="s0">* Broadcasts the `Network.responseReceived` event to connected frontends. This event indicates that</span>
         <span class="s0">* HTTP response is available.</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v22.6.0</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s1">responseReceived(params: ResponseReceivedEventDataType): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This feature is only available with the `--experimental-network-inspection` flag enabled.</span>
         <span class="s0">*</span>
         <span class="s0">* Broadcasts the `Network.loadingFinished` event to connected frontends. This event indicates that</span>
         <span class="s0">* HTTP request has finished loading.</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v22.6.0</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s1">loadingFinished(params: LoadingFinishedEventDataType): </span><span class="s4">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This feature is only available with the `--experimental-network-inspection` flag enabled.</span>
         <span class="s0">*</span>
         <span class="s0">* Broadcasts the `Network.loadingFailed` event to connected frontends. This event indicates that</span>
         <span class="s0">* HTTP request has failed to load.</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v22.7.0</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s4">function </span><span class="s1">loadingFailed(params: LoadingFailedEventDataType): </span><span class="s4">void</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* The `node:inspector` module provides an API for interacting with the V8</span>
 <span class="s0">* inspector.</span>
 <span class="s0">*/</span>
<span class="s1">declare module </span><span class="s3">'node:inspector' </span><span class="s1">{</span>
    <span class="s4">export </span><span class="s1">* from </span><span class="s3">'inspector'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* The `node:inspector/promises` module provides an API for interacting with the V8</span>
 <span class="s0">* inspector.</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">[source](https://github.com/nodejs/node/blob/v20.x/lib/inspector/promises.js)</span>
 <span class="s0">* </span><span class="s2">@since </span><span class="s0">v19.0.0</span>
 <span class="s0">*/</span>
<span class="s1">declare module </span><span class="s3">'inspector/promises' </span><span class="s1">{</span>
    <span class="s4">import </span><span class="s1">EventEmitter = require(</span><span class="s3">'node:events'</span><span class="s1">);</span>
    <span class="s4">import </span><span class="s1">{</span>
        <span class="s1">open,</span>
        <span class="s1">close,</span>
        <span class="s1">url,</span>
        <span class="s1">waitForDebugger,</span>
        <span class="s1">console,</span>
        <span class="s1">InspectorNotification,</span>
        <span class="s1">Schema,</span>
        <span class="s1">Runtime,</span>
        <span class="s1">Debugger,</span>
        <span class="s1">Console,</span>
        <span class="s1">Profiler,</span>
        <span class="s1">HeapProfiler,</span>
        <span class="s1">NodeTracing,</span>
        <span class="s1">NodeWorker,</span>
        <span class="s1">Network,</span>
        <span class="s1">NodeRuntime,</span>
    <span class="s1">} from </span><span class="s3">'inspector'</span><span class="s1">;</span>

    <span class="s0">/**</span>
     <span class="s0">* The `inspector.Session` is used for dispatching messages to the V8 inspector</span>
     <span class="s0">* back-end and receiving message responses and notifications.</span>
     <span class="s0">* </span><span class="s2">@since </span><span class="s0">v19.0.0</span>
     <span class="s0">*/</span>
    <span class="s4">class </span><span class="s1">Session </span><span class="s4">extends </span><span class="s1">EventEmitter {</span>
        <span class="s0">/**</span>
         <span class="s0">* Create a new instance of the `inspector.Session` class.</span>
         <span class="s0">* The inspector session needs to be connected through `session.connect()` before the messages can be dispatched to the inspector backend.</span>
         <span class="s0">*/</span>
        <span class="s1">constructor();</span>

        <span class="s0">/**</span>
         <span class="s0">* Connects a session to the inspector back-end.</span>
         <span class="s0">*/</span>
        <span class="s1">connect(): </span><span class="s4">void</span><span class="s1">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Connects a session to the inspector back-end.</span>
         <span class="s0">* An exception will be thrown if this API was not called on a Worker thread.</span>
         <span class="s0">*/</span>
        <span class="s1">connectToMainThread(): </span><span class="s4">void</span><span class="s1">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Immediately close the session. All pending message callbacks will be called with an error.</span>
         <span class="s0">* `session.connect()` will need to be called to be able to send messages again.</span>
         <span class="s0">* Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.</span>
         <span class="s0">*/</span>
        <span class="s1">disconnect(): </span><span class="s4">void</span><span class="s1">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Posts a message to the inspector back-end.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { Session } from 'node:inspector/promises';</span>
         <span class="s0">* try {</span>
         <span class="s0">*   const session = new Session();</span>
         <span class="s0">*   session.connect();</span>
         <span class="s0">*   const result = await session.post('Runtime.evaluate', { expression: '2 + 2' });</span>
         <span class="s0">*   console.log(result);</span>
         <span class="s0">* } catch (error) {</span>
         <span class="s0">*   console.error(error);</span>
         <span class="s0">* }</span>
         <span class="s0">* // Output: { result: { type: 'number', value: 4, description: '4' } } </span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The latest version of the V8 inspector protocol is published on the</span>
         <span class="s0">* [Chrome DevTools Protocol Viewer](https://chromedevtools.github.io/devtools-protocol/v8/).</span>
         <span class="s0">*</span>
         <span class="s0">* Node.js inspector supports all the Chrome DevTools Protocol domains declared</span>
         <span class="s0">* by V8. Chrome DevTools Protocol domain provides an interface for interacting</span>
         <span class="s0">* with one of the runtime agents used to inspect the application state and listen</span>
         <span class="s0">* to the run-time events.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: string, params?: object): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns supported domains.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Schema.getDomains'</span><span class="s1">): Promise&lt;Schema.GetDomainsReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Evaluates expression on global object.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.evaluate'</span><span class="s1">, params?: Runtime.EvaluateParameterType): Promise&lt;Runtime.EvaluateReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Add handler to promise with given promise object id.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.awaitPromise'</span><span class="s1">, params?: Runtime.AwaitPromiseParameterType): Promise&lt;Runtime.AwaitPromiseReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Calls function with given declaration on the given object. Object group of the result is inherited from the target object.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.callFunctionOn'</span><span class="s1">, params?: Runtime.CallFunctionOnParameterType): Promise&lt;Runtime.CallFunctionOnReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns properties of a given object. Object group of the result is inherited from the target object.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.getProperties'</span><span class="s1">, params?: Runtime.GetPropertiesParameterType): Promise&lt;Runtime.GetPropertiesReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Releases remote object with given id.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.releaseObject'</span><span class="s1">, params?: Runtime.ReleaseObjectParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Releases all remote objects that belong to a given group.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.releaseObjectGroup'</span><span class="s1">, params?: Runtime.ReleaseObjectGroupParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Tells inspected instance to run if it was waiting for debugger to attach.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.runIfWaitingForDebugger'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables reporting of execution contexts creation by means of &lt;code&gt;executionContextCreated&lt;/code&gt; event. When the reporting gets enabled the event will be sent immediately for each existing execution context.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.enable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables reporting of execution contexts creation.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.disable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Discards collected exceptions and console API calls.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.discardConsoleEntries'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.setCustomObjectFormatterEnabled'</span><span class="s1">, params?: Runtime.SetCustomObjectFormatterEnabledParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Compiles expression.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.compileScript'</span><span class="s1">, params?: Runtime.CompileScriptParameterType): Promise&lt;Runtime.CompileScriptReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Runs script with given id in a given context.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.runScript'</span><span class="s1">, params?: Runtime.RunScriptParameterType): Promise&lt;Runtime.RunScriptReturnType&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.queryObjects'</span><span class="s1">, params?: Runtime.QueryObjectsParameterType): Promise&lt;Runtime.QueryObjectsReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns all let, const and class variables from global scope.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Runtime.globalLexicalScopeNames'</span><span class="s1">, params?: Runtime.GlobalLexicalScopeNamesParameterType): Promise&lt;Runtime.GlobalLexicalScopeNamesReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.enable'</span><span class="s1">): Promise&lt;Debugger.EnableReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables debugger for given page.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.disable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Activates / deactivates all breakpoints on the page.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBreakpointsActive'</span><span class="s1">, params?: Debugger.SetBreakpointsActiveParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setSkipAllPauses'</span><span class="s1">, params?: Debugger.SetSkipAllPausesParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in &lt;code&gt;locations&lt;/code&gt; property. Further matching script parsing will result in subsequent &lt;code&gt;breakpointResolved&lt;/code&gt; events issued. This logical breakpoint will survive page reloads.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBreakpointByUrl'</span><span class="s1">, params?: Debugger.SetBreakpointByUrlParameterType): Promise&lt;Debugger.SetBreakpointByUrlReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets JavaScript breakpoint at a given location.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBreakpoint'</span><span class="s1">, params?: Debugger.SetBreakpointParameterType): Promise&lt;Debugger.SetBreakpointReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Removes JavaScript breakpoint.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.removeBreakpoint'</span><span class="s1">, params?: Debugger.RemoveBreakpointParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.getPossibleBreakpoints'</span><span class="s1">, params?: Debugger.GetPossibleBreakpointsParameterType): Promise&lt;Debugger.GetPossibleBreakpointsReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Continues execution until specific location is reached.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.continueToLocation'</span><span class="s1">, params?: Debugger.ContinueToLocationParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.pauseOnAsyncCall'</span><span class="s1">, params?: Debugger.PauseOnAsyncCallParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Steps over the statement.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.stepOver'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Steps into the function call.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.stepInto'</span><span class="s1">, params?: Debugger.StepIntoParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Steps out of the function call.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.stepOut'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Stops on the next JavaScript statement.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.pause'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.scheduleStepIntoAsync'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resumes JavaScript execution.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.resume'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns stack trace with given &lt;code&gt;stackTraceId&lt;/code&gt;.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.getStackTrace'</span><span class="s1">, params?: Debugger.GetStackTraceParameterType): Promise&lt;Debugger.GetStackTraceReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Searches for given string in script content.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.searchInContent'</span><span class="s1">, params?: Debugger.SearchInContentParameterType): Promise&lt;Debugger.SearchInContentReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Edits JavaScript source live.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setScriptSource'</span><span class="s1">, params?: Debugger.SetScriptSourceParameterType): Promise&lt;Debugger.SetScriptSourceReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Restarts particular call frame from the beginning.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.restartFrame'</span><span class="s1">, params?: Debugger.RestartFrameParameterType): Promise&lt;Debugger.RestartFrameReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns source for the script with given id.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.getScriptSource'</span><span class="s1">, params?: Debugger.GetScriptSourceParameterType): Promise&lt;Debugger.GetScriptSourceReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is &lt;code&gt;none&lt;/code&gt;.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setPauseOnExceptions'</span><span class="s1">, params?: Debugger.SetPauseOnExceptionsParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Evaluates expression on a given call frame.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.evaluateOnCallFrame'</span><span class="s1">, params?: Debugger.EvaluateOnCallFrameParameterType): Promise&lt;Debugger.EvaluateOnCallFrameReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setVariableValue'</span><span class="s1">, params?: Debugger.SetVariableValueParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Changes return value in top frame. Available only at return break position.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setReturnValue'</span><span class="s1">, params?: Debugger.SetReturnValueParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables or disables async call stacks tracking.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setAsyncCallStackDepth'</span><span class="s1">, params?: Debugger.SetAsyncCallStackDepthParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBlackboxPatterns'</span><span class="s1">, params?: Debugger.SetBlackboxPatternsParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.</span>
         <span class="s0">* </span><span class="s2">@experimental</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Debugger.setBlackboxedRanges'</span><span class="s1">, params?: Debugger.SetBlackboxedRangesParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables console domain, sends the messages collected so far to the client by means of the &lt;code&gt;messageAdded&lt;/code&gt; notification.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Console.enable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables console domain, prevents further console messages from being reported to the client.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Console.disable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Does nothing.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Console.clearMessages'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.enable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.disable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.setSamplingInterval'</span><span class="s1">, params?: Profiler.SetSamplingIntervalParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.start'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.stop'</span><span class="s1">): Promise&lt;Profiler.StopReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.startPreciseCoverage'</span><span class="s1">, params?: Profiler.StartPreciseCoverageParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.stopPreciseCoverage'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.takePreciseCoverage'</span><span class="s1">): Promise&lt;Profiler.TakePreciseCoverageReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Profiler.getBestEffortCoverage'</span><span class="s1">): Promise&lt;Profiler.GetBestEffortCoverageReturnType&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.enable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.disable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.startTrackingHeapObjects'</span><span class="s1">, params?: HeapProfiler.StartTrackingHeapObjectsParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.stopTrackingHeapObjects'</span><span class="s1">, params?: HeapProfiler.StopTrackingHeapObjectsParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.takeHeapSnapshot'</span><span class="s1">, params?: HeapProfiler.TakeHeapSnapshotParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.collectGarbage'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.getObjectByHeapObjectId'</span><span class="s1">, params?: HeapProfiler.GetObjectByHeapObjectIdParameterType): Promise&lt;HeapProfiler.GetObjectByHeapObjectIdReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.addInspectedHeapObject'</span><span class="s1">, params?: HeapProfiler.AddInspectedHeapObjectParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.getHeapObjectId'</span><span class="s1">, params?: HeapProfiler.GetHeapObjectIdParameterType): Promise&lt;HeapProfiler.GetHeapObjectIdReturnType&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.startSampling'</span><span class="s1">, params?: HeapProfiler.StartSamplingParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.stopSampling'</span><span class="s1">): Promise&lt;HeapProfiler.StopSamplingReturnType&gt;;</span>
        <span class="s1">post(method: </span><span class="s3">'HeapProfiler.getSamplingProfile'</span><span class="s1">): Promise&lt;HeapProfiler.GetSamplingProfileReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets supported tracing categories.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeTracing.getCategories'</span><span class="s1">): Promise&lt;NodeTracing.GetCategoriesReturnType&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Start trace events collection.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeTracing.start'</span><span class="s1">, params?: NodeTracing.StartParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Stop trace events collection. Remaining collected events will be sent as a sequence of</span>
         <span class="s0">* dataCollected events followed by tracingComplete event.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeTracing.stop'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends protocol message over session with given id.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.sendMessageToWorker'</span><span class="s1">, params?: NodeWorker.SendMessageToWorkerParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Instructs the inspector to attach to running workers. Will also attach to new workers</span>
         <span class="s0">* as they start</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.enable'</span><span class="s1">, params?: NodeWorker.EnableParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Detaches from all running workers and disables attaching to new workers as they are started.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.disable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Detached from the worker with given sessionId.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeWorker.detach'</span><span class="s1">, params?: NodeWorker.DetachParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables network tracking, prevents network events from being sent to the client.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Network.disable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables network tracking, network events will now be delivered to the client.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'Network.enable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enable the NodeRuntime events except by `NodeRuntime.waitingForDisconnect`.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeRuntime.enable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disable NodeRuntime events</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeRuntime.disable'</span><span class="s1">): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enable the `NodeRuntime.waitingForDisconnect`.</span>
         <span class="s0">*/</span>
        <span class="s1">post(method: </span><span class="s3">'NodeRuntime.notifyWhenWaitingForDisconnect'</span><span class="s1">, params?: NodeRuntime.NotifyWhenWaitingForDisconnectParameterType): Promise&lt;</span><span class="s4">void</span><span class="s1">&gt;;</span>

        <span class="s1">addListener(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">addListener(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">addListener(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">emit(event: string | symbol, ...args: any[]): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, message: InspectorNotification&lt;object&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">): boolean;</span>
        <span class="s1">emit(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">): boolean;</span>
        <span class="s1">on(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">on(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">on(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">once(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">once(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependListener(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">prependListener(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: string, listener: (...args: any[]) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emitted when any notification from the V8 Inspector is received.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'inspectorNotification'</span><span class="s1">, listener: (message: InspectorNotification&lt;object&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new execution context is created.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.executionContextCreated'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextCreatedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when execution context is destroyed.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.executionContextDestroyed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExecutionContextDestroyedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when all executionContexts were cleared in browser</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.executionContextsCleared'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when exception was thrown and unhandled.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.exceptionThrown'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionThrownEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when unhandled exception was revoked.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.exceptionRevoked'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ExceptionRevokedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when console API was called.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.consoleAPICalled'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.ConsoleAPICalledEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when object should be inspected (for example, as a result of inspect() command line API call).</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Runtime.inspectRequested'</span><span class="s1">, listener: (message: InspectorNotification&lt;Runtime.InspectRequestedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.scriptParsed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptParsedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when virtual machine fails to parse the script.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.scriptFailedToParse'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.ScriptFailedToParseEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when breakpoint is resolved to an actual script and location.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.breakpointResolved'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.BreakpointResolvedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.paused'</span><span class="s1">, listener: (message: InspectorNotification&lt;Debugger.PausedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when the virtual machine resumed execution.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Debugger.resumed'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when new console message is added.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Console.messageAdded'</span><span class="s1">, listener: (message: InspectorNotification&lt;Console.MessageAddedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sent when new profile recording is started using console.profile() call.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Profiler.consoleProfileStarted'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileStartedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Profiler.consoleProfileFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Profiler.ConsoleProfileFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.AddHeapSnapshotChunkEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.resetProfiles'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.ReportHeapSnapshotProgressEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.lastSeenObjectId'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.LastSeenObjectIdEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If heap objects tracking has been started then backend may send update for one or more fragments</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'HeapProfiler.heapStatsUpdate'</span><span class="s1">, listener: (message: InspectorNotification&lt;HeapProfiler.HeapStatsUpdateEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains an bucket of collected trace events.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeTracing.dataCollected'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeTracing.DataCollectedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Signals that tracing is stopped and there is no trace buffers pending flush, all data were</span>
         <span class="s0">* delivered via dataCollected events.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeTracing.tracingComplete'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when attached to a worker.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeWorker.attachedToWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.AttachedToWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Issued when detached from the worker.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeWorker.detachedFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.DetachedFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Notifies about a new protocol message received from the session</span>
         <span class="s0">* (session ID is provided in attachedToWorker notification).</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeWorker.receivedMessageFromWorker'</span><span class="s1">, listener: (message: InspectorNotification&lt;NodeWorker.ReceivedMessageFromWorkerEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when page is about to send HTTP request.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Network.requestWillBeSent'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.RequestWillBeSentEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Fired when HTTP response is available.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Network.responseReceived'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.ResponseReceivedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Network.loadingFailed'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFailedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'Network.loadingFinished'</span><span class="s1">, listener: (message: InspectorNotification&lt;Network.LoadingFinishedEventDataType&gt;) =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired instead of `Runtime.executionContextDestroyed` when</span>
         <span class="s0">* enabled.</span>
         <span class="s0">* It is fired when the Node process finished all code execution and is</span>
         <span class="s0">* waiting for all frontends to disconnect.</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeRuntime.waitingForDisconnect'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This event is fired when the runtime is waiting for the debugger. For</span>
         <span class="s0">* example, when inspector.waitingForDebugger is called</span>
         <span class="s0">*/</span>
        <span class="s1">prependOnceListener(event: </span><span class="s3">'NodeRuntime.waitingForDebugger'</span><span class="s1">, listener: () =&gt; </span><span class="s4">void</span><span class="s1">): </span><span class="s4">this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s4">export </span><span class="s1">{</span>
        <span class="s1">Session,</span>
        <span class="s1">open,</span>
        <span class="s1">close,</span>
        <span class="s1">url,</span>
        <span class="s1">waitForDebugger,</span>
        <span class="s1">console,</span>
        <span class="s1">InspectorNotification,</span>
        <span class="s1">Schema,</span>
        <span class="s1">Runtime,</span>
        <span class="s1">Debugger,</span>
        <span class="s1">Console,</span>
        <span class="s1">Profiler,</span>
        <span class="s1">HeapProfiler,</span>
        <span class="s1">NodeTracing,</span>
        <span class="s1">NodeWorker,</span>
        <span class="s1">Network,</span>
        <span class="s1">NodeRuntime,</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* The `node:inspector/promises` module provides an API for interacting with the V8</span>
 <span class="s0">* inspector.</span>
 <span class="s0">* </span><span class="s2">@since </span><span class="s0">v19.0.0</span>
 <span class="s0">*/</span>
<span class="s1">declare module </span><span class="s3">'node:inspector/promises' </span><span class="s1">{</span>
    <span class="s4">export </span><span class="s1">* from </span><span class="s3">'inspector/promises'</span><span class="s1">;</span>
<span class="s1">}</span>
</pre>
</body>
</html>