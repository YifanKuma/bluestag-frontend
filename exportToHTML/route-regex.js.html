<html>
<head>
<title>route-regex.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
route-regex.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">getNamedMiddlewareRegex: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getNamedRouteRegex: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getRouteRegex: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">getNamedMiddlewareRegex: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getNamedMiddlewareRegex;</span>
    <span class="s1">},</span>
    <span class="s1">getNamedRouteRegex: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getNamedRouteRegex;</span>
    <span class="s1">},</span>
    <span class="s1">getRouteRegex: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getRouteRegex;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_interceptionroutes = require(</span><span class="s0">&quot;./interception-routes&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_escaperegexp = require(</span><span class="s0">&quot;../../escape-regexp&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removetrailingslash = require(</span><span class="s0">&quot;./remove-trailing-slash&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getdynamicparam = require(</span><span class="s0">&quot;./get-dynamic-param&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">getParametrizedRoute(route, includeSuffix, includePrefix) {</span>
    <span class="s2">const </span><span class="s1">groups = {};</span>
    <span class="s2">let </span><span class="s1">groupIndex = </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">segments = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">segment of (</span><span class="s3">0</span><span class="s1">, _removetrailingslash.removeTrailingSlash)(route).slice(</span><span class="s3">1</span><span class="s1">).split(</span><span class="s0">'/'</span><span class="s1">)){</span>
        <span class="s2">const </span><span class="s1">markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=&gt;segment.startsWith(m));</span>
        <span class="s2">const </span><span class="s1">paramMatches = segment.match(_getdynamicparam.PARAMETER_PATTERN) </span><span class="s4">// Check for parameters</span>
        <span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(markerMatch &amp;&amp; paramMatches &amp;&amp; paramMatches[</span><span class="s3">2</span><span class="s1">]) {</span>
            <span class="s2">const </span><span class="s1">{ key, optional, repeat } = (</span><span class="s3">0</span><span class="s1">, _getdynamicparam.parseMatchedParameter)(paramMatches[</span><span class="s3">2</span><span class="s1">]);</span>
            <span class="s1">groups[key] = {</span>
                <span class="s1">pos: groupIndex++,</span>
                <span class="s1">repeat,</span>
                <span class="s1">optional</span>
            <span class="s1">};</span>
            <span class="s1">segments.push(</span><span class="s0">&quot;/&quot; </span><span class="s1">+ (</span><span class="s3">0</span><span class="s1">, _escaperegexp.escapeStringRegexp)(markerMatch) + </span><span class="s0">&quot;([^/]+?)&quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(paramMatches &amp;&amp; paramMatches[</span><span class="s3">2</span><span class="s1">]) {</span>
            <span class="s2">const </span><span class="s1">{ key, repeat, optional } = (</span><span class="s3">0</span><span class="s1">, _getdynamicparam.parseMatchedParameter)(paramMatches[</span><span class="s3">2</span><span class="s1">]);</span>
            <span class="s1">groups[key] = {</span>
                <span class="s1">pos: groupIndex++,</span>
                <span class="s1">repeat,</span>
                <span class="s1">optional</span>
            <span class="s1">};</span>
            <span class="s2">if </span><span class="s1">(includePrefix &amp;&amp; paramMatches[</span><span class="s3">1</span><span class="s1">]) {</span>
                <span class="s1">segments.push(</span><span class="s0">&quot;/&quot; </span><span class="s1">+ (</span><span class="s3">0</span><span class="s1">, _escaperegexp.escapeStringRegexp)(paramMatches[</span><span class="s3">1</span><span class="s1">]));</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">s = repeat ? optional ? </span><span class="s0">'(?:/(.+?))?' </span><span class="s1">: </span><span class="s0">'/(.+?)' </span><span class="s1">: </span><span class="s0">'/([^/]+?)'</span><span class="s1">;</span>
            <span class="s4">// Remove the leading slash if includePrefix already added it.</span>
            <span class="s2">if </span><span class="s1">(includePrefix &amp;&amp; paramMatches[</span><span class="s3">1</span><span class="s1">]) {</span>
                <span class="s1">s = s.substring(</span><span class="s3">1</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">segments.push(s);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">segments.push(</span><span class="s0">&quot;/&quot; </span><span class="s1">+ (</span><span class="s3">0</span><span class="s1">, _escaperegexp.escapeStringRegexp)(segment));</span>
        <span class="s1">}</span>
        <span class="s4">// If there's a suffix, add it to the segments if it's enabled.</span>
        <span class="s2">if </span><span class="s1">(includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[</span><span class="s3">3</span><span class="s1">]) {</span>
            <span class="s1">segments.push((</span><span class="s3">0</span><span class="s1">, _escaperegexp.escapeStringRegexp)(paramMatches[</span><span class="s3">3</span><span class="s1">]));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">parameterizedRoute: segments.join(</span><span class="s0">''</span><span class="s1">),</span>
        <span class="s1">groups</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getRouteRegex(normalizedRoute, param) {</span>
    <span class="s2">let </span><span class="s1">{ includeSuffix = </span><span class="s2">false</span><span class="s1">, includePrefix = </span><span class="s2">false</span><span class="s1">, excludeOptionalTrailingSlash = </span><span class="s2">false </span><span class="s1">} = param === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? {} : param;</span>
    <span class="s2">const </span><span class="s1">{ parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute, includeSuffix, includePrefix);</span>
    <span class="s2">let </span><span class="s1">re = parameterizedRoute;</span>
    <span class="s2">if </span><span class="s1">(!excludeOptionalTrailingSlash) {</span>
        <span class="s1">re += </span><span class="s0">'(?:/)?'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">re: </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">&quot;^&quot; </span><span class="s1">+ re + </span><span class="s0">&quot;$&quot;</span><span class="s1">),</span>
        <span class="s1">groups: groups</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Builds a function to generate a minimal routeKey using only a-z and minimal</span>
 <span class="s4">* number of characters.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">buildGetSafeRouteKey() {</span>
    <span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">()=&gt;{</span>
        <span class="s2">let </span><span class="s1">routeKey = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">j = ++i;</span>
        <span class="s2">while</span><span class="s1">(j &gt; </span><span class="s3">0</span><span class="s1">){</span>
            <span class="s1">routeKey += String.fromCharCode(</span><span class="s3">97 </span><span class="s1">+ (j - </span><span class="s3">1</span><span class="s1">) % </span><span class="s3">26</span><span class="s1">);</span>
            <span class="s1">j = Math.floor((j - </span><span class="s3">1</span><span class="s1">) / </span><span class="s3">26</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">routeKey;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSafeKeyFromSegment(param) {</span>
    <span class="s2">let </span><span class="s1">{ interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix, backreferenceDuplicateKeys } = param;</span>
    <span class="s2">const </span><span class="s1">{ key, optional, repeat } = (</span><span class="s3">0</span><span class="s1">, _getdynamicparam.parseMatchedParameter)(segment);</span>
    <span class="s4">// replace any non-word characters since they can break</span>
    <span class="s4">// the named regex</span>
    <span class="s2">let </span><span class="s1">cleanedKey = key.replace(</span><span class="s5">/\W/g</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(keyPrefix) {</span>
        <span class="s1">cleanedKey = </span><span class="s0">&quot;&quot; </span><span class="s1">+ keyPrefix + cleanedKey;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">invalidKey = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s4">// check if the key is still invalid and fallback to using a known</span>
    <span class="s4">// safe key</span>
    <span class="s2">if </span><span class="s1">(cleanedKey.length === </span><span class="s3">0 </span><span class="s1">|| cleanedKey.length &gt; </span><span class="s3">30</span><span class="s1">) {</span>
        <span class="s1">invalidKey = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!isNaN(parseInt(cleanedKey.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">1</span><span class="s1">)))) {</span>
        <span class="s1">invalidKey = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(invalidKey) {</span>
        <span class="s1">cleanedKey = getSafeRouteKey();</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">duplicateKey = cleanedKey </span><span class="s2">in </span><span class="s1">routeKeys;</span>
    <span class="s2">if </span><span class="s1">(keyPrefix) {</span>
        <span class="s1">routeKeys[cleanedKey] = </span><span class="s0">&quot;&quot; </span><span class="s1">+ keyPrefix + key;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">routeKeys[cleanedKey] = key;</span>
    <span class="s1">}</span>
    <span class="s4">// if the segment has an interception marker, make sure that's part of the regex pattern</span>
    <span class="s4">// this is to ensure that the route with the interception marker doesn't incorrectly match</span>
    <span class="s4">// the non-intercepted route (ie /app/(.)[username] should not match /app/[username])</span>
    <span class="s2">const </span><span class="s1">interceptionPrefix = interceptionMarker ? (</span><span class="s3">0</span><span class="s1">, _escaperegexp.escapeStringRegexp)(interceptionMarker) : </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">pattern;</span>
    <span class="s2">if </span><span class="s1">(duplicateKey &amp;&amp; backreferenceDuplicateKeys) {</span>
        <span class="s4">// Use a backreference to the key to ensure that the key is the same value</span>
        <span class="s4">// in each of the placeholders.</span>
        <span class="s1">pattern = </span><span class="s0">&quot;</span><span class="s6">\\</span><span class="s0">k&lt;&quot; </span><span class="s1">+ cleanedKey + </span><span class="s0">&quot;&gt;&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(repeat) {</span>
        <span class="s1">pattern = </span><span class="s0">&quot;(?&lt;&quot; </span><span class="s1">+ cleanedKey + </span><span class="s0">&quot;&gt;.+?)&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">pattern = </span><span class="s0">&quot;(?&lt;&quot; </span><span class="s1">+ cleanedKey + </span><span class="s0">&quot;&gt;[^/]+?)&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">optional ? </span><span class="s0">&quot;(?:/&quot; </span><span class="s1">+ interceptionPrefix + pattern + </span><span class="s0">&quot;)?&quot; </span><span class="s1">: </span><span class="s0">&quot;/&quot; </span><span class="s1">+ interceptionPrefix + pattern;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getNamedParametrizedRoute(route, prefixRouteKeys, includeSuffix, includePrefix, backreferenceDuplicateKeys) {</span>
    <span class="s2">const </span><span class="s1">getSafeRouteKey = buildGetSafeRouteKey();</span>
    <span class="s2">const </span><span class="s1">routeKeys = {};</span>
    <span class="s2">const </span><span class="s1">segments = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">segment of (</span><span class="s3">0</span><span class="s1">, _removetrailingslash.removeTrailingSlash)(route).slice(</span><span class="s3">1</span><span class="s1">).split(</span><span class="s0">'/'</span><span class="s1">)){</span>
        <span class="s2">const </span><span class="s1">hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=&gt;segment.startsWith(m));</span>
        <span class="s2">const </span><span class="s1">paramMatches = segment.match(_getdynamicparam.PARAMETER_PATTERN) </span><span class="s4">// Check for parameters</span>
        <span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(hasInterceptionMarker &amp;&amp; paramMatches &amp;&amp; paramMatches[</span><span class="s3">2</span><span class="s1">]) {</span>
            <span class="s4">// If there's an interception marker, add it to the segments.</span>
            <span class="s1">segments.push(getSafeKeyFromSegment({</span>
                <span class="s1">getSafeRouteKey,</span>
                <span class="s1">interceptionMarker: paramMatches[</span><span class="s3">1</span><span class="s1">],</span>
                <span class="s1">segment: paramMatches[</span><span class="s3">2</span><span class="s1">],</span>
                <span class="s1">routeKeys,</span>
                <span class="s1">keyPrefix: prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : undefined,</span>
                <span class="s1">backreferenceDuplicateKeys</span>
            <span class="s1">}));</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(paramMatches &amp;&amp; paramMatches[</span><span class="s3">2</span><span class="s1">]) {</span>
            <span class="s4">// If there's a prefix, add it to the segments if it's enabled.</span>
            <span class="s2">if </span><span class="s1">(includePrefix &amp;&amp; paramMatches[</span><span class="s3">1</span><span class="s1">]) {</span>
                <span class="s1">segments.push(</span><span class="s0">&quot;/&quot; </span><span class="s1">+ (</span><span class="s3">0</span><span class="s1">, _escaperegexp.escapeStringRegexp)(paramMatches[</span><span class="s3">1</span><span class="s1">]));</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">s = getSafeKeyFromSegment({</span>
                <span class="s1">getSafeRouteKey,</span>
                <span class="s1">segment: paramMatches[</span><span class="s3">2</span><span class="s1">],</span>
                <span class="s1">routeKeys,</span>
                <span class="s1">keyPrefix: prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : undefined,</span>
                <span class="s1">backreferenceDuplicateKeys</span>
            <span class="s1">});</span>
            <span class="s4">// Remove the leading slash if includePrefix already added it.</span>
            <span class="s2">if </span><span class="s1">(includePrefix &amp;&amp; paramMatches[</span><span class="s3">1</span><span class="s1">]) {</span>
                <span class="s1">s = s.substring(</span><span class="s3">1</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">segments.push(s);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">segments.push(</span><span class="s0">&quot;/&quot; </span><span class="s1">+ (</span><span class="s3">0</span><span class="s1">, _escaperegexp.escapeStringRegexp)(segment));</span>
        <span class="s1">}</span>
        <span class="s4">// If there's a suffix, add it to the segments if it's enabled.</span>
        <span class="s2">if </span><span class="s1">(includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[</span><span class="s3">3</span><span class="s1">]) {</span>
            <span class="s1">segments.push((</span><span class="s3">0</span><span class="s1">, _escaperegexp.escapeStringRegexp)(paramMatches[</span><span class="s3">3</span><span class="s1">]));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">namedParameterizedRoute: segments.join(</span><span class="s0">''</span><span class="s1">),</span>
        <span class="s1">routeKeys</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getNamedRouteRegex(normalizedRoute, options) {</span>
    <span class="s2">var </span><span class="s1">_options_includeSuffix, _options_includePrefix, _options_backreferenceDuplicateKeys;</span>
    <span class="s2">const </span><span class="s1">result = getNamedParametrizedRoute(normalizedRoute, options.prefixRouteKeys, (_options_includeSuffix = options.includeSuffix) != </span><span class="s2">null </span><span class="s1">? _options_includeSuffix : </span><span class="s2">false</span><span class="s1">, (_options_includePrefix = options.includePrefix) != </span><span class="s2">null </span><span class="s1">? _options_includePrefix : </span><span class="s2">false</span><span class="s1">, (_options_backreferenceDuplicateKeys = options.backreferenceDuplicateKeys) != </span><span class="s2">null </span><span class="s1">? _options_backreferenceDuplicateKeys : </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s2">let </span><span class="s1">namedRegex = result.namedParameterizedRoute;</span>
    <span class="s2">if </span><span class="s1">(!options.excludeOptionalTrailingSlash) {</span>
        <span class="s1">namedRegex += </span><span class="s0">'(?:/)?'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">...getRouteRegex(normalizedRoute, options),</span>
        <span class="s1">namedRegex: </span><span class="s0">&quot;^&quot; </span><span class="s1">+ namedRegex + </span><span class="s0">&quot;$&quot;</span><span class="s1">,</span>
        <span class="s1">routeKeys: result.routeKeys</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getNamedMiddlewareRegex(normalizedRoute, options) {</span>
    <span class="s2">const </span><span class="s1">{ parameterizedRoute } = getParametrizedRoute(normalizedRoute, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">{ catchAll = </span><span class="s2">true </span><span class="s1">} = options;</span>
    <span class="s2">if </span><span class="s1">(parameterizedRoute === </span><span class="s0">'/'</span><span class="s1">) {</span>
        <span class="s2">let </span><span class="s1">catchAllRegex = catchAll ? </span><span class="s0">'.*' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">namedRegex: </span><span class="s0">&quot;^/&quot; </span><span class="s1">+ catchAllRegex + </span><span class="s0">&quot;$&quot;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s2">let </span><span class="s1">catchAllGroupedRegex = catchAll ? </span><span class="s0">'(?:(/.*)?)' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">namedRegex: </span><span class="s0">&quot;^&quot; </span><span class="s1">+ namedParameterizedRoute + catchAllGroupedRegex + </span><span class="s0">&quot;$&quot;</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=route-regex.js.map</span></pre>
</body>
</html>