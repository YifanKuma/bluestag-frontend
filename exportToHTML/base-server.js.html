<html>
<head>
<title>base-server.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #0037a6;}
.s7 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base-server.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">WrappedBuildError: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">WrappedBuildError: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">WrappedBuildError;</span>
    <span class="s1">},</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">Server;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../shared/lib/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_url = require(</span><span class="s0">&quot;url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_formathostname = require(</span><span class="s0">&quot;./lib/format-hostname&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;../shared/lib/router/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_runtimeconfigexternal = require(</span><span class="s0">&quot;../shared/lib/runtime-config.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils2 = require(</span><span class="s0">&quot;./utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_isbot = require(</span><span class="s0">&quot;../shared/lib/router/utils/is-bot&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_renderresult = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;./render-result&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_removetrailingslash = require(</span><span class="s0">&quot;../shared/lib/router/utils/remove-trailing-slash&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_denormalizepagepath = require(</span><span class="s0">&quot;../shared/lib/page-path/denormalize-page-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../build/output/log&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_serverutils = require(</span><span class="s0">&quot;./server-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_iserror = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../lib/is-error&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_requestmeta = require(</span><span class="s0">&quot;./request-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removepathprefix = require(</span><span class="s0">&quot;../shared/lib/router/utils/remove-path-prefix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_gethostname = require(</span><span class="s0">&quot;../shared/lib/get-hostname&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parseurl = require(</span><span class="s0">&quot;../shared/lib/router/utils/parse-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getnextpathnameinfo = require(</span><span class="s0">&quot;../shared/lib/router/utils/get-next-pathname-info&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterheaders = require(</span><span class="s0">&quot;../client/components/app-router-headers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_localeroutenormalizer = require(</span><span class="s0">&quot;./normalizers/locale-route-normalizer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_defaultroutematchermanager = require(</span><span class="s0">&quot;./route-matcher-managers/default-route-matcher-manager&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppageroutematcherprovider = require(</span><span class="s0">&quot;./route-matcher-providers/app-page-route-matcher-provider&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuteroutematcherprovider = require(</span><span class="s0">&quot;./route-matcher-providers/app-route-route-matcher-provider&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pagesapiroutematcherprovider = require(</span><span class="s0">&quot;./route-matcher-providers/pages-api-route-matcher-provider&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pagesroutematcherprovider = require(</span><span class="s0">&quot;./route-matcher-providers/pages-route-matcher-provider&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_servermanifestloader = require(</span><span class="s0">&quot;./route-matcher-providers/helpers/manifest-loaders/server-manifest-loader&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_tracer = require(</span><span class="s0">&quot;./lib/trace/tracer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;./lib/trace/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_i18nprovider = require(</span><span class="s0">&quot;./lib/i18n-provider&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_sendresponse = require(</span><span class="s0">&quot;./send-response&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils3 = require(</span><span class="s0">&quot;./web/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants2 = require(</span><span class="s0">&quot;../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizelocalepath = require(</span><span class="s0">&quot;../shared/lib/i18n/normalize-locale-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_matchnextdatapathname = require(</span><span class="s0">&quot;./lib/match-next-data-pathname&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getroutefromassetpath = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../shared/lib/router/utils/get-route-from-asset-path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_rsc = require(</span><span class="s0">&quot;./normalizers/request/rsc&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_stripflightheaders = require(</span><span class="s0">&quot;./app-render/strip-flight-headers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_checks = require(</span><span class="s0">&quot;./route-modules/checks&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_prefetchrsc = require(</span><span class="s0">&quot;./normalizers/request/prefetch-rsc&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nextdata = require(</span><span class="s0">&quot;./normalizers/request/next-data&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_serveractionrequestmeta = require(</span><span class="s0">&quot;./lib/server-action-request-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_interceptionroutes = require(</span><span class="s0">&quot;../shared/lib/router/utils/interception-routes&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_toroute = require(</span><span class="s0">&quot;./lib/to-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_helpers = require(</span><span class="s0">&quot;./base-http/helpers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_patchsetheader = require(</span><span class="s0">&quot;./lib/patch-set-header&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ppr = require(</span><span class="s0">&quot;./lib/experimental/ppr&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_builtinrequestcontext = require(</span><span class="s0">&quot;./after/builtin-request-context&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_adapter = require(</span><span class="s0">&quot;./web/adapter&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fallback = require(</span><span class="s0">&quot;../lib/fallback&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segmentprefixrsc = require(</span><span class="s0">&quot;./normalizers/request/segment-prefix-rsc&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_streamingmetadata = require(</span><span class="s0">&quot;./lib/streaming-metadata&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_decodequerypathparameter = require(</span><span class="s0">&quot;./lib/decode-query-path-parameter&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nofallbackerrorexternal = require(</span><span class="s0">&quot;../shared/lib/no-fallback-error.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_handlers = require(</span><span class="s0">&quot;./use-cache/handlers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fixmojibake = require(</span><span class="s0">&quot;./lib/fix-mojibake&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_cachebustingsearchparam = require(</span><span class="s0">&quot;../shared/lib/router/utils/cache-busting-search-param&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_setcachebustingsearchparam = require(</span><span class="s0">&quot;../client/components/router-reducer/set-cache-busting-search-param&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">WrappedBuildError </span><span class="s2">extends </span><span class="s1">Error {</span>
    <span class="s1">constructor(innerError){</span>
        <span class="s2">super</span><span class="s1">();</span>
        <span class="s2">this</span><span class="s1">.innerError = innerError;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">Server {</span>
    <span class="s1">getServerComponentsHmrCache() {</span>
        <span class="s2">return this</span><span class="s1">.nextConfig.experimental.serverComponentsHmrCache ? globalThis.__serverComponentsHmrCache : undefined;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* This is used to persist cache scopes across</span>
   <span class="s4">* prefetch -&gt; full route requests for cache components</span>
   <span class="s4">* it's only fully used in dev</span>
   <span class="s4">*/ </span><span class="s1">constructor(options){</span>
        <span class="s2">var </span><span class="s1">_this_nextConfig_i18n, _this_nextConfig_experimental_amp, _this_nextConfig_i18n1;</span>
        <span class="s2">this</span><span class="s1">.handleRSCRequest = (req, _res, parsedUrl)=&gt;{</span>
            <span class="s2">var </span><span class="s1">_this_normalizers_segmentPrefetchRSC, _this_normalizers_prefetchRSC, _this_normalizers_rsc;</span>
            <span class="s2">if </span><span class="s1">(!parsedUrl.pathname) </span><span class="s2">return false</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">((_this_normalizers_segmentPrefetchRSC = </span><span class="s2">this</span><span class="s1">.normalizers.segmentPrefetchRSC) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_normalizers_segmentPrefetchRSC.match(parsedUrl.pathname)) {</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.normalizers.segmentPrefetchRSC.extract(parsedUrl.pathname);</span>
                <span class="s2">if </span><span class="s1">(!result) </span><span class="s2">return false</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">{ originalPathname, segmentPath } = result;</span>
                <span class="s1">parsedUrl.pathname = originalPathname;</span>
                <span class="s4">// Mark the request as a router prefetch request.</span>
                <span class="s1">req.headers[_approuterheaders.RSC_HEADER] = </span><span class="s0">'1'</span><span class="s1">;</span>
                <span class="s1">req.headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = </span><span class="s0">'1'</span><span class="s1">;</span>
                <span class="s1">req.headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] = segmentPath;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isRSCRequest'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isPrefetchRSCRequest'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'segmentPrefetchRSCRequest'</span><span class="s1">, segmentPath);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">((_this_normalizers_prefetchRSC = </span><span class="s2">this</span><span class="s1">.normalizers.prefetchRSC) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_normalizers_prefetchRSC.match(parsedUrl.pathname)) {</span>
                <span class="s1">parsedUrl.pathname = </span><span class="s2">this</span><span class="s1">.normalizers.prefetchRSC.normalize(parsedUrl.pathname, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s4">// Mark the request as a router prefetch request.</span>
                <span class="s1">req.headers[_approuterheaders.RSC_HEADER] = </span><span class="s0">'1'</span><span class="s1">;</span>
                <span class="s1">req.headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = </span><span class="s0">'1'</span><span class="s1">;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isRSCRequest'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isPrefetchRSCRequest'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">((_this_normalizers_rsc = </span><span class="s2">this</span><span class="s1">.normalizers.rsc) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_normalizers_rsc.match(parsedUrl.pathname)) {</span>
                <span class="s1">parsedUrl.pathname = </span><span class="s2">this</span><span class="s1">.normalizers.rsc.normalize(parsedUrl.pathname, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s4">// Mark the request as a RSC request.</span>
                <span class="s1">req.headers[_approuterheaders.RSC_HEADER] = </span><span class="s0">'1'</span><span class="s1">;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isRSCRequest'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(req.headers[</span><span class="s0">'x-now-route-matches'</span><span class="s1">]) {</span>
                <span class="s4">// If we didn't match, return with the flight headers stripped. If in</span>
                <span class="s4">// minimal mode we didn't match based on the path, this can't be a RSC</span>
                <span class="s4">// request. This is because Vercel only sends this header during</span>
                <span class="s4">// revalidation requests and we want the cache to instead depend on the</span>
                <span class="s4">// request path for flight information.</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _stripflightheaders.stripFlightHeaders)(req.headers);</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(req.headers[_approuterheaders.RSC_HEADER] === </span><span class="s0">'1'</span><span class="s1">) {</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isRSCRequest'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(req.headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] === </span><span class="s0">'1'</span><span class="s1">) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isPrefetchRSCRequest'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                    <span class="s2">const </span><span class="s1">segmentPrefetchRSCRequest = req.headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER];</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">segmentPrefetchRSCRequest === </span><span class="s0">'string'</span><span class="s1">) {</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'segmentPrefetchRSCRequest'</span><span class="s1">, segmentPrefetchRSCRequest);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// Otherwise just return without doing anything.</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(req.url) {</span>
                <span class="s2">const </span><span class="s1">parsed = (</span><span class="s3">0</span><span class="s1">, _url.parse)(req.url);</span>
                <span class="s1">parsed.pathname = parsedUrl.pathname;</span>
                <span class="s1">req.url = (</span><span class="s3">0</span><span class="s1">, _url.format)(parsed);</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.handleNextDataRequest = async (req, res, parsedUrl)=&gt;{</span>
            <span class="s2">const </span><span class="s1">middleware = </span><span class="s2">await this</span><span class="s1">.getMiddleware();</span>
            <span class="s2">const </span><span class="s1">params = (</span><span class="s3">0</span><span class="s1">, _matchnextdatapathname.matchNextDataPathname)(parsedUrl.pathname);</span>
            <span class="s4">// ignore for non-next data URLs</span>
            <span class="s2">if </span><span class="s1">(!params || !params.path) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(params.path[</span><span class="s3">0</span><span class="s1">] !== </span><span class="s2">this</span><span class="s1">.buildId) {</span>
                <span class="s4">// Ignore if its a middleware request when we aren't on edge.</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'middlewareInvoke'</span><span class="s1">)) {</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// Make sure to 404 if the buildId isn't correct</span>
                <span class="s2">await this</span><span class="s1">.render404(req, res, parsedUrl);</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// remove buildId from URL</span>
            <span class="s1">params.path.shift();</span>
            <span class="s2">const </span><span class="s1">lastParam = params.path[params.path.length - </span><span class="s3">1</span><span class="s1">];</span>
            <span class="s4">// show 404 if it doesn't end with .json</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">lastParam !== </span><span class="s0">'string' </span><span class="s1">|| !lastParam.endsWith(</span><span class="s0">'.json'</span><span class="s1">)) {</span>
                <span class="s2">await this</span><span class="s1">.render404(req, res, parsedUrl);</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// re-create page's pathname</span>
            <span class="s2">let </span><span class="s1">pathname = </span><span class="s0">`/</span><span class="s1">${params.path.join(</span><span class="s0">'/'</span><span class="s1">)}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">pathname = (</span><span class="s3">0</span><span class="s1">, _getroutefromassetpath.default)(pathname, </span><span class="s0">'.json'</span><span class="s1">);</span>
            <span class="s4">// ensure trailing slash is normalized per config</span>
            <span class="s2">if </span><span class="s1">(middleware) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.nextConfig.trailingSlash &amp;&amp; !pathname.endsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
                    <span class="s1">pathname += </span><span class="s0">'/'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.nextConfig.trailingSlash &amp;&amp; pathname.length &gt; </span><span class="s3">1 </span><span class="s1">&amp;&amp; pathname.endsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
                    <span class="s1">pathname = pathname.substring(</span><span class="s3">0</span><span class="s1">, pathname.length - </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.i18nProvider) {</span>
                <span class="s2">var </span><span class="s1">_req_headers_host;</span>
                <span class="s4">// Remove the port from the hostname if present.</span>
                <span class="s2">const </span><span class="s1">hostname = req == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_req_headers_host = req.headers.host) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _req_headers_host.split(</span><span class="s0">':'</span><span class="s1">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].toLowerCase();</span>
                <span class="s2">const </span><span class="s1">domainLocale = </span><span class="s2">this</span><span class="s1">.i18nProvider.detectDomainLocale(hostname);</span>
                <span class="s2">const </span><span class="s1">defaultLocale = (domainLocale == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: domainLocale.defaultLocale) ?? </span><span class="s2">this</span><span class="s1">.i18nProvider.config.defaultLocale;</span>
                <span class="s2">const </span><span class="s1">localePathResult = </span><span class="s2">this</span><span class="s1">.i18nProvider.analyze(pathname);</span>
                <span class="s4">// If the locale is detected from the path, we need to remove it</span>
                <span class="s4">// from the pathname.</span>
                <span class="s2">if </span><span class="s1">(localePathResult.detectedLocale) {</span>
                    <span class="s1">pathname = localePathResult.pathname;</span>
                <span class="s1">}</span>
                <span class="s4">// Update the query with the detected locale and default locale.</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">, localePathResult.detectedLocale);</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'defaultLocale'</span><span class="s1">, defaultLocale);</span>
                <span class="s4">// If the locale is not detected from the path, we need to mark that</span>
                <span class="s4">// it was not inferred from default.</span>
                <span class="s2">if </span><span class="s1">(!localePathResult.detectedLocale) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.removeRequestMeta)(req, </span><span class="s0">'localeInferredFromDefault'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s4">// If no locale was detected and we don't have middleware, we need</span>
                <span class="s4">// to render a 404 page.</span>
                <span class="s2">if </span><span class="s1">(!localePathResult.detectedLocale &amp;&amp; !middleware) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">, defaultLocale);</span>
                    <span class="s2">await this</span><span class="s1">.render404(req, res, parsedUrl);</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">parsedUrl.pathname = pathname;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isNextDataReq'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.handleNextImageRequest = ()=&gt;</span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.handleCatchallRenderRequest = ()=&gt;</span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.handleCatchallMiddlewareRequest = ()=&gt;</span><span class="s2">false</span><span class="s1">;</span>
        <span class="s4">/**</span>
   <span class="s4">* Normalizes a pathname without attaching any metadata from any matched</span>
   <span class="s4">* normalizer.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">pathname the pathname to normalize</span>
   <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the normalized pathname</span>
   <span class="s4">*/ </span><span class="s2">this</span><span class="s1">.normalize = (pathname)=&gt;{</span>
            <span class="s2">const </span><span class="s1">normalizers = [];</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.normalizers.data) {</span>
                <span class="s1">normalizers.push(</span><span class="s2">this</span><span class="s1">.normalizers.data);</span>
            <span class="s1">}</span>
            <span class="s4">// We have to put the segment prefetch normalizer before the RSC normalizer</span>
            <span class="s4">// because the RSC normalizer will match the prefetch RSC routes too.</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.normalizers.segmentPrefetchRSC) {</span>
                <span class="s1">normalizers.push(</span><span class="s2">this</span><span class="s1">.normalizers.segmentPrefetchRSC);</span>
            <span class="s1">}</span>
            <span class="s4">// We have to put the prefetch normalizer before the RSC normalizer</span>
            <span class="s4">// because the RSC normalizer will match the prefetch RSC routes too.</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.normalizers.prefetchRSC) {</span>
                <span class="s1">normalizers.push(</span><span class="s2">this</span><span class="s1">.normalizers.prefetchRSC);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.normalizers.rsc) {</span>
                <span class="s1">normalizers.push(</span><span class="s2">this</span><span class="s1">.normalizers.rsc);</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">normalizer of normalizers){</span>
                <span class="s2">if </span><span class="s1">(!normalizer.match(pathname)) </span><span class="s2">continue</span><span class="s1">;</span>
                <span class="s2">return </span><span class="s1">normalizer.normalize(pathname, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">pathname;</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.normalizeAndAttachMetadata = async (req, res, url)=&gt;{</span>
            <span class="s2">let </span><span class="s1">finished = </span><span class="s2">await this</span><span class="s1">.handleNextImageRequest(req, res, url);</span>
            <span class="s2">if </span><span class="s1">(finished) </span><span class="s2">return true</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.enabledDirectories.pages) {</span>
                <span class="s1">finished = </span><span class="s2">await this</span><span class="s1">.handleNextDataRequest(req, res, url);</span>
                <span class="s2">if </span><span class="s1">(finished) </span><span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.prepared = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.preparedPromise = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.customErrorNo404Warn = (</span><span class="s3">0</span><span class="s1">, _utils.execOnce)(()=&gt;{</span>
            <span class="s1">_log.warn(</span><span class="s0">`You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.</span><span class="s6">\n</span><span class="s0">See here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">{ dir = </span><span class="s0">'.'</span><span class="s1">, quiet = </span><span class="s2">false</span><span class="s1">, conf, dev = </span><span class="s2">false</span><span class="s1">, minimalMode = </span><span class="s2">false</span><span class="s1">, hostname, port, experimentalTestProxy } = options;</span>
        <span class="s2">this</span><span class="s1">.experimentalTestProxy = experimentalTestProxy;</span>
        <span class="s2">this</span><span class="s1">.serverOptions = options;</span>
        <span class="s2">this</span><span class="s1">.dir = require(</span><span class="s0">'path'</span><span class="s1">).resolve(dir);</span>
        <span class="s2">this</span><span class="s1">.quiet = quiet;</span>
        <span class="s2">this</span><span class="s1">.loadEnvConfig({</span>
            <span class="s1">dev</span>
        <span class="s1">});</span>
        <span class="s4">// TODO: should conf be normalized to prevent missing</span>
        <span class="s4">// values from causing issues as this can be user provided</span>
        <span class="s2">this</span><span class="s1">.nextConfig = conf;</span>
        <span class="s2">this</span><span class="s1">.hostname = hostname;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hostname) {</span>
            <span class="s4">// we format the hostname so that it can be fetched</span>
            <span class="s2">this</span><span class="s1">.fetchHostname = (</span><span class="s3">0</span><span class="s1">, _formathostname.formatHostname)(</span><span class="s2">this</span><span class="s1">.hostname);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.port = port;</span>
        <span class="s2">this</span><span class="s1">.distDir = require(</span><span class="s0">'path'</span><span class="s1">).join(</span><span class="s2">this</span><span class="s1">.dir, </span><span class="s2">this</span><span class="s1">.nextConfig.distDir);</span>
        <span class="s2">this</span><span class="s1">.publicDir = </span><span class="s2">this</span><span class="s1">.getPublicDir();</span>
        <span class="s2">this</span><span class="s1">.hasStaticDir = !minimalMode &amp;&amp; </span><span class="s2">this</span><span class="s1">.getHasStaticDir();</span>
        <span class="s2">this</span><span class="s1">.i18nProvider = ((_this_nextConfig_i18n = </span><span class="s2">this</span><span class="s1">.nextConfig.i18n) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_nextConfig_i18n.locales) ? </span><span class="s2">new </span><span class="s1">_i18nprovider.I18NProvider(</span><span class="s2">this</span><span class="s1">.nextConfig.i18n) : undefined;</span>
        <span class="s4">// Configure the locale normalizer, it's used for routes inside `pages/`.</span>
        <span class="s2">this</span><span class="s1">.localeNormalizer = </span><span class="s2">this</span><span class="s1">.i18nProvider ? </span><span class="s2">new </span><span class="s1">_localeroutenormalizer.LocaleRouteNormalizer(</span><span class="s2">this</span><span class="s1">.i18nProvider) : undefined;</span>
        <span class="s4">// Only serverRuntimeConfig needs the default</span>
        <span class="s4">// publicRuntimeConfig gets it's default in client/index.js</span>
        <span class="s2">const </span><span class="s1">{ serverRuntimeConfig = {}, publicRuntimeConfig, assetPrefix, generateEtags } = </span><span class="s2">this</span><span class="s1">.nextConfig;</span>
        <span class="s2">this</span><span class="s1">.buildId = </span><span class="s2">this</span><span class="s1">.getBuildId();</span>
        <span class="s4">// this is a hack to avoid Webpack knowing this is equal to this.minimalMode</span>
        <span class="s4">// because we replace this.minimalMode to true in production bundles.</span>
        <span class="s2">const </span><span class="s1">minimalModeKey = </span><span class="s0">'minimalMode'</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">[minimalModeKey] = minimalMode || !!process.env.NEXT_PRIVATE_MINIMAL_MODE;</span>
        <span class="s2">this</span><span class="s1">.enabledDirectories = </span><span class="s2">this</span><span class="s1">.getEnabledDirectories(dev);</span>
        <span class="s2">this</span><span class="s1">.isAppPPREnabled = </span><span class="s2">this</span><span class="s1">.enabledDirectories.app &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _ppr.checkIsAppPPREnabled)(</span><span class="s2">this</span><span class="s1">.nextConfig.experimental.ppr);</span>
        <span class="s2">this</span><span class="s1">.isAppSegmentPrefetchEnabled = </span><span class="s2">this</span><span class="s1">.enabledDirectories.app &amp;&amp; </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.clientSegmentCache === </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.normalizers = {</span>
            <span class="s4">// We should normalize the pathname from the RSC prefix only in minimal</span>
            <span class="s4">// mode as otherwise that route is not exposed external to the server as</span>
            <span class="s4">// we instead only rely on the headers.</span>
            <span class="s1">rsc: </span><span class="s2">this</span><span class="s1">.enabledDirectories.app &amp;&amp; </span><span class="s2">this</span><span class="s1">.minimalMode ? </span><span class="s2">new </span><span class="s1">_rsc.RSCPathnameNormalizer() : undefined,</span>
            <span class="s1">prefetchRSC: </span><span class="s2">this</span><span class="s1">.isAppPPREnabled &amp;&amp; </span><span class="s2">this</span><span class="s1">.minimalMode ? </span><span class="s2">new </span><span class="s1">_prefetchrsc.PrefetchRSCPathnameNormalizer() : undefined,</span>
            <span class="s1">segmentPrefetchRSC: </span><span class="s2">this</span><span class="s1">.isAppSegmentPrefetchEnabled &amp;&amp; </span><span class="s2">this</span><span class="s1">.minimalMode ? </span><span class="s2">new </span><span class="s1">_segmentprefixrsc.SegmentPrefixRSCPathnameNormalizer() : undefined,</span>
            <span class="s1">data: </span><span class="s2">this</span><span class="s1">.enabledDirectories.pages ? </span><span class="s2">new </span><span class="s1">_nextdata.NextDataPathnameNormalizer(</span><span class="s2">this</span><span class="s1">.buildId) : undefined</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.nextFontManifest = </span><span class="s2">this</span><span class="s1">.getNextFontManifest();</span>
        <span class="s1">process.env.NEXT_DEPLOYMENT_ID = </span><span class="s2">this</span><span class="s1">.nextConfig.deploymentId || </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.renderOpts = {</span>
            <span class="s1">dir: </span><span class="s2">this</span><span class="s1">.dir,</span>
            <span class="s1">supportsDynamicResponse: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">trailingSlash: </span><span class="s2">this</span><span class="s1">.nextConfig.trailingSlash,</span>
            <span class="s1">deploymentId: </span><span class="s2">this</span><span class="s1">.nextConfig.deploymentId,</span>
            <span class="s1">poweredByHeader: </span><span class="s2">this</span><span class="s1">.nextConfig.poweredByHeader,</span>
            <span class="s1">canonicalBase: </span><span class="s2">this</span><span class="s1">.nextConfig.amp.canonicalBase || </span><span class="s0">''</span><span class="s1">,</span>
            <span class="s1">generateEtags,</span>
            <span class="s1">previewProps: </span><span class="s2">this</span><span class="s1">.getPrerenderManifest().preview,</span>
            <span class="s1">ampOptimizerConfig: (_this_nextConfig_experimental_amp = </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.amp) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_nextConfig_experimental_amp.optimizer,</span>
            <span class="s1">basePath: </span><span class="s2">this</span><span class="s1">.nextConfig.basePath,</span>
            <span class="s1">images: </span><span class="s2">this</span><span class="s1">.nextConfig.images,</span>
            <span class="s1">optimizeCss: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.optimizeCss,</span>
            <span class="s1">nextConfigOutput: </span><span class="s2">this</span><span class="s1">.nextConfig.output,</span>
            <span class="s1">nextScriptWorkers: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.nextScriptWorkers,</span>
            <span class="s1">disableOptimizedLoading: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.disableOptimizedLoading,</span>
            <span class="s1">domainLocales: (_this_nextConfig_i18n1 = </span><span class="s2">this</span><span class="s1">.nextConfig.i18n) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_nextConfig_i18n1.domains,</span>
            <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
            <span class="s1">serverComponents: </span><span class="s2">this</span><span class="s1">.enabledDirectories.app,</span>
            <span class="s1">cacheLifeProfiles: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.cacheLife,</span>
            <span class="s1">enableTainting: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.taint,</span>
            <span class="s1">crossOrigin: </span><span class="s2">this</span><span class="s1">.nextConfig.crossOrigin ? </span><span class="s2">this</span><span class="s1">.nextConfig.crossOrigin : undefined,</span>
            <span class="s1">largePageDataBytes: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.largePageDataBytes,</span>
            <span class="s4">// Only the `publicRuntimeConfig` key is exposed to the client side</span>
            <span class="s4">// It'll be rendered as part of __NEXT_DATA__ on the client side</span>
            <span class="s1">runtimeConfig: Object.keys(publicRuntimeConfig).length &gt; </span><span class="s3">0 </span><span class="s1">? publicRuntimeConfig : undefined,</span>
            <span class="s1">isExperimentalCompile: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.isExperimentalCompile,</span>
            <span class="s4">// `htmlLimitedBots` is passed to server as serialized config in string format</span>
            <span class="s1">htmlLimitedBots: </span><span class="s2">this</span><span class="s1">.nextConfig.htmlLimitedBots,</span>
            <span class="s1">experimental: {</span>
                <span class="s1">expireTime: </span><span class="s2">this</span><span class="s1">.nextConfig.expireTime,</span>
                <span class="s1">staleTimes: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.staleTimes,</span>
                <span class="s1">clientTraceMetadata: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.clientTraceMetadata,</span>
                <span class="s1">cacheComponents: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.cacheComponents ?? </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">clientSegmentCache: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.clientSegmentCache === </span><span class="s0">'client-only' </span><span class="s1">? </span><span class="s0">'client-only' </span><span class="s1">: Boolean(</span><span class="s2">this</span><span class="s1">.nextConfig.experimental.clientSegmentCache),</span>
                <span class="s1">clientParamParsing: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.clientParamParsing ?? </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">dynamicOnHover: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.dynamicOnHover ?? </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">inlineCss: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.inlineCss ?? </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">authInterrupts: !!</span><span class="s2">this</span><span class="s1">.nextConfig.experimental.authInterrupts</span>
            <span class="s1">},</span>
            <span class="s1">onInstrumentationRequestError: </span><span class="s2">this</span><span class="s1">.instrumentationOnRequestError.bind(</span><span class="s2">this</span><span class="s1">),</span>
            <span class="s1">reactMaxHeadersLength: </span><span class="s2">this</span><span class="s1">.nextConfig.reactMaxHeadersLength,</span>
            <span class="s1">devtoolSegmentExplorer: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.devtoolSegmentExplorer</span>
        <span class="s1">};</span>
        <span class="s4">// Initialize next/config with the environment configuration</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _runtimeconfigexternal.setConfig)({</span>
            <span class="s1">serverRuntimeConfig,</span>
            <span class="s1">publicRuntimeConfig</span>
        <span class="s1">});</span>
        <span class="s2">this</span><span class="s1">.pagesManifest = </span><span class="s2">this</span><span class="s1">.getPagesManifest();</span>
        <span class="s2">this</span><span class="s1">.appPathsManifest = </span><span class="s2">this</span><span class="s1">.getAppPathsManifest();</span>
        <span class="s2">this</span><span class="s1">.appPathRoutes = </span><span class="s2">this</span><span class="s1">.getAppPathRoutes();</span>
        <span class="s2">this</span><span class="s1">.interceptionRoutePatterns = </span><span class="s2">this</span><span class="s1">.getinterceptionRoutePatterns();</span>
        <span class="s4">// Configure the routes.</span>
        <span class="s2">this</span><span class="s1">.matchers = </span><span class="s2">this</span><span class="s1">.getRouteMatchers();</span>
        <span class="s4">// Start route compilation. We don't wait for the routes to finish loading</span>
        <span class="s4">// because we use the `waitTillReady` promise below in `handleRequest` to</span>
        <span class="s4">// wait. Also we can't `await` in the constructor.</span>
        <span class="s2">void this</span><span class="s1">.matchers.reload();</span>
        <span class="s2">this</span><span class="s1">.setAssetPrefix(assetPrefix);</span>
        <span class="s2">this</span><span class="s1">.responseCache = </span><span class="s2">this</span><span class="s1">.getResponseCache({</span>
            <span class="s1">dev</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">getRouteMatchers() {</span>
        <span class="s4">// Create a new manifest loader that get's the manifests from the server.</span>
        <span class="s2">const </span><span class="s1">manifestLoader = </span><span class="s2">new </span><span class="s1">_servermanifestloader.ServerManifestLoader((name)=&gt;{</span>
            <span class="s2">switch</span><span class="s1">(name){</span>
                <span class="s2">case </span><span class="s1">_constants.PAGES_MANIFEST:</span>
                    <span class="s2">return this</span><span class="s1">.getPagesManifest() ?? </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">_constants.APP_PATHS_MANIFEST:</span>
                    <span class="s2">return this</span><span class="s1">.getAppPathsManifest() ?? </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s4">// Configure the matchers and handlers.</span>
        <span class="s2">const </span><span class="s1">matchers = </span><span class="s2">new </span><span class="s1">_defaultroutematchermanager.DefaultRouteMatcherManager();</span>
        <span class="s4">// Match pages under `pages/`.</span>
        <span class="s1">matchers.push(</span><span class="s2">new </span><span class="s1">_pagesroutematcherprovider.PagesRouteMatcherProvider(</span><span class="s2">this</span><span class="s1">.distDir, manifestLoader, </span><span class="s2">this</span><span class="s1">.i18nProvider));</span>
        <span class="s4">// Match api routes under `pages/api/`.</span>
        <span class="s1">matchers.push(</span><span class="s2">new </span><span class="s1">_pagesapiroutematcherprovider.PagesAPIRouteMatcherProvider(</span><span class="s2">this</span><span class="s1">.distDir, manifestLoader, </span><span class="s2">this</span><span class="s1">.i18nProvider));</span>
        <span class="s4">// If the app directory is enabled, then add the app matchers and handlers.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.enabledDirectories.app) {</span>
            <span class="s4">// Match app pages under `app/`.</span>
            <span class="s1">matchers.push(</span><span class="s2">new </span><span class="s1">_apppageroutematcherprovider.AppPageRouteMatcherProvider(</span><span class="s2">this</span><span class="s1">.distDir, manifestLoader));</span>
            <span class="s1">matchers.push(</span><span class="s2">new </span><span class="s1">_approuteroutematcherprovider.AppRouteRouteMatcherProvider(</span><span class="s2">this</span><span class="s1">.distDir, manifestLoader));</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">matchers;</span>
    <span class="s1">}</span>
    <span class="s1">async instrumentationOnRequestError(...args) {</span>
        <span class="s2">const </span><span class="s1">[err, req, ctx] = args;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.instrumentation) {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">await </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.instrumentation.onRequestError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.instrumentation.onRequestError.call(</span><span class="s2">this</span><span class="s1">.instrumentation, err, {</span>
                    <span class="s1">path: req.url || </span><span class="s0">''</span><span class="s1">,</span>
                    <span class="s1">method: req.method || </span><span class="s0">'GET'</span><span class="s1">,</span>
                    <span class="s4">// Normalize middleware headers and other server request headers</span>
                    <span class="s1">headers: req </span><span class="s2">instanceof </span><span class="s1">_adapter.NextRequestHint ? Object.fromEntries(req.headers.entries()) : req.headers</span>
                <span class="s1">}, ctx));</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(handlerErr) {</span>
                <span class="s4">// Log the soft error and continue, since errors can thrown from react stream handler</span>
                <span class="s1">console.error(</span><span class="s0">'Error in instrumentation.onRequestError:'</span><span class="s1">, handlerErr);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">logError(err) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.quiet) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">_log.error(err);</span>
    <span class="s1">}</span>
    <span class="s1">async handleRequest(req, res, parsedUrl) {</span>
        <span class="s2">await this</span><span class="s1">.prepare();</span>
        <span class="s2">const </span><span class="s1">method = req.method.toUpperCase();</span>
        <span class="s2">const </span><span class="s1">tracer = (</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)();</span>
        <span class="s2">return </span><span class="s1">tracer.withPropagatedContext(req.headers, ()=&gt;{</span>
            <span class="s2">return </span><span class="s1">tracer.trace(_constants1.BaseServerSpan.handleRequest, {</span>
                <span class="s1">spanName: </span><span class="s0">`</span><span class="s1">${method} ${req.url}</span><span class="s0">`</span><span class="s1">,</span>
                <span class="s1">kind: _tracer.SpanKind.SERVER,</span>
                <span class="s1">attributes: {</span>
                    <span class="s0">'http.method'</span><span class="s1">: method,</span>
                    <span class="s0">'http.target'</span><span class="s1">: req.url</span>
                <span class="s1">}</span>
            <span class="s1">}, async (span)=&gt;</span><span class="s2">this</span><span class="s1">.handleRequestImpl(req, res, parsedUrl).finally(()=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(!span) </span><span class="s2">return</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">isRSCRequest = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'isRSCRequest'</span><span class="s1">) ?? </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s1">span.setAttributes({</span>
                        <span class="s0">'http.status_code'</span><span class="s1">: res.statusCode,</span>
                        <span class="s0">'next.rsc'</span><span class="s1">: isRSCRequest</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">(res.statusCode &amp;&amp; res.statusCode &gt;= </span><span class="s3">500</span><span class="s1">) {</span>
                        <span class="s4">// For 5xx status codes: SHOULD be set to 'Error' span status.</span>
                        <span class="s4">// x-ref: https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status</span>
                        <span class="s1">span.setStatus({</span>
                            <span class="s1">code: _tracer.SpanStatusCode.ERROR</span>
                        <span class="s1">});</span>
                        <span class="s4">// For span status 'Error', SHOULD set 'error.type' attribute.</span>
                        <span class="s1">span.setAttribute(</span><span class="s0">'error.type'</span><span class="s1">, res.statusCode.toString());</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">rootSpanAttributes = tracer.getRootSpanAttributes();</span>
                    <span class="s4">// We were unable to get attributes, probably OTEL is not enabled</span>
                    <span class="s2">if </span><span class="s1">(!rootSpanAttributes) </span><span class="s2">return</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(rootSpanAttributes.get(</span><span class="s0">'next.span_type'</span><span class="s1">) !== _constants1.BaseServerSpan.handleRequest) {</span>
                        <span class="s1">console.warn(</span><span class="s0">`Unexpected root span type '</span><span class="s1">${rootSpanAttributes.get(</span><span class="s0">'next.span_type'</span><span class="s1">)}</span><span class="s0">'. Please report this Next.js issue https://github.com/vercel/next.js`</span><span class="s1">);</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">route = rootSpanAttributes.get(</span><span class="s0">'next.route'</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(route) {</span>
                        <span class="s2">const </span><span class="s1">name = isRSCRequest ? </span><span class="s0">`RSC </span><span class="s1">${method} ${route}</span><span class="s0">` </span><span class="s1">: </span><span class="s0">`</span><span class="s1">${method} ${route}</span><span class="s0">`</span><span class="s1">;</span>
                        <span class="s1">span.setAttributes({</span>
                            <span class="s0">'next.route'</span><span class="s1">: route,</span>
                            <span class="s0">'http.route'</span><span class="s1">: route,</span>
                            <span class="s0">'next.span_name'</span><span class="s1">: name</span>
                        <span class="s1">});</span>
                        <span class="s1">span.updateName(name);</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">span.updateName(isRSCRequest ? </span><span class="s0">`RSC </span><span class="s1">${method} ${req.url}</span><span class="s0">` </span><span class="s1">: </span><span class="s0">`</span><span class="s1">${method} ${req.url}</span><span class="s0">`</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}));</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async handleRequestImpl(req, res, parsedUrl) {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s1">_originalRequest_socket, _originalRequest_socket1, _this_i18nProvider, _this_nextConfig_i18n;</span>
            <span class="s4">// Wait for the matchers to be ready.</span>
            <span class="s2">await this</span><span class="s1">.matchers.waitTillReady();</span>
            <span class="s4">// ensure cookies set in middleware are merged and</span>
            <span class="s4">// not overridden by API routes/getServerSideProps</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _patchsetheader.patchSetHeaderWithCookieSupport)(req, (</span><span class="s3">0</span><span class="s1">, _helpers.isNodeNextResponse)(res) ? res.originalResponse : res);</span>
            <span class="s2">const </span><span class="s1">urlParts = (req.url || </span><span class="s0">''</span><span class="s1">).split(</span><span class="s0">'?'</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">urlNoQuery = urlParts[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s4">// this normalizes repeated slashes in the path e.g. hello//world -&gt;</span>
            <span class="s4">// hello/world or backslashes to forward slashes, this does not</span>
            <span class="s4">// handle trailing slash as that is handled the same as a next.config.js</span>
            <span class="s4">// redirect</span>
            <span class="s2">if </span><span class="s1">(urlNoQuery == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: urlNoQuery.match(</span><span class="s7">/(\\|\/\/)/</span><span class="s1">)) {</span>
                <span class="s2">const </span><span class="s1">cleanUrl = (</span><span class="s3">0</span><span class="s1">, _utils.normalizeRepeatedSlashes)(req.url);</span>
                <span class="s1">res.redirect(cleanUrl, </span><span class="s3">308</span><span class="s1">).body(cleanUrl).send();</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Parse url if parsedUrl not provided</span>
            <span class="s2">if </span><span class="s1">(!parsedUrl || </span><span class="s2">typeof </span><span class="s1">parsedUrl !== </span><span class="s0">'object'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!req.url) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: url can not be undefined'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E123&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">parsedUrl = (</span><span class="s3">0</span><span class="s1">, _url.parse)(req.url, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!parsedUrl.pathname) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;Invariant: pathname can't be empty&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E412&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Parse the querystring ourselves if the user doesn't handle querystring parsing</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">parsedUrl.query === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s1">parsedUrl.query = Object.fromEntries(</span><span class="s2">new </span><span class="s1">URLSearchParams(parsedUrl.query));</span>
            <span class="s1">}</span>
            <span class="s4">// Update the `x-forwarded-*` headers.</span>
            <span class="s2">const </span><span class="s1">{ originalRequest = </span><span class="s2">null </span><span class="s1">} = (</span><span class="s3">0</span><span class="s1">, _helpers.isNodeNextRequest)(req) ? req : {};</span>
            <span class="s2">const </span><span class="s1">xForwardedProto = originalRequest == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: originalRequest.headers[</span><span class="s0">'x-forwarded-proto'</span><span class="s1">];</span>
            <span class="s2">const </span><span class="s1">isHttps = xForwardedProto ? xForwardedProto === </span><span class="s0">'https' </span><span class="s1">: !!(originalRequest == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_originalRequest_socket = originalRequest.socket) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _originalRequest_socket.encrypted);</span>
            <span class="s1">req.headers[</span><span class="s0">'x-forwarded-host'</span><span class="s1">] ??= req.headers[</span><span class="s0">'host'</span><span class="s1">] ?? </span><span class="s2">this</span><span class="s1">.hostname;</span>
            <span class="s1">req.headers[</span><span class="s0">'x-forwarded-port'</span><span class="s1">] ??= </span><span class="s2">this</span><span class="s1">.port ? </span><span class="s2">this</span><span class="s1">.port.toString() : isHttps ? </span><span class="s0">'443' </span><span class="s1">: </span><span class="s0">'80'</span><span class="s1">;</span>
            <span class="s1">req.headers[</span><span class="s0">'x-forwarded-proto'</span><span class="s1">] ??= isHttps ? </span><span class="s0">'https' </span><span class="s1">: </span><span class="s0">'http'</span><span class="s1">;</span>
            <span class="s1">req.headers[</span><span class="s0">'x-forwarded-for'</span><span class="s1">] ??= originalRequest == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_originalRequest_socket1 = originalRequest.socket) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _originalRequest_socket1.remoteAddress;</span>
            <span class="s4">// This should be done before any normalization of the pathname happens as</span>
            <span class="s4">// it captures the initial URL.</span>
            <span class="s2">this</span><span class="s1">.attachRequestMeta(req, parsedUrl);</span>
            <span class="s2">let </span><span class="s1">finished = </span><span class="s2">await this</span><span class="s1">.handleRSCRequest(req, res, parsedUrl);</span>
            <span class="s2">if </span><span class="s1">(finished) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">domainLocale = (_this_i18nProvider = </span><span class="s2">this</span><span class="s1">.i18nProvider) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_i18nProvider.detectDomainLocale((</span><span class="s3">0</span><span class="s1">, _gethostname.getHostname)(parsedUrl, req.headers));</span>
            <span class="s2">const </span><span class="s1">defaultLocale = (domainLocale == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: domainLocale.defaultLocale) || ((_this_nextConfig_i18n = </span><span class="s2">this</span><span class="s1">.nextConfig.i18n) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_nextConfig_i18n.defaultLocale);</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'defaultLocale'</span><span class="s1">, defaultLocale);</span>
            <span class="s2">const </span><span class="s1">url = (</span><span class="s3">0</span><span class="s1">, _parseurl.parseUrl)(req.url.replace(</span><span class="s7">/^\/+/</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">));</span>
            <span class="s2">const </span><span class="s1">pathnameInfo = (</span><span class="s3">0</span><span class="s1">, _getnextpathnameinfo.getNextPathnameInfo)(url.pathname, {</span>
                <span class="s1">nextConfig: </span><span class="s2">this</span><span class="s1">.nextConfig,</span>
                <span class="s1">i18nProvider: </span><span class="s2">this</span><span class="s1">.i18nProvider</span>
            <span class="s1">});</span>
            <span class="s1">url.pathname = pathnameInfo.pathname;</span>
            <span class="s2">if </span><span class="s1">(pathnameInfo.basePath) {</span>
                <span class="s1">req.url = (</span><span class="s3">0</span><span class="s1">, _removepathprefix.removePathPrefix)(req.url, </span><span class="s2">this</span><span class="s1">.nextConfig.basePath);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">useMatchedPathHeader = </span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; </span><span class="s2">typeof </span><span class="s1">req.headers[_constants2.MATCHED_PATH_HEADER] === </span><span class="s0">'string'</span><span class="s1">;</span>
            <span class="s4">// TODO: merge handling with invokePath</span>
            <span class="s2">if </span><span class="s1">(useMatchedPathHeader) {</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">var </span><span class="s1">_this_normalizers_data, _this_i18nProvider1, _this_getRoutesManifest;</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.enabledDirectories.app) {</span>
                        <span class="s4">// ensure /index path is normalized for prerender</span>
                        <span class="s4">// in minimal mode</span>
                        <span class="s2">if </span><span class="s1">(req.url.match(</span><span class="s7">/^\/index($|\?)/</span><span class="s1">)) {</span>
                            <span class="s1">req.url = req.url.replace(</span><span class="s7">/^\/index/</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s1">parsedUrl.pathname = parsedUrl.pathname === </span><span class="s0">'/index' </span><span class="s1">? </span><span class="s0">'/' </span><span class="s1">: parsedUrl.pathname;</span>
                    <span class="s1">}</span>
                    <span class="s4">// x-matched-path is the source of truth, it tells what page</span>
                    <span class="s4">// should be rendered because we don't process rewrites in minimalMode</span>
                    <span class="s2">let </span><span class="s1">{ pathname: matchedPath } = </span><span class="s2">new </span><span class="s1">URL((</span><span class="s3">0</span><span class="s1">, _fixmojibake.fixMojibake)(req.headers[_constants2.MATCHED_PATH_HEADER]), </span><span class="s0">'http://localhost'</span><span class="s1">);</span>
                    <span class="s2">let </span><span class="s1">{ pathname: urlPathname } = </span><span class="s2">new </span><span class="s1">URL(req.url, </span><span class="s0">'http://localhost'</span><span class="s1">);</span>
                    <span class="s4">// For ISR the URL is normalized to the prerenderPath so if</span>
                    <span class="s4">// it's a data request the URL path will be the data URL,</span>
                    <span class="s4">// basePath is already stripped by this point</span>
                    <span class="s2">if </span><span class="s1">((_this_normalizers_data = </span><span class="s2">this</span><span class="s1">.normalizers.data) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_normalizers_data.match(urlPathname)) {</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isNextDataReq'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isAppPPREnabled &amp;&amp; </span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; req.headers[_constants2.NEXT_RESUME_HEADER] === </span><span class="s0">'1' </span><span class="s1">&amp;&amp; req.method === </span><span class="s0">'POST'</span><span class="s1">) {</span>
                        <span class="s4">// Decode the postponed state from the request body, it will come as</span>
                        <span class="s4">// an array of buffers, so collect them and then concat them to form</span>
                        <span class="s4">// the string.</span>
                        <span class="s2">const </span><span class="s1">body = [];</span>
                        <span class="s2">for await </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of req.body){</span>
                            <span class="s1">body.push(chunk);</span>
                        <span class="s1">}</span>
                        <span class="s2">const </span><span class="s1">postponed = Buffer.concat(body).toString(</span><span class="s0">'utf8'</span><span class="s1">);</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'postponed'</span><span class="s1">, postponed);</span>
                    <span class="s1">}</span>
                    <span class="s1">matchedPath = </span><span class="s2">this</span><span class="s1">.normalize(matchedPath);</span>
                    <span class="s2">const </span><span class="s1">normalizedUrlPath = </span><span class="s2">this</span><span class="s1">.stripNextDataPath(urlPathname);</span>
                    <span class="s1">matchedPath = (</span><span class="s3">0</span><span class="s1">, _denormalizepagepath.denormalizePagePath)(matchedPath);</span>
                    <span class="s4">// Perform locale detection and normalization.</span>
                    <span class="s2">const </span><span class="s1">localeAnalysisResult = (_this_i18nProvider1 = </span><span class="s2">this</span><span class="s1">.i18nProvider) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_i18nProvider1.analyze(matchedPath, {</span>
                        <span class="s1">defaultLocale</span>
                    <span class="s1">});</span>
                    <span class="s4">// The locale result will be defined even if the locale was not</span>
                    <span class="s4">// detected for the request because it will be inferred from the</span>
                    <span class="s4">// default locale.</span>
                    <span class="s2">if </span><span class="s1">(localeAnalysisResult) {</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">, localeAnalysisResult.detectedLocale);</span>
                        <span class="s4">// If the detected locale was inferred from the default locale, we</span>
                        <span class="s4">// need to modify the metadata on the request to indicate that.</span>
                        <span class="s2">if </span><span class="s1">(localeAnalysisResult.inferredFromDefault) {</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'localeInferredFromDefault'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.removeRequestMeta)(req, </span><span class="s0">'localeInferredFromDefault'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">let </span><span class="s1">srcPathname = matchedPath;</span>
                    <span class="s2">let </span><span class="s1">pageIsDynamic = (</span><span class="s3">0</span><span class="s1">, _utils1.isDynamicRoute)(srcPathname);</span>
                    <span class="s2">let </span><span class="s1">paramsResult = {</span>
                        <span class="s1">params: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">hasValidParams: </span><span class="s2">false</span>
                    <span class="s1">};</span>
                    <span class="s2">if </span><span class="s1">(!pageIsDynamic) {</span>
                        <span class="s2">const </span><span class="s1">match = </span><span class="s2">await this</span><span class="s1">.matchers.match(srcPathname, {</span>
                            <span class="s1">i18n: localeAnalysisResult</span>
                        <span class="s1">});</span>
                        <span class="s4">// Update the source pathname to the matched page's pathname.</span>
                        <span class="s2">if </span><span class="s1">(match) {</span>
                            <span class="s1">srcPathname = match.definition.pathname;</span>
                            <span class="s4">// The page is dynamic if the params are defined. We know at this</span>
                            <span class="s4">// stage that the matched path is not a static page if the params</span>
                            <span class="s4">// were parsed from the matched path header.</span>
                            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">match.params !== </span><span class="s0">'undefined'</span><span class="s1">) {</span>
                                <span class="s1">pageIsDynamic = </span><span class="s2">true</span><span class="s1">;</span>
                                <span class="s1">paramsResult.params = match.params;</span>
                                <span class="s1">paramsResult.hasValidParams = </span><span class="s2">true</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s4">// The rest of this function can't handle i18n properly, so ensure we</span>
                    <span class="s4">// restore the pathname with the locale information stripped from it</span>
                    <span class="s4">// now that we're done matching if we're using i18n.</span>
                    <span class="s2">if </span><span class="s1">(localeAnalysisResult) {</span>
                        <span class="s1">matchedPath = localeAnalysisResult.pathname;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">utils = (</span><span class="s3">0</span><span class="s1">, _serverutils.getServerUtils)({</span>
                        <span class="s1">pageIsDynamic,</span>
                        <span class="s1">page: srcPathname,</span>
                        <span class="s1">i18n: </span><span class="s2">this</span><span class="s1">.nextConfig.i18n,</span>
                        <span class="s1">basePath: </span><span class="s2">this</span><span class="s1">.nextConfig.basePath,</span>
                        <span class="s1">rewrites: ((_this_getRoutesManifest = </span><span class="s2">this</span><span class="s1">.getRoutesManifest()) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_getRoutesManifest.rewrites) || {</span>
                            <span class="s1">beforeFiles: [],</span>
                            <span class="s1">afterFiles: [],</span>
                            <span class="s1">fallback: []</span>
                        <span class="s1">},</span>
                        <span class="s1">caseSensitive: !!</span><span class="s2">this</span><span class="s1">.nextConfig.experimental.caseSensitiveRoutes</span>
                    <span class="s1">});</span>
                    <span class="s4">// Ensure parsedUrl.pathname includes locale before processing</span>
                    <span class="s4">// rewrites or they won't match correctly.</span>
                    <span class="s2">if </span><span class="s1">(defaultLocale &amp;&amp; !pathnameInfo.locale) {</span>
                        <span class="s1">parsedUrl.pathname = </span><span class="s0">`/</span><span class="s1">${defaultLocale}${parsedUrl.pathname}</span><span class="s0">`</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s4">// Store a copy of `parsedUrl.query` before calling handleRewrites.</span>
                    <span class="s4">// Since `handleRewrites` might add new queries to `parsedUrl.query`.</span>
                    <span class="s2">const </span><span class="s1">originQueryParams = {</span>
                        <span class="s1">...parsedUrl.query</span>
                    <span class="s1">};</span>
                    <span class="s2">const </span><span class="s1">pathnameBeforeRewrite = parsedUrl.pathname;</span>
                    <span class="s2">const </span><span class="s1">rewriteParamKeys = Object.keys(utils.handleRewrites(req, parsedUrl));</span>
                    <span class="s4">// Create a copy of the query params to avoid mutating the original</span>
                    <span class="s4">// object. This prevents any overlapping query params that have the</span>
                    <span class="s4">// same normalized key from causing issues.</span>
                    <span class="s2">const </span><span class="s1">queryParams = {</span>
                        <span class="s1">...parsedUrl.query</span>
                    <span class="s1">};</span>
                    <span class="s2">const </span><span class="s1">didRewrite = pathnameBeforeRewrite !== parsedUrl.pathname;</span>
                    <span class="s2">if </span><span class="s1">(didRewrite &amp;&amp; parsedUrl.pathname) {</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'rewroteURL'</span><span class="s1">, parsedUrl.pathname);</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">routeParamKeys = </span><span class="s2">new </span><span class="s1">Set();</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries(parsedUrl.query)){</span>
                        <span class="s2">const </span><span class="s1">normalizedKey = (</span><span class="s3">0</span><span class="s1">, _utils3.normalizeNextQueryParam)(key);</span>
                        <span class="s2">if </span><span class="s1">(!normalizedKey) </span><span class="s2">continue</span><span class="s1">;</span>
                        <span class="s4">// Remove the prefixed key from the query params because we want</span>
                        <span class="s4">// to consume it for the dynamic route matcher.</span>
                        <span class="s2">delete </span><span class="s1">parsedUrl.query[key];</span>
                        <span class="s1">routeParamKeys.add(normalizedKey);</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'undefined'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
                        <span class="s1">queryParams[normalizedKey] = Array.isArray(value) ? value.map((v)=&gt;(</span><span class="s3">0</span><span class="s1">, _decodequerypathparameter.decodeQueryPathParameter)(v)) : (</span><span class="s3">0</span><span class="s1">, _decodequerypathparameter.decodeQueryPathParameter)(value);</span>
                    <span class="s1">}</span>
                    <span class="s4">// interpolate dynamic params and normalize URL if needed</span>
                    <span class="s2">if </span><span class="s1">(pageIsDynamic) {</span>
                        <span class="s2">let </span><span class="s1">params = {};</span>
                        <span class="s4">// If we don't already have valid params, try to parse them from</span>
                        <span class="s4">// the query params.</span>
                        <span class="s2">if </span><span class="s1">(!paramsResult.hasValidParams) {</span>
                            <span class="s1">paramsResult = utils.normalizeDynamicRouteParams(queryParams, </span><span class="s2">false</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s4">// for prerendered ISR paths we attempt parsing the route</span>
                        <span class="s4">// params from the URL directly as route-matches may not</span>
                        <span class="s4">// contain the correct values due to the filesystem path</span>
                        <span class="s4">// matching before the dynamic route has been matched</span>
                        <span class="s2">if </span><span class="s1">(!paramsResult.hasValidParams &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _utils1.isDynamicRoute)(normalizedUrlPath)) {</span>
                            <span class="s2">let </span><span class="s1">matcherParams = utils.dynamicRouteMatcher == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: utils.dynamicRouteMatcher.call(utils, normalizedUrlPath);</span>
                            <span class="s2">if </span><span class="s1">(matcherParams) {</span>
                                <span class="s1">utils.normalizeDynamicRouteParams(matcherParams, </span><span class="s2">false</span><span class="s1">);</span>
                                <span class="s1">Object.assign(paramsResult.params, matcherParams);</span>
                                <span class="s1">paramsResult.hasValidParams = </span><span class="s2">true</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s4">// if an action request is bypassing a prerender and we</span>
                        <span class="s4">// don't have the params in the URL since it was prerendered</span>
                        <span class="s4">// and matched during handle: 'filesystem' rather than dynamic route</span>
                        <span class="s4">// resolving we need to parse the params from the matched-path.</span>
                        <span class="s4">// Note: this is similar to above case but from match-path instead</span>
                        <span class="s4">// of from the request URL since a rewrite could cause that to not</span>
                        <span class="s4">// match the src pathname</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s4">// we can have a collision with /index and a top-level /[slug]</span>
                        <span class="s1">matchedPath !== </span><span class="s0">'/index' </span><span class="s1">&amp;&amp; !paramsResult.hasValidParams &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _utils1.isDynamicRoute)(matchedPath)) {</span>
                            <span class="s2">let </span><span class="s1">matcherParams = utils.dynamicRouteMatcher == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: utils.dynamicRouteMatcher.call(utils, matchedPath);</span>
                            <span class="s2">if </span><span class="s1">(matcherParams) {</span>
                                <span class="s2">const </span><span class="s1">curParamsResult = utils.normalizeDynamicRouteParams(matcherParams, </span><span class="s2">false</span><span class="s1">);</span>
                                <span class="s2">if </span><span class="s1">(curParamsResult.hasValidParams) {</span>
                                    <span class="s1">Object.assign(params, matcherParams);</span>
                                    <span class="s1">paramsResult = curParamsResult;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(paramsResult.hasValidParams) {</span>
                            <span class="s1">params = paramsResult.params;</span>
                        <span class="s1">}</span>
                        <span class="s2">const </span><span class="s1">routeMatchesHeader = req.headers[</span><span class="s0">'x-now-route-matches'</span><span class="s1">];</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">routeMatchesHeader === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; routeMatchesHeader &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _utils1.isDynamicRoute)(matchedPath) &amp;&amp; !paramsResult.hasValidParams) {</span>
                            <span class="s2">const </span><span class="s1">routeMatches = utils.getParamsFromRouteMatches(routeMatchesHeader);</span>
                            <span class="s2">if </span><span class="s1">(routeMatches) {</span>
                                <span class="s1">paramsResult = utils.normalizeDynamicRouteParams(routeMatches, </span><span class="s2">true</span><span class="s1">);</span>
                                <span class="s2">if </span><span class="s1">(paramsResult.hasValidParams) {</span>
                                    <span class="s1">params = paramsResult.params;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s4">// Try to parse the params from the query if we couldn't parse them</span>
                        <span class="s4">// from the route matches but ignore missing optional params.</span>
                        <span class="s2">if </span><span class="s1">(!paramsResult.hasValidParams) {</span>
                            <span class="s1">paramsResult = utils.normalizeDynamicRouteParams(queryParams, </span><span class="s2">true</span><span class="s1">);</span>
                            <span class="s2">if </span><span class="s1">(paramsResult.hasValidParams) {</span>
                                <span class="s1">params = paramsResult.params;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s4">// If the pathname being requested is the same as the source</span>
                        <span class="s4">// pathname, and we don't have valid params, we want to use the</span>
                        <span class="s4">// default route matches.</span>
                        <span class="s2">if </span><span class="s1">(utils.defaultRouteMatches &amp;&amp; normalizedUrlPath === srcPathname &amp;&amp; !paramsResult.hasValidParams) {</span>
                            <span class="s1">params = utils.defaultRouteMatches;</span>
                            <span class="s4">// If the route matches header is an empty string, we want to</span>
                            <span class="s4">// render a fallback shell. This is because we know this came from</span>
                            <span class="s4">// a prerender (it has the header) but it's values were filtered</span>
                            <span class="s4">// out (because the allowQuery was empty). If it was undefined</span>
                            <span class="s4">// then we know that the request is hitting the lambda directly.</span>
                            <span class="s2">if </span><span class="s1">(routeMatchesHeader === </span><span class="s0">''</span><span class="s1">) {</span>
                                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'renderFallbackShell'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(params) {</span>
                            <span class="s1">matchedPath = utils.interpolateDynamicPath(srcPathname, params);</span>
                            <span class="s1">req.url = utils.interpolateDynamicPath(req.url, params);</span>
                            <span class="s4">// If the request is for a segment prefetch, we need to update the</span>
                            <span class="s4">// segment prefetch request path to include the interpolated</span>
                            <span class="s4">// params.</span>
                            <span class="s2">let </span><span class="s1">segmentPrefetchRSCRequest = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'segmentPrefetchRSCRequest'</span><span class="s1">);</span>
                            <span class="s2">if </span><span class="s1">(segmentPrefetchRSCRequest &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _utils1.isDynamicRoute)(segmentPrefetchRSCRequest, </span><span class="s2">false</span><span class="s1">)) {</span>
                                <span class="s1">segmentPrefetchRSCRequest = utils.interpolateDynamicPath(segmentPrefetchRSCRequest, params);</span>
                                <span class="s1">req.headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] = segmentPrefetchRSCRequest;</span>
                                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'segmentPrefetchRSCRequest'</span><span class="s1">, segmentPrefetchRSCRequest);</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(pageIsDynamic || didRewrite) {</span>
                        <span class="s2">var </span><span class="s1">_utils_defaultRouteRegex;</span>
                        <span class="s1">utils.normalizeCdnUrl(req, [</span>
                            <span class="s1">...rewriteParamKeys,</span>
                            <span class="s1">...Object.keys(((_utils_defaultRouteRegex = utils.defaultRouteRegex) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _utils_defaultRouteRegex.groups) || {})</span>
                        <span class="s1">]);</span>
                    <span class="s1">}</span>
                    <span class="s4">// Remove the route `params` keys from `parsedUrl.query` if they are</span>
                    <span class="s4">// not in the original query params.</span>
                    <span class="s4">// If it's used in both route `params` and query `searchParams`, it should be kept.</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of routeParamKeys){</span>
                        <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">originQueryParams)) {</span>
                            <span class="s2">delete </span><span class="s1">parsedUrl.query[key];</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">parsedUrl.pathname = matchedPath;</span>
                    <span class="s1">url.pathname = parsedUrl.pathname;</span>
                    <span class="s1">finished = </span><span class="s2">await this</span><span class="s1">.normalizeAndAttachMetadata(req, res, parsedUrl);</span>
                    <span class="s2">if </span><span class="s1">(finished) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                    <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">_utils.DecodeError || err </span><span class="s2">instanceof </span><span class="s1">_utils.NormalizeError) {</span>
                        <span class="s1">res.statusCode = </span><span class="s3">400</span><span class="s1">;</span>
                        <span class="s2">return this</span><span class="s1">.renderError(</span><span class="s2">null</span><span class="s1">, req, res, </span><span class="s0">'/_error'</span><span class="s1">, {});</span>
                    <span class="s1">}</span>
                    <span class="s2">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'isLocaleDomain'</span><span class="s1">, Boolean(domainLocale));</span>
            <span class="s2">if </span><span class="s1">(pathnameInfo.locale) {</span>
                <span class="s1">req.url = (</span><span class="s3">0</span><span class="s1">, _url.format)(url);</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'didStripLocale'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">// If we aren't in minimal mode or there is no locale in the query</span>
            <span class="s4">// string, add the locale to the query string.</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.minimalMode || !(</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">)) {</span>
                <span class="s4">// If the locale is in the pathname, add it to the query string.</span>
                <span class="s2">if </span><span class="s1">(pathnameInfo.locale) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">, pathnameInfo.locale);</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(defaultLocale) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">, defaultLocale);</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'localeInferredFromDefault'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// set incremental cache to request meta so it can</span>
            <span class="s4">// be passed down for edge functions and the fetch disk</span>
            <span class="s4">// cache can be leveraged locally</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.serverOptions.webServerConfig &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'incrementalCache'</span><span class="s1">)) {</span>
                <span class="s2">const </span><span class="s1">incrementalCache = </span><span class="s2">await this</span><span class="s1">.getIncrementalCache({</span>
                    <span class="s1">requestHeaders: Object.assign({}, req.headers)</span>
                <span class="s1">});</span>
                <span class="s1">incrementalCache.resetRequestCache();</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'incrementalCache'</span><span class="s1">, incrementalCache);</span>
                <span class="s1">globalThis.__incrementalCache = incrementalCache;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">cacheHandlers = (</span><span class="s3">0</span><span class="s1">, _handlers.getCacheHandlers)();</span>
            <span class="s2">if </span><span class="s1">(cacheHandlers) {</span>
                <span class="s2">await </span><span class="s1">Promise.all([</span>
                    <span class="s1">...cacheHandlers</span>
                <span class="s1">].map(async (cacheHandler)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s0">'refreshTags' </span><span class="s2">in </span><span class="s1">cacheHandler) {</span>
                    <span class="s4">// Note: cacheHandler.refreshTags() is called lazily before the</span>
                    <span class="s4">// first cache entry is retrieved. It allows us to skip the</span>
                    <span class="s4">// refresh request if no caches are read at all.</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">previouslyRevalidatedTags = (</span><span class="s3">0</span><span class="s1">, _serverutils.getPreviouslyRevalidatedTags)(req.headers, </span><span class="s2">this</span><span class="s1">.getPrerenderManifest().preview.previewModeId);</span>
                        <span class="s2">await </span><span class="s1">cacheHandler.receiveExpiredTags(...previouslyRevalidatedTags);</span>
                    <span class="s1">}</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s4">// set server components HMR cache to request meta so it can be passed</span>
            <span class="s4">// down for edge functions</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'serverComponentsHmrCache'</span><span class="s1">)) {</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'serverComponentsHmrCache'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.getServerComponentsHmrCache());</span>
            <span class="s1">}</span>
            <span class="s4">// when invokePath is specified we can short short circuit resolving</span>
            <span class="s4">// we only honor this header if we are inside of a render worker to</span>
            <span class="s4">// prevent external users coercing the routing path</span>
            <span class="s2">const </span><span class="s1">invokePath = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'invokePath'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">useInvokePath = !useMatchedPathHeader &amp;&amp; invokePath;</span>
            <span class="s2">if </span><span class="s1">(useInvokePath) {</span>
                <span class="s2">var </span><span class="s1">_this_nextConfig_i18n1;</span>
                <span class="s2">const </span><span class="s1">invokeStatus = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'invokeStatus'</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(invokeStatus) {</span>
                    <span class="s2">const </span><span class="s1">invokeQuery = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'invokeQuery'</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(invokeQuery) {</span>
                        <span class="s1">Object.assign(parsedUrl.query, invokeQuery);</span>
                    <span class="s1">}</span>
                    <span class="s1">res.statusCode = invokeStatus;</span>
                    <span class="s2">let </span><span class="s1">err = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'invokeError'</span><span class="s1">) || </span><span class="s2">null</span><span class="s1">;</span>
                    <span class="s2">return this</span><span class="s1">.renderError(err, req, res, </span><span class="s0">'/_error'</span><span class="s1">, parsedUrl.query);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">parsedMatchedPath = </span><span class="s2">new </span><span class="s1">URL(invokePath || </span><span class="s0">'/'</span><span class="s1">, </span><span class="s0">'http://n'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">invokePathnameInfo = (</span><span class="s3">0</span><span class="s1">, _getnextpathnameinfo.getNextPathnameInfo)(parsedMatchedPath.pathname, {</span>
                    <span class="s1">nextConfig: </span><span class="s2">this</span><span class="s1">.nextConfig,</span>
                    <span class="s1">parseData: </span><span class="s2">false</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(invokePathnameInfo.locale) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">, invokePathnameInfo.locale);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(parsedUrl.pathname !== parsedMatchedPath.pathname) {</span>
                    <span class="s1">parsedUrl.pathname = parsedMatchedPath.pathname;</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'rewroteURL'</span><span class="s1">, invokePathnameInfo.pathname);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">normalizeResult = (</span><span class="s3">0</span><span class="s1">, _normalizelocalepath.normalizeLocalePath)((</span><span class="s3">0</span><span class="s1">, _removepathprefix.removePathPrefix)(parsedUrl.pathname, </span><span class="s2">this</span><span class="s1">.nextConfig.basePath || </span><span class="s0">''</span><span class="s1">), (_this_nextConfig_i18n1 = </span><span class="s2">this</span><span class="s1">.nextConfig.i18n) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_nextConfig_i18n1.locales);</span>
                <span class="s2">if </span><span class="s1">(normalizeResult.detectedLocale) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">, normalizeResult.detectedLocale);</span>
                <span class="s1">}</span>
                <span class="s1">parsedUrl.pathname = normalizeResult.pathname;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of Object.keys(parsedUrl.query)){</span>
                    <span class="s2">delete </span><span class="s1">parsedUrl.query[key];</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">invokeQuery = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'invokeQuery'</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(invokeQuery) {</span>
                    <span class="s1">Object.assign(parsedUrl.query, invokeQuery);</span>
                <span class="s1">}</span>
                <span class="s1">finished = </span><span class="s2">await this</span><span class="s1">.normalizeAndAttachMetadata(req, res, parsedUrl);</span>
                <span class="s2">if </span><span class="s1">(finished) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s2">await this</span><span class="s1">.handleCatchallRenderRequest(req, res, parsedUrl);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'middlewareInvoke'</span><span class="s1">)) {</span>
                <span class="s1">finished = </span><span class="s2">await this</span><span class="s1">.normalizeAndAttachMetadata(req, res, parsedUrl);</span>
                <span class="s2">if </span><span class="s1">(finished) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s1">finished = </span><span class="s2">await this</span><span class="s1">.handleCatchallMiddlewareRequest(req, res, parsedUrl);</span>
                <span class="s2">if </span><span class="s1">(finished) </span><span class="s2">return</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">err = </span><span class="s2">new </span><span class="s1">Error();</span>
                <span class="s1">err.result = {</span>
                    <span class="s1">response: </span><span class="s2">new </span><span class="s1">Response(</span><span class="s2">null</span><span class="s1">, {</span>
                        <span class="s1">headers: {</span>
                            <span class="s0">'x-middleware-next'</span><span class="s1">: </span><span class="s0">'1'</span>
                        <span class="s1">}</span>
                    <span class="s1">})</span>
                <span class="s1">};</span>
                <span class="s1">err.bubble = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s4">// This wasn't a request via the matched path or the invoke path, so</span>
            <span class="s4">// prepare for a legacy run by removing the base path.</span>
            <span class="s4">// ensure we strip the basePath when not using an invoke header</span>
            <span class="s2">if </span><span class="s1">(!useMatchedPathHeader &amp;&amp; pathnameInfo.basePath) {</span>
                <span class="s1">parsedUrl.pathname = (</span><span class="s3">0</span><span class="s1">, _removepathprefix.removePathPrefix)(parsedUrl.pathname, pathnameInfo.basePath);</span>
            <span class="s1">}</span>
            <span class="s1">res.statusCode = </span><span class="s3">200</span><span class="s1">;</span>
            <span class="s2">return await this</span><span class="s1">.run(req, res, parsedUrl);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">_nofallbackerrorexternal.NoFallbackError) {</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(err &amp;&amp; </span><span class="s2">typeof </span><span class="s1">err === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; err.code === </span><span class="s0">'ERR_INVALID_URL' </span><span class="s1">|| err </span><span class="s2">instanceof </span><span class="s1">_utils.DecodeError || err </span><span class="s2">instanceof </span><span class="s1">_utils.NormalizeError) {</span>
                <span class="s1">res.statusCode = </span><span class="s3">400</span><span class="s1">;</span>
                <span class="s2">return this</span><span class="s1">.renderError(</span><span class="s2">null</span><span class="s1">, req, res, </span><span class="s0">'/_error'</span><span class="s1">, {});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.minimalMode || </span><span class="s2">this</span><span class="s1">.renderOpts.dev || (</span><span class="s3">0</span><span class="s1">, _tracer.isBubbledError)(err) &amp;&amp; err.bubble) {</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.logError((</span><span class="s3">0</span><span class="s1">, _iserror.getProperError)(err));</span>
            <span class="s1">res.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
            <span class="s1">res.body(</span><span class="s0">'Internal Server Error'</span><span class="s1">).send();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* </span><span class="s5">@internal </span><span class="s4">- this method is internal to Next.js and should not be used directly by end-users</span>
   <span class="s4">*/ </span><span class="s1">getRequestHandlerWithMetadata(meta) {</span>
        <span class="s2">const </span><span class="s1">handler = </span><span class="s2">this</span><span class="s1">.getRequestHandler();</span>
        <span class="s2">return </span><span class="s1">(req, res, parsedUrl)=&gt;{</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.setRequestMeta)(req, meta);</span>
            <span class="s2">return </span><span class="s1">handler(req, res, parsedUrl);</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">getRequestHandler() {</span>
        <span class="s2">return this</span><span class="s1">.handleRequest.bind(</span><span class="s2">this</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">setAssetPrefix(prefix) {</span>
        <span class="s2">this</span><span class="s1">.nextConfig.assetPrefix = prefix ? prefix.replace(</span><span class="s7">/\/$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">) : </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* Runs async initialization of server.</span>
   <span class="s4">* It is idempotent, won't fire underlying initialization more than once.</span>
   <span class="s4">*/ </span><span class="s1">async prepare() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prepared) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s4">// Get instrumentation module</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.instrumentation) {</span>
            <span class="s2">this</span><span class="s1">.instrumentation = </span><span class="s2">await this</span><span class="s1">.loadInstrumentationModule();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.preparedPromise === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.preparedPromise = </span><span class="s2">this</span><span class="s1">.prepareImpl().then(()=&gt;{</span>
                <span class="s2">this</span><span class="s1">.prepared = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">this</span><span class="s1">.preparedPromise = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.preparedPromise;</span>
    <span class="s1">}</span>
    <span class="s1">async prepareImpl() {}</span>
    <span class="s1">async loadInstrumentationModule() {}</span>
    <span class="s1">async close() {}</span>
    <span class="s1">getAppPathRoutes() {</span>
        <span class="s2">const </span><span class="s1">appPathRoutes = {};</span>
        <span class="s1">Object.keys(</span><span class="s2">this</span><span class="s1">.appPathsManifest || {}).forEach((entry)=&gt;{</span>
            <span class="s2">const </span><span class="s1">normalizedPath = (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(entry);</span>
            <span class="s2">if </span><span class="s1">(!appPathRoutes[normalizedPath]) {</span>
                <span class="s1">appPathRoutes[normalizedPath] = [];</span>
            <span class="s1">}</span>
            <span class="s1">appPathRoutes[normalizedPath].push(entry);</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">appPathRoutes;</span>
    <span class="s1">}</span>
    <span class="s1">async run(req, res, parsedUrl) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.BaseServerSpan.run, async ()=&gt;</span><span class="s2">this</span><span class="s1">.runImpl(req, res, parsedUrl));</span>
    <span class="s1">}</span>
    <span class="s1">async runImpl(req, res, parsedUrl) {</span>
        <span class="s2">await this</span><span class="s1">.handleCatchallRenderRequest(req, res, parsedUrl);</span>
    <span class="s1">}</span>
    <span class="s1">async pipe(fn, partialContext) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.BaseServerSpan.pipe, async ()=&gt;</span><span class="s2">this</span><span class="s1">.pipeImpl(fn, partialContext));</span>
    <span class="s1">}</span>
    <span class="s1">async pipeImpl(fn, partialContext) {</span>
        <span class="s2">const </span><span class="s1">ua = partialContext.req.headers[</span><span class="s0">'user-agent'</span><span class="s1">] || </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">ctx = {</span>
            <span class="s1">...partialContext,</span>
            <span class="s1">renderOpts: {</span>
                <span class="s1">...</span><span class="s2">this</span><span class="s1">.renderOpts,</span>
                <span class="s4">// `renderOpts.botType` is accumulated in `this.renderImpl()`</span>
                <span class="s1">supportsDynamicResponse: !</span><span class="s2">this</span><span class="s1">.renderOpts.botType,</span>
                <span class="s1">serveStreamingMetadata: (</span><span class="s3">0</span><span class="s1">, _streamingmetadata.shouldServeStreamingMetadata)(ua, </span><span class="s2">this</span><span class="s1">.nextConfig.htmlLimitedBots)</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">payload = </span><span class="s2">await </span><span class="s1">fn(ctx);</span>
        <span class="s2">if </span><span class="s1">(payload === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ req, res } = ctx;</span>
        <span class="s2">const </span><span class="s1">originalStatus = res.statusCode;</span>
        <span class="s2">const </span><span class="s1">{ body } = payload;</span>
        <span class="s2">let </span><span class="s1">{ cacheControl } = payload;</span>
        <span class="s2">if </span><span class="s1">(!res.sent) {</span>
            <span class="s2">const </span><span class="s1">{ generateEtags, poweredByHeader, dev } = </span><span class="s2">this</span><span class="s1">.renderOpts;</span>
            <span class="s4">// In dev, we should not cache pages for any reason.</span>
            <span class="s2">if </span><span class="s1">(dev) {</span>
                <span class="s1">res.setHeader(</span><span class="s0">'Cache-Control'</span><span class="s1">, </span><span class="s0">'no-store, must-revalidate'</span><span class="s1">);</span>
                <span class="s1">cacheControl = undefined;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(cacheControl &amp;&amp; cacheControl.expire === undefined) {</span>
                <span class="s1">cacheControl.expire = </span><span class="s2">this</span><span class="s1">.nextConfig.expireTime;</span>
            <span class="s1">}</span>
            <span class="s2">await this</span><span class="s1">.sendRenderResult(req, res, {</span>
                <span class="s1">result: body,</span>
                <span class="s1">generateEtags,</span>
                <span class="s1">poweredByHeader,</span>
                <span class="s1">cacheControl</span>
            <span class="s1">});</span>
            <span class="s1">res.statusCode = originalStatus;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async getStaticHTML(fn, partialContext) {</span>
        <span class="s2">const </span><span class="s1">ctx = {</span>
            <span class="s1">...partialContext,</span>
            <span class="s1">renderOpts: {</span>
                <span class="s1">...</span><span class="s2">this</span><span class="s1">.renderOpts,</span>
                <span class="s1">supportsDynamicResponse: </span><span class="s2">false</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">payload = </span><span class="s2">await </span><span class="s1">fn(ctx);</span>
        <span class="s2">if </span><span class="s1">(payload === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">payload.body.toUnchunkedString();</span>
    <span class="s1">}</span>
    <span class="s1">async render(req, res, pathname, query = {}, parsedUrl, internalRender = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.BaseServerSpan.render, async ()=&gt;</span><span class="s2">this</span><span class="s1">.renderImpl(req, res, pathname, query, parsedUrl, internalRender));</span>
    <span class="s1">}</span>
    <span class="s1">getWaitUntil() {</span>
        <span class="s2">const </span><span class="s1">builtinRequestContext = (</span><span class="s3">0</span><span class="s1">, _builtinrequestcontext.getBuiltinRequestContext)();</span>
        <span class="s2">if </span><span class="s1">(builtinRequestContext) {</span>
            <span class="s4">// the platform provided a request context.</span>
            <span class="s4">// use the `waitUntil` from there, whether actually present or not --</span>
            <span class="s4">// if not present, `after` will error.</span>
            <span class="s4">// NOTE: if we're in an edge runtime sandbox, this context will be used to forward the outer waitUntil.</span>
            <span class="s2">return </span><span class="s1">builtinRequestContext.waitUntil;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.minimalMode) {</span>
            <span class="s4">// we're built for a serverless environment, and `waitUntil` is not available,</span>
            <span class="s4">// but using a noop would likely lead to incorrect behavior,</span>
            <span class="s4">// because we have no way of keeping the invocation alive.</span>
            <span class="s4">// return nothing, and `after` will error if used.</span>
            <span class="s4">//</span>
            <span class="s4">// NOTE: for edge functions, `NextWebServer` always runs in minimal mode.</span>
            <span class="s4">//</span>
            <span class="s4">// NOTE: if we're in an edge runtime sandbox, waitUntil will be passed in using &quot;@next/request-context&quot;,</span>
            <span class="s4">// so we won't get here.</span>
            <span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.getInternalWaitUntil();</span>
    <span class="s1">}</span>
    <span class="s1">getInternalWaitUntil() {</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
    <span class="s1">async renderImpl(req, res, pathname, query = {}, parsedUrl, internalRender = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_req_url;</span>
        <span class="s2">if </span><span class="s1">(!pathname.startsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
            <span class="s1">console.warn(</span><span class="s0">`Cannot render page with path &quot;</span><span class="s1">${pathname}</span><span class="s0">&quot;, did you mean &quot;/</span><span class="s1">${pathname}</span><span class="s0">&quot;?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.serverOptions.customServer &amp;&amp; pathname === </span><span class="s0">'/index' </span><span class="s1">&amp;&amp; !</span><span class="s2">await this</span><span class="s1">.hasPage(</span><span class="s0">'/index'</span><span class="s1">)) {</span>
            <span class="s4">// maintain backwards compatibility for custom server</span>
            <span class="s4">// (see custom-server integration tests)</span>
            <span class="s1">pathname = </span><span class="s0">'/'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">ua = req.headers[</span><span class="s0">'user-agent'</span><span class="s1">] || </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.renderOpts.botType = (</span><span class="s3">0</span><span class="s1">, _isbot.getBotType)(ua);</span>
        <span class="s4">// we allow custom servers to call render for all URLs</span>
        <span class="s4">// so check if we need to serve a static _next file or not.</span>
        <span class="s4">// we don't modify the URL for _next/data request but still</span>
        <span class="s4">// call render so we special case this to prevent an infinite loop</span>
        <span class="s2">if </span><span class="s1">(!internalRender &amp;&amp; !</span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'isNextDataReq'</span><span class="s1">) &amp;&amp; (((_req_url = req.url) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _req_url.match(</span><span class="s7">/^\/_next\//</span><span class="s1">)) || </span><span class="s2">this</span><span class="s1">.hasStaticDir &amp;&amp; req.url.match(</span><span class="s7">/^\/static\//</span><span class="s1">))) {</span>
            <span class="s2">return this</span><span class="s1">.handleRequest(req, res, parsedUrl);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils2.isBlockedPage)(pathname)) {</span>
            <span class="s2">return this</span><span class="s1">.render404(req, res, parsedUrl);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.pipe((ctx)=&gt;</span><span class="s2">this</span><span class="s1">.renderToResponse(ctx), {</span>
            <span class="s1">req,</span>
            <span class="s1">res,</span>
            <span class="s1">pathname,</span>
            <span class="s1">query</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async getStaticPaths({ pathname }) {</span>
        <span class="s2">var </span><span class="s1">_this_getPrerenderManifest_dynamicRoutes_pathname;</span>
        <span class="s4">// Read whether or not fallback should exist from the manifest.</span>
        <span class="s2">const </span><span class="s1">fallbackField = (_this_getPrerenderManifest_dynamicRoutes_pathname = </span><span class="s2">this</span><span class="s1">.getPrerenderManifest().dynamicRoutes[pathname]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_getPrerenderManifest_dynamicRoutes_pathname.fallback;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s4">// `staticPaths` is intentionally set to `undefined` as it should've</span>
            <span class="s4">// been caught when checking disk data.</span>
            <span class="s1">staticPaths: undefined,</span>
            <span class="s1">fallbackMode: (</span><span class="s3">0</span><span class="s1">, _fallback.parseFallbackField)(fallbackField)</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">async renderToResponseWithComponents(requestContext, findComponentsResult) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderToResponseWithComponents, async ()=&gt;</span><span class="s2">this</span><span class="s1">.renderToResponseWithComponentsImpl(requestContext, findComponentsResult));</span>
    <span class="s1">}</span>
    <span class="s1">pathCouldBeIntercepted(resolvedPathname) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _interceptionroutes.isInterceptionRouteAppPath)(resolvedPathname) || </span><span class="s2">this</span><span class="s1">.interceptionRoutePatterns.some((regexp)=&gt;{</span>
            <span class="s2">return </span><span class="s1">regexp.test(resolvedPathname);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">setVaryHeader(req, res, isAppPath, resolvedPathname) {</span>
        <span class="s2">const </span><span class="s1">baseVaryHeader = </span><span class="s0">`</span><span class="s1">${_approuterheaders.RSC_HEADER}</span><span class="s0">, </span><span class="s1">${_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER}</span><span class="s0">, </span><span class="s1">${_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER}</span><span class="s0">, </span><span class="s1">${_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">isRSCRequest = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'isRSCRequest'</span><span class="s1">) ?? </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">addedNextUrlToVary = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(isAppPath &amp;&amp; </span><span class="s2">this</span><span class="s1">.pathCouldBeIntercepted(resolvedPathname)) {</span>
            <span class="s4">// Interception route responses can vary based on the `Next-URL` header.</span>
            <span class="s4">// We use the Vary header to signal this behavior to the client to properly cache the response.</span>
            <span class="s1">res.appendHeader(</span><span class="s0">'vary'</span><span class="s1">, </span><span class="s0">`</span><span class="s1">${baseVaryHeader}</span><span class="s0">, </span><span class="s1">${_approuterheaders.NEXT_URL}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">addedNextUrlToVary = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isAppPath || isRSCRequest) {</span>
            <span class="s4">// We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.</span>
            <span class="s4">// We also set this header for pages to avoid caching issues when navigating between pages and app.</span>
            <span class="s1">res.appendHeader(</span><span class="s0">'vary'</span><span class="s1">, baseVaryHeader);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!addedNextUrlToVary) {</span>
            <span class="s4">// Remove `Next-URL` from the request headers we determined it wasn't necessary to include in the Vary header.</span>
            <span class="s4">// This is to avoid any dependency on the `Next-URL` header being present when preparing the response.</span>
            <span class="s2">delete </span><span class="s1">req.headers[_approuterheaders.NEXT_URL];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async renderToResponseWithComponentsImpl({ req, res, pathname, renderOpts: opts }, { components, query }) {</span>
        <span class="s2">var </span><span class="s1">_this;</span>
        <span class="s2">if </span><span class="s1">(pathname === _constants.UNDERSCORE_NOT_FOUND_ROUTE) {</span>
            <span class="s1">pathname = </span><span class="s0">'/404'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">isErrorPathname = pathname === </span><span class="s0">'/_error'</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">is404Page = pathname === </span><span class="s0">'/404' </span><span class="s1">|| isErrorPathname &amp;&amp; res.statusCode === </span><span class="s3">404</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">is500Page = pathname === </span><span class="s0">'/500' </span><span class="s1">|| isErrorPathname &amp;&amp; res.statusCode === </span><span class="s3">500</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">isAppPath = components.isAppPath === </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">hasServerProps = !!components.getServerSideProps;</span>
        <span class="s2">const </span><span class="s1">isPossibleServerAction = (</span><span class="s3">0</span><span class="s1">, _serveractionrequestmeta.getIsPossibleServerAction)(req);</span>
        <span class="s2">let </span><span class="s1">isSSG = !!components.getStaticProps;</span>
        <span class="s4">// NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later</span>
        <span class="s2">const </span><span class="s1">isRSCRequest = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'isRSCRequest'</span><span class="s1">) ?? </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s4">// Not all CDNs respect the Vary header when caching. We must assume that</span>
        <span class="s4">// only the URL is used to vary the responses. The Next client computes a</span>
        <span class="s4">// hash of the header values and sends it as a search param. Before</span>
        <span class="s4">// responding to a request, we must verify that the hash matches the</span>
        <span class="s4">// expected value. Neglecting to do this properly can lead to cache</span>
        <span class="s4">// poisoning attacks on certain CDNs.</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.validateRSCRequestHeaders &amp;&amp; isRSCRequest) {</span>
            <span class="s2">const </span><span class="s1">headers = req.headers;</span>
            <span class="s2">const </span><span class="s1">prefetchHeaderValue = headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER];</span>
            <span class="s2">const </span><span class="s1">routerPrefetch = prefetchHeaderValue !== undefined ? prefetchHeaderValue === </span><span class="s0">'1' </span><span class="s1">|| prefetchHeaderValue === </span><span class="s0">'2' </span><span class="s1">? prefetchHeaderValue : undefined : </span><span class="s4">// so we don't expect the header to be stripped by an intermediate layer.</span>
            <span class="s4">// This should only happen for static prefetches, so we only handle those here.</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'isPrefetchRSCRequest'</span><span class="s1">) ? </span><span class="s0">'1' </span><span class="s1">: undefined;</span>
            <span class="s2">const </span><span class="s1">segmentPrefetchRSCRequest = headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] || (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'segmentPrefetchRSCRequest'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">expectedHash = (</span><span class="s3">0</span><span class="s1">, _cachebustingsearchparam.computeCacheBustingSearchParam)(routerPrefetch, segmentPrefetchRSCRequest, headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER], headers[_approuterheaders.NEXT_URL]);</span>
            <span class="s2">const </span><span class="s1">actualHash = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'cacheBustingSearchParam'</span><span class="s1">) ?? </span><span class="s2">new </span><span class="s1">URL(req.url || </span><span class="s0">''</span><span class="s1">, </span><span class="s0">'http://localhost'</span><span class="s1">).searchParams.get(_approuterheaders.NEXT_RSC_UNION_QUERY);</span>
            <span class="s2">if </span><span class="s1">(expectedHash !== actualHash) {</span>
                <span class="s4">// The hash sent by the client does not match the expected value.</span>
                <span class="s4">// Redirect to the URL with the correct cache-busting search param.</span>
                <span class="s4">// This prevents cache poisoning attacks on CDNs that don't respect Vary headers.</span>
                <span class="s4">// Note: When no headers are present, expectedHash is empty string and client</span>
                <span class="s4">// must send `_rsc` param, otherwise actualHash is null and hash check fails.</span>
                <span class="s2">const </span><span class="s1">url = </span><span class="s2">new </span><span class="s1">URL(req.url || </span><span class="s0">''</span><span class="s1">, </span><span class="s0">'http://localhost'</span><span class="s1">);</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _setcachebustingsearchparam.setCacheBustingSearchParamWithHash)(url, expectedHash);</span>
                <span class="s1">res.statusCode = </span><span class="s3">307</span><span class="s1">;</span>
                <span class="s1">res.setHeader(</span><span class="s0">'location'</span><span class="s1">, </span><span class="s0">`</span><span class="s1">${url.pathname}${url.search}</span><span class="s0">`</span><span class="s1">);</span>
                <span class="s1">res.body(</span><span class="s0">''</span><span class="s1">).send();</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// Compute the iSSG cache key. We use the rewroteUrl since</span>
        <span class="s4">// pages with fallback: false are allowed to be rewritten to</span>
        <span class="s4">// and we need to look up the path by the rewritten path</span>
        <span class="s2">let </span><span class="s1">urlPathname = (</span><span class="s3">0</span><span class="s1">, _url.parse)(req.url || </span><span class="s0">''</span><span class="s1">).pathname || </span><span class="s0">'/'</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">resolvedUrlPathname = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'rewroteURL'</span><span class="s1">) || urlPathname;</span>
        <span class="s2">this</span><span class="s1">.setVaryHeader(req, res, isAppPath, resolvedUrlPathname);</span>
        <span class="s2">let </span><span class="s1">staticPaths;</span>
        <span class="s2">let </span><span class="s1">hasFallback = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">prerenderManifest = </span><span class="s2">this</span><span class="s1">.getPrerenderManifest();</span>
        <span class="s2">if </span><span class="s1">(hasFallback || (staticPaths == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: staticPaths.includes(resolvedUrlPathname)) || </span><span class="s4">// this signals revalidation in deploy environments</span>
        <span class="s4">// TODO: make this more generic</span>
        <span class="s1">req.headers[</span><span class="s0">'x-now-route-matches'</span><span class="s1">]) {</span>
            <span class="s1">isSSG = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.renderOpts.dev) {</span>
            <span class="s1">isSSG ||= !!prerenderManifest.routes[(</span><span class="s3">0</span><span class="s1">, _toroute.toRoute)(pathname)];</span>
        <span class="s1">}</span>
        <span class="s4">// Toggle whether or not this is a Data request</span>
        <span class="s2">const </span><span class="s1">isNextDataRequest = !!((</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'isNextDataReq'</span><span class="s1">) || req.headers[</span><span class="s0">'x-nextjs-data'</span><span class="s1">] &amp;&amp; </span><span class="s2">this</span><span class="s1">.serverOptions.webServerConfig) &amp;&amp; (isSSG || hasServerProps);</span>
        <span class="s4">// when we are handling a middleware prefetch and it doesn't</span>
        <span class="s4">// resolve to a static data route we bail early to avoid</span>
        <span class="s4">// unexpected SSR invocations</span>
        <span class="s2">if </span><span class="s1">(!isSSG &amp;&amp; req.headers[</span><span class="s0">'x-middleware-prefetch'</span><span class="s1">] &amp;&amp; !(is404Page || pathname === </span><span class="s0">'/_error'</span><span class="s1">)) {</span>
            <span class="s1">res.setHeader(_constants2.MATCHED_PATH_HEADER, pathname);</span>
            <span class="s1">res.setHeader(</span><span class="s0">'x-middleware-skip'</span><span class="s1">, </span><span class="s0">'1'</span><span class="s1">);</span>
            <span class="s1">res.setHeader(</span><span class="s0">'cache-control'</span><span class="s1">, </span><span class="s0">'private, no-cache, no-store, max-age=0, must-revalidate'</span><span class="s1">);</span>
            <span class="s1">res.body(</span><span class="s0">'{}'</span><span class="s1">).send();</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// normalize req.url for SSG paths as it is not exposed</span>
        <span class="s4">// to getStaticProps and the asPath should not expose /_next/data</span>
        <span class="s2">if </span><span class="s1">(isSSG &amp;&amp; </span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; req.headers[_constants2.MATCHED_PATH_HEADER] &amp;&amp; req.url.startsWith(</span><span class="s0">'/_next/data'</span><span class="s1">)) {</span>
            <span class="s1">req.url = </span><span class="s2">this</span><span class="s1">.stripNextDataPath(req.url);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">locale = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(!!req.headers[</span><span class="s0">'x-nextjs-data'</span><span class="s1">] &amp;&amp; (!res.statusCode || res.statusCode === </span><span class="s3">200</span><span class="s1">)) {</span>
            <span class="s1">res.setHeader(</span><span class="s0">'x-nextjs-matched-path'</span><span class="s1">, </span><span class="s0">`</span><span class="s1">${locale ? </span><span class="s0">`/</span><span class="s1">${locale}</span><span class="s0">` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${pathname}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">routeModule;</span>
        <span class="s2">if </span><span class="s1">(components.routeModule) {</span>
            <span class="s1">routeModule = components.routeModule;</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
     <span class="s4">* If the route being rendered is an app page, and the ppr feature has been</span>
     <span class="s4">* enabled, then the given route _could_ support PPR.</span>
     <span class="s4">*/ </span><span class="s2">const </span><span class="s1">couldSupportPPR = </span><span class="s2">this</span><span class="s1">.isAppPPREnabled &amp;&amp; </span><span class="s2">typeof </span><span class="s1">routeModule !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; (</span><span class="s3">0</span><span class="s1">, _checks.isAppPageRouteModule)(routeModule);</span>
        <span class="s4">// When enabled, this will allow the use of the `?__nextppronly` query to</span>
        <span class="s4">// enable debugging of the static shell.</span>
        <span class="s2">const </span><span class="s1">hasDebugStaticShellQuery = process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === </span><span class="s0">'1' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">query.__nextppronly !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; couldSupportPPR;</span>
        <span class="s4">// This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the</span>
        <span class="s4">// prerender manifest and this is an app page.</span>
        <span class="s2">const </span><span class="s1">isRoutePPREnabled = couldSupportPPR &amp;&amp; (((_this = prerenderManifest.routes[pathname] ?? prerenderManifest.dynamicRoutes[pathname]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this.renderingMode) === </span><span class="s0">'PARTIALLY_STATIC' </span><span class="s1">|| </span><span class="s4">// Ideally we'd want to check the appConfig to see if this page has PPR</span>
        <span class="s4">// enabled or not, but that would require plumbing the appConfig through</span>
        <span class="s4">// to the server during development. We assume that the page supports it</span>
        <span class="s4">// but only during development.</span>
        <span class="s1">hasDebugStaticShellQuery &amp;&amp; (</span><span class="s2">this</span><span class="s1">.renderOpts.dev === </span><span class="s2">true </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.experimentalTestProxy === </span><span class="s2">true</span><span class="s1">));</span>
        <span class="s4">// If we're in minimal mode, then try to get the postponed information from</span>
        <span class="s4">// the request metadata. If available, use it for resuming the postponed</span>
        <span class="s4">// render.</span>
        <span class="s2">const </span><span class="s1">minimalPostponed = isRoutePPREnabled ? (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'postponed'</span><span class="s1">) : undefined;</span>
        <span class="s4">// we need to ensure the status code if /404 is visited directly</span>
        <span class="s2">if </span><span class="s1">(is404Page &amp;&amp; !isNextDataRequest &amp;&amp; !isRSCRequest) {</span>
            <span class="s1">res.statusCode = </span><span class="s3">404</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// ensure correct status is set when visiting a status page</span>
        <span class="s4">// directly e.g. /500</span>
        <span class="s2">if </span><span class="s1">(_constants.STATIC_STATUS_PAGES.includes(pathname)) {</span>
            <span class="s1">res.statusCode = parseInt(pathname.slice(</span><span class="s3">1</span><span class="s1">), </span><span class="s3">10</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">// Server actions can use non-GET/HEAD methods.</span>
        <span class="s1">!isPossibleServerAction &amp;&amp; </span><span class="s4">// Resume can use non-GET/HEAD methods.</span>
        <span class="s1">!minimalPostponed &amp;&amp; !is404Page &amp;&amp; !is500Page &amp;&amp; pathname !== </span><span class="s0">'/_error' </span><span class="s1">&amp;&amp; req.method !== </span><span class="s0">'HEAD' </span><span class="s1">&amp;&amp; req.method !== </span><span class="s0">'GET' </span><span class="s1">&amp;&amp; (</span><span class="s2">typeof </span><span class="s1">components.Component === </span><span class="s0">'string' </span><span class="s1">|| isSSG)) {</span>
            <span class="s1">res.statusCode = </span><span class="s3">405</span><span class="s1">;</span>
            <span class="s1">res.setHeader(</span><span class="s0">'Allow'</span><span class="s1">, [</span>
                <span class="s0">'GET'</span><span class="s1">,</span>
                <span class="s0">'HEAD'</span>
            <span class="s1">]);</span>
            <span class="s1">res.body(</span><span class="s0">'Method Not Allowed'</span><span class="s1">).send();</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// handle static page</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">components.Component === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">body: _renderresult.default.fromStatic(components.Component, _constants2.HTML_CONTENT_TYPE_HEADER)</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">// Ensure that if the `amp` query parameter is falsy that we remove it from</span>
        <span class="s4">// the query object. This ensures it won't be found by the `in` operator.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'amp' </span><span class="s2">in </span><span class="s1">query &amp;&amp; !query.amp) </span><span class="s2">delete </span><span class="s1">query.amp;</span>
        <span class="s2">if </span><span class="s1">(opts.supportsDynamicResponse === </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">_components_Document;</span>
            <span class="s2">const </span><span class="s1">ua = req.headers[</span><span class="s0">'user-agent'</span><span class="s1">] || </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">isBotRequest = (</span><span class="s3">0</span><span class="s1">, _isbot.isBot)(ua);</span>
            <span class="s2">const </span><span class="s1">isSupportedDocument = </span><span class="s2">typeof </span><span class="s1">((_components_Document = components.Document) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _components_Document.getInitialProps) !== </span><span class="s0">'function' </span><span class="s1">|| </span><span class="s4">// The built-in `Document` component also supports dynamic HTML for concurrent mode.</span>
            <span class="s1">_constants.NEXT_BUILTIN_DOCUMENT </span><span class="s2">in </span><span class="s1">components.Document;</span>
            <span class="s4">// Disable dynamic HTML in cases that we know it won't be generated,</span>
            <span class="s4">// so that we can continue generating a cache key when possible.</span>
            <span class="s4">// TODO-APP: should the first render for a dynamic app path</span>
            <span class="s4">// be static so we can collect revalidate and populate the</span>
            <span class="s4">// cache if there are no dynamic data requirements</span>
            <span class="s1">opts.supportsDynamicResponse = !isSSG &amp;&amp; !isBotRequest &amp;&amp; !query.amp &amp;&amp; isSupportedDocument;</span>
        <span class="s1">}</span>
        <span class="s4">// In development, we always want to generate dynamic HTML.</span>
        <span class="s2">if </span><span class="s1">(!isNextDataRequest &amp;&amp; isAppPath &amp;&amp; opts.dev) {</span>
            <span class="s1">opts.supportsDynamicResponse = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isSSG &amp;&amp; </span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; req.headers[_constants2.MATCHED_PATH_HEADER]) {</span>
            <span class="s4">// the url value is already correct when the matched-path header is set</span>
            <span class="s1">resolvedUrlPathname = urlPathname;</span>
        <span class="s1">}</span>
        <span class="s1">urlPathname = (</span><span class="s3">0</span><span class="s1">, _removetrailingslash.removeTrailingSlash)(urlPathname);</span>
        <span class="s1">resolvedUrlPathname = (</span><span class="s3">0</span><span class="s1">, _removetrailingslash.removeTrailingSlash)(resolvedUrlPathname);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.localeNormalizer) {</span>
            <span class="s1">resolvedUrlPathname = </span><span class="s2">this</span><span class="s1">.localeNormalizer.normalize(resolvedUrlPathname);</span>
        <span class="s1">}</span>
        <span class="s4">// remove /_next/data prefix from urlPathname so it matches</span>
        <span class="s4">// for direct page visit and /_next/data visit</span>
        <span class="s2">if </span><span class="s1">(isNextDataRequest) {</span>
            <span class="s1">resolvedUrlPathname = </span><span class="s2">this</span><span class="s1">.stripNextDataPath(resolvedUrlPathname);</span>
            <span class="s1">urlPathname = </span><span class="s2">this</span><span class="s1">.stripNextDataPath(urlPathname);</span>
        <span class="s1">}</span>
        <span class="s4">// use existing incrementalCache instance if available</span>
        <span class="s2">const </span><span class="s1">incrementalCache = </span><span class="s2">await this</span><span class="s1">.getIncrementalCache({</span>
            <span class="s1">requestHeaders: Object.assign({}, req.headers)</span>
        <span class="s1">});</span>
        <span class="s4">// TODO: investigate, this is not safe across multiple concurrent requests</span>
        <span class="s1">incrementalCache.resetRequestCache();</span>
        <span class="s2">if </span><span class="s1">((routeModule == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: routeModule.isDev) &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _utils1.isDynamicRoute)(pathname) &amp;&amp; (components.getStaticPaths || isAppPath)) {</span>
            <span class="s2">const </span><span class="s1">pathsResults = </span><span class="s2">await this</span><span class="s1">.getStaticPaths({</span>
                <span class="s1">pathname,</span>
                <span class="s1">urlPathname,</span>
                <span class="s1">requestHeaders: req.headers,</span>
                <span class="s1">page: components.page,</span>
                <span class="s1">isAppPath</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(isAppPath &amp;&amp; </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.cacheComponents) {</span>
                <span class="s2">var </span><span class="s1">_pathsResults_prerenderedRoutes;</span>
                <span class="s2">if </span><span class="s1">((_pathsResults_prerenderedRoutes = pathsResults.prerenderedRoutes) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _pathsResults_prerenderedRoutes.length) {</span>
                    <span class="s2">let </span><span class="s1">smallestFallbackRouteParams = </span><span class="s2">null</span><span class="s1">;</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">route of pathsResults.prerenderedRoutes){</span>
                        <span class="s2">const </span><span class="s1">fallbackRouteParams = route.fallbackRouteParams;</span>
                        <span class="s2">if </span><span class="s1">(!fallbackRouteParams || fallbackRouteParams.length === </span><span class="s3">0</span><span class="s1">) {</span>
                            <span class="s4">// There are no fallback route params so we don't need to continue</span>
                            <span class="s1">smallestFallbackRouteParams = </span><span class="s2">null</span><span class="s1">;</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(smallestFallbackRouteParams === </span><span class="s2">null </span><span class="s1">|| fallbackRouteParams.length &lt; smallestFallbackRouteParams.length) {</span>
                            <span class="s1">smallestFallbackRouteParams = fallbackRouteParams;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(smallestFallbackRouteParams) {</span>
                        <span class="s2">const </span><span class="s1">devValidatingFallbackParams = </span><span class="s2">new </span><span class="s1">Map(smallestFallbackRouteParams.map((v)=&gt;[</span>
                                <span class="s1">v,</span>
                                <span class="s0">''</span>
                            <span class="s1">]));</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'devValidatingFallbackParams'</span><span class="s1">, devValidatingFallbackParams);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// An OPTIONS request to a page handler is invalid.</span>
        <span class="s2">if </span><span class="s1">(req.method === </span><span class="s0">'OPTIONS' </span><span class="s1">&amp;&amp; !is404Page &amp;&amp; (!routeModule || !(</span><span class="s3">0</span><span class="s1">, _checks.isAppRouteRouteModule)(routeModule))) {</span>
            <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _sendresponse.sendResponse)(req, res, </span><span class="s2">new </span><span class="s1">Response(</span><span class="s2">null</span><span class="s1">, {</span>
                <span class="s1">status: </span><span class="s3">400</span>
            <span class="s1">}));</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">request = (</span><span class="s3">0</span><span class="s1">, _helpers.isNodeNextRequest)(req) ? req.originalRequest : req;</span>
        <span class="s2">const </span><span class="s1">response = (</span><span class="s3">0</span><span class="s1">, _helpers.isNodeNextResponse)(res) ? res.originalResponse : res;</span>
        <span class="s2">const </span><span class="s1">parsedInitUrl = (</span><span class="s3">0</span><span class="s1">, _url.parse)((</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'initURL'</span><span class="s1">) || req.url);</span>
        <span class="s2">let </span><span class="s1">initPathname = parsedInitUrl.pathname || </span><span class="s0">'/'</span><span class="s1">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">normalizer of [</span>
            <span class="s2">this</span><span class="s1">.normalizers.segmentPrefetchRSC,</span>
            <span class="s2">this</span><span class="s1">.normalizers.prefetchRSC,</span>
            <span class="s2">this</span><span class="s1">.normalizers.rsc</span>
        <span class="s1">]){</span>
            <span class="s2">if </span><span class="s1">(normalizer == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: normalizer.match(initPathname)) {</span>
                <span class="s1">initPathname = normalizer.normalize(initPathname);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// On minimal mode, the request url of dynamic route can be a</span>
        <span class="s4">// literal dynamic route ('/[slug]') instead of actual URL, so overwriting to initPathname</span>
        <span class="s4">// will transform back the resolved url to the dynamic route pathname.</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; isErrorPathname)) {</span>
            <span class="s1">request.url = </span><span class="s0">`</span><span class="s1">${initPathname}${parsedInitUrl.search || </span><span class="s0">''</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// propagate the request context for dev</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.setRequestMeta)(request, (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req));</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(request, </span><span class="s0">'distDir'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.distDir);</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(request, </span><span class="s0">'query'</span><span class="s1">, query);</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(request, </span><span class="s0">'params'</span><span class="s1">, opts.params);</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(request, </span><span class="s0">'ampValidator'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.renderOpts.ampValidator);</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(request, </span><span class="s0">'minimalMode'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.minimalMode);</span>
        <span class="s2">if </span><span class="s1">(opts.err) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(request, </span><span class="s0">'invokeError'</span><span class="s1">, opts.err);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">handler = components.ComponentMod.handler;</span>
        <span class="s2">const </span><span class="s1">maybeDevRequest = </span><span class="s4">// we need to capture fetch metrics when they are set</span>
        <span class="s4">// and can't wait for handler to resolve as the fetch</span>
        <span class="s4">// metrics are logged on response close which happens</span>
        <span class="s4">// before handler resolves</span>
        <span class="s1">process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">? </span><span class="s2">new </span><span class="s1">Proxy(request, {</span>
            <span class="s1">get (target, prop) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">target[prop] === </span><span class="s0">'function'</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">target[prop].bind(target);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">target[prop];</span>
            <span class="s1">},</span>
            <span class="s1">set (target, prop, value) {</span>
                <span class="s2">if </span><span class="s1">(prop === </span><span class="s0">'fetchMetrics'</span><span class="s1">) {</span>
                    <span class="s1">;</span>
                    <span class="s1">req.fetchMetrics = value;</span>
                <span class="s1">}</span>
                <span class="s1">target[prop] = value;</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}) : request;</span>
        <span class="s2">await </span><span class="s1">handler(maybeDevRequest, response, {</span>
            <span class="s1">waitUntil: </span><span class="s2">this</span><span class="s1">.getWaitUntil()</span>
        <span class="s1">});</span>
        <span class="s4">// response is handled fully in handler</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">stripNextDataPath(path, stripLocale = </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(path.includes(</span><span class="s2">this</span><span class="s1">.buildId)) {</span>
            <span class="s2">const </span><span class="s1">splitPath = path.substring(path.indexOf(</span><span class="s2">this</span><span class="s1">.buildId) + </span><span class="s2">this</span><span class="s1">.buildId.length);</span>
            <span class="s1">path = (</span><span class="s3">0</span><span class="s1">, _denormalizepagepath.denormalizePagePath)(splitPath.replace(</span><span class="s7">/\.json$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.localeNormalizer &amp;&amp; stripLocale) {</span>
            <span class="s2">return this</span><span class="s1">.localeNormalizer.normalize(path);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">path;</span>
    <span class="s1">}</span>
    <span class="s4">// map the route to the actual bundle name</span>
    <span class="s1">getOriginalAppPaths(route) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.enabledDirectories.app) {</span>
            <span class="s2">var </span><span class="s1">_this_appPathRoutes;</span>
            <span class="s2">const </span><span class="s1">originalAppPath = (_this_appPathRoutes = </span><span class="s2">this</span><span class="s1">.appPathRoutes) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_appPathRoutes[route];</span>
            <span class="s2">if </span><span class="s1">(!originalAppPath) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">originalAppPath;</span>
        <span class="s1">}</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">async renderPageComponent(ctx, bubbleNoFallback) {</span>
        <span class="s2">var </span><span class="s1">_this_nextConfig_experimental_sri;</span>
        <span class="s2">const </span><span class="s1">{ query, pathname } = ctx;</span>
        <span class="s2">const </span><span class="s1">appPaths = </span><span class="s2">this</span><span class="s1">.getOriginalAppPaths(pathname);</span>
        <span class="s2">const </span><span class="s1">isAppPath = Array.isArray(appPaths);</span>
        <span class="s2">let </span><span class="s1">page = pathname;</span>
        <span class="s2">if </span><span class="s1">(isAppPath) {</span>
            <span class="s4">// the last item in the array is the root page, if there are parallel routes</span>
            <span class="s1">page = appPaths[appPaths.length - </span><span class="s3">1</span><span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">result = </span><span class="s2">await this</span><span class="s1">.findPageComponents({</span>
            <span class="s1">locale: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'locale'</span><span class="s1">),</span>
            <span class="s1">page,</span>
            <span class="s1">query,</span>
            <span class="s1">params: ctx.renderOpts.params || {},</span>
            <span class="s1">isAppPath,</span>
            <span class="s1">sriEnabled: !!((_this_nextConfig_experimental_sri = </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.sri) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_nextConfig_experimental_sri.algorithm),</span>
            <span class="s1">appPaths,</span>
            <span class="s4">// Ensuring for loading page component routes is done via the matcher.</span>
            <span class="s1">shouldEnsure: </span><span class="s2">false</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(result) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().setRootSpanAttribute(</span><span class="s0">'next.route'</span><span class="s1">, pathname);</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">return await this</span><span class="s1">.renderToResponseWithComponents(ctx, result);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s2">const </span><span class="s1">isNoFallbackError = err </span><span class="s2">instanceof </span><span class="s1">_nofallbackerrorexternal.NoFallbackError;</span>
                <span class="s2">if </span><span class="s1">(!isNoFallbackError || isNoFallbackError &amp;&amp; bubbleNoFallback) {</span>
                    <span class="s2">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">async renderToResponse(ctx) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderToResponse, {</span>
            <span class="s1">spanName: </span><span class="s0">`rendering page`</span><span class="s1">,</span>
            <span class="s1">attributes: {</span>
                <span class="s0">'next.route'</span><span class="s1">: ctx.pathname</span>
            <span class="s1">}</span>
        <span class="s1">}, async ()=&gt;{</span>
            <span class="s2">return this</span><span class="s1">.renderToResponseImpl(ctx);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async renderToResponseImpl(ctx) {</span>
        <span class="s2">var </span><span class="s1">_this_i18nProvider;</span>
        <span class="s2">const </span><span class="s1">{ req, res, query, pathname } = ctx;</span>
        <span class="s2">let </span><span class="s1">page = pathname;</span>
        <span class="s2">const </span><span class="s1">bubbleNoFallback = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'bubbleNoFallback'</span><span class="s1">) ?? </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.validateRSCRequestHeaders) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(ctx.req, </span><span class="s0">'cacheBustingSearchParam'</span><span class="s1">, query[_approuterheaders.NEXT_RSC_UNION_QUERY]);</span>
        <span class="s1">}</span>
        <span class="s2">delete </span><span class="s1">query[_approuterheaders.NEXT_RSC_UNION_QUERY];</span>
        <span class="s2">const </span><span class="s1">options = {</span>
            <span class="s1">i18n: (_this_i18nProvider = </span><span class="s2">this</span><span class="s1">.i18nProvider) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_i18nProvider.fromRequest(req, pathname)</span>
        <span class="s1">};</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">for await </span><span class="s1">(</span><span class="s2">const </span><span class="s1">match of </span><span class="s2">this</span><span class="s1">.matchers.matchAll(pathname, options)){</span>
                <span class="s4">// when a specific invoke-output is meant to be matched</span>
                <span class="s4">// ensure a prior dynamic route/page doesn't take priority</span>
                <span class="s2">const </span><span class="s1">invokeOutput = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'invokeOutput'</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; </span><span class="s2">typeof </span><span class="s1">invokeOutput === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; (</span><span class="s3">0</span><span class="s1">, _utils1.isDynamicRoute)(invokeOutput || </span><span class="s0">''</span><span class="s1">) &amp;&amp; invokeOutput !== match.definition.pathname) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">await this</span><span class="s1">.renderPageComponent({</span>
                    <span class="s1">...ctx,</span>
                    <span class="s1">pathname: match.definition.pathname,</span>
                    <span class="s1">renderOpts: {</span>
                        <span class="s1">...ctx.renderOpts,</span>
                        <span class="s1">params: match.params</span>
                    <span class="s1">}</span>
                <span class="s1">}, bubbleNoFallback);</span>
                <span class="s2">if </span><span class="s1">(result !== </span><span class="s2">false</span><span class="s1">) </span><span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s4">// currently edge functions aren't receiving the x-matched-path</span>
            <span class="s4">// header so we need to fallback to matching the current page</span>
            <span class="s4">// when we weren't able to match via dynamic route to handle</span>
            <span class="s4">// the rewrite case</span>
            <span class="s4">// @ts-expect-error extended in child class web-server</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.serverOptions.webServerConfig) {</span>
                <span class="s4">// @ts-expect-error extended in child class web-server</span>
                <span class="s1">ctx.pathname = </span><span class="s2">this</span><span class="s1">.serverOptions.webServerConfig.page;</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">await this</span><span class="s1">.renderPageComponent(ctx, bubbleNoFallback);</span>
                <span class="s2">if </span><span class="s1">(result !== </span><span class="s2">false</span><span class="s1">) </span><span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s2">const </span><span class="s1">err = (</span><span class="s3">0</span><span class="s1">, _iserror.getProperError)(error);</span>
            <span class="s2">if </span><span class="s1">(error </span><span class="s2">instanceof </span><span class="s1">_utils.MissingStaticPage) {</span>
                <span class="s1">console.error(</span><span class="s0">'Invariant: failed to load static page'</span><span class="s1">, JSON.stringify({</span>
                    <span class="s1">page,</span>
                    <span class="s1">url: ctx.req.url,</span>
                    <span class="s1">matchedPath: ctx.req.headers[_constants2.MATCHED_PATH_HEADER],</span>
                    <span class="s1">initUrl: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'initURL'</span><span class="s1">),</span>
                    <span class="s1">didRewrite: !!(</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'rewroteURL'</span><span class="s1">),</span>
                    <span class="s1">rewroteUrl: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'rewroteURL'</span><span class="s1">)</span>
                <span class="s1">}, </span><span class="s2">null</span><span class="s1">, </span><span class="s3">2</span><span class="s1">));</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">_nofallbackerrorexternal.NoFallbackError &amp;&amp; bubbleNoFallback) {</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">_utils.DecodeError || err </span><span class="s2">instanceof </span><span class="s1">_utils.NormalizeError) {</span>
                <span class="s1">res.statusCode = </span><span class="s3">400</span><span class="s1">;</span>
                <span class="s2">return await this</span><span class="s1">.renderErrorToResponse(ctx, err);</span>
            <span class="s1">}</span>
            <span class="s1">res.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
            <span class="s4">// if pages/500 is present we still need to trigger</span>
            <span class="s4">// /_error `getInitialProps` to allow reporting error</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">await this</span><span class="s1">.hasPage(</span><span class="s0">'/500'</span><span class="s1">)) {</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(ctx.req, </span><span class="s0">'customErrorRender'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">await this</span><span class="s1">.renderErrorToResponse(ctx, err);</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.removeRequestMeta)(ctx.req, </span><span class="s0">'customErrorRender'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">isWrappedError = err </span><span class="s2">instanceof </span><span class="s1">WrappedBuildError;</span>
            <span class="s2">if </span><span class="s1">(!isWrappedError) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.minimalMode || </span><span class="s2">this</span><span class="s1">.renderOpts.dev) {</span>
                    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _iserror.default)(err)) err.page = page;</span>
                    <span class="s2">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.logError((</span><span class="s3">0</span><span class="s1">, _iserror.getProperError)(err));</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">response = </span><span class="s2">await this</span><span class="s1">.renderErrorToResponse(ctx, isWrappedError ? err.innerError : err);</span>
            <span class="s2">return </span><span class="s1">response;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">middleware = </span><span class="s2">await this</span><span class="s1">.getMiddleware();</span>
        <span class="s2">if </span><span class="s1">(middleware &amp;&amp; !!ctx.req.headers[</span><span class="s0">'x-nextjs-data'</span><span class="s1">] &amp;&amp; (!res.statusCode || res.statusCode === </span><span class="s3">200 </span><span class="s1">|| res.statusCode === </span><span class="s3">404</span><span class="s1">)) {</span>
            <span class="s2">const </span><span class="s1">locale = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">);</span>
            <span class="s1">res.setHeader(</span><span class="s0">'x-nextjs-matched-path'</span><span class="s1">, </span><span class="s0">`</span><span class="s1">${locale ? </span><span class="s0">`/</span><span class="s1">${locale}</span><span class="s0">` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${pathname}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">res.statusCode = </span><span class="s3">200</span><span class="s1">;</span>
            <span class="s1">res.setHeader(</span><span class="s0">'Content-Type'</span><span class="s1">, _constants2.JSON_CONTENT_TYPE_HEADER);</span>
            <span class="s1">res.body(</span><span class="s0">'{}'</span><span class="s1">);</span>
            <span class="s1">res.send();</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">res.statusCode = </span><span class="s3">404</span><span class="s1">;</span>
        <span class="s2">return this</span><span class="s1">.renderErrorToResponse(ctx, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">async renderToHTML(req, res, pathname, query = {}) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderToHTML, async ()=&gt;{</span>
            <span class="s2">return this</span><span class="s1">.renderToHTMLImpl(req, res, pathname, query);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async renderToHTMLImpl(req, res, pathname, query = {}) {</span>
        <span class="s2">return this</span><span class="s1">.getStaticHTML((ctx)=&gt;</span><span class="s2">this</span><span class="s1">.renderToResponse(ctx), {</span>
            <span class="s1">req,</span>
            <span class="s1">res,</span>
            <span class="s1">pathname,</span>
            <span class="s1">query</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async renderError(err, req, res, pathname, query = {}, setHeaders = </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderError, async ()=&gt;{</span>
            <span class="s2">return this</span><span class="s1">.renderErrorImpl(err, req, res, pathname, query, setHeaders);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async renderErrorImpl(err, req, res, pathname, query = {}, setHeaders = </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(setHeaders) {</span>
            <span class="s1">res.setHeader(</span><span class="s0">'Cache-Control'</span><span class="s1">, </span><span class="s0">'private, no-cache, no-store, max-age=0, must-revalidate'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.pipe(async (ctx)=&gt;{</span>
            <span class="s2">const </span><span class="s1">response = </span><span class="s2">await this</span><span class="s1">.renderErrorToResponse(ctx, err);</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; res.statusCode === </span><span class="s3">500</span><span class="s1">) {</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">response;</span>
        <span class="s1">}, {</span>
            <span class="s1">req,</span>
            <span class="s1">res,</span>
            <span class="s1">pathname,</span>
            <span class="s1">query</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async renderErrorToResponse(ctx, err) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderErrorToResponse, async ()=&gt;{</span>
            <span class="s2">return this</span><span class="s1">.renderErrorToResponseImpl(ctx, err);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async renderErrorToResponseImpl(ctx, err) {</span>
        <span class="s4">// Short-circuit favicon.ico in development to avoid compiling 404 page when the app has no favicon.ico.</span>
        <span class="s4">// Since favicon.ico is automatically requested by the browser.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderOpts.dev &amp;&amp; ctx.pathname === </span><span class="s0">'/favicon.ico'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">body: _renderresult.default.EMPTY</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ res, query } = ctx;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">let </span><span class="s1">result = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">is404 = res.statusCode === </span><span class="s3">404</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">using404Page = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(is404) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.enabledDirectories.app) {</span>
                    <span class="s4">// Use the not-found entry in app directory</span>
                    <span class="s1">result = </span><span class="s2">await this</span><span class="s1">.findPageComponents({</span>
                        <span class="s1">locale: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'locale'</span><span class="s1">),</span>
                        <span class="s1">page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span>
                        <span class="s1">query,</span>
                        <span class="s1">params: {},</span>
                        <span class="s1">isAppPath: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">shouldEnsure: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">url: ctx.req.url</span>
                    <span class="s1">});</span>
                    <span class="s1">using404Page = result !== </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!result &amp;&amp; </span><span class="s2">await this</span><span class="s1">.hasPage(</span><span class="s0">'/404'</span><span class="s1">)) {</span>
                    <span class="s1">result = </span><span class="s2">await this</span><span class="s1">.findPageComponents({</span>
                        <span class="s1">locale: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'locale'</span><span class="s1">),</span>
                        <span class="s1">page: </span><span class="s0">'/404'</span><span class="s1">,</span>
                        <span class="s1">query,</span>
                        <span class="s1">params: {},</span>
                        <span class="s1">isAppPath: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s4">// Ensuring can't be done here because you never &quot;match&quot; a 404 route.</span>
                        <span class="s1">shouldEnsure: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">url: ctx.req.url</span>
                    <span class="s1">});</span>
                    <span class="s1">using404Page = result !== </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">statusPage = </span><span class="s0">`/</span><span class="s1">${res.statusCode}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'customErrorRender'</span><span class="s1">) &amp;&amp; !result &amp;&amp; _constants.STATIC_STATUS_PAGES.includes(statusPage)) {</span>
                <span class="s4">// skip ensuring /500 in dev mode as it isn't used and the</span>
                <span class="s4">// dev overlay is used instead</span>
                <span class="s2">if </span><span class="s1">(statusPage !== </span><span class="s0">'/500' </span><span class="s1">|| !</span><span class="s2">this</span><span class="s1">.renderOpts.dev) {</span>
                    <span class="s1">result = </span><span class="s2">await this</span><span class="s1">.findPageComponents({</span>
                        <span class="s1">locale: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'locale'</span><span class="s1">),</span>
                        <span class="s1">page: statusPage,</span>
                        <span class="s1">query,</span>
                        <span class="s1">params: {},</span>
                        <span class="s1">isAppPath: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s4">// Ensuring can't be done here because you never &quot;match&quot; a 500</span>
                        <span class="s4">// route.</span>
                        <span class="s1">shouldEnsure: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">url: ctx.req.url</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!result) {</span>
                <span class="s1">result = </span><span class="s2">await this</span><span class="s1">.findPageComponents({</span>
                    <span class="s1">locale: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(ctx.req, </span><span class="s0">'locale'</span><span class="s1">),</span>
                    <span class="s1">page: </span><span class="s0">'/_error'</span><span class="s1">,</span>
                    <span class="s1">query,</span>
                    <span class="s1">params: {},</span>
                    <span class="s1">isAppPath: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s4">// Ensuring can't be done here because you never &quot;match&quot; an error</span>
                    <span class="s4">// route.</span>
                    <span class="s1">shouldEnsure: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">url: ctx.req.url</span>
                <span class="s1">});</span>
                <span class="s1">statusPage = </span><span class="s0">'/_error'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production' </span><span class="s1">&amp;&amp; !using404Page &amp;&amp; </span><span class="s2">await this</span><span class="s1">.hasPage(</span><span class="s0">'/_error'</span><span class="s1">) &amp;&amp; !</span><span class="s2">await this</span><span class="s1">.hasPage(</span><span class="s0">'/404'</span><span class="s1">)) {</span>
                <span class="s2">this</span><span class="s1">.customErrorNo404Warn();</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!result) {</span>
                <span class="s4">// this can occur when a project directory has been moved/deleted</span>
                <span class="s4">// which is handled in the parent process in development</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderOpts.dev) {</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s4">// wait for dev-server to restart before refreshing</span>
                        <span class="s1">body: _renderresult.default.fromStatic(</span><span class="s0">`</span>
              <span class="s0">&lt;pre&gt;missing required error components, refreshing...&lt;/pre&gt; 
              &lt;script&gt; 
                async function check() { 
                  const res = await fetch(location.href).catch(() =&gt; ({})) 
 
                  if (res.status === 200) { 
                    location.reload() 
                  } else { 
                    setTimeout(check, 1000) 
                  } 
                } 
                check() 
              &lt;/script&gt;`</span><span class="s1">, _constants2.HTML_CONTENT_TYPE_HEADER)</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
                <span class="s2">throw new </span><span class="s1">WrappedBuildError(Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'missing required error components'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E60&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s4">// If the page has a route module, use it for the new match. If it doesn't</span>
            <span class="s4">// have a route module, remove the match.</span>
            <span class="s2">if </span><span class="s1">(result.components.routeModule) {</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(ctx.req, </span><span class="s0">'match'</span><span class="s1">, {</span>
                    <span class="s1">definition: result.components.routeModule.definition,</span>
                    <span class="s1">params: undefined</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.removeRequestMeta)(ctx.req, </span><span class="s0">'match'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">return await this</span><span class="s1">.renderToResponseWithComponents({</span>
                    <span class="s1">...ctx,</span>
                    <span class="s1">pathname: statusPage,</span>
                    <span class="s1">renderOpts: {</span>
                        <span class="s1">...ctx.renderOpts,</span>
                        <span class="s1">err</span>
                    <span class="s1">}</span>
                <span class="s1">}, result);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(maybeFallbackError) {</span>
                <span class="s2">if </span><span class="s1">(maybeFallbackError </span><span class="s2">instanceof </span><span class="s1">_nofallbackerrorexternal.NoFallbackError) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant: failed to render error page'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E55&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">throw </span><span class="s1">maybeFallbackError;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s2">const </span><span class="s1">renderToHtmlError = (</span><span class="s3">0</span><span class="s1">, _iserror.getProperError)(error);</span>
            <span class="s2">const </span><span class="s1">isWrappedError = renderToHtmlError </span><span class="s2">instanceof </span><span class="s1">WrappedBuildError;</span>
            <span class="s2">if </span><span class="s1">(!isWrappedError) {</span>
                <span class="s2">this</span><span class="s1">.logError(renderToHtmlError);</span>
            <span class="s1">}</span>
            <span class="s1">res.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">fallbackComponents = </span><span class="s2">await this</span><span class="s1">.getFallbackErrorComponents(ctx.req.url);</span>
            <span class="s2">if </span><span class="s1">(fallbackComponents) {</span>
                <span class="s4">// There was an error, so use it's definition from the route module</span>
                <span class="s4">// to add the match to the request.</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(ctx.req, </span><span class="s0">'match'</span><span class="s1">, {</span>
                    <span class="s1">definition: fallbackComponents.routeModule.definition,</span>
                    <span class="s1">params: undefined</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.renderToResponseWithComponents({</span>
                    <span class="s1">...ctx,</span>
                    <span class="s1">pathname: </span><span class="s0">'/_error'</span><span class="s1">,</span>
                    <span class="s1">renderOpts: {</span>
                        <span class="s1">...ctx.renderOpts,</span>
                        <span class="s4">// We render `renderToHtmlError` here because `err` is</span>
                        <span class="s4">// already captured in the stacktrace.</span>
                        <span class="s1">err: isWrappedError ? renderToHtmlError.innerError : renderToHtmlError</span>
                    <span class="s1">}</span>
                <span class="s1">}, {</span>
                    <span class="s1">query,</span>
                    <span class="s1">components: fallbackComponents</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">body: _renderresult.default.fromStatic(</span><span class="s0">'Internal Server Error'</span><span class="s1">, </span><span class="s0">'text/plain'</span><span class="s1">)</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async renderErrorToHTML(err, req, res, pathname, query = {}) {</span>
        <span class="s2">return this</span><span class="s1">.getStaticHTML((ctx)=&gt;</span><span class="s2">this</span><span class="s1">.renderErrorToResponse(ctx, err), {</span>
            <span class="s1">req,</span>
            <span class="s1">res,</span>
            <span class="s1">pathname,</span>
            <span class="s1">query</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async render404(req, res, parsedUrl, setHeaders = </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">{ pathname, query } = parsedUrl ? parsedUrl : (</span><span class="s3">0</span><span class="s1">, _url.parse)(req.url, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s4">// Ensure the locales are provided on the request meta.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.nextConfig.i18n) {</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">)) {</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'locale'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.nextConfig.i18n.defaultLocale);</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'defaultLocale'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.nextConfig.i18n.defaultLocale);</span>
        <span class="s1">}</span>
        <span class="s1">res.statusCode = </span><span class="s3">404</span><span class="s1">;</span>
        <span class="s2">return this</span><span class="s1">.renderError(</span><span class="s2">null</span><span class="s1">, req, res, pathname, query, setHeaders);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=base-server.js.map</span></pre>
</body>
</html>