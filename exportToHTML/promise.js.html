<html>
<head>
<title>promise.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
promise.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span>

<span class="s2">const </span><span class="s1">test = require(</span><span class="s0">'tape'</span><span class="s1">)</span>
<span class="s2">const </span><span class="s1">buildQueue = require(</span><span class="s0">'../'</span><span class="s1">).promise</span>
<span class="s2">const </span><span class="s1">{ promisify } = require(</span><span class="s0">'util'</span><span class="s1">)</span>
<span class="s2">const </span><span class="s1">sleep = promisify(setTimeout)</span>
<span class="s2">const </span><span class="s1">immediate = promisify(setImmediate)</span>

<span class="s1">test(</span><span class="s0">'concurrency'</span><span class="s1">, </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s1">t.plan(</span><span class="s3">2</span><span class="s1">)</span>
  <span class="s1">t.throws(buildQueue.bind(</span><span class="s2">null</span><span class="s1">, worker, </span><span class="s3">0</span><span class="s1">))</span>
  <span class="s1">t.doesNotThrow(buildQueue.bind(</span><span class="s2">null</span><span class="s1">, worker, </span><span class="s3">1</span><span class="s1">))</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'worker execution'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">1</span><span class="s1">)</span>

  <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">queue.push(</span><span class="s3">42</span><span class="s1">)</span>

  <span class="s1">t.equal(result, </span><span class="s2">true</span><span class="s1">, </span><span class="s0">'result matches'</span><span class="s1">)</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s1">t.equal(arg, </span><span class="s3">42</span><span class="s1">)</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'limit'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">1</span><span class="s1">)</span>

  <span class="s2">const </span><span class="s1">[res1, res2] = </span><span class="s2">await </span><span class="s1">Promise.all([queue.push(</span><span class="s3">10</span><span class="s1">), queue.push(</span><span class="s3">0</span><span class="s1">)])</span>
  <span class="s1">t.equal(res1, </span><span class="s3">10</span><span class="s1">, </span><span class="s0">'the result matches'</span><span class="s1">)</span>
  <span class="s1">t.equal(res2, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">'the result matches'</span><span class="s1">)</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s2">await </span><span class="s1">sleep(arg)</span>
    <span class="s2">return </span><span class="s1">arg</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'multiple executions'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">1</span><span class="s1">)</span>
  <span class="s2">const </span><span class="s1">toExec = [</span><span class="s3">1</span><span class="s1">, </span><span class="s3">2</span><span class="s1">, </span><span class="s3">3</span><span class="s1">, </span><span class="s3">4</span><span class="s1">, </span><span class="s3">5</span><span class="s1">]</span>
  <span class="s2">const </span><span class="s1">expected = [</span><span class="s0">'a'</span><span class="s1">, </span><span class="s0">'b'</span><span class="s1">, </span><span class="s0">'c'</span><span class="s1">, </span><span class="s0">'d'</span><span class="s1">, </span><span class="s0">'e'</span><span class="s1">]</span>
  <span class="s2">let </span><span class="s1">count = </span><span class="s3">0</span>

  <span class="s2">await </span><span class="s1">Promise.all(toExec.map(async </span><span class="s2">function </span><span class="s1">(task, i) {</span>
    <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">queue.push(task)</span>
    <span class="s1">t.equal(result, expected[i], </span><span class="s0">'the result matches'</span><span class="s1">)</span>
  <span class="s1">}))</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s1">t.equal(arg, toExec[count], </span><span class="s0">'arg matches'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">expected[count++]</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'drained'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">2</span><span class="s1">)</span>

  <span class="s2">const </span><span class="s1">toExec = </span><span class="s2">new </span><span class="s1">Array(</span><span class="s3">10</span><span class="s1">).fill(</span><span class="s3">10</span><span class="s1">)</span>
  <span class="s2">let </span><span class="s1">count = </span><span class="s3">0</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s2">await </span><span class="s1">sleep(arg)</span>
    <span class="s1">count++</span>
  <span class="s1">}</span>

  <span class="s1">toExec.forEach(</span><span class="s2">function </span><span class="s1">(i) {</span>
    <span class="s1">queue.push(i)</span>
  <span class="s1">})</span>

  <span class="s2">await </span><span class="s1">queue.drained()</span>

  <span class="s1">t.equal(count, toExec.length)</span>

  <span class="s1">toExec.forEach(</span><span class="s2">function </span><span class="s1">(i) {</span>
    <span class="s1">queue.push(i)</span>
  <span class="s1">})</span>

  <span class="s2">await </span><span class="s1">queue.drained()</span>

  <span class="s1">t.equal(count, toExec.length * </span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'drained with exception should not throw'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">2</span><span class="s1">)</span>

  <span class="s2">const </span><span class="s1">toExec = </span><span class="s2">new </span><span class="s1">Array(</span><span class="s3">10</span><span class="s1">).fill(</span><span class="s3">10</span><span class="s1">)</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker () {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'foo'</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">toExec.forEach(</span><span class="s2">function </span><span class="s1">(i) {</span>
    <span class="s1">queue.push(i)</span>
  <span class="s1">})</span>

  <span class="s2">await </span><span class="s1">queue.drained()</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'drained with drain function'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">let </span><span class="s1">drainCalled = </span><span class="s2">false</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">2</span><span class="s1">)</span>

  <span class="s1">queue.drain = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s1">drainCalled = </span><span class="s2">true</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">toExec = </span><span class="s2">new </span><span class="s1">Array(</span><span class="s3">10</span><span class="s1">).fill(</span><span class="s3">10</span><span class="s1">)</span>
  <span class="s2">let </span><span class="s1">count = </span><span class="s3">0</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s2">await </span><span class="s1">sleep(arg)</span>
    <span class="s1">count++</span>
  <span class="s1">}</span>

  <span class="s1">toExec.forEach(</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s1">queue.push()</span>
  <span class="s1">})</span>

  <span class="s2">await </span><span class="s1">queue.drained()</span>

  <span class="s1">t.equal(count, toExec.length)</span>
  <span class="s1">t.equal(drainCalled, </span><span class="s2">true</span><span class="s1">)</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'drained while idle should resolve'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">2</span><span class="s1">)</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s2">await </span><span class="s1">sleep(arg)</span>
  <span class="s1">}</span>

  <span class="s2">await </span><span class="s1">queue.drained()</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'drained while idle should not call the drain function'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">let </span><span class="s1">drainCalled = </span><span class="s2">false</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">2</span><span class="s1">)</span>

  <span class="s1">queue.drain = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s1">drainCalled = </span><span class="s2">true</span>
  <span class="s1">}</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s2">await </span><span class="s1">sleep(arg)</span>
  <span class="s1">}</span>

  <span class="s2">await </span><span class="s1">queue.drained()</span>

  <span class="s1">t.equal(drainCalled, </span><span class="s2">false</span><span class="s1">)</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'set this'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s1">t.plan(</span><span class="s3">1</span><span class="s1">)</span>
  <span class="s2">const </span><span class="s1">that = {}</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(that, worker, </span><span class="s3">1</span><span class="s1">)</span>

  <span class="s2">await </span><span class="s1">queue.push(</span><span class="s3">42</span><span class="s1">)</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s1">t.equal(</span><span class="s2">this</span><span class="s1">, that, </span><span class="s0">'this matches'</span><span class="s1">)</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'unshift'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">1</span><span class="s1">)</span>
  <span class="s2">const </span><span class="s1">expected = [</span><span class="s3">1</span><span class="s1">, </span><span class="s3">2</span><span class="s1">, </span><span class="s3">3</span><span class="s1">, </span><span class="s3">4</span><span class="s1">]</span>

  <span class="s2">await </span><span class="s1">Promise.all([</span>
    <span class="s1">queue.push(</span><span class="s3">1</span><span class="s1">),</span>
    <span class="s1">queue.push(</span><span class="s3">4</span><span class="s1">),</span>
    <span class="s1">queue.unshift(</span><span class="s3">3</span><span class="s1">),</span>
    <span class="s1">queue.unshift(</span><span class="s3">2</span><span class="s1">)</span>
  <span class="s1">])</span>

  <span class="s1">t.is(expected.length, </span><span class="s3">0</span><span class="s1">)</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s1">t.equal(expected.shift(), arg, </span><span class="s0">'tasks come in order'</span><span class="s1">)</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'push with worker throwing error'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s1">t.plan(</span><span class="s3">5</span><span class="s1">)</span>
  <span class="s2">const </span><span class="s1">q = buildQueue(async </span><span class="s2">function </span><span class="s1">(task, cb) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'test error'</span><span class="s1">)</span>
  <span class="s1">}, </span><span class="s3">1</span><span class="s1">)</span>
  <span class="s1">q.error(</span><span class="s2">function </span><span class="s1">(err, task) {</span>
    <span class="s1">t.ok(err </span><span class="s2">instanceof </span><span class="s1">Error, </span><span class="s0">'global error handler should catch the error'</span><span class="s1">)</span>
    <span class="s1">t.match(err.message, </span><span class="s4">/test error/</span><span class="s1">, </span><span class="s0">'error message should be &quot;test error&quot;'</span><span class="s1">)</span>
    <span class="s1">t.equal(task, </span><span class="s3">42</span><span class="s1">, </span><span class="s0">'The task executed should be passed'</span><span class="s1">)</span>
  <span class="s1">})</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">await </span><span class="s1">q.push(</span><span class="s3">42</span><span class="s1">)</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s1">t.ok(err </span><span class="s2">instanceof </span><span class="s1">Error, </span><span class="s0">'push callback should catch the error'</span><span class="s1">)</span>
    <span class="s1">t.match(err.message, </span><span class="s4">/test error/</span><span class="s1">, </span><span class="s0">'error message should be &quot;test error&quot;'</span><span class="s1">)</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'unshift with worker throwing error'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s1">t.plan(</span><span class="s3">2</span><span class="s1">)</span>
  <span class="s2">const </span><span class="s1">q = buildQueue(async </span><span class="s2">function </span><span class="s1">(task, cb) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'test error'</span><span class="s1">)</span>
  <span class="s1">}, </span><span class="s3">1</span><span class="s1">)</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">await </span><span class="s1">q.unshift(</span><span class="s3">42</span><span class="s1">)</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s1">t.ok(err </span><span class="s2">instanceof </span><span class="s1">Error, </span><span class="s0">'push callback should catch the error'</span><span class="s1">)</span>
    <span class="s1">t.match(err.message, </span><span class="s4">/test error/</span><span class="s1">, </span><span class="s0">'error message should be &quot;test error&quot;'</span><span class="s1">)</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'no unhandledRejection (push)'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">function </span><span class="s1">handleRejection () {</span>
    <span class="s1">t.fail(</span><span class="s0">'unhandledRejection'</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s1">process.once(</span><span class="s0">'unhandledRejection'</span><span class="s1">, handleRejection)</span>
  <span class="s2">const </span><span class="s1">q = buildQueue(async </span><span class="s2">function </span><span class="s1">(task, cb) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'test error'</span><span class="s1">)</span>
  <span class="s1">}, </span><span class="s3">1</span><span class="s1">)</span>

  <span class="s1">q.push(</span><span class="s3">42</span><span class="s1">)</span>

  <span class="s2">await </span><span class="s1">immediate()</span>
  <span class="s1">process.removeListener(</span><span class="s0">'unhandledRejection'</span><span class="s1">, handleRejection)</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'no unhandledRejection (unshift)'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">function </span><span class="s1">handleRejection () {</span>
    <span class="s1">t.fail(</span><span class="s0">'unhandledRejection'</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s1">process.once(</span><span class="s0">'unhandledRejection'</span><span class="s1">, handleRejection)</span>
  <span class="s2">const </span><span class="s1">q = buildQueue(async </span><span class="s2">function </span><span class="s1">(task, cb) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'test error'</span><span class="s1">)</span>
  <span class="s1">}, </span><span class="s3">1</span><span class="s1">)</span>

  <span class="s1">q.unshift(</span><span class="s3">42</span><span class="s1">)</span>

  <span class="s2">await </span><span class="s1">immediate()</span>
  <span class="s1">process.removeListener(</span><span class="s0">'unhandledRejection'</span><span class="s1">, handleRejection)</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'drained should resolve after async tasks complete'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">const </span><span class="s1">logs = []</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">processTask () {</span>
    <span class="s2">await new </span><span class="s1">Promise(resolve =&gt; setTimeout(resolve, </span><span class="s3">0</span><span class="s1">))</span>
    <span class="s1">logs.push(</span><span class="s0">'processed'</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">queue = buildQueue(processTask, </span><span class="s3">1</span><span class="s1">)</span>
  <span class="s1">queue.drain = () =&gt; logs.push(</span><span class="s0">'called drain'</span><span class="s1">)</span>

  <span class="s1">queue.drained().then(() =&gt; logs.push(</span><span class="s0">'drained promise resolved'</span><span class="s1">))</span>

  <span class="s2">await </span><span class="s1">Promise.all([</span>
    <span class="s1">queue.push(),</span>
    <span class="s1">queue.push(),</span>
    <span class="s1">queue.push()</span>
  <span class="s1">])</span>

  <span class="s1">t.deepEqual(logs, [</span>
    <span class="s0">'processed'</span><span class="s1">,</span>
    <span class="s0">'processed'</span><span class="s1">,</span>
    <span class="s0">'processed'</span><span class="s1">,</span>
    <span class="s0">'called drain'</span><span class="s1">,</span>
    <span class="s0">'drained promise resolved'</span>
  <span class="s1">], </span><span class="s0">'events happened in correct order'</span><span class="s1">)</span>
<span class="s1">})</span>

<span class="s1">test(</span><span class="s0">'drained should handle undefined drain function'</span><span class="s1">, async </span><span class="s2">function </span><span class="s1">(t) {</span>
  <span class="s2">const </span><span class="s1">queue = buildQueue(worker, </span><span class="s3">1</span><span class="s1">)</span>

  <span class="s1">async </span><span class="s2">function </span><span class="s1">worker (arg) {</span>
    <span class="s2">await </span><span class="s1">sleep(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">arg</span>
  <span class="s1">}</span>

  <span class="s1">queue.drain = undefined</span>
  <span class="s1">queue.push(</span><span class="s3">1</span><span class="s1">)</span>
  <span class="s2">await </span><span class="s1">queue.drained()</span>

  <span class="s1">t.pass(</span><span class="s0">'drained resolved successfully with undefined drain'</span><span class="s1">)</span>
<span class="s1">})</span>
</pre>
</body>
</html>