<html>
<head>
<title>_tsserver.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_tsserver.js</font>
</center></td></tr></table>
<pre><span class="s0">/*! ***************************************************************************** 
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use 
this file except in compliance with the License. You may obtain a copy of the 
License at http://www.apache.org/licenses/LICENSE-2.0 
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED 
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions 
and limitations under the License. 
***************************************************************************** */</span>


<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">__create = Object.create;</span>
<span class="s3">var </span><span class="s1">__defProp = Object.defineProperty;</span>
<span class="s3">var </span><span class="s1">__getOwnPropDesc = Object.getOwnPropertyDescriptor;</span>
<span class="s3">var </span><span class="s1">__getOwnPropNames = Object.getOwnPropertyNames;</span>
<span class="s3">var </span><span class="s1">__getProtoOf = Object.getPrototypeOf;</span>
<span class="s3">var </span><span class="s1">__hasOwnProp = Object.prototype.hasOwnProperty;</span>
<span class="s3">var </span><span class="s1">__copyProps = (to, from, except, desc) =&gt; {</span>
  <span class="s3">if </span><span class="s1">(from &amp;&amp; </span><span class="s3">typeof </span><span class="s1">from === </span><span class="s2">&quot;object&quot; </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">from === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">key of __getOwnPropNames(from))</span>
      <span class="s3">if </span><span class="s1">(!__hasOwnProp.call(to, key) &amp;&amp; key !== except)</span>
        <span class="s1">__defProp(to, key, { get: () =&gt; from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">to;</span>
<span class="s1">};</span>
<span class="s3">var </span><span class="s1">__reExport = (target, mod, secondTarget) =&gt; (__copyProps(target, mod, </span><span class="s2">&quot;default&quot;</span><span class="s1">), secondTarget &amp;&amp; __copyProps(secondTarget, mod, </span><span class="s2">&quot;default&quot;</span><span class="s1">));</span>
<span class="s3">var </span><span class="s1">__toESM = (mod, isNodeMode, target) =&gt; (target = mod != </span><span class="s3">null </span><span class="s1">? __create(__getProtoOf(mod)) : {}, __copyProps(</span>
  <span class="s0">// If the importer is in node compatibility mode or this is not an ESM</span>
  <span class="s0">// file that has been converted to a CommonJS file using a Babel-</span>
  <span class="s0">// compatible transform (i.e. &quot;__esModule&quot; has not been set), then set</span>
  <span class="s0">// &quot;default&quot; to the CommonJS &quot;module.exports&quot; for node compatibility.</span>
  <span class="s1">isNodeMode || !mod || !mod.__esModule ? __defProp(target, </span><span class="s2">&quot;default&quot;</span><span class="s1">, { value: mod, enumerable: </span><span class="s3">true </span><span class="s1">}) : target,</span>
  <span class="s1">mod</span>
<span class="s1">));</span>

<span class="s0">// src/tsserver/server.ts</span>
<span class="s3">var </span><span class="s1">import_os2 = __toESM(require(</span><span class="s2">&quot;os&quot;</span><span class="s1">));</span>

<span class="s0">// src/typescript/typescript.ts</span>
<span class="s3">var </span><span class="s1">typescript_exports = {};</span>
<span class="s1">__reExport(typescript_exports, require(</span><span class="s2">&quot;./typescript.js&quot;</span><span class="s1">));</span>

<span class="s0">// src/tsserver/nodeServer.ts</span>
<span class="s3">var </span><span class="s1">import_child_process = __toESM(require(</span><span class="s2">&quot;child_process&quot;</span><span class="s1">));</span>
<span class="s3">var </span><span class="s1">import_fs = __toESM(require(</span><span class="s2">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s3">var </span><span class="s1">import_net = __toESM(require(</span><span class="s2">&quot;net&quot;</span><span class="s1">));</span>
<span class="s3">var </span><span class="s1">import_os = __toESM(require(</span><span class="s2">&quot;os&quot;</span><span class="s1">));</span>
<span class="s3">var </span><span class="s1">import_readline = __toESM(require(</span><span class="s2">&quot;readline&quot;</span><span class="s1">));</span>

<span class="s0">// src/tsserver/common.ts</span>
<span class="s3">function </span><span class="s1">getLogLevel(level) {</span>
  <span class="s3">if </span><span class="s1">(level) {</span>
    <span class="s3">const </span><span class="s1">l = level.toLowerCase();</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">name </span><span class="s3">in </span><span class="s1">typescript_exports.server.LogLevel) {</span>
      <span class="s3">if </span><span class="s1">(isNaN(+name) &amp;&amp; l === name.toLowerCase()) {</span>
        <span class="s3">return </span><span class="s1">typescript_exports.server.LogLevel[name];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// src/tsserver/nodeServer.ts</span>
<span class="s3">function </span><span class="s1">parseLoggingEnvironmentString(logEnvStr) {</span>
  <span class="s3">if </span><span class="s1">(!logEnvStr) {</span>
    <span class="s3">return </span><span class="s1">{};</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">logEnv = { logToFile: </span><span class="s3">true </span><span class="s1">};</span>
  <span class="s3">const </span><span class="s1">args = logEnvStr.split(</span><span class="s2">&quot; &quot;</span><span class="s1">);</span>
  <span class="s3">const </span><span class="s1">len = args.length - </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; len; i += </span><span class="s4">2</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s1">option = args[i];</span>
    <span class="s3">const </span><span class="s1">{ value, extraPartCounter } = getEntireValue(i + </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">i += extraPartCounter;</span>
    <span class="s3">if </span><span class="s1">(option &amp;&amp; value) {</span>
      <span class="s3">switch </span><span class="s1">(option) {</span>
        <span class="s3">case </span><span class="s2">&quot;-file&quot;</span><span class="s1">:</span>
          <span class="s1">logEnv.file = value;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;-level&quot;</span><span class="s1">:</span>
          <span class="s3">const </span><span class="s1">level = getLogLevel(value);</span>
          <span class="s1">logEnv.detailLevel = level !== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">? level : typescript_exports.server.LogLevel.normal;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;-traceToConsole&quot;</span><span class="s1">:</span>
          <span class="s1">logEnv.traceToConsole = value.toLowerCase() === </span><span class="s2">&quot;true&quot;</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;-logToFile&quot;</span><span class="s1">:</span>
          <span class="s1">logEnv.logToFile = value.toLowerCase() === </span><span class="s2">&quot;true&quot;</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">logEnv;</span>
  <span class="s3">function </span><span class="s1">getEntireValue(initialIndex) {</span>
    <span class="s3">let </span><span class="s1">pathStart = args[initialIndex];</span>
    <span class="s3">let </span><span class="s1">extraPartCounter = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(pathStart.charCodeAt(</span><span class="s4">0</span><span class="s1">) === typescript_exports.CharacterCodes.doubleQuote &amp;&amp; pathStart.charCodeAt(pathStart.length - </span><span class="s4">1</span><span class="s1">) !== typescript_exports.CharacterCodes.doubleQuote) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = initialIndex + </span><span class="s4">1</span><span class="s1">; i &lt; args.length; i++) {</span>
        <span class="s1">pathStart += </span><span class="s2">&quot; &quot;</span><span class="s1">;</span>
        <span class="s1">pathStart += args[i];</span>
        <span class="s1">extraPartCounter++;</span>
        <span class="s3">if </span><span class="s1">(pathStart.charCodeAt(pathStart.length - </span><span class="s4">1</span><span class="s1">) === typescript_exports.CharacterCodes.doubleQuote) </span><span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">{ value: (</span><span class="s4">0</span><span class="s1">, typescript_exports.stripQuotes)(pathStart), extraPartCounter };</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">parseServerMode() {</span>
  <span class="s3">const </span><span class="s1">mode = typescript_exports.server.findArgument(</span><span class="s2">&quot;--serverMode&quot;</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(!mode) </span><span class="s3">return void </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">switch </span><span class="s1">(mode.toLowerCase()) {</span>
    <span class="s3">case </span><span class="s2">&quot;semantic&quot;</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">typescript_exports.LanguageServiceMode.Semantic;</span>
    <span class="s3">case </span><span class="s2">&quot;partialsemantic&quot;</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">typescript_exports.LanguageServiceMode.PartialSemantic;</span>
    <span class="s3">case </span><span class="s2">&quot;syntactic&quot;</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">typescript_exports.LanguageServiceMode.Syntactic;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">mode;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">initializeNodeSystem() {</span>
  <span class="s3">const </span><span class="s1">sys4 = typescript_exports.Debug.checkDefined(typescript_exports.sys);</span>
  <span class="s3">class </span><span class="s1">Logger {</span>
    <span class="s1">constructor(logFilename, traceToConsole, level) {</span>
      <span class="s3">this</span><span class="s1">.logFilename = logFilename;</span>
      <span class="s3">this</span><span class="s1">.traceToConsole = traceToConsole;</span>
      <span class="s3">this</span><span class="s1">.level = level;</span>
      <span class="s3">this</span><span class="s1">.seq = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.inGroup = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.firstInGroup = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.fd = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.logFilename) {</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">this</span><span class="s1">.fd = import_fs.default.openSync(</span><span class="s3">this</span><span class="s1">.logFilename, </span><span class="s2">&quot;w&quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">{</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">static </span><span class="s1">padStringRight(str, padding) {</span>
      <span class="s3">return </span><span class="s1">(str + padding).slice(</span><span class="s4">0</span><span class="s1">, padding.length);</span>
    <span class="s1">}</span>
    <span class="s1">close() {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.fd &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">import_fs.default.close(</span><span class="s3">this</span><span class="s1">.fd, typescript_exports.noop);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLogFileName() {</span>
      <span class="s3">return this</span><span class="s1">.logFilename;</span>
    <span class="s1">}</span>
    <span class="s1">perftrc(s) {</span>
      <span class="s3">this</span><span class="s1">.msg(s, typescript_exports.server.Msg.Perf);</span>
    <span class="s1">}</span>
    <span class="s1">info(s) {</span>
      <span class="s3">this</span><span class="s1">.msg(s, typescript_exports.server.Msg.Info);</span>
    <span class="s1">}</span>
    <span class="s1">err(s) {</span>
      <span class="s3">this</span><span class="s1">.msg(s, typescript_exports.server.Msg.Err);</span>
    <span class="s1">}</span>
    <span class="s1">startGroup() {</span>
      <span class="s3">this</span><span class="s1">.inGroup = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.firstInGroup = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">endGroup() {</span>
      <span class="s3">this</span><span class="s1">.inGroup = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">loggingEnabled() {</span>
      <span class="s3">return </span><span class="s1">!!</span><span class="s3">this</span><span class="s1">.logFilename || </span><span class="s3">this</span><span class="s1">.traceToConsole;</span>
    <span class="s1">}</span>
    <span class="s1">hasLevel(level) {</span>
      <span class="s3">return this</span><span class="s1">.loggingEnabled() &amp;&amp; </span><span class="s3">this</span><span class="s1">.level &gt;= level;</span>
    <span class="s1">}</span>
    <span class="s1">msg(s, type = typescript_exports.server.Msg.Err) {</span>
      <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.canWrite()) </span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">s = </span><span class="s2">`[</span><span class="s1">${typescript_exports.server.nowString()}</span><span class="s2">] </span><span class="s1">${s}</span>
<span class="s2">`</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.inGroup || </span><span class="s3">this</span><span class="s1">.firstInGroup) {</span>
        <span class="s3">const </span><span class="s1">prefix = Logger.padStringRight(type + </span><span class="s2">&quot; &quot; </span><span class="s1">+ </span><span class="s3">this</span><span class="s1">.seq.toString(), </span><span class="s2">&quot;          &quot;</span><span class="s1">);</span>
        <span class="s1">s = prefix + s;</span>
      <span class="s1">}</span>
      <span class="s3">this</span><span class="s1">.write(s, type);</span>
      <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.inGroup) {</span>
        <span class="s3">this</span><span class="s1">.seq++;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">canWrite() {</span>
      <span class="s3">return this</span><span class="s1">.fd &gt;= </span><span class="s4">0 </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">.traceToConsole;</span>
    <span class="s1">}</span>
    <span class="s1">write(s, _type) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.fd &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">const </span><span class="s1">buf = Buffer.from(s);</span>
        <span class="s1">import_fs.default.writeSync(</span>
          <span class="s3">this</span><span class="s1">.fd,</span>
          <span class="s1">buf,</span>
          <span class="s4">0</span><span class="s1">,</span>
          <span class="s1">buf.length,</span>
          <span class="s0">/*position*/</span>
          <span class="s3">null</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.traceToConsole) {</span>
        <span class="s1">console.warn(s);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">libDirectory = (</span><span class="s4">0</span><span class="s1">, typescript_exports.getDirectoryPath)((</span><span class="s4">0</span><span class="s1">, typescript_exports.normalizePath)(sys4.getExecutingFilePath()));</span>
  <span class="s3">const </span><span class="s1">useWatchGuard = process.platform === </span><span class="s2">&quot;win32&quot;</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s1">originalWatchDirectory = sys4.watchDirectory.bind(sys4);</span>
  <span class="s3">const </span><span class="s1">logger = createLogger();</span>
  <span class="s1">typescript_exports.Debug.loggingHost = {</span>
    <span class="s1">log(level, s) {</span>
      <span class="s3">switch </span><span class="s1">(level) {</span>
        <span class="s3">case </span><span class="s1">typescript_exports.LogLevel.Error:</span>
        <span class="s3">case </span><span class="s1">typescript_exports.LogLevel.Warning:</span>
          <span class="s3">return </span><span class="s1">logger.msg(s, typescript_exports.server.Msg.Err);</span>
        <span class="s3">case </span><span class="s1">typescript_exports.LogLevel.Info:</span>
        <span class="s3">case </span><span class="s1">typescript_exports.LogLevel.Verbose:</span>
          <span class="s3">return </span><span class="s1">logger.msg(s, typescript_exports.server.Msg.Info);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s3">const </span><span class="s1">pending = (</span><span class="s4">0</span><span class="s1">, typescript_exports.createQueue)();</span>
  <span class="s3">let </span><span class="s1">canWrite = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(useWatchGuard) {</span>
    <span class="s3">const </span><span class="s1">currentDrive = extractWatchDirectoryCacheKey(</span>
      <span class="s1">sys4.resolvePath(sys4.getCurrentDirectory()),</span>
      <span class="s0">/*currentDriveKey*/</span>
      <span class="s3">void </span><span class="s4">0</span>
    <span class="s1">);</span>
    <span class="s3">const </span><span class="s1">statusCache = </span><span class="s0">/* @__PURE__ */ </span><span class="s3">new </span><span class="s1">Map();</span>
    <span class="s1">sys4.watchDirectory = (path, callback, recursive, options) =&gt; {</span>
      <span class="s3">const </span><span class="s1">cacheKey = extractWatchDirectoryCacheKey(path, currentDrive);</span>
      <span class="s3">let </span><span class="s1">status = cacheKey &amp;&amp; statusCache.get(cacheKey);</span>
      <span class="s3">if </span><span class="s1">(status === </span><span class="s3">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {</span>
          <span class="s1">logger.info(</span><span class="s2">`</span><span class="s1">${cacheKey} </span><span class="s2">for path </span><span class="s1">${path} </span><span class="s2">not found in cache...`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">const </span><span class="s1">args = [(</span><span class="s4">0</span><span class="s1">, typescript_exports.combinePaths)(libDirectory, </span><span class="s2">&quot;watchGuard.js&quot;</span><span class="s1">), path];</span>
          <span class="s3">if </span><span class="s1">(logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {</span>
            <span class="s1">logger.info(</span><span class="s2">`Starting </span><span class="s1">${process.execPath} </span><span class="s2">with args:</span><span class="s1">${typescript_exports.server.stringifyIndented(args)}</span><span class="s2">`</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">import_child_process.default.execFileSync(process.execPath, args, { stdio: </span><span class="s2">&quot;ignore&quot;</span><span class="s1">, env: { ELECTRON_RUN_AS_NODE: </span><span class="s2">&quot;1&quot; </span><span class="s1">} });</span>
          <span class="s1">status = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">if </span><span class="s1">(logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {</span>
            <span class="s1">logger.info(</span><span class="s2">`WatchGuard for path </span><span class="s1">${path} </span><span class="s2">returned: OK`</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
          <span class="s1">status = </span><span class="s3">false</span><span class="s1">;</span>
          <span class="s3">if </span><span class="s1">(logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {</span>
            <span class="s1">logger.info(</span><span class="s2">`WatchGuard for path </span><span class="s1">${path} </span><span class="s2">returned: </span><span class="s1">${e.message}</span><span class="s2">`</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(cacheKey) {</span>
          <span class="s1">statusCache.set(cacheKey, status);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {</span>
        <span class="s1">logger.info(</span><span class="s2">`watchDirectory for </span><span class="s1">${path} </span><span class="s2">uses cached drive information.`</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(status) {</span>
        <span class="s3">return </span><span class="s1">watchDirectorySwallowingException(path, callback, recursive, options);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">typescript_exports.noopFileWatcher;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">sys4.watchDirectory = watchDirectorySwallowingException;</span>
  <span class="s1">}</span>
  <span class="s1">sys4.write = (s) =&gt; writeMessage(Buffer.from(s, </span><span class="s2">&quot;utf8&quot;</span><span class="s1">));</span>
  <span class="s1">sys4.setTimeout = setTimeout;</span>
  <span class="s1">sys4.clearTimeout = clearTimeout;</span>
  <span class="s1">sys4.setImmediate = setImmediate;</span>
  <span class="s1">sys4.clearImmediate = clearImmediate;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">global !== </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp; global.gc) {</span>
    <span class="s1">sys4.gc = () =&gt; {</span>
      <span class="s3">var </span><span class="s1">_a;</span>
      <span class="s3">return </span><span class="s1">(_a = global.gc) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _a.call(global);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">cancellationToken = createCancellationToken(sys4.args);</span>
  <span class="s3">const </span><span class="s1">localeStr = typescript_exports.server.findArgument(</span><span class="s2">&quot;--locale&quot;</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(localeStr) {</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, typescript_exports.validateLocaleAndSetLanguage)(localeStr, sys4);</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">modeOrUnknown = parseServerMode();</span>
  <span class="s3">let </span><span class="s1">serverMode;</span>
  <span class="s3">let </span><span class="s1">unknownServerMode;</span>
  <span class="s3">if </span><span class="s1">(modeOrUnknown !== </span><span class="s3">void </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">modeOrUnknown === </span><span class="s2">&quot;number&quot;</span><span class="s1">) serverMode = modeOrUnknown;</span>
    <span class="s3">else </span><span class="s1">unknownServerMode = modeOrUnknown;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">args: process.argv,</span>
    <span class="s1">logger,</span>
    <span class="s1">cancellationToken,</span>
    <span class="s1">serverMode,</span>
    <span class="s1">unknownServerMode,</span>
    <span class="s1">startSession: startNodeSession</span>
  <span class="s1">};</span>
  <span class="s3">function </span><span class="s1">createLogger() {</span>
    <span class="s3">const </span><span class="s1">cmdLineLogFileName = typescript_exports.server.findArgument(</span><span class="s2">&quot;--logFile&quot;</span><span class="s1">);</span>
    <span class="s3">const </span><span class="s1">cmdLineVerbosity = getLogLevel(typescript_exports.server.findArgument(</span><span class="s2">&quot;--logVerbosity&quot;</span><span class="s1">));</span>
    <span class="s3">const </span><span class="s1">envLogOptions = parseLoggingEnvironmentString(process.env.TSS_LOG);</span>
    <span class="s3">const </span><span class="s1">unsubstitutedLogFileName = cmdLineLogFileName ? (</span><span class="s4">0</span><span class="s1">, typescript_exports.stripQuotes)(cmdLineLogFileName) : envLogOptions.logToFile ? envLogOptions.file || libDirectory + </span><span class="s2">&quot;/.log&quot; </span><span class="s1">+ process.pid.toString() : </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">substitutedLogFileName = unsubstitutedLogFileName ? unsubstitutedLogFileName.replace(</span><span class="s2">&quot;PID&quot;</span><span class="s1">, process.pid.toString()) : </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">logVerbosity = cmdLineVerbosity || envLogOptions.detailLevel;</span>
    <span class="s3">return new </span><span class="s1">Logger(substitutedLogFileName, envLogOptions.traceToConsole, logVerbosity);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">writeMessage(buf) {</span>
    <span class="s3">if </span><span class="s1">(!canWrite) {</span>
      <span class="s1">pending.enqueue(buf);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">canWrite = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">process.stdout.write(buf, setCanWriteFlagAndWriteMessageIfNecessary);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">setCanWriteFlagAndWriteMessageIfNecessary() {</span>
    <span class="s1">canWrite = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(!pending.isEmpty()) {</span>
      <span class="s1">writeMessage(pending.dequeue());</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">extractWatchDirectoryCacheKey(path, currentDriveKey) {</span>
    <span class="s1">path = (</span><span class="s4">0</span><span class="s1">, typescript_exports.normalizeSlashes)(path);</span>
    <span class="s3">if </span><span class="s1">(isUNCPath(path)) {</span>
      <span class="s3">const </span><span class="s1">firstSlash = path.indexOf(typescript_exports.directorySeparator, </span><span class="s4">2</span><span class="s1">);</span>
      <span class="s3">return </span><span class="s1">firstSlash !== -</span><span class="s4">1 </span><span class="s1">? (</span><span class="s4">0</span><span class="s1">, typescript_exports.toFileNameLowerCase)(path.substring(</span><span class="s4">0</span><span class="s1">, firstSlash)) : path;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">rootLength = (</span><span class="s4">0</span><span class="s1">, typescript_exports.getRootLength)(path);</span>
    <span class="s3">if </span><span class="s1">(rootLength === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">currentDriveKey;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(path.charCodeAt(</span><span class="s4">1</span><span class="s1">) === typescript_exports.CharacterCodes.colon &amp;&amp; path.charCodeAt(</span><span class="s4">2</span><span class="s1">) === typescript_exports.CharacterCodes.slash) {</span>
      <span class="s3">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, typescript_exports.toFileNameLowerCase)(path.charAt(</span><span class="s4">0</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(path.charCodeAt(</span><span class="s4">0</span><span class="s1">) === typescript_exports.CharacterCodes.slash &amp;&amp; path.charCodeAt(</span><span class="s4">1</span><span class="s1">) !== typescript_exports.CharacterCodes.slash) {</span>
      <span class="s3">return </span><span class="s1">currentDriveKey;</span>
    <span class="s1">}</span>
    <span class="s3">return void </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isUNCPath(s) {</span>
    <span class="s3">return </span><span class="s1">s.length &gt; </span><span class="s4">2 </span><span class="s1">&amp;&amp; s.charCodeAt(</span><span class="s4">0</span><span class="s1">) === typescript_exports.CharacterCodes.slash &amp;&amp; s.charCodeAt(</span><span class="s4">1</span><span class="s1">) === typescript_exports.CharacterCodes.slash;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">watchDirectorySwallowingException(path, callback, recursive, options) {</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">originalWatchDirectory(path, callback, recursive, options);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
      <span class="s1">logger.info(</span><span class="s2">`Exception when creating directory watcher: </span><span class="s1">${e.message}</span><span class="s2">`</span><span class="s1">);</span>
      <span class="s3">return </span><span class="s1">typescript_exports.noopFileWatcher;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">parseEventPort(eventPortStr) {</span>
  <span class="s3">const </span><span class="s1">eventPort = eventPortStr === </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: parseInt(eventPortStr);</span>
  <span class="s3">return </span><span class="s1">eventPort !== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">&amp;&amp; !isNaN(eventPort) ? eventPort : </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">startNodeSession(options, logger, cancellationToken) {</span>
  <span class="s3">const </span><span class="s1">rl = import_readline.default.createInterface({</span>
    <span class="s1">input: process.stdin,</span>
    <span class="s1">output: process.stdout,</span>
    <span class="s1">terminal: </span><span class="s3">false</span>
  <span class="s1">});</span>
  <span class="s3">const </span><span class="s1">_NodeTypingsInstallerAdapter = </span><span class="s3">class </span><span class="s1">_NodeTypingsInstallerAdapter </span><span class="s3">extends </span><span class="s1">typescript_exports.server.TypingsInstallerAdapter {</span>
    <span class="s1">constructor(telemetryEnabled2, logger2, host, globalTypingsCacheLocation, typingSafeListLocation2, typesMapLocation2, npmLocation2, validateDefaultNpmLocation2, event) {</span>
      <span class="s3">super</span><span class="s1">(</span>
        <span class="s1">telemetryEnabled2,</span>
        <span class="s1">logger2,</span>
        <span class="s1">host,</span>
        <span class="s1">globalTypingsCacheLocation,</span>
        <span class="s1">event,</span>
        <span class="s1">_NodeTypingsInstallerAdapter.maxActiveRequestCount</span>
      <span class="s1">);</span>
      <span class="s3">this</span><span class="s1">.typingSafeListLocation = typingSafeListLocation2;</span>
      <span class="s3">this</span><span class="s1">.typesMapLocation = typesMapLocation2;</span>
      <span class="s3">this</span><span class="s1">.npmLocation = npmLocation2;</span>
      <span class="s3">this</span><span class="s1">.validateDefaultNpmLocation = validateDefaultNpmLocation2;</span>
    <span class="s1">}</span>
    <span class="s1">createInstallerProcess() {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.logger.hasLevel(typescript_exports.server.LogLevel.requestTime)) {</span>
        <span class="s3">this</span><span class="s1">.logger.info(</span><span class="s2">&quot;Binding...&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">const </span><span class="s1">args = [typescript_exports.server.Arguments.GlobalCacheLocation, </span><span class="s3">this</span><span class="s1">.globalTypingsCacheLocation];</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.telemetryEnabled) {</span>
        <span class="s1">args.push(typescript_exports.server.Arguments.EnableTelemetry);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.logger.loggingEnabled() &amp;&amp; </span><span class="s3">this</span><span class="s1">.logger.getLogFileName()) {</span>
        <span class="s1">args.push(typescript_exports.server.Arguments.LogFile, (</span><span class="s4">0</span><span class="s1">, typescript_exports.combinePaths)((</span><span class="s4">0</span><span class="s1">, typescript_exports.getDirectoryPath)((</span><span class="s4">0</span><span class="s1">, typescript_exports.normalizeSlashes)(</span><span class="s3">this</span><span class="s1">.logger.getLogFileName())), </span><span class="s2">`ti-</span><span class="s1">${process.pid}</span><span class="s2">.log`</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.typingSafeListLocation) {</span>
        <span class="s1">args.push(typescript_exports.server.Arguments.TypingSafeListLocation, </span><span class="s3">this</span><span class="s1">.typingSafeListLocation);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.typesMapLocation) {</span>
        <span class="s1">args.push(typescript_exports.server.Arguments.TypesMapLocation, </span><span class="s3">this</span><span class="s1">.typesMapLocation);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.npmLocation) {</span>
        <span class="s1">args.push(typescript_exports.server.Arguments.NpmLocation, </span><span class="s3">this</span><span class="s1">.npmLocation);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.validateDefaultNpmLocation) {</span>
        <span class="s1">args.push(typescript_exports.server.Arguments.ValidateDefaultNpmLocation);</span>
      <span class="s1">}</span>
      <span class="s3">const </span><span class="s1">execArgv = [];</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">arg of process.execArgv) {</span>
        <span class="s3">const </span><span class="s1">match = </span><span class="s5">/^--((?:debug|inspect)(?:-brk)?)(?:=(\d+))?$/</span><span class="s1">.exec(arg);</span>
        <span class="s3">if </span><span class="s1">(match) {</span>
          <span class="s3">const </span><span class="s1">currentPort = match[</span><span class="s4">2</span><span class="s1">] !== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">? +match[</span><span class="s4">2</span><span class="s1">] : match[</span><span class="s4">1</span><span class="s1">].charAt(</span><span class="s4">0</span><span class="s1">) === </span><span class="s2">&quot;d&quot; </span><span class="s1">? </span><span class="s4">5858 </span><span class="s1">: </span><span class="s4">9229</span><span class="s1">;</span>
          <span class="s1">execArgv.push(</span><span class="s2">`--</span><span class="s1">${match[</span><span class="s4">1</span><span class="s1">]}</span><span class="s2">=</span><span class="s1">${currentPort + </span><span class="s4">1</span><span class="s1">}</span><span class="s2">`</span><span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">const </span><span class="s1">typingsInstaller = (</span><span class="s4">0</span><span class="s1">, typescript_exports.combinePaths)((</span><span class="s4">0</span><span class="s1">, typescript_exports.getDirectoryPath)(typescript_exports.sys.getExecutingFilePath()), </span><span class="s2">&quot;typingsInstaller.js&quot;</span><span class="s1">);</span>
      <span class="s3">this</span><span class="s1">.installer = import_child_process.default.fork(typingsInstaller, args, { execArgv });</span>
      <span class="s3">this</span><span class="s1">.installer.on(</span><span class="s2">&quot;message&quot;</span><span class="s1">, (m) =&gt; </span><span class="s3">this</span><span class="s1">.handleMessage(m));</span>
      <span class="s3">this</span><span class="s1">.host.setImmediate(() =&gt; </span><span class="s3">this</span><span class="s1">.event({ pid: </span><span class="s3">this</span><span class="s1">.installer.pid }, </span><span class="s2">&quot;typingsInstallerPid&quot;</span><span class="s1">));</span>
      <span class="s1">process.on(</span><span class="s2">&quot;exit&quot;</span><span class="s1">, () =&gt; {</span>
        <span class="s3">this</span><span class="s1">.installer.kill();</span>
      <span class="s1">});</span>
      <span class="s3">return this</span><span class="s1">.installer;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s0">// This number is essentially arbitrary.  Processing more than one typings request</span>
  <span class="s0">// at a time makes sense, but having too many in the pipe results in a hang</span>
  <span class="s0">// (see https://github.com/nodejs/node/issues/7657).</span>
  <span class="s0">// It would be preferable to base our limit on the amount of space left in the</span>
  <span class="s0">// buffer, but we have yet to find a way to retrieve that value.</span>
  <span class="s1">_NodeTypingsInstallerAdapter.maxActiveRequestCount = </span><span class="s4">10</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">NodeTypingsInstallerAdapter = _NodeTypingsInstallerAdapter;</span>
  <span class="s3">class </span><span class="s1">IOSession </span><span class="s3">extends </span><span class="s1">typescript_exports.server.Session {</span>
    <span class="s1">constructor() {</span>
      <span class="s3">const </span><span class="s1">event = (body, eventName) =&gt; {</span>
        <span class="s3">this</span><span class="s1">.event(body, eventName);</span>
      <span class="s1">};</span>
      <span class="s3">const </span><span class="s1">host = typescript_exports.sys;</span>
      <span class="s3">const </span><span class="s1">typingsInstaller = disableAutomaticTypingAcquisition ? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: </span><span class="s3">new </span><span class="s1">NodeTypingsInstallerAdapter(telemetryEnabled, logger, host, getGlobalTypingsCacheLocation(), typingSafeListLocation, typesMapLocation, npmLocation, validateDefaultNpmLocation, event);</span>
      <span class="s3">super</span><span class="s1">({</span>
        <span class="s1">host,</span>
        <span class="s1">cancellationToken,</span>
        <span class="s1">...options,</span>
        <span class="s1">typingsInstaller,</span>
        <span class="s1">byteLength: Buffer.byteLength,</span>
        <span class="s1">hrtime: process.hrtime,</span>
        <span class="s1">logger,</span>
        <span class="s1">canUseEvents: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">typesMapLocation</span>
      <span class="s1">});</span>
      <span class="s3">this</span><span class="s1">.eventPort = eventPort;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.canUseEvents &amp;&amp; </span><span class="s3">this</span><span class="s1">.eventPort) {</span>
        <span class="s3">const </span><span class="s1">s = import_net.default.connect({ port: </span><span class="s3">this</span><span class="s1">.eventPort }, () =&gt; {</span>
          <span class="s3">this</span><span class="s1">.eventSocket = s;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.socketEventQueue) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">event2 of </span><span class="s3">this</span><span class="s1">.socketEventQueue) {</span>
              <span class="s3">this</span><span class="s1">.writeToEventSocket(event2.body, event2.eventName);</span>
            <span class="s1">}</span>
            <span class="s3">this</span><span class="s1">.socketEventQueue = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s3">this</span><span class="s1">.constructed = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">event(body, eventName) {</span>
      <span class="s1">typescript_exports.Debug.assert(!!</span><span class="s3">this</span><span class="s1">.constructed, </span><span class="s2">&quot;Should only call `IOSession.prototype.event` on an initialized IOSession&quot;</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.canUseEvents &amp;&amp; </span><span class="s3">this</span><span class="s1">.eventPort) {</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.eventSocket) {</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {</span>
            <span class="s3">this</span><span class="s1">.logger.info(</span><span class="s2">`eventPort: event &quot;</span><span class="s1">${eventName}</span><span class="s2">&quot; queued, but socket not yet initialized`</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">(</span><span class="s3">this</span><span class="s1">.socketEventQueue || (</span><span class="s3">this</span><span class="s1">.socketEventQueue = [])).push({ body, eventName });</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">typescript_exports.Debug.assert(</span><span class="s3">this</span><span class="s1">.socketEventQueue === </span><span class="s3">void </span><span class="s4">0</span><span class="s1">);</span>
          <span class="s3">this</span><span class="s1">.writeToEventSocket(body, eventName);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">super</span><span class="s1">.event(body, eventName);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">writeToEventSocket(body, eventName) {</span>
      <span class="s3">this</span><span class="s1">.eventSocket.write(typescript_exports.server.formatMessage(typescript_exports.server.toEvent(eventName, body), </span><span class="s3">this</span><span class="s1">.logger, </span><span class="s3">this</span><span class="s1">.byteLength, </span><span class="s3">this</span><span class="s1">.host.newLine), </span><span class="s2">&quot;utf8&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">exit() {</span>
      <span class="s3">var </span><span class="s1">_a;</span>
      <span class="s3">this</span><span class="s1">.logger.info(</span><span class="s2">&quot;Exiting...&quot;</span><span class="s1">);</span>
      <span class="s3">this</span><span class="s1">.projectService.closeLog();</span>
      <span class="s1">(_a = typescript_exports.tracing) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _a.stopTracing();</span>
      <span class="s1">process.exit(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">listen() {</span>
      <span class="s1">rl.on(</span><span class="s2">&quot;line&quot;</span><span class="s1">, (input) =&gt; {</span>
        <span class="s3">const </span><span class="s1">message = input.trim();</span>
        <span class="s3">this</span><span class="s1">.onMessage(message);</span>
      <span class="s1">});</span>
      <span class="s1">rl.on(</span><span class="s2">&quot;close&quot;</span><span class="s1">, () =&gt; {</span>
        <span class="s3">this</span><span class="s1">.exit();</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">class </span><span class="s1">IpcIOSession </span><span class="s3">extends </span><span class="s1">IOSession {</span>
    <span class="s1">writeMessage(msg) {</span>
      <span class="s3">const </span><span class="s1">verboseLogging = logger.hasLevel(typescript_exports.server.LogLevel.verbose);</span>
      <span class="s3">if </span><span class="s1">(verboseLogging) {</span>
        <span class="s3">const </span><span class="s1">json = JSON.stringify(msg);</span>
        <span class="s1">logger.info(</span><span class="s2">`</span><span class="s1">${msg.type}</span><span class="s2">:</span><span class="s1">${typescript_exports.server.indent(json)}</span><span class="s2">`</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">process.send(msg);</span>
    <span class="s1">}</span>
    <span class="s1">parseMessage(message) {</span>
      <span class="s3">return </span><span class="s1">message;</span>
    <span class="s1">}</span>
    <span class="s1">toStringMessage(message) {</span>
      <span class="s3">return </span><span class="s1">JSON.stringify(message, </span><span class="s3">void </span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">listen() {</span>
      <span class="s1">process.on(</span><span class="s2">&quot;message&quot;</span><span class="s1">, (e) =&gt; {</span>
        <span class="s3">this</span><span class="s1">.onMessage(e);</span>
      <span class="s1">});</span>
      <span class="s1">process.on(</span><span class="s2">&quot;disconnect&quot;</span><span class="s1">, () =&gt; {</span>
        <span class="s3">this</span><span class="s1">.exit();</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">eventPort = parseEventPort(typescript_exports.server.findArgument(</span><span class="s2">&quot;--eventPort&quot;</span><span class="s1">));</span>
  <span class="s3">const </span><span class="s1">typingSafeListLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.TypingSafeListLocation);</span>
  <span class="s3">const </span><span class="s1">typesMapLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.TypesMapLocation) || (</span><span class="s4">0</span><span class="s1">, typescript_exports.combinePaths)((</span><span class="s4">0</span><span class="s1">, typescript_exports.getDirectoryPath)(typescript_exports.sys.getExecutingFilePath()), </span><span class="s2">&quot;typesMap.json&quot;</span><span class="s1">);</span>
  <span class="s3">const </span><span class="s1">npmLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.NpmLocation);</span>
  <span class="s3">const </span><span class="s1">validateDefaultNpmLocation = typescript_exports.server.hasArgument(typescript_exports.server.Arguments.ValidateDefaultNpmLocation);</span>
  <span class="s3">const </span><span class="s1">disableAutomaticTypingAcquisition = typescript_exports.server.hasArgument(</span><span class="s2">&quot;--disableAutomaticTypingAcquisition&quot;</span><span class="s1">);</span>
  <span class="s3">const </span><span class="s1">useNodeIpc = typescript_exports.server.hasArgument(</span><span class="s2">&quot;--useNodeIpc&quot;</span><span class="s1">);</span>
  <span class="s3">const </span><span class="s1">telemetryEnabled = typescript_exports.server.hasArgument(typescript_exports.server.Arguments.EnableTelemetry);</span>
  <span class="s3">const </span><span class="s1">commandLineTraceDir = typescript_exports.server.findArgument(</span><span class="s2">&quot;--traceDirectory&quot;</span><span class="s1">);</span>
  <span class="s3">const </span><span class="s1">traceDir = commandLineTraceDir ? (</span><span class="s4">0</span><span class="s1">, typescript_exports.stripQuotes)(commandLineTraceDir) : process.env.TSS_TRACE;</span>
  <span class="s3">if </span><span class="s1">(traceDir) {</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, typescript_exports.startTracing)(</span><span class="s2">&quot;server&quot;</span><span class="s1">, traceDir);</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">ioSession = useNodeIpc ? </span><span class="s3">new </span><span class="s1">IpcIOSession() : </span><span class="s3">new </span><span class="s1">IOSession();</span>
  <span class="s1">process.on(</span><span class="s2">&quot;uncaughtException&quot;</span><span class="s1">, (err) =&gt; {</span>
    <span class="s1">ioSession.logError(err, </span><span class="s2">&quot;unknown&quot;</span><span class="s1">);</span>
  <span class="s1">});</span>
  <span class="s1">process.noAsar = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">ioSession.listen();</span>
  <span class="s3">function </span><span class="s1">getGlobalTypingsCacheLocation() {</span>
    <span class="s3">switch </span><span class="s1">(process.platform) {</span>
      <span class="s3">case </span><span class="s2">&quot;win32&quot;</span><span class="s1">: {</span>
        <span class="s3">const </span><span class="s1">basePath = process.env.LOCALAPPDATA || process.env.APPDATA || import_os.default.homedir &amp;&amp; import_os.default.homedir() || process.env.USERPROFILE || process.env.HOMEDRIVE &amp;&amp; process.env.HOMEPATH &amp;&amp; (</span><span class="s4">0</span><span class="s1">, typescript_exports.normalizeSlashes)(process.env.HOMEDRIVE + process.env.HOMEPATH) || import_os.default.tmpdir();</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, typescript_exports.combinePaths)((</span><span class="s4">0</span><span class="s1">, typescript_exports.combinePaths)((</span><span class="s4">0</span><span class="s1">, typescript_exports.normalizeSlashes)(basePath), </span><span class="s2">&quot;Microsoft/TypeScript&quot;</span><span class="s1">), typescript_exports.versionMajorMinor);</span>
      <span class="s1">}</span>
      <span class="s3">case </span><span class="s2">&quot;openbsd&quot;</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">&quot;freebsd&quot;</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">&quot;netbsd&quot;</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">&quot;darwin&quot;</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">&quot;linux&quot;</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">&quot;android&quot;</span><span class="s1">: {</span>
        <span class="s3">const </span><span class="s1">cacheLocation = getNonWindowsCacheLocation(process.platform === </span><span class="s2">&quot;darwin&quot;</span><span class="s1">);</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, typescript_exports.combinePaths)((</span><span class="s4">0</span><span class="s1">, typescript_exports.combinePaths)(cacheLocation, </span><span class="s2">&quot;typescript&quot;</span><span class="s1">), typescript_exports.versionMajorMinor);</span>
      <span class="s1">}</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">typescript_exports.Debug.fail(</span><span class="s2">`unsupported platform '</span><span class="s1">${process.platform}</span><span class="s2">'`</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getNonWindowsCacheLocation(platformIsDarwin) {</span>
    <span class="s3">if </span><span class="s1">(process.env.XDG_CACHE_HOME) {</span>
      <span class="s3">return </span><span class="s1">process.env.XDG_CACHE_HOME;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">usersDir = platformIsDarwin ? </span><span class="s2">&quot;Users&quot; </span><span class="s1">: </span><span class="s2">&quot;home&quot;</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">homePath = import_os.default.homedir &amp;&amp; import_os.default.homedir() || process.env.HOME || (process.env.LOGNAME || process.env.USER) &amp;&amp; </span><span class="s2">`/</span><span class="s1">${usersDir}</span><span class="s2">/</span><span class="s1">${process.env.LOGNAME || process.env.USER}</span><span class="s2">` </span><span class="s1">|| import_os.default.tmpdir();</span>
    <span class="s3">const </span><span class="s1">cacheFolder = platformIsDarwin ? </span><span class="s2">&quot;Library/Caches&quot; </span><span class="s1">: </span><span class="s2">&quot;.cache&quot;</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, typescript_exports.combinePaths)((</span><span class="s4">0</span><span class="s1">, typescript_exports.normalizeSlashes)(homePath), cacheFolder);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pipeExists(name) {</span>
  <span class="s3">return </span><span class="s1">import_fs.default.existsSync(name);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createCancellationToken(args) {</span>
  <span class="s3">let </span><span class="s1">cancellationPipeName;</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; args.length - </span><span class="s4">1</span><span class="s1">; i++) {</span>
    <span class="s3">if </span><span class="s1">(args[i] === </span><span class="s2">&quot;--cancellationPipeName&quot;</span><span class="s1">) {</span>
      <span class="s1">cancellationPipeName = args[i + </span><span class="s4">1</span><span class="s1">];</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(!cancellationPipeName) {</span>
    <span class="s3">return </span><span class="s1">typescript_exports.server.nullCancellationToken;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(cancellationPipeName.charAt(cancellationPipeName.length - </span><span class="s4">1</span><span class="s1">) === </span><span class="s2">&quot;*&quot;</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s1">namePrefix = cancellationPipeName.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(namePrefix.length === </span><span class="s4">0 </span><span class="s1">|| namePrefix.includes(</span><span class="s2">&quot;*&quot;</span><span class="s1">)) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Invalid name for template cancellation pipe: it should have length greater than 2 characters and contain only one '*'.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">let </span><span class="s1">perRequestPipeName;</span>
    <span class="s3">let </span><span class="s1">currentRequestId;</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">isCancellationRequested: () =&gt; perRequestPipeName !== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">&amp;&amp; pipeExists(perRequestPipeName),</span>
      <span class="s1">setRequest(requestId) {</span>
        <span class="s1">currentRequestId = requestId;</span>
        <span class="s1">perRequestPipeName = namePrefix + requestId;</span>
      <span class="s1">},</span>
      <span class="s1">resetRequest(requestId) {</span>
        <span class="s3">if </span><span class="s1">(currentRequestId !== requestId) {</span>
          <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">`Mismatched request id, expected </span><span class="s1">${currentRequestId}</span><span class="s2">, actual </span><span class="s1">${requestId}</span><span class="s2">`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">perRequestPipeName = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">isCancellationRequested: () =&gt; pipeExists(cancellationPipeName),</span>
      <span class="s1">setRequest: (_requestId) =&gt; </span><span class="s3">void </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">resetRequest: (_requestId) =&gt; </span><span class="s3">void </span><span class="s4">0</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// src/tsserver/server.ts</span>
<span class="s3">function </span><span class="s1">findArgumentStringArray(argName) {</span>
  <span class="s3">const </span><span class="s1">arg = typescript_exports.server.findArgument(argName);</span>
  <span class="s3">if </span><span class="s1">(arg === </span><span class="s3">void </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">typescript_exports.emptyArray;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">arg.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">).filter((name) =&gt; name !== </span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">start({ args, logger, cancellationToken, serverMode, unknownServerMode, startSession: startServer }, platform) {</span>
  <span class="s1">logger.info(</span><span class="s2">`Starting TS Server`</span><span class="s1">);</span>
  <span class="s1">logger.info(</span><span class="s2">`Version: </span><span class="s1">${typescript_exports.version}</span><span class="s2">`</span><span class="s1">);</span>
  <span class="s1">logger.info(</span><span class="s2">`Arguments: </span><span class="s1">${args.join(</span><span class="s2">&quot; &quot;</span><span class="s1">)}</span><span class="s2">`</span><span class="s1">);</span>
  <span class="s1">logger.info(</span><span class="s2">`Platform: </span><span class="s1">${platform} </span><span class="s2">NodeVersion: </span><span class="s1">${process.version} </span><span class="s2">CaseSensitive: </span><span class="s1">${typescript_exports.sys.useCaseSensitiveFileNames}</span><span class="s2">`</span><span class="s1">);</span>
  <span class="s1">logger.info(</span><span class="s2">`ServerMode: </span><span class="s1">${serverMode} </span><span class="s2">hasUnknownServerMode: </span><span class="s1">${unknownServerMode}</span><span class="s2">`</span><span class="s1">);</span>
  <span class="s1">typescript_exports.setStackTraceLimit();</span>
  <span class="s3">if </span><span class="s1">(typescript_exports.Debug.isDebugging) {</span>
    <span class="s1">typescript_exports.Debug.enableDebugInfo();</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(typescript_exports.sys.tryEnableSourceMapsForHost &amp;&amp; </span><span class="s5">/^development$/i</span><span class="s1">.test(typescript_exports.sys.getEnvironmentVariable(</span><span class="s2">&quot;NODE_ENV&quot;</span><span class="s1">))) {</span>
    <span class="s1">typescript_exports.sys.tryEnableSourceMapsForHost();</span>
  <span class="s1">}</span>
  <span class="s1">console.log = (...args2) =&gt; logger.msg(args2.length === </span><span class="s4">1 </span><span class="s1">? args2[</span><span class="s4">0</span><span class="s1">] : args2.join(</span><span class="s2">&quot;, &quot;</span><span class="s1">), typescript_exports.server.Msg.Info);</span>
  <span class="s1">console.warn = (...args2) =&gt; logger.msg(args2.length === </span><span class="s4">1 </span><span class="s1">? args2[</span><span class="s4">0</span><span class="s1">] : args2.join(</span><span class="s2">&quot;, &quot;</span><span class="s1">), typescript_exports.server.Msg.Err);</span>
  <span class="s1">console.error = (...args2) =&gt; logger.msg(args2.length === </span><span class="s4">1 </span><span class="s1">? args2[</span><span class="s4">0</span><span class="s1">] : args2.join(</span><span class="s2">&quot;, &quot;</span><span class="s1">), typescript_exports.server.Msg.Err);</span>
  <span class="s1">startServer(</span>
    <span class="s1">{</span>
      <span class="s1">globalPlugins: findArgumentStringArray(</span><span class="s2">&quot;--globalPlugins&quot;</span><span class="s1">),</span>
      <span class="s1">pluginProbeLocations: findArgumentStringArray(</span><span class="s2">&quot;--pluginProbeLocations&quot;</span><span class="s1">),</span>
      <span class="s1">allowLocalPluginLoads: typescript_exports.server.hasArgument(</span><span class="s2">&quot;--allowLocalPluginLoads&quot;</span><span class="s1">),</span>
      <span class="s1">useSingleInferredProject: typescript_exports.server.hasArgument(</span><span class="s2">&quot;--useSingleInferredProject&quot;</span><span class="s1">),</span>
      <span class="s1">useInferredProjectPerProjectRoot: typescript_exports.server.hasArgument(</span><span class="s2">&quot;--useInferredProjectPerProjectRoot&quot;</span><span class="s1">),</span>
      <span class="s1">suppressDiagnosticEvents: typescript_exports.server.hasArgument(</span><span class="s2">&quot;--suppressDiagnosticEvents&quot;</span><span class="s1">),</span>
      <span class="s1">noGetErrOnBackgroundUpdate: typescript_exports.server.hasArgument(</span><span class="s2">&quot;--noGetErrOnBackgroundUpdate&quot;</span><span class="s1">),</span>
      <span class="s1">canUseWatchEvents: typescript_exports.server.hasArgument(</span><span class="s2">&quot;--canUseWatchEvents&quot;</span><span class="s1">),</span>
      <span class="s1">serverMode</span>
    <span class="s1">},</span>
    <span class="s1">logger,</span>
    <span class="s1">cancellationToken</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">typescript_exports.setStackTraceLimit();</span>
<span class="s1">start(initializeNodeSystem(), import_os2.default.platform());</span>
<span class="s0">//# sourceMappingURL=_tsserver.js.map</span>
</pre>
</body>
</html>