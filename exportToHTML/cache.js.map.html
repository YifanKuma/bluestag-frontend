<html>
<head>
<title>cache.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cache.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/segment-cache-impl/cache.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">TreePrefetch,</span><span class="s3">\n  </span><span class="s1">RootTreePrefetch,</span><span class="s3">\n  </span><span class="s1">SegmentPrefetch,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/collect-segment-data'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HeadData,</span><span class="s3">\n  </span><span class="s1">LoadingModuleData,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">DynamicParamTypesShort,</span><span class="s3">\n  </span><span class="s1">Segment as FlightRouterStateSegment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { HasLoadingBoundary } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_DID_POSTPONE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STALE_TIME_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_URL,</span><span class="s3">\n  </span><span class="s1">RSC_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createFetch,</span><span class="s3">\n  </span><span class="s1">createFromNextReadableStream,</span><span class="s3">\n  </span><span class="s1">type RSCResponse,</span><span class="s3">\n  </span><span class="s1">type RequestHeaders,</span><span class="s3">\n</span><span class="s1">} from '../router-reducer/fetch-server-response'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">pingPrefetchTask,</span><span class="s3">\n  </span><span class="s1">isPrefetchTaskDirty,</span><span class="s3">\n  </span><span class="s1">type PrefetchTask,</span><span class="s3">\n  </span><span class="s1">type PrefetchSubtaskResult,</span><span class="s3">\n</span><span class="s1">} from './scheduler'</span><span class="s3">\n</span><span class="s1">import { getAppBuildId } from '../../app-build-id'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from '../router-reducer/create-href-from-url'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">NormalizedHref,</span><span class="s3">\n  </span><span class="s1">NormalizedNextUrl,</span><span class="s3">\n  </span><span class="s1">NormalizedSearch,</span><span class="s3">\n  </span><span class="s1">RouteCacheKey,</span><span class="s3">\n</span><span class="s1">} from './cache-key'</span><span class="s3">\n</span><span class="s1">// TODO: Rename this module to avoid confusion with other types of cache keys</span><span class="s3">\n</span><span class="s1">import { createCacheKey as createPrefetchRequestKey } from './cache-key'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">doesStaticSegmentAppearInURL,</span><span class="s3">\n  </span><span class="s1">getCacheKeyForDynamicParam,</span><span class="s3">\n  </span><span class="s1">getParamValueFromCacheKey,</span><span class="s3">\n  </span><span class="s1">getRenderedPathname,</span><span class="s3">\n  </span><span class="s1">getRenderedSearch,</span><span class="s3">\n  </span><span class="s1">parseDynamicParamFromURLPart,</span><span class="s3">\n  </span><span class="s1">type RouteParam,</span><span class="s3">\n</span><span class="s1">} from '../../route-params'</span><span class="s3">\n</span><span class="s1">import { createTupleMap, type TupleMap, type Prefix } from './tuple-map'</span><span class="s3">\n</span><span class="s1">import { createLRU } from './lru'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">appendSegmentCacheKeyPart,</span><span class="s3">\n  </span><span class="s1">appendSegmentRequestKeyPart,</span><span class="s3">\n  </span><span class="s1">convertSegmentPathToStaticExportFilename,</span><span class="s3">\n  </span><span class="s1">createSegmentCacheKeyPart,</span><span class="s3">\n  </span><span class="s1">createSegmentRequestKeyPart,</span><span class="s3">\n  </span><span class="s1">ROOT_SEGMENT_CACHE_KEY,</span><span class="s3">\n  </span><span class="s1">ROOT_SEGMENT_REQUEST_KEY,</span><span class="s3">\n  </span><span class="s1">type SegmentCacheKey,</span><span class="s3">\n  </span><span class="s1">type SegmentRequestKey,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment-cache/segment-value-encoding'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">NavigationFlightResponse,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { normalizeFlightData } from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { STATIC_STALETIME_MS } from '../router-reducer/prefetch-cache-utils'</span><span class="s3">\n</span><span class="s1">import { pingVisibleLinks } from '../links'</span><span class="s3">\n</span><span class="s1">import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">DOC_PREFETCH_RANGE_HEADER_VALUE,</span><span class="s3">\n  </span><span class="s1">doesExportedHtmlMatchBuildId,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment-cache/output-export-prefetch-encoding'</span><span class="s3">\n</span><span class="s1">import { FetchStrategy } from '../segment-cache'</span><span class="s3">\n</span><span class="s1">import { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'</span><span class="s3">\n\n</span><span class="s1">// A note on async/await when working in the prefetch cache:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Most async operations in the prefetch cache should *not* use async/await,</span><span class="s3">\n</span><span class="s1">// Instead, spawn a subtask that writes the results to a cache entry, and attach</span><span class="s3">\n</span><span class="s1">// a </span><span class="s3">\&quot;</span><span class="s1">ping</span><span class="s3">\&quot; </span><span class="s1">listener to notify the prefetch queue to try again.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The reason is we need to be able to access the segment cache and traverse its</span><span class="s3">\n</span><span class="s1">// data structures synchronously. For example, if there's a synchronous update</span><span class="s3">\n</span><span class="s1">// we can take an immediate snapshot of the cache to produce something we can</span><span class="s3">\n</span><span class="s1">// render. Limiting the use of async/await also makes it easier to avoid race</span><span class="s3">\n</span><span class="s1">// conditions, which is especially important because is cache is mutable.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Another reason is that while we're performing async work, it's possible for</span><span class="s3">\n</span><span class="s1">// existing entries to become stale, or for Link prefetches to be removed from</span><span class="s3">\n</span><span class="s1">// the queue. For optimal scheduling, we need to be able to </span><span class="s3">\&quot;</span><span class="s1">cancel</span><span class="s3">\&quot; </span><span class="s1">subtasks</span><span class="s3">\n</span><span class="s1">// that are no longer needed. So, when a segment is received from the server, we</span><span class="s3">\n</span><span class="s1">// restart from the root of the tree that's being prefetched, to confirm all the</span><span class="s3">\n</span><span class="s1">// parent segments are still cached. If the segment is no longer reachable from</span><span class="s3">\n</span><span class="s1">// the root, then it's effectively canceled. This is similar to the design of</span><span class="s3">\n</span><span class="s1">// Rust Futures, or React Suspense.</span><span class="s3">\n\n</span><span class="s1">export type RouteTree = {</span><span class="s3">\n  </span><span class="s1">cacheKey: SegmentCacheKey</span><span class="s3">\n  </span><span class="s1">requestKey: SegmentRequestKey</span><span class="s3">\n  </span><span class="s1">// TODO: Remove the `segment` field, now that it can be reconstructed</span><span class="s3">\n  </span><span class="s1">// from `param`.</span><span class="s3">\n  </span><span class="s1">segment: FlightRouterStateSegment</span><span class="s3">\n  </span><span class="s1">param: RouteParam | null</span><span class="s3">\n  </span><span class="s1">slots: null | {</span><span class="s3">\n    </span><span class="s1">[parallelRouteKey: string]: RouteTree</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">isRootLayout: boolean</span><span class="s3">\n\n  </span><span class="s1">// If this is a dynamic route, indicates whether there is a loading boundary</span><span class="s3">\n  </span><span class="s1">// somewhere in the tree. If not, we can skip the prefetch for the data,</span><span class="s3">\n  </span><span class="s1">// because we know it would be an empty response. (For a static/PPR route,</span><span class="s3">\n  </span><span class="s1">// this value is disregarded, because in that model `loading.tsx` is treated</span><span class="s3">\n  </span><span class="s1">// like any other Suspense boundary.)</span><span class="s3">\n  </span><span class="s1">hasLoadingBoundary: HasLoadingBoundary</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RouteCacheEntryShared = {</span><span class="s3">\n  </span><span class="s1">staleAt: number</span><span class="s3">\n  </span><span class="s1">// This is false only if we're certain the route cannot be intercepted. It's</span><span class="s3">\n  </span><span class="s1">// true in all other cases, including on initialization when we haven't yet</span><span class="s3">\n  </span><span class="s1">// received a response from the server.</span><span class="s3">\n  </span><span class="s1">couldBeIntercepted: boolean</span><span class="s3">\n\n  </span><span class="s1">// See comment in scheduler.ts for context</span><span class="s3">\n  </span><span class="s1">TODO_metadataStatus: EntryStatus.Empty | EntryStatus.Fulfilled</span><span class="s3">\n  </span><span class="s1">TODO_isHeadDynamic: boolean</span><span class="s3">\n\n  </span><span class="s1">// LRU-related fields</span><span class="s3">\n  </span><span class="s1">keypath: null | Prefix&lt;RouteCacheKeypath&gt;</span><span class="s3">\n  </span><span class="s1">next: null | RouteCacheEntry</span><span class="s3">\n  </span><span class="s1">prev: null | RouteCacheEntry</span><span class="s3">\n  </span><span class="s1">size: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tracks the status of a cache entry as it progresses from no data (Empty),</span><span class="s3">\n </span><span class="s1">* waiting for server data (Pending), and finished (either Fulfilled or</span><span class="s3">\n </span><span class="s1">* Rejected depending on the response from the server.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const enum EntryStatus {</span><span class="s3">\n  </span><span class="s1">Empty,</span><span class="s3">\n  </span><span class="s1">Pending,</span><span class="s3">\n  </span><span class="s1">Fulfilled,</span><span class="s3">\n  </span><span class="s1">Rejected,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PendingRouteCacheEntry = RouteCacheEntryShared &amp; {</span><span class="s3">\n  </span><span class="s1">status: EntryStatus.Empty | EntryStatus.Pending</span><span class="s3">\n  </span><span class="s1">blockedTasks: Set&lt;PrefetchTask&gt; | null</span><span class="s3">\n  </span><span class="s1">canonicalUrl: null</span><span class="s3">\n  </span><span class="s1">renderedSearch: null</span><span class="s3">\n  </span><span class="s1">tree: null</span><span class="s3">\n  </span><span class="s1">head: HeadData | null</span><span class="s3">\n  </span><span class="s1">isHeadPartial: true</span><span class="s3">\n  </span><span class="s1">isPPREnabled: false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RejectedRouteCacheEntry = RouteCacheEntryShared &amp; {</span><span class="s3">\n  </span><span class="s1">status: EntryStatus.Rejected</span><span class="s3">\n  </span><span class="s1">blockedTasks: Set&lt;PrefetchTask&gt; | null</span><span class="s3">\n  </span><span class="s1">canonicalUrl: null</span><span class="s3">\n  </span><span class="s1">renderedSearch: null</span><span class="s3">\n  </span><span class="s1">tree: null</span><span class="s3">\n  </span><span class="s1">head: null</span><span class="s3">\n  </span><span class="s1">isHeadPartial: true</span><span class="s3">\n  </span><span class="s1">isPPREnabled: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FulfilledRouteCacheEntry = RouteCacheEntryShared &amp; {</span><span class="s3">\n  </span><span class="s1">status: EntryStatus.Fulfilled</span><span class="s3">\n  </span><span class="s1">blockedTasks: null</span><span class="s3">\n  </span><span class="s1">canonicalUrl: string</span><span class="s3">\n  </span><span class="s1">renderedSearch: NormalizedSearch</span><span class="s3">\n  </span><span class="s1">tree: RouteTree</span><span class="s3">\n  </span><span class="s1">head: HeadData</span><span class="s3">\n  </span><span class="s1">isHeadPartial: boolean</span><span class="s3">\n  </span><span class="s1">isPPREnabled: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RouteCacheEntry =</span><span class="s3">\n  </span><span class="s1">| PendingRouteCacheEntry</span><span class="s3">\n  </span><span class="s1">| FulfilledRouteCacheEntry</span><span class="s3">\n  </span><span class="s1">| RejectedRouteCacheEntry</span><span class="s3">\n\n</span><span class="s1">type SegmentCacheEntryShared = {</span><span class="s3">\n  </span><span class="s1">staleAt: number</span><span class="s3">\n  </span><span class="s1">fetchStrategy: FetchStrategy</span><span class="s3">\n  </span><span class="s1">revalidating: SegmentCacheEntry | null</span><span class="s3">\n\n  </span><span class="s1">// LRU-related fields</span><span class="s3">\n  </span><span class="s1">keypath: null | Prefix&lt;SegmentCacheKeypath&gt;</span><span class="s3">\n  </span><span class="s1">next: null | SegmentCacheEntry</span><span class="s3">\n  </span><span class="s1">prev: null | SegmentCacheEntry</span><span class="s3">\n  </span><span class="s1">size: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type EmptySegmentCacheEntry = SegmentCacheEntryShared &amp; {</span><span class="s3">\n  </span><span class="s1">status: EntryStatus.Empty</span><span class="s3">\n  </span><span class="s1">rsc: null</span><span class="s3">\n  </span><span class="s1">loading: null</span><span class="s3">\n  </span><span class="s1">isPartial: true</span><span class="s3">\n  </span><span class="s1">promise: null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PendingSegmentCacheEntry = SegmentCacheEntryShared &amp; {</span><span class="s3">\n  </span><span class="s1">status: EntryStatus.Pending</span><span class="s3">\n  </span><span class="s1">rsc: null</span><span class="s3">\n  </span><span class="s1">loading: null</span><span class="s3">\n  </span><span class="s1">isPartial: true</span><span class="s3">\n  </span><span class="s1">promise: null | PromiseWithResolvers&lt;FulfilledSegmentCacheEntry | null&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RejectedSegmentCacheEntry = SegmentCacheEntryShared &amp; {</span><span class="s3">\n  </span><span class="s1">status: EntryStatus.Rejected</span><span class="s3">\n  </span><span class="s1">rsc: null</span><span class="s3">\n  </span><span class="s1">loading: null</span><span class="s3">\n  </span><span class="s1">isPartial: true</span><span class="s3">\n  </span><span class="s1">promise: null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FulfilledSegmentCacheEntry = SegmentCacheEntryShared &amp; {</span><span class="s3">\n  </span><span class="s1">status: EntryStatus.Fulfilled</span><span class="s3">\n  </span><span class="s1">rsc: React.ReactNode | null</span><span class="s3">\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n  </span><span class="s1">isPartial: boolean</span><span class="s3">\n  </span><span class="s1">promise: null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type SegmentCacheEntry =</span><span class="s3">\n  </span><span class="s1">| EmptySegmentCacheEntry</span><span class="s3">\n  </span><span class="s1">| PendingSegmentCacheEntry</span><span class="s3">\n  </span><span class="s1">| RejectedSegmentCacheEntry</span><span class="s3">\n  </span><span class="s1">| FulfilledSegmentCacheEntry</span><span class="s3">\n\n</span><span class="s1">export type NonEmptySegmentCacheEntry = Exclude&lt;</span><span class="s3">\n  </span><span class="s1">SegmentCacheEntry,</span><span class="s3">\n  </span><span class="s1">EmptySegmentCacheEntry</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">const isOutputExportMode =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV === 'production' &amp;&amp;</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CONFIG_OUTPUT === 'export'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensures a minimum stale time of 30s to avoid issues where the server sends a too</span><span class="s3">\n </span><span class="s1">* short-lived stale time, which would prevent anything from being prefetched.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getStaleTimeMs(staleTimeSeconds: number): number {</span><span class="s3">\n  </span><span class="s1">return Math.max(staleTimeSeconds, 30) * 1000</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Route cache entries vary on multiple keys: the href and the Next-Url. Each of</span><span class="s3">\n</span><span class="s1">// these parts needs to be included in the internal cache key. Rather than</span><span class="s3">\n</span><span class="s1">// concatenate the keys into a single key, we use a multi-level map, where the</span><span class="s3">\n</span><span class="s1">// first level is keyed by href, the second level is keyed by Next-Url, and so</span><span class="s3">\n</span><span class="s1">// on (if were to add more levels).</span><span class="s3">\n</span><span class="s1">type RouteCacheKeypath = [NormalizedHref, NormalizedNextUrl]</span><span class="s3">\n</span><span class="s1">let routeCacheMap: TupleMap&lt;RouteCacheKeypath, RouteCacheEntry&gt; =</span><span class="s3">\n  </span><span class="s1">createTupleMap()</span><span class="s3">\n\n</span><span class="s1">// We use an LRU for memory management. We must update this whenever we add or</span><span class="s3">\n</span><span class="s1">// remove a new cache entry, or when an entry changes size.</span><span class="s3">\n</span><span class="s1">// TODO: I chose the max size somewhat arbitrarily. Consider setting this based</span><span class="s3">\n</span><span class="s1">// on navigator.deviceMemory, or some other heuristic. We should make this</span><span class="s3">\n</span><span class="s1">// customizable via the Next.js config, too.</span><span class="s3">\n</span><span class="s1">const maxRouteLruSize = 10 * 1024 * 1024 // 10 MB</span><span class="s3">\n</span><span class="s1">let routeCacheLru = createLRU&lt;RouteCacheEntry&gt;(</span><span class="s3">\n  </span><span class="s1">maxRouteLruSize,</span><span class="s3">\n  </span><span class="s1">onRouteLRUEviction</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">type SegmentCacheKeypath = [string, NormalizedSearch]</span><span class="s3">\n</span><span class="s1">let segmentCacheMap: TupleMap&lt;SegmentCacheKeypath, SegmentCacheEntry&gt; =</span><span class="s3">\n  </span><span class="s1">createTupleMap()</span><span class="s3">\n</span><span class="s1">// NOTE: Segments and Route entries are managed by separate LRUs. We could</span><span class="s3">\n</span><span class="s1">// combine them into a single LRU, but because they are separate types, we'd</span><span class="s3">\n</span><span class="s1">// need to wrap each one in an extra LRU node (to maintain monomorphism, at the</span><span class="s3">\n</span><span class="s1">// cost of additional memory).</span><span class="s3">\n</span><span class="s1">const maxSegmentLruSize = 50 * 1024 * 1024 // 50 MB</span><span class="s3">\n</span><span class="s1">let segmentCacheLru = createLRU&lt;SegmentCacheEntry&gt;(</span><span class="s3">\n  </span><span class="s1">maxSegmentLruSize,</span><span class="s3">\n  </span><span class="s1">onSegmentLRUEviction</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">// All invalidation listeners for the whole cache are tracked in single set.</span><span class="s3">\n</span><span class="s1">// Since we don't yet support tag or path-based invalidation, there's no point</span><span class="s3">\n</span><span class="s1">// tracking them any more granularly than this. Once we add granular</span><span class="s3">\n</span><span class="s1">// invalidation, that may change, though generally the model is to just notify</span><span class="s3">\n</span><span class="s1">// the listeners and allow the caller to poll the prefetch cache with a new</span><span class="s3">\n</span><span class="s1">// prefetch task if desired.</span><span class="s3">\n</span><span class="s1">let invalidationListeners: Set&lt;PrefetchTask&gt; | null = null</span><span class="s3">\n\n</span><span class="s1">// Incrementing counter used to track cache invalidations.</span><span class="s3">\n</span><span class="s1">let currentCacheVersion = 0</span><span class="s3">\n\n</span><span class="s1">export function getCurrentCacheVersion(): number {</span><span class="s3">\n  </span><span class="s1">return currentCacheVersion</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used to clear the client prefetch cache when a server action calls</span><span class="s3">\n </span><span class="s1">* revalidatePath or revalidateTag. Eventually we will support only clearing the</span><span class="s3">\n </span><span class="s1">* segments that were actually affected, but there's more work to be done on the</span><span class="s3">\n </span><span class="s1">* server before the client is able to do this correctly.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function revalidateEntireCache(</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null,</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">currentCacheVersion++</span><span class="s3">\n\n  </span><span class="s1">// Clearing the cache also effectively rejects any pending requests, because</span><span class="s3">\n  </span><span class="s1">// when the response is received, it gets written into a cache entry that is</span><span class="s3">\n  </span><span class="s1">// no longer reachable.</span><span class="s3">\n  </span><span class="s1">// TODO: There's an exception to this case that we don't currently handle</span><span class="s3">\n  </span><span class="s1">// correctly: background revalidations. See note in `upsertSegmentEntry`.</span><span class="s3">\n  </span><span class="s1">routeCacheMap = createTupleMap()</span><span class="s3">\n  </span><span class="s1">routeCacheLru = createLRU(maxRouteLruSize, onRouteLRUEviction)</span><span class="s3">\n  </span><span class="s1">segmentCacheMap = createTupleMap()</span><span class="s3">\n  </span><span class="s1">segmentCacheLru = createLRU(maxSegmentLruSize, onSegmentLRUEviction)</span><span class="s3">\n\n  </span><span class="s1">// Prefetch all the currently visible links again, to re-fill the cache.</span><span class="s3">\n  </span><span class="s1">pingVisibleLinks(nextUrl, tree)</span><span class="s3">\n\n  </span><span class="s1">// Similarly, notify all invalidation listeners (i.e. those passed to</span><span class="s3">\n  </span><span class="s1">// `router.prefetch(onInvalidate)`), so they can trigger a new prefetch</span><span class="s3">\n  </span><span class="s1">// if needed.</span><span class="s3">\n  </span><span class="s1">pingInvalidationListeners(nextUrl, tree)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function attachInvalidationListener(task: PrefetchTask): void {</span><span class="s3">\n  </span><span class="s1">// This function is called whenever a prefetch task reads a cache entry. If</span><span class="s3">\n  </span><span class="s1">// the task has an onInvalidate function associated with it — i.e. the one</span><span class="s3">\n  </span><span class="s1">// optionally passed to router.prefetch(onInvalidate) — then we attach that</span><span class="s3">\n  </span><span class="s1">// listener to the every cache entry that the task reads. Then, if an entry</span><span class="s3">\n  </span><span class="s1">// is invalidated, we call the function.</span><span class="s3">\n  </span><span class="s1">if (task.onInvalidate !== null) {</span><span class="s3">\n    </span><span class="s1">if (invalidationListeners === null) {</span><span class="s3">\n      </span><span class="s1">invalidationListeners = new Set([task])</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">invalidationListeners.add(task)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function notifyInvalidationListener(task: PrefetchTask): void {</span><span class="s3">\n  </span><span class="s1">const onInvalidate = task.onInvalidate</span><span class="s3">\n  </span><span class="s1">if (onInvalidate !== null) {</span><span class="s3">\n    </span><span class="s1">// Clear the callback from the task object to guarantee it's not called more</span><span class="s3">\n    </span><span class="s1">// than once.</span><span class="s3">\n    </span><span class="s1">task.onInvalidate = null</span><span class="s3">\n\n    </span><span class="s1">// This is a user-space function, so we must wrap in try/catch.</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">onInvalidate()</span><span class="s3">\n    </span><span class="s1">} catch (error) {</span><span class="s3">\n      </span><span class="s1">if (typeof reportError === 'function') {</span><span class="s3">\n        </span><span class="s1">reportError(error)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">console.error(error)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function pingInvalidationListeners(</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null,</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.</span><span class="s3">\n  </span><span class="s1">// This is called when the Next-Url or the base tree changes, since those</span><span class="s3">\n  </span><span class="s1">// may affect the result of a prefetch task. It's also called after a</span><span class="s3">\n  </span><span class="s1">// cache invalidation.</span><span class="s3">\n  </span><span class="s1">if (invalidationListeners !== null) {</span><span class="s3">\n    </span><span class="s1">const tasks = invalidationListeners</span><span class="s3">\n    </span><span class="s1">invalidationListeners = null</span><span class="s3">\n    </span><span class="s1">for (const task of tasks) {</span><span class="s3">\n      </span><span class="s1">if (isPrefetchTaskDirty(task, nextUrl, tree)) {</span><span class="s3">\n        </span><span class="s1">notifyInvalidationListener(task)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function readExactRouteCacheEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">href: NormalizedHref,</span><span class="s3">\n  </span><span class="s1">nextUrl: NormalizedNextUrl | null</span><span class="s3">\n</span><span class="s1">): RouteCacheEntry | null {</span><span class="s3">\n  </span><span class="s1">const keypath: Prefix&lt;RouteCacheKeypath&gt; =</span><span class="s3">\n    </span><span class="s1">nextUrl === null ? [href] : [href, nextUrl]</span><span class="s3">\n  </span><span class="s1">const existingEntry = routeCacheMap.get(keypath)</span><span class="s3">\n  </span><span class="s1">if (existingEntry !== null) {</span><span class="s3">\n    </span><span class="s1">// Check if the entry is stale</span><span class="s3">\n    </span><span class="s1">if (existingEntry.staleAt &gt; now) {</span><span class="s3">\n      </span><span class="s1">// Reuse the existing entry.</span><span class="s3">\n\n      </span><span class="s1">// Since this is an access, move the entry to the front of the LRU.</span><span class="s3">\n      </span><span class="s1">routeCacheLru.put(existingEntry)</span><span class="s3">\n\n      </span><span class="s1">return existingEntry</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Evict the stale entry from the cache.</span><span class="s3">\n      </span><span class="s1">deleteRouteFromCache(existingEntry, keypath)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function readRouteCacheEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">key: RouteCacheKey</span><span class="s3">\n</span><span class="s1">): RouteCacheEntry | null {</span><span class="s3">\n  </span><span class="s1">// First check if there's a non-intercepted entry. Most routes cannot be</span><span class="s3">\n  </span><span class="s1">// intercepted, so this is the common case.</span><span class="s3">\n  </span><span class="s1">const nonInterceptedEntry = readExactRouteCacheEntry(now, key.href, null)</span><span class="s3">\n  </span><span class="s1">if (nonInterceptedEntry !== null &amp;&amp; !nonInterceptedEntry.couldBeIntercepted) {</span><span class="s3">\n    </span><span class="s1">// Found a match, and the route cannot be intercepted. We can reuse it.</span><span class="s3">\n    </span><span class="s1">return nonInterceptedEntry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// There was no match. Check again but include the Next-Url this time.</span><span class="s3">\n  </span><span class="s1">return readExactRouteCacheEntry(now, key.href, key.nextUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getSegmentKeypathForTask(</span><span class="s3">\n  </span><span class="s1">task: PrefetchTask,</span><span class="s3">\n  </span><span class="s1">route: FulfilledRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">cacheKey: SegmentCacheKey</span><span class="s3">\n</span><span class="s1">): Prefix&lt;SegmentCacheKeypath&gt; {</span><span class="s3">\n  </span><span class="s1">// When a prefetch includes dynamic data, the search params are included</span><span class="s3">\n  </span><span class="s1">// in the result, so we must include the search string in the segment</span><span class="s3">\n  </span><span class="s1">// cache key. (Note that this is true even if the search string is empty.)</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// If we're fetching using PPR, we do not need to include the search params in</span><span class="s3">\n  </span><span class="s1">// the cache key, because the search params are treated as dynamic data. The</span><span class="s3">\n  </span><span class="s1">// cache entry is valid for all possible search param values.</span><span class="s3">\n  </span><span class="s1">const isDynamicTask =</span><span class="s3">\n    </span><span class="s1">task.fetchStrategy === FetchStrategy.Full ||</span><span class="s3">\n    </span><span class="s1">task.fetchStrategy === FetchStrategy.PPRRuntime ||</span><span class="s3">\n    </span><span class="s1">!route.isPPREnabled</span><span class="s3">\n  </span><span class="s1">return isDynamicTask &amp;&amp; cacheKey.endsWith('/' + PAGE_SEGMENT_KEY)</span><span class="s3">\n    </span><span class="s1">? [cacheKey, route.renderedSearch]</span><span class="s3">\n    </span><span class="s1">: [cacheKey]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function readSegmentCacheEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">route: FulfilledRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">cacheKey: SegmentCacheKey</span><span class="s3">\n</span><span class="s1">): SegmentCacheEntry | null {</span><span class="s3">\n  </span><span class="s1">if (!cacheKey.endsWith('/' + PAGE_SEGMENT_KEY)) {</span><span class="s3">\n    </span><span class="s1">// Fast path. Search params only exist on page segments.</span><span class="s3">\n    </span><span class="s1">return readExactSegmentCacheEntry(now, [cacheKey])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const renderedSearch = route.renderedSearch</span><span class="s3">\n  </span><span class="s1">if (renderedSearch !== null) {</span><span class="s3">\n    </span><span class="s1">// Page segments may or may not contain search params. If they were prefetched</span><span class="s3">\n    </span><span class="s1">// using a dynamic request, then we will have an entry with search params.</span><span class="s3">\n    </span><span class="s1">// Check for that case first.</span><span class="s3">\n    </span><span class="s1">const entryWithSearchParams = readExactSegmentCacheEntry(now, [</span><span class="s3">\n      </span><span class="s1">cacheKey,</span><span class="s3">\n      </span><span class="s1">renderedSearch,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">if (entryWithSearchParams !== null) {</span><span class="s3">\n      </span><span class="s1">return entryWithSearchParams</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we did not find an entry with the given search params, check for a</span><span class="s3">\n  </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">fallback</span><span class="s3">\&quot; </span><span class="s1">entry, where the search params are treated as dynamic data. This</span><span class="s3">\n  </span><span class="s1">// is the common case because PPR/static prerenders always treat search params</span><span class="s3">\n  </span><span class="s1">// as dynamic.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// See corresponding logic in `getSegmentKeypathForTask`.</span><span class="s3">\n  </span><span class="s1">const entryWithoutSearchParams = readExactSegmentCacheEntry(now, [cacheKey])</span><span class="s3">\n  </span><span class="s1">return entryWithoutSearchParams</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function readExactSegmentCacheEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">keypath: Prefix&lt;SegmentCacheKeypath&gt;</span><span class="s3">\n</span><span class="s1">): SegmentCacheEntry | null {</span><span class="s3">\n  </span><span class="s1">const existingEntry = segmentCacheMap.get(keypath)</span><span class="s3">\n  </span><span class="s1">if (existingEntry !== null) {</span><span class="s3">\n    </span><span class="s1">// Check if the entry is stale</span><span class="s3">\n    </span><span class="s1">if (existingEntry.staleAt &gt; now) {</span><span class="s3">\n      </span><span class="s1">// Reuse the existing entry.</span><span class="s3">\n\n      </span><span class="s1">// Since this is an access, move the entry to the front of the LRU.</span><span class="s3">\n      </span><span class="s1">segmentCacheLru.put(existingEntry)</span><span class="s3">\n\n      </span><span class="s1">return existingEntry</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// This is a stale entry.</span><span class="s3">\n      </span><span class="s1">const revalidatingEntry = existingEntry.revalidating</span><span class="s3">\n      </span><span class="s1">if (revalidatingEntry !== null) {</span><span class="s3">\n        </span><span class="s1">// There's a revalidation in progress. Upsert it.</span><span class="s3">\n        </span><span class="s1">const upsertedEntry = upsertSegmentEntry(</span><span class="s3">\n          </span><span class="s1">now,</span><span class="s3">\n          </span><span class="s1">keypath,</span><span class="s3">\n          </span><span class="s1">revalidatingEntry</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (upsertedEntry !== null &amp;&amp; upsertedEntry.staleAt &gt; now) {</span><span class="s3">\n          </span><span class="s1">// We can use the upserted revalidation entry.</span><span class="s3">\n          </span><span class="s1">return upsertedEntry</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Evict the stale entry from the cache.</span><span class="s3">\n        </span><span class="s1">deleteSegmentFromCache(existingEntry, keypath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function readRevalidatingSegmentCacheEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">owner: SegmentCacheEntry</span><span class="s3">\n</span><span class="s1">): SegmentCacheEntry | null {</span><span class="s3">\n  </span><span class="s1">const existingRevalidation = owner.revalidating</span><span class="s3">\n  </span><span class="s1">if (existingRevalidation !== null) {</span><span class="s3">\n    </span><span class="s1">if (existingRevalidation.staleAt &gt; now) {</span><span class="s3">\n      </span><span class="s1">// There's already a revalidation in progress. Or a previous revalidation</span><span class="s3">\n      </span><span class="s1">// failed and it has not yet expired.</span><span class="s3">\n      </span><span class="s1">return existingRevalidation</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Clear the stale revalidation from its owner.</span><span class="s3">\n      </span><span class="s1">clearRevalidatingSegmentFromOwner(owner)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function waitForSegmentCacheEntry(</span><span class="s3">\n  </span><span class="s1">pendingEntry: PendingSegmentCacheEntry</span><span class="s3">\n</span><span class="s1">): Promise&lt;FulfilledSegmentCacheEntry | null&gt; {</span><span class="s3">\n  </span><span class="s1">// Because the entry is pending, there's already a in-progress request.</span><span class="s3">\n  </span><span class="s1">// Attach a promise to the entry that will resolve when the server responds.</span><span class="s3">\n  </span><span class="s1">let promiseWithResolvers = pendingEntry.promise</span><span class="s3">\n  </span><span class="s1">if (promiseWithResolvers === null) {</span><span class="s3">\n    </span><span class="s1">promiseWithResolvers = pendingEntry.promise =</span><span class="s3">\n      </span><span class="s1">createPromiseWithResolvers&lt;FulfilledSegmentCacheEntry | null&gt;()</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// There's already a promise we can use</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return promiseWithResolvers.promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if an entry for a route exists in the cache. If so, it returns the</span><span class="s3">\n </span><span class="s1">* entry, If not, it adds an empty entry to the cache and returns it.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function readOrCreateRouteCacheEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">task: PrefetchTask</span><span class="s3">\n</span><span class="s1">): RouteCacheEntry {</span><span class="s3">\n  </span><span class="s1">attachInvalidationListener(task)</span><span class="s3">\n\n  </span><span class="s1">const key = task.key</span><span class="s3">\n  </span><span class="s1">const existingEntry = readRouteCacheEntry(now, key)</span><span class="s3">\n  </span><span class="s1">if (existingEntry !== null) {</span><span class="s3">\n    </span><span class="s1">return existingEntry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Create a pending entry and add it to the cache.</span><span class="s3">\n  </span><span class="s1">const pendingEntry: PendingRouteCacheEntry = {</span><span class="s3">\n    </span><span class="s1">canonicalUrl: null,</span><span class="s3">\n    </span><span class="s1">status: EntryStatus.Empty,</span><span class="s3">\n    </span><span class="s1">blockedTasks: null,</span><span class="s3">\n    </span><span class="s1">tree: null,</span><span class="s3">\n    </span><span class="s1">head: null,</span><span class="s3">\n    </span><span class="s1">isHeadPartial: true,</span><span class="s3">\n    </span><span class="s1">// Since this is an empty entry, there's no reason to ever evict it. It will</span><span class="s3">\n    </span><span class="s1">// be updated when the data is populated.</span><span class="s3">\n    </span><span class="s1">staleAt: Infinity,</span><span class="s3">\n    </span><span class="s1">// This is initialized to true because we don't know yet whether the route</span><span class="s3">\n    </span><span class="s1">// could be intercepted. It's only set to false once we receive a response</span><span class="s3">\n    </span><span class="s1">// from the server.</span><span class="s3">\n    </span><span class="s1">couldBeIntercepted: true,</span><span class="s3">\n    </span><span class="s1">// Similarly, we don't yet know if the route supports PPR.</span><span class="s3">\n    </span><span class="s1">isPPREnabled: false,</span><span class="s3">\n    </span><span class="s1">renderedSearch: null,</span><span class="s3">\n\n    </span><span class="s1">TODO_metadataStatus: EntryStatus.Empty,</span><span class="s3">\n    </span><span class="s1">TODO_isHeadDynamic: false,</span><span class="s3">\n\n    </span><span class="s1">// LRU-related fields</span><span class="s3">\n    </span><span class="s1">keypath: null,</span><span class="s3">\n    </span><span class="s1">next: null,</span><span class="s3">\n    </span><span class="s1">prev: null,</span><span class="s3">\n    </span><span class="s1">size: 0,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const keypath: Prefix&lt;RouteCacheKeypath&gt; =</span><span class="s3">\n    </span><span class="s1">key.nextUrl === null ? [key.href] : [key.href, key.nextUrl]</span><span class="s3">\n  </span><span class="s1">routeCacheMap.set(keypath, pendingEntry)</span><span class="s3">\n  </span><span class="s1">// Stash the keypath on the entry so we know how to remove it from the map</span><span class="s3">\n  </span><span class="s1">// if it gets evicted from the LRU.</span><span class="s3">\n  </span><span class="s1">pendingEntry.keypath = keypath</span><span class="s3">\n  </span><span class="s1">routeCacheLru.put(pendingEntry)</span><span class="s3">\n  </span><span class="s1">return pendingEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function requestOptimisticRouteCacheEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">requestedUrl: URL,</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null</span><span class="s3">\n</span><span class="s1">): FulfilledRouteCacheEntry | null {</span><span class="s3">\n  </span><span class="s1">// This function is called during a navigation when there was no matching</span><span class="s3">\n  </span><span class="s1">// route tree in the prefetch cache. Before de-opting to a blocking,</span><span class="s3">\n  </span><span class="s1">// unprefetched navigation, we will first attempt to construct an </span><span class="s3">\&quot;</span><span class="s1">optimistic</span><span class="s3">\&quot;\n  </span><span class="s1">// route tree by checking the cache for similar routes.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Check if there's a route with the same pathname, but with different</span><span class="s3">\n  </span><span class="s1">// search params. We can then base our optimistic route tree on this entry.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Conceptually, we are simulating what would happen if we did perform a</span><span class="s3">\n  </span><span class="s1">// prefetch the requested URL, under the assumption that the server will</span><span class="s3">\n  </span><span class="s1">// not redirect or rewrite the request in a different manner than the</span><span class="s3">\n  </span><span class="s1">// base route tree. This assumption might not hold, in which case we'll have</span><span class="s3">\n  </span><span class="s1">// to recover when we perform the dynamic navigation request. However, this</span><span class="s3">\n  </span><span class="s1">// is what would happen if a route were dynamically rewritten/redirected</span><span class="s3">\n  </span><span class="s1">// in between the prefetch and the navigation. So the logic needs to exist</span><span class="s3">\n  </span><span class="s1">// to handle this case regardless.</span><span class="s3">\n\n  </span><span class="s1">// Look for a route with the same pathname, but with an empty search string.</span><span class="s3">\n  </span><span class="s1">// TODO: There's nothing inherently special about the empty search string;</span><span class="s3">\n  </span><span class="s1">// it's chosen somewhat arbitrarily, with the rationale that it's the most</span><span class="s3">\n  </span><span class="s1">// likely one to exist. But we should update this to match _any_ search</span><span class="s3">\n  </span><span class="s1">// string. The plan is to generalize this logic alongside other improvements</span><span class="s3">\n  </span><span class="s1">// related to </span><span class="s3">\&quot;</span><span class="s1">fallback</span><span class="s3">\&quot; </span><span class="s1">cache entries.</span><span class="s3">\n  </span><span class="s1">const requestedSearch = requestedUrl.search as NormalizedSearch</span><span class="s3">\n  </span><span class="s1">if (requestedSearch === '') {</span><span class="s3">\n    </span><span class="s1">// The caller would have already checked if a route with an empty search</span><span class="s3">\n    </span><span class="s1">// string is in the cache. So we can bail out here.</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const routeWithNoSearchParams = readRouteCacheEntry(</span><span class="s3">\n    </span><span class="s1">now,</span><span class="s3">\n    </span><span class="s1">createPrefetchRequestKey(</span><span class="s3">\n      </span><span class="s1">requestedUrl.origin + requestedUrl.pathname,</span><span class="s3">\n      </span><span class="s1">nextUrl</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">routeWithNoSearchParams === null ||</span><span class="s3">\n    </span><span class="s1">routeWithNoSearchParams.status !== EntryStatus.Fulfilled ||</span><span class="s3">\n    </span><span class="s1">// There's no point constructing an optimistic route tree if the metadata</span><span class="s3">\n    </span><span class="s1">// isn't fully available, because we'll have to do a blocking</span><span class="s3">\n    </span><span class="s1">// navigation anyway.</span><span class="s3">\n    </span><span class="s1">routeWithNoSearchParams.isHeadPartial ||</span><span class="s3">\n    </span><span class="s1">// We cannot reuse this route if it has dynamic metadata.</span><span class="s3">\n    </span><span class="s1">// TODO: Move the metadata out of the route cache entry so the route</span><span class="s3">\n    </span><span class="s1">// tree is reusable separately from the metadata. Then we can remove</span><span class="s3">\n    </span><span class="s1">// these checks.</span><span class="s3">\n    </span><span class="s1">routeWithNoSearchParams.TODO_metadataStatus !== EntryStatus.Empty ||</span><span class="s3">\n    </span><span class="s1">routeWithNoSearchParams.TODO_isHeadDynamic</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// Bail out of constructing an optimistic route tree. This will result in</span><span class="s3">\n    </span><span class="s1">// a blocking, unprefetched navigation.</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Now we have a base route tree we can </span><span class="s3">\&quot;</span><span class="s1">patch</span><span class="s3">\&quot; </span><span class="s1">with our optimistic values.</span><span class="s3">\n\n  </span><span class="s1">// Optimistically assume that redirects for the requested pathname do</span><span class="s3">\n  </span><span class="s1">// not vary on the search string. Therefore, if the base route was</span><span class="s3">\n  </span><span class="s1">// redirected to a different search string, then the optimistic route</span><span class="s3">\n  </span><span class="s1">// should be redirected to the same search string. Otherwise, we use</span><span class="s3">\n  </span><span class="s1">// the requested search string.</span><span class="s3">\n  </span><span class="s1">const canonicalUrlForRouteWithNoSearchParams = new URL(</span><span class="s3">\n    </span><span class="s1">routeWithNoSearchParams.canonicalUrl,</span><span class="s3">\n    </span><span class="s1">requestedUrl.origin</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const optimisticCanonicalSearch =</span><span class="s3">\n    </span><span class="s1">canonicalUrlForRouteWithNoSearchParams.search !== ''</span><span class="s3">\n      </span><span class="s1">? // Base route was redirected. Reuse the same redirected search string.</span><span class="s3">\n        </span><span class="s1">canonicalUrlForRouteWithNoSearchParams.search</span><span class="s3">\n      </span><span class="s1">: requestedSearch</span><span class="s3">\n\n  </span><span class="s1">// Similarly, optimistically assume that rewrites for the requested</span><span class="s3">\n  </span><span class="s1">// pathname do not vary on the search string. Therefore, if the base</span><span class="s3">\n  </span><span class="s1">// route was rewritten to a different search string, then the optimistic</span><span class="s3">\n  </span><span class="s1">// route should be rewritten to the same search string. Otherwise, we use</span><span class="s3">\n  </span><span class="s1">// the requested search string.</span><span class="s3">\n  </span><span class="s1">const optimisticRenderedSearch =</span><span class="s3">\n    </span><span class="s1">routeWithNoSearchParams.renderedSearch !== ''</span><span class="s3">\n      </span><span class="s1">? // Base route was rewritten. Reuse the same rewritten search string.</span><span class="s3">\n        </span><span class="s1">routeWithNoSearchParams.renderedSearch</span><span class="s3">\n      </span><span class="s1">: requestedSearch</span><span class="s3">\n\n  </span><span class="s1">const optimisticUrl = new URL(</span><span class="s3">\n    </span><span class="s1">routeWithNoSearchParams.canonicalUrl,</span><span class="s3">\n    </span><span class="s1">location.origin</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">optimisticUrl.search = optimisticCanonicalSearch</span><span class="s3">\n  </span><span class="s1">const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)</span><span class="s3">\n\n  </span><span class="s1">// Clone the base route tree, and override the relevant fields with our</span><span class="s3">\n  </span><span class="s1">// optimistic values.</span><span class="s3">\n  </span><span class="s1">const optimisticEntry: FulfilledRouteCacheEntry = {</span><span class="s3">\n    </span><span class="s1">canonicalUrl: optimisticCanonicalUrl,</span><span class="s3">\n\n    </span><span class="s1">status: EntryStatus.Fulfilled,</span><span class="s3">\n    </span><span class="s1">// This isn't cloned because it's instance-specific</span><span class="s3">\n    </span><span class="s1">blockedTasks: null,</span><span class="s3">\n    </span><span class="s1">tree: routeWithNoSearchParams.tree,</span><span class="s3">\n    </span><span class="s1">head: routeWithNoSearchParams.head,</span><span class="s3">\n    </span><span class="s1">isHeadPartial: routeWithNoSearchParams.isHeadPartial,</span><span class="s3">\n    </span><span class="s1">staleAt: routeWithNoSearchParams.staleAt,</span><span class="s3">\n    </span><span class="s1">couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,</span><span class="s3">\n    </span><span class="s1">isPPREnabled: routeWithNoSearchParams.isPPREnabled,</span><span class="s3">\n\n    </span><span class="s1">// Override the rendered search with the optimistic value.</span><span class="s3">\n    </span><span class="s1">renderedSearch: optimisticRenderedSearch,</span><span class="s3">\n\n    </span><span class="s1">TODO_metadataStatus: routeWithNoSearchParams.TODO_metadataStatus,</span><span class="s3">\n    </span><span class="s1">TODO_isHeadDynamic: routeWithNoSearchParams.TODO_isHeadDynamic,</span><span class="s3">\n\n    </span><span class="s1">// LRU-related fields</span><span class="s3">\n    </span><span class="s1">keypath: null,</span><span class="s3">\n    </span><span class="s1">next: null,</span><span class="s3">\n    </span><span class="s1">prev: null,</span><span class="s3">\n    </span><span class="s1">size: 0,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Do not insert this entry into the cache. It only exists so we can</span><span class="s3">\n  </span><span class="s1">// perform the current navigation. Just return it to the caller.</span><span class="s3">\n  </span><span class="s1">return optimisticEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if an entry for a segment exists in the cache. If so, it returns the</span><span class="s3">\n </span><span class="s1">* entry, If not, it adds an empty entry to the cache and returns it.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function readOrCreateSegmentCacheEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">task: PrefetchTask,</span><span class="s3">\n  </span><span class="s1">route: FulfilledRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">cacheKey: SegmentCacheKey</span><span class="s3">\n</span><span class="s1">): SegmentCacheEntry {</span><span class="s3">\n  </span><span class="s1">const keypath = getSegmentKeypathForTask(task, route, cacheKey)</span><span class="s3">\n  </span><span class="s1">const existingEntry = readExactSegmentCacheEntry(now, keypath)</span><span class="s3">\n  </span><span class="s1">if (existingEntry !== null) {</span><span class="s3">\n    </span><span class="s1">return existingEntry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Create a pending entry and add it to the cache.</span><span class="s3">\n  </span><span class="s1">const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)</span><span class="s3">\n  </span><span class="s1">segmentCacheMap.set(keypath, pendingEntry)</span><span class="s3">\n  </span><span class="s1">// Stash the keypath on the entry so we know how to remove it from the map</span><span class="s3">\n  </span><span class="s1">// if it gets evicted from the LRU.</span><span class="s3">\n  </span><span class="s1">pendingEntry.keypath = keypath</span><span class="s3">\n  </span><span class="s1">segmentCacheLru.put(pendingEntry)</span><span class="s3">\n  </span><span class="s1">return pendingEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function readOrCreateRevalidatingSegmentEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">prevEntry: SegmentCacheEntry</span><span class="s3">\n</span><span class="s1">): SegmentCacheEntry {</span><span class="s3">\n  </span><span class="s1">const existingRevalidation = readRevalidatingSegmentCacheEntry(now, prevEntry)</span><span class="s3">\n  </span><span class="s1">if (existingRevalidation !== null) {</span><span class="s3">\n    </span><span class="s1">return existingRevalidation</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const pendingEntry = createDetachedSegmentCacheEntry(prevEntry.staleAt)</span><span class="s3">\n\n  </span><span class="s1">// Background revalidations are not stored directly in the cache map or LRU;</span><span class="s3">\n  </span><span class="s1">// they're stashed on the entry that they will (potentially) replace.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Note that we don't actually ever clear this field, except when the entry</span><span class="s3">\n  </span><span class="s1">// expires. When the revalidation finishes, one of two things will happen:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//  1) the revalidation is successful, `prevEntry` is removed from the cache</span><span class="s3">\n  </span><span class="s1">//     and garbage collected (so there's no point clearing any of its fields)</span><span class="s3">\n  </span><span class="s1">//  2) the revalidation fails, and we'll use the `revalidating` field to</span><span class="s3">\n  </span><span class="s1">//     prevent subsequent revalidation attempts, until it expires.</span><span class="s3">\n  </span><span class="s1">prevEntry.revalidating = pendingEntry</span><span class="s3">\n\n  </span><span class="s1">return pendingEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function upsertSegmentEntry(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">keypath: Prefix&lt;SegmentCacheKeypath&gt;,</span><span class="s3">\n  </span><span class="s1">candidateEntry: SegmentCacheEntry</span><span class="s3">\n</span><span class="s1">): SegmentCacheEntry | null {</span><span class="s3">\n  </span><span class="s1">// We have a new entry that has not yet been inserted into the cache. Before</span><span class="s3">\n  </span><span class="s1">// we do so, we need to confirm whether it takes precedence over the existing</span><span class="s3">\n  </span><span class="s1">// entry (if one exists).</span><span class="s3">\n  </span><span class="s1">// TODO: We should not upsert an entry if its key was invalidated in the time</span><span class="s3">\n  </span><span class="s1">// since the request was made. We can do that by passing the </span><span class="s3">\&quot;</span><span class="s1">owner</span><span class="s3">\&quot; </span><span class="s1">entry to</span><span class="s3">\n  </span><span class="s1">// this function and confirming it's the same as `existingEntry`.</span><span class="s3">\n  </span><span class="s1">const existingEntry = readExactSegmentCacheEntry(now, keypath)</span><span class="s3">\n  </span><span class="s1">if (existingEntry !== null) {</span><span class="s3">\n    </span><span class="s1">// Don't replace a more specific segment with a less-specific one. A case where this</span><span class="s3">\n    </span><span class="s1">// might happen is if the existing segment was fetched via</span><span class="s3">\n    </span><span class="s1">// `&lt;Link prefetch={true}&gt;`.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// We fetched the new segment using a different, less specific fetch strategy</span><span class="s3">\n      </span><span class="s1">// than the segment we already have in the cache, so it can't have more content.</span><span class="s3">\n      </span><span class="s1">(candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!canNewFetchStrategyProvideMoreContent(</span><span class="s3">\n          </span><span class="s1">existingEntry.fetchStrategy,</span><span class="s3">\n          </span><span class="s1">candidateEntry.fetchStrategy</span><span class="s3">\n        </span><span class="s1">)) ||</span><span class="s3">\n      </span><span class="s1">// The existing entry isn't partial, but the new one is.</span><span class="s3">\n      </span><span class="s1">// (TODO: can this be true if `candidateEntry.fetchStrategy &gt;= existingEntry.fetchStrategy`?)</span><span class="s3">\n      </span><span class="s1">(!existingEntry.isPartial &amp;&amp; candidateEntry.isPartial)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// We're going to leave the entry on the owner's `revalidating` field</span><span class="s3">\n      </span><span class="s1">// so that it doesn't get revalidated again unnecessarily. Downgrade the</span><span class="s3">\n      </span><span class="s1">// Fulfilled entry to Rejected and null out the data so it can be garbage</span><span class="s3">\n      </span><span class="s1">// collected. We leave `staleAt` intact to prevent subsequent revalidation</span><span class="s3">\n      </span><span class="s1">// attempts only until the entry expires.</span><span class="s3">\n      </span><span class="s1">const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any</span><span class="s3">\n      </span><span class="s1">rejectedEntry.status = EntryStatus.Rejected</span><span class="s3">\n      </span><span class="s1">rejectedEntry.loading = null</span><span class="s3">\n      </span><span class="s1">rejectedEntry.rsc = null</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Evict the existing entry from the cache.</span><span class="s3">\n    </span><span class="s1">deleteSegmentFromCache(existingEntry, keypath)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">segmentCacheMap.set(keypath, candidateEntry)</span><span class="s3">\n  </span><span class="s1">// Stash the keypath on the entry so we know how to remove it from the map</span><span class="s3">\n  </span><span class="s1">// if it gets evicted from the LRU.</span><span class="s3">\n  </span><span class="s1">candidateEntry.keypath = keypath</span><span class="s3">\n  </span><span class="s1">segmentCacheLru.put(candidateEntry)</span><span class="s3">\n  </span><span class="s1">return candidateEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createDetachedSegmentCacheEntry(</span><span class="s3">\n  </span><span class="s1">staleAt: number</span><span class="s3">\n</span><span class="s1">): EmptySegmentCacheEntry {</span><span class="s3">\n  </span><span class="s1">const emptyEntry: EmptySegmentCacheEntry = {</span><span class="s3">\n    </span><span class="s1">status: EntryStatus.Empty,</span><span class="s3">\n    </span><span class="s1">// Default to assuming the fetch strategy will be PPR. This will be updated</span><span class="s3">\n    </span><span class="s1">// when a fetch is actually initiated.</span><span class="s3">\n    </span><span class="s1">fetchStrategy: FetchStrategy.PPR,</span><span class="s3">\n    </span><span class="s1">revalidating: null,</span><span class="s3">\n    </span><span class="s1">rsc: null,</span><span class="s3">\n    </span><span class="s1">loading: null,</span><span class="s3">\n    </span><span class="s1">staleAt,</span><span class="s3">\n    </span><span class="s1">isPartial: true,</span><span class="s3">\n    </span><span class="s1">promise: null,</span><span class="s3">\n\n    </span><span class="s1">// LRU-related fields</span><span class="s3">\n    </span><span class="s1">keypath: null,</span><span class="s3">\n    </span><span class="s1">next: null,</span><span class="s3">\n    </span><span class="s1">prev: null,</span><span class="s3">\n    </span><span class="s1">size: 0,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return emptyEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function upgradeToPendingSegment(</span><span class="s3">\n  </span><span class="s1">emptyEntry: EmptySegmentCacheEntry,</span><span class="s3">\n  </span><span class="s1">fetchStrategy: FetchStrategy</span><span class="s3">\n</span><span class="s1">): PendingSegmentCacheEntry {</span><span class="s3">\n  </span><span class="s1">const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any</span><span class="s3">\n  </span><span class="s1">pendingEntry.status = EntryStatus.Pending</span><span class="s3">\n  </span><span class="s1">pendingEntry.fetchStrategy = fetchStrategy</span><span class="s3">\n  </span><span class="s1">return pendingEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function deleteRouteFromCache(</span><span class="s3">\n  </span><span class="s1">entry: RouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">keypath: Prefix&lt;RouteCacheKeypath&gt;</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">pingBlockedTasks(entry)</span><span class="s3">\n  </span><span class="s1">routeCacheMap.delete(keypath)</span><span class="s3">\n  </span><span class="s1">routeCacheLru.delete(entry)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function deleteSegmentFromCache(</span><span class="s3">\n  </span><span class="s1">entry: SegmentCacheEntry,</span><span class="s3">\n  </span><span class="s1">keypath: Prefix&lt;SegmentCacheKeypath&gt;</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">cancelEntryListeners(entry)</span><span class="s3">\n  </span><span class="s1">segmentCacheMap.delete(keypath)</span><span class="s3">\n  </span><span class="s1">segmentCacheLru.delete(entry)</span><span class="s3">\n  </span><span class="s1">clearRevalidatingSegmentFromOwner(entry)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function clearRevalidatingSegmentFromOwner(owner: SegmentCacheEntry): void {</span><span class="s3">\n  </span><span class="s1">// Revalidating segments are not stored in the cache directly; they're</span><span class="s3">\n  </span><span class="s1">// stored as a field on the entry that they will (potentially) replace. So</span><span class="s3">\n  </span><span class="s1">// to dispose of an existing revalidation, we just need to null out the field</span><span class="s3">\n  </span><span class="s1">// on the owner.</span><span class="s3">\n  </span><span class="s1">const revalidatingSegment = owner.revalidating</span><span class="s3">\n  </span><span class="s1">if (revalidatingSegment !== null) {</span><span class="s3">\n    </span><span class="s1">cancelEntryListeners(revalidatingSegment)</span><span class="s3">\n    </span><span class="s1">owner.revalidating = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function resetRevalidatingSegmentEntry(</span><span class="s3">\n  </span><span class="s1">owner: SegmentCacheEntry</span><span class="s3">\n</span><span class="s1">): EmptySegmentCacheEntry {</span><span class="s3">\n  </span><span class="s1">clearRevalidatingSegmentFromOwner(owner)</span><span class="s3">\n  </span><span class="s1">const emptyEntry = createDetachedSegmentCacheEntry(owner.staleAt)</span><span class="s3">\n  </span><span class="s1">owner.revalidating = emptyEntry</span><span class="s3">\n  </span><span class="s1">return emptyEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function onRouteLRUEviction(entry: RouteCacheEntry): void {</span><span class="s3">\n  </span><span class="s1">// The LRU evicted this entry. Remove it from the map.</span><span class="s3">\n  </span><span class="s1">const keypath = entry.keypath</span><span class="s3">\n  </span><span class="s1">if (keypath !== null) {</span><span class="s3">\n    </span><span class="s1">entry.keypath = null</span><span class="s3">\n    </span><span class="s1">pingBlockedTasks(entry)</span><span class="s3">\n    </span><span class="s1">routeCacheMap.delete(keypath)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function onSegmentLRUEviction(entry: SegmentCacheEntry): void {</span><span class="s3">\n  </span><span class="s1">// The LRU evicted this entry. Remove it from the map.</span><span class="s3">\n  </span><span class="s1">const keypath = entry.keypath</span><span class="s3">\n  </span><span class="s1">if (keypath !== null) {</span><span class="s3">\n    </span><span class="s1">entry.keypath = null</span><span class="s3">\n    </span><span class="s1">cancelEntryListeners(entry)</span><span class="s3">\n    </span><span class="s1">segmentCacheMap.delete(keypath)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function cancelEntryListeners(entry: SegmentCacheEntry): void {</span><span class="s3">\n  </span><span class="s1">if (entry.status === EntryStatus.Pending &amp;&amp; entry.promise !== null) {</span><span class="s3">\n    </span><span class="s1">// There were listeners for this entry. Resolve them with `null` to indicate</span><span class="s3">\n    </span><span class="s1">// that the prefetch failed. It's up to the listener to decide how to handle</span><span class="s3">\n    </span><span class="s1">// this case.</span><span class="s3">\n    </span><span class="s1">// NOTE: We don't currently propagate the reason the prefetch was canceled</span><span class="s3">\n    </span><span class="s1">// but we could by accepting a `reason` argument.</span><span class="s3">\n    </span><span class="s1">entry.promise.resolve(null)</span><span class="s3">\n    </span><span class="s1">entry.promise = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function pingBlockedTasks(entry: {</span><span class="s3">\n  </span><span class="s1">blockedTasks: Set&lt;PrefetchTask&gt; | null</span><span class="s3">\n</span><span class="s1">}): void {</span><span class="s3">\n  </span><span class="s1">const blockedTasks = entry.blockedTasks</span><span class="s3">\n  </span><span class="s1">if (blockedTasks !== null) {</span><span class="s3">\n    </span><span class="s1">for (const task of blockedTasks) {</span><span class="s3">\n      </span><span class="s1">pingPrefetchTask(task)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">entry.blockedTasks = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function fulfillRouteCacheEntry(</span><span class="s3">\n  </span><span class="s1">entry: RouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">tree: RouteTree,</span><span class="s3">\n  </span><span class="s1">head: HeadData,</span><span class="s3">\n  </span><span class="s1">isHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">staleAt: number,</span><span class="s3">\n  </span><span class="s1">couldBeIntercepted: boolean,</span><span class="s3">\n  </span><span class="s1">canonicalUrl: string,</span><span class="s3">\n  </span><span class="s1">renderedSearch: NormalizedSearch,</span><span class="s3">\n  </span><span class="s1">isPPREnabled: boolean,</span><span class="s3">\n  </span><span class="s1">isHeadDynamic: boolean</span><span class="s3">\n</span><span class="s1">): FulfilledRouteCacheEntry {</span><span class="s3">\n  </span><span class="s1">const fulfilledEntry: FulfilledRouteCacheEntry = entry as any</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.status = EntryStatus.Fulfilled</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.tree = tree</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.head = head</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.isHeadPartial = isHeadPartial</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.staleAt = staleAt</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.couldBeIntercepted = couldBeIntercepted</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.canonicalUrl = canonicalUrl</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.renderedSearch = renderedSearch</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.isPPREnabled = isPPREnabled</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.TODO_isHeadDynamic = isHeadDynamic</span><span class="s3">\n  </span><span class="s1">pingBlockedTasks(entry)</span><span class="s3">\n  </span><span class="s1">return fulfilledEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function fulfillSegmentCacheEntry(</span><span class="s3">\n  </span><span class="s1">segmentCacheEntry: PendingSegmentCacheEntry,</span><span class="s3">\n  </span><span class="s1">rsc: React.ReactNode,</span><span class="s3">\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;,</span><span class="s3">\n  </span><span class="s1">staleAt: number,</span><span class="s3">\n  </span><span class="s1">isPartial: boolean</span><span class="s3">\n</span><span class="s1">): FulfilledSegmentCacheEntry {</span><span class="s3">\n  </span><span class="s1">const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.status = EntryStatus.Fulfilled</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.rsc = rsc</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.loading = loading</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.staleAt = staleAt</span><span class="s3">\n  </span><span class="s1">fulfilledEntry.isPartial = isPartial</span><span class="s3">\n  </span><span class="s1">// Resolve any listeners that were waiting for this data.</span><span class="s3">\n  </span><span class="s1">if (segmentCacheEntry.promise !== null) {</span><span class="s3">\n    </span><span class="s1">segmentCacheEntry.promise.resolve(fulfilledEntry)</span><span class="s3">\n    </span><span class="s1">// Free the promise for garbage collection.</span><span class="s3">\n    </span><span class="s1">fulfilledEntry.promise = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return fulfilledEntry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function rejectRouteCacheEntry(</span><span class="s3">\n  </span><span class="s1">entry: PendingRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">staleAt: number</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const rejectedEntry: RejectedRouteCacheEntry = entry as any</span><span class="s3">\n  </span><span class="s1">rejectedEntry.status = EntryStatus.Rejected</span><span class="s3">\n  </span><span class="s1">rejectedEntry.staleAt = staleAt</span><span class="s3">\n  </span><span class="s1">pingBlockedTasks(entry)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function rejectSegmentCacheEntry(</span><span class="s3">\n  </span><span class="s1">entry: PendingSegmentCacheEntry,</span><span class="s3">\n  </span><span class="s1">staleAt: number</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const rejectedEntry: RejectedSegmentCacheEntry = entry as any</span><span class="s3">\n  </span><span class="s1">rejectedEntry.status = EntryStatus.Rejected</span><span class="s3">\n  </span><span class="s1">rejectedEntry.staleAt = staleAt</span><span class="s3">\n  </span><span class="s1">if (entry.promise !== null) {</span><span class="s3">\n    </span><span class="s1">// NOTE: We don't currently propagate the reason the prefetch was canceled</span><span class="s3">\n    </span><span class="s1">// but we could by accepting a `reason` argument.</span><span class="s3">\n    </span><span class="s1">entry.promise.resolve(null)</span><span class="s3">\n    </span><span class="s1">entry.promise = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function convertRootTreePrefetchToRouteTree(</span><span class="s3">\n  </span><span class="s1">rootTree: RootTreePrefetch,</span><span class="s3">\n  </span><span class="s1">renderedPathname: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Remove trailing and leading slashes</span><span class="s3">\n  </span><span class="s1">const pathnameParts = renderedPathname.split('/').filter((p) =&gt; p !== '')</span><span class="s3">\n  </span><span class="s1">const index = 0</span><span class="s3">\n  </span><span class="s1">const rootSegment = ROOT_SEGMENT_CACHE_KEY</span><span class="s3">\n  </span><span class="s1">return convertTreePrefetchToRouteTree(</span><span class="s3">\n    </span><span class="s1">rootTree.tree,</span><span class="s3">\n    </span><span class="s1">rootSegment,</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">ROOT_SEGMENT_REQUEST_KEY,</span><span class="s3">\n    </span><span class="s1">ROOT_SEGMENT_CACHE_KEY,</span><span class="s3">\n    </span><span class="s1">pathnameParts,</span><span class="s3">\n    </span><span class="s1">index</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function convertTreePrefetchToRouteTree(</span><span class="s3">\n  </span><span class="s1">prefetch: TreePrefetch,</span><span class="s3">\n  </span><span class="s1">segment: FlightRouterStateSegment,</span><span class="s3">\n  </span><span class="s1">param: RouteParam | null,</span><span class="s3">\n  </span><span class="s1">requestKey: SegmentRequestKey,</span><span class="s3">\n  </span><span class="s1">cacheKey: SegmentCacheKey,</span><span class="s3">\n  </span><span class="s1">pathnameParts: Array&lt;string&gt;,</span><span class="s3">\n  </span><span class="s1">pathnamePartsIndex: number</span><span class="s3">\n</span><span class="s1">): RouteTree {</span><span class="s3">\n  </span><span class="s1">// Converts the route tree sent by the server into the format used by the</span><span class="s3">\n  </span><span class="s1">// cache. The cached version of the tree includes additional fields, such as a</span><span class="s3">\n  </span><span class="s1">// cache key for each segment. Since this is frequently accessed, we compute</span><span class="s3">\n  </span><span class="s1">// it once instead of on every access. This same cache key is also used to</span><span class="s3">\n  </span><span class="s1">// request the segment from the server.</span><span class="s3">\n\n  </span><span class="s1">let slots: { [parallelRouteKey: string]: RouteTree } | null = null</span><span class="s3">\n  </span><span class="s1">const prefetchSlots = prefetch.slots</span><span class="s3">\n  </span><span class="s1">if (prefetchSlots !== null) {</span><span class="s3">\n    </span><span class="s1">slots = {}</span><span class="s3">\n    </span><span class="s1">for (let parallelRouteKey in prefetchSlots) {</span><span class="s3">\n      </span><span class="s1">const childPrefetch = prefetchSlots[parallelRouteKey]</span><span class="s3">\n      </span><span class="s1">const childParamName = childPrefetch.name</span><span class="s3">\n      </span><span class="s1">const childParamType = childPrefetch.paramType</span><span class="s3">\n      </span><span class="s1">const childServerSentParamKey = childPrefetch.paramKey</span><span class="s3">\n\n      </span><span class="s1">let childDoesAppearInURL: boolean</span><span class="s3">\n      </span><span class="s1">let childParam: RouteParam | null = null</span><span class="s3">\n      </span><span class="s1">let childSegment: FlightRouterStateSegment</span><span class="s3">\n      </span><span class="s1">if (childParamType !== null) {</span><span class="s3">\n        </span><span class="s1">// This segment is parameterized. Get the param from the pathname.</span><span class="s3">\n        </span><span class="s1">const childParamValue = parseDynamicParamFromURLPart(</span><span class="s3">\n          </span><span class="s1">childParamType,</span><span class="s3">\n          </span><span class="s1">pathnameParts,</span><span class="s3">\n          </span><span class="s1">pathnamePartsIndex</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// Assign a cache key to the segment, based on the param value. In the</span><span class="s3">\n        </span><span class="s1">// pre-Segment Cache implementation, the server computes this and sends</span><span class="s3">\n        </span><span class="s1">// it in the body of the response. In the Segment Cache implementation,</span><span class="s3">\n        </span><span class="s1">// the server sends an empty string and we fill it in here.</span><span class="s3">\n\n        </span><span class="s1">// TODO: We're intentionally not adding the search param to page</span><span class="s3">\n        </span><span class="s1">// segments here; it's tracked separately and added back during a read.</span><span class="s3">\n        </span><span class="s1">// This would clearer if we waited to construct the segment until it's</span><span class="s3">\n        </span><span class="s1">// read from the cache, since that's effectively what we're</span><span class="s3">\n        </span><span class="s1">// doing anyway.</span><span class="s3">\n        </span><span class="s1">const renderedSearch = '' as NormalizedSearch</span><span class="s3">\n        </span><span class="s1">const childParamKey =</span><span class="s3">\n          </span><span class="s1">// The server omits this field from the prefetch response when</span><span class="s3">\n          </span><span class="s1">// clientParamParsing is enabled. The flag only exists while we're</span><span class="s3">\n          </span><span class="s1">// testing the feature, in case there's a bug and we need to revert.</span><span class="s3">\n          </span><span class="s1">// TODO: Remove once clientParamParsing is enabled everywhere.</span><span class="s3">\n          </span><span class="s1">childServerSentParamKey !== null</span><span class="s3">\n            </span><span class="s1">? childServerSentParamKey</span><span class="s3">\n            </span><span class="s1">: // If no param key was sent, use the value parsed on the client.</span><span class="s3">\n              </span><span class="s1">getCacheKeyForDynamicParam(childParamValue, renderedSearch)</span><span class="s3">\n\n        </span><span class="s1">childParam = {</span><span class="s3">\n          </span><span class="s1">name: childParamName,</span><span class="s3">\n          </span><span class="s1">value: childParamValue,</span><span class="s3">\n          </span><span class="s1">type: childParamType,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">childSegment = [childParamName, childParamKey, childParamType]</span><span class="s3">\n        </span><span class="s1">childDoesAppearInURL = true</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">childSegment = childParamName</span><span class="s3">\n        </span><span class="s1">childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Only increment the index if the segment appears in the URL. If it's a</span><span class="s3">\n      </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">virtual</span><span class="s3">\&quot; </span><span class="s1">segment, like a route group, it remains the same.</span><span class="s3">\n      </span><span class="s1">const childPathnamePartsIndex = childDoesAppearInURL</span><span class="s3">\n        </span><span class="s1">? pathnamePartsIndex + 1</span><span class="s3">\n        </span><span class="s1">: pathnamePartsIndex</span><span class="s3">\n\n      </span><span class="s1">const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)</span><span class="s3">\n      </span><span class="s1">const childRequestKey = appendSegmentRequestKeyPart(</span><span class="s3">\n        </span><span class="s1">requestKey,</span><span class="s3">\n        </span><span class="s1">parallelRouteKey,</span><span class="s3">\n        </span><span class="s1">childRequestKeyPart</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const childCacheKey = appendSegmentCacheKeyPart(</span><span class="s3">\n        </span><span class="s1">cacheKey,</span><span class="s3">\n        </span><span class="s1">parallelRouteKey,</span><span class="s3">\n        </span><span class="s1">createSegmentCacheKeyPart(childRequestKeyPart, childSegment)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">slots[parallelRouteKey] = convertTreePrefetchToRouteTree(</span><span class="s3">\n        </span><span class="s1">childPrefetch,</span><span class="s3">\n        </span><span class="s1">childSegment,</span><span class="s3">\n        </span><span class="s1">childParam,</span><span class="s3">\n        </span><span class="s1">childRequestKey,</span><span class="s3">\n        </span><span class="s1">childCacheKey,</span><span class="s3">\n        </span><span class="s1">pathnameParts,</span><span class="s3">\n        </span><span class="s1">childPathnamePartsIndex</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">cacheKey,</span><span class="s3">\n    </span><span class="s1">requestKey,</span><span class="s3">\n    </span><span class="s1">segment,</span><span class="s3">\n    </span><span class="s1">param,</span><span class="s3">\n    </span><span class="s1">slots,</span><span class="s3">\n    </span><span class="s1">isRootLayout: prefetch.isRootLayout,</span><span class="s3">\n    </span><span class="s1">// This field is only relevant to dynamic routes. For a PPR/static route,</span><span class="s3">\n    </span><span class="s1">// there's always some partial loading state we can fetch.</span><span class="s3">\n    </span><span class="s1">hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function convertRootFlightRouterStateToRouteTree(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): RouteTree {</span><span class="s3">\n  </span><span class="s1">return convertFlightRouterStateToRouteTree(</span><span class="s3">\n    </span><span class="s1">flightRouterState,</span><span class="s3">\n    </span><span class="s1">ROOT_SEGMENT_CACHE_KEY,</span><span class="s3">\n    </span><span class="s1">ROOT_SEGMENT_REQUEST_KEY</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function convertFlightRouterStateToRouteTree(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">cacheKey: SegmentCacheKey,</span><span class="s3">\n  </span><span class="s1">requestKey: SegmentRequestKey</span><span class="s3">\n</span><span class="s1">): RouteTree {</span><span class="s3">\n  </span><span class="s1">let slots: { [parallelRouteKey: string]: RouteTree } | null = null</span><span class="s3">\n\n  </span><span class="s1">const parallelRoutes = flightRouterState[1]</span><span class="s3">\n  </span><span class="s1">for (let parallelRouteKey in parallelRoutes) {</span><span class="s3">\n    </span><span class="s1">const childRouterState = parallelRoutes[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const childSegment = childRouterState[0]</span><span class="s3">\n    </span><span class="s1">// TODO: Eventually, the param values will not be included in the response</span><span class="s3">\n    </span><span class="s1">// from the server. We'll instead fill them in on the client by parsing</span><span class="s3">\n    </span><span class="s1">// the URL. This is where we'll do that.</span><span class="s3">\n    </span><span class="s1">const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)</span><span class="s3">\n    </span><span class="s1">const childRequestKey = appendSegmentRequestKeyPart(</span><span class="s3">\n      </span><span class="s1">requestKey,</span><span class="s3">\n      </span><span class="s1">parallelRouteKey,</span><span class="s3">\n      </span><span class="s1">childRequestKeyPart</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const childCacheKey = appendSegmentCacheKeyPart(</span><span class="s3">\n      </span><span class="s1">cacheKey,</span><span class="s3">\n      </span><span class="s1">parallelRouteKey,</span><span class="s3">\n      </span><span class="s1">createSegmentCacheKeyPart(childRequestKeyPart, childSegment)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const childTree = convertFlightRouterStateToRouteTree(</span><span class="s3">\n      </span><span class="s1">childRouterState,</span><span class="s3">\n      </span><span class="s1">childCacheKey,</span><span class="s3">\n      </span><span class="s1">childRequestKey</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (slots === null) {</span><span class="s3">\n      </span><span class="s1">slots = {</span><span class="s3">\n        </span><span class="s1">[parallelRouteKey]: childTree,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">slots[parallelRouteKey] = childTree</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const originalSegment = flightRouterState[0]</span><span class="s3">\n\n  </span><span class="s1">let segment: FlightRouterStateSegment</span><span class="s3">\n  </span><span class="s1">let param: RouteParam | null = null</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(originalSegment)) {</span><span class="s3">\n    </span><span class="s1">const paramCacheKey = originalSegment[1]</span><span class="s3">\n    </span><span class="s1">const paramType = originalSegment[2]</span><span class="s3">\n    </span><span class="s1">const paramValue = getParamValueFromCacheKey(paramCacheKey, paramType)</span><span class="s3">\n    </span><span class="s1">param = {</span><span class="s3">\n      </span><span class="s1">name: originalSegment[0],</span><span class="s3">\n      </span><span class="s1">value: paramValue === undefined ? null : paramValue,</span><span class="s3">\n      </span><span class="s1">type: originalSegment[2] as DynamicParamTypesShort,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">segment = originalSegment</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// The navigation implementation expects the search params to be included</span><span class="s3">\n    </span><span class="s1">// in the segment. However, in the case of a static response, the search</span><span class="s3">\n    </span><span class="s1">// params are omitted. So the client needs to add them back in when reading</span><span class="s3">\n    </span><span class="s1">// from the Segment Cache.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// For consistency, we'll do this for dynamic responses, too.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// TODO: We should move search params out of FlightRouterState and handle</span><span class="s3">\n    </span><span class="s1">// them entirely on the client, similar to our plan for dynamic params.</span><span class="s3">\n    </span><span class="s1">segment =</span><span class="s3">\n      </span><span class="s1">typeof originalSegment === 'string' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">originalSegment.startsWith(PAGE_SEGMENT_KEY)</span><span class="s3">\n        </span><span class="s1">? PAGE_SEGMENT_KEY</span><span class="s3">\n        </span><span class="s1">: originalSegment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">cacheKey,</span><span class="s3">\n    </span><span class="s1">requestKey,</span><span class="s3">\n    </span><span class="s1">segment,</span><span class="s3">\n    </span><span class="s1">param,</span><span class="s3">\n    </span><span class="s1">slots,</span><span class="s3">\n    </span><span class="s1">isRootLayout: flightRouterState[4] === true,</span><span class="s3">\n    </span><span class="s1">hasLoadingBoundary:</span><span class="s3">\n      </span><span class="s1">flightRouterState[5] !== undefined</span><span class="s3">\n        </span><span class="s1">? flightRouterState[5]</span><span class="s3">\n        </span><span class="s1">: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function convertRouteTreeToFlightRouterState(</span><span class="s3">\n  </span><span class="s1">routeTree: RouteTree</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const parallelRoutes: Record&lt;string, FlightRouterState&gt; = {}</span><span class="s3">\n  </span><span class="s1">if (routeTree.slots !== null) {</span><span class="s3">\n    </span><span class="s1">for (const parallelRouteKey in routeTree.slots) {</span><span class="s3">\n      </span><span class="s1">parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(</span><span class="s3">\n        </span><span class="s1">routeTree.slots[parallelRouteKey]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const flightRouterState: FlightRouterState = [</span><span class="s3">\n    </span><span class="s1">routeTree.segment,</span><span class="s3">\n    </span><span class="s1">parallelRoutes,</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">routeTree.isRootLayout,</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">return flightRouterState</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function fetchRouteOnCacheMiss(</span><span class="s3">\n  </span><span class="s1">entry: PendingRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">task: PrefetchTask</span><span class="s3">\n</span><span class="s1">): Promise&lt;PrefetchSubtaskResult&lt;null&gt; | null&gt; {</span><span class="s3">\n  </span><span class="s1">// This function is allowed to use async/await because it contains the actual</span><span class="s3">\n  </span><span class="s1">// fetch that gets issued on a cache miss. Notice it writes the result to the</span><span class="s3">\n  </span><span class="s1">// cache entry directly, rather than return data that is then written by</span><span class="s3">\n  </span><span class="s1">// the caller.</span><span class="s3">\n  </span><span class="s1">const key = task.key</span><span class="s3">\n  </span><span class="s1">const href = key.href</span><span class="s3">\n  </span><span class="s1">const nextUrl = key.nextUrl</span><span class="s3">\n  </span><span class="s1">const segmentPath = '/_tree' as SegmentRequestKey</span><span class="s3">\n\n  </span><span class="s1">const headers: RequestHeaders = {</span><span class="s3">\n    </span><span class="s1">[RSC_HEADER]: '1',</span><span class="s3">\n    </span><span class="s1">[NEXT_ROUTER_PREFETCH_HEADER]: '1',</span><span class="s3">\n    </span><span class="s1">[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (nextUrl !== null) {</span><span class="s3">\n    </span><span class="s1">headers[NEXT_URL] = nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">let response</span><span class="s3">\n    </span><span class="s1">let urlAfterRedirects</span><span class="s3">\n    </span><span class="s1">if (isOutputExportMode) {</span><span class="s3">\n      </span><span class="s1">// In output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot; </span><span class="s1">mode, we can't use headers to request a particular</span><span class="s3">\n      </span><span class="s1">// segment. Instead, we encode the extra request information into the URL.</span><span class="s3">\n      </span><span class="s1">// This is not part of the </span><span class="s3">\&quot;</span><span class="s1">public</span><span class="s3">\&quot; </span><span class="s1">interface of the app; it's an internal</span><span class="s3">\n      </span><span class="s1">// Next.js implementation detail that the app developer should not need to</span><span class="s3">\n      </span><span class="s1">// concern themselves with.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// For example, to request a segment:</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">//   Path passed to &lt;Link&gt;:   /path/to/page</span><span class="s3">\n      </span><span class="s1">//   Path passed to fetch:    /path/to/page/__next-segments/_tree</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">//   (This is not the exact protocol, just an illustration.)</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Before we do that, though, we need to account for redirects. Even in</span><span class="s3">\n      </span><span class="s1">// output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot; </span><span class="s1">mode, a proxy might redirect the page to a different</span><span class="s3">\n      </span><span class="s1">// location, but we shouldn't assume or expect that they also redirect all</span><span class="s3">\n      </span><span class="s1">// the segment files, too.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// To check whether the page is redirected, we perform a range request of</span><span class="s3">\n      </span><span class="s1">// the first N bytes of the HTML document. The canonical URL is determined</span><span class="s3">\n      </span><span class="s1">// from the response.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Then we can use the canonical URL to request the route tree.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// NOTE: We could embed the route tree into the HTML document, to avoid</span><span class="s3">\n      </span><span class="s1">// a second request. We're not doing that currently because it would make</span><span class="s3">\n      </span><span class="s1">// the HTML document larger and affect normal page loads.</span><span class="s3">\n      </span><span class="s1">const url = new URL(href)</span><span class="s3">\n      </span><span class="s1">const htmlResponse = await fetch(href, {</span><span class="s3">\n        </span><span class="s1">headers: {</span><span class="s3">\n          </span><span class="s1">Range: DOC_PREFETCH_RANGE_HEADER_VALUE,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">const partialHtml = await htmlResponse.text()</span><span class="s3">\n      </span><span class="s1">if (!doesExportedHtmlMatchBuildId(partialHtml, getAppBuildId())) {</span><span class="s3">\n        </span><span class="s1">// The target page is not part of this app, or it belongs to a</span><span class="s3">\n        </span><span class="s1">// different build.</span><span class="s3">\n        </span><span class="s1">rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">urlAfterRedirects = htmlResponse.redirected</span><span class="s3">\n        </span><span class="s1">? new URL(htmlResponse.url)</span><span class="s3">\n        </span><span class="s1">: url</span><span class="s3">\n      </span><span class="s1">response = await fetchPrefetchResponse(</span><span class="s3">\n        </span><span class="s1">addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),</span><span class="s3">\n        </span><span class="s1">headers</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Server</span><span class="s3">\&quot; </span><span class="s1">mode. We can use request headers instead of the pathname.</span><span class="s3">\n      </span><span class="s1">// TODO: The eventual plan is to get rid of our custom request headers and</span><span class="s3">\n      </span><span class="s1">// encode everything into the URL, using a similar strategy to the</span><span class="s3">\n      </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">output: export</span><span class="s3">\&quot; </span><span class="s1">block above.</span><span class="s3">\n      </span><span class="s1">const url = new URL(href)</span><span class="s3">\n      </span><span class="s1">response = await fetchPrefetchResponse(url, headers)</span><span class="s3">\n      </span><span class="s1">urlAfterRedirects =</span><span class="s3">\n        </span><span class="s1">response !== null &amp;&amp; response.redirected ? new URL(response.url) : url</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!response ||</span><span class="s3">\n      </span><span class="s1">!response.ok ||</span><span class="s3">\n      </span><span class="s1">// 204 is a Cache miss. Though theoretically this shouldn't happen when</span><span class="s3">\n      </span><span class="s1">// PPR is enabled, because we always respond to route tree requests, even</span><span class="s3">\n      </span><span class="s1">// if it needs to be blockingly generated on demand.</span><span class="s3">\n      </span><span class="s1">response.status === 204 ||</span><span class="s3">\n      </span><span class="s1">!response.body</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Server responded with an error, or with a miss. We should still cache</span><span class="s3">\n      </span><span class="s1">// the response, but we can try again after 10 seconds.</span><span class="s3">\n      </span><span class="s1">rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// TODO: The canonical URL is the href without the origin. I think</span><span class="s3">\n    </span><span class="s1">// historically the reason for this is because the initial canonical URL</span><span class="s3">\n    </span><span class="s1">// gets passed as a prop to the top-level React component, which means it</span><span class="s3">\n    </span><span class="s1">// needs to be computed during SSR. If it were to include the origin, it</span><span class="s3">\n    </span><span class="s1">// would need to always be same as location.origin on the client, to prevent</span><span class="s3">\n    </span><span class="s1">// a hydration mismatch. To sidestep this complexity, we omit the origin.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// However, since this is neither a native URL object nor a fully qualified</span><span class="s3">\n    </span><span class="s1">// URL string, we need to be careful about how we use it. To prevent subtle</span><span class="s3">\n    </span><span class="s1">// mistakes, we should create a special type for it, instead of just string.</span><span class="s3">\n    </span><span class="s1">// Or, we should just use a (readonly) URL object instead. The type of the</span><span class="s3">\n    </span><span class="s1">// prop that we pass to seed the initial state does not need to be the same</span><span class="s3">\n    </span><span class="s1">// type as the state itself.</span><span class="s3">\n    </span><span class="s1">const canonicalUrl = createHrefFromUrl(urlAfterRedirects)</span><span class="s3">\n\n    </span><span class="s1">// Check whether the response varies based on the Next-Url header.</span><span class="s3">\n    </span><span class="s1">const varyHeader = response.headers.get('vary')</span><span class="s3">\n    </span><span class="s1">const couldBeIntercepted =</span><span class="s3">\n      </span><span class="s1">varyHeader !== null &amp;&amp; varyHeader.includes(NEXT_URL)</span><span class="s3">\n\n    </span><span class="s1">// Track when the network connection closes.</span><span class="s3">\n    </span><span class="s1">const closed = createPromiseWithResolvers&lt;void&gt;()</span><span class="s3">\n\n    </span><span class="s1">// This checks whether the response was served from the per-segment cache,</span><span class="s3">\n    </span><span class="s1">// rather than the old prefetching flow. If it fails, it implies that PPR</span><span class="s3">\n    </span><span class="s1">// is disabled on this route.</span><span class="s3">\n    </span><span class="s1">const routeIsPPREnabled =</span><span class="s3">\n      </span><span class="s1">response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||</span><span class="s3">\n      </span><span class="s1">// In output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot; </span><span class="s1">mode, we can't rely on response headers. But if we</span><span class="s3">\n      </span><span class="s1">// receive a well-formed response, we can assume it's a static response,</span><span class="s3">\n      </span><span class="s1">// because all data is static in this mode.</span><span class="s3">\n      </span><span class="s1">isOutputExportMode</span><span class="s3">\n\n    </span><span class="s1">// Regardless of the type of response, we will never receive dynamic</span><span class="s3">\n    </span><span class="s1">// metadata as part of this prefetch request.</span><span class="s3">\n    </span><span class="s1">const isHeadDynamic = false</span><span class="s3">\n\n    </span><span class="s1">if (routeIsPPREnabled) {</span><span class="s3">\n      </span><span class="s1">const prefetchStream = createPrefetchResponseStream(</span><span class="s3">\n        </span><span class="s1">response.body,</span><span class="s3">\n        </span><span class="s1">closed.resolve,</span><span class="s3">\n        </span><span class="s1">function onResponseSizeUpdate(size) {</span><span class="s3">\n          </span><span class="s1">routeCacheLru.updateSize(entry, size)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const serverData = await (createFromNextReadableStream(</span><span class="s3">\n        </span><span class="s1">prefetchStream</span><span class="s3">\n      </span><span class="s1">) as Promise&lt;RootTreePrefetch&gt;)</span><span class="s3">\n      </span><span class="s1">if (serverData.buildId !== getAppBuildId()) {</span><span class="s3">\n        </span><span class="s1">// The server build does not match the client. Treat as a 404. During</span><span class="s3">\n        </span><span class="s1">// an actual navigation, the router will trigger an MPA navigation.</span><span class="s3">\n        </span><span class="s1">// TODO: Consider moving the build ID to a response header so we can check</span><span class="s3">\n        </span><span class="s1">// it before decoding the response, and so there's one way of checking</span><span class="s3">\n        </span><span class="s1">// across all response types.</span><span class="s3">\n        </span><span class="s1">// TODO: We should cache the fact that this is an MPA navigation.</span><span class="s3">\n        </span><span class="s1">rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Get the params that were used to render the target page. These may</span><span class="s3">\n      </span><span class="s1">// be different from the params in the request URL, if the page</span><span class="s3">\n      </span><span class="s1">// was rewritten.</span><span class="s3">\n      </span><span class="s1">const renderedPathname = getRenderedPathname(response)</span><span class="s3">\n      </span><span class="s1">const renderedSearch = getRenderedSearch(response)</span><span class="s3">\n\n      </span><span class="s1">const routeTree = convertRootTreePrefetchToRouteTree(</span><span class="s3">\n        </span><span class="s1">serverData,</span><span class="s3">\n        </span><span class="s1">renderedPathname</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const staleTimeMs = getStaleTimeMs(serverData.staleTime)</span><span class="s3">\n      </span><span class="s1">fulfillRouteCacheEntry(</span><span class="s3">\n        </span><span class="s1">entry,</span><span class="s3">\n        </span><span class="s1">routeTree,</span><span class="s3">\n        </span><span class="s1">serverData.head,</span><span class="s3">\n        </span><span class="s1">serverData.isHeadPartial,</span><span class="s3">\n        </span><span class="s1">Date.now() + staleTimeMs,</span><span class="s3">\n        </span><span class="s1">couldBeIntercepted,</span><span class="s3">\n        </span><span class="s1">canonicalUrl,</span><span class="s3">\n        </span><span class="s1">renderedSearch,</span><span class="s3">\n        </span><span class="s1">routeIsPPREnabled,</span><span class="s3">\n        </span><span class="s1">isHeadDynamic</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// PPR is not enabled for this route. The server responds with a</span><span class="s3">\n      </span><span class="s1">// different format (FlightRouterState) that we need to convert.</span><span class="s3">\n      </span><span class="s1">// TODO: We will unify the responses eventually. I'm keeping the types</span><span class="s3">\n      </span><span class="s1">// separate for now because FlightRouterState has so many</span><span class="s3">\n      </span><span class="s1">// overloaded concerns.</span><span class="s3">\n      </span><span class="s1">const prefetchStream = createPrefetchResponseStream(</span><span class="s3">\n        </span><span class="s1">response.body,</span><span class="s3">\n        </span><span class="s1">closed.resolve,</span><span class="s3">\n        </span><span class="s1">function onResponseSizeUpdate(size) {</span><span class="s3">\n          </span><span class="s1">routeCacheLru.updateSize(entry, size)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const serverData = await (createFromNextReadableStream(</span><span class="s3">\n        </span><span class="s1">prefetchStream</span><span class="s3">\n      </span><span class="s1">) as Promise&lt;NavigationFlightResponse&gt;)</span><span class="s3">\n      </span><span class="s1">if (serverData.b !== getAppBuildId()) {</span><span class="s3">\n        </span><span class="s1">// The server build does not match the client. Treat as a 404. During</span><span class="s3">\n        </span><span class="s1">// an actual navigation, the router will trigger an MPA navigation.</span><span class="s3">\n        </span><span class="s1">// TODO: Consider moving the build ID to a response header so we can check</span><span class="s3">\n        </span><span class="s1">// it before decoding the response, and so there's one way of checking</span><span class="s3">\n        </span><span class="s1">// across all response types.</span><span class="s3">\n        </span><span class="s1">// TODO: We should cache the fact that this is an MPA navigation.</span><span class="s3">\n        </span><span class="s1">rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">writeDynamicTreeResponseIntoCache(</span><span class="s3">\n        </span><span class="s1">Date.now(),</span><span class="s3">\n        </span><span class="s1">task,</span><span class="s3">\n        </span><span class="s1">// The non-PPR response format is what we'd get if we prefetched these segments</span><span class="s3">\n        </span><span class="s1">// using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.</span><span class="s3">\n        </span><span class="s1">FetchStrategy.LoadingBoundary,</span><span class="s3">\n        </span><span class="s1">response,</span><span class="s3">\n        </span><span class="s1">serverData,</span><span class="s3">\n        </span><span class="s1">entry,</span><span class="s3">\n        </span><span class="s1">couldBeIntercepted,</span><span class="s3">\n        </span><span class="s1">canonicalUrl,</span><span class="s3">\n        </span><span class="s1">routeIsPPREnabled</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!couldBeIntercepted &amp;&amp; nextUrl !== null) {</span><span class="s3">\n      </span><span class="s1">// This route will never be intercepted. So we can use this entry for all</span><span class="s3">\n      </span><span class="s1">// requests to this route, regardless of the Next-Url header. This works</span><span class="s3">\n      </span><span class="s1">// because when reading the cache we always check for a valid</span><span class="s3">\n      </span><span class="s1">// non-intercepted entry first.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Re-key the entry. Since we're in an async task, we must first confirm</span><span class="s3">\n      </span><span class="s1">// that the entry hasn't been concurrently modified by a different task.</span><span class="s3">\n      </span><span class="s1">const currentKeypath: Prefix&lt;RouteCacheKeypath&gt; = [href, nextUrl]</span><span class="s3">\n      </span><span class="s1">const expectedEntry = routeCacheMap.get(currentKeypath)</span><span class="s3">\n      </span><span class="s1">if (expectedEntry === entry) {</span><span class="s3">\n        </span><span class="s1">routeCacheMap.delete(currentKeypath)</span><span class="s3">\n        </span><span class="s1">const newKeypath: Prefix&lt;RouteCacheKeypath&gt; = [href]</span><span class="s3">\n        </span><span class="s1">routeCacheMap.set(newKeypath, entry)</span><span class="s3">\n        </span><span class="s1">// We don't need to update the LRU because the entry is already in it.</span><span class="s3">\n        </span><span class="s1">// But since we changed the keypath, we do need to update that, so we</span><span class="s3">\n        </span><span class="s1">// know how to remove it from the map if it gets evicted from the LRU.</span><span class="s3">\n        </span><span class="s1">entry.keypath = newKeypath</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Something else modified this entry already. Since the re-keying is</span><span class="s3">\n        </span><span class="s1">// just a performance optimization, we can safely skip it.</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Return a promise that resolves when the network connection closes, so</span><span class="s3">\n    </span><span class="s1">// the scheduler can track the number of concurrent network connections.</span><span class="s3">\n    </span><span class="s1">return { value: null, closed: closed.promise }</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Either the connection itself failed, or something bad happened while</span><span class="s3">\n    </span><span class="s1">// decoding the response.</span><span class="s3">\n    </span><span class="s1">rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function fetchSegmentOnCacheMiss(</span><span class="s3">\n  </span><span class="s1">route: FulfilledRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">segmentCacheEntry: PendingSegmentCacheEntry,</span><span class="s3">\n  </span><span class="s1">routeKey: RouteCacheKey,</span><span class="s3">\n  </span><span class="s1">tree: RouteTree</span><span class="s3">\n</span><span class="s1">): Promise&lt;PrefetchSubtaskResult&lt;FulfilledSegmentCacheEntry&gt; | null&gt; {</span><span class="s3">\n  </span><span class="s1">// This function is allowed to use async/await because it contains the actual</span><span class="s3">\n  </span><span class="s1">// fetch that gets issued on a cache miss. Notice it writes the result to the</span><span class="s3">\n  </span><span class="s1">// cache entry directly, rather than return data that is then written by</span><span class="s3">\n  </span><span class="s1">// the caller.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Segment fetches are non-blocking so we don't need to ping the scheduler</span><span class="s3">\n  </span><span class="s1">// on completion.</span><span class="s3">\n\n  </span><span class="s1">// Use the canonical URL to request the segment, not the original URL. These</span><span class="s3">\n  </span><span class="s1">// are usually the same, but the canonical URL will be different if the route</span><span class="s3">\n  </span><span class="s1">// tree response was redirected. To avoid an extra waterfall on every segment</span><span class="s3">\n  </span><span class="s1">// request, we pass the redirected URL instead of the original one.</span><span class="s3">\n  </span><span class="s1">const url = new URL(route.canonicalUrl, routeKey.href)</span><span class="s3">\n  </span><span class="s1">const nextUrl = routeKey.nextUrl</span><span class="s3">\n\n  </span><span class="s1">const requestKey = tree.requestKey</span><span class="s3">\n  </span><span class="s1">const normalizedRequestKey =</span><span class="s3">\n    </span><span class="s1">requestKey === ROOT_SEGMENT_REQUEST_KEY</span><span class="s3">\n      </span><span class="s1">? // The root segment is a special case. To simplify the server-side</span><span class="s3">\n        </span><span class="s1">// handling of these requests, we encode the root segment path as</span><span class="s3">\n        </span><span class="s1">// `_index` instead of as an empty string. This should be treated as</span><span class="s3">\n        </span><span class="s1">// an implementation detail and not as a stable part of the protocol.</span><span class="s3">\n        </span><span class="s1">// It just needs to match the equivalent logic that happens when</span><span class="s3">\n        </span><span class="s1">// prerendering the responses. It should not leak outside of Next.js.</span><span class="s3">\n        </span><span class="s1">('/_index' as SegmentRequestKey)</span><span class="s3">\n      </span><span class="s1">: requestKey</span><span class="s3">\n\n  </span><span class="s1">const headers: RequestHeaders = {</span><span class="s3">\n    </span><span class="s1">[RSC_HEADER]: '1',</span><span class="s3">\n    </span><span class="s1">[NEXT_ROUTER_PREFETCH_HEADER]: '1',</span><span class="s3">\n    </span><span class="s1">[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (nextUrl !== null) {</span><span class="s3">\n    </span><span class="s1">headers[NEXT_URL] = nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const requestUrl = isOutputExportMode</span><span class="s3">\n    </span><span class="s1">? // In output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot; </span><span class="s1">mode, we need to add the segment path to the URL.</span><span class="s3">\n      </span><span class="s1">addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)</span><span class="s3">\n    </span><span class="s1">: url</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const response = await fetchPrefetchResponse(requestUrl, headers)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!response ||</span><span class="s3">\n      </span><span class="s1">!response.ok ||</span><span class="s3">\n      </span><span class="s1">response.status === 204 || // Cache miss</span><span class="s3">\n      </span><span class="s1">// This checks whether the response was served from the per-segment cache,</span><span class="s3">\n      </span><span class="s1">// rather than the old prefetching flow. If it fails, it implies that PPR</span><span class="s3">\n      </span><span class="s1">// is disabled on this route. Theoretically this should never happen</span><span class="s3">\n      </span><span class="s1">// because we only issue requests for segments once we've verified that</span><span class="s3">\n      </span><span class="s1">// the route supports PPR.</span><span class="s3">\n      </span><span class="s1">(response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// In output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot; </span><span class="s1">mode, we can't rely on response headers. But if</span><span class="s3">\n        </span><span class="s1">// we receive a well-formed response, we can assume it's a static</span><span class="s3">\n        </span><span class="s1">// response, because all data is static in this mode.</span><span class="s3">\n        </span><span class="s1">!isOutputExportMode) ||</span><span class="s3">\n      </span><span class="s1">!response.body</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Server responded with an error, or with a miss. We should still cache</span><span class="s3">\n      </span><span class="s1">// the response, but we can try again after 10 seconds.</span><span class="s3">\n      </span><span class="s1">rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Track when the network connection closes.</span><span class="s3">\n    </span><span class="s1">const closed = createPromiseWithResolvers&lt;void&gt;()</span><span class="s3">\n\n    </span><span class="s1">// Wrap the original stream in a new stream that never closes. That way the</span><span class="s3">\n    </span><span class="s1">// Flight client doesn't error if there's a hanging promise.</span><span class="s3">\n    </span><span class="s1">const prefetchStream = createPrefetchResponseStream(</span><span class="s3">\n      </span><span class="s1">response.body,</span><span class="s3">\n      </span><span class="s1">closed.resolve,</span><span class="s3">\n      </span><span class="s1">function onResponseSizeUpdate(size) {</span><span class="s3">\n        </span><span class="s1">segmentCacheLru.updateSize(segmentCacheEntry, size)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const serverData = await (createFromNextReadableStream(</span><span class="s3">\n      </span><span class="s1">prefetchStream</span><span class="s3">\n    </span><span class="s1">) as Promise&lt;SegmentPrefetch&gt;)</span><span class="s3">\n    </span><span class="s1">if (serverData.buildId !== getAppBuildId()) {</span><span class="s3">\n      </span><span class="s1">// The server build does not match the client. Treat as a 404. During</span><span class="s3">\n      </span><span class="s1">// an actual navigation, the router will trigger an MPA navigation.</span><span class="s3">\n      </span><span class="s1">// TODO: Consider moving the build ID to a response header so we can check</span><span class="s3">\n      </span><span class="s1">// it before decoding the response, and so there's one way of checking</span><span class="s3">\n      </span><span class="s1">// across all response types.</span><span class="s3">\n      </span><span class="s1">rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">value: fulfillSegmentCacheEntry(</span><span class="s3">\n        </span><span class="s1">segmentCacheEntry,</span><span class="s3">\n        </span><span class="s1">serverData.rsc,</span><span class="s3">\n        </span><span class="s1">serverData.loading,</span><span class="s3">\n        </span><span class="s1">// TODO: The server does not currently provide per-segment stale time.</span><span class="s3">\n        </span><span class="s1">// So we use the stale time of the route.</span><span class="s3">\n        </span><span class="s1">route.staleAt,</span><span class="s3">\n        </span><span class="s1">serverData.isPartial</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// Return a promise that resolves when the network connection closes, so</span><span class="s3">\n      </span><span class="s1">// the scheduler can track the number of concurrent network connections.</span><span class="s3">\n      </span><span class="s1">closed: closed.promise,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Either the connection itself failed, or something bad happened while</span><span class="s3">\n    </span><span class="s1">// decoding the response.</span><span class="s3">\n    </span><span class="s1">rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function fetchSegmentPrefetchesUsingDynamicRequest(</span><span class="s3">\n  </span><span class="s1">task: PrefetchTask,</span><span class="s3">\n  </span><span class="s1">route: FulfilledRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">fetchStrategy:</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.LoadingBoundary</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.PPRRuntime</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.Full,</span><span class="s3">\n  </span><span class="s1">dynamicRequestTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">spawnedEntries: Map&lt;SegmentCacheKey, PendingSegmentCacheEntry&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;PrefetchSubtaskResult&lt;null&gt; | null&gt; {</span><span class="s3">\n  </span><span class="s1">const url = new URL(route.canonicalUrl, task.key.href)</span><span class="s3">\n  </span><span class="s1">const nextUrl = task.key.nextUrl</span><span class="s3">\n  </span><span class="s1">const headers: RequestHeaders = {</span><span class="s3">\n    </span><span class="s1">[RSC_HEADER]: '1',</span><span class="s3">\n    </span><span class="s1">[NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(</span><span class="s3">\n      </span><span class="s1">JSON.stringify(dynamicRequestTree)</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (nextUrl !== null) {</span><span class="s3">\n    </span><span class="s1">headers[NEXT_URL] = nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">switch (fetchStrategy) {</span><span class="s3">\n    </span><span class="s1">case FetchStrategy.Full: {</span><span class="s3">\n      </span><span class="s1">// We omit the prefetch header from a full prefetch because it's essentially</span><span class="s3">\n      </span><span class="s1">// just a navigation request that happens ahead of time — it should include</span><span class="s3">\n      </span><span class="s1">// all the same data in the response.</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case FetchStrategy.PPRRuntime: {</span><span class="s3">\n      </span><span class="s1">headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case FetchStrategy.LoadingBoundary: {</span><span class="s3">\n      </span><span class="s1">headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">default: {</span><span class="s3">\n      </span><span class="s1">fetchStrategy satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const response = await fetchPrefetchResponse(url, headers)</span><span class="s3">\n    </span><span class="s1">if (!response || !response.ok || !response.body) {</span><span class="s3">\n      </span><span class="s1">// Server responded with an error, or with a miss. We should still cache</span><span class="s3">\n      </span><span class="s1">// the response, but we can try again after 10 seconds.</span><span class="s3">\n      </span><span class="s1">rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const renderedSearch = getRenderedSearch(response)</span><span class="s3">\n    </span><span class="s1">if (renderedSearch !== route.renderedSearch) {</span><span class="s3">\n      </span><span class="s1">// The search params that were used to render the target page are</span><span class="s3">\n      </span><span class="s1">// different from the search params in the request URL. This only happens</span><span class="s3">\n      </span><span class="s1">// when there's a dynamic rewrite in between the tree prefetch and the</span><span class="s3">\n      </span><span class="s1">// data prefetch.</span><span class="s3">\n      </span><span class="s1">// TODO: For now, since this is an edge case, we reject the prefetch, but</span><span class="s3">\n      </span><span class="s1">// the proper way to handle this is to evict the stale route tree entry</span><span class="s3">\n      </span><span class="s1">// then fill the cache with the new response.</span><span class="s3">\n      </span><span class="s1">rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Track when the network connection closes.</span><span class="s3">\n    </span><span class="s1">const closed = createPromiseWithResolvers&lt;void&gt;()</span><span class="s3">\n\n    </span><span class="s1">let fulfilledEntries: Array&lt;FulfilledSegmentCacheEntry&gt; | null = null</span><span class="s3">\n    </span><span class="s1">const prefetchStream = createPrefetchResponseStream(</span><span class="s3">\n      </span><span class="s1">response.body,</span><span class="s3">\n      </span><span class="s1">closed.resolve,</span><span class="s3">\n      </span><span class="s1">function onResponseSizeUpdate(totalBytesReceivedSoFar) {</span><span class="s3">\n        </span><span class="s1">// When processing a dynamic response, we don't know how large each</span><span class="s3">\n        </span><span class="s1">// individual segment is, so approximate by assiging each segment</span><span class="s3">\n        </span><span class="s1">// the average of the total response size.</span><span class="s3">\n        </span><span class="s1">if (fulfilledEntries === null) {</span><span class="s3">\n          </span><span class="s1">// Haven't received enough data yet to know which segments</span><span class="s3">\n          </span><span class="s1">// were included.</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length</span><span class="s3">\n        </span><span class="s1">for (const entry of fulfilledEntries) {</span><span class="s3">\n          </span><span class="s1">segmentCacheLru.updateSize(entry, averageSize)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const serverData = await (createFromNextReadableStream(</span><span class="s3">\n      </span><span class="s1">prefetchStream</span><span class="s3">\n    </span><span class="s1">) as Promise&lt;NavigationFlightResponse&gt;)</span><span class="s3">\n\n    </span><span class="s1">const isResponsePartial =</span><span class="s3">\n      </span><span class="s1">fetchStrategy === FetchStrategy.PPRRuntime</span><span class="s3">\n        </span><span class="s1">? // A runtime prefetch may have holes.</span><span class="s3">\n          </span><span class="s1">!!response.headers.get(NEXT_DID_POSTPONE_HEADER)</span><span class="s3">\n        </span><span class="s1">: // Full and LoadingBoundary prefetches cannot have holes.</span><span class="s3">\n          </span><span class="s1">// (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)</span><span class="s3">\n          </span><span class="s1">false</span><span class="s3">\n\n    </span><span class="s1">// Aside from writing the data into the cache, this function also returns</span><span class="s3">\n    </span><span class="s1">// the entries that were fulfilled, so we can streamingly update their sizes</span><span class="s3">\n    </span><span class="s1">// in the LRU as more data comes in.</span><span class="s3">\n    </span><span class="s1">fulfilledEntries = writeDynamicRenderResponseIntoCache(</span><span class="s3">\n      </span><span class="s1">Date.now(),</span><span class="s3">\n      </span><span class="s1">task,</span><span class="s3">\n      </span><span class="s1">fetchStrategy,</span><span class="s3">\n      </span><span class="s1">response,</span><span class="s3">\n      </span><span class="s1">serverData,</span><span class="s3">\n      </span><span class="s1">isResponsePartial,</span><span class="s3">\n      </span><span class="s1">route,</span><span class="s3">\n      </span><span class="s1">spawnedEntries</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// Return a promise that resolves when the network connection closes, so</span><span class="s3">\n    </span><span class="s1">// the scheduler can track the number of concurrent network connections.</span><span class="s3">\n    </span><span class="s1">return { value: null, closed: closed.promise }</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function writeDynamicTreeResponseIntoCache(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">task: PrefetchTask,</span><span class="s3">\n  </span><span class="s1">fetchStrategy:</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.LoadingBoundary</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.PPRRuntime</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.Full,</span><span class="s3">\n  </span><span class="s1">response: RSCResponse,</span><span class="s3">\n  </span><span class="s1">serverData: NavigationFlightResponse,</span><span class="s3">\n  </span><span class="s1">entry: PendingRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">couldBeIntercepted: boolean,</span><span class="s3">\n  </span><span class="s1">canonicalUrl: string,</span><span class="s3">\n  </span><span class="s1">routeIsPPREnabled: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Get the URL that was used to render the target page. This may be different</span><span class="s3">\n  </span><span class="s1">// from the URL in the request URL, if the page was rewritten.</span><span class="s3">\n  </span><span class="s1">const renderedSearch = getRenderedSearch(response)</span><span class="s3">\n\n  </span><span class="s1">const normalizedFlightDataResult = normalizeFlightData(serverData.f)</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// A string result means navigating to this route will result in an</span><span class="s3">\n    </span><span class="s1">// MPA navigation.</span><span class="s3">\n    </span><span class="s1">typeof normalizedFlightDataResult === 'string' ||</span><span class="s3">\n    </span><span class="s1">normalizedFlightDataResult.length !== 1</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">rejectRouteCacheEntry(entry, now + 10 * 1000)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const flightData = normalizedFlightDataResult[0]</span><span class="s3">\n  </span><span class="s1">if (!flightData.isRootRender) {</span><span class="s3">\n    </span><span class="s1">// Unexpected response format.</span><span class="s3">\n    </span><span class="s1">rejectRouteCacheEntry(entry, now + 10 * 1000)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const flightRouterState = flightData.tree</span><span class="s3">\n  </span><span class="s1">// TODO: Extract to function</span><span class="s3">\n  </span><span class="s1">const staleTimeHeaderSeconds = response.headers.get(</span><span class="s3">\n    </span><span class="s1">NEXT_ROUTER_STALE_TIME_HEADER</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const staleTimeMs =</span><span class="s3">\n    </span><span class="s1">staleTimeHeaderSeconds !== null</span><span class="s3">\n      </span><span class="s1">? getStaleTimeMs(parseInt(staleTimeHeaderSeconds, 10))</span><span class="s3">\n      </span><span class="s1">: STATIC_STALETIME_MS</span><span class="s3">\n\n  </span><span class="s1">// If the response contains dynamic holes, then we must conservatively assume</span><span class="s3">\n  </span><span class="s1">// that any individual segment might contain dynamic holes, and also the</span><span class="s3">\n  </span><span class="s1">// head. If it did not contain dynamic holes, then we can assume every segment</span><span class="s3">\n  </span><span class="s1">// and the head is completely static.</span><span class="s3">\n  </span><span class="s1">const isResponsePartial =</span><span class="s3">\n    </span><span class="s1">response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'</span><span class="s3">\n\n  </span><span class="s1">// Since this is a dynamic response, we must conservatively assume that the</span><span class="s3">\n  </span><span class="s1">// head responded with dynamic data.</span><span class="s3">\n  </span><span class="s1">const isHeadDynamic = true</span><span class="s3">\n\n  </span><span class="s1">const fulfilledEntry = fulfillRouteCacheEntry(</span><span class="s3">\n    </span><span class="s1">entry,</span><span class="s3">\n    </span><span class="s1">convertRootFlightRouterStateToRouteTree(flightRouterState),</span><span class="s3">\n    </span><span class="s1">flightData.head,</span><span class="s3">\n    </span><span class="s1">flightData.isHeadPartial,</span><span class="s3">\n    </span><span class="s1">now + staleTimeMs,</span><span class="s3">\n    </span><span class="s1">couldBeIntercepted,</span><span class="s3">\n    </span><span class="s1">canonicalUrl,</span><span class="s3">\n    </span><span class="s1">renderedSearch,</span><span class="s3">\n    </span><span class="s1">routeIsPPREnabled,</span><span class="s3">\n    </span><span class="s1">isHeadDynamic</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// If the server sent segment data as part of the response, we should write</span><span class="s3">\n  </span><span class="s1">// it into the cache to prevent a second, redundant prefetch request.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// TODO: When `clientSegmentCache` is enabled, the server does not include</span><span class="s3">\n  </span><span class="s1">// segment data when responding to a route tree prefetch request. However,</span><span class="s3">\n  </span><span class="s1">// when `clientSegmentCache` is set to </span><span class="s3">\&quot;</span><span class="s1">client-only</span><span class="s3">\&quot;</span><span class="s1">, and PPR is enabled (or</span><span class="s3">\n  </span><span class="s1">// the page is fully static), the normal check is bypassed and the server</span><span class="s3">\n  </span><span class="s1">// responds with the full page. This is a temporary situation until we can</span><span class="s3">\n  </span><span class="s1">// remove the </span><span class="s3">\&quot;</span><span class="s1">client-only</span><span class="s3">\&quot; </span><span class="s1">option. Then, we can delete this function call.</span><span class="s3">\n  </span><span class="s1">writeDynamicRenderResponseIntoCache(</span><span class="s3">\n    </span><span class="s1">now,</span><span class="s3">\n    </span><span class="s1">task,</span><span class="s3">\n    </span><span class="s1">fetchStrategy,</span><span class="s3">\n    </span><span class="s1">response,</span><span class="s3">\n    </span><span class="s1">serverData,</span><span class="s3">\n    </span><span class="s1">isResponsePartial,</span><span class="s3">\n    </span><span class="s1">fulfilledEntry,</span><span class="s3">\n    </span><span class="s1">null</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function rejectSegmentEntriesIfStillPending(</span><span class="s3">\n  </span><span class="s1">entries: Map&lt;SegmentCacheKey, SegmentCacheEntry&gt;,</span><span class="s3">\n  </span><span class="s1">staleAt: number</span><span class="s3">\n</span><span class="s1">): Array&lt;FulfilledSegmentCacheEntry&gt; {</span><span class="s3">\n  </span><span class="s1">const fulfilledEntries = []</span><span class="s3">\n  </span><span class="s1">for (const entry of entries.values()) {</span><span class="s3">\n    </span><span class="s1">if (entry.status === EntryStatus.Pending) {</span><span class="s3">\n      </span><span class="s1">rejectSegmentCacheEntry(entry, staleAt)</span><span class="s3">\n    </span><span class="s1">} else if (entry.status === EntryStatus.Fulfilled) {</span><span class="s3">\n      </span><span class="s1">fulfilledEntries.push(entry)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return fulfilledEntries</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function writeDynamicRenderResponseIntoCache(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">task: PrefetchTask,</span><span class="s3">\n  </span><span class="s1">fetchStrategy:</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.LoadingBoundary</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.PPRRuntime</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.Full,</span><span class="s3">\n  </span><span class="s1">response: RSCResponse,</span><span class="s3">\n  </span><span class="s1">serverData: NavigationFlightResponse,</span><span class="s3">\n  </span><span class="s1">isResponsePartial: boolean,</span><span class="s3">\n  </span><span class="s1">route: FulfilledRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">spawnedEntries: Map&lt;SegmentCacheKey, PendingSegmentCacheEntry&gt; | null</span><span class="s3">\n</span><span class="s1">): Array&lt;FulfilledSegmentCacheEntry&gt; | null {</span><span class="s3">\n  </span><span class="s1">if (serverData.b !== getAppBuildId()) {</span><span class="s3">\n    </span><span class="s1">// The server build does not match the client. Treat as a 404. During</span><span class="s3">\n    </span><span class="s1">// an actual navigation, the router will trigger an MPA navigation.</span><span class="s3">\n    </span><span class="s1">// TODO: Consider moving the build ID to a response header so we can check</span><span class="s3">\n    </span><span class="s1">// it before decoding the response, and so there's one way of checking</span><span class="s3">\n    </span><span class="s1">// across all response types.</span><span class="s3">\n    </span><span class="s1">if (spawnedEntries !== null) {</span><span class="s3">\n      </span><span class="s1">rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const flightDatas = normalizeFlightData(serverData.f)</span><span class="s3">\n  </span><span class="s1">if (typeof flightDatas === 'string') {</span><span class="s3">\n    </span><span class="s1">// This means navigating to this route will result in an MPA navigation.</span><span class="s3">\n    </span><span class="s1">// TODO: We should cache this, too, so that the MPA navigation is immediate.</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const staleTimeHeaderSeconds = response.headers.get(</span><span class="s3">\n    </span><span class="s1">NEXT_ROUTER_STALE_TIME_HEADER</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const staleTimeMs =</span><span class="s3">\n    </span><span class="s1">staleTimeHeaderSeconds !== null</span><span class="s3">\n      </span><span class="s1">? getStaleTimeMs(parseInt(staleTimeHeaderSeconds, 10))</span><span class="s3">\n      </span><span class="s1">: STATIC_STALETIME_MS</span><span class="s3">\n  </span><span class="s1">const staleAt = now + staleTimeMs</span><span class="s3">\n\n  </span><span class="s1">for (const flightData of flightDatas) {</span><span class="s3">\n    </span><span class="s1">const seedData = flightData.seedData</span><span class="s3">\n    </span><span class="s1">if (seedData !== null) {</span><span class="s3">\n      </span><span class="s1">// The data sent by the server represents only a subtree of the app. We</span><span class="s3">\n      </span><span class="s1">// need to find the part of the task tree that matches the response.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// segmentPath represents the parent path of subtree. It's a repeating</span><span class="s3">\n      </span><span class="s1">// pattern of parallel route key and segment:</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">//   [string, Segment, string, Segment, string, Segment, ...]</span><span class="s3">\n      </span><span class="s1">const segmentPath = flightData.segmentPath</span><span class="s3">\n      </span><span class="s1">let requestKey = ROOT_SEGMENT_REQUEST_KEY</span><span class="s3">\n      </span><span class="s1">let cacheKey = ROOT_SEGMENT_CACHE_KEY</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; segmentPath.length; i += 2) {</span><span class="s3">\n        </span><span class="s1">const parallelRouteKey: string = segmentPath[i]</span><span class="s3">\n        </span><span class="s1">const segment: FlightRouterStateSegment = segmentPath[i + 1]</span><span class="s3">\n        </span><span class="s1">const requestKeyPart = createSegmentRequestKeyPart(segment)</span><span class="s3">\n        </span><span class="s1">requestKey = appendSegmentRequestKeyPart(</span><span class="s3">\n          </span><span class="s1">requestKey,</span><span class="s3">\n          </span><span class="s1">parallelRouteKey,</span><span class="s3">\n          </span><span class="s1">requestKeyPart</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">cacheKey = appendSegmentCacheKeyPart(</span><span class="s3">\n          </span><span class="s1">cacheKey,</span><span class="s3">\n          </span><span class="s1">parallelRouteKey,</span><span class="s3">\n          </span><span class="s1">createSegmentCacheKeyPart(requestKeyPart, segment)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">writeSeedDataIntoCache(</span><span class="s3">\n        </span><span class="s1">now,</span><span class="s3">\n        </span><span class="s1">task,</span><span class="s3">\n        </span><span class="s1">fetchStrategy,</span><span class="s3">\n        </span><span class="s1">route,</span><span class="s3">\n        </span><span class="s1">staleAt,</span><span class="s3">\n        </span><span class="s1">seedData,</span><span class="s3">\n        </span><span class="s1">isResponsePartial,</span><span class="s3">\n        </span><span class="s1">cacheKey,</span><span class="s3">\n        </span><span class="s1">requestKey,</span><span class="s3">\n        </span><span class="s1">spawnedEntries</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// During a dynamic request, the server sends back new head data for the</span><span class="s3">\n    </span><span class="s1">// page. Overwrite the existing head with the new one. Note that we're</span><span class="s3">\n    </span><span class="s1">// intentionally not taking into account whether the existing head is</span><span class="s3">\n    </span><span class="s1">// already complete, even though the incoming head might not have finished</span><span class="s3">\n    </span><span class="s1">// streaming in yet. This is to prioritize consistency of the head with</span><span class="s3">\n    </span><span class="s1">// the segment data (though it's still not a guarantee, since some of the</span><span class="s3">\n    </span><span class="s1">// segment data may be reused from a previous request).</span><span class="s3">\n    </span><span class="s1">route.head = flightData.head</span><span class="s3">\n    </span><span class="s1">route.isHeadPartial = flightData.isHeadPartial</span><span class="s3">\n    </span><span class="s1">route.TODO_isHeadDynamic = true</span><span class="s3">\n\n    </span><span class="s1">// TODO: Currently the stale time of the route tree represents the</span><span class="s3">\n    </span><span class="s1">// stale time of both the route tree *and* all the segment data. So we</span><span class="s3">\n    </span><span class="s1">// can't just overwrite this field; we have to use whichever value is</span><span class="s3">\n    </span><span class="s1">// lower. In the future, though, the plan is to track segment lifetimes</span><span class="s3">\n    </span><span class="s1">// separately from the route tree lifetime.</span><span class="s3">\n    </span><span class="s1">if (staleAt &lt; route.staleAt) {</span><span class="s3">\n      </span><span class="s1">route.staleAt = staleAt</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Any entry that's still pending was intentionally not rendered by the</span><span class="s3">\n  </span><span class="s1">// server, because it was inside the loading boundary. Mark them as rejected</span><span class="s3">\n  </span><span class="s1">// so we know not to fetch them again.</span><span class="s3">\n  </span><span class="s1">// TODO: If PPR is enabled on some routes but not others, then it's possible</span><span class="s3">\n  </span><span class="s1">// that a different page is able to do a per-segment prefetch of one of the</span><span class="s3">\n  </span><span class="s1">// segments we're marking as rejected here. We should mark on the segment</span><span class="s3">\n  </span><span class="s1">// somehow that the reason for the rejection is because of a non-PPR prefetch.</span><span class="s3">\n  </span><span class="s1">// That way a per-segment prefetch knows to disregard the rejection.</span><span class="s3">\n  </span><span class="s1">if (spawnedEntries !== null) {</span><span class="s3">\n    </span><span class="s1">const fulfilledEntries = rejectSegmentEntriesIfStillPending(</span><span class="s3">\n      </span><span class="s1">spawnedEntries,</span><span class="s3">\n      </span><span class="s1">now + 10 * 1000</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return fulfilledEntries</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function writeSeedDataIntoCache(</span><span class="s3">\n  </span><span class="s1">now: number,</span><span class="s3">\n  </span><span class="s1">task: PrefetchTask,</span><span class="s3">\n  </span><span class="s1">fetchStrategy:</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.LoadingBoundary</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.PPRRuntime</span><span class="s3">\n    </span><span class="s1">| FetchStrategy.Full,</span><span class="s3">\n  </span><span class="s1">route: FulfilledRouteCacheEntry,</span><span class="s3">\n  </span><span class="s1">staleAt: number,</span><span class="s3">\n  </span><span class="s1">seedData: CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">isResponsePartial: boolean,</span><span class="s3">\n  </span><span class="s1">cacheKey: SegmentCacheKey,</span><span class="s3">\n  </span><span class="s1">requestKey: SegmentRequestKey,</span><span class="s3">\n  </span><span class="s1">entriesOwnedByCurrentTask: Map&lt;</span><span class="s3">\n    </span><span class="s1">SegmentCacheKey,</span><span class="s3">\n    </span><span class="s1">PendingSegmentCacheEntry</span><span class="s3">\n  </span><span class="s1">&gt; | null</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// This function is used to write the result of a dynamic server request</span><span class="s3">\n  </span><span class="s1">// (CacheNodeSeedData) into the prefetch cache. It's used in cases where we</span><span class="s3">\n  </span><span class="s1">// want to treat a dynamic response as if it were static. The two examples</span><span class="s3">\n  </span><span class="s1">// where this happens are &lt;Link prefetch={true}&gt; (which implicitly opts</span><span class="s3">\n  </span><span class="s1">// dynamic data into being static) and when prefetching a PPR-disabled route</span><span class="s3">\n  </span><span class="s1">const rsc = seedData[1]</span><span class="s3">\n  </span><span class="s1">const loading = seedData[3]</span><span class="s3">\n  </span><span class="s1">const isPartial = rsc === null || isResponsePartial</span><span class="s3">\n\n  </span><span class="s1">// We should only write into cache entries that are owned by us. Or create</span><span class="s3">\n  </span><span class="s1">// a new one and write into that. We must never write over an entry that was</span><span class="s3">\n  </span><span class="s1">// created by a different task, because that causes data races.</span><span class="s3">\n  </span><span class="s1">const ownedEntry =</span><span class="s3">\n    </span><span class="s1">entriesOwnedByCurrentTask !== null</span><span class="s3">\n      </span><span class="s1">? entriesOwnedByCurrentTask.get(cacheKey)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n  </span><span class="s1">if (ownedEntry !== undefined) {</span><span class="s3">\n    </span><span class="s1">fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// There's no matching entry. Attempt to create a new one.</span><span class="s3">\n    </span><span class="s1">const possiblyNewEntry = readOrCreateSegmentCacheEntry(</span><span class="s3">\n      </span><span class="s1">now,</span><span class="s3">\n      </span><span class="s1">task,</span><span class="s3">\n      </span><span class="s1">route,</span><span class="s3">\n      </span><span class="s1">cacheKey</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (possiblyNewEntry.status === EntryStatus.Empty) {</span><span class="s3">\n      </span><span class="s1">// Confirmed this is a new entry. We can fulfill it.</span><span class="s3">\n      </span><span class="s1">const newEntry = possiblyNewEntry</span><span class="s3">\n      </span><span class="s1">fulfillSegmentCacheEntry(</span><span class="s3">\n        </span><span class="s1">upgradeToPendingSegment(newEntry, fetchStrategy),</span><span class="s3">\n        </span><span class="s1">rsc,</span><span class="s3">\n        </span><span class="s1">loading,</span><span class="s3">\n        </span><span class="s1">staleAt,</span><span class="s3">\n        </span><span class="s1">isPartial</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// There was already an entry in the cache. But we may be able to</span><span class="s3">\n      </span><span class="s1">// replace it with the new one from the server.</span><span class="s3">\n      </span><span class="s1">const newEntry = fulfillSegmentCacheEntry(</span><span class="s3">\n        </span><span class="s1">upgradeToPendingSegment(</span><span class="s3">\n          </span><span class="s1">createDetachedSegmentCacheEntry(staleAt),</span><span class="s3">\n          </span><span class="s1">fetchStrategy</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">rsc,</span><span class="s3">\n        </span><span class="s1">loading,</span><span class="s3">\n        </span><span class="s1">staleAt,</span><span class="s3">\n        </span><span class="s1">isPartial</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">upsertSegmentEntry(</span><span class="s3">\n        </span><span class="s1">now,</span><span class="s3">\n        </span><span class="s1">getSegmentKeypathForTask(task, route, cacheKey),</span><span class="s3">\n        </span><span class="s1">newEntry</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Recursively write the child data into the cache.</span><span class="s3">\n  </span><span class="s1">const seedDataChildren = seedData[2]</span><span class="s3">\n  </span><span class="s1">if (seedDataChildren !== null) {</span><span class="s3">\n    </span><span class="s1">for (const parallelRouteKey in seedDataChildren) {</span><span class="s3">\n      </span><span class="s1">const childSeedData = seedDataChildren[parallelRouteKey]</span><span class="s3">\n      </span><span class="s1">if (childSeedData !== null) {</span><span class="s3">\n        </span><span class="s1">const childSegment = childSeedData[0]</span><span class="s3">\n        </span><span class="s1">const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)</span><span class="s3">\n        </span><span class="s1">const childRequestKey = appendSegmentRequestKeyPart(</span><span class="s3">\n          </span><span class="s1">requestKey,</span><span class="s3">\n          </span><span class="s1">parallelRouteKey,</span><span class="s3">\n          </span><span class="s1">childRequestKeyPart</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">const childCacheKey = appendSegmentCacheKeyPart(</span><span class="s3">\n          </span><span class="s1">cacheKey,</span><span class="s3">\n          </span><span class="s1">parallelRouteKey,</span><span class="s3">\n          </span><span class="s1">createSegmentCacheKeyPart(childRequestKeyPart, childSegment)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">writeSeedDataIntoCache(</span><span class="s3">\n          </span><span class="s1">now,</span><span class="s3">\n          </span><span class="s1">task,</span><span class="s3">\n          </span><span class="s1">fetchStrategy,</span><span class="s3">\n          </span><span class="s1">route,</span><span class="s3">\n          </span><span class="s1">staleAt,</span><span class="s3">\n          </span><span class="s1">childSeedData,</span><span class="s3">\n          </span><span class="s1">isResponsePartial,</span><span class="s3">\n          </span><span class="s1">childCacheKey,</span><span class="s3">\n          </span><span class="s1">childRequestKey,</span><span class="s3">\n          </span><span class="s1">entriesOwnedByCurrentTask</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function fetchPrefetchResponse(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">headers: RequestHeaders</span><span class="s3">\n</span><span class="s1">): Promise&lt;RSCResponse | null&gt; {</span><span class="s3">\n  </span><span class="s1">const fetchPriority = 'low'</span><span class="s3">\n  </span><span class="s1">const response = await createFetch(url, headers, fetchPriority)</span><span class="s3">\n  </span><span class="s1">if (!response.ok) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check the content type</span><span class="s3">\n  </span><span class="s1">if (isOutputExportMode) {</span><span class="s3">\n    </span><span class="s1">// In output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot; </span><span class="s1">mode, we relaxed about the content type, since it's</span><span class="s3">\n    </span><span class="s1">// not Next.js that's serving the response. If the status is OK, assume the</span><span class="s3">\n    </span><span class="s1">// response is valid. If it's not a valid response, the Flight client won't</span><span class="s3">\n    </span><span class="s1">// be able to decode it, and we'll treat it as a miss.</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const contentType = response.headers.get('content-type')</span><span class="s3">\n    </span><span class="s1">const isFlightResponse =</span><span class="s3">\n      </span><span class="s1">contentType &amp;&amp; contentType.startsWith(RSC_CONTENT_TYPE_HEADER)</span><span class="s3">\n    </span><span class="s1">if (!isFlightResponse) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return response</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPrefetchResponseStream(</span><span class="s3">\n  </span><span class="s1">originalFlightStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">onStreamClose: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">onResponseSizeUpdate: (size: number) =&gt; void</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">// When PPR is enabled, prefetch streams may contain references that never</span><span class="s3">\n  </span><span class="s1">// resolve, because that's how we encode dynamic data access. In the decoded</span><span class="s3">\n  </span><span class="s1">// object returned by the Flight client, these are reified into hanging</span><span class="s3">\n  </span><span class="s1">// promises that suspend during render, which is effectively what we want.</span><span class="s3">\n  </span><span class="s1">// The UI resolves when it switches to the dynamic data stream</span><span class="s3">\n  </span><span class="s1">// (via useDeferredValue(dynamic, static)).</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// However, the Flight implementation currently errors if the server closes</span><span class="s3">\n  </span><span class="s1">// the response before all the references are resolved. As a cheat to work</span><span class="s3">\n  </span><span class="s1">// around this, we wrap the original stream in a new stream that never closes,</span><span class="s3">\n  </span><span class="s1">// and therefore doesn't error.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// While processing the original stream, we also incrementally update the size</span><span class="s3">\n  </span><span class="s1">// of the cache entry in the LRU.</span><span class="s3">\n  </span><span class="s1">let totalByteLength = 0</span><span class="s3">\n  </span><span class="s1">const reader = originalFlightStream.getReader()</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">async pull(controller) {</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n        </span><span class="s1">if (!done) {</span><span class="s3">\n          </span><span class="s1">// Pass to the target stream and keep consuming the Flight response</span><span class="s3">\n          </span><span class="s1">// from the server.</span><span class="s3">\n          </span><span class="s1">controller.enqueue(value)</span><span class="s3">\n\n          </span><span class="s1">// Incrementally update the size of the cache entry in the LRU.</span><span class="s3">\n          </span><span class="s1">// NOTE: Since prefetch responses are delivered in a single chunk,</span><span class="s3">\n          </span><span class="s1">// it's not really necessary to do this streamingly, but I'm doing it</span><span class="s3">\n          </span><span class="s1">// anyway in case this changes in the future.</span><span class="s3">\n          </span><span class="s1">totalByteLength += value.byteLength</span><span class="s3">\n          </span><span class="s1">onResponseSizeUpdate(totalByteLength)</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The server stream has closed. Exit, but intentionally do not close</span><span class="s3">\n        </span><span class="s1">// the target stream. We do notify the caller, though.</span><span class="s3">\n        </span><span class="s1">onStreamClose()</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addSegmentPathToUrlInOutputExportMode(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">segmentPath: SegmentRequestKey</span><span class="s3">\n</span><span class="s1">): URL {</span><span class="s3">\n  </span><span class="s1">if (isOutputExportMode) {</span><span class="s3">\n    </span><span class="s1">// In output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot; </span><span class="s1">mode, we cannot use a header to encode the segment</span><span class="s3">\n    </span><span class="s1">// path. Instead, we append it to the end of the pathname.</span><span class="s3">\n    </span><span class="s1">const staticUrl = new URL(url)</span><span class="s3">\n    </span><span class="s1">const routeDir = staticUrl.pathname.endsWith('/')</span><span class="s3">\n      </span><span class="s1">? staticUrl.pathname.substring(0, -1)</span><span class="s3">\n      </span><span class="s1">: staticUrl.pathname</span><span class="s3">\n    </span><span class="s1">const staticExportFilename =</span><span class="s3">\n      </span><span class="s1">convertSegmentPathToStaticExportFilename(segmentPath)</span><span class="s3">\n    </span><span class="s1">staticUrl.pathname = `${routeDir}/${staticExportFilename}`</span><span class="s3">\n    </span><span class="s1">return staticUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return url</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks whether the new fetch strategy is likely to provide more content than the old one.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Generally, when an app uses dynamic data, a </span><span class="s3">\&quot;</span><span class="s1">more specific</span><span class="s3">\&quot; </span><span class="s1">fetch strategy is expected to provide more content:</span><span class="s3">\n </span><span class="s1">* - `LoadingBoundary` only provides static layouts</span><span class="s3">\n </span><span class="s1">* - `PPR` can provide shells for each segment (even for segments that use dynamic data)</span><span class="s3">\n </span><span class="s1">* - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies</span><span class="s3">\n </span><span class="s1">* - `Full` includes all the content, even if it uses dynamic data</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* However, it's possible that a more specific fetch strategy *won't* give us more content if:</span><span class="s3">\n </span><span class="s1">* - a segment is fully static</span><span class="s3">\n </span><span class="s1">*   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)</span><span class="s3">\n </span><span class="s1">* - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`</span><span class="s3">\n </span><span class="s1">*   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)</span><span class="s3">\n </span><span class="s1">* Because of this, when comparing two segments, we should also check if the existing segment is partial.</span><span class="s3">\n </span><span class="s1">* If it's not partial, then there's no need to prefetch it again, even using a </span><span class="s3">\&quot;</span><span class="s1">more specific</span><span class="s3">\&quot; </span><span class="s1">strategy.</span><span class="s3">\n </span><span class="s1">* There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,</span><span class="s3">\n </span><span class="s1">* because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function canNewFetchStrategyProvideMoreContent(</span><span class="s3">\n  </span><span class="s1">currentStrategy: FetchStrategy,</span><span class="s3">\n  </span><span class="s1">newStrategy: FetchStrategy</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return currentStrategy &lt; newStrategy</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;EntryStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;canNewFetchStrategyProvideMoreContent&quot;</span><span class="s0">,</span><span class="s1">&quot;convertRouteTreeToFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;createDetachedSegmentCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchRouteOnCacheMiss&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchSegmentOnCacheMiss&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchSegmentPrefetchesUsingDynamicRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentCacheVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;getSegmentKeypathForTask&quot;</span><span class="s0">,</span><span class="s1">&quot;pingInvalidationListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;readExactRouteCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;readOrCreateRevalidatingSegmentEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;readOrCreateRouteCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;readOrCreateSegmentCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;readRouteCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;readSegmentCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;requestOptimisticRouteCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;resetRevalidatingSegmentEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateEntireCache&quot;</span><span class="s0">,</span><span class="s1">&quot;upgradeToPendingSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;upsertSegmentEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;waitForSegmentCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isOutputExportMode&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CONFIG_OUTPUT&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaleTimeMs&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTimeSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;routeCacheMap&quot;</span><span class="s0">,</span><span class="s1">&quot;createTupleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;maxRouteLruSize&quot;</span><span class="s0">,</span><span class="s1">&quot;routeCacheLru&quot;</span><span class="s0">,</span><span class="s1">&quot;createLRU&quot;</span><span class="s0">,</span><span class="s1">&quot;onRouteLRUEviction&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentCacheMap&quot;</span><span class="s0">,</span><span class="s1">&quot;maxSegmentLruSize&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentCacheLru&quot;</span><span class="s0">,</span><span class="s1">&quot;onSegmentLRUEviction&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidationListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;currentCacheVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;pingVisibleLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;attachInvalidationListener&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;onInvalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;notifyInvalidationListener&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;reportError&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;tasks&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchTaskDirty&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;keypath&quot;</span><span class="s0">,</span><span class="s1">&quot;existingEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;staleAt&quot;</span><span class="s0">,</span><span class="s1">&quot;put&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteRouteFromCache&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;nonInterceptedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicTask&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;Full&quot;</span><span class="s0">,</span><span class="s1">&quot;PPRRuntime&quot;</span><span class="s0">,</span><span class="s1">&quot;isPPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;renderedSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;readExactSegmentCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;entryWithSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;entryWithoutSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatingEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidating&quot;</span><span class="s0">,</span><span class="s1">&quot;upsertedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteSegmentFromCache&quot;</span><span class="s0">,</span><span class="s1">&quot;readRevalidatingSegmentCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;owner&quot;</span><span class="s0">,</span><span class="s1">&quot;existingRevalidation&quot;</span><span class="s0">,</span><span class="s1">&quot;clearRevalidatingSegmentFromOwner&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;promiseWithResolvers&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;createPromiseWithResolvers&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;blockedTasks&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;isHeadPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;Infinity&quot;</span><span class="s0">,</span><span class="s1">&quot;TODO_metadataStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;TODO_isHeadDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;prev&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;requestedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;requestedSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;routeWithNoSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchRequestKey&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrlForRouteWithNoSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;optimisticCanonicalSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;optimisticRenderedSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;optimisticUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;optimisticCanonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;optimisticEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;prevEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;candidateEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;rejectedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;emptyEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;PPR&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;pingBlockedTasks&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelEntryListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatingSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;pingPrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;fulfillRouteCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isHeadDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;fulfilledEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;fulfillSegmentCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;rejectRouteCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;rejectSegmentCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;convertRootTreePrefetchToRouteTree&quot;</span><span class="s0">,</span><span class="s1">&quot;rootTree&quot;</span><span class="s0">,</span><span class="s1">&quot;renderedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameParts&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;rootSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;ROOT_SEGMENT_CACHE_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;convertTreePrefetchToRouteTree&quot;</span><span class="s0">,</span><span class="s1">&quot;ROOT_SEGMENT_REQUEST_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;requestKey&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnamePartsIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;slots&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;childPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;childParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;childParamType&quot;</span><span class="s0">,</span><span class="s1">&quot;paramType&quot;</span><span class="s0">,</span><span class="s1">&quot;childServerSentParamKey&quot;</span><span class="s0">,</span><span class="s1">&quot;paramKey&quot;</span><span class="s0">,</span><span class="s1">&quot;childDoesAppearInURL&quot;</span><span class="s0">,</span><span class="s1">&quot;childParam&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;childParamValue&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDynamicParamFromURLPart&quot;</span><span class="s0">,</span><span class="s1">&quot;childParamKey&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheKeyForDynamicParam&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;doesStaticSegmentAppearInURL&quot;</span><span class="s0">,</span><span class="s1">&quot;childPathnamePartsIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;childRequestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;createSegmentRequestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;childRequestKey&quot;</span><span class="s0">,</span><span class="s1">&quot;appendSegmentRequestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;childCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;appendSegmentCacheKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;createSegmentCacheKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;HasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentHasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;convertRootFlightRouterStateToRouteTree&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;convertFlightRouterStateToRouteTree&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;childRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;childTree&quot;</span><span class="s0">,</span><span class="s1">&quot;originalSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;paramCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;paramValue&quot;</span><span class="s0">,</span><span class="s1">&quot;getParamValueFromCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;SubtreeHasNoLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;routeTree&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_SEGMENT_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;urlAfterRedirects&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;Range&quot;</span><span class="s0">,</span><span class="s1">&quot;DOC_PREFETCH_RANGE_HEADER_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;partialHtml&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;doesExportedHtmlMatchBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;redirected&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchPrefetchResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;addSegmentPathToUrlInOutputExportMode&quot;</span><span class="s0">,</span><span class="s1">&quot;ok&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;varyHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;closed&quot;</span><span class="s0">,</span><span class="s1">&quot;routeIsPPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DID_POSTPONE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchStream&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchResponseStream&quot;</span><span class="s0">,</span><span class="s1">&quot;onResponseSizeUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;updateSize&quot;</span><span class="s0">,</span><span class="s1">&quot;serverData&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromNextReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderedSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTimeMs&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;writeDynamicTreeResponseIntoCache&quot;</span><span class="s0">,</span><span class="s1">&quot;LoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;currentKeypath&quot;</span><span class="s0">,</span><span class="s1">&quot;expectedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;newKeypath&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedRequestKey&quot;</span><span class="s0">,</span><span class="s1">&quot;requestUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequestTree&quot;</span><span class="s0">,</span><span class="s1">&quot;spawnedEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;rejectSegmentEntriesIfStillPending&quot;</span><span class="s0">,</span><span class="s1">&quot;fulfilledEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;totalBytesReceivedSoFar&quot;</span><span class="s0">,</span><span class="s1">&quot;averageSize&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isResponsePartial&quot;</span><span class="s0">,</span><span class="s1">&quot;writeDynamicRenderResponseIntoCache&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightDataResult&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTimeHeaderSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STALE_TIME_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_STALETIME_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;flightDatas&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;requestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;writeSeedDataIntoCache&quot;</span><span class="s0">,</span><span class="s1">&quot;entriesOwnedByCurrentTask&quot;</span><span class="s0">,</span><span class="s1">&quot;ownedEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;possiblyNewEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;newEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;seedDataChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;childSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchPriority&quot;</span><span class="s0">,</span><span class="s1">&quot;createFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;isFlightResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFlightStream&quot;</span><span class="s0">,</span><span class="s1">&quot;onStreamClose&quot;</span><span class="s0">,</span><span class="s1">&quot;totalByteLength&quot;</span><span class="s0">,</span><span class="s1">&quot;reader&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;pull&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;read&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;byteLength&quot;</span><span class="s0">,</span><span class="s1">&quot;staticUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;routeDir&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;staticExportFilename&quot;</span><span class="s0">,</span><span class="s1">&quot;convertSegmentPathToStaticExportFilename&quot;</span><span class="s0">,</span><span class="s1">&quot;currentStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;newStrategy&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>