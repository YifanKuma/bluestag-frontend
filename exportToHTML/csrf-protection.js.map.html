<html>
<head>
<title>csrf-protection.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
csrf-protection.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/csrf-protection.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// micromatch is only available at node runtime, so it cannot be used here since the code path that calls this function</span><span class="s3">\n</span><span class="s1">// can be run from edge. This is a simple implementation that safely achieves the required functionality.</span><span class="s3">\n</span><span class="s1">// the goal is to match the functionality for remotePatterns as defined here -</span><span class="s3">\n</span><span class="s1">// https://nextjs.org/docs/app/api-reference/components/image#remotepatterns</span><span class="s3">\n</span><span class="s1">// TODO - retrofit micromatch to work in edge and use that instead</span><span class="s3">\n</span><span class="s1">function matchWildcardDomain(domain: string, pattern: string) {</span><span class="s3">\n  </span><span class="s1">const domainParts = domain.split('.')</span><span class="s3">\n  </span><span class="s1">const patternParts = pattern.split('.')</span><span class="s3">\n\n  </span><span class="s1">if (patternParts.length &lt; 1) {</span><span class="s3">\n    </span><span class="s1">// pattern is empty and therefore invalid to match against</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (domainParts.length &lt; patternParts.length) {</span><span class="s3">\n    </span><span class="s1">// domain has too few segments and thus cannot match</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Prevent wildcards from matching entire domains (e.g. '**' or '*.com')</span><span class="s3">\n  </span><span class="s1">// This ensures wildcards can only match subdomains, not the main domain</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">patternParts.length === 1 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(patternParts[0] === '*' || patternParts[0] === '**')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (patternParts.length) {</span><span class="s3">\n    </span><span class="s1">const patternPart = patternParts.pop()</span><span class="s3">\n    </span><span class="s1">const domainPart = domainParts.pop()</span><span class="s3">\n\n    </span><span class="s1">switch (patternPart) {</span><span class="s3">\n      </span><span class="s1">case '': {</span><span class="s3">\n        </span><span class="s1">// invalid pattern. pattern segments must be non empty</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case '*': {</span><span class="s3">\n        </span><span class="s1">// wildcard matches anything so we continue if the domain part is non-empty</span><span class="s3">\n        </span><span class="s1">if (domainPart) {</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case '**': {</span><span class="s3">\n        </span><span class="s1">// if this is not the last item in the pattern the pattern is invalid</span><span class="s3">\n        </span><span class="s1">if (patternParts.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// recursive wildcard matches anything so we terminate here if the domain part is non empty</span><span class="s3">\n        </span><span class="s1">return domainPart !== undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case undefined:</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">if (domainPart !== patternPart) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We exhausted the pattern. If we also exhausted the domain we have a match</span><span class="s3">\n  </span><span class="s1">return domainParts.length === 0</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const isCsrfOriginAllowed = (</span><span class="s3">\n  </span><span class="s1">originDomain: string,</span><span class="s3">\n  </span><span class="s1">allowedOrigins: string[] = []</span><span class="s3">\n</span><span class="s1">): boolean =&gt; {</span><span class="s3">\n  </span><span class="s1">return allowedOrigins.some(</span><span class="s3">\n    </span><span class="s1">(allowedOrigin) =&gt;</span><span class="s3">\n      </span><span class="s1">allowedOrigin &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(allowedOrigin === originDomain ||</span><span class="s3">\n        </span><span class="s1">matchWildcardDomain(originDomain, allowedOrigin))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;isCsrfOriginAllowed&quot;</span><span class="s0">,</span><span class="s1">&quot;matchWildcardDomain&quot;</span><span class="s0">,</span><span class="s1">&quot;domain&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;domainParts&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;patternParts&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;patternPart&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;domainPart&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;originDomain&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedOrigins&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedOrigin&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,uHAAuH;AACvH,yGAAyG;AACzG,8EAA8E;AAC9E,4EAA4E;AAC5E,kEAAkE;;;;;+BA8DrDA;;;eAAAA;;;AA7Db,SAASC,oBAAoBC,MAAc,EAAEC,OAAe;IAC1D,MAAMC,cAAcF,OAAOG,KAAK,CAAC;IACjC,MAAMC,eAAeH,QAAQE,KAAK,CAAC;IAEnC,IAAIC,aAAaC,MAAM,GAAG,GAAG;QAC3B,0DAA0D;QAC1D,OAAO;IACT;IAEA,IAAIH,YAAYG,MAAM,GAAGD,aAAaC,MAAM,EAAE;QAC5C,oDAAoD;QACpD,OAAO;IACT;IAEA,wEAAwE;IACxE,wEAAwE;IACxE,IACED,aAAaC,MAAM,KAAK,KACvBD,CAAAA,YAAY,CAAC,EAAE,KAAK,OAAOA,YAAY,CAAC,EAAE,KAAK,IAAG,GACnD;QACA,OAAO;IACT;IAEA,MAAOA,aAAaC,MAAM,CAAE;QAC1B,MAAMC,cAAcF,aAAaG,GAAG;QACpC,MAAMC,aAAaN,YAAYK,GAAG;QAElC,OAAQD;YACN,KAAK;gBAAI;oBACP,sDAAsD;oBACtD,OAAO;gBACT;YACA,KAAK;gBAAK;oBACR,2EAA2E;oBAC3E,IAAIE,YAAY;wBACd;oBACF,OAAO;wBACL,OAAO;oBACT;gBACF;YACA,KAAK;gBAAM;oBACT,qEAAqE;oBACrE,IAAIJ,aAAaC,MAAM,GAAG,GAAG;wBAC3B,OAAO;oBACT;oBACA,2FAA2F;oBAC3F,OAAOG,eAAeC;gBACxB;YACA,KAAKA;YACL;gBAAS;oBACP,IAAID,eAAeF,aAAa;wBAC9B,OAAO;oBACT;gBACF;QACF;IACF;IAEA,4EAA4E;IAC5E,OAAOJ,YAAYG,MAAM,KAAK;AAChC;AAEO,MAAMP,sBAAsB,CACjCY,cACAC,iBAA2B,EAAE;IAE7B,OAAOA,eAAeC,IAAI,CACxB,CAACC,gBACCA,iBACCA,CAAAA,kBAAkBH,gBACjBX,oBAAoBW,cAAcG,cAAa;AAEvD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>