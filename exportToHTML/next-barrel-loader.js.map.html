<html>
<head>
<title>next-barrel-loader.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-barrel-loader.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/build/webpack/loaders/next-barrel-loader.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* ## Barrel Optimizations</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This loader is used to optimize the imports of </span><span class="s3">\&quot;</span><span class="s1">barrel</span><span class="s3">\&quot; </span><span class="s1">files that have many</span><span class="s3">\n </span><span class="s1">* re-exports. Currently, both Node.js and Webpack have to enter all of these</span><span class="s3">\n </span><span class="s1">* submodules even if we only need a few of them.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* For example, say a file `foo.js` with the following contents:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   export { a } from './a'</span><span class="s3">\n </span><span class="s1">*   export { b } from './b'</span><span class="s3">\n </span><span class="s1">*   export { c } from './c'</span><span class="s3">\n </span><span class="s1">*   ...</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the user imports `a` only, this loader will accept the `names` option to</span><span class="s3">\n </span><span class="s1">* be `['a']`. Then, it request the </span><span class="s3">\&quot;</span><span class="s1">__barrel_transform__</span><span class="s3">\&quot; </span><span class="s1">SWC transform to load</span><span class="s3">\n </span><span class="s1">* `foo.js` and receive the following output:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   export const __next_private_export_map__ = '[[</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">./a</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">],[</span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">./b</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">],[</span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">./c</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">],...]'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   format: '[</span><span class="s3">\&quot;</span><span class="s1">&lt;imported identifier&gt;</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">&lt;import path&gt;</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">&lt;exported name&gt;</span><span class="s3">\&quot;</span><span class="s1">]'</span><span class="s3">\n </span><span class="s1">*   e.g.: import { a as b } from './module-a' =&gt; '[</span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">./module-a</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">]'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The export map, generated by SWC, is a JSON that represents the exports of</span><span class="s3">\n </span><span class="s1">* that module, their original file, and their original name (since you can do</span><span class="s3">\n </span><span class="s1">* `export { a as b }`).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Then, this loader can safely remove all the exports that are not needed and</span><span class="s3">\n </span><span class="s1">* re-export the ones from `names`:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   export { a } from './a'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* That's the basic situation and also the happy path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ## Wildcard Exports</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* For wildcard exports (e.g. `export * from './a'`), it becomes a bit more complicated.</span><span class="s3">\n </span><span class="s1">* Say `foo.js` with the following contents:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   export * from './a'</span><span class="s3">\n </span><span class="s1">*   export * from './b'</span><span class="s3">\n </span><span class="s1">*   export * from './c'</span><span class="s3">\n </span><span class="s1">*   ...</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the user imports `bar` from it, SWC can never know which files are going to be</span><span class="s3">\n </span><span class="s1">* exporting `bar`. So, we have to keep all the wildcard exports and do the same</span><span class="s3">\n </span><span class="s1">* process recursively. This loader will return the following output:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   export * from '__barrel_optimize__?names=bar&amp;wildcard!=!./a'</span><span class="s3">\n </span><span class="s1">*   export * from '__barrel_optimize__?names=bar&amp;wildcard!=!./b'</span><span class="s3">\n </span><span class="s1">*   export * from '__barrel_optimize__?names=bar&amp;wildcard!=!./c'</span><span class="s3">\n </span><span class="s1">*   ...</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The </span><span class="s3">\&quot;</span><span class="s1">!=!</span><span class="s3">\&quot; </span><span class="s1">tells Webpack to use the same loader to process './a', './b', and './c'.</span><span class="s3">\n </span><span class="s1">* After the recursive process, the </span><span class="s3">\&quot;</span><span class="s1">inner loaders</span><span class="s3">\&quot; </span><span class="s1">will either return an empty string</span><span class="s3">\n </span><span class="s1">* or:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   export * from './target'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Where `target` is the file that exports `bar`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ## Non-Barrel Files</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the file is not a barrel, we can't apply any optimizations. That's because</span><span class="s3">\n </span><span class="s1">* we can't easily remove things from the file. For example, say `foo.js` with:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   const v = 1</span><span class="s3">\n </span><span class="s1">*   export function b () {</span><span class="s3">\n </span><span class="s1">*     return v</span><span class="s3">\n </span><span class="s1">*   }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the user imports `b` only, we can't remove the `const v = 1` even though</span><span class="s3">\n </span><span class="s1">* the file is side-effect free. In these caes, this loader will simply re-export</span><span class="s3">\n </span><span class="s1">* `foo.js`:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   export * from './foo'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Besides these cases, this loader also carefully handles the module cache so</span><span class="s3">\n </span><span class="s1">* SWC won't analyze the same file twice, and no instance of the same file will</span><span class="s3">\n </span><span class="s1">* be accidentally created as different instances.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type webpack from 'webpack'</span><span class="s3">\n\n</span><span class="s1">import path from 'path'</span><span class="s3">\n</span><span class="s1">import { transform } from '../../swc'</span><span class="s3">\n\n</span><span class="s1">// This is a in-memory cache for the mapping of barrel exports. This only applies</span><span class="s3">\n</span><span class="s1">// to the packages that we optimize. It will never change (e.g. upgrading packages)</span><span class="s3">\n</span><span class="s1">// during the lifetime of the server so we can safely cache it.</span><span class="s3">\n</span><span class="s1">// There is also no need to collect the cache for the same reason.</span><span class="s3">\n</span><span class="s1">const barrelTransformMappingCache = new Map&lt;</span><span class="s3">\n  </span><span class="s1">string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">exportList: [string, string, string][]</span><span class="s3">\n    </span><span class="s1">wildcardExports: string[]</span><span class="s3">\n    </span><span class="s1">isClientEntry: boolean</span><span class="s3">\n  </span><span class="s1">} | null</span><span class="s3">\n</span><span class="s1">&gt;()</span><span class="s3">\n\n</span><span class="s1">async function getBarrelMapping(</span><span class="s3">\n  </span><span class="s1">resourcePath: string,</span><span class="s3">\n  </span><span class="s1">swcCacheDir: string,</span><span class="s3">\n  </span><span class="s1">resolve: (context: string, request: string) =&gt; Promise&lt;string&gt;,</span><span class="s3">\n  </span><span class="s1">fs: {</span><span class="s3">\n    </span><span class="s1">readFile: (</span><span class="s3">\n      </span><span class="s1">path: string,</span><span class="s3">\n      </span><span class="s1">callback: (err: any, data: string | Buffer | undefined) =&gt; void</span><span class="s3">\n    </span><span class="s1">) =&gt; void</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (barrelTransformMappingCache.has(resourcePath)) {</span><span class="s3">\n    </span><span class="s1">return barrelTransformMappingCache.get(resourcePath)!</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// This is a SWC transform specifically for `optimizeBarrelExports`. We don't</span><span class="s3">\n  </span><span class="s1">// care about other things but the export map only.</span><span class="s3">\n  </span><span class="s1">async function transpileSource(</span><span class="s3">\n    </span><span class="s1">filename: string,</span><span class="s3">\n    </span><span class="s1">source: string,</span><span class="s3">\n    </span><span class="s1">isWildcard: boolean</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const isTypeScript = filename.endsWith('.ts') || filename.endsWith('.tsx')</span><span class="s3">\n    </span><span class="s1">return new Promise&lt;string&gt;((res) =&gt;</span><span class="s3">\n      </span><span class="s1">transform(source, {</span><span class="s3">\n        </span><span class="s1">filename,</span><span class="s3">\n        </span><span class="s1">inputSourceMap: undefined,</span><span class="s3">\n        </span><span class="s1">sourceFileName: filename,</span><span class="s3">\n        </span><span class="s1">optimizeBarrelExports: {</span><span class="s3">\n          </span><span class="s1">wildcard: isWildcard,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">jsc: {</span><span class="s3">\n          </span><span class="s1">parser: {</span><span class="s3">\n            </span><span class="s1">syntax: isTypeScript ? 'typescript' : 'ecmascript',</span><span class="s3">\n            </span><span class="s1">[isTypeScript ? 'tsx' : 'jsx']: true,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">experimental: {</span><span class="s3">\n            </span><span class="s1">cacheRoot: swcCacheDir,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">}).then((output) =&gt; {</span><span class="s3">\n        </span><span class="s1">res(output.code)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Avoid circular `export *` dependencies</span><span class="s3">\n  </span><span class="s1">const visited = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">async function getMatches(</span><span class="s3">\n    </span><span class="s1">file: string,</span><span class="s3">\n    </span><span class="s1">isWildcard: boolean,</span><span class="s3">\n    </span><span class="s1">isClientEntry: boolean</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (visited.has(file)) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visited.add(file)</span><span class="s3">\n\n    </span><span class="s1">const source = await new Promise&lt;string&gt;((res, rej) =&gt; {</span><span class="s3">\n      </span><span class="s1">fs.readFile(file, (err, data) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (err || data === undefined) {</span><span class="s3">\n          </span><span class="s1">rej(err)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">res(data.toString())</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const output = await transpileSource(file, source, isWildcard)</span><span class="s3">\n\n    </span><span class="s1">const matches = output.match(</span><span class="s3">\n      </span><span class="s1">/^([^]*)export (const|var) __next_private_export_map__ = ('[^']+'|</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">]+</span><span class="s3">\&quot;</span><span class="s1">)/</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (!matches) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const matchedDirectives = output.match(</span><span class="s3">\n      </span><span class="s1">/^([^]*)export (const|var) __next_private_directive_list__ = '([^']+)'/</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const directiveList = matchedDirectives</span><span class="s3">\n      </span><span class="s1">? JSON.parse(matchedDirectives[3])</span><span class="s3">\n      </span><span class="s1">: []</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot; </span><span class="s1">in barrel files has to be transferred to the target file.</span><span class="s3">\n    </span><span class="s1">isClientEntry = directiveList.includes('use client')</span><span class="s3">\n\n    </span><span class="s1">let exportList = JSON.parse(matches[3].slice(1, -1)) as [</span><span class="s3">\n      </span><span class="s1">string,</span><span class="s3">\n      </span><span class="s1">string,</span><span class="s3">\n      </span><span class="s1">string,</span><span class="s3">\n    </span><span class="s1">][]</span><span class="s3">\n    </span><span class="s1">const wildcardExports = [</span><span class="s3">\n      </span><span class="s1">...output.matchAll(/export </span><span class="s3">\\</span><span class="s1">* from </span><span class="s3">\&quot;</span><span class="s1">([^</span><span class="s3">\&quot;</span><span class="s1">]+)</span><span class="s3">\&quot;</span><span class="s1">/g),</span><span class="s3">\n    </span><span class="s1">].map((match) =&gt; match[1])</span><span class="s3">\n\n    </span><span class="s1">// In the wildcard case, if the value is exported from another file, we</span><span class="s3">\n    </span><span class="s1">// redirect to that file (decl[0]). Otherwise, export from the current</span><span class="s3">\n    </span><span class="s1">// file itself.</span><span class="s3">\n    </span><span class="s1">if (isWildcard) {</span><span class="s3">\n      </span><span class="s1">for (const decl of exportList) {</span><span class="s3">\n        </span><span class="s1">decl[1] = file</span><span class="s3">\n        </span><span class="s1">decl[2] = decl[0]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// This recursively handles the wildcard exports (e.g. `export * from './a'`)</span><span class="s3">\n    </span><span class="s1">if (wildcardExports.length) {</span><span class="s3">\n      </span><span class="s1">await Promise.all(</span><span class="s3">\n        </span><span class="s1">wildcardExports.map(async (req) =&gt; {</span><span class="s3">\n          </span><span class="s1">const targetPath = await resolve(</span><span class="s3">\n            </span><span class="s1">path.dirname(file),</span><span class="s3">\n            </span><span class="s1">req.replace('__barrel_optimize__?names=__PLACEHOLDER__!=!', '')</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">const targetMatches = await getMatches(</span><span class="s3">\n            </span><span class="s1">targetPath,</span><span class="s3">\n            </span><span class="s1">true,</span><span class="s3">\n            </span><span class="s1">isClientEntry</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">if (targetMatches) {</span><span class="s3">\n            </span><span class="s1">// Merge the export list</span><span class="s3">\n            </span><span class="s1">exportList = exportList.concat(targetMatches.exportList)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">exportList,</span><span class="s3">\n      </span><span class="s1">wildcardExports,</span><span class="s3">\n      </span><span class="s1">isClientEntry,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const res = await getMatches(resourcePath, false, false)</span><span class="s3">\n  </span><span class="s1">barrelTransformMappingCache.set(resourcePath, res)</span><span class="s3">\n\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const NextBarrelLoader = async function (</span><span class="s3">\n  </span><span class="s1">this: webpack.LoaderContext&lt;{</span><span class="s3">\n    </span><span class="s1">names: string[]</span><span class="s3">\n    </span><span class="s1">swcCacheDir: string</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.async()</span><span class="s3">\n  </span><span class="s1">this.cacheable(true)</span><span class="s3">\n\n  </span><span class="s1">const { names, swcCacheDir } = this.getOptions()</span><span class="s3">\n\n  </span><span class="s1">// For barrel optimizations, we always prefer the </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot; </span><span class="s1">field over the</span><span class="s3">\n  </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">main</span><span class="s3">\&quot; </span><span class="s1">field because ESM handling is more robust with better tree-shaking.</span><span class="s3">\n  </span><span class="s1">const resolve = this.getResolve({</span><span class="s3">\n    </span><span class="s1">mainFields: ['module', 'main'],</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const mapping = await getBarrelMapping(</span><span class="s3">\n    </span><span class="s1">this.resourcePath,</span><span class="s3">\n    </span><span class="s1">swcCacheDir,</span><span class="s3">\n    </span><span class="s1">resolve,</span><span class="s3">\n    </span><span class="s1">this.fs</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// `resolve` adds all sub-paths to the dependency graph. However, we already</span><span class="s3">\n  </span><span class="s1">// cached the mapping and we assume them to not change. So, we can safely</span><span class="s3">\n  </span><span class="s1">// clear the dependencies here to avoid unnecessary watchers which turned out</span><span class="s3">\n  </span><span class="s1">// to be very expensive.</span><span class="s3">\n  </span><span class="s1">this.clearDependencies()</span><span class="s3">\n\n  </span><span class="s1">if (!mapping) {</span><span class="s3">\n    </span><span class="s1">// This file isn't a barrel and we can't apply any optimizations. Let's re-export everything.</span><span class="s3">\n    </span><span class="s1">// Since this loader accepts `names` and the request is keyed with `names`, we can't simply</span><span class="s3">\n    </span><span class="s1">// return the original source here. That will create these imports with different names as</span><span class="s3">\n    </span><span class="s1">// different modules instances.</span><span class="s3">\n    </span><span class="s1">this.callback(null, `export * from ${JSON.stringify(this.resourcePath)}`)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const exportList = mapping.exportList</span><span class="s3">\n  </span><span class="s1">const isClientEntry = mapping.isClientEntry</span><span class="s3">\n  </span><span class="s1">const exportMap = new Map&lt;string, [string, string]&gt;()</span><span class="s3">\n  </span><span class="s1">for (const [name, filePath, orig] of exportList) {</span><span class="s3">\n    </span><span class="s1">exportMap.set(name, [filePath, orig])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let output = ''</span><span class="s3">\n  </span><span class="s1">let missedNames: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const name of names) {</span><span class="s3">\n    </span><span class="s1">// If the name matches</span><span class="s3">\n    </span><span class="s1">if (exportMap.has(name)) {</span><span class="s3">\n      </span><span class="s1">const decl = exportMap.get(name)!</span><span class="s3">\n\n      </span><span class="s1">if (decl[1] === '*') {</span><span class="s3">\n        </span><span class="s1">output += `</span><span class="s3">\\</span><span class="s1">nexport * as ${name} from ${JSON.stringify(decl[0])}`</span><span class="s3">\n      </span><span class="s1">} else if (decl[1] === 'default') {</span><span class="s3">\n        </span><span class="s1">output += `</span><span class="s3">\\</span><span class="s1">nexport { default as ${name} } from ${JSON.stringify(</span><span class="s3">\n          </span><span class="s1">decl[0]</span><span class="s3">\n        </span><span class="s1">)}`</span><span class="s3">\n      </span><span class="s1">} else if (decl[1] === name) {</span><span class="s3">\n        </span><span class="s1">output += `</span><span class="s3">\\</span><span class="s1">nexport { ${name} } from ${JSON.stringify(decl[0])}`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">output += `</span><span class="s3">\\</span><span class="s1">nexport { ${decl[1]} as ${name} } from ${JSON.stringify(</span><span class="s3">\n          </span><span class="s1">decl[0]</span><span class="s3">\n        </span><span class="s1">)}`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">missedNames.push(name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// These are from wildcard exports.</span><span class="s3">\n  </span><span class="s1">if (missedNames.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">for (const req of mapping.wildcardExports) {</span><span class="s3">\n      </span><span class="s1">output += `</span><span class="s3">\\</span><span class="s1">nexport * from ${JSON.stringify(</span><span class="s3">\n        </span><span class="s1">req.replace('__PLACEHOLDER__', missedNames.join(',') + '&amp;wildcard')</span><span class="s3">\n      </span><span class="s1">)}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// When it has `</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">` inherited from its barrel files, we need to</span><span class="s3">\n  </span><span class="s1">// prefix it to this target file as well.</span><span class="s3">\n  </span><span class="s1">if (isClientEntry) {</span><span class="s3">\n    </span><span class="s1">output = `</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\\</span><span class="s1">n${output}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.callback(null, output)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default NextBarrelLoader</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;barrelTransformMappingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;getBarrelMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;resourcePath&quot;</span><span class="s0">,</span><span class="s1">&quot;swcCacheDir&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;transpileSource&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;isWildcard&quot;</span><span class="s0">,</span><span class="s1">&quot;isTypeScript&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;transform&quot;</span><span class="s0">,</span><span class="s1">&quot;inputSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceFileName&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizeBarrelExports&quot;</span><span class="s0">,</span><span class="s1">&quot;wildcard&quot;</span><span class="s0">,</span><span class="s1">&quot;jsc&quot;</span><span class="s0">,</span><span class="s1">&quot;parser&quot;</span><span class="s0">,</span><span class="s1">&quot;syntax&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;output&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;visited&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;getMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;isClientEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;rej&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedDirectives&quot;</span><span class="s0">,</span><span class="s1">&quot;directiveList&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;exportList&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;wildcardExports&quot;</span><span class="s0">,</span><span class="s1">&quot;matchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;decl&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;targetPath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;dirname&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;targetMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;NextBarrelLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheable&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">,</span><span class="s1">&quot;getOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;getResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;mainFields&quot;</span><span class="s0">,</span><span class="s1">&quot;mapping&quot;</span><span class="s0">,</span><span class="s1">&quot;clearDependencies&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;exportMap&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;orig&quot;</span><span class="s0">,</span><span class="s1">&quot;missedNames&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>