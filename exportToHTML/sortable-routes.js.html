<html>
<head>
<title>sortable-routes.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sortable-routes.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* A route that can be sorted by specificity.</span>
 <span class="s0">*/ </span><span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s4">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">compareRouteSegments: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">getSegmentSpecificity: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">sortPageObjects: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">sortPages: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">sortSortableRouteObjects: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">sortSortableRoutes: </span><span class="s3">null</span>
<span class="s1">});</span>
<span class="s3">function </span><span class="s1">_export(target, all) {</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">name </span><span class="s3">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">compareRouteSegments: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">compareRouteSegments;</span>
    <span class="s1">},</span>
    <span class="s1">getSegmentSpecificity: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">getSegmentSpecificity;</span>
    <span class="s1">},</span>
    <span class="s1">sortPageObjects: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">sortPageObjects;</span>
    <span class="s1">},</span>
    <span class="s1">sortPages: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">sortPages;</span>
    <span class="s1">},</span>
    <span class="s1">sortSortableRouteObjects: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">sortSortableRouteObjects;</span>
    <span class="s1">},</span>
    <span class="s1">sortSortableRoutes: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">sortSortableRoutes;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">function </span><span class="s1">getSegmentSpecificity(segment) {</span>
    <span class="s0">// Static segments are most specific - they match exactly one path</span>
    <span class="s3">if </span><span class="s1">(!segment.includes(</span><span class="s2">'['</span><span class="s1">)) {</span>
        <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// Optional catch-all [[...param]] is least specific - matches zero or more segments</span>
    <span class="s3">if </span><span class="s1">(segment.startsWith(</span><span class="s2">'[[...'</span><span class="s1">) &amp;&amp; segment.endsWith(</span><span class="s2">']]'</span><span class="s1">)) {</span>
        <span class="s3">return </span><span class="s4">3</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// Catch-all [...param] is less specific - matches one or more segments</span>
    <span class="s3">if </span><span class="s1">(segment.startsWith(</span><span class="s2">'[...'</span><span class="s1">) &amp;&amp; segment.endsWith(</span><span class="s2">']'</span><span class="s1">)) {</span>
        <span class="s3">return </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// Regular dynamic [param] is more specific than catch-all - matches exactly one segment</span>
    <span class="s3">if </span><span class="s1">(segment.startsWith(</span><span class="s2">'['</span><span class="s1">) &amp;&amp; segment.endsWith(</span><span class="s2">']'</span><span class="s1">)) {</span>
        <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// Default to static (fallback case)</span>
    <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">compareRouteSegments(pathA, pathB) {</span>
    <span class="s0">// Split paths into segments, removing empty strings from leading/trailing slashes</span>
    <span class="s3">const </span><span class="s1">segmentsA = pathA.split(</span><span class="s2">'/'</span><span class="s1">).filter(Boolean);</span>
    <span class="s3">const </span><span class="s1">segmentsB = pathB.split(</span><span class="s2">'/'</span><span class="s1">).filter(Boolean);</span>
    <span class="s0">// Compare segment by segment up to the length of the longer path</span>
    <span class="s3">const </span><span class="s1">maxLength = Math.max(segmentsA.length, segmentsB.length);</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; maxLength; i++){</span>
        <span class="s3">const </span><span class="s1">segA = segmentsA[i] || </span><span class="s2">''</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s1">segB = segmentsB[i] || </span><span class="s2">''</span><span class="s1">;</span>
        <span class="s0">// Handle length differences: shorter routes are MORE specific</span>
        <span class="s0">// Example: &quot;/api&quot; is more specific than &quot;/api/users&quot;</span>
        <span class="s3">if </span><span class="s1">(!segA &amp;&amp; segB) </span><span class="s3">return </span><span class="s1">-</span><span class="s4">1 </span><span class="s0">// pathA is shorter, so more specific</span>
        <span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(segA &amp;&amp; !segB) </span><span class="s3">return </span><span class="s4">1 </span><span class="s0">// pathB is shorter, so more specific</span>
        <span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(!segA &amp;&amp; !segB) </span><span class="s3">return </span><span class="s4">0 </span><span class="s0">// Both paths ended, they're equal</span>
        <span class="s1">;</span>
        <span class="s0">// Compare segment specificity using our specificity scoring</span>
        <span class="s3">const </span><span class="s1">specificityA = getSegmentSpecificity(segA);</span>
        <span class="s3">const </span><span class="s1">specificityB = getSegmentSpecificity(segB);</span>
        <span class="s0">// Lower specificity number = more specific route</span>
        <span class="s0">// Example: &quot;api&quot; (0) vs &quot;[slug]&quot; (1) - &quot;api&quot; wins</span>
        <span class="s3">if </span><span class="s1">(specificityA !== specificityB) {</span>
            <span class="s3">return </span><span class="s1">specificityA - specificityB;</span>
        <span class="s1">}</span>
        <span class="s0">// If segments have same specificity, compare lexicographically for determinism</span>
        <span class="s0">// Example: &quot;[id]&quot; vs &quot;[slug]&quot; - &quot;[id]&quot; comes first alphabetically</span>
        <span class="s3">if </span><span class="s1">(segA !== segB) {</span>
            <span class="s3">return </span><span class="s1">segA.localeCompare(segB);</span>
        <span class="s1">}</span>
    <span class="s0">// Segments are identical, continue to next segment</span>
    <span class="s1">}</span>
    <span class="s0">// All segments compared equally</span>
    <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Compares two complete routes for sorting purposes.</span>
 <span class="s0">*</span>
 <span class="s0">* Routes are compared with a two-tier priority system:</span>
 <span class="s0">* 1. Primary: Compare by source path specificity</span>
 <span class="s0">* 2. Secondary: If sources are equal, compare by page path specificity</span>
 <span class="s0">*</span>
 <span class="s0">* This ensures that routes are primarily organized by their source patterns,</span>
 <span class="s0">* with page-specific variations grouped together.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">a - First route to compare</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">b - Second route to compare</span>
 <span class="s0">* </span><span class="s5">@returns </span><span class="s0">Negative if route a should come first, positive if route b should come first, 0 if equal</span>
 <span class="s0">*/ </span><span class="s3">function </span><span class="s1">compareSortableRoutes(a, b) {</span>
    <span class="s0">// First compare by source specificity - this is the primary sorting criterion</span>
    <span class="s0">// Source represents the original route pattern and takes precedence</span>
    <span class="s3">const </span><span class="s1">sourceResult = compareRouteSegments(a.sourcePage, b.sourcePage);</span>
    <span class="s3">if </span><span class="s1">(sourceResult !== </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">sourceResult;</span>
    <span class="s0">// If sources are identical, compare by page specificity as a tiebreaker</span>
    <span class="s0">// Page represents the final rendered route and provides secondary ordering</span>
    <span class="s3">return </span><span class="s1">compareRouteSegments(a.page, b.page);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">sortSortableRoutes(routes) {</span>
    <span class="s0">// Because sort is always in-place, we need to create a shallow copy to avoid</span>
    <span class="s0">// mutating the input array.</span>
    <span class="s3">return </span><span class="s1">[</span>
        <span class="s1">...routes</span>
    <span class="s1">].sort(compareSortableRoutes);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">sortPages(pages) {</span>
    <span class="s0">// Because sort is always in-place, we need to create a shallow copy to avoid</span>
    <span class="s0">// mutating the input array.</span>
    <span class="s3">return </span><span class="s1">[</span>
        <span class="s1">...pages</span>
    <span class="s1">].sort(compareRouteSegments);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">sortSortableRouteObjects(objects, getter) {</span>
    <span class="s0">// Create a SortableRoute for each object.</span>
    <span class="s3">const </span><span class="s1">routes = [];</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">object of objects){</span>
        <span class="s3">const </span><span class="s1">route = getter(object);</span>
        <span class="s1">routes.push({</span>
            <span class="s1">...route,</span>
            <span class="s1">object</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s0">// In-place sort the SortableRoutes.</span>
    <span class="s1">routes.sort(compareSortableRoutes);</span>
    <span class="s0">// Map the sorted SortableRoutes back to the original objects.</span>
    <span class="s3">return </span><span class="s1">routes.map((param)=&gt;{</span>
        <span class="s3">let </span><span class="s1">{ object } = param;</span>
        <span class="s3">return </span><span class="s1">object;</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">sortPageObjects(objects, getter) {</span>
    <span class="s3">const </span><span class="s1">indexes = {};</span>
    <span class="s3">const </span><span class="s1">pages = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; objects.length; i++){</span>
        <span class="s3">var </span><span class="s1">_indexes_page;</span>
        <span class="s3">const </span><span class="s1">object = objects[i];</span>
        <span class="s3">const </span><span class="s1">page = getter(object);</span>
        <span class="s1">((_indexes_page = indexes[page]) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _indexes_page.push(i)) || (indexes[page] = [</span>
            <span class="s1">i</span>
        <span class="s1">]);</span>
        <span class="s1">pages.add(page);</span>
    <span class="s1">}</span>
    <span class="s0">// Sort the unique pages.</span>
    <span class="s3">const </span><span class="s1">sortedPages = Array.from(pages).sort(compareRouteSegments);</span>
    <span class="s0">// Map the sorted pages back to the original objects.</span>
    <span class="s3">return </span><span class="s1">sortedPages.reduce((sortedObjects, page)=&gt;{</span>
        <span class="s0">// Add all objects for this page to the sorted array.</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">i of indexes[page]){</span>
            <span class="s1">sortedObjects.push(objects[i]);</span>
        <span class="s1">}</span>
        <span class="s0">// Return the sorted array.</span>
        <span class="s3">return </span><span class="s1">sortedObjects;</span>
    <span class="s1">}, []);</span>
<span class="s1">}</span>

<span class="s0">//# sourceMappingURL=sortable-routes.js.map</span></pre>
</body>
</html>