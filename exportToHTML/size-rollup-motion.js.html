<html>
<head>
<title>size-rollup-motion.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
size-rollup-motion.js</font>
</center></td></tr></table>
<pre><span class="s0">import</span><span class="s1">{jsxs as t,jsx as e}from</span><span class="s2">&quot;react/jsx-runtime&quot;</span><span class="s1">;</span><span class="s0">import</span><span class="s1">{createContext as n,useContext as i,useMemo as s,Fragment as o,createElement as r,useRef as a,useCallback as l,useLayoutEffect as h,useEffect as u,useInsertionEffect as c,forwardRef as d,useId as p,Component as m}from</span><span class="s2">&quot;react&quot;</span><span class="s1">;</span><span class="s0">function </span><span class="s1">f(t,e){-</span><span class="s3">1</span><span class="s1">===t.indexOf(e)&amp;&amp;t.push(e)}</span><span class="s0">function </span><span class="s1">y(t,e){</span><span class="s0">const </span><span class="s1">n=t.indexOf(e);n&gt;-</span><span class="s3">1</span><span class="s1">&amp;&amp;t.splice(n,</span><span class="s3">1</span><span class="s1">)}</span><span class="s0">const </span><span class="s1">g=(t,e,n)=&gt;n&gt;e?e:n&lt;t?t:n;</span><span class="s0">const </span><span class="s1">v={},x=t=&gt;</span><span class="s4">/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u</span><span class="s1">.test(t);</span><span class="s0">function </span><span class="s1">T(t){</span><span class="s0">return</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;</span><span class="s0">null</span><span class="s1">!==t}</span><span class="s0">const </span><span class="s1">w=t=&gt;</span><span class="s4">/^0[^.\s]+$/u</span><span class="s1">.test(t);</span><span class="s0">function </span><span class="s1">P(t){</span><span class="s0">let </span><span class="s1">e;</span><span class="s0">return</span><span class="s1">()=&gt;(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e&amp;&amp;(e=t()),e)}</span><span class="s0">const </span><span class="s1">S=t=&gt;t,b=(t,e)=&gt;n=&gt;e(t(n)),A=(...t)=&gt;t.reduce(b),E=(t,e,n)=&gt;{</span><span class="s0">const </span><span class="s1">i=e-t;</span><span class="s0">return </span><span class="s3">0</span><span class="s1">===i?</span><span class="s3">1</span><span class="s1">:(n-t)/i};</span><span class="s0">class </span><span class="s1">V{constructor(){</span><span class="s0">this</span><span class="s1">.subscriptions=[]}add(t){</span><span class="s0">return </span><span class="s1">f(</span><span class="s0">this</span><span class="s1">.subscriptions,t),()=&gt;y(</span><span class="s0">this</span><span class="s1">.subscriptions,t)}notify(t,e,n){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.subscriptions.length;</span><span class="s0">if</span><span class="s1">(i)</span><span class="s0">if</span><span class="s1">(</span><span class="s3">1</span><span class="s1">===i)</span><span class="s0">this</span><span class="s1">.subscriptions[</span><span class="s3">0</span><span class="s1">](t,e,n);</span><span class="s0">else for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">s=</span><span class="s3">0</span><span class="s1">;s&lt;i;s++){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.subscriptions[s];i&amp;&amp;i(t,e,n)}}getSize(){</span><span class="s0">return this</span><span class="s1">.subscriptions.length}clear(){</span><span class="s0">this</span><span class="s1">.subscriptions.length=</span><span class="s3">0</span><span class="s1">}}</span><span class="s0">const </span><span class="s1">M=t=&gt;</span><span class="s3">1e3</span><span class="s1">*t,C=t=&gt;t/</span><span class="s3">1e3</span><span class="s1">;</span><span class="s0">function </span><span class="s1">D(t,e){</span><span class="s0">return </span><span class="s1">e?t*(</span><span class="s3">1e3</span><span class="s1">/e):</span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">k=(t,e,n)=&gt;(((</span><span class="s3">1</span><span class="s1">-</span><span class="s3">3</span><span class="s1">*n+</span><span class="s3">3</span><span class="s1">*e)*t+(</span><span class="s3">3</span><span class="s1">*n-</span><span class="s3">6</span><span class="s1">*e))*t+</span><span class="s3">3</span><span class="s1">*e)*t;</span><span class="s0">function </span><span class="s1">R(t,e,n,i){</span><span class="s0">if</span><span class="s1">(t===e&amp;&amp;n===i)</span><span class="s0">return </span><span class="s1">S;</span><span class="s0">const </span><span class="s1">s=e=&gt;</span><span class="s0">function</span><span class="s1">(t,e,n,i,s){</span><span class="s0">let </span><span class="s1">o,r,a=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">do</span><span class="s1">{r=e+(n-e)/</span><span class="s3">2</span><span class="s1">,o=k(r,i,s)-t,o&gt;</span><span class="s3">0</span><span class="s1">?n=r:e=r}</span><span class="s0">while</span><span class="s1">(Math.abs(o)&gt;</span><span class="s3">1e-7</span><span class="s1">&amp;&amp;++a&lt;</span><span class="s3">12</span><span class="s1">);</span><span class="s0">return </span><span class="s1">r}(e,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,t,n);</span><span class="s0">return </span><span class="s1">t=&gt;</span><span class="s3">0</span><span class="s1">===t||</span><span class="s3">1</span><span class="s1">===t?t:k(s(t),e,i)}</span><span class="s0">const </span><span class="s1">L=t=&gt;e=&gt;e&lt;=</span><span class="s3">.5</span><span class="s1">?t(</span><span class="s3">2</span><span class="s1">*e)/</span><span class="s3">2</span><span class="s1">:(</span><span class="s3">2</span><span class="s1">-t(</span><span class="s3">2</span><span class="s1">*(</span><span class="s3">1</span><span class="s1">-e)))/</span><span class="s3">2</span><span class="s1">,j=t=&gt;e=&gt;</span><span class="s3">1</span><span class="s1">-t(</span><span class="s3">1</span><span class="s1">-e),B=R(</span><span class="s3">.33</span><span class="s1">,</span><span class="s3">1.53</span><span class="s1">,</span><span class="s3">.69</span><span class="s1">,</span><span class="s3">.99</span><span class="s1">),F=j(B),O=L(F),I=t=&gt;(t*=</span><span class="s3">2</span><span class="s1">)&lt;</span><span class="s3">1</span><span class="s1">?</span><span class="s3">.5</span><span class="s1">*F(t):</span><span class="s3">.5</span><span class="s1">*(</span><span class="s3">2</span><span class="s1">-Math.pow(</span><span class="s3">2</span><span class="s1">,-</span><span class="s3">10</span><span class="s1">*(t-</span><span class="s3">1</span><span class="s1">))),U=t=&gt;</span><span class="s3">1</span><span class="s1">-Math.sin(Math.acos(t)),N=j(U),W=L(U),$=R(</span><span class="s3">.42</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">1</span><span class="s1">),Y=R(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.58</span><span class="s1">,</span><span class="s3">1</span><span class="s1">),X=R(</span><span class="s3">.42</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.58</span><span class="s1">,</span><span class="s3">1</span><span class="s1">),K=t=&gt;Array.isArray(t)&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t[</span><span class="s3">0</span><span class="s1">],z={linear:S,easeIn:$,easeInOut:X,easeOut:Y,circIn:U,circInOut:W,circOut:N,backIn:F,backInOut:O,backOut:B,anticipate:I},H=t=&gt;{</span><span class="s0">if</span><span class="s1">(K(t)){t.length;</span><span class="s0">const</span><span class="s1">[e,n,i,s]=t;</span><span class="s0">return </span><span class="s1">R(e,n,i,s)}</span><span class="s0">return</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?z[t]:t},G=n({}),q=n({strict:!</span><span class="s3">1</span><span class="s1">}),Z=n({transformPagePoint:t=&gt;t,isStatic:!</span><span class="s3">1</span><span class="s1">,reducedMotion:</span><span class="s2">&quot;never&quot;</span><span class="s1">}),_=n({});</span><span class="s0">function </span><span class="s1">J(t){</span><span class="s0">return null</span><span class="s1">!==t&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t.start}</span><span class="s0">function </span><span class="s1">Q(t){</span><span class="s0">return</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t||Array.isArray(t)}</span><span class="s0">const </span><span class="s1">tt=[</span><span class="s2">&quot;animate&quot;</span><span class="s1">,</span><span class="s2">&quot;whileInView&quot;</span><span class="s1">,</span><span class="s2">&quot;whileFocus&quot;</span><span class="s1">,</span><span class="s2">&quot;whileHover&quot;</span><span class="s1">,</span><span class="s2">&quot;whileTap&quot;</span><span class="s1">,</span><span class="s2">&quot;whileDrag&quot;</span><span class="s1">,</span><span class="s2">&quot;exit&quot;</span><span class="s1">],et=[</span><span class="s2">&quot;initial&quot;</span><span class="s1">,...tt];</span><span class="s0">function </span><span class="s1">nt(t){</span><span class="s0">return </span><span class="s1">J(t.animate)||et.some(e=&gt;Q(t[e]))}</span><span class="s0">function </span><span class="s1">it(t){</span><span class="s0">return </span><span class="s1">Boolean(nt(t)||t.variants)}</span><span class="s0">function </span><span class="s1">st(t){</span><span class="s0">const</span><span class="s1">{initial:e,animate:n}=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">if</span><span class="s1">(nt(t)){</span><span class="s0">const</span><span class="s1">{initial:e,animate:n}=t;</span><span class="s0">return</span><span class="s1">{initial:!</span><span class="s3">1</span><span class="s1">===e||Q(e)?e:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,animate:Q(n)?n:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}}</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">!==t.inherit?e:{}}(t,i(_));</span><span class="s0">return </span><span class="s1">s(()=&gt;({initial:e,animate:n}),[ot(e),ot(n)])}</span><span class="s0">function </span><span class="s1">ot(t){</span><span class="s0">return </span><span class="s1">Array.isArray(t)?t.join(</span><span class="s2">&quot; &quot;</span><span class="s1">):t}</span><span class="s0">const </span><span class="s1">rt=[</span><span class="s2">&quot;setup&quot;</span><span class="s1">,</span><span class="s2">&quot;read&quot;</span><span class="s1">,</span><span class="s2">&quot;resolveKeyframes&quot;</span><span class="s1">,</span><span class="s2">&quot;preUpdate&quot;</span><span class="s1">,</span><span class="s2">&quot;update&quot;</span><span class="s1">,</span><span class="s2">&quot;preRender&quot;</span><span class="s1">,</span><span class="s2">&quot;render&quot;</span><span class="s1">,</span><span class="s2">&quot;postRender&quot;</span><span class="s1">],at={value:</span><span class="s0">null</span><span class="s1">,addProjectionMetrics:</span><span class="s0">null</span><span class="s1">};</span><span class="s0">function </span><span class="s1">lt(t,e){</span><span class="s0">let </span><span class="s1">n=!</span><span class="s3">1</span><span class="s1">,i=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s={delta:</span><span class="s3">0</span><span class="s1">,timestamp:</span><span class="s3">0</span><span class="s1">,isProcessing:!</span><span class="s3">1</span><span class="s1">},o=()=&gt;n=!</span><span class="s3">0</span><span class="s1">,r=rt.reduce((t,n)=&gt;(t[n]=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">let </span><span class="s1">n=</span><span class="s0">new </span><span class="s1">Set,i=</span><span class="s0">new </span><span class="s1">Set,s=!</span><span class="s3">1</span><span class="s1">,o=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">new </span><span class="s1">WeakSet;</span><span class="s0">let </span><span class="s1">a={delta:</span><span class="s3">0</span><span class="s1">,timestamp:</span><span class="s3">0</span><span class="s1">,isProcessing:!</span><span class="s3">1</span><span class="s1">},l=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">function </span><span class="s1">h(e){r.has(e)&amp;&amp;(u.schedule(e),t()),l++,e(a)}</span><span class="s0">const </span><span class="s1">u={schedule:(t,e=!</span><span class="s3">1</span><span class="s1">,o=!</span><span class="s3">1</span><span class="s1">)=&gt;{</span><span class="s0">const </span><span class="s1">a=o&amp;&amp;s?n:i;</span><span class="s0">return </span><span class="s1">e&amp;&amp;r.add(t),a.has(t)||a.add(t),t},cancel:t=&gt;{i.delete(t),r.delete(t)},process:t=&gt;{a=t,s?o=!</span><span class="s3">0</span><span class="s1">:(s=!</span><span class="s3">0</span><span class="s1">,[n,i]=[i,n],n.forEach(h),e&amp;&amp;at.value&amp;&amp;at.value.frameloop[e].push(l),l=</span><span class="s3">0</span><span class="s1">,n.clear(),s=!</span><span class="s3">1</span><span class="s1">,o&amp;&amp;(o=!</span><span class="s3">1</span><span class="s1">,u.process(t)))}};</span><span class="s0">return </span><span class="s1">u}(o,e?n:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),t),{}),{setup:a,read:l,resolveKeyframes:h,preUpdate:u,update:c,preRender:d,render:p,postRender:m}=r,f=()=&gt;{</span><span class="s0">const </span><span class="s1">o=v.useManualTiming?s.timestamp:performance.now();n=!</span><span class="s3">1</span><span class="s1">,v.useManualTiming||(s.delta=i?</span><span class="s3">1e3</span><span class="s1">/</span><span class="s3">60</span><span class="s1">:Math.max(Math.min(o-s.timestamp,</span><span class="s3">40</span><span class="s1">),</span><span class="s3">1</span><span class="s1">)),s.timestamp=o,s.isProcessing=!</span><span class="s3">0</span><span class="s1">,a.process(s),l.process(s),h.process(s),u.process(s),c.process(s),d.process(s),p.process(s),m.process(s),s.isProcessing=!</span><span class="s3">1</span><span class="s1">,n&amp;&amp;e&amp;&amp;(i=!</span><span class="s3">1</span><span class="s1">,t(f))};</span><span class="s0">return</span><span class="s1">{schedule:rt.reduce((e,o)=&gt;{</span><span class="s0">const </span><span class="s1">a=r[o];</span><span class="s0">return </span><span class="s1">e[o]=(e,o=!</span><span class="s3">1</span><span class="s1">,r=!</span><span class="s3">1</span><span class="s1">)=&gt;(n||(n=!</span><span class="s3">0</span><span class="s1">,i=!</span><span class="s3">0</span><span class="s1">,s.isProcessing||t(f)),a.schedule(e,o,r)),e},{}),cancel:t=&gt;{</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;rt.length;e++)r[rt[e]].cancel(t)},state:s,steps:r}}</span><span class="s0">const</span><span class="s1">{schedule:ht,cancel:ut,state:ct,steps:dt}=lt(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">requestAnimationFrame?requestAnimationFrame:S,!</span><span class="s3">0</span><span class="s1">);</span><span class="s0">let </span><span class="s1">pt;</span><span class="s0">function </span><span class="s1">mt(){pt=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">ft={now:()=&gt;(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===pt&amp;&amp;ft.set(ct.isProcessing||v.useManualTiming?ct.timestamp:performance.now()),pt),set:t=&gt;{pt=t,queueMicrotask(mt)}},yt=t=&gt;e=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;e.startsWith(t),gt=yt(</span><span class="s2">&quot;--&quot;</span><span class="s1">),vt=yt(</span><span class="s2">&quot;var(--&quot;</span><span class="s1">),xt=t=&gt;!!vt(t)&amp;&amp;Tt.test(t.split(</span><span class="s2">&quot;/*&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].trim()),Tt=</span><span class="s4">/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu</span><span class="s1">,wt={test:t=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t,parse:parseFloat,transform:t=&gt;t},Pt={...wt,transform:t=&gt;g(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,t)},St={...wt,</span><span class="s0">default</span><span class="s1">:</span><span class="s3">1</span><span class="s1">},bt=t=&gt;Math.round(</span><span class="s3">1e5</span><span class="s1">*t)/</span><span class="s3">1e5</span><span class="s1">,At=</span><span class="s4">/-?(?:\d+(?:\.\d+)?|\.\d+)/gu</span><span class="s1">;</span><span class="s0">const </span><span class="s1">Et=</span><span class="s4">/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu</span><span class="s1">,Vt=(t,e)=&gt;n=&gt;Boolean(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n&amp;&amp;Et.test(n)&amp;&amp;n.startsWith(t)||e&amp;&amp;!</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">return null</span><span class="s1">==t}(n)&amp;&amp;Object.prototype.hasOwnProperty.call(n,e)),Mt=(t,e,n)=&gt;i=&gt;{</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">i)</span><span class="s0">return </span><span class="s1">i;</span><span class="s0">const</span><span class="s1">[s,o,r,a]=i.match(At);</span><span class="s0">return</span><span class="s1">{[t]:parseFloat(s),[e]:parseFloat(o),[n]:parseFloat(r),alpha:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==a?parseFloat(a):</span><span class="s3">1</span><span class="s1">}},Ct={...wt,transform:t=&gt;Math.round((t=&gt;g(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">255</span><span class="s1">,t))(t))},Dt={test:Vt(</span><span class="s2">&quot;rgb&quot;</span><span class="s1">,</span><span class="s2">&quot;red&quot;</span><span class="s1">),parse:Mt(</span><span class="s2">&quot;red&quot;</span><span class="s1">,</span><span class="s2">&quot;green&quot;</span><span class="s1">,</span><span class="s2">&quot;blue&quot;</span><span class="s1">),transform:({red:t,green:e,blue:n,alpha:i=</span><span class="s3">1</span><span class="s1">})=&gt;</span><span class="s2">&quot;rgba(&quot;</span><span class="s1">+Ct.transform(t)+</span><span class="s2">&quot;, &quot;</span><span class="s1">+Ct.transform(e)+</span><span class="s2">&quot;, &quot;</span><span class="s1">+Ct.transform(n)+</span><span class="s2">&quot;, &quot;</span><span class="s1">+bt(Pt.transform(i))+</span><span class="s2">&quot;)&quot;</span><span class="s1">};</span><span class="s0">const </span><span class="s1">kt={test:Vt(</span><span class="s2">&quot;#&quot;</span><span class="s1">),parse:</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">let </span><span class="s1">e=</span><span class="s2">&quot;&quot;</span><span class="s1">,n=</span><span class="s2">&quot;&quot;</span><span class="s1">,i=</span><span class="s2">&quot;&quot;</span><span class="s1">,s=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">return </span><span class="s1">t.length&gt;</span><span class="s3">5</span><span class="s1">?(e=t.substring(</span><span class="s3">1</span><span class="s1">,</span><span class="s3">3</span><span class="s1">),n=t.substring(</span><span class="s3">3</span><span class="s1">,</span><span class="s3">5</span><span class="s1">),i=t.substring(</span><span class="s3">5</span><span class="s1">,</span><span class="s3">7</span><span class="s1">),s=t.substring(</span><span class="s3">7</span><span class="s1">,</span><span class="s3">9</span><span class="s1">)):(e=t.substring(</span><span class="s3">1</span><span class="s1">,</span><span class="s3">2</span><span class="s1">),n=t.substring(</span><span class="s3">2</span><span class="s1">,</span><span class="s3">3</span><span class="s1">),i=t.substring(</span><span class="s3">3</span><span class="s1">,</span><span class="s3">4</span><span class="s1">),s=t.substring(</span><span class="s3">4</span><span class="s1">,</span><span class="s3">5</span><span class="s1">),e+=e,n+=n,i+=i,s+=s),{red:parseInt(e,</span><span class="s3">16</span><span class="s1">),green:parseInt(n,</span><span class="s3">16</span><span class="s1">),blue:parseInt(i,</span><span class="s3">16</span><span class="s1">),alpha:s?parseInt(s,</span><span class="s3">16</span><span class="s1">)/</span><span class="s3">255</span><span class="s1">:</span><span class="s3">1</span><span class="s1">}},transform:Dt.transform},Rt=t=&gt;({test:e=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;e.endsWith(t)&amp;&amp;</span><span class="s3">1</span><span class="s1">===e.split(</span><span class="s2">&quot; &quot;</span><span class="s1">).length,parse:parseFloat,transform:e=&gt;</span><span class="s2">`</span><span class="s1">${e}${t}</span><span class="s2">`</span><span class="s1">}),Lt=Rt(</span><span class="s2">&quot;deg&quot;</span><span class="s1">),jt=Rt(</span><span class="s2">&quot;%&quot;</span><span class="s1">),Bt=Rt(</span><span class="s2">&quot;px&quot;</span><span class="s1">),Ft=Rt(</span><span class="s2">&quot;vh&quot;</span><span class="s1">),Ot=Rt(</span><span class="s2">&quot;vw&quot;</span><span class="s1">),It=(()=&gt;({...jt,parse:t=&gt;jt.parse(t)/</span><span class="s3">100</span><span class="s1">,transform:t=&gt;jt.transform(</span><span class="s3">100</span><span class="s1">*t)}))(),Ut={test:Vt(</span><span class="s2">&quot;hsl&quot;</span><span class="s1">,</span><span class="s2">&quot;hue&quot;</span><span class="s1">),parse:Mt(</span><span class="s2">&quot;hue&quot;</span><span class="s1">,</span><span class="s2">&quot;saturation&quot;</span><span class="s1">,</span><span class="s2">&quot;lightness&quot;</span><span class="s1">),transform:({hue:t,saturation:e,lightness:n,alpha:i=</span><span class="s3">1</span><span class="s1">})=&gt;</span><span class="s2">&quot;hsla(&quot;</span><span class="s1">+Math.round(t)+</span><span class="s2">&quot;, &quot;</span><span class="s1">+jt.transform(bt(e))+</span><span class="s2">&quot;, &quot;</span><span class="s1">+jt.transform(bt(n))+</span><span class="s2">&quot;, &quot;</span><span class="s1">+bt(Pt.transform(i))+</span><span class="s2">&quot;)&quot;</span><span class="s1">},Nt={test:t=&gt;Dt.test(t)||kt.test(t)||Ut.test(t),parse:t=&gt;Dt.test(t)?Dt.parse(t):Ut.test(t)?Ut.parse(t):kt.parse(t),transform:t=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?t:t.hasOwnProperty(</span><span class="s2">&quot;red&quot;</span><span class="s1">)?Dt.transform(t):Ut.transform(t),getAnimatableNone:t=&gt;{</span><span class="s0">const </span><span class="s1">e=Nt.parse(t);</span><span class="s0">return </span><span class="s1">e.alpha=</span><span class="s3">0</span><span class="s1">,Nt.transform(e)}},Wt=</span><span class="s4">/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu</span><span class="s1">;</span><span class="s0">const </span><span class="s1">$t=</span><span class="s2">&quot;number&quot;</span><span class="s1">,Yt=</span><span class="s2">&quot;color&quot;</span><span class="s1">,Xt=</span><span class="s4">/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Kt(t){</span><span class="s0">const </span><span class="s1">e=t.toString(),n=[],i={color:[],number:[],</span><span class="s0">var</span><span class="s1">:[]},s=[];</span><span class="s0">let </span><span class="s1">o=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">r=e.replace(Xt,t=&gt;(Nt.test(t)?(i.color.push(o),s.push(Yt),n.push(Nt.parse(t))):t.startsWith(</span><span class="s2">&quot;var(&quot;</span><span class="s1">)?(i.var.push(o),s.push(</span><span class="s2">&quot;var&quot;</span><span class="s1">),n.push(t)):(i.number.push(o),s.push($t),n.push(parseFloat(t))),++o,</span><span class="s2">&quot;${}&quot;</span><span class="s1">)).split(</span><span class="s2">&quot;${}&quot;</span><span class="s1">);</span><span class="s0">return</span><span class="s1">{values:n,split:r,indexes:i,types:s}}</span><span class="s0">function </span><span class="s1">zt(t){</span><span class="s0">return </span><span class="s1">Kt(t).values}</span><span class="s0">function </span><span class="s1">Ht(t){</span><span class="s0">const</span><span class="s1">{split:e,types:n}=Kt(t),i=e.length;</span><span class="s0">return </span><span class="s1">t=&gt;{</span><span class="s0">let </span><span class="s1">s=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">o=</span><span class="s3">0</span><span class="s1">;o&lt;i;o++)</span><span class="s0">if</span><span class="s1">(s+=e[o],</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t[o]){</span><span class="s0">const </span><span class="s1">e=n[o];s+=e===$t?bt(t[o]):e===Yt?Nt.transform(t[o]):t[o]}</span><span class="s0">return </span><span class="s1">s}}</span><span class="s0">const </span><span class="s1">Gt=t=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?</span><span class="s3">0</span><span class="s1">:Nt.test(t)?Nt.getAnimatableNone(t):t;</span><span class="s0">const </span><span class="s1">qt={test:</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">return </span><span class="s1">isNaN(t)&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;(t.match(At)?.length||</span><span class="s3">0</span><span class="s1">)+(t.match(Wt)?.length||</span><span class="s3">0</span><span class="s1">)&gt;</span><span class="s3">0</span><span class="s1">},parse:zt,createTransformer:Ht,getAnimatableNone:</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const </span><span class="s1">e=zt(t);</span><span class="s0">return </span><span class="s1">Ht(t)(e.map(Gt))}};</span><span class="s0">function </span><span class="s1">Zt(t,e,n){</span><span class="s0">return </span><span class="s1">n&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(n+=</span><span class="s3">1</span><span class="s1">),n&gt;</span><span class="s3">1</span><span class="s1">&amp;&amp;(n-=</span><span class="s3">1</span><span class="s1">),n&lt;</span><span class="s3">1</span><span class="s1">/</span><span class="s3">6</span><span class="s1">?t+</span><span class="s3">6</span><span class="s1">*(e-t)*n:n&lt;</span><span class="s3">.5</span><span class="s1">?e:n&lt;</span><span class="s3">2</span><span class="s1">/</span><span class="s3">3</span><span class="s1">?t+(e-t)*(</span><span class="s3">2</span><span class="s1">/</span><span class="s3">3</span><span class="s1">-n)*</span><span class="s3">6</span><span class="s1">:t}</span><span class="s0">function </span><span class="s1">_t(t,e){</span><span class="s0">return </span><span class="s1">n=&gt;n&gt;</span><span class="s3">0</span><span class="s1">?e:t}</span><span class="s0">const </span><span class="s1">Jt=(t,e,n)=&gt;t+(e-t)*n,Qt=(t,e,n)=&gt;{</span><span class="s0">const </span><span class="s1">i=t*t,s=n*(e*e-i)+i;</span><span class="s0">return </span><span class="s1">s&lt;</span><span class="s3">0</span><span class="s1">?</span><span class="s3">0</span><span class="s1">:Math.sqrt(s)},te=[kt,Dt,Ut];</span><span class="s0">function </span><span class="s1">ee(t){</span><span class="s0">const </span><span class="s1">e=(n=t,te.find(t=&gt;t.test(n)));</span><span class="s0">var </span><span class="s1">n;</span><span class="s0">if</span><span class="s1">(!Boolean(e))</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">let </span><span class="s1">i=e.parse(t);</span><span class="s0">return </span><span class="s1">e===Ut&amp;&amp;(i=</span><span class="s0">function</span><span class="s1">({hue:t,saturation:e,lightness:n,alpha:i}){t/=</span><span class="s3">360</span><span class="s1">,n/=</span><span class="s3">100</span><span class="s1">;</span><span class="s0">let </span><span class="s1">s=</span><span class="s3">0</span><span class="s1">,o=</span><span class="s3">0</span><span class="s1">,r=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(e/=</span><span class="s3">100</span><span class="s1">){</span><span class="s0">const </span><span class="s1">i=n&lt;</span><span class="s3">.5</span><span class="s1">?n*(</span><span class="s3">1</span><span class="s1">+e):n+e-n*e,a=</span><span class="s3">2</span><span class="s1">*n-i;s=Zt(a,i,t+</span><span class="s3">1</span><span class="s1">/</span><span class="s3">3</span><span class="s1">),o=Zt(a,i,t),r=Zt(a,i,t-</span><span class="s3">1</span><span class="s1">/</span><span class="s3">3</span><span class="s1">)}</span><span class="s0">else </span><span class="s1">s=o=r=n;</span><span class="s0">return</span><span class="s1">{red:Math.round(</span><span class="s3">255</span><span class="s1">*s),green:Math.round(</span><span class="s3">255</span><span class="s1">*o),blue:Math.round(</span><span class="s3">255</span><span class="s1">*r),alpha:i}}(i)),i}</span><span class="s0">const </span><span class="s1">ne=(t,e)=&gt;{</span><span class="s0">const </span><span class="s1">n=ee(t),i=ee(e);</span><span class="s0">if</span><span class="s1">(!n||!i)</span><span class="s0">return </span><span class="s1">_t(t,e);</span><span class="s0">const </span><span class="s1">s={...n};</span><span class="s0">return </span><span class="s1">t=&gt;(s.red=Qt(n.red,i.red,t),s.green=Qt(n.green,i.green,t),s.blue=Qt(n.blue,i.blue,t),s.alpha=Jt(n.alpha,i.alpha,t),Dt.transform(s))},ie=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;none&quot;</span><span class="s1">,</span><span class="s2">&quot;hidden&quot;</span><span class="s1">]);</span><span class="s0">function </span><span class="s1">se(t,e){</span><span class="s0">return </span><span class="s1">n=&gt;Jt(t,e,n)}</span><span class="s0">function </span><span class="s1">oe(t){</span><span class="s0">return</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?se:</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?xt(t)?_t:Nt.test(t)?ne:le:Array.isArray(t)?re:</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?Nt.test(t)?ne:ae:_t}</span><span class="s0">function </span><span class="s1">re(t,e){</span><span class="s0">const </span><span class="s1">n=[...t],i=n.length,s=t.map((t,n)=&gt;oe(t)(t,e[n]));</span><span class="s0">return </span><span class="s1">t=&gt;{</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;i;e++)n[e]=s[e](t);</span><span class="s0">return </span><span class="s1">n}}</span><span class="s0">function </span><span class="s1">ae(t,e){</span><span class="s0">const </span><span class="s1">n={...t,...e},i={};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">s </span><span class="s0">in </span><span class="s1">n)</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t[s]&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e[s]&amp;&amp;(i[s]=oe(t[s])(t[s],e[s]));</span><span class="s0">return </span><span class="s1">t=&gt;{</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">i)n[e]=i[e](t);</span><span class="s0">return </span><span class="s1">n}}</span><span class="s0">const </span><span class="s1">le=(t,e)=&gt;{</span><span class="s0">const </span><span class="s1">n=qt.createTransformer(e),i=Kt(t),s=Kt(e);</span><span class="s0">return </span><span class="s1">i.indexes.var.length===s.indexes.var.length&amp;&amp;i.indexes.color.length===s.indexes.color.length&amp;&amp;i.indexes.number.length&gt;=s.indexes.number.length?ie.has(t)&amp;&amp;!s.values.length||ie.has(e)&amp;&amp;!i.values.length?</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">return </span><span class="s1">ie.has(t)?n=&gt;n&lt;=</span><span class="s3">0</span><span class="s1">?t:e:n=&gt;n&gt;=</span><span class="s3">1</span><span class="s1">?e:t}(t,e):A(re(</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">n=[],i={color:</span><span class="s3">0</span><span class="s1">,</span><span class="s0">var</span><span class="s1">:</span><span class="s3">0</span><span class="s1">,number:</span><span class="s3">0</span><span class="s1">};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">s=</span><span class="s3">0</span><span class="s1">;s&lt;e.values.length;s++){</span><span class="s0">const </span><span class="s1">o=e.types[s],r=t.indexes[o][i[o]],a=t.values[r]??</span><span class="s3">0</span><span class="s1">;n[s]=a,i[o]++}</span><span class="s0">return </span><span class="s1">n}(i,s),s.values),n):_t(t,e)};</span><span class="s0">function </span><span class="s1">he(t,e,n){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n)</span><span class="s0">return </span><span class="s1">Jt(t,e,n);</span><span class="s0">return </span><span class="s1">oe(t)(t,e)}</span><span class="s0">const </span><span class="s1">ue=t=&gt;{</span><span class="s0">const </span><span class="s1">e=({timestamp:e})=&gt;t(e);</span><span class="s0">return</span><span class="s1">{start:(t=!</span><span class="s3">0</span><span class="s1">)=&gt;ht.update(e,t),stop:()=&gt;ut(e),now:()=&gt;ct.isProcessing?ct.timestamp:ft.now()}},ce=(t,e,n=</span><span class="s3">10</span><span class="s1">)=&gt;{</span><span class="s0">let </span><span class="s1">i=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=Math.max(Math.round(e/n),</span><span class="s3">2</span><span class="s1">);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;s;e++)i+=Math.round(</span><span class="s3">1e4</span><span class="s1">*t(e/(s-</span><span class="s3">1</span><span class="s1">)))/</span><span class="s3">1e4</span><span class="s1">+</span><span class="s2">&quot;, &quot;</span><span class="s1">;</span><span class="s0">return</span><span class="s2">`linear(</span><span class="s1">${i.substring(</span><span class="s3">0</span><span class="s1">,i.length-</span><span class="s3">2</span><span class="s1">)}</span><span class="s2">)`</span><span class="s1">},de=</span><span class="s3">2e4</span><span class="s1">;</span><span class="s0">function </span><span class="s1">pe(t){</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">let </span><span class="s1">n=t.next(e);</span><span class="s0">for</span><span class="s1">(;!n.done&amp;&amp;e&lt;de;)e+=</span><span class="s3">50</span><span class="s1">,n=t.next(e);</span><span class="s0">return </span><span class="s1">e&gt;=de?</span><span class="s3">1</span><span class="s1">/</span><span class="s3">0</span><span class="s1">:e}</span><span class="s0">function </span><span class="s1">me(t,e,n){</span><span class="s0">const </span><span class="s1">i=Math.max(e-</span><span class="s3">5</span><span class="s1">,</span><span class="s3">0</span><span class="s1">);</span><span class="s0">return </span><span class="s1">D(n-t(i),e-i)}</span><span class="s0">const </span><span class="s1">fe=</span><span class="s3">100</span><span class="s1">,ye=</span><span class="s3">10</span><span class="s1">,ge=</span><span class="s3">1</span><span class="s1">,ve=</span><span class="s3">0</span><span class="s1">,xe=</span><span class="s3">800</span><span class="s1">,Te=</span><span class="s3">.3</span><span class="s1">,we=</span><span class="s3">.3</span><span class="s1">,Pe={granular:</span><span class="s3">.01</span><span class="s1">,</span><span class="s0">default</span><span class="s1">:</span><span class="s3">2</span><span class="s1">},Se={granular:</span><span class="s3">.005</span><span class="s1">,</span><span class="s0">default</span><span class="s1">:</span><span class="s3">.5</span><span class="s1">},be=</span><span class="s3">.01</span><span class="s1">,Ae=</span><span class="s3">10</span><span class="s1">,Ee=</span><span class="s3">.05</span><span class="s1">,Ve=</span><span class="s3">1</span><span class="s1">,Me=</span><span class="s3">.001</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Ce({duration:t=xe,bounce:e=Te,velocity:n=ve,mass:i=ge}){</span><span class="s0">let </span><span class="s1">s,o,r=</span><span class="s3">1</span><span class="s1">-e;r=g(Ee,Ve,r),t=g(be,Ae,C(t)),r&lt;</span><span class="s3">1</span><span class="s1">?(s=e=&gt;{</span><span class="s0">const </span><span class="s1">i=e*r,s=i*t,o=i-n,a=ke(e,r),l=Math.exp(-s);</span><span class="s0">return </span><span class="s1">Me-o/a*l},o=e=&gt;{</span><span class="s0">const </span><span class="s1">i=e*r*t,o=i*n+n,a=Math.pow(r,</span><span class="s3">2</span><span class="s1">)*Math.pow(e,</span><span class="s3">2</span><span class="s1">)*t,l=Math.exp(-i),h=ke(Math.pow(e,</span><span class="s3">2</span><span class="s1">),r);</span><span class="s0">return</span><span class="s1">(-s(e)+Me&gt;</span><span class="s3">0</span><span class="s1">?-</span><span class="s3">1</span><span class="s1">:</span><span class="s3">1</span><span class="s1">)*((o-a)*l)/h}):(s=e=&gt;Math.exp(-e*t)*((e-n)*t+</span><span class="s3">1</span><span class="s1">)-</span><span class="s3">.001</span><span class="s1">,o=e=&gt;Math.exp(-e*t)*(t*t*(n-e)));</span><span class="s0">const </span><span class="s1">a=</span><span class="s0">function</span><span class="s1">(t,e,n){</span><span class="s0">let </span><span class="s1">i=n;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">1</span><span class="s1">;n&lt;De;n++)i-=t(i)/e(i);</span><span class="s0">return </span><span class="s1">i}(s,o,</span><span class="s3">5</span><span class="s1">/t);</span><span class="s0">if</span><span class="s1">(t=M(t),isNaN(a))</span><span class="s0">return</span><span class="s1">{stiffness:fe,damping:ye,duration:t};{</span><span class="s0">const </span><span class="s1">e=Math.pow(a,</span><span class="s3">2</span><span class="s1">)*i;</span><span class="s0">return</span><span class="s1">{stiffness:e,damping:</span><span class="s3">2</span><span class="s1">*r*Math.sqrt(i*e),duration:t}}}</span><span class="s0">const </span><span class="s1">De=</span><span class="s3">12</span><span class="s1">;</span><span class="s0">function </span><span class="s1">ke(t,e){</span><span class="s0">return </span><span class="s1">t*Math.sqrt(</span><span class="s3">1</span><span class="s1">-e*e)}</span><span class="s0">const </span><span class="s1">Re=[</span><span class="s2">&quot;duration&quot;</span><span class="s1">,</span><span class="s2">&quot;bounce&quot;</span><span class="s1">],Le=[</span><span class="s2">&quot;stiffness&quot;</span><span class="s1">,</span><span class="s2">&quot;damping&quot;</span><span class="s1">,</span><span class="s2">&quot;mass&quot;</span><span class="s1">];</span><span class="s0">function </span><span class="s1">je(t,e){</span><span class="s0">return </span><span class="s1">e.some(e=&gt;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t[e])}</span><span class="s0">function </span><span class="s1">Be(t=we,e=Te){</span><span class="s0">const </span><span class="s1">n=</span><span class="s2">&quot;object&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t?{visualDuration:t,keyframes:[</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">],bounce:e}:t;</span><span class="s0">let</span><span class="s1">{restSpeed:i,restDelta:s}=n;</span><span class="s0">const </span><span class="s1">o=n.keyframes[</span><span class="s3">0</span><span class="s1">],r=n.keyframes[n.keyframes.length-</span><span class="s3">1</span><span class="s1">],a={done:!</span><span class="s3">1</span><span class="s1">,value:o},{stiffness:l,damping:h,mass:u,duration:c,velocity:d,isResolvedFromDuration:p}=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">let </span><span class="s1">e={velocity:ve,stiffness:fe,damping:ye,mass:ge,isResolvedFromDuration:!</span><span class="s3">1</span><span class="s1">,...t};</span><span class="s0">if</span><span class="s1">(!je(t,Le)&amp;&amp;je(t,Re))</span><span class="s0">if</span><span class="s1">(t.visualDuration){</span><span class="s0">const </span><span class="s1">n=t.visualDuration,i=</span><span class="s3">2</span><span class="s1">*Math.PI/(</span><span class="s3">1.2</span><span class="s1">*n),s=i*i,o=</span><span class="s3">2</span><span class="s1">*g(</span><span class="s3">.05</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">1</span><span class="s1">-(t.bounce||</span><span class="s3">0</span><span class="s1">))*Math.sqrt(s);e={...e,mass:ge,stiffness:s,damping:o}}</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">n=Ce(t);e={...e,...n,mass:ge},e.isResolvedFromDuration=!</span><span class="s3">0</span><span class="s1">}</span><span class="s0">return </span><span class="s1">e}({...n,velocity:-C(n.velocity||</span><span class="s3">0</span><span class="s1">)}),m=d||</span><span class="s3">0</span><span class="s1">,f=h/(</span><span class="s3">2</span><span class="s1">*Math.sqrt(l*u)),y=r-o,v=C(Math.sqrt(l/u)),x=Math.abs(y)&lt;</span><span class="s3">5</span><span class="s1">;</span><span class="s0">let </span><span class="s1">T;</span><span class="s0">if</span><span class="s1">(i||(i=x?Pe.granular:Pe.default),s||(s=x?Se.granular:Se.default),f&lt;</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">t=ke(v,f);T=e=&gt;{</span><span class="s0">const </span><span class="s1">n=Math.exp(-f*v*e);</span><span class="s0">return </span><span class="s1">r-n*((m+f*v*y)/t*Math.sin(t*e)+y*Math.cos(t*e))}}</span><span class="s0">else if</span><span class="s1">(</span><span class="s3">1</span><span class="s1">===f)T=t=&gt;r-Math.exp(-v*t)*(y+(m+v*y)*t);</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">t=v*Math.sqrt(f*f-</span><span class="s3">1</span><span class="s1">);T=e=&gt;{</span><span class="s0">const </span><span class="s1">n=Math.exp(-f*v*e),i=Math.min(t*e,</span><span class="s3">300</span><span class="s1">);</span><span class="s0">return </span><span class="s1">r-n*((m+f*v*y)*Math.sinh(i)+t*y*Math.cosh(i))/t}}</span><span class="s0">const </span><span class="s1">w={calculatedDuration:p&amp;&amp;c||</span><span class="s0">null</span><span class="s1">,next:t=&gt;{</span><span class="s0">const </span><span class="s1">e=T(t);</span><span class="s0">if</span><span class="s1">(p)a.done=t&gt;=c;</span><span class="s0">else</span><span class="s1">{</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">===t?m:</span><span class="s3">0</span><span class="s1">;f&lt;</span><span class="s3">1</span><span class="s1">&amp;&amp;(n=</span><span class="s3">0</span><span class="s1">===t?M(m):me(T,t,e));</span><span class="s0">const </span><span class="s1">o=Math.abs(n)&lt;=i,l=Math.abs(r-e)&lt;=s;a.done=o&amp;&amp;l}</span><span class="s0">return </span><span class="s1">a.value=a.done?r:e,a},toString:()=&gt;{</span><span class="s0">const </span><span class="s1">t=Math.min(pe(w),de),e=ce(e=&gt;w.next(t*e).value,t,</span><span class="s3">30</span><span class="s1">);</span><span class="s0">return </span><span class="s1">t+</span><span class="s2">&quot;ms &quot;</span><span class="s1">+e},toTransition:()=&gt;{}};</span><span class="s0">return </span><span class="s1">w}</span><span class="s0">function </span><span class="s1">Fe({keyframes:t,velocity:e=</span><span class="s3">0</span><span class="s1">,power:n=</span><span class="s3">.8</span><span class="s1">,timeConstant:i=</span><span class="s3">325</span><span class="s1">,bounceDamping:s=</span><span class="s3">10</span><span class="s1">,bounceStiffness:o=</span><span class="s3">500</span><span class="s1">,modifyTarget:r,min:a,max:l,restDelta:h=</span><span class="s3">.5</span><span class="s1">,restSpeed:u}){</span><span class="s0">const </span><span class="s1">c=t[</span><span class="s3">0</span><span class="s1">],d={done:!</span><span class="s3">1</span><span class="s1">,value:c},p=t=&gt;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===a?l:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===l||Math.abs(a-t)&lt;Math.abs(l-t)?a:l;</span><span class="s0">let </span><span class="s1">m=n*e;</span><span class="s0">const </span><span class="s1">f=c+m,y=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===r?f:r(f);y!==f&amp;&amp;(m=y-c);</span><span class="s0">const </span><span class="s1">g=t=&gt;-m*Math.exp(-t/i),v=t=&gt;y+g(t),x=t=&gt;{</span><span class="s0">const </span><span class="s1">e=g(t),n=v(t);d.done=Math.abs(e)&lt;=h,d.value=d.done?y:n};</span><span class="s0">let </span><span class="s1">T,w;</span><span class="s0">const </span><span class="s1">P=t=&gt;{</span><span class="s0">var </span><span class="s1">e;(e=d.value,</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==a&amp;&amp;e&lt;a||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==l&amp;&amp;e&gt;l)&amp;&amp;(T=t,w=Be({keyframes:[d.value,p(d.value)],velocity:me(v,t,d.value),damping:s,stiffness:o,restDelta:h,restSpeed:u}))};</span><span class="s0">return </span><span class="s1">P(</span><span class="s3">0</span><span class="s1">),{calculatedDuration:</span><span class="s0">null</span><span class="s1">,next:t=&gt;{</span><span class="s0">let </span><span class="s1">e=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">return </span><span class="s1">w||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==T||(e=!</span><span class="s3">0</span><span class="s1">,x(t),P(t)),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==T&amp;&amp;t&gt;=T?w.next(t-T):(!e&amp;&amp;x(t),d)}}}</span><span class="s0">function </span><span class="s1">Oe(t,e,{clamp:n=!</span><span class="s3">0</span><span class="s1">,ease:i,mixer:s}={}){</span><span class="s0">const </span><span class="s1">o=t.length;</span><span class="s0">if</span><span class="s1">(e.length,</span><span class="s3">1</span><span class="s1">===o)</span><span class="s0">return</span><span class="s1">()=&gt;e[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">if</span><span class="s1">(</span><span class="s3">2</span><span class="s1">===o&amp;&amp;e[</span><span class="s3">0</span><span class="s1">]===e[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">return</span><span class="s1">()=&gt;e[</span><span class="s3">1</span><span class="s1">];</span><span class="s0">const </span><span class="s1">r=t[</span><span class="s3">0</span><span class="s1">]===t[</span><span class="s3">1</span><span class="s1">];t[</span><span class="s3">0</span><span class="s1">]&gt;t[o-</span><span class="s3">1</span><span class="s1">]&amp;&amp;(t=[...t].reverse(),e=[...e].reverse());</span><span class="s0">const </span><span class="s1">a=</span><span class="s0">function</span><span class="s1">(t,e,n){</span><span class="s0">const </span><span class="s1">i=[],s=n||v.mix||he,o=t.length-</span><span class="s3">1</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">;n&lt;o;n++){</span><span class="s0">let </span><span class="s1">o=s(t[n],t[n+</span><span class="s3">1</span><span class="s1">]);</span><span class="s0">if</span><span class="s1">(e){</span><span class="s0">const </span><span class="s1">t=Array.isArray(e)?e[n]||S:e;o=A(t,o)}i.push(o)}</span><span class="s0">return </span><span class="s1">i}(e,i,s),l=a.length,h=n=&gt;{</span><span class="s0">if</span><span class="s1">(r&amp;&amp;n&lt;t[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">return </span><span class="s1">e[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(l&gt;</span><span class="s3">1</span><span class="s1">)</span><span class="s0">for</span><span class="s1">(;i&lt;t.length-</span><span class="s3">2</span><span class="s1">&amp;&amp;!(n&lt;t[i+</span><span class="s3">1</span><span class="s1">]);i++);</span><span class="s0">const </span><span class="s1">s=E(t[i],t[i+</span><span class="s3">1</span><span class="s1">],n);</span><span class="s0">return </span><span class="s1">a[i](s)};</span><span class="s0">return </span><span class="s1">n?e=&gt;h(g(t[</span><span class="s3">0</span><span class="s1">],t[o-</span><span class="s3">1</span><span class="s1">],e)):h}</span><span class="s0">function </span><span class="s1">Ie(t){</span><span class="s0">const </span><span class="s1">e=[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">return function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">n=t[t.length-</span><span class="s3">1</span><span class="s1">];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">1</span><span class="s1">;i&lt;=e;i++){</span><span class="s0">const </span><span class="s1">s=E(</span><span class="s3">0</span><span class="s1">,e,i);t.push(Jt(n,</span><span class="s3">1</span><span class="s1">,s))}}(e,t.length-</span><span class="s3">1</span><span class="s1">),e}</span><span class="s0">function </span><span class="s1">Ue({duration:t=</span><span class="s3">300</span><span class="s1">,keyframes:e,times:n,ease:i=</span><span class="s2">&quot;easeInOut&quot;</span><span class="s1">}){</span><span class="s0">const </span><span class="s1">s=(t=&gt;Array.isArray(t)&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t[</span><span class="s3">0</span><span class="s1">])(i)?i.map(H):H(i),o={done:!</span><span class="s3">1</span><span class="s1">,value:e[</span><span class="s3">0</span><span class="s1">]},r=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">return </span><span class="s1">t.map(t=&gt;t*e)}(n&amp;&amp;n.length===e.length?n:Ie(e),t),a=Oe(r,e,{ease:Array.isArray(s)?s:(l=e,h=s,l.map(()=&gt;h||X).splice(</span><span class="s3">0</span><span class="s1">,l.length-</span><span class="s3">1</span><span class="s1">))});</span><span class="s0">var </span><span class="s1">l,h;</span><span class="s0">return</span><span class="s1">{calculatedDuration:t,next:e=&gt;(o.value=a(e),o.done=e&gt;=t,o)}}Be.applyToOptions=t=&gt;{</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">function</span><span class="s1">(t,e=</span><span class="s3">100</span><span class="s1">,n){</span><span class="s0">const </span><span class="s1">i=n({...t,keyframes:[</span><span class="s3">0</span><span class="s1">,e]}),s=Math.min(pe(i),de);</span><span class="s0">return</span><span class="s1">{type:</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,ease:t=&gt;i.next(s*t).value/e,duration:C(s)}}(t,</span><span class="s3">100</span><span class="s1">,Be);</span><span class="s0">return </span><span class="s1">t.ease=e.ease,t.duration=M(e.duration),t.type=</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,t};</span><span class="s0">const </span><span class="s1">Ne=t=&gt;</span><span class="s0">null</span><span class="s1">!==t;</span><span class="s0">function </span><span class="s1">We(t,{repeat:e,repeatType:n=</span><span class="s2">&quot;loop&quot;</span><span class="s1">},i,s=</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">o=t.filter(Ne),r=s&lt;</span><span class="s3">0</span><span class="s1">||e&amp;&amp;</span><span class="s2">&quot;loop&quot;</span><span class="s1">!==n&amp;&amp;e%</span><span class="s3">2</span><span class="s1">==</span><span class="s3">1</span><span class="s1">?</span><span class="s3">0</span><span class="s1">:o.length-</span><span class="s3">1</span><span class="s1">;</span><span class="s0">return </span><span class="s1">r&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==i?i:o[r]}</span><span class="s0">const </span><span class="s1">$e={decay:Fe,inertia:Fe,tween:Ue,keyframes:Ue,spring:Be};</span><span class="s0">function </span><span class="s1">Ye(t){</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t.type&amp;&amp;(t.type=$e[t.type])}</span><span class="s0">class </span><span class="s1">Xe{constructor(){</span><span class="s0">this</span><span class="s1">.updateFinished()}get finished(){</span><span class="s0">return this</span><span class="s1">._finished}updateFinished(){</span><span class="s0">this</span><span class="s1">._finished=</span><span class="s0">new </span><span class="s1">Promise(t=&gt;{</span><span class="s0">this</span><span class="s1">.resolve=t})}notifyFinished(){</span><span class="s0">this</span><span class="s1">.resolve()}then(t,e){</span><span class="s0">return this</span><span class="s1">.finished.then(t,e)}}</span><span class="s0">const </span><span class="s1">Ke=t=&gt;t/</span><span class="s3">100</span><span class="s1">;</span><span class="s0">class </span><span class="s1">ze </span><span class="s0">extends </span><span class="s1">Xe{constructor(t){</span><span class="s0">super</span><span class="s1">(),</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;idle&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.startTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isStopped=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.currentTime=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.playbackSpeed=</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.stop=()=&gt;{</span><span class="s0">const</span><span class="s1">{motionValue:t}=</span><span class="s0">this</span><span class="s1">.options;t&amp;&amp;t.updatedAt!==ft.now()&amp;&amp;</span><span class="s0">this</span><span class="s1">.tick(ft.now()),</span><span class="s0">this</span><span class="s1">.isStopped=!</span><span class="s3">0</span><span class="s1">,</span><span class="s2">&quot;idle&quot;</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.state&amp;&amp;(</span><span class="s0">this</span><span class="s1">.teardown(),</span><span class="s0">this</span><span class="s1">.options.onStop?.())},</span><span class="s0">this</span><span class="s1">.options=t,</span><span class="s0">this</span><span class="s1">.initAnimation(),</span><span class="s0">this</span><span class="s1">.play(),!</span><span class="s3">1</span><span class="s1">===t.autoplay&amp;&amp;</span><span class="s0">this</span><span class="s1">.pause()}initAnimation(){</span><span class="s0">const</span><span class="s1">{options:t}=</span><span class="s0">this</span><span class="s1">;Ye(t);</span><span class="s0">const</span><span class="s1">{type:e=Ue,repeat:n=</span><span class="s3">0</span><span class="s1">,repeatDelay:i=</span><span class="s3">0</span><span class="s1">,repeatType:s,velocity:o=</span><span class="s3">0</span><span class="s1">}=t;</span><span class="s0">let</span><span class="s1">{keyframes:r}=t;</span><span class="s0">const </span><span class="s1">a=e||Ue;a!==Ue&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">r[</span><span class="s3">0</span><span class="s1">]&amp;&amp;(</span><span class="s0">this</span><span class="s1">.mixKeyframes=A(Ke,he(r[</span><span class="s3">0</span><span class="s1">],r[</span><span class="s3">1</span><span class="s1">])),r=[</span><span class="s3">0</span><span class="s1">,</span><span class="s3">100</span><span class="s1">]);</span><span class="s0">const </span><span class="s1">l=a({...t,keyframes:r});</span><span class="s2">&quot;mirror&quot;</span><span class="s1">===s&amp;&amp;(</span><span class="s0">this</span><span class="s1">.mirroredGenerator=a({...t,keyframes:[...r].reverse(),velocity:-o})),</span><span class="s0">null</span><span class="s1">===l.calculatedDuration&amp;&amp;(l.calculatedDuration=pe(l));</span><span class="s0">const</span><span class="s1">{calculatedDuration:h}=l;</span><span class="s0">this</span><span class="s1">.calculatedDuration=h,</span><span class="s0">this</span><span class="s1">.resolvedDuration=h+i,</span><span class="s0">this</span><span class="s1">.totalDuration=</span><span class="s0">this</span><span class="s1">.resolvedDuration*(n+</span><span class="s3">1</span><span class="s1">)-i,</span><span class="s0">this</span><span class="s1">.generator=l}updateTime(t){</span><span class="s0">const </span><span class="s1">e=Math.round(t-</span><span class="s0">this</span><span class="s1">.startTime)*</span><span class="s0">this</span><span class="s1">.playbackSpeed;</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.holdTime?</span><span class="s0">this</span><span class="s1">.currentTime=</span><span class="s0">this</span><span class="s1">.holdTime:</span><span class="s0">this</span><span class="s1">.currentTime=e}tick(t,e=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const</span><span class="s1">{generator:n,totalDuration:i,mixKeyframes:s,mirroredGenerator:o,resolvedDuration:r,calculatedDuration:a}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.startTime)</span><span class="s0">return </span><span class="s1">n.next(</span><span class="s3">0</span><span class="s1">);</span><span class="s0">const</span><span class="s1">{delay:l=</span><span class="s3">0</span><span class="s1">,keyframes:h,repeat:u,repeatType:c,repeatDelay:d,type:p,onUpdate:m,finalKeyframe:f}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">this</span><span class="s1">.speed&gt;</span><span class="s3">0</span><span class="s1">?</span><span class="s0">this</span><span class="s1">.startTime=Math.min(</span><span class="s0">this</span><span class="s1">.startTime,t):</span><span class="s0">this</span><span class="s1">.speed&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.startTime=Math.min(t-i/</span><span class="s0">this</span><span class="s1">.speed,</span><span class="s0">this</span><span class="s1">.startTime)),e?</span><span class="s0">this</span><span class="s1">.currentTime=t:</span><span class="s0">this</span><span class="s1">.updateTime(t);</span><span class="s0">const </span><span class="s1">y=</span><span class="s0">this</span><span class="s1">.currentTime-l*(</span><span class="s0">this</span><span class="s1">.playbackSpeed&gt;=</span><span class="s3">0</span><span class="s1">?</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">),v=</span><span class="s0">this</span><span class="s1">.playbackSpeed&gt;=</span><span class="s3">0</span><span class="s1">?y&lt;</span><span class="s3">0</span><span class="s1">:y&gt;i;</span><span class="s0">this</span><span class="s1">.currentTime=Math.max(y,</span><span class="s3">0</span><span class="s1">),</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.holdTime&amp;&amp;(</span><span class="s0">this</span><span class="s1">.currentTime=i);</span><span class="s0">let </span><span class="s1">x=</span><span class="s0">this</span><span class="s1">.currentTime,T=n;</span><span class="s0">if</span><span class="s1">(u){</span><span class="s0">const </span><span class="s1">t=Math.min(</span><span class="s0">this</span><span class="s1">.currentTime,i)/r;</span><span class="s0">let </span><span class="s1">e=Math.floor(t),n=t%</span><span class="s3">1</span><span class="s1">;!n&amp;&amp;t&gt;=</span><span class="s3">1</span><span class="s1">&amp;&amp;(n=</span><span class="s3">1</span><span class="s1">),</span><span class="s3">1</span><span class="s1">===n&amp;&amp;e--,e=Math.min(e,u+</span><span class="s3">1</span><span class="s1">);Boolean(e%</span><span class="s3">2</span><span class="s1">)&amp;&amp;(</span><span class="s2">&quot;reverse&quot;</span><span class="s1">===c?(n=</span><span class="s3">1</span><span class="s1">-n,d&amp;&amp;(n-=d/r)):</span><span class="s2">&quot;mirror&quot;</span><span class="s1">===c&amp;&amp;(T=o)),x=g(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,n)*r}</span><span class="s0">const </span><span class="s1">w=v?{done:!</span><span class="s3">1</span><span class="s1">,value:h[</span><span class="s3">0</span><span class="s1">]}:T.next(x);s&amp;&amp;(w.value=s(w.value));</span><span class="s0">let</span><span class="s1">{done:P}=w;v||</span><span class="s0">null</span><span class="s1">===a||(P=</span><span class="s0">this</span><span class="s1">.playbackSpeed&gt;=</span><span class="s3">0</span><span class="s1">?</span><span class="s0">this</span><span class="s1">.currentTime&gt;=i:</span><span class="s0">this</span><span class="s1">.currentTime&lt;=</span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">S=</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.holdTime&amp;&amp;(</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state||</span><span class="s2">&quot;running&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;P);</span><span class="s0">return </span><span class="s1">S&amp;&amp;p!==Fe&amp;&amp;(w.value=We(h,</span><span class="s0">this</span><span class="s1">.options,f,</span><span class="s0">this</span><span class="s1">.speed)),m&amp;&amp;m(w.value),S&amp;&amp;</span><span class="s0">this</span><span class="s1">.finish(),w}then(t,e){</span><span class="s0">return this</span><span class="s1">.finished.then(t,e)}get duration(){</span><span class="s0">return </span><span class="s1">C(</span><span class="s0">this</span><span class="s1">.calculatedDuration)}get iterationDuration(){</span><span class="s0">const</span><span class="s1">{delay:t=</span><span class="s3">0</span><span class="s1">}=</span><span class="s0">this</span><span class="s1">.options||{};</span><span class="s0">return this</span><span class="s1">.duration+C(t)}get time(){</span><span class="s0">return </span><span class="s1">C(</span><span class="s0">this</span><span class="s1">.currentTime)}set time(t){t=M(t),</span><span class="s0">this</span><span class="s1">.currentTime=t,</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.startTime||</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.holdTime||</span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.playbackSpeed?</span><span class="s0">this</span><span class="s1">.holdTime=t:</span><span class="s0">this</span><span class="s1">.driver&amp;&amp;(</span><span class="s0">this</span><span class="s1">.startTime=</span><span class="s0">this</span><span class="s1">.driver.now()-t/</span><span class="s0">this</span><span class="s1">.playbackSpeed),</span><span class="s0">this</span><span class="s1">.driver?.start(!</span><span class="s3">1</span><span class="s1">)}get speed(){</span><span class="s0">return this</span><span class="s1">.playbackSpeed}set speed(t){</span><span class="s0">this</span><span class="s1">.updateTime(ft.now());</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.playbackSpeed!==t;</span><span class="s0">this</span><span class="s1">.playbackSpeed=t,e&amp;&amp;(</span><span class="s0">this</span><span class="s1">.time=C(</span><span class="s0">this</span><span class="s1">.currentTime))}play(){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isStopped)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{driver:t=ue,startTime:e}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">this</span><span class="s1">.driver||(</span><span class="s0">this</span><span class="s1">.driver=t(t=&gt;</span><span class="s0">this</span><span class="s1">.tick(t))),</span><span class="s0">this</span><span class="s1">.options.onPlay?.();</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.driver.now();</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state?(</span><span class="s0">this</span><span class="s1">.updateFinished(),</span><span class="s0">this</span><span class="s1">.startTime=n):</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.holdTime?</span><span class="s0">this</span><span class="s1">.startTime=n-</span><span class="s0">this</span><span class="s1">.holdTime:</span><span class="s0">this</span><span class="s1">.startTime||(</span><span class="s0">this</span><span class="s1">.startTime=e??n),</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">this</span><span class="s1">.speed&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.startTime+=</span><span class="s0">this</span><span class="s1">.calculatedDuration),</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;running&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.driver.start()}pause(){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;paused&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateTime(ft.now()),</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">this</span><span class="s1">.currentTime}complete(){</span><span class="s2">&quot;running&quot;</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">this</span><span class="s1">.play(),</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;finished&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">}finish(){</span><span class="s0">this</span><span class="s1">.notifyFinished(),</span><span class="s0">this</span><span class="s1">.teardown(),</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;finished&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.options.onComplete?.()}cancel(){</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.startTime=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.tick(</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.teardown(),</span><span class="s0">this</span><span class="s1">.options.onCancel?.()}teardown(){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;idle&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.stopDriver(),</span><span class="s0">this</span><span class="s1">.startTime=</span><span class="s0">this</span><span class="s1">.holdTime=</span><span class="s0">null</span><span class="s1">}stopDriver(){</span><span class="s0">this</span><span class="s1">.driver&amp;&amp;(</span><span class="s0">this</span><span class="s1">.driver.stop(),</span><span class="s0">this</span><span class="s1">.driver=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}sample(t){</span><span class="s0">return this</span><span class="s1">.startTime=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.tick(t,!</span><span class="s3">0</span><span class="s1">)}attachTimeline(t){</span><span class="s0">return this</span><span class="s1">.options.allowFlatten&amp;&amp;(</span><span class="s0">this</span><span class="s1">.options.type=</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.options.ease=</span><span class="s2">&quot;linear&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.initAnimation()),</span><span class="s0">this</span><span class="s1">.driver?.stop(),t.observe(</span><span class="s0">this</span><span class="s1">)}}</span><span class="s0">const </span><span class="s1">He=t=&gt;</span><span class="s3">180</span><span class="s1">*t/Math.PI,Ge=t=&gt;{</span><span class="s0">const </span><span class="s1">e=He(Math.atan2(t[</span><span class="s3">1</span><span class="s1">],t[</span><span class="s3">0</span><span class="s1">]));</span><span class="s0">return </span><span class="s1">Ze(e)},qe={x:</span><span class="s3">4</span><span class="s1">,y:</span><span class="s3">5</span><span class="s1">,translateX:</span><span class="s3">4</span><span class="s1">,translateY:</span><span class="s3">5</span><span class="s1">,scaleX:</span><span class="s3">0</span><span class="s1">,scaleY:</span><span class="s3">3</span><span class="s1">,scale:t=&gt;(Math.abs(t[</span><span class="s3">0</span><span class="s1">])+Math.abs(t[</span><span class="s3">3</span><span class="s1">]))/</span><span class="s3">2</span><span class="s1">,rotate:Ge,rotateZ:Ge,skewX:t=&gt;He(Math.atan(t[</span><span class="s3">1</span><span class="s1">])),skewY:t=&gt;He(Math.atan(t[</span><span class="s3">2</span><span class="s1">])),skew:t=&gt;(Math.abs(t[</span><span class="s3">1</span><span class="s1">])+Math.abs(t[</span><span class="s3">2</span><span class="s1">]))/</span><span class="s3">2</span><span class="s1">},Ze=t=&gt;((t%=</span><span class="s3">360</span><span class="s1">)&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(t+=</span><span class="s3">360</span><span class="s1">),t),_e=t=&gt;Math.sqrt(t[</span><span class="s3">0</span><span class="s1">]*t[</span><span class="s3">0</span><span class="s1">]+t[</span><span class="s3">1</span><span class="s1">]*t[</span><span class="s3">1</span><span class="s1">]),Je=t=&gt;Math.sqrt(t[</span><span class="s3">4</span><span class="s1">]*t[</span><span class="s3">4</span><span class="s1">]+t[</span><span class="s3">5</span><span class="s1">]*t[</span><span class="s3">5</span><span class="s1">]),Qe={x:</span><span class="s3">12</span><span class="s1">,y:</span><span class="s3">13</span><span class="s1">,z:</span><span class="s3">14</span><span class="s1">,translateX:</span><span class="s3">12</span><span class="s1">,translateY:</span><span class="s3">13</span><span class="s1">,translateZ:</span><span class="s3">14</span><span class="s1">,scaleX:_e,scaleY:Je,scale:t=&gt;(_e(t)+Je(t))/</span><span class="s3">2</span><span class="s1">,rotateX:t=&gt;Ze(He(Math.atan2(t[</span><span class="s3">6</span><span class="s1">],t[</span><span class="s3">5</span><span class="s1">]))),rotateY:t=&gt;Ze(He(Math.atan2(-t[</span><span class="s3">2</span><span class="s1">],t[</span><span class="s3">0</span><span class="s1">]))),rotateZ:Ge,rotate:Ge,skewX:t=&gt;He(Math.atan(t[</span><span class="s3">4</span><span class="s1">])),skewY:t=&gt;He(Math.atan(t[</span><span class="s3">1</span><span class="s1">])),skew:t=&gt;(Math.abs(t[</span><span class="s3">1</span><span class="s1">])+Math.abs(t[</span><span class="s3">4</span><span class="s1">]))/</span><span class="s3">2</span><span class="s1">};</span><span class="s0">function </span><span class="s1">tn(t){</span><span class="s0">return </span><span class="s1">t.includes(</span><span class="s2">&quot;scale&quot;</span><span class="s1">)?</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">}</span><span class="s0">function </span><span class="s1">en(t,e){</span><span class="s0">if</span><span class="s1">(!t||</span><span class="s2">&quot;none&quot;</span><span class="s1">===t)</span><span class="s0">return </span><span class="s1">tn(e);</span><span class="s0">const </span><span class="s1">n=t.match(</span><span class="s4">/^matrix3d\(([-\d.e\s,]+)\)$/u</span><span class="s1">);</span><span class="s0">let </span><span class="s1">i,s;</span><span class="s0">if</span><span class="s1">(n)i=Qe,s=n;</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">e=t.match(</span><span class="s4">/^matrix\(([-\d.e\s,]+)\)$/u</span><span class="s1">);i=qe,s=e}</span><span class="s0">if</span><span class="s1">(!s)</span><span class="s0">return </span><span class="s1">tn(e);</span><span class="s0">const </span><span class="s1">o=i[e],r=s[</span><span class="s3">1</span><span class="s1">].split(</span><span class="s2">&quot;,&quot;</span><span class="s1">).map(nn);</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">o?o(r):r[o]}</span><span class="s0">function </span><span class="s1">nn(t){</span><span class="s0">return </span><span class="s1">parseFloat(t.trim())}</span><span class="s0">const </span><span class="s1">sn=[</span><span class="s2">&quot;transformPerspective&quot;</span><span class="s1">,</span><span class="s2">&quot;x&quot;</span><span class="s1">,</span><span class="s2">&quot;y&quot;</span><span class="s1">,</span><span class="s2">&quot;z&quot;</span><span class="s1">,</span><span class="s2">&quot;translateX&quot;</span><span class="s1">,</span><span class="s2">&quot;translateY&quot;</span><span class="s1">,</span><span class="s2">&quot;translateZ&quot;</span><span class="s1">,</span><span class="s2">&quot;scale&quot;</span><span class="s1">,</span><span class="s2">&quot;scaleX&quot;</span><span class="s1">,</span><span class="s2">&quot;scaleY&quot;</span><span class="s1">,</span><span class="s2">&quot;rotate&quot;</span><span class="s1">,</span><span class="s2">&quot;rotateX&quot;</span><span class="s1">,</span><span class="s2">&quot;rotateY&quot;</span><span class="s1">,</span><span class="s2">&quot;rotateZ&quot;</span><span class="s1">,</span><span class="s2">&quot;skew&quot;</span><span class="s1">,</span><span class="s2">&quot;skewX&quot;</span><span class="s1">,</span><span class="s2">&quot;skewY&quot;</span><span class="s1">],on=(()=&gt;</span><span class="s0">new </span><span class="s1">Set(sn))(),rn=t=&gt;t===wt||t===Bt,an=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;x&quot;</span><span class="s1">,</span><span class="s2">&quot;y&quot;</span><span class="s1">,</span><span class="s2">&quot;z&quot;</span><span class="s1">]),ln=sn.filter(t=&gt;!an.has(t));</span><span class="s0">const </span><span class="s1">hn={width:({x:t},{paddingLeft:e=</span><span class="s2">&quot;0&quot;</span><span class="s1">,paddingRight:n=</span><span class="s2">&quot;0&quot;</span><span class="s1">})=&gt;t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e=</span><span class="s2">&quot;0&quot;</span><span class="s1">,paddingBottom:n=</span><span class="s2">&quot;0&quot;</span><span class="s1">})=&gt;t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=&gt;parseFloat(e),left:(t,{left:e})=&gt;parseFloat(e),bottom:({y:t},{top:e})=&gt;parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=&gt;parseFloat(e)+(t.max-t.min),x:(t,{transform:e})=&gt;en(e,</span><span class="s2">&quot;x&quot;</span><span class="s1">),y:(t,{transform:e})=&gt;en(e,</span><span class="s2">&quot;y&quot;</span><span class="s1">)};hn.translateX=hn.x,hn.translateY=hn.y;</span><span class="s0">const </span><span class="s1">un=</span><span class="s0">new </span><span class="s1">Set;</span><span class="s0">let </span><span class="s1">cn=!</span><span class="s3">1</span><span class="s1">,dn=!</span><span class="s3">1</span><span class="s1">,pn=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">function </span><span class="s1">mn(){</span><span class="s0">if</span><span class="s1">(dn){</span><span class="s0">const </span><span class="s1">t=Array.from(un).filter(t=&gt;t.needsMeasurement),e=</span><span class="s0">new </span><span class="s1">Set(t.map(t=&gt;t.element)),n=</span><span class="s0">new </span><span class="s1">Map;e.forEach(t=&gt;{</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const </span><span class="s1">e=[];</span><span class="s0">return </span><span class="s1">ln.forEach(n=&gt;{</span><span class="s0">const </span><span class="s1">i=t.getValue(n);</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==i&amp;&amp;(e.push([n,i.get()]),i.set(n.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s1">)?</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">))}),e}(t);e.length&amp;&amp;(n.set(t,e),t.render())}),t.forEach(t=&gt;t.measureInitialState()),e.forEach(t=&gt;{t.render();</span><span class="s0">const </span><span class="s1">e=n.get(t);e&amp;&amp;e.forEach(([e,n])=&gt;{t.getValue(e)?.set(n)})}),t.forEach(t=&gt;t.measureEndState()),t.forEach(t=&gt;{</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t.suspendedScrollY&amp;&amp;window.scrollTo(</span><span class="s3">0</span><span class="s1">,t.suspendedScrollY)})}dn=!</span><span class="s3">1</span><span class="s1">,cn=!</span><span class="s3">1</span><span class="s1">,un.forEach(t=&gt;t.complete(pn)),un.clear()}</span><span class="s0">function </span><span class="s1">fn(){un.forEach(t=&gt;{t.readKeyframes(),t.needsMeasurement&amp;&amp;(dn=!</span><span class="s3">0</span><span class="s1">)})}</span><span class="s0">class </span><span class="s1">yn{constructor(t,e,n,i,s,o=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;pending&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isAsync=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.needsMeasurement=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.unresolvedKeyframes=[...t],</span><span class="s0">this</span><span class="s1">.onComplete=e,</span><span class="s0">this</span><span class="s1">.name=n,</span><span class="s0">this</span><span class="s1">.motionValue=i,</span><span class="s0">this</span><span class="s1">.element=s,</span><span class="s0">this</span><span class="s1">.isAsync=o}scheduleResolve(){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;scheduled&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isAsync?(un.add(</span><span class="s0">this</span><span class="s1">),cn||(cn=!</span><span class="s3">0</span><span class="s1">,ht.read(fn),ht.resolveKeyframes(mn))):(</span><span class="s0">this</span><span class="s1">.readKeyframes(),</span><span class="s0">this</span><span class="s1">.complete())}readKeyframes(){</span><span class="s0">const</span><span class="s1">{unresolvedKeyframes:t,name:e,element:n,motionValue:i}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===t[</span><span class="s3">0</span><span class="s1">]){</span><span class="s0">const </span><span class="s1">s=i?.get(),o=t[t.length-</span><span class="s3">1</span><span class="s1">];</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s)t[</span><span class="s3">0</span><span class="s1">]=s;</span><span class="s0">else if</span><span class="s1">(n&amp;&amp;e){</span><span class="s0">const </span><span class="s1">i=n.readValue(e,o);</span><span class="s0">null</span><span class="s1">!=i&amp;&amp;(t[</span><span class="s3">0</span><span class="s1">]=i)}</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===t[</span><span class="s3">0</span><span class="s1">]&amp;&amp;(t[</span><span class="s3">0</span><span class="s1">]=o),i&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===s&amp;&amp;i.set(t[</span><span class="s3">0</span><span class="s1">])}!</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">1</span><span class="s1">;e&lt;t.length;e++)t[e]??(t[e]=t[e-</span><span class="s3">1</span><span class="s1">])}(t)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(t=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;complete&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.onComplete(</span><span class="s0">this</span><span class="s1">.unresolvedKeyframes,</span><span class="s0">this</span><span class="s1">.finalKeyframe,t),un.delete(</span><span class="s0">this</span><span class="s1">)}cancel(){</span><span class="s2">&quot;scheduled&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;(un.delete(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.state=</span><span class="s2">&quot;pending&quot;</span><span class="s1">)}resume(){</span><span class="s2">&quot;pending&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">this</span><span class="s1">.scheduleResolve()}}</span><span class="s0">const </span><span class="s1">gn=P(()=&gt;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==window.ScrollTimeline),vn={};</span><span class="s0">function </span><span class="s1">xn(t,e){</span><span class="s0">const </span><span class="s1">n=P(t);</span><span class="s0">return</span><span class="s1">()=&gt;vn[e]??n()}</span><span class="s0">const </span><span class="s1">Tn=xn(()=&gt;{</span><span class="s0">try</span><span class="s1">{document.createElement(</span><span class="s2">&quot;div&quot;</span><span class="s1">).animate({opacity:</span><span class="s3">0</span><span class="s1">},{easing:</span><span class="s2">&quot;linear(0, 1)&quot;</span><span class="s1">})}</span><span class="s0">catch</span><span class="s1">(t){</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">}</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">},</span><span class="s2">&quot;linearEasing&quot;</span><span class="s1">),wn=([t,e,n,i])=&gt;</span><span class="s2">`cubic-bezier(</span><span class="s1">${t}</span><span class="s2">, </span><span class="s1">${e}</span><span class="s2">, </span><span class="s1">${n}</span><span class="s2">, </span><span class="s1">${i}</span><span class="s2">)`</span><span class="s1">,Pn={linear:</span><span class="s2">&quot;linear&quot;</span><span class="s1">,ease:</span><span class="s2">&quot;ease&quot;</span><span class="s1">,easeIn:</span><span class="s2">&quot;ease-in&quot;</span><span class="s1">,easeOut:</span><span class="s2">&quot;ease-out&quot;</span><span class="s1">,easeInOut:</span><span class="s2">&quot;ease-in-out&quot;</span><span class="s1">,circIn:wn([</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.65</span><span class="s1">,</span><span class="s3">.55</span><span class="s1">,</span><span class="s3">1</span><span class="s1">]),circOut:wn([</span><span class="s3">.55</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,</span><span class="s3">.45</span><span class="s1">]),backIn:wn([</span><span class="s3">.31</span><span class="s1">,</span><span class="s3">.01</span><span class="s1">,</span><span class="s3">.66</span><span class="s1">,-</span><span class="s3">.59</span><span class="s1">]),backOut:wn([</span><span class="s3">.33</span><span class="s1">,</span><span class="s3">1.53</span><span class="s1">,</span><span class="s3">.69</span><span class="s1">,</span><span class="s3">.99</span><span class="s1">])};</span><span class="s0">function </span><span class="s1">Sn(t,e){</span><span class="s0">return </span><span class="s1">t?</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?Tn()?ce(t,e):</span><span class="s2">&quot;ease-out&quot;</span><span class="s1">:K(t)?wn(t):Array.isArray(t)?t.map(t=&gt;Sn(t,e)||Pn.easeOut):Pn[t]:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">function </span><span class="s1">bn(t,e,n,{delay:i=</span><span class="s3">0</span><span class="s1">,duration:s=</span><span class="s3">300</span><span class="s1">,repeat:o=</span><span class="s3">0</span><span class="s1">,repeatType:r=</span><span class="s2">&quot;loop&quot;</span><span class="s1">,ease:a=</span><span class="s2">&quot;easeOut&quot;</span><span class="s1">,times:l}={},h=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">){</span><span class="s0">const </span><span class="s1">u={[e]:n};l&amp;&amp;(u.offset=l);</span><span class="s0">const </span><span class="s1">c=Sn(a,s);Array.isArray(c)&amp;&amp;(u.easing=c);</span><span class="s0">const </span><span class="s1">d={delay:i,duration:s,easing:Array.isArray(c)?</span><span class="s2">&quot;linear&quot;</span><span class="s1">:c,fill:</span><span class="s2">&quot;both&quot;</span><span class="s1">,iterations:o+</span><span class="s3">1</span><span class="s1">,direction:</span><span class="s2">&quot;reverse&quot;</span><span class="s1">===r?</span><span class="s2">&quot;alternate&quot;</span><span class="s1">:</span><span class="s2">&quot;normal&quot;</span><span class="s1">};h&amp;&amp;(d.pseudoElement=h);</span><span class="s0">return </span><span class="s1">t.animate(u,d)}</span><span class="s0">function </span><span class="s1">An(t){</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;</span><span class="s2">&quot;applyToOptions&quot;</span><span class="s0">in </span><span class="s1">t}</span><span class="s0">class </span><span class="s1">En </span><span class="s0">extends </span><span class="s1">Xe{constructor(t){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">super</span><span class="s1">(),</span><span class="s0">this</span><span class="s1">.finishedTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isStopped=!</span><span class="s3">1</span><span class="s1">,!t)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{element:e,name:n,keyframes:i,pseudoElement:s,allowFlatten:o=!</span><span class="s3">1</span><span class="s1">,finalKeyframe:r,onComplete:a}=t;</span><span class="s0">this</span><span class="s1">.isPseudoElement=Boolean(s),</span><span class="s0">this</span><span class="s1">.allowFlatten=o,</span><span class="s0">this</span><span class="s1">.options=t,t.type;</span><span class="s0">const </span><span class="s1">l=</span><span class="s0">function</span><span class="s1">({type:t,...e}){</span><span class="s0">return </span><span class="s1">An(t)&amp;&amp;Tn()?t.applyToOptions(e):(e.duration??(e.duration=</span><span class="s3">300</span><span class="s1">),e.ease??(e.ease=</span><span class="s2">&quot;easeOut&quot;</span><span class="s1">),e)}(t);</span><span class="s0">this</span><span class="s1">.animation=bn(e,n,i,l,s),!</span><span class="s3">1</span><span class="s1">===l.autoplay&amp;&amp;</span><span class="s0">this</span><span class="s1">.animation.pause(),</span><span class="s0">this</span><span class="s1">.animation.onfinish=()=&gt;{</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.finishedTime=</span><span class="s0">this</span><span class="s1">.time,!s){</span><span class="s0">const </span><span class="s1">t=We(i,</span><span class="s0">this</span><span class="s1">.options,r,</span><span class="s0">this</span><span class="s1">.speed);</span><span class="s0">this</span><span class="s1">.updateMotionValue?</span><span class="s0">this</span><span class="s1">.updateMotionValue(t):</span><span class="s0">function</span><span class="s1">(t,e,n){(t=&gt;t.startsWith(</span><span class="s2">&quot;--&quot;</span><span class="s1">))(e)?t.style.setProperty(e,n):t.style[e]=n}(e,n,t),</span><span class="s0">this</span><span class="s1">.animation.cancel()}a?.(),</span><span class="s0">this</span><span class="s1">.notifyFinished()}}play(){</span><span class="s0">this</span><span class="s1">.isStopped||(</span><span class="s0">this</span><span class="s1">.animation.play(),</span><span class="s2">&quot;finished&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.state&amp;&amp;</span><span class="s0">this</span><span class="s1">.updateFinished())}pause(){</span><span class="s0">this</span><span class="s1">.animation.pause()}complete(){</span><span class="s0">this</span><span class="s1">.animation.finish?.()}cancel(){</span><span class="s0">try</span><span class="s1">{</span><span class="s0">this</span><span class="s1">.animation.cancel()}</span><span class="s0">catch</span><span class="s1">(t){}}stop(){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isStopped)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.isStopped=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{state:t}=</span><span class="s0">this</span><span class="s1">;</span><span class="s2">&quot;idle&quot;</span><span class="s1">!==t&amp;&amp;</span><span class="s2">&quot;finished&quot;</span><span class="s1">!==t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.updateMotionValue?</span><span class="s0">this</span><span class="s1">.updateMotionValue():</span><span class="s0">this</span><span class="s1">.commitStyles(),</span><span class="s0">this</span><span class="s1">.isPseudoElement||</span><span class="s0">this</span><span class="s1">.cancel())}commitStyles(){</span><span class="s0">this</span><span class="s1">.isPseudoElement||</span><span class="s0">this</span><span class="s1">.animation.commitStyles?.()}get duration(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.animation.effect?.getComputedTiming?.().duration||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">return </span><span class="s1">C(Number(t))}get iterationDuration(){</span><span class="s0">const</span><span class="s1">{delay:t=</span><span class="s3">0</span><span class="s1">}=</span><span class="s0">this</span><span class="s1">.options||{};</span><span class="s0">return this</span><span class="s1">.duration+C(t)}get time(){</span><span class="s0">return </span><span class="s1">C(Number(</span><span class="s0">this</span><span class="s1">.animation.currentTime)||</span><span class="s3">0</span><span class="s1">)}set time(t){</span><span class="s0">this</span><span class="s1">.finishedTime=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.animation.currentTime=M(t)}get speed(){</span><span class="s0">return this</span><span class="s1">.animation.playbackRate}set speed(t){t&lt;</span><span class="s3">0</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.finishedTime=</span><span class="s0">null</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.animation.playbackRate=t}get state(){</span><span class="s0">return null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.finishedTime?</span><span class="s2">&quot;finished&quot;</span><span class="s1">:</span><span class="s0">this</span><span class="s1">.animation.playState}get startTime(){</span><span class="s0">return </span><span class="s1">Number(</span><span class="s0">this</span><span class="s1">.animation.startTime)}set startTime(t){</span><span class="s0">this</span><span class="s1">.animation.startTime=t}attachTimeline({timeline:t,observe:e}){</span><span class="s0">return this</span><span class="s1">.allowFlatten&amp;&amp;</span><span class="s0">this</span><span class="s1">.animation.effect?.updateTiming({easing:</span><span class="s2">&quot;linear&quot;</span><span class="s1">}),</span><span class="s0">this</span><span class="s1">.animation.onfinish=</span><span class="s0">null</span><span class="s1">,t&amp;&amp;gn()?(</span><span class="s0">this</span><span class="s1">.animation.timeline=t,S):e(</span><span class="s0">this</span><span class="s1">)}}</span><span class="s0">const </span><span class="s1">Vn={anticipate:I,backInOut:O,circInOut:W};</span><span class="s0">function </span><span class="s1">Mn(t){</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t.ease&amp;&amp;t.ease </span><span class="s0">in </span><span class="s1">Vn&amp;&amp;(t.ease=Vn[t.ease])}</span><span class="s0">class </span><span class="s1">Cn </span><span class="s0">extends </span><span class="s1">En{constructor(t){Mn(t),Ye(t),</span><span class="s0">super</span><span class="s1">(t),t.startTime&amp;&amp;(</span><span class="s0">this</span><span class="s1">.startTime=t.startTime),</span><span class="s0">this</span><span class="s1">.options=t}updateMotionValue(t){</span><span class="s0">const</span><span class="s1">{motionValue:e,onUpdate:n,onComplete:i,element:s,...o}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t)</span><span class="s0">return void </span><span class="s1">e.set(t);</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">new </span><span class="s1">ze({...o,autoplay:!</span><span class="s3">1</span><span class="s1">}),a=M(</span><span class="s0">this</span><span class="s1">.finishedTime??</span><span class="s0">this</span><span class="s1">.time);e.setWithVelocity(r.sample(a-</span><span class="s3">10</span><span class="s1">).value,r.sample(a).value,</span><span class="s3">10</span><span class="s1">),r.stop()}}</span><span class="s0">const </span><span class="s1">Dn=(t,e)=&gt;</span><span class="s2">&quot;zIndex&quot;</span><span class="s1">!==e&amp;&amp;(!(</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;!Array.isArray(t))||!(</span><span class="s2">&quot;string&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t||!qt.test(t)&amp;&amp;</span><span class="s2">&quot;0&quot;</span><span class="s1">!==t||t.startsWith(</span><span class="s2">&quot;url(&quot;</span><span class="s1">)));</span><span class="s0">function </span><span class="s1">kn(t){t.duration=</span><span class="s3">0</span><span class="s1">,t.type=</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">}</span><span class="s0">const </span><span class="s1">Rn=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;opacity&quot;</span><span class="s1">,</span><span class="s2">&quot;clipPath&quot;</span><span class="s1">,</span><span class="s2">&quot;filter&quot;</span><span class="s1">,</span><span class="s2">&quot;transform&quot;</span><span class="s1">]),Ln=P(()=&gt;Object.hasOwnProperty.call(Element.prototype,</span><span class="s2">&quot;animate&quot;</span><span class="s1">));</span><span class="s0">class </span><span class="s1">jn </span><span class="s0">extends </span><span class="s1">Xe{constructor({autoplay:t=!</span><span class="s3">0</span><span class="s1">,delay:e=</span><span class="s3">0</span><span class="s1">,type:n=</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,repeat:i=</span><span class="s3">0</span><span class="s1">,repeatDelay:s=</span><span class="s3">0</span><span class="s1">,repeatType:o=</span><span class="s2">&quot;loop&quot;</span><span class="s1">,keyframes:r,name:a,motionValue:l,element:h,...u}){</span><span class="s0">super</span><span class="s1">(),</span><span class="s0">this</span><span class="s1">.stop=()=&gt;{</span><span class="s0">this</span><span class="s1">._animation&amp;&amp;(</span><span class="s0">this</span><span class="s1">._animation.stop(),</span><span class="s0">this</span><span class="s1">.stopTimeline?.()),</span><span class="s0">this</span><span class="s1">.keyframeResolver?.cancel()},</span><span class="s0">this</span><span class="s1">.createdAt=ft.now();</span><span class="s0">const </span><span class="s1">c={autoplay:t,delay:e,type:n,repeat:i,repeatDelay:s,repeatType:o,name:a,motionValue:l,element:h,...u},d=h?.KeyframeResolver||yn;</span><span class="s0">this</span><span class="s1">.keyframeResolver=</span><span class="s0">new </span><span class="s1">d(r,(t,e,n)=&gt;</span><span class="s0">this</span><span class="s1">.onKeyframesResolved(t,e,c,!n),a,l,h),</span><span class="s0">this</span><span class="s1">.keyframeResolver?.scheduleResolve()}onKeyframesResolved(t,e,n,i){</span><span class="s0">this</span><span class="s1">.keyframeResolver=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{name:s,type:o,velocity:r,delay:a,isHandoff:l,onUpdate:h}=n;</span><span class="s0">this</span><span class="s1">.resolvedAt=ft.now(),</span><span class="s0">function</span><span class="s1">(t,e,n,i){</span><span class="s0">const </span><span class="s1">s=t[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===s)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;display&quot;</span><span class="s1">===e||</span><span class="s2">&quot;visibility&quot;</span><span class="s1">===e)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">o=t[t.length-</span><span class="s3">1</span><span class="s1">],r=Dn(s,e),a=Dn(o,e);</span><span class="s0">return</span><span class="s1">!(!r||!a)&amp;&amp;(</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const </span><span class="s1">e=t[</span><span class="s3">0</span><span class="s1">];</span><span class="s0">if</span><span class="s1">(</span><span class="s3">1</span><span class="s1">===t.length)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">;n&lt;t.length;n++)</span><span class="s0">if</span><span class="s1">(t[n]!==e)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">}(t)||(</span><span class="s2">&quot;spring&quot;</span><span class="s1">===n||An(n))&amp;&amp;i)}(t,s,o,r)||(!v.instantAnimations&amp;&amp;a||h?.(We(t,n,e)),t[</span><span class="s3">0</span><span class="s1">]=t[t.length-</span><span class="s3">1</span><span class="s1">],kn(n),n.repeat=</span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">u={startTime:i?</span><span class="s0">this</span><span class="s1">.resolvedAt&amp;&amp;</span><span class="s0">this</span><span class="s1">.resolvedAt-</span><span class="s0">this</span><span class="s1">.createdAt&gt;</span><span class="s3">40</span><span class="s1">?</span><span class="s0">this</span><span class="s1">.resolvedAt:</span><span class="s0">this</span><span class="s1">.createdAt:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,finalKeyframe:e,...n,keyframes:t},c=!l&amp;&amp;</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const</span><span class="s1">{motionValue:e,name:n,repeatDelay:i,repeatType:s,damping:o,type:r}=t,a=e?.owner?.current;</span><span class="s0">if</span><span class="s1">(!(a </span><span class="s0">instanceof </span><span class="s1">HTMLElement))</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{onUpdate:l,transformTemplate:h}=e.owner.getProps();</span><span class="s0">return </span><span class="s1">Ln()&amp;&amp;n&amp;&amp;Rn.has(n)&amp;&amp;(</span><span class="s2">&quot;transform&quot;</span><span class="s1">!==n||!h)&amp;&amp;!l&amp;&amp;!i&amp;&amp;</span><span class="s2">&quot;mirror&quot;</span><span class="s1">!==s&amp;&amp;</span><span class="s3">0</span><span class="s1">!==o&amp;&amp;</span><span class="s2">&quot;inertia&quot;</span><span class="s1">!==r}(u)?</span><span class="s0">new </span><span class="s1">Cn({...u,element:u.motionValue.owner.current}):</span><span class="s0">new </span><span class="s1">ze(u);c.finished.then(()=&gt;</span><span class="s0">this</span><span class="s1">.notifyFinished()).catch(S),</span><span class="s0">this</span><span class="s1">.pendingTimeline&amp;&amp;(</span><span class="s0">this</span><span class="s1">.stopTimeline=c.attachTimeline(</span><span class="s0">this</span><span class="s1">.pendingTimeline),</span><span class="s0">this</span><span class="s1">.pendingTimeline=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">._animation=c}get finished(){</span><span class="s0">return this</span><span class="s1">._animation?</span><span class="s0">this</span><span class="s1">.animation.finished:</span><span class="s0">this</span><span class="s1">._finished}then(t,e){</span><span class="s0">return this</span><span class="s1">.finished.finally(t).then(()=&gt;{})}get animation(){</span><span class="s0">return this</span><span class="s1">._animation||(</span><span class="s0">this</span><span class="s1">.keyframeResolver?.resume(),pn=!</span><span class="s3">0</span><span class="s1">,fn(),mn(),pn=!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">._animation}get duration(){</span><span class="s0">return this</span><span class="s1">.animation.duration}get iterationDuration(){</span><span class="s0">return this</span><span class="s1">.animation.iterationDuration}get time(){</span><span class="s0">return this</span><span class="s1">.animation.time}set time(t){</span><span class="s0">this</span><span class="s1">.animation.time=t}get speed(){</span><span class="s0">return this</span><span class="s1">.animation.speed}get state(){</span><span class="s0">return this</span><span class="s1">.animation.state}set speed(t){</span><span class="s0">this</span><span class="s1">.animation.speed=t}get startTime(){</span><span class="s0">return this</span><span class="s1">.animation.startTime}attachTimeline(t){</span><span class="s0">return this</span><span class="s1">._animation?</span><span class="s0">this</span><span class="s1">.stopTimeline=</span><span class="s0">this</span><span class="s1">.animation.attachTimeline(t):</span><span class="s0">this</span><span class="s1">.pendingTimeline=t,()=&gt;</span><span class="s0">this</span><span class="s1">.stop()}play(){</span><span class="s0">this</span><span class="s1">.animation.play()}pause(){</span><span class="s0">this</span><span class="s1">.animation.pause()}complete(){</span><span class="s0">this</span><span class="s1">.animation.complete()}cancel(){</span><span class="s0">this</span><span class="s1">._animation&amp;&amp;</span><span class="s0">this</span><span class="s1">.animation.cancel(),</span><span class="s0">this</span><span class="s1">.keyframeResolver?.cancel()}}</span><span class="s0">const </span><span class="s1">Bn=</span><span class="s4">/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Fn(t,e,n=</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const</span><span class="s1">[i,s]=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const </span><span class="s1">e=Bn.exec(t);</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">return</span><span class="s1">[,];</span><span class="s0">const</span><span class="s1">[,n,i,s]=e;</span><span class="s0">return</span><span class="s1">[</span><span class="s2">`--</span><span class="s1">${n??i}</span><span class="s2">`</span><span class="s1">,s]}(t);</span><span class="s0">if</span><span class="s1">(!i)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">o=window.getComputedStyle(e).getPropertyValue(i);</span><span class="s0">if</span><span class="s1">(o){</span><span class="s0">const </span><span class="s1">t=o.trim();</span><span class="s0">return </span><span class="s1">x(t)?parseFloat(t):t}</span><span class="s0">return </span><span class="s1">xt(s)?Fn(s,e,n+</span><span class="s3">1</span><span class="s1">):s}</span><span class="s0">function </span><span class="s1">On(t,e){</span><span class="s0">return </span><span class="s1">t?.[e]??t?.default??t}</span><span class="s0">const </span><span class="s1">In=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;width&quot;</span><span class="s1">,</span><span class="s2">&quot;height&quot;</span><span class="s1">,</span><span class="s2">&quot;top&quot;</span><span class="s1">,</span><span class="s2">&quot;left&quot;</span><span class="s1">,</span><span class="s2">&quot;right&quot;</span><span class="s1">,</span><span class="s2">&quot;bottom&quot;</span><span class="s1">,...sn]),Un=t=&gt;e=&gt;e.test(t),Nn=[wt,Bt,jt,Lt,Ot,Ft,{test:t=&gt;</span><span class="s2">&quot;auto&quot;</span><span class="s1">===t,parse:t=&gt;t}],Wn=t=&gt;Nn.find(Un(t));</span><span class="s0">function </span><span class="s1">$n(t){</span><span class="s0">return</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?</span><span class="s3">0</span><span class="s1">===t:</span><span class="s0">null</span><span class="s1">===t||(</span><span class="s2">&quot;none&quot;</span><span class="s1">===t||</span><span class="s2">&quot;0&quot;</span><span class="s1">===t||w(t))}</span><span class="s0">const </span><span class="s1">Yn=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;brightness&quot;</span><span class="s1">,</span><span class="s2">&quot;contrast&quot;</span><span class="s1">,</span><span class="s2">&quot;saturate&quot;</span><span class="s1">,</span><span class="s2">&quot;opacity&quot;</span><span class="s1">]);</span><span class="s0">function </span><span class="s1">Xn(t){</span><span class="s0">const</span><span class="s1">[e,n]=t.slice(</span><span class="s3">0</span><span class="s1">,-</span><span class="s3">1</span><span class="s1">).split(</span><span class="s2">&quot;(&quot;</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;drop-shadow&quot;</span><span class="s1">===e)</span><span class="s0">return </span><span class="s1">t;</span><span class="s0">const</span><span class="s1">[i]=n.match(At)||[];</span><span class="s0">if</span><span class="s1">(!i)</span><span class="s0">return </span><span class="s1">t;</span><span class="s0">const </span><span class="s1">s=n.replace(i,</span><span class="s2">&quot;&quot;</span><span class="s1">);</span><span class="s0">let </span><span class="s1">o=Yn.has(e)?</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">;</span><span class="s0">return </span><span class="s1">i!==n&amp;&amp;(o*=</span><span class="s3">100</span><span class="s1">),e+</span><span class="s2">&quot;(&quot;</span><span class="s1">+o+s+</span><span class="s2">&quot;)&quot;</span><span class="s1">}</span><span class="s0">const </span><span class="s1">Kn=</span><span class="s4">/\b([a-z-]*)\(.*?\)/gu</span><span class="s1">,zn={...qt,getAnimatableNone:t=&gt;{</span><span class="s0">const </span><span class="s1">e=t.match(Kn);</span><span class="s0">return </span><span class="s1">e?e.map(Xn).join(</span><span class="s2">&quot; &quot;</span><span class="s1">):t}},Hn={...wt,transform:Math.round},Gn={borderWidth:Bt,borderTopWidth:Bt,borderRightWidth:Bt,borderBottomWidth:Bt,borderLeftWidth:Bt,borderRadius:Bt,radius:Bt,borderTopLeftRadius:Bt,borderTopRightRadius:Bt,borderBottomRightRadius:Bt,borderBottomLeftRadius:Bt,width:Bt,maxWidth:Bt,height:Bt,maxHeight:Bt,top:Bt,right:Bt,bottom:Bt,left:Bt,padding:Bt,paddingTop:Bt,paddingRight:Bt,paddingBottom:Bt,paddingLeft:Bt,margin:Bt,marginTop:Bt,marginRight:Bt,marginBottom:Bt,marginLeft:Bt,backgroundPositionX:Bt,backgroundPositionY:Bt,...{rotate:Lt,rotateX:Lt,rotateY:Lt,rotateZ:Lt,scale:St,scaleX:St,scaleY:St,scaleZ:St,skew:Lt,skewX:Lt,skewY:Lt,distance:Bt,translateX:Bt,translateY:Bt,translateZ:Bt,x:Bt,y:Bt,z:Bt,perspective:Bt,transformPerspective:Bt,opacity:Pt,originX:It,originY:It,originZ:Bt},zIndex:Hn,fillOpacity:Pt,strokeOpacity:Pt,numOctaves:Hn},qn={...Gn,color:Nt,backgroundColor:Nt,outlineColor:Nt,fill:Nt,stroke:Nt,borderColor:Nt,borderTopColor:Nt,borderRightColor:Nt,borderBottomColor:Nt,borderLeftColor:Nt,filter:zn,WebkitFilter:zn},Zn=t=&gt;qn[t];</span><span class="s0">function </span><span class="s1">_n(t,e){</span><span class="s0">let </span><span class="s1">n=Zn(t);</span><span class="s0">return </span><span class="s1">n!==zn&amp;&amp;(n=qt),n.getAnimatableNone?n.getAnimatableNone(e):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">Jn=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;auto&quot;</span><span class="s1">,</span><span class="s2">&quot;none&quot;</span><span class="s1">,</span><span class="s2">&quot;0&quot;</span><span class="s1">]);</span><span class="s0">class </span><span class="s1">Qn </span><span class="s0">extends </span><span class="s1">yn{constructor(t,e,n,i,s){</span><span class="s0">super</span><span class="s1">(t,e,n,i,s,!</span><span class="s3">0</span><span class="s1">)}readKeyframes(){</span><span class="s0">const</span><span class="s1">{unresolvedKeyframes:t,element:e,name:n}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!e||!e.current)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">super</span><span class="s1">.readKeyframes();</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">;n&lt;t.length;n++){</span><span class="s0">let </span><span class="s1">i=t[n];</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">i&amp;&amp;(i=i.trim(),xt(i))){</span><span class="s0">const </span><span class="s1">s=Fn(i,e.current);</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s&amp;&amp;(t[n]=s),n===t.length-</span><span class="s3">1</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.finalKeyframe=i)}}</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.resolveNoneKeyframes(),!In.has(n)||</span><span class="s3">2</span><span class="s1">!==t.length)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">[i,s]=t,o=Wn(i),r=Wn(s);</span><span class="s0">if</span><span class="s1">(o!==r)</span><span class="s0">if</span><span class="s1">(rn(o)&amp;&amp;rn(r))</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;t.length;e++){</span><span class="s0">const </span><span class="s1">n=t[e];</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n&amp;&amp;(t[e]=parseFloat(n))}</span><span class="s0">else </span><span class="s1">hn[n]&amp;&amp;(</span><span class="s0">this</span><span class="s1">.needsMeasurement=!</span><span class="s3">0</span><span class="s1">)}resolveNoneKeyframes(){</span><span class="s0">const</span><span class="s1">{unresolvedKeyframes:t,name:e}=</span><span class="s0">this</span><span class="s1">,n=[];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;t.length;e++)(</span><span class="s0">null</span><span class="s1">===t[e]||$n(t[e]))&amp;&amp;n.push(e);n.length&amp;&amp;</span><span class="s0">function</span><span class="s1">(t,e,n){</span><span class="s0">let </span><span class="s1">i,s=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(;s&lt;t.length&amp;&amp;!i;){</span><span class="s0">const </span><span class="s1">e=t[s];</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;!Jn.has(e)&amp;&amp;Kt(e).values.length&amp;&amp;(i=t[s]),s++}</span><span class="s0">if</span><span class="s1">(i&amp;&amp;n)</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">s of e)t[s]=_n(n,i)}(t,n,e)}measureInitialState(){</span><span class="s0">const</span><span class="s1">{element:t,unresolvedKeyframes:e,name:n}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!t||!t.current)</span><span class="s0">return</span><span class="s1">;</span><span class="s2">&quot;height&quot;</span><span class="s1">===n&amp;&amp;(</span><span class="s0">this</span><span class="s1">.suspendedScrollY=window.pageYOffset),</span><span class="s0">this</span><span class="s1">.measuredOrigin=hn[n](t.measureViewportBox(),window.getComputedStyle(t.current)),e[</span><span class="s3">0</span><span class="s1">]=</span><span class="s0">this</span><span class="s1">.measuredOrigin;</span><span class="s0">const </span><span class="s1">i=e[e.length-</span><span class="s3">1</span><span class="s1">];</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==i&amp;&amp;t.getValue(n,i).jump(i,!</span><span class="s3">1</span><span class="s1">)}measureEndState(){</span><span class="s0">const</span><span class="s1">{element:t,name:e,unresolvedKeyframes:n}=</span><span class="s0">this</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!t||!t.current)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=t.getValue(e);i&amp;&amp;i.jump(</span><span class="s0">this</span><span class="s1">.measuredOrigin,!</span><span class="s3">1</span><span class="s1">);</span><span class="s0">const </span><span class="s1">s=n.length-</span><span class="s3">1</span><span class="s1">,o=n[s];n[s]=hn[e](t.measureViewportBox(),window.getComputedStyle(t.current)),</span><span class="s0">null</span><span class="s1">!==o&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.finalKeyframe&amp;&amp;(</span><span class="s0">this</span><span class="s1">.finalKeyframe=o),</span><span class="s0">this</span><span class="s1">.removedTransforms?.length&amp;&amp;</span><span class="s0">this</span><span class="s1">.removedTransforms.forEach(([e,n])=&gt;{t.getValue(e).set(n)}),</span><span class="s0">this</span><span class="s1">.resolveNoneKeyframes()}}</span><span class="s0">const </span><span class="s1">ti=(t,e)=&gt;e&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?e.transform(t):t;</span><span class="s0">class </span><span class="s1">ei{constructor(t,e={}){</span><span class="s0">this</span><span class="s1">.canTrackVelocity=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.events={},</span><span class="s0">this</span><span class="s1">.updateAndNotify=t=&gt;{</span><span class="s0">const </span><span class="s1">e=ft.now();</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.updatedAt!==e&amp;&amp;</span><span class="s0">this</span><span class="s1">.setPrevFrameValue(),</span><span class="s0">this</span><span class="s1">.prev=</span><span class="s0">this</span><span class="s1">.current,</span><span class="s0">this</span><span class="s1">.setCurrent(t),</span><span class="s0">this</span><span class="s1">.current!==</span><span class="s0">this</span><span class="s1">.prev&amp;&amp;(</span><span class="s0">this</span><span class="s1">.events.change?.notify(</span><span class="s0">this</span><span class="s1">.current),</span><span class="s0">this</span><span class="s1">.dependents))</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t of </span><span class="s0">this</span><span class="s1">.dependents)t.dirty()},</span><span class="s0">this</span><span class="s1">.hasAnimated=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.setCurrent(t),</span><span class="s0">this</span><span class="s1">.owner=e.owner}setCurrent(t){</span><span class="s0">var </span><span class="s1">e;</span><span class="s0">this</span><span class="s1">.current=t,</span><span class="s0">this</span><span class="s1">.updatedAt=ft.now(),</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.canTrackVelocity&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.canTrackVelocity=(e=</span><span class="s0">this</span><span class="s1">.current,!isNaN(parseFloat(e))))}setPrevFrameValue(t=</span><span class="s0">this</span><span class="s1">.current){</span><span class="s0">this</span><span class="s1">.prevFrameValue=t,</span><span class="s0">this</span><span class="s1">.prevUpdatedAt=</span><span class="s0">this</span><span class="s1">.updatedAt}onChange(t){</span><span class="s0">return this</span><span class="s1">.on(</span><span class="s2">&quot;change&quot;</span><span class="s1">,t)}on(t,e){</span><span class="s0">this</span><span class="s1">.events[t]||(</span><span class="s0">this</span><span class="s1">.events[t]=</span><span class="s0">new </span><span class="s1">V);</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.events[t].add(e);</span><span class="s0">return</span><span class="s2">&quot;change&quot;</span><span class="s1">===t?()=&gt;{n(),ht.read(()=&gt;{</span><span class="s0">this</span><span class="s1">.events.change.getSize()||</span><span class="s0">this</span><span class="s1">.stop()})}:n}clearListeners(){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in this</span><span class="s1">.events)</span><span class="s0">this</span><span class="s1">.events[t].clear()}attach(t,e){</span><span class="s0">this</span><span class="s1">.passiveEffect=t,</span><span class="s0">this</span><span class="s1">.stopPassiveEffect=e}set(t){</span><span class="s0">this</span><span class="s1">.passiveEffect?</span><span class="s0">this</span><span class="s1">.passiveEffect(t,</span><span class="s0">this</span><span class="s1">.updateAndNotify):</span><span class="s0">this</span><span class="s1">.updateAndNotify(t)}setWithVelocity(t,e,n){</span><span class="s0">this</span><span class="s1">.set(e),</span><span class="s0">this</span><span class="s1">.prev=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.prevFrameValue=t,</span><span class="s0">this</span><span class="s1">.prevUpdatedAt=</span><span class="s0">this</span><span class="s1">.updatedAt-n}jump(t,e=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">this</span><span class="s1">.updateAndNotify(t),</span><span class="s0">this</span><span class="s1">.prev=t,</span><span class="s0">this</span><span class="s1">.prevUpdatedAt=</span><span class="s0">this</span><span class="s1">.prevFrameValue=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,e&amp;&amp;</span><span class="s0">this</span><span class="s1">.stop(),</span><span class="s0">this</span><span class="s1">.stopPassiveEffect&amp;&amp;</span><span class="s0">this</span><span class="s1">.stopPassiveEffect()}dirty(){</span><span class="s0">this</span><span class="s1">.events.change?.notify(</span><span class="s0">this</span><span class="s1">.current)}addDependent(t){</span><span class="s0">this</span><span class="s1">.dependents||(</span><span class="s0">this</span><span class="s1">.dependents=</span><span class="s0">new </span><span class="s1">Set),</span><span class="s0">this</span><span class="s1">.dependents.add(t)}removeDependent(t){</span><span class="s0">this</span><span class="s1">.dependents&amp;&amp;</span><span class="s0">this</span><span class="s1">.dependents.delete(t)}get(){</span><span class="s0">return this</span><span class="s1">.current}getPrevious(){</span><span class="s0">return this</span><span class="s1">.prev}getVelocity(){</span><span class="s0">const </span><span class="s1">t=ft.now();</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.canTrackVelocity||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.prevFrameValue||t-</span><span class="s0">this</span><span class="s1">.updatedAt&gt;</span><span class="s3">30</span><span class="s1">)</span><span class="s0">return </span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">e=Math.min(</span><span class="s0">this</span><span class="s1">.updatedAt-</span><span class="s0">this</span><span class="s1">.prevUpdatedAt,</span><span class="s3">30</span><span class="s1">);</span><span class="s0">return </span><span class="s1">D(parseFloat(</span><span class="s0">this</span><span class="s1">.current)-parseFloat(</span><span class="s0">this</span><span class="s1">.prevFrameValue),e)}start(t){</span><span class="s0">return this</span><span class="s1">.stop(),</span><span class="s0">new </span><span class="s1">Promise(e=&gt;{</span><span class="s0">this</span><span class="s1">.hasAnimated=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.animation=t(e),</span><span class="s0">this</span><span class="s1">.events.animationStart&amp;&amp;</span><span class="s0">this</span><span class="s1">.events.animationStart.notify()}).then(()=&gt;{</span><span class="s0">this</span><span class="s1">.events.animationComplete&amp;&amp;</span><span class="s0">this</span><span class="s1">.events.animationComplete.notify(),</span><span class="s0">this</span><span class="s1">.clearAnimation()})}stop(){</span><span class="s0">this</span><span class="s1">.animation&amp;&amp;(</span><span class="s0">this</span><span class="s1">.animation.stop(),</span><span class="s0">this</span><span class="s1">.events.animationCancel&amp;&amp;</span><span class="s0">this</span><span class="s1">.events.animationCancel.notify()),</span><span class="s0">this</span><span class="s1">.clearAnimation()}isAnimating(){</span><span class="s0">return</span><span class="s1">!!</span><span class="s0">this</span><span class="s1">.animation}clearAnimation(){</span><span class="s0">delete this</span><span class="s1">.animation}destroy(){</span><span class="s0">this</span><span class="s1">.dependents?.clear(),</span><span class="s0">this</span><span class="s1">.events.destroy?.notify(),</span><span class="s0">this</span><span class="s1">.clearListeners(),</span><span class="s0">this</span><span class="s1">.stop(),</span><span class="s0">this</span><span class="s1">.stopPassiveEffect&amp;&amp;</span><span class="s0">this</span><span class="s1">.stopPassiveEffect()}}</span><span class="s0">function </span><span class="s1">ni(t,e){</span><span class="s0">return new </span><span class="s1">ei(t,e)}</span><span class="s0">const</span><span class="s1">{schedule:ii,cancel:si}=lt(queueMicrotask,!</span><span class="s3">1</span><span class="s1">),oi={x:!</span><span class="s3">1</span><span class="s1">,y:!</span><span class="s3">1</span><span class="s1">};</span><span class="s0">function </span><span class="s1">ri(){</span><span class="s0">return </span><span class="s1">oi.x||oi.y}</span><span class="s0">function </span><span class="s1">ai(t,e){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">if</span><span class="s1">(t </span><span class="s0">instanceof </span><span class="s1">EventTarget)</span><span class="s0">return</span><span class="s1">[t];</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t){</span><span class="s0">const </span><span class="s1">e=document.querySelectorAll(t);</span><span class="s0">return </span><span class="s1">e?Array.from(e):[]}</span><span class="s0">return </span><span class="s1">Array.from(t)}(t),i=</span><span class="s0">new </span><span class="s1">AbortController;</span><span class="s0">return</span><span class="s1">[n,{passive:!</span><span class="s3">0</span><span class="s1">,...e,signal:i.signal},()=&gt;i.abort()]}</span><span class="s0">function </span><span class="s1">li(t){</span><span class="s0">return</span><span class="s1">!(</span><span class="s2">&quot;touch&quot;</span><span class="s1">===t.pointerType||ri())}</span><span class="s0">const </span><span class="s1">hi=(t,e)=&gt;!!e&amp;&amp;(t===e||hi(t,e.parentElement)),ui=t=&gt;</span><span class="s2">&quot;mouse&quot;</span><span class="s1">===t.pointerType?</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">t.button||t.button&lt;=</span><span class="s3">0</span><span class="s1">:!</span><span class="s3">1</span><span class="s1">!==t.isPrimary,ci=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;BUTTON&quot;</span><span class="s1">,</span><span class="s2">&quot;INPUT&quot;</span><span class="s1">,</span><span class="s2">&quot;SELECT&quot;</span><span class="s1">,</span><span class="s2">&quot;TEXTAREA&quot;</span><span class="s1">,</span><span class="s2">&quot;A&quot;</span><span class="s1">]);</span><span class="s0">const </span><span class="s1">di=</span><span class="s0">new </span><span class="s1">WeakSet;</span><span class="s0">function </span><span class="s1">pi(t){</span><span class="s0">return </span><span class="s1">e=&gt;{</span><span class="s2">&quot;Enter&quot;</span><span class="s1">===e.key&amp;&amp;t(e)}}</span><span class="s0">function </span><span class="s1">mi(t,e){t.dispatchEvent(</span><span class="s0">new </span><span class="s1">PointerEvent(</span><span class="s2">&quot;pointer&quot;</span><span class="s1">+e,{isPrimary:!</span><span class="s3">0</span><span class="s1">,bubbles:!</span><span class="s3">0</span><span class="s1">}))}</span><span class="s0">function </span><span class="s1">fi(t){</span><span class="s0">return </span><span class="s1">ui(t)&amp;&amp;!ri()}</span><span class="s0">function </span><span class="s1">yi(t,e,n={}){</span><span class="s0">const</span><span class="s1">[i,s,o]=ai(t,n),r=t=&gt;{</span><span class="s0">const </span><span class="s1">i=t.currentTarget;</span><span class="s0">if</span><span class="s1">(!fi(t))</span><span class="s0">return</span><span class="s1">;di.add(i);</span><span class="s0">const </span><span class="s1">o=e(i,t),r=(t,e)=&gt;{window.removeEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s1">,a),window.removeEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s1">,l),di.has(i)&amp;&amp;di.delete(i),fi(t)&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">o&amp;&amp;o(t,{success:e})},a=t=&gt;{r(t,i===window||i===document||n.useGlobalTarget||hi(i,t.target))},l=t=&gt;{r(t,!</span><span class="s3">1</span><span class="s1">)};window.addEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s1">,a,s),window.addEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s1">,l,s)};</span><span class="s0">return </span><span class="s1">i.forEach(t=&gt;{</span><span class="s0">var </span><span class="s1">e;(n.useGlobalTarget?window:t).addEventListener(</span><span class="s2">&quot;pointerdown&quot;</span><span class="s1">,r,s),T(e=t)&amp;&amp;</span><span class="s2">&quot;offsetHeight&quot;</span><span class="s0">in </span><span class="s1">e&amp;&amp;(t.addEventListener(</span><span class="s2">&quot;focus&quot;</span><span class="s1">,t=&gt;((t,e)=&gt;{</span><span class="s0">const </span><span class="s1">n=t.currentTarget;</span><span class="s0">if</span><span class="s1">(!n)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=pi(()=&gt;{</span><span class="s0">if</span><span class="s1">(di.has(n))</span><span class="s0">return</span><span class="s1">;mi(n,</span><span class="s2">&quot;down&quot;</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=pi(()=&gt;{mi(n,</span><span class="s2">&quot;up&quot;</span><span class="s1">)});n.addEventListener(</span><span class="s2">&quot;keyup&quot;</span><span class="s1">,t,e),n.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s1">,()=&gt;mi(n,</span><span class="s2">&quot;cancel&quot;</span><span class="s1">),e)});n.addEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s1">,i,e),n.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s1">,()=&gt;n.removeEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s1">,i),e)})(t,s)),</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">return </span><span class="s1">ci.has(t.tagName)||-</span><span class="s3">1</span><span class="s1">!==t.tabIndex}(t)||t.hasAttribute(</span><span class="s2">&quot;tabindex&quot;</span><span class="s1">)||(t.tabIndex=</span><span class="s3">0</span><span class="s1">))}),o}</span><span class="s0">function </span><span class="s1">gi(t){</span><span class="s0">return </span><span class="s1">T(t)&amp;&amp;</span><span class="s2">&quot;ownerSVGElement&quot;</span><span class="s0">in </span><span class="s1">t}</span><span class="s0">const </span><span class="s1">vi=t=&gt;Boolean(t&amp;&amp;t.getVelocity),xi=[...Nn,Nt,qt],Ti={};</span><span class="s0">function </span><span class="s1">wi(t,{layout:e,layoutId:n}){</span><span class="s0">return </span><span class="s1">on.has(t)||t.startsWith(</span><span class="s2">&quot;origin&quot;</span><span class="s1">)||(e||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n)&amp;&amp;(!!Ti[t]||</span><span class="s2">&quot;opacity&quot;</span><span class="s1">===t)}</span><span class="s0">const </span><span class="s1">Pi={x:</span><span class="s2">&quot;translateX&quot;</span><span class="s1">,y:</span><span class="s2">&quot;translateY&quot;</span><span class="s1">,z:</span><span class="s2">&quot;translateZ&quot;</span><span class="s1">,transformPerspective:</span><span class="s2">&quot;perspective&quot;</span><span class="s1">},Si=sn.length;</span><span class="s0">function </span><span class="s1">bi(t,e,n){</span><span class="s0">const</span><span class="s1">{style:i,vars:s,transformOrigin:o}=t;</span><span class="s0">let </span><span class="s1">r=!</span><span class="s3">1</span><span class="s1">,a=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">e){</span><span class="s0">const </span><span class="s1">n=e[t];</span><span class="s0">if</span><span class="s1">(on.has(t))r=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">else if</span><span class="s1">(gt(t))s[t]=n;</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">e=ti(n,Gn[t]);t.startsWith(</span><span class="s2">&quot;origin&quot;</span><span class="s1">)?(a=!</span><span class="s3">0</span><span class="s1">,o[t]=e):i[t]=e}}</span><span class="s0">if</span><span class="s1">(e.transform||(r||n?i.transform=</span><span class="s0">function</span><span class="s1">(t,e,n){</span><span class="s0">let </span><span class="s1">i=</span><span class="s2">&quot;&quot;</span><span class="s1">,s=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">o=</span><span class="s3">0</span><span class="s1">;o&lt;Si;o++){</span><span class="s0">const </span><span class="s1">r=sn[o],a=t[r];</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===a)</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">let </span><span class="s1">l=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(l=</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">a?a===(r.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s1">)?</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">):</span><span class="s3">0</span><span class="s1">===parseFloat(a),!l||n){</span><span class="s0">const </span><span class="s1">t=ti(a,Gn[r]);l||(s=!</span><span class="s3">1</span><span class="s1">,i+=</span><span class="s2">`</span><span class="s1">${Pi[r]||r}</span><span class="s2">(</span><span class="s1">${t}</span><span class="s2">) `</span><span class="s1">),n&amp;&amp;(e[r]=t)}}</span><span class="s0">return </span><span class="s1">i=i.trim(),n?i=n(e,s?</span><span class="s2">&quot;&quot;</span><span class="s1">:i):s&amp;&amp;(i=</span><span class="s2">&quot;none&quot;</span><span class="s1">),i}(e,t.transform,n):i.transform&amp;&amp;(i.transform=</span><span class="s2">&quot;none&quot;</span><span class="s1">)),a){</span><span class="s0">const</span><span class="s1">{originX:t=</span><span class="s2">&quot;50%&quot;</span><span class="s1">,originY:e=</span><span class="s2">&quot;50%&quot;</span><span class="s1">,originZ:n=</span><span class="s3">0</span><span class="s1">}=o;i.transformOrigin=</span><span class="s2">`</span><span class="s1">${t} ${e} ${n}</span><span class="s2">`</span><span class="s1">}}</span><span class="s0">const </span><span class="s1">Ai=()=&gt;({style:{},transform:{},transformOrigin:{},vars:{}});</span><span class="s0">function </span><span class="s1">Ei(t,e,n){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">i </span><span class="s0">in </span><span class="s1">e)vi(e[i])||wi(i,n)||(t[i]=e[i])}</span><span class="s0">function </span><span class="s1">Vi(t,e){</span><span class="s0">const </span><span class="s1">n={};</span><span class="s0">return </span><span class="s1">Ei(n,t.style||{},t),Object.assign(n,</span><span class="s0">function</span><span class="s1">({transformTemplate:t},e){</span><span class="s0">return </span><span class="s1">s(()=&gt;{</span><span class="s0">const </span><span class="s1">n={style:{},transform:{},transformOrigin:{},vars:{}};</span><span class="s0">return </span><span class="s1">bi(n,e,t),Object.assign({},n.vars,n.style)},[e])}(t,e)),n}</span><span class="s0">function </span><span class="s1">Mi(t,e){</span><span class="s0">const </span><span class="s1">n={},i=Vi(t,e);</span><span class="s0">return </span><span class="s1">t.drag&amp;&amp;!</span><span class="s3">1</span><span class="s1">!==t.dragListener&amp;&amp;(n.draggable=!</span><span class="s3">1</span><span class="s1">,i.userSelect=i.WebkitUserSelect=i.WebkitTouchCallout=</span><span class="s2">&quot;none&quot;</span><span class="s1">,i.touchAction=!</span><span class="s3">0</span><span class="s1">===t.drag?</span><span class="s2">&quot;none&quot;</span><span class="s1">:</span><span class="s2">&quot;pan-&quot;</span><span class="s1">+(</span><span class="s2">&quot;x&quot;</span><span class="s1">===t.drag?</span><span class="s2">&quot;y&quot;</span><span class="s1">:</span><span class="s2">&quot;x&quot;</span><span class="s1">)),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===t.tabIndex&amp;&amp;(t.onTap||t.onTapStart||t.whileTap)&amp;&amp;(n.tabIndex=</span><span class="s3">0</span><span class="s1">),n.style=i,n}</span><span class="s0">const </span><span class="s1">Ci={offset:</span><span class="s2">&quot;stroke-dashoffset&quot;</span><span class="s1">,array:</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s1">},Di={offset:</span><span class="s2">&quot;strokeDashoffset&quot;</span><span class="s1">,array:</span><span class="s2">&quot;strokeDasharray&quot;</span><span class="s1">};</span><span class="s0">function </span><span class="s1">ki(t,{attrX:e,attrY:n,attrScale:i,pathLength:s,pathSpacing:o=</span><span class="s3">1</span><span class="s1">,pathOffset:r=</span><span class="s3">0</span><span class="s1">,...a},l,h,u){</span><span class="s0">if</span><span class="s1">(bi(t,a,h),l)</span><span class="s0">return void</span><span class="s1">(t.style.viewBox&amp;&amp;(t.attrs.viewBox=t.style.viewBox));t.attrs=t.style,t.style={};</span><span class="s0">const</span><span class="s1">{attrs:c,style:d}=t;c.transform&amp;&amp;(d.transform=c.transform,</span><span class="s0">delete </span><span class="s1">c.transform),(d.transform||c.transformOrigin)&amp;&amp;(d.transformOrigin=c.transformOrigin??</span><span class="s2">&quot;50% 50%&quot;</span><span class="s1">,</span><span class="s0">delete </span><span class="s1">c.transformOrigin),d.transform&amp;&amp;(d.transformBox=u?.transformBox??</span><span class="s2">&quot;fill-box&quot;</span><span class="s1">,</span><span class="s0">delete </span><span class="s1">c.transformBox),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e&amp;&amp;(c.x=e),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n&amp;&amp;(c.y=n),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==i&amp;&amp;(c.scale=i),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s&amp;&amp;</span><span class="s0">function</span><span class="s1">(t,e,n=</span><span class="s3">1</span><span class="s1">,i=</span><span class="s3">0</span><span class="s1">,s=!</span><span class="s3">0</span><span class="s1">){t.pathLength=</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">o=s?Ci:Di;t[o.offset]=Bt.transform(-i);</span><span class="s0">const </span><span class="s1">r=Bt.transform(e),a=Bt.transform(n);t[o.array]=</span><span class="s2">`</span><span class="s1">${r} ${a}</span><span class="s2">`</span><span class="s1">}(c,s,o,r,!</span><span class="s3">1</span><span class="s1">)}</span><span class="s0">const </span><span class="s1">Ri=()=&gt;({style:{},transform:{},transformOrigin:{},vars:{},attrs:{}}),Li=t=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;</span><span class="s2">&quot;svg&quot;</span><span class="s1">===t.toLowerCase();</span><span class="s0">function </span><span class="s1">ji(t,e,n,i){</span><span class="s0">const </span><span class="s1">o=s(()=&gt;{</span><span class="s0">const </span><span class="s1">n={style:{},transform:{},transformOrigin:{},vars:{},attrs:{}};</span><span class="s0">return </span><span class="s1">ki(n,e,Li(i),t.transformTemplate,t.style),{...n.attrs,style:{...n.style}}},[e]);</span><span class="s0">if</span><span class="s1">(t.style){</span><span class="s0">const </span><span class="s1">e={};Ei(e,t.style,t),o.style={...e,...o.style}}</span><span class="s0">return </span><span class="s1">o}</span><span class="s0">const </span><span class="s1">Bi=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;animate&quot;</span><span class="s1">,</span><span class="s2">&quot;exit&quot;</span><span class="s1">,</span><span class="s2">&quot;variants&quot;</span><span class="s1">,</span><span class="s2">&quot;initial&quot;</span><span class="s1">,</span><span class="s2">&quot;style&quot;</span><span class="s1">,</span><span class="s2">&quot;values&quot;</span><span class="s1">,</span><span class="s2">&quot;variants&quot;</span><span class="s1">,</span><span class="s2">&quot;transition&quot;</span><span class="s1">,</span><span class="s2">&quot;transformTemplate&quot;</span><span class="s1">,</span><span class="s2">&quot;custom&quot;</span><span class="s1">,</span><span class="s2">&quot;inherit&quot;</span><span class="s1">,</span><span class="s2">&quot;onBeforeLayoutMeasure&quot;</span><span class="s1">,</span><span class="s2">&quot;onAnimationStart&quot;</span><span class="s1">,</span><span class="s2">&quot;onAnimationComplete&quot;</span><span class="s1">,</span><span class="s2">&quot;onUpdate&quot;</span><span class="s1">,</span><span class="s2">&quot;onDragStart&quot;</span><span class="s1">,</span><span class="s2">&quot;onDrag&quot;</span><span class="s1">,</span><span class="s2">&quot;onDragEnd&quot;</span><span class="s1">,</span><span class="s2">&quot;onMeasureDragConstraints&quot;</span><span class="s1">,</span><span class="s2">&quot;onDirectionLock&quot;</span><span class="s1">,</span><span class="s2">&quot;onDragTransitionEnd&quot;</span><span class="s1">,</span><span class="s2">&quot;_dragX&quot;</span><span class="s1">,</span><span class="s2">&quot;_dragY&quot;</span><span class="s1">,</span><span class="s2">&quot;onHoverStart&quot;</span><span class="s1">,</span><span class="s2">&quot;onHoverEnd&quot;</span><span class="s1">,</span><span class="s2">&quot;onViewportEnter&quot;</span><span class="s1">,</span><span class="s2">&quot;onViewportLeave&quot;</span><span class="s1">,</span><span class="s2">&quot;globalTapTarget&quot;</span><span class="s1">,</span><span class="s2">&quot;ignoreStrict&quot;</span><span class="s1">,</span><span class="s2">&quot;viewport&quot;</span><span class="s1">]);</span><span class="s0">function </span><span class="s1">Fi(t){</span><span class="s0">return </span><span class="s1">t.startsWith(</span><span class="s2">&quot;while&quot;</span><span class="s1">)||t.startsWith(</span><span class="s2">&quot;drag&quot;</span><span class="s1">)&amp;&amp;</span><span class="s2">&quot;draggable&quot;</span><span class="s1">!==t||t.startsWith(</span><span class="s2">&quot;layout&quot;</span><span class="s1">)||t.startsWith(</span><span class="s2">&quot;onTap&quot;</span><span class="s1">)||t.startsWith(</span><span class="s2">&quot;onPan&quot;</span><span class="s1">)||t.startsWith(</span><span class="s2">&quot;onLayout&quot;</span><span class="s1">)||Bi.has(t)}</span><span class="s0">let </span><span class="s1">Oi=t=&gt;!Fi(t);</span><span class="s0">try</span><span class="s1">{</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof</span><span class="s1">(Ii=require(</span><span class="s2">&quot;@emotion/is-prop-valid&quot;</span><span class="s1">).default)&amp;&amp;(Oi=t=&gt;t.startsWith(</span><span class="s2">&quot;on&quot;</span><span class="s1">)?!Fi(t):Ii(t))}</span><span class="s0">catch</span><span class="s1">{}</span><span class="s0">var </span><span class="s1">Ii;</span><span class="s0">const </span><span class="s1">Ui=[</span><span class="s2">&quot;animate&quot;</span><span class="s1">,</span><span class="s2">&quot;circle&quot;</span><span class="s1">,</span><span class="s2">&quot;defs&quot;</span><span class="s1">,</span><span class="s2">&quot;desc&quot;</span><span class="s1">,</span><span class="s2">&quot;ellipse&quot;</span><span class="s1">,</span><span class="s2">&quot;g&quot;</span><span class="s1">,</span><span class="s2">&quot;image&quot;</span><span class="s1">,</span><span class="s2">&quot;line&quot;</span><span class="s1">,</span><span class="s2">&quot;filter&quot;</span><span class="s1">,</span><span class="s2">&quot;marker&quot;</span><span class="s1">,</span><span class="s2">&quot;mask&quot;</span><span class="s1">,</span><span class="s2">&quot;metadata&quot;</span><span class="s1">,</span><span class="s2">&quot;path&quot;</span><span class="s1">,</span><span class="s2">&quot;pattern&quot;</span><span class="s1">,</span><span class="s2">&quot;polygon&quot;</span><span class="s1">,</span><span class="s2">&quot;polyline&quot;</span><span class="s1">,</span><span class="s2">&quot;rect&quot;</span><span class="s1">,</span><span class="s2">&quot;stop&quot;</span><span class="s1">,</span><span class="s2">&quot;switch&quot;</span><span class="s1">,</span><span class="s2">&quot;symbol&quot;</span><span class="s1">,</span><span class="s2">&quot;svg&quot;</span><span class="s1">,</span><span class="s2">&quot;text&quot;</span><span class="s1">,</span><span class="s2">&quot;tspan&quot;</span><span class="s1">,</span><span class="s2">&quot;use&quot;</span><span class="s1">,</span><span class="s2">&quot;view&quot;</span><span class="s1">];</span><span class="s0">function </span><span class="s1">Ni(t){</span><span class="s0">return</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;!t.includes(</span><span class="s2">&quot;-&quot;</span><span class="s1">)&amp;&amp;!!(Ui.indexOf(t)&gt;-</span><span class="s3">1</span><span class="s1">||</span><span class="s4">/[A-Z]/u</span><span class="s1">.test(t))}</span><span class="s0">function </span><span class="s1">Wi(t,e,n,{latestValues:i},a,l=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">h=(Ni(t)?ji:Mi)(e,i,a,t),u=</span><span class="s0">function</span><span class="s1">(t,e,n){</span><span class="s0">const </span><span class="s1">i={};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">s </span><span class="s0">in </span><span class="s1">t)</span><span class="s2">&quot;values&quot;</span><span class="s1">===s&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t.values||(Oi(s)||!</span><span class="s3">0</span><span class="s1">===n&amp;&amp;Fi(s)||!e&amp;&amp;!Fi(s)||t.draggable&amp;&amp;s.startsWith(</span><span class="s2">&quot;onDrag&quot;</span><span class="s1">))&amp;&amp;(i[s]=t[s]);</span><span class="s0">return </span><span class="s1">i}(e,</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t,l),c=t!==o?{...u,...h,ref:n}:{},{children:d}=e,p=s(()=&gt;vi(d)?d.get():d,[d]);</span><span class="s0">return </span><span class="s1">r(t,{...c,children:p})}</span><span class="s0">const </span><span class="s1">$i=n(</span><span class="s0">null</span><span class="s1">);</span><span class="s0">function </span><span class="s1">Yi(t){</span><span class="s0">const </span><span class="s1">e=[{},{}];</span><span class="s0">return </span><span class="s1">t?.values.forEach((t,n)=&gt;{e[</span><span class="s3">0</span><span class="s1">][n]=t.get(),e[</span><span class="s3">1</span><span class="s1">][n]=t.getVelocity()}),e}</span><span class="s0">function </span><span class="s1">Xi(t,e,n,i){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e){</span><span class="s0">const</span><span class="s1">[s,o]=Yi(i);e=e(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n?n:t.custom,s,o)}</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;(e=t.variants&amp;&amp;t.variants[e]),</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e){</span><span class="s0">const</span><span class="s1">[s,o]=Yi(i);e=e(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n?n:t.custom,s,o)}</span><span class="s0">return </span><span class="s1">e}</span><span class="s0">function </span><span class="s1">Ki(t){</span><span class="s0">return </span><span class="s1">vi(t)?t.get():t}</span><span class="s0">function </span><span class="s1">zi(t,e,n,i){</span><span class="s0">const </span><span class="s1">s={},o=i(t,{});</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">o)s[t]=Ki(o[t]);</span><span class="s0">let</span><span class="s1">{initial:r,animate:a}=t;</span><span class="s0">const </span><span class="s1">l=nt(t),h=it(t);e&amp;&amp;h&amp;&amp;!l&amp;&amp;!</span><span class="s3">1</span><span class="s1">!==t.inherit&amp;&amp;(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===r&amp;&amp;(r=e.initial),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===a&amp;&amp;(a=e.animate));</span><span class="s0">let </span><span class="s1">u=!!n&amp;&amp;!</span><span class="s3">1</span><span class="s1">===n.initial;u=u||!</span><span class="s3">1</span><span class="s1">===r;</span><span class="s0">const </span><span class="s1">c=u?a:r;</span><span class="s0">if</span><span class="s1">(c&amp;&amp;</span><span class="s2">&quot;boolean&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">c&amp;&amp;!J(c)){</span><span class="s0">const </span><span class="s1">e=Array.isArray(c)?c:[c];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">;n&lt;e.length;n++){</span><span class="s0">const </span><span class="s1">i=Xi(t,e[n]);</span><span class="s0">if</span><span class="s1">(i){</span><span class="s0">const</span><span class="s1">{transitionEnd:t,transition:e,...n}=i;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">n){</span><span class="s0">let </span><span class="s1">e=n[t];</span><span class="s0">if</span><span class="s1">(Array.isArray(e)){e=e[u?e.length-</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">]}</span><span class="s0">null</span><span class="s1">!==e&amp;&amp;(s[t]=e)}</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">t)s[e]=t[e]}}}</span><span class="s0">return </span><span class="s1">s}</span><span class="s0">const </span><span class="s1">Hi=t=&gt;(e,n)=&gt;{</span><span class="s0">const </span><span class="s1">s=i(_),o=i($i),r=()=&gt;</span><span class="s0">function</span><span class="s1">({scrapeMotionValuesFromProps:t,createRenderState:e},n,i,s){</span><span class="s0">return</span><span class="s1">{latestValues:zi(n,i,s,t),renderState:e()}}(t,e,s,o);</span><span class="s0">return </span><span class="s1">n?r():</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const </span><span class="s1">e=a(</span><span class="s0">null</span><span class="s1">);</span><span class="s0">return null</span><span class="s1">===e.current&amp;&amp;(e.current=t()),e.current}(r)};</span><span class="s0">function </span><span class="s1">Gi(t,e,n){</span><span class="s0">const</span><span class="s1">{style:i}=t,s={};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">o </span><span class="s0">in </span><span class="s1">i)(vi(i[o])||e.style&amp;&amp;vi(e.style[o])||wi(o,t)||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n?.getValue(o)?.liveStyle)&amp;&amp;(s[o]=i[o]);</span><span class="s0">return </span><span class="s1">s}</span><span class="s0">const </span><span class="s1">qi=Hi({scrapeMotionValuesFromProps:Gi,createRenderState:Ai});</span><span class="s0">function </span><span class="s1">Zi(t,e,n){</span><span class="s0">const </span><span class="s1">i=Gi(t,e,n);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">n </span><span class="s0">in </span><span class="s1">t)</span><span class="s0">if</span><span class="s1">(vi(t[n])||vi(e[n])){i[-</span><span class="s3">1</span><span class="s1">!==sn.indexOf(n)?</span><span class="s2">&quot;attr&quot;</span><span class="s1">+n.charAt(</span><span class="s3">0</span><span class="s1">).toUpperCase()+n.substring(</span><span class="s3">1</span><span class="s1">):n]=t[n]}</span><span class="s0">return </span><span class="s1">i}</span><span class="s0">const </span><span class="s1">_i=Hi({scrapeMotionValuesFromProps:Zi,createRenderState:Ri}),Ji=</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">window,Qi={animation:[</span><span class="s2">&quot;animate&quot;</span><span class="s1">,</span><span class="s2">&quot;variants&quot;</span><span class="s1">,</span><span class="s2">&quot;whileHover&quot;</span><span class="s1">,</span><span class="s2">&quot;whileTap&quot;</span><span class="s1">,</span><span class="s2">&quot;exit&quot;</span><span class="s1">,</span><span class="s2">&quot;whileInView&quot;</span><span class="s1">,</span><span class="s2">&quot;whileFocus&quot;</span><span class="s1">,</span><span class="s2">&quot;whileDrag&quot;</span><span class="s1">],exit:[</span><span class="s2">&quot;exit&quot;</span><span class="s1">],drag:[</span><span class="s2">&quot;drag&quot;</span><span class="s1">,</span><span class="s2">&quot;dragControls&quot;</span><span class="s1">],focus:[</span><span class="s2">&quot;whileFocus&quot;</span><span class="s1">],hover:[</span><span class="s2">&quot;whileHover&quot;</span><span class="s1">,</span><span class="s2">&quot;onHoverStart&quot;</span><span class="s1">,</span><span class="s2">&quot;onHoverEnd&quot;</span><span class="s1">],tap:[</span><span class="s2">&quot;whileTap&quot;</span><span class="s1">,</span><span class="s2">&quot;onTap&quot;</span><span class="s1">,</span><span class="s2">&quot;onTapStart&quot;</span><span class="s1">,</span><span class="s2">&quot;onTapCancel&quot;</span><span class="s1">],pan:[</span><span class="s2">&quot;onPan&quot;</span><span class="s1">,</span><span class="s2">&quot;onPanStart&quot;</span><span class="s1">,</span><span class="s2">&quot;onPanSessionStart&quot;</span><span class="s1">,</span><span class="s2">&quot;onPanEnd&quot;</span><span class="s1">],inView:[</span><span class="s2">&quot;whileInView&quot;</span><span class="s1">,</span><span class="s2">&quot;onViewportEnter&quot;</span><span class="s1">,</span><span class="s2">&quot;onViewportLeave&quot;</span><span class="s1">],layout:[</span><span class="s2">&quot;layout&quot;</span><span class="s1">,</span><span class="s2">&quot;layoutId&quot;</span><span class="s1">]},ts={};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">Qi)ts[t]={isEnabled:e=&gt;Qi[t].some(t=&gt;!!e[t])};</span><span class="s0">const </span><span class="s1">es=Symbol.for(</span><span class="s2">&quot;motionComponentSymbol&quot;</span><span class="s1">);</span><span class="s0">function </span><span class="s1">ns(t){</span><span class="s0">return </span><span class="s1">t&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;Object.prototype.hasOwnProperty.call(t,</span><span class="s2">&quot;current&quot;</span><span class="s1">)}</span><span class="s0">function </span><span class="s1">is(t,e,n){</span><span class="s0">return </span><span class="s1">l(i=&gt;{i&amp;&amp;t.onMount&amp;&amp;t.onMount(i),e&amp;&amp;(i?e.mount(i):e.unmount()),n&amp;&amp;(</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n?n(i):ns(n)&amp;&amp;(n.current=i))},[e])}</span><span class="s0">const </span><span class="s1">ss=t=&gt;t.replace(</span><span class="s4">/([a-z])([A-Z])/gu</span><span class="s1">,</span><span class="s2">&quot;$1-$2&quot;</span><span class="s1">).toLowerCase(),os=</span><span class="s2">&quot;data-&quot;</span><span class="s1">+ss(</span><span class="s2">&quot;framerAppearId&quot;</span><span class="s1">),rs=n({}),as=Ji?h:u;</span><span class="s0">function </span><span class="s1">ls(t,e,n,s,o){</span><span class="s0">const</span><span class="s1">{visualElement:r}=i(_),l=i(q),h=i($i),d=i(Z).reducedMotion,p=a(</span><span class="s0">null</span><span class="s1">);s=s||l.renderer,!p.current&amp;&amp;s&amp;&amp;(p.current=s(t,{visualState:e,parent:r,props:n,presenceContext:h,blockInitialAnimation:!!h&amp;&amp;!</span><span class="s3">1</span><span class="s1">===h.initial,reducedMotionConfig:d}));</span><span class="s0">const </span><span class="s1">m=p.current,f=i(rs);!m||m.projection||!o||</span><span class="s2">&quot;html&quot;</span><span class="s1">!==m.type&amp;&amp;</span><span class="s2">&quot;svg&quot;</span><span class="s1">!==m.type||</span><span class="s0">function</span><span class="s1">(t,e,n,i){</span><span class="s0">const</span><span class="s1">{layoutId:s,layout:o,drag:r,dragConstraints:a,layoutScroll:l,layoutRoot:h,layoutCrossfade:u}=e;t.projection=</span><span class="s0">new </span><span class="s1">n(t.latestValues,e[</span><span class="s2">&quot;data-framer-portal-id&quot;</span><span class="s1">]?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:hs(t.parent)),t.projection.setOptions({layoutId:s,layout:o,alwaysMeasureLayout:Boolean(r)||a&amp;&amp;ns(a),visualElement:t,animationType:</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">o?o:</span><span class="s2">&quot;both&quot;</span><span class="s1">,initialPromotionConfig:i,crossfade:u,layoutScroll:l,layoutRoot:h})}(p.current,n,o,f);</span><span class="s0">const </span><span class="s1">y=a(!</span><span class="s3">1</span><span class="s1">);c(()=&gt;{m&amp;&amp;y.current&amp;&amp;m.update(n,h)});</span><span class="s0">const </span><span class="s1">g=n[os],v=a(Boolean(g)&amp;&amp;!window.MotionHandoffIsComplete?.(g)&amp;&amp;window.MotionHasOptimisedAnimation?.(g));</span><span class="s0">return </span><span class="s1">as(()=&gt;{m&amp;&amp;(y.current=!</span><span class="s3">0</span><span class="s1">,window.MotionIsMounted=!</span><span class="s3">0</span><span class="s1">,m.updateFeatures(),m.scheduleRenderMicrotask(),v.current&amp;&amp;m.animationState&amp;&amp;m.animationState.animateChanges())}),u(()=&gt;{m&amp;&amp;(!v.current&amp;&amp;m.animationState&amp;&amp;m.animationState.animateChanges(),v.current&amp;&amp;(queueMicrotask(()=&gt;{window.MotionHandoffMarkAsComplete?.(g)}),v.current=!</span><span class="s3">1</span><span class="s1">),m.enteringChildren=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}),m}</span><span class="s0">function </span><span class="s1">hs(t){</span><span class="s0">if</span><span class="s1">(t)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">!==t.options.allowProjection?t.projection:hs(t.parent)}</span><span class="s0">function </span><span class="s1">us(n,{forwardMotionProps:s=!</span><span class="s3">1</span><span class="s1">}={},o,r){o&amp;&amp;</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">t)ts[e]={...ts[e],...t[e]}}(o);</span><span class="s0">const </span><span class="s1">a=Ni(n)?_i:qi;</span><span class="s0">function </span><span class="s1">l(o,l){</span><span class="s0">let </span><span class="s1">h;</span><span class="s0">const </span><span class="s1">u={...i(Z),...o,layoutId:cs(o)},{isStatic:c}=u,d=st(o),p=a(o,c);</span><span class="s0">if</span><span class="s1">(!c&amp;&amp;Ji){i(q).strict;</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">const</span><span class="s1">{drag:e,layout:n}=ts;</span><span class="s0">if</span><span class="s1">(!e&amp;&amp;!n)</span><span class="s0">return</span><span class="s1">{};</span><span class="s0">const </span><span class="s1">i={...e,...n};</span><span class="s0">return</span><span class="s1">{MeasureLayout:e?.isEnabled(t)||n?.isEnabled(t)?i.MeasureLayout:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,ProjectionNode:i.ProjectionNode}}(u);h=t.MeasureLayout,d.visualElement=ls(n,p,u,r,t.ProjectionNode)}</span><span class="s0">return </span><span class="s1">t(_.Provider,{value:d,children:[h&amp;&amp;d.visualElement?e(h,{visualElement:d.visualElement,...u}):</span><span class="s0">null</span><span class="s1">,Wi(n,o,is(p,d.visualElement,l),p,c,s)]})}l.displayName=</span><span class="s2">`motion.</span><span class="s1">${</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n?n:</span><span class="s2">`create(</span><span class="s1">${n.displayName??n.name??</span><span class="s2">&quot;&quot;</span><span class="s1">}</span><span class="s2">)`</span><span class="s1">}</span><span class="s2">`</span><span class="s1">;</span><span class="s0">const </span><span class="s1">h=d(l);</span><span class="s0">return </span><span class="s1">h[es]=n,h}</span><span class="s0">function </span><span class="s1">cs({layoutId:t}){</span><span class="s0">const </span><span class="s1">e=i(G).id;</span><span class="s0">return </span><span class="s1">e&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t?e+</span><span class="s2">&quot;-&quot;</span><span class="s1">+t:t}</span><span class="s0">function </span><span class="s1">ds({top:t,left:e,right:n,bottom:i}){</span><span class="s0">return</span><span class="s1">{x:{min:e,max:n},y:{min:t,max:i}}}</span><span class="s0">function </span><span class="s1">ps(t){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">===t||</span><span class="s3">1</span><span class="s1">===t}</span><span class="s0">function </span><span class="s1">ms({scale:t,scaleX:e,scaleY:n}){</span><span class="s0">return</span><span class="s1">!ps(t)||!ps(e)||!ps(n)}</span><span class="s0">function </span><span class="s1">fs(t){</span><span class="s0">return </span><span class="s1">ms(t)||ys(t)||t.z||t.rotate||t.rotateX||t.rotateY||t.skewX||t.skewY}</span><span class="s0">function </span><span class="s1">ys(t){</span><span class="s0">return </span><span class="s1">gs(t.x)||gs(t.y)}</span><span class="s0">function </span><span class="s1">gs(t){</span><span class="s0">return </span><span class="s1">t&amp;&amp;</span><span class="s2">&quot;0%&quot;</span><span class="s1">!==t}</span><span class="s0">function </span><span class="s1">vs(t,e,n){</span><span class="s0">return </span><span class="s1">n+e*(t-n)}</span><span class="s0">function </span><span class="s1">xs(t,e,n,i,s){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==s&amp;&amp;(t=vs(t,s,i)),vs(t,n,i)+e}</span><span class="s0">function </span><span class="s1">Ts(t,e=</span><span class="s3">0</span><span class="s1">,n=</span><span class="s3">1</span><span class="s1">,i,s){t.min=xs(t.min,e,n,i,s),t.max=xs(t.max,e,n,i,s)}</span><span class="s0">function </span><span class="s1">ws(t,{x:e,y:n}){Ts(t.x,e.translate,e.scale,e.originPoint),Ts(t.y,n.translate,n.scale,n.originPoint)}</span><span class="s0">const </span><span class="s1">Ps=</span><span class="s3">.999999999999</span><span class="s1">,Ss=</span><span class="s3">1.0000000000001</span><span class="s1">;</span><span class="s0">function </span><span class="s1">bs(t,e){t.min=t.min+e,t.max=t.max+e}</span><span class="s0">function </span><span class="s1">As(t,e,n,i,s=</span><span class="s3">.5</span><span class="s1">){Ts(t,e,n,Jt(t.min,t.max,s),i)}</span><span class="s0">function </span><span class="s1">Es(t,e){As(t.x,e.x,e.scaleX,e.scale,e.originX),As(t.y,e.y,e.scaleY,e.scale,e.originY)}</span><span class="s0">function </span><span class="s1">Vs(t,e){</span><span class="s0">return </span><span class="s1">ds(</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">return </span><span class="s1">t;</span><span class="s0">const </span><span class="s1">n=e({x:t.left,y:t.top}),i=e({x:t.right,y:t.bottom});</span><span class="s0">return</span><span class="s1">{top:n.y,left:n.x,bottom:i.y,right:i.x}}(t.getBoundingClientRect(),e))}</span><span class="s0">const </span><span class="s1">Ms=()=&gt;({x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}}),Cs={current:</span><span class="s0">null</span><span class="s1">},Ds={current:!</span><span class="s3">1</span><span class="s1">};</span><span class="s0">const </span><span class="s1">ks=</span><span class="s0">new </span><span class="s1">WeakMap;</span><span class="s0">const </span><span class="s1">Rs=[</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s1">,</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s1">,</span><span class="s2">&quot;Update&quot;</span><span class="s1">,</span><span class="s2">&quot;BeforeLayoutMeasure&quot;</span><span class="s1">,</span><span class="s2">&quot;LayoutMeasure&quot;</span><span class="s1">,</span><span class="s2">&quot;LayoutAnimationStart&quot;</span><span class="s1">,</span><span class="s2">&quot;LayoutAnimationComplete&quot;</span><span class="s1">];</span><span class="s0">class </span><span class="s1">Ls{scrapeMotionValuesFromProps(t,e,n){</span><span class="s0">return</span><span class="s1">{}}constructor({parent:t,props:e,presenceContext:n,reducedMotionConfig:i,blockInitialAnimation:s,visualState:o},r={}){</span><span class="s0">this</span><span class="s1">.current=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.children=</span><span class="s0">new </span><span class="s1">Set,</span><span class="s0">this</span><span class="s1">.isVariantNode=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isControllingVariants=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.shouldReduceMotion=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.values=</span><span class="s0">new </span><span class="s1">Map,</span><span class="s0">this</span><span class="s1">.KeyframeResolver=yn,</span><span class="s0">this</span><span class="s1">.features={},</span><span class="s0">this</span><span class="s1">.valueSubscriptions=</span><span class="s0">new </span><span class="s1">Map,</span><span class="s0">this</span><span class="s1">.prevMotionValues={},</span><span class="s0">this</span><span class="s1">.events={},</span><span class="s0">this</span><span class="s1">.propEventSubscriptions={},</span><span class="s0">this</span><span class="s1">.notifyUpdate=()=&gt;</span><span class="s0">this</span><span class="s1">.notify(</span><span class="s2">&quot;Update&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.latestValues),</span><span class="s0">this</span><span class="s1">.render=()=&gt;{</span><span class="s0">this</span><span class="s1">.current&amp;&amp;(</span><span class="s0">this</span><span class="s1">.triggerBuild(),</span><span class="s0">this</span><span class="s1">.renderInstance(</span><span class="s0">this</span><span class="s1">.current,</span><span class="s0">this</span><span class="s1">.renderState,</span><span class="s0">this</span><span class="s1">.props.style,</span><span class="s0">this</span><span class="s1">.projection))},</span><span class="s0">this</span><span class="s1">.renderScheduledAt=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scheduleRender=()=&gt;{</span><span class="s0">const </span><span class="s1">t=ft.now();</span><span class="s0">this</span><span class="s1">.renderScheduledAt&lt;t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.renderScheduledAt=t,ht.render(</span><span class="s0">this</span><span class="s1">.render,!</span><span class="s3">1</span><span class="s1">,!</span><span class="s3">0</span><span class="s1">))};</span><span class="s0">const</span><span class="s1">{latestValues:a,renderState:l}=o;</span><span class="s0">this</span><span class="s1">.latestValues=a,</span><span class="s0">this</span><span class="s1">.baseTarget={...a},</span><span class="s0">this</span><span class="s1">.initialValues=e.initial?{...a}:{},</span><span class="s0">this</span><span class="s1">.renderState=l,</span><span class="s0">this</span><span class="s1">.parent=t,</span><span class="s0">this</span><span class="s1">.props=e,</span><span class="s0">this</span><span class="s1">.presenceContext=n,</span><span class="s0">this</span><span class="s1">.depth=t?t.depth+</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.reducedMotionConfig=i,</span><span class="s0">this</span><span class="s1">.options=r,</span><span class="s0">this</span><span class="s1">.blockInitialAnimation=Boolean(s),</span><span class="s0">this</span><span class="s1">.isControllingVariants=nt(e),</span><span class="s0">this</span><span class="s1">.isVariantNode=it(e),</span><span class="s0">this</span><span class="s1">.isVariantNode&amp;&amp;(</span><span class="s0">this</span><span class="s1">.variantChildren=</span><span class="s0">new </span><span class="s1">Set),</span><span class="s0">this</span><span class="s1">.manuallyAnimateOnMount=Boolean(t&amp;&amp;t.current);</span><span class="s0">const</span><span class="s1">{willChange:h,...u}=</span><span class="s0">this</span><span class="s1">.scrapeMotionValuesFromProps(e,{},</span><span class="s0">this</span><span class="s1">);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">u){</span><span class="s0">const </span><span class="s1">e=u[t];</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==a[t]&amp;&amp;vi(e)&amp;&amp;e.set(a[t])}}mount(t){</span><span class="s0">this</span><span class="s1">.current=t,ks.set(t,</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.projection&amp;&amp;!</span><span class="s0">this</span><span class="s1">.projection.instance&amp;&amp;</span><span class="s0">this</span><span class="s1">.projection.mount(t),</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.isVariantNode&amp;&amp;!</span><span class="s0">this</span><span class="s1">.isControllingVariants&amp;&amp;(</span><span class="s0">this</span><span class="s1">.removeFromVariantTree=</span><span class="s0">this</span><span class="s1">.parent.addVariantChild(</span><span class="s0">this</span><span class="s1">)),</span><span class="s0">this</span><span class="s1">.values.forEach((t,e)=&gt;</span><span class="s0">this</span><span class="s1">.bindToMotionValue(e,t)),Ds.current||</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">if</span><span class="s1">(Ds.current=!</span><span class="s3">0</span><span class="s1">,Ji)</span><span class="s0">if</span><span class="s1">(window.matchMedia){</span><span class="s0">const </span><span class="s1">t=window.matchMedia(</span><span class="s2">&quot;(prefers-reduced-motion)&quot;</span><span class="s1">),e=()=&gt;Cs.current=t.matches;t.addEventListener(</span><span class="s2">&quot;change&quot;</span><span class="s1">,e),e()}</span><span class="s0">else </span><span class="s1">Cs.current=!</span><span class="s3">1</span><span class="s1">}(),</span><span class="s0">this</span><span class="s1">.shouldReduceMotion=</span><span class="s2">&quot;never&quot;</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.reducedMotionConfig&amp;&amp;(</span><span class="s2">&quot;always&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.reducedMotionConfig||Cs.current),</span><span class="s0">this</span><span class="s1">.parent?.addChild(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.update(</span><span class="s0">this</span><span class="s1">.props,</span><span class="s0">this</span><span class="s1">.presenceContext)}unmount(){</span><span class="s0">this</span><span class="s1">.projection&amp;&amp;</span><span class="s0">this</span><span class="s1">.projection.unmount(),ut(</span><span class="s0">this</span><span class="s1">.notifyUpdate),ut(</span><span class="s0">this</span><span class="s1">.render),</span><span class="s0">this</span><span class="s1">.valueSubscriptions.forEach(t=&gt;t()),</span><span class="s0">this</span><span class="s1">.valueSubscriptions.clear(),</span><span class="s0">this</span><span class="s1">.removeFromVariantTree&amp;&amp;</span><span class="s0">this</span><span class="s1">.removeFromVariantTree(),</span><span class="s0">this</span><span class="s1">.parent?.removeChild(</span><span class="s0">this</span><span class="s1">);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in this</span><span class="s1">.events)</span><span class="s0">this</span><span class="s1">.events[t].clear();</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in this</span><span class="s1">.features){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.features[t];e&amp;&amp;(e.unmount(),e.isMounted=!</span><span class="s3">1</span><span class="s1">)}</span><span class="s0">this</span><span class="s1">.current=</span><span class="s0">null</span><span class="s1">}addChild(t){</span><span class="s0">this</span><span class="s1">.children.add(t),</span><span class="s0">this</span><span class="s1">.enteringChildren??(</span><span class="s0">this</span><span class="s1">.enteringChildren=</span><span class="s0">new </span><span class="s1">Set),</span><span class="s0">this</span><span class="s1">.enteringChildren.add(t)}removeChild(t){</span><span class="s0">this</span><span class="s1">.children.delete(t),</span><span class="s0">this</span><span class="s1">.enteringChildren&amp;&amp;</span><span class="s0">this</span><span class="s1">.enteringChildren.delete(t)}bindToMotionValue(t,e){</span><span class="s0">this</span><span class="s1">.valueSubscriptions.has(t)&amp;&amp;</span><span class="s0">this</span><span class="s1">.valueSubscriptions.get(t)();</span><span class="s0">const </span><span class="s1">n=on.has(t);n&amp;&amp;</span><span class="s0">this</span><span class="s1">.onBindTransform&amp;&amp;</span><span class="s0">this</span><span class="s1">.onBindTransform();</span><span class="s0">const </span><span class="s1">i=e.on(</span><span class="s2">&quot;change&quot;</span><span class="s1">,e=&gt;{</span><span class="s0">this</span><span class="s1">.latestValues[t]=e,</span><span class="s0">this</span><span class="s1">.props.onUpdate&amp;&amp;ht.preRender(</span><span class="s0">this</span><span class="s1">.notifyUpdate),n&amp;&amp;</span><span class="s0">this</span><span class="s1">.projection&amp;&amp;(</span><span class="s0">this</span><span class="s1">.projection.isTransformDirty=!</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.scheduleRender()});</span><span class="s0">let </span><span class="s1">s;window.MotionCheckAppearSync&amp;&amp;(s=window.MotionCheckAppearSync(</span><span class="s0">this</span><span class="s1">,t,e)),</span><span class="s0">this</span><span class="s1">.valueSubscriptions.set(t,()=&gt;{i(),s&amp;&amp;s(),e.owner&amp;&amp;e.stop()})}sortNodePosition(t){</span><span class="s0">return this</span><span class="s1">.current&amp;&amp;</span><span class="s0">this</span><span class="s1">.sortInstanceNodePosition&amp;&amp;</span><span class="s0">this</span><span class="s1">.type===t.type?</span><span class="s0">this</span><span class="s1">.sortInstanceNodePosition(</span><span class="s0">this</span><span class="s1">.current,t.current):</span><span class="s3">0</span><span class="s1">}updateFeatures(){</span><span class="s0">let </span><span class="s1">t=</span><span class="s2">&quot;animation&quot;</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(t </span><span class="s0">in </span><span class="s1">ts){</span><span class="s0">const </span><span class="s1">e=ts[t];</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{isEnabled:n,Feature:i}=e;</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.features[t]&amp;&amp;i&amp;&amp;n(</span><span class="s0">this</span><span class="s1">.props)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.features[t]=</span><span class="s0">new </span><span class="s1">i(</span><span class="s0">this</span><span class="s1">)),</span><span class="s0">this</span><span class="s1">.features[t]){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.features[t];e.isMounted?e.update():(e.mount(),e.isMounted=!</span><span class="s3">0</span><span class="s1">)}}}triggerBuild(){</span><span class="s0">this</span><span class="s1">.build(</span><span class="s0">this</span><span class="s1">.renderState,</span><span class="s0">this</span><span class="s1">.latestValues,</span><span class="s0">this</span><span class="s1">.props)}measureViewportBox(){</span><span class="s0">return this</span><span class="s1">.current?</span><span class="s0">this</span><span class="s1">.measureInstanceViewportBox(</span><span class="s0">this</span><span class="s1">.current,</span><span class="s0">this</span><span class="s1">.props):{x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}}}getStaticValue(t){</span><span class="s0">return this</span><span class="s1">.latestValues[t]}setStaticValue(t,e){</span><span class="s0">this</span><span class="s1">.latestValues[t]=e}update(t,e){(t.transformTemplate||</span><span class="s0">this</span><span class="s1">.props.transformTemplate)&amp;&amp;</span><span class="s0">this</span><span class="s1">.scheduleRender(),</span><span class="s0">this</span><span class="s1">.prevProps=</span><span class="s0">this</span><span class="s1">.props,</span><span class="s0">this</span><span class="s1">.props=t,</span><span class="s0">this</span><span class="s1">.prevPresenceContext=</span><span class="s0">this</span><span class="s1">.presenceContext,</span><span class="s0">this</span><span class="s1">.presenceContext=e;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;Rs.length;e++){</span><span class="s0">const </span><span class="s1">n=Rs[e];</span><span class="s0">this</span><span class="s1">.propEventSubscriptions[n]&amp;&amp;(</span><span class="s0">this</span><span class="s1">.propEventSubscriptions[n](),</span><span class="s0">delete this</span><span class="s1">.propEventSubscriptions[n]);</span><span class="s0">const </span><span class="s1">i=t[</span><span class="s2">&quot;on&quot;</span><span class="s1">+n];i&amp;&amp;(</span><span class="s0">this</span><span class="s1">.propEventSubscriptions[n]=</span><span class="s0">this</span><span class="s1">.on(n,i))}</span><span class="s0">this</span><span class="s1">.prevMotionValues=</span><span class="s0">function</span><span class="s1">(t,e,n){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">i </span><span class="s0">in </span><span class="s1">e){</span><span class="s0">const </span><span class="s1">s=e[i],o=n[i];</span><span class="s0">if</span><span class="s1">(vi(s))t.addValue(i,s);</span><span class="s0">else if</span><span class="s1">(vi(o))t.addValue(i,ni(s,{owner:t}));</span><span class="s0">else if</span><span class="s1">(o!==s)</span><span class="s0">if</span><span class="s1">(t.hasValue(i)){</span><span class="s0">const </span><span class="s1">e=t.getValue(i);!</span><span class="s3">0</span><span class="s1">===e.liveStyle?e.jump(s):e.hasAnimated||e.set(s)}</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">e=t.getStaticValue(i);t.addValue(i,ni(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e?e:s,{owner:t}))}}</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">i </span><span class="s0">in </span><span class="s1">n)</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e[i]&amp;&amp;t.removeValue(i);</span><span class="s0">return </span><span class="s1">e}(</span><span class="s0">this</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scrapeMotionValuesFromProps(t,</span><span class="s0">this</span><span class="s1">.prevProps,</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.prevMotionValues),</span><span class="s0">this</span><span class="s1">.handleChildMotionValue&amp;&amp;</span><span class="s0">this</span><span class="s1">.handleChildMotionValue()}getProps(){</span><span class="s0">return this</span><span class="s1">.props}getVariant(t){</span><span class="s0">return this</span><span class="s1">.props.variants?</span><span class="s0">this</span><span class="s1">.props.variants[t]:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}getDefaultTransition(){</span><span class="s0">return this</span><span class="s1">.props.transition}getTransformPagePoint(){</span><span class="s0">return this</span><span class="s1">.props.transformPagePoint}getClosestVariantNode(){</span><span class="s0">return this</span><span class="s1">.isVariantNode?</span><span class="s0">this</span><span class="s1">:</span><span class="s0">this</span><span class="s1">.parent?</span><span class="s0">this</span><span class="s1">.parent.getClosestVariantNode():</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}addVariantChild(t){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.getClosestVariantNode();</span><span class="s0">if</span><span class="s1">(e)</span><span class="s0">return </span><span class="s1">e.variantChildren&amp;&amp;e.variantChildren.add(t),()=&gt;e.variantChildren.delete(t)}addValue(t,e){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.values.get(t);e!==n&amp;&amp;(n&amp;&amp;</span><span class="s0">this</span><span class="s1">.removeValue(t),</span><span class="s0">this</span><span class="s1">.bindToMotionValue(t,e),</span><span class="s0">this</span><span class="s1">.values.set(t,e),</span><span class="s0">this</span><span class="s1">.latestValues[t]=e.get())}removeValue(t){</span><span class="s0">this</span><span class="s1">.values.delete(t);</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.valueSubscriptions.get(t);e&amp;&amp;(e(),</span><span class="s0">this</span><span class="s1">.valueSubscriptions.delete(t)),</span><span class="s0">delete this</span><span class="s1">.latestValues[t],</span><span class="s0">this</span><span class="s1">.removeValueFromRenderState(t,</span><span class="s0">this</span><span class="s1">.renderState)}hasValue(t){</span><span class="s0">return this</span><span class="s1">.values.has(t)}getValue(t,e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.props.values&amp;&amp;</span><span class="s0">this</span><span class="s1">.props.values[t])</span><span class="s0">return this</span><span class="s1">.props.values[t];</span><span class="s0">let </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.values.get(t);</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">===n&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e&amp;&amp;(n=ni(</span><span class="s0">null</span><span class="s1">===e?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:e,{owner:</span><span class="s0">this</span><span class="s1">}),</span><span class="s0">this</span><span class="s1">.addValue(t,n)),n}readValue(t,e){</span><span class="s0">let </span><span class="s1">n=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.latestValues[t]&amp;&amp;</span><span class="s0">this</span><span class="s1">.current?</span><span class="s0">this</span><span class="s1">.getBaseTargetFromProps(</span><span class="s0">this</span><span class="s1">.props,t)??</span><span class="s0">this</span><span class="s1">.readValueFromInstance(</span><span class="s0">this</span><span class="s1">.current,t,</span><span class="s0">this</span><span class="s1">.options):</span><span class="s0">this</span><span class="s1">.latestValues[t];</span><span class="s0">var </span><span class="s1">i;</span><span class="s0">return null</span><span class="s1">!=n&amp;&amp;(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n&amp;&amp;(x(n)||w(n))?n=parseFloat(n):(i=n,!xi.find(Un(i))&amp;&amp;qt.test(e)&amp;&amp;(n=_n(t,e))),</span><span class="s0">this</span><span class="s1">.setBaseTarget(t,vi(n)?n.get():n)),vi(n)?n.get():n}setBaseTarget(t,e){</span><span class="s0">this</span><span class="s1">.baseTarget[t]=e}getBaseTarget(t){</span><span class="s0">const</span><span class="s1">{initial:e}=</span><span class="s0">this</span><span class="s1">.props;</span><span class="s0">let </span><span class="s1">n;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e||</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e){</span><span class="s0">const </span><span class="s1">i=Xi(</span><span class="s0">this</span><span class="s1">.props,e,</span><span class="s0">this</span><span class="s1">.presenceContext?.custom);i&amp;&amp;(n=i[t])}</span><span class="s0">if</span><span class="s1">(e&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n)</span><span class="s0">return </span><span class="s1">n;</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.getBaseTargetFromProps(</span><span class="s0">this</span><span class="s1">.props,t);</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">===i||vi(i)?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.initialValues[t]&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===n?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:</span><span class="s0">this</span><span class="s1">.baseTarget[t]:i}on(t,e){</span><span class="s0">return this</span><span class="s1">.events[t]||(</span><span class="s0">this</span><span class="s1">.events[t]=</span><span class="s0">new </span><span class="s1">V),</span><span class="s0">this</span><span class="s1">.events[t].add(e)}notify(t,...e){</span><span class="s0">this</span><span class="s1">.events[t]&amp;&amp;</span><span class="s0">this</span><span class="s1">.events[t].notify(...e)}scheduleRenderMicrotask(){ii.render(</span><span class="s0">this</span><span class="s1">.render)}}</span><span class="s0">class </span><span class="s1">js </span><span class="s0">extends </span><span class="s1">Ls{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.KeyframeResolver=Qn}sortInstanceNodePosition(t,e){</span><span class="s0">return </span><span class="s3">2</span><span class="s1">&amp;t.compareDocumentPosition(e)?</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">}getBaseTargetFromProps(t,e){</span><span class="s0">return </span><span class="s1">t.style?t.style[e]:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}removeValueFromRenderState(t,{vars:e,style:n}){</span><span class="s0">delete </span><span class="s1">e[t],</span><span class="s0">delete </span><span class="s1">n[t]}handleChildMotionValue(){</span><span class="s0">this</span><span class="s1">.childSubscription&amp;&amp;(</span><span class="s0">this</span><span class="s1">.childSubscription(),</span><span class="s0">delete this</span><span class="s1">.childSubscription);</span><span class="s0">const</span><span class="s1">{children:t}=</span><span class="s0">this</span><span class="s1">.props;vi(t)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.childSubscription=t.on(</span><span class="s2">&quot;change&quot;</span><span class="s1">,t=&gt;{</span><span class="s0">this</span><span class="s1">.current&amp;&amp;(</span><span class="s0">this</span><span class="s1">.current.textContent=</span><span class="s2">`</span><span class="s1">${t}</span><span class="s2">`</span><span class="s1">)}))}}</span><span class="s0">function </span><span class="s1">Bs(t,{style:e,vars:n},i,s){</span><span class="s0">const </span><span class="s1">o=t.style;</span><span class="s0">let </span><span class="s1">r;</span><span class="s0">for</span><span class="s1">(r </span><span class="s0">in </span><span class="s1">e)o[r]=e[r];</span><span class="s0">for</span><span class="s1">(r </span><span class="s0">in </span><span class="s1">s?.applyProjectionStyles(o,i),n)o.setProperty(r,n[r])}</span><span class="s0">class </span><span class="s1">Fs </span><span class="s0">extends </span><span class="s1">js{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.type=</span><span class="s2">&quot;html&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.renderInstance=Bs}readValueFromInstance(t,e){</span><span class="s0">if</span><span class="s1">(on.has(e))</span><span class="s0">return this</span><span class="s1">.projection?.isProjecting?tn(e):((t,e)=&gt;{</span><span class="s0">const</span><span class="s1">{transform:n=</span><span class="s2">&quot;none&quot;</span><span class="s1">}=getComputedStyle(t);</span><span class="s0">return </span><span class="s1">en(n,e)})(t,e);{</span><span class="s0">const </span><span class="s1">i=(n=t,window.getComputedStyle(n)),s=(gt(e)?i.getPropertyValue(e):i[e])||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">return</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">s?s.trim():s}</span><span class="s0">var </span><span class="s1">n}measureInstanceViewportBox(t,{transformPagePoint:e}){</span><span class="s0">return </span><span class="s1">Vs(t,e)}build(t,e,n){bi(t,e,n.transformTemplate)}scrapeMotionValuesFromProps(t,e,n){</span><span class="s0">return </span><span class="s1">Gi(t,e,n)}}</span><span class="s0">const </span><span class="s1">Os=</span><span class="s0">new </span><span class="s1">Set([</span><span class="s2">&quot;baseFrequency&quot;</span><span class="s1">,</span><span class="s2">&quot;diffuseConstant&quot;</span><span class="s1">,</span><span class="s2">&quot;kernelMatrix&quot;</span><span class="s1">,</span><span class="s2">&quot;kernelUnitLength&quot;</span><span class="s1">,</span><span class="s2">&quot;keySplines&quot;</span><span class="s1">,</span><span class="s2">&quot;keyTimes&quot;</span><span class="s1">,</span><span class="s2">&quot;limitingConeAngle&quot;</span><span class="s1">,</span><span class="s2">&quot;markerHeight&quot;</span><span class="s1">,</span><span class="s2">&quot;markerWidth&quot;</span><span class="s1">,</span><span class="s2">&quot;numOctaves&quot;</span><span class="s1">,</span><span class="s2">&quot;targetX&quot;</span><span class="s1">,</span><span class="s2">&quot;targetY&quot;</span><span class="s1">,</span><span class="s2">&quot;surfaceScale&quot;</span><span class="s1">,</span><span class="s2">&quot;specularConstant&quot;</span><span class="s1">,</span><span class="s2">&quot;specularExponent&quot;</span><span class="s1">,</span><span class="s2">&quot;stdDeviation&quot;</span><span class="s1">,</span><span class="s2">&quot;tableValues&quot;</span><span class="s1">,</span><span class="s2">&quot;viewBox&quot;</span><span class="s1">,</span><span class="s2">&quot;gradientTransform&quot;</span><span class="s1">,</span><span class="s2">&quot;pathLength&quot;</span><span class="s1">,</span><span class="s2">&quot;startOffset&quot;</span><span class="s1">,</span><span class="s2">&quot;textLength&quot;</span><span class="s1">,</span><span class="s2">&quot;lengthAdjust&quot;</span><span class="s1">]);</span><span class="s0">class </span><span class="s1">Is </span><span class="s0">extends </span><span class="s1">js{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.type=</span><span class="s2">&quot;svg&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isSVGTag=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.measureInstanceViewportBox=Ms}getBaseTargetFromProps(t,e){</span><span class="s0">return </span><span class="s1">t[e]}readValueFromInstance(t,e){</span><span class="s0">if</span><span class="s1">(on.has(e)){</span><span class="s0">const </span><span class="s1">t=Zn(e);</span><span class="s0">return </span><span class="s1">t&amp;&amp;t.default||</span><span class="s3">0</span><span class="s1">}</span><span class="s0">return </span><span class="s1">e=Os.has(e)?e:ss(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,n){</span><span class="s0">return </span><span class="s1">Zi(t,e,n)}build(t,e,n){ki(t,e,</span><span class="s0">this</span><span class="s1">.isSVGTag,n.transformTemplate,n.style)}renderInstance(t,e,n,i){!</span><span class="s0">function</span><span class="s1">(t,e,n,i){Bs(t,e,</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,i);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">n </span><span class="s0">in </span><span class="s1">e.attrs)t.setAttribute(Os.has(n)?n:ss(n),e.attrs[n])}(t,e,</span><span class="s3">0</span><span class="s1">,i)}mount(t){</span><span class="s0">this</span><span class="s1">.isSVGTag=Li(t.tagName),</span><span class="s0">super</span><span class="s1">.mount(t)}}</span><span class="s0">const </span><span class="s1">Us=(t,e)=&gt;Ni(t)?</span><span class="s0">new </span><span class="s1">Is(e):</span><span class="s0">new </span><span class="s1">Fs(e,{allowProjection:t!==o});</span><span class="s0">function </span><span class="s1">Ns(t,e,n){</span><span class="s0">const </span><span class="s1">i=t.getProps();</span><span class="s0">return </span><span class="s1">Xi(i,e,</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n?n:i.custom,t)}</span><span class="s0">const </span><span class="s1">Ws=t=&gt;Array.isArray(t);</span><span class="s0">function </span><span class="s1">$s(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,ni(n))}</span><span class="s0">function </span><span class="s1">Ys(t){</span><span class="s0">return </span><span class="s1">Ws(t)?t[t.length-</span><span class="s3">1</span><span class="s1">]||</span><span class="s3">0</span><span class="s1">:t}</span><span class="s0">function </span><span class="s1">Xs(t,e){</span><span class="s0">const </span><span class="s1">n=t.getValue(</span><span class="s2">&quot;willChange&quot;</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(i=n,Boolean(vi(i)&amp;&amp;i.add))</span><span class="s0">return </span><span class="s1">n.add(e);</span><span class="s0">if</span><span class="s1">(!n&amp;&amp;v.WillChange){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">new </span><span class="s1">v.WillChange(</span><span class="s2">&quot;auto&quot;</span><span class="s1">);t.addValue(</span><span class="s2">&quot;willChange&quot;</span><span class="s1">,n),n.add(e)}</span><span class="s0">var </span><span class="s1">i}</span><span class="s0">function </span><span class="s1">Ks(t){</span><span class="s0">return </span><span class="s1">t.props[os]}</span><span class="s0">const </span><span class="s1">zs=t=&gt;</span><span class="s0">null</span><span class="s1">!==t;</span><span class="s0">const </span><span class="s1">Hs={type:</span><span class="s2">&quot;spring&quot;</span><span class="s1">,stiffness:</span><span class="s3">500</span><span class="s1">,damping:</span><span class="s3">25</span><span class="s1">,restSpeed:</span><span class="s3">10</span><span class="s1">},Gs={type:</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,duration:</span><span class="s3">.8</span><span class="s1">},qs={type:</span><span class="s2">&quot;keyframes&quot;</span><span class="s1">,ease:[</span><span class="s3">.25</span><span class="s1">,</span><span class="s3">.1</span><span class="s1">,</span><span class="s3">.35</span><span class="s1">,</span><span class="s3">1</span><span class="s1">],duration:</span><span class="s3">.3</span><span class="s1">},Zs=(t,{keyframes:e})=&gt;e.length&gt;</span><span class="s3">2</span><span class="s1">?Gs:on.has(t)?t.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s1">)?{type:</span><span class="s2">&quot;spring&quot;</span><span class="s1">,stiffness:</span><span class="s3">550</span><span class="s1">,damping:</span><span class="s3">0</span><span class="s1">===e[</span><span class="s3">1</span><span class="s1">]?</span><span class="s3">2</span><span class="s1">*Math.sqrt(</span><span class="s3">550</span><span class="s1">):</span><span class="s3">30</span><span class="s1">,restSpeed:</span><span class="s3">10</span><span class="s1">}:Hs:qs;</span><span class="s0">const </span><span class="s1">_s=(t,e,n,i={},s,o)=&gt;r=&gt;{</span><span class="s0">const </span><span class="s1">a=On(i,t)||{},l=a.delay||i.delay||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">let</span><span class="s1">{elapsed:h=</span><span class="s3">0</span><span class="s1">}=i;h-=M(l);</span><span class="s0">const </span><span class="s1">u={keyframes:Array.isArray(n)?n:[</span><span class="s0">null</span><span class="s1">,n],ease:</span><span class="s2">&quot;easeOut&quot;</span><span class="s1">,velocity:e.getVelocity(),...a,delay:-h,onUpdate:t=&gt;{e.set(t),a.onUpdate&amp;&amp;a.onUpdate(t)},onComplete:()=&gt;{r(),a.onComplete&amp;&amp;a.onComplete()},name:t,motionValue:e,element:o?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:s};(</span><span class="s0">function</span><span class="s1">({when:t,delay:e,delayChildren:n,staggerChildren:i,staggerDirection:s,repeat:o,repeatType:r,repeatDelay:a,from:l,elapsed:h,...u}){</span><span class="s0">return</span><span class="s1">!!Object.keys(u).length})(a)||Object.assign(u,Zs(t,u)),u.duration&amp;&amp;(u.duration=M(u.duration)),u.repeatDelay&amp;&amp;(u.repeatDelay=M(u.repeatDelay)),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==u.from&amp;&amp;(u.keyframes[</span><span class="s3">0</span><span class="s1">]=u.from);</span><span class="s0">let </span><span class="s1">c=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">((!</span><span class="s3">1</span><span class="s1">===u.type||</span><span class="s3">0</span><span class="s1">===u.duration&amp;&amp;!u.repeatDelay)&amp;&amp;(kn(u),</span><span class="s3">0</span><span class="s1">===u.delay&amp;&amp;(c=!</span><span class="s3">0</span><span class="s1">)),(v.instantAnimations||v.skipAnimations)&amp;&amp;(c=!</span><span class="s3">0</span><span class="s1">,kn(u),u.delay=</span><span class="s3">0</span><span class="s1">),u.allowFlatten=!a.type&amp;&amp;!a.ease,c&amp;&amp;!o&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e.get()){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">function</span><span class="s1">(t,{repeat:e,repeatType:n=</span><span class="s2">&quot;loop&quot;</span><span class="s1">},i){</span><span class="s0">const </span><span class="s1">s=t.filter(zs),o=e&amp;&amp;</span><span class="s2">&quot;loop&quot;</span><span class="s1">!==n&amp;&amp;e%</span><span class="s3">2</span><span class="s1">==</span><span class="s3">1</span><span class="s1">?</span><span class="s3">0</span><span class="s1">:s.length-</span><span class="s3">1</span><span class="s1">;</span><span class="s0">return </span><span class="s1">o&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==i?i:s[o]}(u.keyframes,a);</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t)</span><span class="s0">return void </span><span class="s1">ht.update(()=&gt;{u.onUpdate(t),u.onComplete()})}</span><span class="s0">return </span><span class="s1">a.isSync?</span><span class="s0">new </span><span class="s1">ze(u):</span><span class="s0">new </span><span class="s1">jn(u)};</span><span class="s0">function </span><span class="s1">Js({protectedKeys:t,needsAnimating:e},n){</span><span class="s0">const </span><span class="s1">i=t.hasOwnProperty(n)&amp;&amp;!</span><span class="s3">0</span><span class="s1">!==e[n];</span><span class="s0">return </span><span class="s1">e[n]=!</span><span class="s3">1</span><span class="s1">,i}</span><span class="s0">function </span><span class="s1">Qs(t,e,{delay:n=</span><span class="s3">0</span><span class="s1">,transitionOverride:i,type:s}={}){</span><span class="s0">let</span><span class="s1">{transition:o=t.getDefaultTransition(),transitionEnd:r,...a}=e;i&amp;&amp;(o=i);</span><span class="s0">const </span><span class="s1">l=[],h=s&amp;&amp;t.animationState&amp;&amp;t.animationState.getState()[s];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">a){</span><span class="s0">const </span><span class="s1">i=t.getValue(e,t.latestValues[e]??</span><span class="s0">null</span><span class="s1">),s=a[e];</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===s||h&amp;&amp;Js(h,e))</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">const </span><span class="s1">r={delay:n,...On(o||{},e)},u=i.get();</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==u&amp;&amp;!i.isAnimating&amp;&amp;!Array.isArray(s)&amp;&amp;s===u&amp;&amp;!r.velocity)</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">let </span><span class="s1">c=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(window.MotionHandoffAnimation){</span><span class="s0">const </span><span class="s1">n=Ks(t);</span><span class="s0">if</span><span class="s1">(n){</span><span class="s0">const </span><span class="s1">t=window.MotionHandoffAnimation(n,e,ht);</span><span class="s0">null</span><span class="s1">!==t&amp;&amp;(r.startTime=t,c=!</span><span class="s3">0</span><span class="s1">)}}Xs(t,e),i.start(_s(e,i,s,t.shouldReduceMotion&amp;&amp;In.has(e)?{type:!</span><span class="s3">1</span><span class="s1">}:r,t,c));</span><span class="s0">const </span><span class="s1">d=i.animation;d&amp;&amp;l.push(d)}</span><span class="s0">return </span><span class="s1">r&amp;&amp;Promise.all(l).then(()=&gt;{ht.update(()=&gt;{r&amp;&amp;</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">n=Ns(t,e);</span><span class="s0">let</span><span class="s1">{transitionEnd:i={},transition:s={},...o}=n||{};o={...o,...i};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">o)$s(t,e,Ys(o[e]))}(t,r)})}),l}</span><span class="s0">function </span><span class="s1">to(t,e,n,i=</span><span class="s3">0</span><span class="s1">,s=</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">o=Array.from(t).sort((t,e)=&gt;t.sortNodePosition(e)).indexOf(e),r=t.size,a=(r-</span><span class="s3">1</span><span class="s1">)*i;</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">n?n(o,r):</span><span class="s3">1</span><span class="s1">===s?o*i:a-o*i}</span><span class="s0">function </span><span class="s1">eo(t,e,n={}){</span><span class="s0">const </span><span class="s1">i=Ns(t,e,</span><span class="s2">&quot;exit&quot;</span><span class="s1">===n.type?t.presenceContext?.custom:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">let</span><span class="s1">{transition:s=t.getDefaultTransition()||{}}=i||{};n.transitionOverride&amp;&amp;(s=n.transitionOverride);</span><span class="s0">const </span><span class="s1">o=i?()=&gt;Promise.all(Qs(t,i,n)):()=&gt;Promise.resolve(),r=t.variantChildren&amp;&amp;t.variantChildren.size?(i=</span><span class="s3">0</span><span class="s1">)=&gt;{</span><span class="s0">const</span><span class="s1">{delayChildren:o=</span><span class="s3">0</span><span class="s1">,staggerChildren:r,staggerDirection:a}=s;</span><span class="s0">return function</span><span class="s1">(t,e,n=</span><span class="s3">0</span><span class="s1">,i=</span><span class="s3">0</span><span class="s1">,s=</span><span class="s3">0</span><span class="s1">,o=</span><span class="s3">1</span><span class="s1">,r){</span><span class="s0">const </span><span class="s1">a=[];</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">l of t.variantChildren)l.notify(</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s1">,e),a.push(eo(l,e,{...r,delay:n+(</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">i?</span><span class="s3">0</span><span class="s1">:i)+to(t.variantChildren,l,i,s,o)}).then(()=&gt;l.notify(</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s1">,e)));</span><span class="s0">return </span><span class="s1">Promise.all(a)}(t,e,i,o,r,a,n)}:()=&gt;Promise.resolve(),{when:a}=s;</span><span class="s0">if</span><span class="s1">(a){</span><span class="s0">const</span><span class="s1">[t,e]=</span><span class="s2">&quot;beforeChildren&quot;</span><span class="s1">===a?[o,r]:[r,o];</span><span class="s0">return </span><span class="s1">t().then(()=&gt;e())}</span><span class="s0">return </span><span class="s1">Promise.all([o(),r(n.delay)])}</span><span class="s0">function </span><span class="s1">no(t,e){</span><span class="s0">if</span><span class="s1">(!Array.isArray(e))</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=e.length;</span><span class="s0">if</span><span class="s1">(n!==t.length)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">i=</span><span class="s3">0</span><span class="s1">;i&lt;n;i++)</span><span class="s0">if</span><span class="s1">(e[i]!==t[i])</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">io=et.length;</span><span class="s0">function </span><span class="s1">so(t){</span><span class="s0">if</span><span class="s1">(!t)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!t.isControllingVariants){</span><span class="s0">const </span><span class="s1">e=t.parent&amp;&amp;so(t.parent)||{};</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==t.props.initial&amp;&amp;(e.initial=t.props.initial),e}</span><span class="s0">const </span><span class="s1">e={};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">;n&lt;io;n++){</span><span class="s0">const </span><span class="s1">i=et[n],s=t.props[i];(Q(s)||!</span><span class="s3">1</span><span class="s1">===s)&amp;&amp;(e[i]=s)}</span><span class="s0">return </span><span class="s1">e}</span><span class="s0">const </span><span class="s1">oo=[...tt].reverse(),ro=tt.length;</span><span class="s0">function </span><span class="s1">ao(t){</span><span class="s0">return </span><span class="s1">e=&gt;Promise.all(e.map(({animation:e,options:n})=&gt;</span><span class="s0">function</span><span class="s1">(t,e,n={}){</span><span class="s0">let </span><span class="s1">i;</span><span class="s0">if</span><span class="s1">(t.notify(</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s1">,e),Array.isArray(e)){</span><span class="s0">const </span><span class="s1">s=e.map(e=&gt;eo(t,e,n));i=Promise.all(s)}</span><span class="s0">else if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e)i=eo(t,e,n);</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">s=</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e?Ns(t,e,n.custom):e;i=Promise.all(Qs(t,s,n))}</span><span class="s0">return </span><span class="s1">i.then(()=&gt;{t.notify(</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s1">,e)})}(t,e,n)))}</span><span class="s0">function </span><span class="s1">lo(t){</span><span class="s0">let </span><span class="s1">e=ao(t),n=co(),i=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=e=&gt;(n,i)=&gt;{</span><span class="s0">const </span><span class="s1">s=Ns(t,i,</span><span class="s2">&quot;exit&quot;</span><span class="s1">===e?t.presenceContext?.custom:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(s){</span><span class="s0">const</span><span class="s1">{transition:t,transitionEnd:e,...i}=s;n={...n,...i,...e}}</span><span class="s0">return </span><span class="s1">n};</span><span class="s0">function </span><span class="s1">o(o){</span><span class="s0">const</span><span class="s1">{props:r}=t,a=so(t.parent)||{},l=[],h=</span><span class="s0">new </span><span class="s1">Set;</span><span class="s0">let </span><span class="s1">u={},c=</span><span class="s3">1</span><span class="s1">/</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;ro;e++){</span><span class="s0">const </span><span class="s1">d=oo[e],p=n[d],m=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==r[d]?r[d]:a[d],f=Q(m),y=d===o?p.isActive:</span><span class="s0">null</span><span class="s1">;!</span><span class="s3">1</span><span class="s1">===y&amp;&amp;(c=e);</span><span class="s0">let </span><span class="s1">g=m===a[d]&amp;&amp;m!==r[d]&amp;&amp;f;</span><span class="s0">if</span><span class="s1">(g&amp;&amp;i&amp;&amp;t.manuallyAnimateOnMount&amp;&amp;(g=!</span><span class="s3">1</span><span class="s1">),p.protectedKeys={...u},!p.isActive&amp;&amp;</span><span class="s0">null</span><span class="s1">===y||!m&amp;&amp;!p.prevProp||J(m)||</span><span class="s2">&quot;boolean&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">m)</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">const </span><span class="s1">v=ho(p.prevProp,m);</span><span class="s0">let </span><span class="s1">x=v||d===o&amp;&amp;p.isActive&amp;&amp;!g&amp;&amp;f||e&gt;c&amp;&amp;f,T=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">w=Array.isArray(m)?m:[m];</span><span class="s0">let </span><span class="s1">P=w.reduce(s(d),{});!</span><span class="s3">1</span><span class="s1">===y&amp;&amp;(P={});</span><span class="s0">const</span><span class="s1">{prevResolvedValues:S={}}=p,b={...S,...P},A=e=&gt;{x=!</span><span class="s3">0</span><span class="s1">,h.has(e)&amp;&amp;(T=!</span><span class="s3">0</span><span class="s1">,h.delete(e)),p.needsAnimating[e]=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=t.getValue(e);n&amp;&amp;(n.liveStyle=!</span><span class="s3">1</span><span class="s1">)};</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">b){</span><span class="s0">const </span><span class="s1">e=P[t],n=S[t];</span><span class="s0">if</span><span class="s1">(u.hasOwnProperty(t))</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">let </span><span class="s1">i=!</span><span class="s3">1</span><span class="s1">;i=Ws(e)&amp;&amp;Ws(n)?!no(e,n):e!==n,i?</span><span class="s0">null</span><span class="s1">!=e?A(t):h.add(t):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e&amp;&amp;h.has(t)?A(t):p.protectedKeys[t]=!</span><span class="s3">0</span><span class="s1">}p.prevProp=m,p.prevResolvedValues=P,p.isActive&amp;&amp;(u={...u,...P}),i&amp;&amp;t.blockInitialAnimation&amp;&amp;(x=!</span><span class="s3">1</span><span class="s1">);</span><span class="s0">const </span><span class="s1">E=g&amp;&amp;v;x&amp;&amp;(!E||T)&amp;&amp;l.push(...w.map(e=&gt;{</span><span class="s0">const </span><span class="s1">n={type:d};</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;i&amp;&amp;!E&amp;&amp;t.manuallyAnimateOnMount&amp;&amp;t.parent){</span><span class="s0">const</span><span class="s1">{parent:i}=t,s=Ns(i,e);</span><span class="s0">if</span><span class="s1">(i.enteringChildren&amp;&amp;s){</span><span class="s0">const</span><span class="s1">{delayChildren:e}=s.transition||{};n.delay=to(i.enteringChildren,t,e)}}</span><span class="s0">return</span><span class="s1">{animation:e,options:n}}))}</span><span class="s0">if</span><span class="s1">(h.size){</span><span class="s0">const </span><span class="s1">e={};</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;boolean&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">r.initial){</span><span class="s0">const </span><span class="s1">n=Ns(t,Array.isArray(r.initial)?r.initial[</span><span class="s3">0</span><span class="s1">]:r.initial);n&amp;&amp;n.transition&amp;&amp;(e.transition=n.transition)}h.forEach(n=&gt;{</span><span class="s0">const </span><span class="s1">i=t.getBaseTarget(n),s=t.getValue(n);s&amp;&amp;(s.liveStyle=!</span><span class="s3">0</span><span class="s1">),e[n]=i??</span><span class="s0">null</span><span class="s1">}),l.push({animation:e})}</span><span class="s0">let </span><span class="s1">d=Boolean(l.length);</span><span class="s0">return</span><span class="s1">!i||!</span><span class="s3">1</span><span class="s1">!==r.initial&amp;&amp;r.initial!==r.animate||t.manuallyAnimateOnMount||(d=!</span><span class="s3">1</span><span class="s1">),i=!</span><span class="s3">1</span><span class="s1">,d?e(l):Promise.resolve()}</span><span class="s0">return</span><span class="s1">{animateChanges:o,setActive:</span><span class="s0">function</span><span class="s1">(e,i){</span><span class="s0">if</span><span class="s1">(n[e].isActive===i)</span><span class="s0">return </span><span class="s1">Promise.resolve();t.variantChildren?.forEach(t=&gt;t.animationState?.setActive(e,i)),n[e].isActive=i;</span><span class="s0">const </span><span class="s1">s=o(e);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">t </span><span class="s0">in </span><span class="s1">n)n[t].protectedKeys={};</span><span class="s0">return </span><span class="s1">s},setAnimateFunction:</span><span class="s0">function</span><span class="s1">(n){e=n(t)},getState:()=&gt;n,reset:()=&gt;{n=co(),i=!</span><span class="s3">0</span><span class="s1">}}}</span><span class="s0">function </span><span class="s1">ho(t,e){</span><span class="s0">return</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e?e!==t:!!Array.isArray(e)&amp;&amp;!no(e,t)}</span><span class="s0">function </span><span class="s1">uo(t=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">return</span><span class="s1">{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}</span><span class="s0">function </span><span class="s1">co(){</span><span class="s0">return</span><span class="s1">{animate:uo(!</span><span class="s3">0</span><span class="s1">),whileInView:uo(),whileHover:uo(),whileTap:uo(),whileDrag:uo(),whileFocus:uo(),exit:uo()}}</span><span class="s0">class </span><span class="s1">po{constructor(t){</span><span class="s0">this</span><span class="s1">.isMounted=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.node=t}update(){}}</span><span class="s0">let </span><span class="s1">mo=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">fo={animation:{Feature:</span><span class="s0">class extends </span><span class="s1">po{constructor(t){</span><span class="s0">super</span><span class="s1">(t),t.animationState||(t.animationState=lo(t))}updateAnimationControlsSubscription(){</span><span class="s0">const</span><span class="s1">{animate:t}=</span><span class="s0">this</span><span class="s1">.node.getProps();J(t)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unmountControls=t.subscribe(</span><span class="s0">this</span><span class="s1">.node))}mount(){</span><span class="s0">this</span><span class="s1">.updateAnimationControlsSubscription()}update(){</span><span class="s0">const</span><span class="s1">{animate:t}=</span><span class="s0">this</span><span class="s1">.node.getProps(),{animate:e}=</span><span class="s0">this</span><span class="s1">.node.prevProps||{};t!==e&amp;&amp;</span><span class="s0">this</span><span class="s1">.updateAnimationControlsSubscription()}unmount(){</span><span class="s0">this</span><span class="s1">.node.animationState.reset(),</span><span class="s0">this</span><span class="s1">.unmountControls?.()}}},exit:{Feature:</span><span class="s0">class extends </span><span class="s1">po{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.id=mo++}update(){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.node.presenceContext)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{isPresent:t,onExitComplete:e}=</span><span class="s0">this</span><span class="s1">.node.presenceContext,{isPresent:n}=</span><span class="s0">this</span><span class="s1">.node.prevPresenceContext||{};</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.node.animationState||t===n)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.node.animationState.setActive(</span><span class="s2">&quot;exit&quot;</span><span class="s1">,!t);e&amp;&amp;!t&amp;&amp;i.then(()=&gt;{e(</span><span class="s0">this</span><span class="s1">.id)})}mount(){</span><span class="s0">const</span><span class="s1">{register:t,onExitComplete:e}=</span><span class="s0">this</span><span class="s1">.node.presenceContext||{};e&amp;&amp;e(</span><span class="s0">this</span><span class="s1">.id),t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unmount=t(</span><span class="s0">this</span><span class="s1">.id))}unmount(){}}}};</span><span class="s0">function </span><span class="s1">yo(t,e,n,i={passive:!</span><span class="s3">0</span><span class="s1">}){</span><span class="s0">return </span><span class="s1">t.addEventListener(e,n,i),()=&gt;t.removeEventListener(e,n)}</span><span class="s0">function </span><span class="s1">go(t){</span><span class="s0">return</span><span class="s1">{point:{x:t.pageX,y:t.pageY}}}</span><span class="s0">function </span><span class="s1">vo(t,e,n,i){</span><span class="s0">return </span><span class="s1">yo(t,e,(t=&gt;e=&gt;ui(e)&amp;&amp;t(e,go(e)))(n),i)}</span><span class="s0">function </span><span class="s1">xo(t){</span><span class="s0">return </span><span class="s1">t.max-t.min}</span><span class="s0">function </span><span class="s1">To(t,e,n,i=</span><span class="s3">.5</span><span class="s1">){t.origin=i,t.originPoint=Jt(e.min,e.max,t.origin),t.scale=xo(n)/xo(e),t.translate=Jt(n.min,n.max,t.origin)-t.originPoint,(t.scale&gt;=</span><span class="s3">.9999</span><span class="s1">&amp;&amp;t.scale&lt;=</span><span class="s3">1.0001</span><span class="s1">||isNaN(t.scale))&amp;&amp;(t.scale=</span><span class="s3">1</span><span class="s1">),(t.translate&gt;=-</span><span class="s3">.01</span><span class="s1">&amp;&amp;t.translate&lt;=</span><span class="s3">.01</span><span class="s1">||isNaN(t.translate))&amp;&amp;(t.translate=</span><span class="s3">0</span><span class="s1">)}</span><span class="s0">function </span><span class="s1">wo(t,e,n,i){To(t.x,e.x,n.x,i?i.originX:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),To(t.y,e.y,n.y,i?i.originY:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}</span><span class="s0">function </span><span class="s1">Po(t,e,n){t.min=n.min+e.min,t.max=t.min+xo(e)}</span><span class="s0">function </span><span class="s1">So(t,e,n){t.min=e.min-n.min,t.max=t.min+xo(e)}</span><span class="s0">function </span><span class="s1">bo(t,e,n){So(t.x,e.x,n.x),So(t.y,e.y,n.y)}</span><span class="s0">function </span><span class="s1">Ao(t){</span><span class="s0">return</span><span class="s1">[t(</span><span class="s2">&quot;x&quot;</span><span class="s1">),t(</span><span class="s2">&quot;y&quot;</span><span class="s1">)]}</span><span class="s0">const </span><span class="s1">Eo=({current:t})=&gt;t?t.ownerDocument.defaultView:</span><span class="s0">null</span><span class="s1">,Vo=(t,e)=&gt;Math.abs(t-e);</span><span class="s0">class </span><span class="s1">Mo{constructor(t,e,{transformPagePoint:n,contextWindow:i=window,dragSnapToOrigin:s=!</span><span class="s3">1</span><span class="s1">,distanceThreshold:o=</span><span class="s3">3</span><span class="s1">}={}){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.startEvent=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.lastMoveEvent=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.handlers={},</span><span class="s0">this</span><span class="s1">.contextWindow=window,</span><span class="s0">this</span><span class="s1">.updatePoint=()=&gt;{</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.lastMoveEvent||!</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">t=ko(</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo,</span><span class="s0">this</span><span class="s1">.history),e=</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.startEvent,n=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">n=Vo(t.x,e.x),i=Vo(t.y,e.y);</span><span class="s0">return </span><span class="s1">Math.sqrt(n**</span><span class="s3">2</span><span class="s1">+i**</span><span class="s3">2</span><span class="s1">)}(t.offset,{x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">})&gt;=</span><span class="s0">this</span><span class="s1">.distanceThreshold;</span><span class="s0">if</span><span class="s1">(!e&amp;&amp;!n)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{point:i}=t,{timestamp:s}=ct;</span><span class="s0">this</span><span class="s1">.history.push({...i,timestamp:s});</span><span class="s0">const</span><span class="s1">{onStart:o,onMove:r}=</span><span class="s0">this</span><span class="s1">.handlers;e||(o&amp;&amp;o(</span><span class="s0">this</span><span class="s1">.lastMoveEvent,t),</span><span class="s0">this</span><span class="s1">.startEvent=</span><span class="s0">this</span><span class="s1">.lastMoveEvent),r&amp;&amp;r(</span><span class="s0">this</span><span class="s1">.lastMoveEvent,t)},</span><span class="s0">this</span><span class="s1">.handlePointerMove=(t,e)=&gt;{</span><span class="s0">this</span><span class="s1">.lastMoveEvent=t,</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo=Co(e,</span><span class="s0">this</span><span class="s1">.transformPagePoint),ht.update(</span><span class="s0">this</span><span class="s1">.updatePoint,!</span><span class="s3">0</span><span class="s1">)},</span><span class="s0">this</span><span class="s1">.handlePointerUp=(t,e)=&gt;{</span><span class="s0">this</span><span class="s1">.end();</span><span class="s0">const</span><span class="s1">{onEnd:n,onSessionEnd:i,resumeAnimation:s}=</span><span class="s0">this</span><span class="s1">.handlers;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.dragSnapToOrigin&amp;&amp;s&amp;&amp;s(),!</span><span class="s0">this</span><span class="s1">.lastMoveEvent||!</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">o=ko(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s1">===t.type?</span><span class="s0">this</span><span class="s1">.lastMoveEventInfo:Co(e,</span><span class="s0">this</span><span class="s1">.transformPagePoint),</span><span class="s0">this</span><span class="s1">.history);</span><span class="s0">this</span><span class="s1">.startEvent&amp;&amp;n&amp;&amp;n(t,o),i&amp;&amp;i(t,o)},!ui(t))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.dragSnapToOrigin=s,</span><span class="s0">this</span><span class="s1">.handlers=e,</span><span class="s0">this</span><span class="s1">.transformPagePoint=n,</span><span class="s0">this</span><span class="s1">.distanceThreshold=o,</span><span class="s0">this</span><span class="s1">.contextWindow=i||window;</span><span class="s0">const </span><span class="s1">r=Co(go(t),</span><span class="s0">this</span><span class="s1">.transformPagePoint),{point:a}=r,{timestamp:l}=ct;</span><span class="s0">this</span><span class="s1">.history=[{...a,timestamp:l}];</span><span class="s0">const</span><span class="s1">{onSessionStart:h}=e;h&amp;&amp;h(t,ko(r,</span><span class="s0">this</span><span class="s1">.history)),</span><span class="s0">this</span><span class="s1">.removeListeners=A(vo(</span><span class="s0">this</span><span class="s1">.contextWindow,</span><span class="s2">&quot;pointermove&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.handlePointerMove),vo(</span><span class="s0">this</span><span class="s1">.contextWindow,</span><span class="s2">&quot;pointerup&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.handlePointerUp),vo(</span><span class="s0">this</span><span class="s1">.contextWindow,</span><span class="s2">&quot;pointercancel&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.handlePointerUp))}updateHandlers(t){</span><span class="s0">this</span><span class="s1">.handlers=t}end(){</span><span class="s0">this</span><span class="s1">.removeListeners&amp;&amp;</span><span class="s0">this</span><span class="s1">.removeListeners(),ut(</span><span class="s0">this</span><span class="s1">.updatePoint)}}</span><span class="s0">function </span><span class="s1">Co(t,e){</span><span class="s0">return </span><span class="s1">e?{point:e(t.point)}:t}</span><span class="s0">function </span><span class="s1">Do(t,e){</span><span class="s0">return</span><span class="s1">{x:t.x-e.x,y:t.y-e.y}}</span><span class="s0">function </span><span class="s1">ko({point:t},e){</span><span class="s0">return</span><span class="s1">{point:t,delta:Do(t,Lo(e)),offset:Do(t,Ro(e)),velocity:jo(e,</span><span class="s3">.1</span><span class="s1">)}}</span><span class="s0">function </span><span class="s1">Ro(t){</span><span class="s0">return </span><span class="s1">t[</span><span class="s3">0</span><span class="s1">]}</span><span class="s0">function </span><span class="s1">Lo(t){</span><span class="s0">return </span><span class="s1">t[t.length-</span><span class="s3">1</span><span class="s1">]}</span><span class="s0">function </span><span class="s1">jo(t,e){</span><span class="s0">if</span><span class="s1">(t.length&lt;</span><span class="s3">2</span><span class="s1">)</span><span class="s0">return</span><span class="s1">{x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">};</span><span class="s0">let </span><span class="s1">n=t.length-</span><span class="s3">1</span><span class="s1">,i=</span><span class="s0">null</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=Lo(t);</span><span class="s0">for</span><span class="s1">(;n&gt;=</span><span class="s3">0</span><span class="s1">&amp;&amp;(i=t[n],!(s.timestamp-i.timestamp&gt;M(e)));)n--;</span><span class="s0">if</span><span class="s1">(!i)</span><span class="s0">return</span><span class="s1">{x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">};</span><span class="s0">const </span><span class="s1">o=C(s.timestamp-i.timestamp);</span><span class="s0">if</span><span class="s1">(</span><span class="s3">0</span><span class="s1">===o)</span><span class="s0">return</span><span class="s1">{x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">};</span><span class="s0">const </span><span class="s1">r={x:(s.x-i.x)/o,y:(s.y-i.y)/o};</span><span class="s0">return </span><span class="s1">r.x===</span><span class="s3">1</span><span class="s1">/</span><span class="s3">0</span><span class="s1">&amp;&amp;(r.x=</span><span class="s3">0</span><span class="s1">),r.y===</span><span class="s3">1</span><span class="s1">/</span><span class="s3">0</span><span class="s1">&amp;&amp;(r.y=</span><span class="s3">0</span><span class="s1">),r}</span><span class="s0">function </span><span class="s1">Bo(t,e,n){</span><span class="s0">return</span><span class="s1">{min:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e?t.min+e:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,max:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n?t.max+n-(t.max-t.min):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}}</span><span class="s0">function </span><span class="s1">Fo(t,e){</span><span class="s0">let </span><span class="s1">n=e.min-t.min,i=e.max-t.max;</span><span class="s0">return </span><span class="s1">e.max-e.min&lt;t.max-t.min&amp;&amp;([n,i]=[i,n]),{min:n,max:i}}</span><span class="s0">const </span><span class="s1">Oo=</span><span class="s3">.35</span><span class="s1">;</span><span class="s0">function </span><span class="s1">Io(t,e,n){</span><span class="s0">return</span><span class="s1">{min:Uo(t,e),max:Uo(t,n)}}</span><span class="s0">function </span><span class="s1">Uo(t,e){</span><span class="s0">return</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?t:t[e]||</span><span class="s3">0</span><span class="s1">}</span><span class="s0">const </span><span class="s1">No=</span><span class="s0">new </span><span class="s1">WeakMap;</span><span class="s0">class </span><span class="s1">Wo{constructor(t){</span><span class="s0">this</span><span class="s1">.openDragLock=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isDragging=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.currentDirection=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.originPoint={x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">},</span><span class="s0">this</span><span class="s1">.constraints=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.hasMutatedConstraints=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.elastic={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.latestPointerEvent=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.latestPanInfo=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.visualElement=t}start(t,{snapToCursor:e=!</span><span class="s3">1</span><span class="s1">,distanceThreshold:n}={}){</span><span class="s0">const</span><span class="s1">{presenceContext:i}=</span><span class="s0">this</span><span class="s1">.visualElement;</span><span class="s0">if</span><span class="s1">(i&amp;&amp;!</span><span class="s3">1</span><span class="s1">===i.isPresent)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{dragSnapToOrigin:s}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">this</span><span class="s1">.panSession=</span><span class="s0">new </span><span class="s1">Mo(t,{onSessionStart:t=&gt;{</span><span class="s0">const</span><span class="s1">{dragSnapToOrigin:n}=</span><span class="s0">this</span><span class="s1">.getProps();n?</span><span class="s0">this</span><span class="s1">.pauseAnimation():</span><span class="s0">this</span><span class="s1">.stopAnimation(),e&amp;&amp;</span><span class="s0">this</span><span class="s1">.snapToCursor(go(t).point)},onStart:(t,e)=&gt;{</span><span class="s0">const</span><span class="s1">{drag:n,dragPropagation:i,onDragStart:s}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(n&amp;&amp;!i&amp;&amp;(</span><span class="s0">this</span><span class="s1">.openDragLock&amp;&amp;</span><span class="s0">this</span><span class="s1">.openDragLock(),</span><span class="s0">this</span><span class="s1">.openDragLock=</span><span class="s2">&quot;x&quot;</span><span class="s1">===(o=n)||</span><span class="s2">&quot;y&quot;</span><span class="s1">===o?oi[o]?</span><span class="s0">null</span><span class="s1">:(oi[o]=!</span><span class="s3">0</span><span class="s1">,()=&gt;{oi[o]=!</span><span class="s3">1</span><span class="s1">}):oi.x||oi.y?</span><span class="s0">null</span><span class="s1">:(oi.x=oi.y=!</span><span class="s3">0</span><span class="s1">,()=&gt;{oi.x=oi.y=!</span><span class="s3">1</span><span class="s1">}),!</span><span class="s0">this</span><span class="s1">.openDragLock))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">var </span><span class="s1">o;</span><span class="s0">this</span><span class="s1">.latestPointerEvent=t,</span><span class="s0">this</span><span class="s1">.latestPanInfo=e,</span><span class="s0">this</span><span class="s1">.isDragging=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.currentDirection=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.resolveConstraints(),</span><span class="s0">this</span><span class="s1">.visualElement.projection&amp;&amp;(</span><span class="s0">this</span><span class="s1">.visualElement.projection.isAnimationBlocked=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.visualElement.projection.target=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),Ao(t=&gt;{</span><span class="s0">let </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t).get()||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(jt.test(e)){</span><span class="s0">const</span><span class="s1">{projection:n}=</span><span class="s0">this</span><span class="s1">.visualElement;</span><span class="s0">if</span><span class="s1">(n&amp;&amp;n.layout){</span><span class="s0">const </span><span class="s1">i=n.layout.layoutBox[t];</span><span class="s0">if</span><span class="s1">(i){e=xo(i)*(parseFloat(e)/</span><span class="s3">100</span><span class="s1">)}}}</span><span class="s0">this</span><span class="s1">.originPoint[t]=e}),s&amp;&amp;ht.postRender(()=&gt;s(t,e)),Xs(</span><span class="s0">this</span><span class="s1">.visualElement,</span><span class="s2">&quot;transform&quot;</span><span class="s1">);</span><span class="s0">const</span><span class="s1">{animationState:r}=</span><span class="s0">this</span><span class="s1">.visualElement;r&amp;&amp;r.setActive(</span><span class="s2">&quot;whileDrag&quot;</span><span class="s1">,!</span><span class="s3">0</span><span class="s1">)},onMove:(t,e)=&gt;{</span><span class="s0">this</span><span class="s1">.latestPointerEvent=t,</span><span class="s0">this</span><span class="s1">.latestPanInfo=e;</span><span class="s0">const</span><span class="s1">{dragPropagation:n,dragDirectionLock:i,onDirectionLock:s,onDrag:o}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(!n&amp;&amp;!</span><span class="s0">this</span><span class="s1">.openDragLock)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{offset:r}=e;</span><span class="s0">if</span><span class="s1">(i&amp;&amp;</span><span class="s0">null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.currentDirection)</span><span class="s0">return this</span><span class="s1">.currentDirection=</span><span class="s0">function</span><span class="s1">(t,e=</span><span class="s3">10</span><span class="s1">){</span><span class="s0">let </span><span class="s1">n=</span><span class="s0">null</span><span class="s1">;Math.abs(t.y)&gt;e?n=</span><span class="s2">&quot;y&quot;</span><span class="s1">:Math.abs(t.x)&gt;e&amp;&amp;(n=</span><span class="s2">&quot;x&quot;</span><span class="s1">);</span><span class="s0">return </span><span class="s1">n}(r),</span><span class="s0">void</span><span class="s1">(</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.currentDirection&amp;&amp;s&amp;&amp;s(</span><span class="s0">this</span><span class="s1">.currentDirection));</span><span class="s0">this</span><span class="s1">.updateAxis(</span><span class="s2">&quot;x&quot;</span><span class="s1">,e.point,r),</span><span class="s0">this</span><span class="s1">.updateAxis(</span><span class="s2">&quot;y&quot;</span><span class="s1">,e.point,r),</span><span class="s0">this</span><span class="s1">.visualElement.render(),o&amp;&amp;o(t,e)},onSessionEnd:(t,e)=&gt;{</span><span class="s0">this</span><span class="s1">.latestPointerEvent=t,</span><span class="s0">this</span><span class="s1">.latestPanInfo=e,</span><span class="s0">this</span><span class="s1">.stop(t,e),</span><span class="s0">this</span><span class="s1">.latestPointerEvent=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.latestPanInfo=</span><span class="s0">null</span><span class="s1">},resumeAnimation:()=&gt;Ao(t=&gt;</span><span class="s2">&quot;paused&quot;</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.getAnimationState(t)&amp;&amp;</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t).animation?.play())},{transformPagePoint:</span><span class="s0">this</span><span class="s1">.visualElement.getTransformPagePoint(),dragSnapToOrigin:s,distanceThreshold:n,contextWindow:Eo(</span><span class="s0">this</span><span class="s1">.visualElement)})}stop(t,e){</span><span class="s0">const </span><span class="s1">n=t||</span><span class="s0">this</span><span class="s1">.latestPointerEvent,i=e||</span><span class="s0">this</span><span class="s1">.latestPanInfo,s=</span><span class="s0">this</span><span class="s1">.isDragging;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.cancel(),!s||!i||!n)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{velocity:o}=i;</span><span class="s0">this</span><span class="s1">.startAnimation(o);</span><span class="s0">const</span><span class="s1">{onDragEnd:r}=</span><span class="s0">this</span><span class="s1">.getProps();r&amp;&amp;ht.postRender(()=&gt;r(n,i))}cancel(){</span><span class="s0">this</span><span class="s1">.isDragging=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{projection:t,animationState:e}=</span><span class="s0">this</span><span class="s1">.visualElement;t&amp;&amp;(t.isAnimationBlocked=!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.panSession&amp;&amp;</span><span class="s0">this</span><span class="s1">.panSession.end(),</span><span class="s0">this</span><span class="s1">.panSession=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{dragPropagation:n}=</span><span class="s0">this</span><span class="s1">.getProps();!n&amp;&amp;</span><span class="s0">this</span><span class="s1">.openDragLock&amp;&amp;(</span><span class="s0">this</span><span class="s1">.openDragLock(),</span><span class="s0">this</span><span class="s1">.openDragLock=</span><span class="s0">null</span><span class="s1">),e&amp;&amp;e.setActive(</span><span class="s2">&quot;whileDrag&quot;</span><span class="s1">,!</span><span class="s3">1</span><span class="s1">)}updateAxis(t,e,n){</span><span class="s0">const</span><span class="s1">{drag:i}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(!n||!$o(t,i,</span><span class="s0">this</span><span class="s1">.currentDirection))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t);</span><span class="s0">let </span><span class="s1">o=</span><span class="s0">this</span><span class="s1">.originPoint[t]+n[t];</span><span class="s0">this</span><span class="s1">.constraints&amp;&amp;</span><span class="s0">this</span><span class="s1">.constraints[t]&amp;&amp;(o=</span><span class="s0">function</span><span class="s1">(t,{min:e,max:n},i){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==e&amp;&amp;t&lt;e?t=i?Jt(e,t,i.min):Math.max(t,e):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==n&amp;&amp;t&gt;n&amp;&amp;(t=i?Jt(n,t,i.max):Math.min(t,n)),t}(o,</span><span class="s0">this</span><span class="s1">.constraints[t],</span><span class="s0">this</span><span class="s1">.elastic[t])),s.set(o)}resolveConstraints(){</span><span class="s0">const</span><span class="s1">{dragConstraints:t,dragElastic:e}=</span><span class="s0">this</span><span class="s1">.getProps(),n=</span><span class="s0">this</span><span class="s1">.visualElement.projection&amp;&amp;!</span><span class="s0">this</span><span class="s1">.visualElement.projection.layout?</span><span class="s0">this</span><span class="s1">.visualElement.projection.measure(!</span><span class="s3">1</span><span class="s1">):</span><span class="s0">this</span><span class="s1">.visualElement.projection?.layout,i=</span><span class="s0">this</span><span class="s1">.constraints;t&amp;&amp;ns(t)?</span><span class="s0">this</span><span class="s1">.constraints||(</span><span class="s0">this</span><span class="s1">.constraints=</span><span class="s0">this</span><span class="s1">.resolveRefConstraints()):</span><span class="s0">this</span><span class="s1">.constraints=!(!t||!n)&amp;&amp;</span><span class="s0">function</span><span class="s1">(t,{top:e,left:n,bottom:i,right:s}){</span><span class="s0">return</span><span class="s1">{x:Bo(t.x,n,s),y:Bo(t.y,e,i)}}(n.layoutBox,t),</span><span class="s0">this</span><span class="s1">.elastic=</span><span class="s0">function</span><span class="s1">(t=Oo){</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">===t?t=</span><span class="s3">0</span><span class="s1">:!</span><span class="s3">0</span><span class="s1">===t&amp;&amp;(t=Oo),{x:Io(t,</span><span class="s2">&quot;left&quot;</span><span class="s1">,</span><span class="s2">&quot;right&quot;</span><span class="s1">),y:Io(t,</span><span class="s2">&quot;top&quot;</span><span class="s1">,</span><span class="s2">&quot;bottom&quot;</span><span class="s1">)}}(e),i!==</span><span class="s0">this</span><span class="s1">.constraints&amp;&amp;n&amp;&amp;</span><span class="s0">this</span><span class="s1">.constraints&amp;&amp;!</span><span class="s0">this</span><span class="s1">.hasMutatedConstraints&amp;&amp;Ao(t=&gt;{!</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.constraints&amp;&amp;</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.constraints[t]=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">n={};</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==e.min&amp;&amp;(n.min=e.min-t.min),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e.max&amp;&amp;(n.max=e.max-t.min),n}(n.layoutBox[t],</span><span class="s0">this</span><span class="s1">.constraints[t]))})}resolveRefConstraints(){</span><span class="s0">const</span><span class="s1">{dragConstraints:t,onMeasureDragConstraints:e}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(!t||!ns(t))</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=t.current,{projection:i}=</span><span class="s0">this</span><span class="s1">.visualElement;</span><span class="s0">if</span><span class="s1">(!i||!i.layout)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">function</span><span class="s1">(t,e,n){</span><span class="s0">const </span><span class="s1">i=Vs(t,n),{scroll:s}=e;</span><span class="s0">return </span><span class="s1">s&amp;&amp;(bs(i.x,s.offset.x),bs(i.y,s.offset.y)),i}(n,i.root,</span><span class="s0">this</span><span class="s1">.visualElement.getTransformPagePoint());</span><span class="s0">let </span><span class="s1">o=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">return</span><span class="s1">{x:Fo(t.x,e.x),y:Fo(t.y,e.y)}}(i.layout.layoutBox,s);</span><span class="s0">if</span><span class="s1">(e){</span><span class="s0">const </span><span class="s1">t=e(</span><span class="s0">function</span><span class="s1">({x:t,y:e}){</span><span class="s0">return</span><span class="s1">{top:e.min,right:t.max,bottom:e.max,left:t.min}}(o));</span><span class="s0">this</span><span class="s1">.hasMutatedConstraints=!!t,t&amp;&amp;(o=ds(t))}</span><span class="s0">return </span><span class="s1">o}startAnimation(t){</span><span class="s0">const</span><span class="s1">{drag:e,dragMomentum:n,dragElastic:i,dragTransition:s,dragSnapToOrigin:o,onDragTransitionEnd:r}=</span><span class="s0">this</span><span class="s1">.getProps(),a=</span><span class="s0">this</span><span class="s1">.constraints||{},l=Ao(r=&gt;{</span><span class="s0">if</span><span class="s1">(!$o(r,e,</span><span class="s0">this</span><span class="s1">.currentDirection))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">let </span><span class="s1">l=a&amp;&amp;a[r]||{};o&amp;&amp;(l={min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">});</span><span class="s0">const </span><span class="s1">h=i?</span><span class="s3">200</span><span class="s1">:</span><span class="s3">1e6</span><span class="s1">,u=i?</span><span class="s3">40</span><span class="s1">:</span><span class="s3">1e7</span><span class="s1">,c={type:</span><span class="s2">&quot;inertia&quot;</span><span class="s1">,velocity:n?t[r]:</span><span class="s3">0</span><span class="s1">,bounceStiffness:h,bounceDamping:u,timeConstant:</span><span class="s3">750</span><span class="s1">,restDelta:</span><span class="s3">1</span><span class="s1">,restSpeed:</span><span class="s3">10</span><span class="s1">,...s,...l};</span><span class="s0">return this</span><span class="s1">.startAxisValueAnimation(r,c)});</span><span class="s0">return </span><span class="s1">Promise.all(l).then(r)}startAxisValueAnimation(t,e){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t);</span><span class="s0">return </span><span class="s1">Xs(</span><span class="s0">this</span><span class="s1">.visualElement,t),n.start(_s(t,n,</span><span class="s3">0</span><span class="s1">,e,</span><span class="s0">this</span><span class="s1">.visualElement,!</span><span class="s3">1</span><span class="s1">))}stopAnimation(){Ao(t=&gt;</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t).stop())}pauseAnimation(){Ao(t=&gt;</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t).animation?.pause())}getAnimationState(t){</span><span class="s0">return this</span><span class="s1">.getAxisMotionValue(t).animation?.state}getAxisMotionValue(t){</span><span class="s0">const </span><span class="s1">e=</span><span class="s2">`_drag</span><span class="s1">${t.toUpperCase()}</span><span class="s2">`</span><span class="s1">,n=</span><span class="s0">this</span><span class="s1">.visualElement.getProps(),i=n[e];</span><span class="s0">return </span><span class="s1">i||</span><span class="s0">this</span><span class="s1">.visualElement.getValue(t,(n.initial?n.initial[t]:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)||</span><span class="s3">0</span><span class="s1">)}snapToCursor(t){Ao(e=&gt;{</span><span class="s0">const</span><span class="s1">{drag:n}=</span><span class="s0">this</span><span class="s1">.getProps();</span><span class="s0">if</span><span class="s1">(!$o(e,n,</span><span class="s0">this</span><span class="s1">.currentDirection))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{projection:i}=</span><span class="s0">this</span><span class="s1">.visualElement,s=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(e);</span><span class="s0">if</span><span class="s1">(i&amp;&amp;i.layout){</span><span class="s0">const</span><span class="s1">{min:n,max:o}=i.layout.layoutBox[e];s.set(t[e]-Jt(n,o,</span><span class="s3">.5</span><span class="s1">))}})}scalePositionWithinConstraints(){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.visualElement.current)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{drag:t,dragConstraints:e}=</span><span class="s0">this</span><span class="s1">.getProps(),{projection:n}=</span><span class="s0">this</span><span class="s1">.visualElement;</span><span class="s0">if</span><span class="s1">(!ns(e)||!n||!</span><span class="s0">this</span><span class="s1">.constraints)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.stopAnimation();</span><span class="s0">const </span><span class="s1">i={x:</span><span class="s3">0</span><span class="s1">,y:</span><span class="s3">0</span><span class="s1">};Ao(t=&gt;{</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(t);</span><span class="s0">if</span><span class="s1">(e&amp;&amp;!</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.constraints){</span><span class="s0">const </span><span class="s1">n=e.get();i[t]=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">.5</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=xo(t),s=xo(e);</span><span class="s0">return </span><span class="s1">s&gt;i?n=E(e.min,e.max-i,t.min):i&gt;s&amp;&amp;(n=E(t.min,t.max-s,e.min)),g(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,n)}({min:n,max:n},</span><span class="s0">this</span><span class="s1">.constraints[t])}});</span><span class="s0">const</span><span class="s1">{transformTemplate:s}=</span><span class="s0">this</span><span class="s1">.visualElement.getProps();</span><span class="s0">this</span><span class="s1">.visualElement.current.style.transform=s?s({},</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s2">&quot;none&quot;</span><span class="s1">,n.root&amp;&amp;n.root.updateScroll(),n.updateLayout(),</span><span class="s0">this</span><span class="s1">.resolveConstraints(),Ao(e=&gt;{</span><span class="s0">if</span><span class="s1">(!$o(e,t,</span><span class="s0">null</span><span class="s1">))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(e),{min:s,max:o}=</span><span class="s0">this</span><span class="s1">.constraints[e];n.set(Jt(s,o,i[e]))})}addListeners(){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.visualElement.current)</span><span class="s0">return</span><span class="s1">;No.set(</span><span class="s0">this</span><span class="s1">.visualElement,</span><span class="s0">this</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=vo(</span><span class="s0">this</span><span class="s1">.visualElement.current,</span><span class="s2">&quot;pointerdown&quot;</span><span class="s1">,t=&gt;{</span><span class="s0">const</span><span class="s1">{drag:e,dragListener:n=!</span><span class="s3">0</span><span class="s1">}=</span><span class="s0">this</span><span class="s1">.getProps();e&amp;&amp;n&amp;&amp;</span><span class="s0">this</span><span class="s1">.start(t)}),e=()=&gt;{</span><span class="s0">const</span><span class="s1">{dragConstraints:t}=</span><span class="s0">this</span><span class="s1">.getProps();ns(t)&amp;&amp;t.current&amp;&amp;(</span><span class="s0">this</span><span class="s1">.constraints=</span><span class="s0">this</span><span class="s1">.resolveRefConstraints())},{projection:n}=</span><span class="s0">this</span><span class="s1">.visualElement,i=n.addEventListener(</span><span class="s2">&quot;measure&quot;</span><span class="s1">,e);n&amp;&amp;!n.layout&amp;&amp;(n.root&amp;&amp;n.root.updateScroll(),n.updateLayout()),ht.read(e);</span><span class="s0">const </span><span class="s1">s=yo(window,</span><span class="s2">&quot;resize&quot;</span><span class="s1">,()=&gt;</span><span class="s0">this</span><span class="s1">.scalePositionWithinConstraints()),o=n.addEventListener(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s1">,({delta:t,hasLayoutChanged:e})=&gt;{</span><span class="s0">this</span><span class="s1">.isDragging&amp;&amp;e&amp;&amp;(Ao(e=&gt;{</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.getAxisMotionValue(e);n&amp;&amp;(</span><span class="s0">this</span><span class="s1">.originPoint[e]+=t[e].translate,n.set(n.get()+t[e].translate))}),</span><span class="s0">this</span><span class="s1">.visualElement.render())});</span><span class="s0">return</span><span class="s1">()=&gt;{s(),t(),i(),o&amp;&amp;o()}}getProps(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.visualElement.getProps(),{drag:e=!</span><span class="s3">1</span><span class="s1">,dragDirectionLock:n=!</span><span class="s3">1</span><span class="s1">,dragPropagation:i=!</span><span class="s3">1</span><span class="s1">,dragConstraints:s=!</span><span class="s3">1</span><span class="s1">,dragElastic:o=Oo,dragMomentum:r=!</span><span class="s3">0</span><span class="s1">}=t;</span><span class="s0">return</span><span class="s1">{...t,drag:e,dragDirectionLock:n,dragPropagation:i,dragConstraints:s,dragElastic:o,dragMomentum:r}}}</span><span class="s0">function </span><span class="s1">$o(t,e,n){</span><span class="s0">return</span><span class="s1">!(!</span><span class="s3">0</span><span class="s1">!==e&amp;&amp;e!==t||</span><span class="s0">null</span><span class="s1">!==n&amp;&amp;n!==t)}</span><span class="s0">const </span><span class="s1">Yo=t=&gt;(e,n)=&gt;{t&amp;&amp;ht.postRender(()=&gt;t(e,n))};</span><span class="s0">const </span><span class="s1">Xo=(t,e)=&gt;t.depth-e.depth;</span><span class="s0">class </span><span class="s1">Ko{constructor(){</span><span class="s0">this</span><span class="s1">.children=[],</span><span class="s0">this</span><span class="s1">.isDirty=!</span><span class="s3">1</span><span class="s1">}add(t){f(</span><span class="s0">this</span><span class="s1">.children,t),</span><span class="s0">this</span><span class="s1">.isDirty=!</span><span class="s3">0</span><span class="s1">}remove(t){y(</span><span class="s0">this</span><span class="s1">.children,t),</span><span class="s0">this</span><span class="s1">.isDirty=!</span><span class="s3">0</span><span class="s1">}forEach(t){</span><span class="s0">this</span><span class="s1">.isDirty&amp;&amp;</span><span class="s0">this</span><span class="s1">.children.sort(Xo),</span><span class="s0">this</span><span class="s1">.isDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.children.forEach(t)}}</span><span class="s0">const </span><span class="s1">zo=[</span><span class="s2">&quot;TopLeft&quot;</span><span class="s1">,</span><span class="s2">&quot;TopRight&quot;</span><span class="s1">,</span><span class="s2">&quot;BottomLeft&quot;</span><span class="s1">,</span><span class="s2">&quot;BottomRight&quot;</span><span class="s1">],Ho=zo.length,Go=t=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t?parseFloat(t):t,qo=t=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t||Bt.test(t);</span><span class="s0">function </span><span class="s1">Zo(t,e){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==t[e]?t[e]:t.borderRadius}</span><span class="s0">const </span><span class="s1">_o=Qo(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.5</span><span class="s1">,N),Jo=Qo(</span><span class="s3">.5</span><span class="s1">,</span><span class="s3">.95</span><span class="s1">,S);</span><span class="s0">function </span><span class="s1">Qo(t,e,n){</span><span class="s0">return </span><span class="s1">i=&gt;i&lt;t?</span><span class="s3">0</span><span class="s1">:i&gt;e?</span><span class="s3">1</span><span class="s1">:n(E(t,e,i))}</span><span class="s0">function </span><span class="s1">tr(t,e){t.min=e.min,t.max=e.max}</span><span class="s0">function </span><span class="s1">er(t,e){tr(t.x,e.x),tr(t.y,e.y)}</span><span class="s0">function </span><span class="s1">nr(t,e){t.translate=e.translate,t.scale=e.scale,t.originPoint=e.originPoint,t.origin=e.origin}</span><span class="s0">function </span><span class="s1">ir(t,e,n,i,s){</span><span class="s0">return </span><span class="s1">t=vs(t-=e,</span><span class="s3">1</span><span class="s1">/n,i),</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s&amp;&amp;(t=vs(t,</span><span class="s3">1</span><span class="s1">/s,i)),t}</span><span class="s0">function </span><span class="s1">sr(t,e,[n,i,s],o,r){!</span><span class="s0">function</span><span class="s1">(t,e=</span><span class="s3">0</span><span class="s1">,n=</span><span class="s3">1</span><span class="s1">,i=</span><span class="s3">.5</span><span class="s1">,s,o=t,r=t){jt.test(e)&amp;&amp;(e=parseFloat(e),e=Jt(r.min,r.max,e/</span><span class="s3">100</span><span class="s1">)-r.min);</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">let </span><span class="s1">a=Jt(o.min,o.max,i);t===o&amp;&amp;(a-=e),t.min=ir(t.min,e,n,a,s),t.max=ir(t.max,e,n,a,s)}(t,e[n],e[i],e[s],e.scale,o,r)}</span><span class="s0">const </span><span class="s1">or=[</span><span class="s2">&quot;x&quot;</span><span class="s1">,</span><span class="s2">&quot;scaleX&quot;</span><span class="s1">,</span><span class="s2">&quot;originX&quot;</span><span class="s1">],rr=[</span><span class="s2">&quot;y&quot;</span><span class="s1">,</span><span class="s2">&quot;scaleY&quot;</span><span class="s1">,</span><span class="s2">&quot;originY&quot;</span><span class="s1">];</span><span class="s0">function </span><span class="s1">ar(t,e,n,i){sr(t.x,e,or,n?n.x:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,i?i.x:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),sr(t.y,e,rr,n?n.y:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,i?i.y:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}</span><span class="s0">function </span><span class="s1">lr(t){</span><span class="s0">return </span><span class="s3">0</span><span class="s1">===t.translate&amp;&amp;</span><span class="s3">1</span><span class="s1">===t.scale}</span><span class="s0">function </span><span class="s1">hr(t){</span><span class="s0">return </span><span class="s1">lr(t.x)&amp;&amp;lr(t.y)}</span><span class="s0">function </span><span class="s1">ur(t,e){</span><span class="s0">return </span><span class="s1">t.min===e.min&amp;&amp;t.max===e.max}</span><span class="s0">function </span><span class="s1">cr(t,e){</span><span class="s0">return </span><span class="s1">Math.round(t.min)===Math.round(e.min)&amp;&amp;Math.round(t.max)===Math.round(e.max)}</span><span class="s0">function </span><span class="s1">dr(t,e){</span><span class="s0">return </span><span class="s1">cr(t.x,e.x)&amp;&amp;cr(t.y,e.y)}</span><span class="s0">function </span><span class="s1">pr(t){</span><span class="s0">return </span><span class="s1">xo(t.x)/xo(t.y)}</span><span class="s0">function </span><span class="s1">mr(t,e){</span><span class="s0">return </span><span class="s1">t.translate===e.translate&amp;&amp;t.scale===e.scale&amp;&amp;t.originPoint===e.originPoint}</span><span class="s0">class </span><span class="s1">fr{constructor(){</span><span class="s0">this</span><span class="s1">.members=[]}add(t){f(</span><span class="s0">this</span><span class="s1">.members,t),t.scheduleRender()}remove(t){</span><span class="s0">if</span><span class="s1">(y(</span><span class="s0">this</span><span class="s1">.members,t),t===</span><span class="s0">this</span><span class="s1">.prevLead&amp;&amp;(</span><span class="s0">this</span><span class="s1">.prevLead=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),t===</span><span class="s0">this</span><span class="s1">.lead){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.members[</span><span class="s0">this</span><span class="s1">.members.length-</span><span class="s3">1</span><span class="s1">];t&amp;&amp;</span><span class="s0">this</span><span class="s1">.promote(t)}}relegate(t){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.members.findIndex(e=&gt;t===e);</span><span class="s0">if</span><span class="s1">(</span><span class="s3">0</span><span class="s1">===e)</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">let </span><span class="s1">n;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=e;t&gt;=</span><span class="s3">0</span><span class="s1">;t--){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.members[t];</span><span class="s0">if</span><span class="s1">(!</span><span class="s3">1</span><span class="s1">!==e.isPresent){n=e;</span><span class="s0">break</span><span class="s1">}}</span><span class="s0">return</span><span class="s1">!!n&amp;&amp;(</span><span class="s0">this</span><span class="s1">.promote(n),!</span><span class="s3">0</span><span class="s1">)}promote(t,e){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.lead;</span><span class="s0">if</span><span class="s1">(t!==n&amp;&amp;(</span><span class="s0">this</span><span class="s1">.prevLead=n,</span><span class="s0">this</span><span class="s1">.lead=t,t.show(),n)){n.instance&amp;&amp;n.scheduleRender(),t.scheduleRender(),t.resumeFrom=n,e&amp;&amp;(t.resumeFrom.preserveOpacity=!</span><span class="s3">0</span><span class="s1">),n.snapshot&amp;&amp;(t.snapshot=n.snapshot,t.snapshot.latestValues=n.animationValues||n.latestValues),t.root&amp;&amp;t.root.isUpdating&amp;&amp;(t.isLayoutDirty=!</span><span class="s3">0</span><span class="s1">);</span><span class="s0">const</span><span class="s1">{crossfade:i}=t.options;!</span><span class="s3">1</span><span class="s1">===i&amp;&amp;n.hide()}}exitAnimationComplete(){</span><span class="s0">this</span><span class="s1">.members.forEach(t=&gt;{</span><span class="s0">const</span><span class="s1">{options:e,resumingFrom:n}=t;e.onExitComplete&amp;&amp;e.onExitComplete(),n&amp;&amp;n.options.onExitComplete&amp;&amp;n.options.onExitComplete()})}scheduleRender(){</span><span class="s0">this</span><span class="s1">.members.forEach(t=&gt;{t.instance&amp;&amp;t.scheduleRender(!</span><span class="s3">1</span><span class="s1">)})}removeLeadSnapshot(){</span><span class="s0">this</span><span class="s1">.lead&amp;&amp;</span><span class="s0">this</span><span class="s1">.lead.snapshot&amp;&amp;(</span><span class="s0">this</span><span class="s1">.lead.snapshot=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}}</span><span class="s0">const </span><span class="s1">yr={hasAnimatedSinceResize:!</span><span class="s3">0</span><span class="s1">,hasEverUpdated:!</span><span class="s3">1</span><span class="s1">},gr=[</span><span class="s2">&quot;&quot;</span><span class="s1">,</span><span class="s2">&quot;X&quot;</span><span class="s1">,</span><span class="s2">&quot;Y&quot;</span><span class="s1">,</span><span class="s2">&quot;Z&quot;</span><span class="s1">];</span><span class="s0">let </span><span class="s1">vr=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">function </span><span class="s1">xr(t,e,n,i){</span><span class="s0">const</span><span class="s1">{latestValues:s}=e;s[t]&amp;&amp;(n[t]=s[t],e.setStaticValue(t,</span><span class="s3">0</span><span class="s1">),i&amp;&amp;(i[t]=</span><span class="s3">0</span><span class="s1">))}</span><span class="s0">function </span><span class="s1">Tr(t){</span><span class="s0">if</span><span class="s1">(t.hasCheckedOptimisedAppear=!</span><span class="s3">0</span><span class="s1">,t.root===t)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{visualElement:e}=t.options;</span><span class="s0">if</span><span class="s1">(!e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">n=Ks(e);</span><span class="s0">if</span><span class="s1">(window.MotionHasOptimisedAnimation(n,</span><span class="s2">&quot;transform&quot;</span><span class="s1">)){</span><span class="s0">const</span><span class="s1">{layout:e,layoutId:i}=t.options;window.MotionCancelOptimisedAnimation(n,</span><span class="s2">&quot;transform&quot;</span><span class="s1">,ht,!(e||i))}</span><span class="s0">const</span><span class="s1">{parent:i}=t;i&amp;&amp;!i.hasCheckedOptimisedAppear&amp;&amp;Tr(i)}</span><span class="s0">function </span><span class="s1">wr({attachResizeListener:t,defaultParent:e,measureScroll:n,checkIsScrollRoot:i,resetTransform:s}){</span><span class="s0">return class</span><span class="s1">{constructor(t={},n=e?.()){</span><span class="s0">this</span><span class="s1">.id=vr++,</span><span class="s0">this</span><span class="s1">.animationId=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.animationCommitId=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.children=</span><span class="s0">new </span><span class="s1">Set,</span><span class="s0">this</span><span class="s1">.options={},</span><span class="s0">this</span><span class="s1">.isTreeAnimating=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isAnimationBlocked=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isProjectionDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isTransformDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateManuallyBlocked=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateBlockedByResize=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isUpdating=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isSVG=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.needsReset=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.shouldResetTransform=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.hasCheckedOptimisedAppear=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.treeScale={x:</span><span class="s3">1</span><span class="s1">,y:</span><span class="s3">1</span><span class="s1">},</span><span class="s0">this</span><span class="s1">.eventHandlers=</span><span class="s0">new </span><span class="s1">Map,</span><span class="s0">this</span><span class="s1">.hasTreeAnimated=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateScheduled=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scheduleUpdate=()=&gt;</span><span class="s0">this</span><span class="s1">.update(),</span><span class="s0">this</span><span class="s1">.projectionUpdateScheduled=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.checkUpdateFailed=()=&gt;{</span><span class="s0">this</span><span class="s1">.isUpdating&amp;&amp;(</span><span class="s0">this</span><span class="s1">.isUpdating=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.clearAllSnapshots())},</span><span class="s0">this</span><span class="s1">.updateProjection=()=&gt;{</span><span class="s0">this</span><span class="s1">.projectionUpdateScheduled=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.nodes.forEach(br),</span><span class="s0">this</span><span class="s1">.nodes.forEach(kr),</span><span class="s0">this</span><span class="s1">.nodes.forEach(Rr),</span><span class="s0">this</span><span class="s1">.nodes.forEach(Ar)},</span><span class="s0">this</span><span class="s1">.resolvedRelativeTargetAt=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.hasProjected=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isVisible=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.animationProgress=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.sharedNodes=</span><span class="s0">new </span><span class="s1">Map,</span><span class="s0">this</span><span class="s1">.latestValues=t,</span><span class="s0">this</span><span class="s1">.root=n?n.root||n:</span><span class="s0">this</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.path=n?[...n.path,n]:[],</span><span class="s0">this</span><span class="s1">.parent=n,</span><span class="s0">this</span><span class="s1">.depth=n?n.depth+</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++)</span><span class="s0">this</span><span class="s1">.path[t].shouldResetTransform=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.root===</span><span class="s0">this</span><span class="s1">&amp;&amp;(</span><span class="s0">this</span><span class="s1">.nodes=</span><span class="s0">new </span><span class="s1">Ko)}addEventListener(t,e){</span><span class="s0">return this</span><span class="s1">.eventHandlers.has(t)||</span><span class="s0">this</span><span class="s1">.eventHandlers.set(t,</span><span class="s0">new </span><span class="s1">V),</span><span class="s0">this</span><span class="s1">.eventHandlers.get(t).add(e)}notifyListeners(t,...e){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.eventHandlers.get(t);n&amp;&amp;n.notify(...e)}hasListeners(t){</span><span class="s0">return this</span><span class="s1">.eventHandlers.has(t)}mount(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.instance)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">var </span><span class="s1">n;</span><span class="s0">this</span><span class="s1">.isSVG=gi(e)&amp;&amp;!(gi(n=e)&amp;&amp;</span><span class="s2">&quot;svg&quot;</span><span class="s1">===n.tagName),</span><span class="s0">this</span><span class="s1">.instance=e;</span><span class="s0">const</span><span class="s1">{layoutId:i,layout:s,visualElement:o}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(o&amp;&amp;!o.current&amp;&amp;o.mount(e),</span><span class="s0">this</span><span class="s1">.root.nodes.add(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.parent.children.add(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.root.hasTreeAnimated&amp;&amp;(s||i)&amp;&amp;(</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">0</span><span class="s1">),t){</span><span class="s0">let </span><span class="s1">n,i=</span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=()=&gt;</span><span class="s0">this</span><span class="s1">.root.updateBlockedByResize=!</span><span class="s3">1</span><span class="s1">;ht.read(()=&gt;{i=window.innerWidth}),t(e,()=&gt;{</span><span class="s0">const </span><span class="s1">t=window.innerWidth;t!==i&amp;&amp;(i=t,</span><span class="s0">this</span><span class="s1">.root.updateBlockedByResize=!</span><span class="s3">0</span><span class="s1">,n&amp;&amp;n(),n=</span><span class="s0">function</span><span class="s1">(t,e){</span><span class="s0">const </span><span class="s1">n=ft.now(),i=({timestamp:s})=&gt;{</span><span class="s0">const </span><span class="s1">o=s-n;o&gt;=e&amp;&amp;(ut(i),t(o-e))};</span><span class="s0">return </span><span class="s1">ht.setup(i,!</span><span class="s3">0</span><span class="s1">),()=&gt;ut(i)}(s,</span><span class="s3">250</span><span class="s1">),yr.hasAnimatedSinceResize&amp;&amp;(yr.hasAnimatedSinceResize=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.nodes.forEach(Dr)))})}i&amp;&amp;</span><span class="s0">this</span><span class="s1">.root.registerSharedNode(i,</span><span class="s0">this</span><span class="s1">),!</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.options.animate&amp;&amp;o&amp;&amp;(i||s)&amp;&amp;</span><span class="s0">this</span><span class="s1">.addEventListener(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s1">,({delta:t,hasLayoutChanged:e,hasRelativeLayoutChanged:n,layout:i})=&gt;{</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isTreeAnimationBlocked())</span><span class="s0">return this</span><span class="s1">.target=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">void</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">this</span><span class="s1">.options.transition||o.getDefaultTransition()||Ir,{onLayoutAnimationStart:r,onLayoutAnimationComplete:a}=o.getProps(),l=!</span><span class="s0">this</span><span class="s1">.targetLayout||!dr(</span><span class="s0">this</span><span class="s1">.targetLayout,i),h=!e&amp;&amp;n;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.options.layoutRoot||</span><span class="s0">this</span><span class="s1">.resumeFrom||h||e&amp;&amp;(l||!</span><span class="s0">this</span><span class="s1">.currentAnimation)){</span><span class="s0">this</span><span class="s1">.resumeFrom&amp;&amp;(</span><span class="s0">this</span><span class="s1">.resumingFrom=</span><span class="s0">this</span><span class="s1">.resumeFrom,</span><span class="s0">this</span><span class="s1">.resumingFrom.resumingFrom=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">e={...On(s,</span><span class="s2">&quot;layout&quot;</span><span class="s1">),onPlay:r,onComplete:a};(o.shouldReduceMotion||</span><span class="s0">this</span><span class="s1">.options.layoutRoot)&amp;&amp;(e.delay=</span><span class="s3">0</span><span class="s1">,e.type=!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.startAnimation(e),</span><span class="s0">this</span><span class="s1">.setAnimationOrigin(t,h)}</span><span class="s0">else </span><span class="s1">e||Dr(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.isLead()&amp;&amp;</span><span class="s0">this</span><span class="s1">.options.onExitComplete&amp;&amp;</span><span class="s0">this</span><span class="s1">.options.onExitComplete();</span><span class="s0">this</span><span class="s1">.targetLayout=i})}unmount(){</span><span class="s0">this</span><span class="s1">.options.layoutId&amp;&amp;</span><span class="s0">this</span><span class="s1">.willUpdate(),</span><span class="s0">this</span><span class="s1">.root.nodes.remove(</span><span class="s0">this</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();t&amp;&amp;t.remove(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.parent.children.delete(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.instance=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.eventHandlers.clear(),ut(</span><span class="s0">this</span><span class="s1">.updateProjection)}blockUpdate(){</span><span class="s0">this</span><span class="s1">.updateManuallyBlocked=!</span><span class="s3">0</span><span class="s1">}unblockUpdate(){</span><span class="s0">this</span><span class="s1">.updateManuallyBlocked=!</span><span class="s3">1</span><span class="s1">}isUpdateBlocked(){</span><span class="s0">return this</span><span class="s1">.updateManuallyBlocked||</span><span class="s0">this</span><span class="s1">.updateBlockedByResize}isTreeAnimationBlocked(){</span><span class="s0">return this</span><span class="s1">.isAnimationBlocked||</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.parent.isTreeAnimationBlocked()||!</span><span class="s3">1</span><span class="s1">}startUpdate(){</span><span class="s0">this</span><span class="s1">.isUpdateBlocked()||(</span><span class="s0">this</span><span class="s1">.isUpdating=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.nodes&amp;&amp;</span><span class="s0">this</span><span class="s1">.nodes.forEach(Lr),</span><span class="s0">this</span><span class="s1">.animationId++)}getTransformTemplate(){</span><span class="s0">const</span><span class="s1">{visualElement:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">return </span><span class="s1">t&amp;&amp;t.getProps().transformTemplate}willUpdate(t=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.root.hasTreeAnimated=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.root.isUpdateBlocked())</span><span class="s0">return void</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.options.onExitComplete&amp;&amp;</span><span class="s0">this</span><span class="s1">.options.onExitComplete());</span><span class="s0">if</span><span class="s1">(window.MotionCancelOptimisedAnimation&amp;&amp;!</span><span class="s0">this</span><span class="s1">.hasCheckedOptimisedAppear&amp;&amp;Tr(</span><span class="s0">this</span><span class="s1">),!</span><span class="s0">this</span><span class="s1">.root.isUpdating&amp;&amp;</span><span class="s0">this</span><span class="s1">.root.startUpdate(),</span><span class="s0">this</span><span class="s1">.isLayoutDirty)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.path[t];e.shouldResetTransform=!</span><span class="s3">0</span><span class="s1">,e.updateScroll(</span><span class="s2">&quot;snapshot&quot;</span><span class="s1">),e.options.layoutRoot&amp;&amp;e.willUpdate(!</span><span class="s3">1</span><span class="s1">)}</span><span class="s0">const</span><span class="s1">{layoutId:e,layout:n}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e&amp;&amp;!n)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.getTransformTemplate();</span><span class="s0">this</span><span class="s1">.prevTransformTemplateValue=i?i(</span><span class="s0">this</span><span class="s1">.latestValues,</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.updateSnapshot(),t&amp;&amp;</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;willUpdate&quot;</span><span class="s1">)}update(){</span><span class="s0">this</span><span class="s1">.updateScheduled=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isUpdateBlocked())</span><span class="s0">return this</span><span class="s1">.unblockUpdate(),</span><span class="s0">this</span><span class="s1">.clearAllSnapshots(),</span><span class="s0">void this</span><span class="s1">.nodes.forEach(Vr);</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.animationId&lt;=</span><span class="s0">this</span><span class="s1">.animationCommitId)</span><span class="s0">return void this</span><span class="s1">.nodes.forEach(Mr);</span><span class="s0">this</span><span class="s1">.animationCommitId=</span><span class="s0">this</span><span class="s1">.animationId,</span><span class="s0">this</span><span class="s1">.isUpdating?(</span><span class="s0">this</span><span class="s1">.isUpdating=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.nodes.forEach(Cr),</span><span class="s0">this</span><span class="s1">.nodes.forEach(Pr),</span><span class="s0">this</span><span class="s1">.nodes.forEach(Sr)):</span><span class="s0">this</span><span class="s1">.nodes.forEach(Mr),</span><span class="s0">this</span><span class="s1">.clearAllSnapshots();</span><span class="s0">const </span><span class="s1">t=ft.now();ct.delta=g(</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1e3</span><span class="s1">/</span><span class="s3">60</span><span class="s1">,t-ct.timestamp),ct.timestamp=t,ct.isProcessing=!</span><span class="s3">0</span><span class="s1">,dt.update.process(ct),dt.preRender.process(ct),dt.render.process(ct),ct.isProcessing=!</span><span class="s3">1</span><span class="s1">}didUpdate(){</span><span class="s0">this</span><span class="s1">.updateScheduled||(</span><span class="s0">this</span><span class="s1">.updateScheduled=!</span><span class="s3">0</span><span class="s1">,ii.read(</span><span class="s0">this</span><span class="s1">.scheduleUpdate))}clearAllSnapshots(){</span><span class="s0">this</span><span class="s1">.nodes.forEach(Er),</span><span class="s0">this</span><span class="s1">.sharedNodes.forEach(jr)}scheduleUpdateProjection(){</span><span class="s0">this</span><span class="s1">.projectionUpdateScheduled||(</span><span class="s0">this</span><span class="s1">.projectionUpdateScheduled=!</span><span class="s3">0</span><span class="s1">,ht.preRender(</span><span class="s0">this</span><span class="s1">.updateProjection,!</span><span class="s3">1</span><span class="s1">,!</span><span class="s3">0</span><span class="s1">))}scheduleCheckAfterUnmount(){ht.postRender(()=&gt;{</span><span class="s0">this</span><span class="s1">.isLayoutDirty?</span><span class="s0">this</span><span class="s1">.root.didUpdate():</span><span class="s0">this</span><span class="s1">.root.checkUpdateFailed()})}updateSnapshot(){!</span><span class="s0">this</span><span class="s1">.snapshot&amp;&amp;</span><span class="s0">this</span><span class="s1">.instance&amp;&amp;(</span><span class="s0">this</span><span class="s1">.snapshot=</span><span class="s0">this</span><span class="s1">.measure(),!</span><span class="s0">this</span><span class="s1">.snapshot||xo(</span><span class="s0">this</span><span class="s1">.snapshot.measuredBox.x)||xo(</span><span class="s0">this</span><span class="s1">.snapshot.measuredBox.y)||(</span><span class="s0">this</span><span class="s1">.snapshot=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">))}updateLayout(){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.instance)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.updateScroll(),!(</span><span class="s0">this</span><span class="s1">.options.alwaysMeasureLayout&amp;&amp;</span><span class="s0">this</span><span class="s1">.isLead()||</span><span class="s0">this</span><span class="s1">.isLayoutDirty))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.resumeFrom&amp;&amp;!</span><span class="s0">this</span><span class="s1">.resumeFrom.instance)</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++){</span><span class="s0">this</span><span class="s1">.path[t].updateScroll()}</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.layout;</span><span class="s0">this</span><span class="s1">.layout=</span><span class="s0">this</span><span class="s1">.measure(!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.layoutCorrected={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.projectionDelta=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;measure&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.layout.layoutBox);</span><span class="s0">const</span><span class="s1">{visualElement:e}=</span><span class="s0">this</span><span class="s1">.options;e&amp;&amp;e.notify(</span><span class="s2">&quot;LayoutMeasure&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.layout.layoutBox,t?t.layoutBox:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}updateScroll(t=</span><span class="s2">&quot;measure&quot;</span><span class="s1">){</span><span class="s0">let </span><span class="s1">e=Boolean(</span><span class="s0">this</span><span class="s1">.options.layoutScroll&amp;&amp;</span><span class="s0">this</span><span class="s1">.instance);</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.scroll&amp;&amp;</span><span class="s0">this</span><span class="s1">.scroll.animationId===</span><span class="s0">this</span><span class="s1">.root.animationId&amp;&amp;</span><span class="s0">this</span><span class="s1">.scroll.phase===t&amp;&amp;(e=!</span><span class="s3">1</span><span class="s1">),e&amp;&amp;</span><span class="s0">this</span><span class="s1">.instance){</span><span class="s0">const </span><span class="s1">e=i(</span><span class="s0">this</span><span class="s1">.instance);</span><span class="s0">this</span><span class="s1">.scroll={animationId:</span><span class="s0">this</span><span class="s1">.root.animationId,phase:t,isRoot:e,offset:n(</span><span class="s0">this</span><span class="s1">.instance),wasRoot:</span><span class="s0">this</span><span class="s1">.scroll?</span><span class="s0">this</span><span class="s1">.scroll.isRoot:e}}}resetTransform(){</span><span class="s0">if</span><span class="s1">(!s)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.isLayoutDirty||</span><span class="s0">this</span><span class="s1">.shouldResetTransform||</span><span class="s0">this</span><span class="s1">.options.alwaysMeasureLayout,e=</span><span class="s0">this</span><span class="s1">.projectionDelta&amp;&amp;!hr(</span><span class="s0">this</span><span class="s1">.projectionDelta),n=</span><span class="s0">this</span><span class="s1">.getTransformTemplate(),i=n?n(</span><span class="s0">this</span><span class="s1">.latestValues,</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,o=i!==</span><span class="s0">this</span><span class="s1">.prevTransformTemplateValue;t&amp;&amp;</span><span class="s0">this</span><span class="s1">.instance&amp;&amp;(e||fs(</span><span class="s0">this</span><span class="s1">.latestValues)||o)&amp;&amp;(s(</span><span class="s0">this</span><span class="s1">.instance,i),</span><span class="s0">this</span><span class="s1">.shouldResetTransform=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scheduleRender())}measure(t=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.measurePageBox();</span><span class="s0">let </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.removeElementScroll(e);</span><span class="s0">var </span><span class="s1">i;</span><span class="s0">return </span><span class="s1">t&amp;&amp;(n=</span><span class="s0">this</span><span class="s1">.removeTransform(n)),Wr((i=n).x),Wr(i.y),{animationId:</span><span class="s0">this</span><span class="s1">.root.animationId,measuredBox:e,layoutBox:n,latestValues:{},source:</span><span class="s0">this</span><span class="s1">.id}}measurePageBox(){</span><span class="s0">const</span><span class="s1">{visualElement:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(!t)</span><span class="s0">return</span><span class="s1">{x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};</span><span class="s0">const </span><span class="s1">e=t.measureViewportBox();</span><span class="s0">if</span><span class="s1">(!(</span><span class="s0">this</span><span class="s1">.scroll?.wasRoot||</span><span class="s0">this</span><span class="s1">.path.some(Yr))){</span><span class="s0">const</span><span class="s1">{scroll:t}=</span><span class="s0">this</span><span class="s1">.root;t&amp;&amp;(bs(e.x,t.offset.x),bs(e.y,t.offset.y))}</span><span class="s0">return </span><span class="s1">e}removeElementScroll(t){</span><span class="s0">const </span><span class="s1">e={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};</span><span class="s0">if</span><span class="s1">(er(e,t),</span><span class="s0">this</span><span class="s1">.scroll?.wasRoot)</span><span class="s0">return </span><span class="s1">e;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">;n&lt;</span><span class="s0">this</span><span class="s1">.path.length;n++){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.path[n],{scroll:s,options:o}=i;i!==</span><span class="s0">this</span><span class="s1">.root&amp;&amp;s&amp;&amp;o.layoutScroll&amp;&amp;(s.wasRoot&amp;&amp;er(e,t),bs(e.x,s.offset.x),bs(e.y,s.offset.y))}</span><span class="s0">return </span><span class="s1">e}applyTransform(t,e=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">n={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};er(n,t);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.path[t];!e&amp;&amp;i.options.layoutScroll&amp;&amp;i.scroll&amp;&amp;i!==i.root&amp;&amp;Es(n,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),fs(i.latestValues)&amp;&amp;Es(n,i.latestValues)}</span><span class="s0">return </span><span class="s1">fs(</span><span class="s0">this</span><span class="s1">.latestValues)&amp;&amp;Es(n,</span><span class="s0">this</span><span class="s1">.latestValues),n}removeTransform(t){</span><span class="s0">const </span><span class="s1">e={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};er(e,t);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;</span><span class="s0">this</span><span class="s1">.path.length;t++){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.path[t];</span><span class="s0">if</span><span class="s1">(!n.instance)</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!fs(n.latestValues))</span><span class="s0">continue</span><span class="s1">;ms(n.latestValues)&amp;&amp;n.updateSnapshot();</span><span class="s0">const </span><span class="s1">i=Ms();er(i,n.measurePageBox()),ar(e,n.latestValues,n.snapshot?n.snapshot.layoutBox:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,i)}</span><span class="s0">return </span><span class="s1">fs(</span><span class="s0">this</span><span class="s1">.latestValues)&amp;&amp;ar(e,</span><span class="s0">this</span><span class="s1">.latestValues),e}setTargetDelta(t){</span><span class="s0">this</span><span class="s1">.targetDelta=t,</span><span class="s0">this</span><span class="s1">.root.scheduleUpdateProjection(),</span><span class="s0">this</span><span class="s1">.isProjectionDirty=!</span><span class="s3">0</span><span class="s1">}setOptions(t){</span><span class="s0">this</span><span class="s1">.options={...</span><span class="s0">this</span><span class="s1">.options,...t,crossfade:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===t.crossfade||t.crossfade}}clearMeasurements(){</span><span class="s0">this</span><span class="s1">.scroll=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.layout=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.snapshot=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.prevTransformTemplateValue=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.targetDelta=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.target=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isLayoutDirty=!</span><span class="s3">1</span><span class="s1">}forceRelativeParentToResolveTarget(){</span><span class="s0">this</span><span class="s1">.relativeParent&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.resolvedRelativeTargetAt!==ct.timestamp&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.resolveTargetDelta(!</span><span class="s3">0</span><span class="s1">)}resolveTargetDelta(t=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.getLead();</span><span class="s0">this</span><span class="s1">.isProjectionDirty||(</span><span class="s0">this</span><span class="s1">.isProjectionDirty=e.isProjectionDirty),</span><span class="s0">this</span><span class="s1">.isTransformDirty||(</span><span class="s0">this</span><span class="s1">.isTransformDirty=e.isTransformDirty),</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty||(</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty=e.isSharedProjectionDirty);</span><span class="s0">const </span><span class="s1">n=Boolean(</span><span class="s0">this</span><span class="s1">.resumingFrom)||</span><span class="s0">this</span><span class="s1">!==e;</span><span class="s0">if</span><span class="s1">(!(t||n&amp;&amp;</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty||</span><span class="s0">this</span><span class="s1">.isProjectionDirty||</span><span class="s0">this</span><span class="s1">.parent?.isProjectionDirty||</span><span class="s0">this</span><span class="s1">.attemptToResolveRelativeTarget||</span><span class="s0">this</span><span class="s1">.root.updateBlockedByResize))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{layout:i,layoutId:s}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.layout&amp;&amp;(i||s)){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.resolvedRelativeTargetAt=ct.timestamp,!</span><span class="s0">this</span><span class="s1">.targetDelta&amp;&amp;!</span><span class="s0">this</span><span class="s1">.relativeTarget){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getClosestProjectingParent();t&amp;&amp;t.layout&amp;&amp;</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.animationProgress?(</span><span class="s0">this</span><span class="s1">.relativeParent=t,</span><span class="s0">this</span><span class="s1">.forceRelativeParentToResolveTarget(),</span><span class="s0">this</span><span class="s1">.relativeTarget={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},bo(</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin,</span><span class="s0">this</span><span class="s1">.layout.layoutBox,t.layout.layoutBox),er(</span><span class="s0">this</span><span class="s1">.relativeTarget,</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin)):</span><span class="s0">this</span><span class="s1">.relativeParent=</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">var </span><span class="s1">o,r,a;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.relativeTarget||</span><span class="s0">this</span><span class="s1">.targetDelta)</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.target||(</span><span class="s0">this</span><span class="s1">.target={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.targetWithTransforms={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}}),</span><span class="s0">this</span><span class="s1">.relativeTarget&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.target?(</span><span class="s0">this</span><span class="s1">.forceRelativeParentToResolveTarget(),o=</span><span class="s0">this</span><span class="s1">.target,r=</span><span class="s0">this</span><span class="s1">.relativeTarget,a=</span><span class="s0">this</span><span class="s1">.relativeParent.target,Po(o.x,r.x,a.x),Po(o.y,r.y,a.y)):</span><span class="s0">this</span><span class="s1">.targetDelta?(Boolean(</span><span class="s0">this</span><span class="s1">.resumingFrom)?</span><span class="s0">this</span><span class="s1">.target=</span><span class="s0">this</span><span class="s1">.applyTransform(</span><span class="s0">this</span><span class="s1">.layout.layoutBox):er(</span><span class="s0">this</span><span class="s1">.target,</span><span class="s0">this</span><span class="s1">.layout.layoutBox),ws(</span><span class="s0">this</span><span class="s1">.target,</span><span class="s0">this</span><span class="s1">.targetDelta)):er(</span><span class="s0">this</span><span class="s1">.target,</span><span class="s0">this</span><span class="s1">.layout.layoutBox),</span><span class="s0">this</span><span class="s1">.attemptToResolveRelativeTarget){</span><span class="s0">this</span><span class="s1">.attemptToResolveRelativeTarget=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getClosestProjectingParent();t&amp;&amp;Boolean(t.resumingFrom)===Boolean(</span><span class="s0">this</span><span class="s1">.resumingFrom)&amp;&amp;!t.options.layoutScroll&amp;&amp;t.target&amp;&amp;</span><span class="s3">1</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.animationProgress?(</span><span class="s0">this</span><span class="s1">.relativeParent=t,</span><span class="s0">this</span><span class="s1">.forceRelativeParentToResolveTarget(),</span><span class="s0">this</span><span class="s1">.relativeTarget={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},bo(</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin,</span><span class="s0">this</span><span class="s1">.target,t.target),er(</span><span class="s0">this</span><span class="s1">.relativeTarget,</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin)):</span><span class="s0">this</span><span class="s1">.relativeParent=</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}}}getClosestProjectingParent(){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;!ms(</span><span class="s0">this</span><span class="s1">.parent.latestValues)&amp;&amp;!ys(</span><span class="s0">this</span><span class="s1">.parent.latestValues))</span><span class="s0">return this</span><span class="s1">.parent.isProjecting()?</span><span class="s0">this</span><span class="s1">.parent:</span><span class="s0">this</span><span class="s1">.parent.getClosestProjectingParent()}isProjecting(){</span><span class="s0">return </span><span class="s1">Boolean((</span><span class="s0">this</span><span class="s1">.relativeTarget||</span><span class="s0">this</span><span class="s1">.targetDelta||</span><span class="s0">this</span><span class="s1">.options.layoutRoot)&amp;&amp;</span><span class="s0">this</span><span class="s1">.layout)}calcProjection(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getLead(),e=Boolean(</span><span class="s0">this</span><span class="s1">.resumingFrom)||</span><span class="s0">this</span><span class="s1">!==t;</span><span class="s0">let </span><span class="s1">n=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">((</span><span class="s0">this</span><span class="s1">.isProjectionDirty||</span><span class="s0">this</span><span class="s1">.parent?.isProjectionDirty)&amp;&amp;(n=!</span><span class="s3">1</span><span class="s1">),e&amp;&amp;(</span><span class="s0">this</span><span class="s1">.isSharedProjectionDirty||</span><span class="s0">this</span><span class="s1">.isTransformDirty)&amp;&amp;(n=!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.resolvedRelativeTargetAt===ct.timestamp&amp;&amp;(n=!</span><span class="s3">1</span><span class="s1">),n)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{layout:i,layoutId:s}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isTreeAnimating=Boolean(</span><span class="s0">this</span><span class="s1">.parent&amp;&amp;</span><span class="s0">this</span><span class="s1">.parent.isTreeAnimating||</span><span class="s0">this</span><span class="s1">.currentAnimation||</span><span class="s0">this</span><span class="s1">.pendingAnimation),</span><span class="s0">this</span><span class="s1">.isTreeAnimating||(</span><span class="s0">this</span><span class="s1">.targetDelta=</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),!</span><span class="s0">this</span><span class="s1">.layout||!i&amp;&amp;!s)</span><span class="s0">return</span><span class="s1">;er(</span><span class="s0">this</span><span class="s1">.layoutCorrected,</span><span class="s0">this</span><span class="s1">.layout.layoutBox);</span><span class="s0">const </span><span class="s1">o=</span><span class="s0">this</span><span class="s1">.treeScale.x,r=</span><span class="s0">this</span><span class="s1">.treeScale.y;!</span><span class="s0">function</span><span class="s1">(t,e,n,i=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">s=n.length;</span><span class="s0">if</span><span class="s1">(!s)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">let </span><span class="s1">o,r;e.x=e.y=</span><span class="s3">1</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">a=</span><span class="s3">0</span><span class="s1">;a&lt;s;a++){o=n[a],r=o.projectionDelta;</span><span class="s0">const</span><span class="s1">{visualElement:s}=o.options;s&amp;&amp;s.props.style&amp;&amp;</span><span class="s2">&quot;contents&quot;</span><span class="s1">===s.props.style.display||(i&amp;&amp;o.options.layoutScroll&amp;&amp;o.scroll&amp;&amp;o!==o.root&amp;&amp;Es(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),r&amp;&amp;(e.x*=r.x.scale,e.y*=r.y.scale,ws(t,r)),i&amp;&amp;fs(o.latestValues)&amp;&amp;Es(t,o.latestValues))}e.x&lt;Ss&amp;&amp;e.x&gt;Ps&amp;&amp;(e.x=</span><span class="s3">1</span><span class="s1">),e.y&lt;Ss&amp;&amp;e.y&gt;Ps&amp;&amp;(e.y=</span><span class="s3">1</span><span class="s1">)}(</span><span class="s0">this</span><span class="s1">.layoutCorrected,</span><span class="s0">this</span><span class="s1">.treeScale,</span><span class="s0">this</span><span class="s1">.path,e),!t.layout||t.target||</span><span class="s3">1</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.treeScale.x&amp;&amp;</span><span class="s3">1</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.treeScale.y||(t.target=t.layout.layoutBox,t.targetWithTransforms={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}});</span><span class="s0">const</span><span class="s1">{target:a}=t;a?(</span><span class="s0">this</span><span class="s1">.projectionDelta&amp;&amp;</span><span class="s0">this</span><span class="s1">.prevProjectionDelta?(nr(</span><span class="s0">this</span><span class="s1">.prevProjectionDelta.x,</span><span class="s0">this</span><span class="s1">.projectionDelta.x),nr(</span><span class="s0">this</span><span class="s1">.prevProjectionDelta.y,</span><span class="s0">this</span><span class="s1">.projectionDelta.y)):</span><span class="s0">this</span><span class="s1">.createProjectionDeltas(),wo(</span><span class="s0">this</span><span class="s1">.projectionDelta,</span><span class="s0">this</span><span class="s1">.layoutCorrected,a,</span><span class="s0">this</span><span class="s1">.latestValues),</span><span class="s0">this</span><span class="s1">.treeScale.x===o&amp;&amp;</span><span class="s0">this</span><span class="s1">.treeScale.y===r&amp;&amp;mr(</span><span class="s0">this</span><span class="s1">.projectionDelta.x,</span><span class="s0">this</span><span class="s1">.prevProjectionDelta.x)&amp;&amp;mr(</span><span class="s0">this</span><span class="s1">.projectionDelta.y,</span><span class="s0">this</span><span class="s1">.prevProjectionDelta.y)||(</span><span class="s0">this</span><span class="s1">.hasProjected=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.scheduleRender(),</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;projectionUpdate&quot;</span><span class="s1">,a))):</span><span class="s0">this</span><span class="s1">.prevProjectionDelta&amp;&amp;(</span><span class="s0">this</span><span class="s1">.createProjectionDeltas(),</span><span class="s0">this</span><span class="s1">.scheduleRender())}hide(){</span><span class="s0">this</span><span class="s1">.isVisible=!</span><span class="s3">1</span><span class="s1">}show(){</span><span class="s0">this</span><span class="s1">.isVisible=!</span><span class="s3">0</span><span class="s1">}scheduleRender(t=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.options.visualElement?.scheduleRender(),t){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();t&amp;&amp;t.scheduleRender()}</span><span class="s0">this</span><span class="s1">.resumingFrom&amp;&amp;!</span><span class="s0">this</span><span class="s1">.resumingFrom.instance&amp;&amp;(</span><span class="s0">this</span><span class="s1">.resumingFrom=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}createProjectionDeltas(){</span><span class="s0">this</span><span class="s1">.prevProjectionDelta={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.projectionDelta={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}},</span><span class="s0">this</span><span class="s1">.projectionDeltaWithTransform={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}}}setAnimationOrigin(t,e=!</span><span class="s3">1</span><span class="s1">){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.snapshot,i=n?n.latestValues:{},s={...</span><span class="s0">this</span><span class="s1">.latestValues},o={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}};</span><span class="s0">this</span><span class="s1">.relativeParent&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.options.layoutRoot||(</span><span class="s0">this</span><span class="s1">.relativeTarget=</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.attemptToResolveRelativeTarget=!e;</span><span class="s0">const </span><span class="s1">r={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}},a=(n?n.source:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)!==(</span><span class="s0">this</span><span class="s1">.layout?</span><span class="s0">this</span><span class="s1">.layout.source:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),l=</span><span class="s0">this</span><span class="s1">.getStack(),h=!l||l.members.length&lt;=</span><span class="s3">1</span><span class="s1">,u=Boolean(a&amp;&amp;!h&amp;&amp;!</span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.options.crossfade&amp;&amp;!</span><span class="s0">this</span><span class="s1">.path.some(Or));</span><span class="s0">let </span><span class="s1">c;</span><span class="s0">this</span><span class="s1">.animationProgress=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.mixTargetDelta=e=&gt;{</span><span class="s0">const </span><span class="s1">n=e/</span><span class="s3">1e3</span><span class="s1">;</span><span class="s0">var </span><span class="s1">l,d,p,m,f,y;Br(o.x,t.x,n),Br(o.y,t.y,n),</span><span class="s0">this</span><span class="s1">.setTargetDelta(o),</span><span class="s0">this</span><span class="s1">.relativeTarget&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin&amp;&amp;</span><span class="s0">this</span><span class="s1">.layout&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent&amp;&amp;</span><span class="s0">this</span><span class="s1">.relativeParent.layout&amp;&amp;(bo(r,</span><span class="s0">this</span><span class="s1">.layout.layoutBox,</span><span class="s0">this</span><span class="s1">.relativeParent.layout.layoutBox),p=</span><span class="s0">this</span><span class="s1">.relativeTarget,m=</span><span class="s0">this</span><span class="s1">.relativeTargetOrigin,f=r,y=n,Fr(p.x,m.x,f.x,y),Fr(p.y,m.y,f.y,y),c&amp;&amp;(l=</span><span class="s0">this</span><span class="s1">.relativeTarget,d=c,ur(l.x,d.x)&amp;&amp;ur(l.y,d.y))&amp;&amp;(</span><span class="s0">this</span><span class="s1">.isProjectionDirty=!</span><span class="s3">1</span><span class="s1">),c||(c={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}}),er(c,</span><span class="s0">this</span><span class="s1">.relativeTarget)),a&amp;&amp;(</span><span class="s0">this</span><span class="s1">.animationValues=s,</span><span class="s0">function</span><span class="s1">(t,e,n,i,s,o){s?(t.opacity=Jt(</span><span class="s3">0</span><span class="s1">,n.opacity??</span><span class="s3">1</span><span class="s1">,_o(i)),t.opacityExit=Jt(e.opacity??</span><span class="s3">1</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,Jo(i))):o&amp;&amp;(t.opacity=Jt(e.opacity??</span><span class="s3">1</span><span class="s1">,n.opacity??</span><span class="s3">1</span><span class="s1">,i));</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">s=</span><span class="s3">0</span><span class="s1">;s&lt;Ho;s++){</span><span class="s0">const </span><span class="s1">o=</span><span class="s2">`border</span><span class="s1">${zo[s]}</span><span class="s2">Radius`</span><span class="s1">;</span><span class="s0">let </span><span class="s1">r=Zo(e,o),a=Zo(n,o);</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===r&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===a||(r||(r=</span><span class="s3">0</span><span class="s1">),a||(a=</span><span class="s3">0</span><span class="s1">),</span><span class="s3">0</span><span class="s1">===r||</span><span class="s3">0</span><span class="s1">===a||qo(r)===qo(a)?(t[o]=Math.max(Jt(Go(r),Go(a),i),</span><span class="s3">0</span><span class="s1">),(jt.test(a)||jt.test(r))&amp;&amp;(t[o]+=</span><span class="s2">&quot;%&quot;</span><span class="s1">)):t[o]=a)}(e.rotate||n.rotate)&amp;&amp;(t.rotate=Jt(e.rotate||</span><span class="s3">0</span><span class="s1">,n.rotate||</span><span class="s3">0</span><span class="s1">,i))}(s,i,</span><span class="s0">this</span><span class="s1">.latestValues,n,u,h)),</span><span class="s0">this</span><span class="s1">.root.scheduleUpdateProjection(),</span><span class="s0">this</span><span class="s1">.scheduleRender(),</span><span class="s0">this</span><span class="s1">.animationProgress=n},</span><span class="s0">this</span><span class="s1">.mixTargetDelta(</span><span class="s0">this</span><span class="s1">.options.layoutRoot?</span><span class="s3">1e3</span><span class="s1">:</span><span class="s3">0</span><span class="s1">)}startAnimation(t){</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;animationStart&quot;</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.currentAnimation?.stop(),</span><span class="s0">this</span><span class="s1">.resumingFrom?.currentAnimation?.stop(),</span><span class="s0">this</span><span class="s1">.pendingAnimation&amp;&amp;(ut(</span><span class="s0">this</span><span class="s1">.pendingAnimation),</span><span class="s0">this</span><span class="s1">.pendingAnimation=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.pendingAnimation=ht.update(()=&gt;{yr.hasAnimatedSinceResize=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.motionValue||(</span><span class="s0">this</span><span class="s1">.motionValue=ni(</span><span class="s3">0</span><span class="s1">)),</span><span class="s0">this</span><span class="s1">.currentAnimation=</span><span class="s0">function</span><span class="s1">(t,e,n){</span><span class="s0">const </span><span class="s1">i=vi(t)?t:ni(t);</span><span class="s0">return </span><span class="s1">i.start(_s(</span><span class="s2">&quot;&quot;</span><span class="s1">,i,e,n)),i.animation}(</span><span class="s0">this</span><span class="s1">.motionValue,[</span><span class="s3">0</span><span class="s1">,</span><span class="s3">1e3</span><span class="s1">],{...t,velocity:</span><span class="s3">0</span><span class="s1">,isSync:!</span><span class="s3">0</span><span class="s1">,onUpdate:e=&gt;{</span><span class="s0">this</span><span class="s1">.mixTargetDelta(e),t.onUpdate&amp;&amp;t.onUpdate(e)},onStop:()=&gt;{},onComplete:()=&gt;{t.onComplete&amp;&amp;t.onComplete(),</span><span class="s0">this</span><span class="s1">.completeAnimation()}}),</span><span class="s0">this</span><span class="s1">.resumingFrom&amp;&amp;(</span><span class="s0">this</span><span class="s1">.resumingFrom.currentAnimation=</span><span class="s0">this</span><span class="s1">.currentAnimation),</span><span class="s0">this</span><span class="s1">.pendingAnimation=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">})}completeAnimation(){</span><span class="s0">this</span><span class="s1">.resumingFrom&amp;&amp;(</span><span class="s0">this</span><span class="s1">.resumingFrom.currentAnimation=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.resumingFrom.preserveOpacity=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();t&amp;&amp;t.exitAnimationComplete(),</span><span class="s0">this</span><span class="s1">.resumingFrom=</span><span class="s0">this</span><span class="s1">.currentAnimation=</span><span class="s0">this</span><span class="s1">.animationValues=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.notifyListeners(</span><span class="s2">&quot;animationComplete&quot;</span><span class="s1">)}finishAnimation(){</span><span class="s0">this</span><span class="s1">.currentAnimation&amp;&amp;(</span><span class="s0">this</span><span class="s1">.mixTargetDelta&amp;&amp;</span><span class="s0">this</span><span class="s1">.mixTargetDelta(</span><span class="s3">1e3</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.currentAnimation.stop()),</span><span class="s0">this</span><span class="s1">.completeAnimation()}applyTransformsToTarget(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getLead();</span><span class="s0">let</span><span class="s1">{targetWithTransforms:e,target:n,layout:i,latestValues:s}=t;</span><span class="s0">if</span><span class="s1">(e&amp;&amp;n&amp;&amp;i){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">!==t&amp;&amp;</span><span class="s0">this</span><span class="s1">.layout&amp;&amp;i&amp;&amp;$r(</span><span class="s0">this</span><span class="s1">.options.animationType,</span><span class="s0">this</span><span class="s1">.layout.layoutBox,i.layoutBox)){n=</span><span class="s0">this</span><span class="s1">.target||{x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};</span><span class="s0">const </span><span class="s1">e=xo(</span><span class="s0">this</span><span class="s1">.layout.layoutBox.x);n.x.min=t.target.x.min,n.x.max=n.x.min+e;</span><span class="s0">const </span><span class="s1">i=xo(</span><span class="s0">this</span><span class="s1">.layout.layoutBox.y);n.y.min=t.target.y.min,n.y.max=n.y.min+i}er(e,n),Es(e,s),wo(</span><span class="s0">this</span><span class="s1">.projectionDeltaWithTransform,</span><span class="s0">this</span><span class="s1">.layoutCorrected,e,s)}}registerSharedNode(t,e){</span><span class="s0">this</span><span class="s1">.sharedNodes.has(t)||</span><span class="s0">this</span><span class="s1">.sharedNodes.set(t,</span><span class="s0">new </span><span class="s1">fr);</span><span class="s0">this</span><span class="s1">.sharedNodes.get(t).add(e);</span><span class="s0">const </span><span class="s1">n=e.options.initialPromotionConfig;e.promote({transition:n?n.transition:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,preserveFollowOpacity:n&amp;&amp;n.shouldPreserveFollowOpacity?n.shouldPreserveFollowOpacity(e):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">})}isLead(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();</span><span class="s0">return</span><span class="s1">!t||t.lead===</span><span class="s0">this</span><span class="s1">}getLead(){</span><span class="s0">const</span><span class="s1">{layoutId:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">return </span><span class="s1">t&amp;&amp;</span><span class="s0">this</span><span class="s1">.getStack()?.lead||</span><span class="s0">this</span><span class="s1">}getPrevLead(){</span><span class="s0">const</span><span class="s1">{layoutId:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">return </span><span class="s1">t?</span><span class="s0">this</span><span class="s1">.getStack()?.prevLead:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}getStack(){</span><span class="s0">const</span><span class="s1">{layoutId:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(t)</span><span class="s0">return this</span><span class="s1">.root.sharedNodes.get(t)}promote({needsReset:t,transition:e,preserveFollowOpacity:n}={}){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.getStack();i&amp;&amp;i.promote(</span><span class="s0">this</span><span class="s1">,n),t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.projectionDelta=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.needsReset=!</span><span class="s3">0</span><span class="s1">),e&amp;&amp;</span><span class="s0">this</span><span class="s1">.setOptions({transition:e})}relegate(){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.getStack();</span><span class="s0">return</span><span class="s1">!!t&amp;&amp;t.relegate(</span><span class="s0">this</span><span class="s1">)}resetSkewAndRotation(){</span><span class="s0">const</span><span class="s1">{visualElement:t}=</span><span class="s0">this</span><span class="s1">.options;</span><span class="s0">if</span><span class="s1">(!t)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">let </span><span class="s1">e=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{latestValues:n}=t;</span><span class="s0">if</span><span class="s1">((n.z||n.rotate||n.rotateX||n.rotateY||n.rotateZ||n.skewX||n.skewY)&amp;&amp;(e=!</span><span class="s3">0</span><span class="s1">),!e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i={};n.z&amp;&amp;xr(</span><span class="s2">&quot;z&quot;</span><span class="s1">,t,i,</span><span class="s0">this</span><span class="s1">.animationValues);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;gr.length;e++)xr(</span><span class="s2">`rotate</span><span class="s1">${gr[e]}</span><span class="s2">`</span><span class="s1">,t,i,</span><span class="s0">this</span><span class="s1">.animationValues),xr(</span><span class="s2">`skew</span><span class="s1">${gr[e]}</span><span class="s2">`</span><span class="s1">,t,i,</span><span class="s0">this</span><span class="s1">.animationValues);t.render();</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">i)t.setStaticValue(e,i[e]),</span><span class="s0">this</span><span class="s1">.animationValues&amp;&amp;(</span><span class="s0">this</span><span class="s1">.animationValues[e]=i[e]);t.scheduleRender()}applyProjectionStyles(t,e){</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.instance||</span><span class="s0">this</span><span class="s1">.isSVG)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.isVisible)</span><span class="s0">return void</span><span class="s1">(t.visibility=</span><span class="s2">&quot;hidden&quot;</span><span class="s1">);</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.getTransformTemplate();</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.needsReset)</span><span class="s0">return this</span><span class="s1">.needsReset=!</span><span class="s3">1</span><span class="s1">,t.visibility=</span><span class="s2">&quot;&quot;</span><span class="s1">,t.opacity=</span><span class="s2">&quot;&quot;</span><span class="s1">,t.pointerEvents=Ki(e?.pointerEvents)||</span><span class="s2">&quot;&quot;</span><span class="s1">,</span><span class="s0">void</span><span class="s1">(t.transform=n?n(</span><span class="s0">this</span><span class="s1">.latestValues,</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s2">&quot;none&quot;</span><span class="s1">);</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.getLead();</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.projectionDelta||!</span><span class="s0">this</span><span class="s1">.layout||!i.target)</span><span class="s0">return this</span><span class="s1">.options.layoutId&amp;&amp;(t.opacity=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.latestValues.opacity?</span><span class="s0">this</span><span class="s1">.latestValues.opacity:</span><span class="s3">1</span><span class="s1">,t.pointerEvents=Ki(e?.pointerEvents)||</span><span class="s2">&quot;&quot;</span><span class="s1">),</span><span class="s0">void</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.hasProjected&amp;&amp;!fs(</span><span class="s0">this</span><span class="s1">.latestValues)&amp;&amp;(t.transform=n?n({},</span><span class="s2">&quot;&quot;</span><span class="s1">):</span><span class="s2">&quot;none&quot;</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.hasProjected=!</span><span class="s3">1</span><span class="s1">));t.visibility=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=i.animationValues||i.latestValues;</span><span class="s0">this</span><span class="s1">.applyTransformsToTarget();</span><span class="s0">let </span><span class="s1">o=</span><span class="s0">function</span><span class="s1">(t,e,n){</span><span class="s0">let </span><span class="s1">i=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=t.x.translate/e.x,o=t.y.translate/e.y,r=n?.z||</span><span class="s3">0</span><span class="s1">;</span><span class="s0">if</span><span class="s1">((s||o||r)&amp;&amp;(i=</span><span class="s2">`translate3d(</span><span class="s1">${s}</span><span class="s2">px, </span><span class="s1">${o}</span><span class="s2">px, </span><span class="s1">${r}</span><span class="s2">px) `</span><span class="s1">),</span><span class="s3">1</span><span class="s1">===e.x&amp;&amp;</span><span class="s3">1</span><span class="s1">===e.y||(i+=</span><span class="s2">`scale(</span><span class="s1">${</span><span class="s3">1</span><span class="s1">/e.x}</span><span class="s2">, </span><span class="s1">${</span><span class="s3">1</span><span class="s1">/e.y}</span><span class="s2">) `</span><span class="s1">),n){</span><span class="s0">const</span><span class="s1">{transformPerspective:t,rotate:e,rotateX:s,rotateY:o,skewX:r,skewY:a}=n;t&amp;&amp;(i=</span><span class="s2">`perspective(</span><span class="s1">${t}</span><span class="s2">px) </span><span class="s1">${i}</span><span class="s2">`</span><span class="s1">),e&amp;&amp;(i+=</span><span class="s2">`rotate(</span><span class="s1">${e}</span><span class="s2">deg) `</span><span class="s1">),s&amp;&amp;(i+=</span><span class="s2">`rotateX(</span><span class="s1">${s}</span><span class="s2">deg) `</span><span class="s1">),o&amp;&amp;(i+=</span><span class="s2">`rotateY(</span><span class="s1">${o}</span><span class="s2">deg) `</span><span class="s1">),r&amp;&amp;(i+=</span><span class="s2">`skewX(</span><span class="s1">${r}</span><span class="s2">deg) `</span><span class="s1">),a&amp;&amp;(i+=</span><span class="s2">`skewY(</span><span class="s1">${a}</span><span class="s2">deg) `</span><span class="s1">)}</span><span class="s0">const </span><span class="s1">a=t.x.scale*e.x,l=t.y.scale*e.y;</span><span class="s0">return </span><span class="s3">1</span><span class="s1">===a&amp;&amp;</span><span class="s3">1</span><span class="s1">===l||(i+=</span><span class="s2">`scale(</span><span class="s1">${a}</span><span class="s2">, </span><span class="s1">${l}</span><span class="s2">)`</span><span class="s1">),i||</span><span class="s2">&quot;none&quot;</span><span class="s1">}(</span><span class="s0">this</span><span class="s1">.projectionDeltaWithTransform,</span><span class="s0">this</span><span class="s1">.treeScale,s);n&amp;&amp;(o=n(s,o)),t.transform=o;</span><span class="s0">const</span><span class="s1">{x:r,y:a}=</span><span class="s0">this</span><span class="s1">.projectionDelta;t.transformOrigin=</span><span class="s2">`</span><span class="s1">${</span><span class="s3">100</span><span class="s1">*r.origin}</span><span class="s2">% </span><span class="s1">${</span><span class="s3">100</span><span class="s1">*a.origin}</span><span class="s2">% 0`</span><span class="s1">,i.animationValues?t.opacity=i===</span><span class="s0">this</span><span class="s1">?s.opacity??</span><span class="s0">this</span><span class="s1">.latestValues.opacity??</span><span class="s3">1</span><span class="s1">:</span><span class="s0">this</span><span class="s1">.preserveOpacity?</span><span class="s0">this</span><span class="s1">.latestValues.opacity:s.opacityExit:t.opacity=i===</span><span class="s0">this</span><span class="s1">?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s.opacity?s.opacity:</span><span class="s2">&quot;&quot;</span><span class="s1">:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==s.opacityExit?s.opacityExit:</span><span class="s3">0</span><span class="s1">;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">Ti){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===s[e])</span><span class="s0">continue</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{correct:n,applyTo:r,isCSSVariable:a}=Ti[e],l=</span><span class="s2">&quot;none&quot;</span><span class="s1">===o?s[e]:n(s[e],i);</span><span class="s0">if</span><span class="s1">(r){</span><span class="s0">const </span><span class="s1">e=r.length;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">;n&lt;e;n++)t[r[n]]=l}</span><span class="s0">else </span><span class="s1">a?</span><span class="s0">this</span><span class="s1">.options.visualElement.renderState.vars[e]=l:t[e]=l}</span><span class="s0">this</span><span class="s1">.options.layoutId&amp;&amp;(t.pointerEvents=i===</span><span class="s0">this</span><span class="s1">?Ki(e?.pointerEvents)||</span><span class="s2">&quot;&quot;</span><span class="s1">:</span><span class="s2">&quot;none&quot;</span><span class="s1">)}clearSnapshot(){</span><span class="s0">this</span><span class="s1">.resumeFrom=</span><span class="s0">this</span><span class="s1">.snapshot=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}resetTree(){</span><span class="s0">this</span><span class="s1">.root.nodes.forEach(t=&gt;t.currentAnimation?.stop()),</span><span class="s0">this</span><span class="s1">.root.nodes.forEach(Vr),</span><span class="s0">this</span><span class="s1">.root.sharedNodes.clear()}}}</span><span class="s0">function </span><span class="s1">Pr(t){t.updateLayout()}</span><span class="s0">function </span><span class="s1">Sr(t){</span><span class="s0">const </span><span class="s1">e=t.resumeFrom?.snapshot||t.snapshot;</span><span class="s0">if</span><span class="s1">(t.isLead()&amp;&amp;t.layout&amp;&amp;e&amp;&amp;t.hasListeners(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s1">)){</span><span class="s0">const</span><span class="s1">{layoutBox:n,measuredBox:i}=t.layout,{animationType:s}=t.options,o=e.source!==t.layout.source;</span><span class="s2">&quot;size&quot;</span><span class="s1">===s?Ao(t=&gt;{</span><span class="s0">const </span><span class="s1">i=o?e.measuredBox[t]:e.layoutBox[t],s=xo(i);i.min=n[t].min,i.max=i.min+s}):$r(s,e.layoutBox,n)&amp;&amp;Ao(i=&gt;{</span><span class="s0">const </span><span class="s1">s=o?e.measuredBox[i]:e.layoutBox[i],r=xo(n[i]);s.max=s.min+r,t.relativeTarget&amp;&amp;!t.currentAnimation&amp;&amp;(t.isProjectionDirty=!</span><span class="s3">0</span><span class="s1">,t.relativeTarget[i].max=t.relativeTarget[i].min+r)});</span><span class="s0">const </span><span class="s1">r={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}};wo(r,n,e.layoutBox);</span><span class="s0">const </span><span class="s1">a={x:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">},y:{translate:</span><span class="s3">0</span><span class="s1">,scale:</span><span class="s3">1</span><span class="s1">,origin:</span><span class="s3">0</span><span class="s1">,originPoint:</span><span class="s3">0</span><span class="s1">}};o?wo(a,t.applyTransform(i,!</span><span class="s3">0</span><span class="s1">),e.measuredBox):wo(a,n,e.layoutBox);</span><span class="s0">const </span><span class="s1">l=!hr(r);</span><span class="s0">let </span><span class="s1">h=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(!t.resumeFrom){</span><span class="s0">const </span><span class="s1">i=t.getClosestProjectingParent();</span><span class="s0">if</span><span class="s1">(i&amp;&amp;!i.resumeFrom){</span><span class="s0">const</span><span class="s1">{snapshot:s,layout:o}=i;</span><span class="s0">if</span><span class="s1">(s&amp;&amp;o){</span><span class="s0">const </span><span class="s1">r={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};bo(r,e.layoutBox,s.layoutBox);</span><span class="s0">const </span><span class="s1">a={x:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">},y:{min:</span><span class="s3">0</span><span class="s1">,max:</span><span class="s3">0</span><span class="s1">}};bo(a,n,o.layoutBox),dr(r,a)||(h=!</span><span class="s3">0</span><span class="s1">),i.options.layoutRoot&amp;&amp;(t.relativeTarget=a,t.relativeTargetOrigin=r,t.relativeParent=i)}}}t.notifyListeners(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s1">,{layout:n,snapshot:e,delta:a,layoutDelta:r,hasLayoutChanged:l,hasRelativeLayoutChanged:h})}</span><span class="s0">else if</span><span class="s1">(t.isLead()){</span><span class="s0">const</span><span class="s1">{onExitComplete:e}=t.options;e&amp;&amp;e()}t.options.transition=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}</span><span class="s0">function </span><span class="s1">br(t){t.parent&amp;&amp;(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=Boolean(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}</span><span class="s0">function </span><span class="s1">Ar(t){t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!</span><span class="s3">1</span><span class="s1">}</span><span class="s0">function </span><span class="s1">Er(t){t.clearSnapshot()}</span><span class="s0">function </span><span class="s1">Vr(t){t.clearMeasurements()}</span><span class="s0">function </span><span class="s1">Mr(t){t.isLayoutDirty=!</span><span class="s3">1</span><span class="s1">}</span><span class="s0">function </span><span class="s1">Cr(t){</span><span class="s0">const</span><span class="s1">{visualElement:e}=t.options;e&amp;&amp;e.getProps().onBeforeLayoutMeasure&amp;&amp;e.notify(</span><span class="s2">&quot;BeforeLayoutMeasure&quot;</span><span class="s1">),t.resetTransform()}</span><span class="s0">function </span><span class="s1">Dr(t){t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,t.isProjectionDirty=!</span><span class="s3">0</span><span class="s1">}</span><span class="s0">function </span><span class="s1">kr(t){t.resolveTargetDelta()}</span><span class="s0">function </span><span class="s1">Rr(t){t.calcProjection()}</span><span class="s0">function </span><span class="s1">Lr(t){t.resetSkewAndRotation()}</span><span class="s0">function </span><span class="s1">jr(t){t.removeLeadSnapshot()}</span><span class="s0">function </span><span class="s1">Br(t,e,n){t.translate=Jt(e.translate,</span><span class="s3">0</span><span class="s1">,n),t.scale=Jt(e.scale,</span><span class="s3">1</span><span class="s1">,n),t.origin=e.origin,t.originPoint=e.originPoint}</span><span class="s0">function </span><span class="s1">Fr(t,e,n,i){t.min=Jt(e.min,n.min,i),t.max=Jt(e.max,n.max,i)}</span><span class="s0">function </span><span class="s1">Or(t){</span><span class="s0">return </span><span class="s1">t.animationValues&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==t.animationValues.opacityExit}</span><span class="s0">const </span><span class="s1">Ir={duration:</span><span class="s3">.45</span><span class="s1">,ease:[</span><span class="s3">.4</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s3">.1</span><span class="s1">,</span><span class="s3">1</span><span class="s1">]},Ur=t=&gt;</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">navigator&amp;&amp;navigator.userAgent&amp;&amp;navigator.userAgent.toLowerCase().includes(t),Nr=Ur(</span><span class="s2">&quot;applewebkit/&quot;</span><span class="s1">)&amp;&amp;!Ur(</span><span class="s2">&quot;chrome/&quot;</span><span class="s1">)?Math.round:S;</span><span class="s0">function </span><span class="s1">Wr(t){t.min=Nr(t.min),t.max=Nr(t.max)}</span><span class="s0">function </span><span class="s1">$r(t,e,n){</span><span class="s0">return</span><span class="s2">&quot;position&quot;</span><span class="s1">===t||</span><span class="s2">&quot;preserve-aspect&quot;</span><span class="s1">===t&amp;&amp;(i=pr(e),s=pr(n),o=</span><span class="s3">.2</span><span class="s1">,!(Math.abs(i-s)&lt;=o));</span><span class="s0">var </span><span class="s1">i,s,o}</span><span class="s0">function </span><span class="s1">Yr(t){</span><span class="s0">return </span><span class="s1">t!==t.root&amp;&amp;t.scroll?.wasRoot}</span><span class="s0">const </span><span class="s1">Xr=wr({attachResizeListener:(t,e)=&gt;yo(t,</span><span class="s2">&quot;resize&quot;</span><span class="s1">,e),measureScroll:()=&gt;({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=&gt;!</span><span class="s3">0</span><span class="s1">}),Kr={current:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">},zr=wr({measureScroll:t=&gt;({x:t.scrollLeft,y:t.scrollTop}),defaultParent:()=&gt;{</span><span class="s0">if</span><span class="s1">(!Kr.current){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">new </span><span class="s1">Xr({});t.mount(window),t.setOptions({layoutScroll:!</span><span class="s3">0</span><span class="s1">}),Kr.current=t}</span><span class="s0">return </span><span class="s1">Kr.current},resetTransform:(t,e)=&gt;{t.style.transform=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==e?e:</span><span class="s2">&quot;none&quot;</span><span class="s1">},checkIsScrollRoot:t=&gt;Boolean(</span><span class="s2">&quot;fixed&quot;</span><span class="s1">===window.getComputedStyle(t).position)});</span><span class="s0">function </span><span class="s1">Hr(t,e){</span><span class="s0">return </span><span class="s1">e.max===e.min?</span><span class="s3">0</span><span class="s1">:t/(e.max-e.min)*</span><span class="s3">100</span><span class="s1">}</span><span class="s0">const </span><span class="s1">Gr={correct:(t,e)=&gt;{</span><span class="s0">if</span><span class="s1">(!e.target)</span><span class="s0">return </span><span class="s1">t;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t){</span><span class="s0">if</span><span class="s1">(!Bt.test(t))</span><span class="s0">return </span><span class="s1">t;t=parseFloat(t)}</span><span class="s0">return</span><span class="s2">`</span><span class="s1">${Hr(t,e.target.x)}</span><span class="s2">% </span><span class="s1">${Hr(t,e.target.y)}</span><span class="s2">%`</span><span class="s1">}},qr={correct:(t,{treeScale:e,projectionDelta:n})=&gt;{</span><span class="s0">const </span><span class="s1">i=t,s=qt.parse(t);</span><span class="s0">if</span><span class="s1">(s.length&gt;</span><span class="s3">5</span><span class="s1">)</span><span class="s0">return </span><span class="s1">i;</span><span class="s0">const </span><span class="s1">o=qt.createTransformer(t),r=</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">s[</span><span class="s3">0</span><span class="s1">]?</span><span class="s3">1</span><span class="s1">:</span><span class="s3">0</span><span class="s1">,a=n.x.scale*e.x,l=n.y.scale*e.y;s[</span><span class="s3">0</span><span class="s1">+r]/=a,s[</span><span class="s3">1</span><span class="s1">+r]/=l;</span><span class="s0">const </span><span class="s1">h=Jt(a,l,</span><span class="s3">.5</span><span class="s1">);</span><span class="s0">return</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">s[</span><span class="s3">2</span><span class="s1">+r]&amp;&amp;(s[</span><span class="s3">2</span><span class="s1">+r]/=h),</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">s[</span><span class="s3">3</span><span class="s1">+r]&amp;&amp;(s[</span><span class="s3">3</span><span class="s1">+r]/=h),o(s)}};</span><span class="s0">let </span><span class="s1">Zr=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">class </span><span class="s1">_r </span><span class="s0">extends </span><span class="s1">m{componentDidMount(){</span><span class="s0">const</span><span class="s1">{visualElement:t,layoutGroup:e,switchLayoutGroup:n,layoutId:i}=</span><span class="s0">this</span><span class="s1">.props,{projection:s}=t;!</span><span class="s0">function</span><span class="s1">(t){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">const </span><span class="s1">e </span><span class="s0">in </span><span class="s1">t)Ti[e]=t[e],gt(e)&amp;&amp;(Ti[e].isCSSVariable=!</span><span class="s3">0</span><span class="s1">)}(Qr),s&amp;&amp;(e.group&amp;&amp;e.group.add(s),n&amp;&amp;n.register&amp;&amp;i&amp;&amp;n.register(s),Zr&amp;&amp;s.root.didUpdate(),s.addEventListener(</span><span class="s2">&quot;animationComplete&quot;</span><span class="s1">,()=&gt;{</span><span class="s0">this</span><span class="s1">.safeToRemove()}),s.setOptions({...s.options,onExitComplete:()=&gt;</span><span class="s0">this</span><span class="s1">.safeToRemove()})),yr.hasEverUpdated=!</span><span class="s3">0</span><span class="s1">}getSnapshotBeforeUpdate(t){</span><span class="s0">const</span><span class="s1">{layoutDependency:e,visualElement:n,drag:i,isPresent:s}=</span><span class="s0">this</span><span class="s1">.props,{projection:o}=n;</span><span class="s0">return </span><span class="s1">o?(o.isPresent=s,Zr=!</span><span class="s3">0</span><span class="s1">,i||t.layoutDependency!==e||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e||t.isPresent!==s?o.willUpdate():</span><span class="s0">this</span><span class="s1">.safeToRemove(),t.isPresent!==s&amp;&amp;(s?o.promote():o.relegate()||ht.postRender(()=&gt;{</span><span class="s0">const </span><span class="s1">t=o.getStack();t&amp;&amp;t.members.length||</span><span class="s0">this</span><span class="s1">.safeToRemove()})),</span><span class="s0">null</span><span class="s1">):</span><span class="s0">null</span><span class="s1">}componentDidUpdate(){</span><span class="s0">const</span><span class="s1">{projection:t}=</span><span class="s0">this</span><span class="s1">.props.visualElement;t&amp;&amp;(t.root.didUpdate(),ii.postRender(()=&gt;{!t.currentAnimation&amp;&amp;t.isLead()&amp;&amp;</span><span class="s0">this</span><span class="s1">.safeToRemove()}))}componentWillUnmount(){</span><span class="s0">const</span><span class="s1">{visualElement:t,layoutGroup:e,switchLayoutGroup:n}=</span><span class="s0">this</span><span class="s1">.props,{projection:i}=t;Zr=!</span><span class="s3">0</span><span class="s1">,i&amp;&amp;(i.scheduleCheckAfterUnmount(),e&amp;&amp;e.group&amp;&amp;e.group.remove(i),n&amp;&amp;n.deregister&amp;&amp;n.deregister(i))}safeToRemove(){</span><span class="s0">const</span><span class="s1">{safeToRemove:t}=</span><span class="s0">this</span><span class="s1">.props;t&amp;&amp;t()}render(){</span><span class="s0">return null</span><span class="s1">}}</span><span class="s0">function </span><span class="s1">Jr(t){</span><span class="s0">const</span><span class="s1">[n,s]=</span><span class="s0">function</span><span class="s1">(t=!</span><span class="s3">0</span><span class="s1">){</span><span class="s0">const </span><span class="s1">e=i($i);</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">===e)</span><span class="s0">return</span><span class="s1">[!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">null</span><span class="s1">];</span><span class="s0">const</span><span class="s1">{isPresent:n,onExitComplete:s,register:o}=e,r=p();u(()=&gt;{</span><span class="s0">if</span><span class="s1">(t)</span><span class="s0">return </span><span class="s1">o(r)},[t]);</span><span class="s0">const </span><span class="s1">a=l(()=&gt;t&amp;&amp;s&amp;&amp;s(r),[r,s,t]);</span><span class="s0">return</span><span class="s1">!n&amp;&amp;s?[!</span><span class="s3">1</span><span class="s1">,a]:[!</span><span class="s3">0</span><span class="s1">]}(),o=i(G);</span><span class="s0">return </span><span class="s1">e(_r,{...t,layoutGroup:o,switchLayoutGroup:i(rs),isPresent:n,safeToRemove:s})}</span><span class="s0">const </span><span class="s1">Qr={borderRadius:{...Gr,applyTo:[</span><span class="s2">&quot;borderTopLeftRadius&quot;</span><span class="s1">,</span><span class="s2">&quot;borderTopRightRadius&quot;</span><span class="s1">,</span><span class="s2">&quot;borderBottomLeftRadius&quot;</span><span class="s1">,</span><span class="s2">&quot;borderBottomRightRadius&quot;</span><span class="s1">]},borderTopLeftRadius:Gr,borderTopRightRadius:Gr,borderBottomLeftRadius:Gr,borderBottomRightRadius:Gr,boxShadow:qr},ta={pan:{Feature:</span><span class="s0">class extends </span><span class="s1">po{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.removePointerDownListener=S}onPointerDown(t){</span><span class="s0">this</span><span class="s1">.session=</span><span class="s0">new </span><span class="s1">Mo(t,</span><span class="s0">this</span><span class="s1">.createPanHandlers(),{transformPagePoint:</span><span class="s0">this</span><span class="s1">.node.getTransformPagePoint(),contextWindow:Eo(</span><span class="s0">this</span><span class="s1">.node)})}createPanHandlers(){</span><span class="s0">const</span><span class="s1">{onPanSessionStart:t,onPanStart:e,onPan:n,onPanEnd:i}=</span><span class="s0">this</span><span class="s1">.node.getProps();</span><span class="s0">return</span><span class="s1">{onSessionStart:Yo(t),onStart:Yo(e),onMove:n,onEnd:(t,e)=&gt;{</span><span class="s0">delete this</span><span class="s1">.session,i&amp;&amp;ht.postRender(()=&gt;i(t,e))}}}mount(){</span><span class="s0">this</span><span class="s1">.removePointerDownListener=vo(</span><span class="s0">this</span><span class="s1">.node.current,</span><span class="s2">&quot;pointerdown&quot;</span><span class="s1">,t=&gt;</span><span class="s0">this</span><span class="s1">.onPointerDown(t))}update(){</span><span class="s0">this</span><span class="s1">.session&amp;&amp;</span><span class="s0">this</span><span class="s1">.session.updateHandlers(</span><span class="s0">this</span><span class="s1">.createPanHandlers())}unmount(){</span><span class="s0">this</span><span class="s1">.removePointerDownListener(),</span><span class="s0">this</span><span class="s1">.session&amp;&amp;</span><span class="s0">this</span><span class="s1">.session.end()}}},drag:{Feature:</span><span class="s0">class extends </span><span class="s1">po{constructor(t){</span><span class="s0">super</span><span class="s1">(t),</span><span class="s0">this</span><span class="s1">.removeGroupControls=S,</span><span class="s0">this</span><span class="s1">.removeListeners=S,</span><span class="s0">this</span><span class="s1">.controls=</span><span class="s0">new </span><span class="s1">Wo(t)}mount(){</span><span class="s0">const</span><span class="s1">{dragControls:t}=</span><span class="s0">this</span><span class="s1">.node.getProps();t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.removeGroupControls=t.subscribe(</span><span class="s0">this</span><span class="s1">.controls)),</span><span class="s0">this</span><span class="s1">.removeListeners=</span><span class="s0">this</span><span class="s1">.controls.addListeners()||S}unmount(){</span><span class="s0">this</span><span class="s1">.removeGroupControls(),</span><span class="s0">this</span><span class="s1">.removeListeners()}},ProjectionNode:zr,MeasureLayout:Jr}};</span><span class="s0">function </span><span class="s1">ea(t,e,n){</span><span class="s0">const</span><span class="s1">{props:i}=t;t.animationState&amp;&amp;i.whileHover&amp;&amp;t.animationState.setActive(</span><span class="s2">&quot;whileHover&quot;</span><span class="s1">,</span><span class="s2">&quot;Start&quot;</span><span class="s1">===n);</span><span class="s0">const </span><span class="s1">s=i[</span><span class="s2">&quot;onHover&quot;</span><span class="s1">+n];s&amp;&amp;ht.postRender(()=&gt;s(e,go(e)))}</span><span class="s0">function </span><span class="s1">na(t,e,n){</span><span class="s0">const</span><span class="s1">{props:i}=t;</span><span class="s0">if</span><span class="s1">(t.current </span><span class="s0">instanceof </span><span class="s1">HTMLButtonElement&amp;&amp;t.current.disabled)</span><span class="s0">return</span><span class="s1">;t.animationState&amp;&amp;i.whileTap&amp;&amp;t.animationState.setActive(</span><span class="s2">&quot;whileTap&quot;</span><span class="s1">,</span><span class="s2">&quot;Start&quot;</span><span class="s1">===n);</span><span class="s0">const </span><span class="s1">s=i[</span><span class="s2">&quot;onTap&quot;</span><span class="s1">+(</span><span class="s2">&quot;End&quot;</span><span class="s1">===n?</span><span class="s2">&quot;&quot;</span><span class="s1">:n)];s&amp;&amp;ht.postRender(()=&gt;s(e,go(e)))}</span><span class="s0">const </span><span class="s1">ia=</span><span class="s0">new </span><span class="s1">WeakMap,sa=</span><span class="s0">new </span><span class="s1">WeakMap,oa=t=&gt;{</span><span class="s0">const </span><span class="s1">e=ia.get(t.target);e&amp;&amp;e(t)},ra=t=&gt;{t.forEach(oa)};</span><span class="s0">function </span><span class="s1">aa(t,e,n){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">function</span><span class="s1">({root:t,...e}){</span><span class="s0">const </span><span class="s1">n=t||document;sa.has(n)||sa.set(n,{});</span><span class="s0">const </span><span class="s1">i=sa.get(n),s=JSON.stringify(e);</span><span class="s0">return </span><span class="s1">i[s]||(i[s]=</span><span class="s0">new </span><span class="s1">IntersectionObserver(ra,{root:t,...e})),i[s]}(e);</span><span class="s0">return </span><span class="s1">ia.set(t,n),i.observe(t),()=&gt;{ia.delete(t),i.unobserve(t)}}</span><span class="s0">const </span><span class="s1">la={some:</span><span class="s3">0</span><span class="s1">,all:</span><span class="s3">1</span><span class="s1">};</span><span class="s0">const </span><span class="s1">ha={...fo,...{inView:{Feature:</span><span class="s0">class extends </span><span class="s1">po{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.hasEnteredView=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.isInView=!</span><span class="s3">1</span><span class="s1">}startObserver(){</span><span class="s0">this</span><span class="s1">.unmount();</span><span class="s0">const</span><span class="s1">{viewport:t={}}=</span><span class="s0">this</span><span class="s1">.node.getProps(),{root:e,margin:n,amount:i=</span><span class="s2">&quot;some&quot;</span><span class="s1">,once:s}=t,o={root:e?e.current:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,rootMargin:n,threshold:</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">i?i:la[i]};</span><span class="s0">return </span><span class="s1">aa(</span><span class="s0">this</span><span class="s1">.node.current,o,t=&gt;{</span><span class="s0">const</span><span class="s1">{isIntersecting:e}=t;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isInView===e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isInView=e,s&amp;&amp;!e&amp;&amp;</span><span class="s0">this</span><span class="s1">.hasEnteredView)</span><span class="s0">return</span><span class="s1">;e&amp;&amp;(</span><span class="s0">this</span><span class="s1">.hasEnteredView=!</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.node.animationState&amp;&amp;</span><span class="s0">this</span><span class="s1">.node.animationState.setActive(</span><span class="s2">&quot;whileInView&quot;</span><span class="s1">,e);</span><span class="s0">const</span><span class="s1">{onViewportEnter:n,onViewportLeave:i}=</span><span class="s0">this</span><span class="s1">.node.getProps(),o=e?n:i;o&amp;&amp;o(t)})}mount(){</span><span class="s0">this</span><span class="s1">.startObserver()}update(){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">IntersectionObserver)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{props:t,prevProps:e}=</span><span class="s0">this</span><span class="s1">.node;[</span><span class="s2">&quot;amount&quot;</span><span class="s1">,</span><span class="s2">&quot;margin&quot;</span><span class="s1">,</span><span class="s2">&quot;root&quot;</span><span class="s1">].some(</span><span class="s0">function</span><span class="s1">({viewport:t={}},{viewport:e={}}={}){</span><span class="s0">return </span><span class="s1">n=&gt;t[n]!==e[n]}(t,e))&amp;&amp;</span><span class="s0">this</span><span class="s1">.startObserver()}unmount(){}}},tap:{Feature:</span><span class="s0">class extends </span><span class="s1">po{mount(){</span><span class="s0">const</span><span class="s1">{current:t}=</span><span class="s0">this</span><span class="s1">.node;t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unmount=yi(t,(t,e)=&gt;(na(</span><span class="s0">this</span><span class="s1">.node,e,</span><span class="s2">&quot;Start&quot;</span><span class="s1">),(t,{success:e})=&gt;na(</span><span class="s0">this</span><span class="s1">.node,t,e?</span><span class="s2">&quot;End&quot;</span><span class="s1">:</span><span class="s2">&quot;Cancel&quot;</span><span class="s1">)),{useGlobalTarget:</span><span class="s0">this</span><span class="s1">.node.props.globalTapTarget}))}unmount(){}}},focus:{Feature:</span><span class="s0">class extends </span><span class="s1">po{constructor(){</span><span class="s0">super</span><span class="s1">(...arguments),</span><span class="s0">this</span><span class="s1">.isActive=!</span><span class="s3">1</span><span class="s1">}onFocus(){</span><span class="s0">let </span><span class="s1">t=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">try</span><span class="s1">{t=</span><span class="s0">this</span><span class="s1">.node.current.matches(</span><span class="s2">&quot;:focus-visible&quot;</span><span class="s1">)}</span><span class="s0">catch</span><span class="s1">(e){t=!</span><span class="s3">0</span><span class="s1">}t&amp;&amp;</span><span class="s0">this</span><span class="s1">.node.animationState&amp;&amp;(</span><span class="s0">this</span><span class="s1">.node.animationState.setActive(</span><span class="s2">&quot;whileFocus&quot;</span><span class="s1">,!</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.isActive=!</span><span class="s3">0</span><span class="s1">)}onBlur(){</span><span class="s0">this</span><span class="s1">.isActive&amp;&amp;</span><span class="s0">this</span><span class="s1">.node.animationState&amp;&amp;(</span><span class="s0">this</span><span class="s1">.node.animationState.setActive(</span><span class="s2">&quot;whileFocus&quot;</span><span class="s1">,!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.isActive=!</span><span class="s3">1</span><span class="s1">)}mount(){</span><span class="s0">this</span><span class="s1">.unmount=A(yo(</span><span class="s0">this</span><span class="s1">.node.current,</span><span class="s2">&quot;focus&quot;</span><span class="s1">,()=&gt;</span><span class="s0">this</span><span class="s1">.onFocus()),yo(</span><span class="s0">this</span><span class="s1">.node.current,</span><span class="s2">&quot;blur&quot;</span><span class="s1">,()=&gt;</span><span class="s0">this</span><span class="s1">.onBlur()))}unmount(){}}},hover:{Feature:</span><span class="s0">class extends </span><span class="s1">po{mount(){</span><span class="s0">const</span><span class="s1">{current:t}=</span><span class="s0">this</span><span class="s1">.node;t&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unmount=</span><span class="s0">function</span><span class="s1">(t,e,n={}){</span><span class="s0">const</span><span class="s1">[i,s,o]=ai(t,n),r=t=&gt;{</span><span class="s0">if</span><span class="s1">(!li(t))</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const</span><span class="s1">{target:n}=t,i=e(n,t);</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">i||!n)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">o=t=&gt;{li(t)&amp;&amp;(i(t),n.removeEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s1">,o))};n.addEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s1">,o,s)};</span><span class="s0">return </span><span class="s1">i.forEach(t=&gt;{t.addEventListener(</span><span class="s2">&quot;pointerenter&quot;</span><span class="s1">,r,s)}),o}(t,(t,e)=&gt;(ea(</span><span class="s0">this</span><span class="s1">.node,e,</span><span class="s2">&quot;Start&quot;</span><span class="s1">),t=&gt;ea(</span><span class="s0">this</span><span class="s1">.node,t,</span><span class="s2">&quot;End&quot;</span><span class="s1">))))}unmount(){}}}},...ta,...{layout:{ProjectionNode:zr,MeasureLayout:Jr}}};</span><span class="s0">function </span><span class="s1">ua(t,e){</span><span class="s0">return </span><span class="s1">us(t,e,ha,Us)}</span><span class="s0">const </span><span class="s1">ca=ua(</span><span class="s2">&quot;div&quot;</span><span class="s1">);</span><span class="s0">export</span><span class="s1">{ca as MotionDiv};</span>
</pre>
</body>
</html>