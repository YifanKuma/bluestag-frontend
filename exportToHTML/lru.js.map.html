<html>
<head>
<title>lru.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lru.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/segment-cache-impl/lru.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export type LRU&lt;T extends LRUNode&gt; = {</span><span class="s3">\n  </span><span class="s1">put(node: T): void</span><span class="s3">\n  </span><span class="s1">delete(node: T): void</span><span class="s3">\n  </span><span class="s1">updateSize(node: T, size: number): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Doubly-linked list</span><span class="s3">\n</span><span class="s1">type LRUNode&lt;T = any&gt; = {</span><span class="s3">\n  </span><span class="s1">// Although it's not encoded in the type, these are both null if the node is</span><span class="s3">\n  </span><span class="s1">// not in the LRU; both non-null if it is.</span><span class="s3">\n  </span><span class="s1">prev: T | null</span><span class="s3">\n  </span><span class="s1">next: T | null</span><span class="s3">\n  </span><span class="s1">size: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Rather than create an internal LRU node, the passed-in type must conform</span><span class="s3">\n</span><span class="s1">// the LRUNode interface. This is just a memory optimization to avoid creating</span><span class="s3">\n</span><span class="s1">// another object; we only use this for Segment Cache entries so it doesn't need</span><span class="s3">\n</span><span class="s1">// to be general purpose.</span><span class="s3">\n</span><span class="s1">export function createLRU&lt;T extends LRUNode&gt;(</span><span class="s3">\n  </span><span class="s1">// From the LRU's perspective, the size unit is arbitrary, but for our</span><span class="s3">\n  </span><span class="s1">// purposes this is the byte size.</span><span class="s3">\n  </span><span class="s1">maxLruSize: number,</span><span class="s3">\n  </span><span class="s1">onEviction: (node: T) =&gt; void</span><span class="s3">\n</span><span class="s1">): LRU&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">let head: T | null = null</span><span class="s3">\n  </span><span class="s1">let didScheduleCleanup: boolean = false</span><span class="s3">\n  </span><span class="s1">let lruSize: number = 0</span><span class="s3">\n\n  </span><span class="s1">function put(node: T) {</span><span class="s3">\n    </span><span class="s1">if (head === node) {</span><span class="s3">\n      </span><span class="s1">// Already at the head</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const prev = node.prev</span><span class="s3">\n    </span><span class="s1">const next = node.next</span><span class="s3">\n    </span><span class="s1">if (next === null || prev === null) {</span><span class="s3">\n      </span><span class="s1">// This is an insertion</span><span class="s3">\n      </span><span class="s1">lruSize += node.size</span><span class="s3">\n      </span><span class="s1">// Whenever we add an entry, we need to check if we've exceeded the</span><span class="s3">\n      </span><span class="s1">// max size. We don't evict entries immediately; they're evicted later in</span><span class="s3">\n      </span><span class="s1">// an asynchronous task.</span><span class="s3">\n      </span><span class="s1">ensureCleanupIsScheduled()</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// This is a move. Remove from its current position.</span><span class="s3">\n      </span><span class="s1">prev.next = next</span><span class="s3">\n      </span><span class="s1">next.prev = prev</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Move to the front of the list</span><span class="s3">\n    </span><span class="s1">if (head === null) {</span><span class="s3">\n      </span><span class="s1">// This is the first entry</span><span class="s3">\n      </span><span class="s1">node.prev = node</span><span class="s3">\n      </span><span class="s1">node.next = node</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Add to the front of the list</span><span class="s3">\n      </span><span class="s1">const tail = head.prev</span><span class="s3">\n      </span><span class="s1">node.prev = tail</span><span class="s3">\n      </span><span class="s1">tail.next = node</span><span class="s3">\n      </span><span class="s1">node.next = head</span><span class="s3">\n      </span><span class="s1">head.prev = node</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">head = node</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function updateSize(node: T, newNodeSize: number) {</span><span class="s3">\n    </span><span class="s1">// This is a separate function from `put` so that we can resize the entry</span><span class="s3">\n    </span><span class="s1">// regardless of whether it's currently being tracked by the LRU.</span><span class="s3">\n    </span><span class="s1">const prevNodeSize = node.size</span><span class="s3">\n    </span><span class="s1">node.size = newNodeSize</span><span class="s3">\n    </span><span class="s1">if (node.next === null) {</span><span class="s3">\n      </span><span class="s1">// This entry is not currently being tracked by the LRU.</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Update the total LRU size</span><span class="s3">\n    </span><span class="s1">lruSize = lruSize - prevNodeSize + newNodeSize</span><span class="s3">\n    </span><span class="s1">ensureCleanupIsScheduled()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function deleteNode(deleted: T) {</span><span class="s3">\n    </span><span class="s1">const next = deleted.next</span><span class="s3">\n    </span><span class="s1">const prev = deleted.prev</span><span class="s3">\n    </span><span class="s1">if (next !== null &amp;&amp; prev !== null) {</span><span class="s3">\n      </span><span class="s1">lruSize -= deleted.size</span><span class="s3">\n\n      </span><span class="s1">deleted.next = null</span><span class="s3">\n      </span><span class="s1">deleted.prev = null</span><span class="s3">\n\n      </span><span class="s1">// Remove from the list</span><span class="s3">\n      </span><span class="s1">if (head === deleted) {</span><span class="s3">\n        </span><span class="s1">// Update the head</span><span class="s3">\n        </span><span class="s1">if (next === head) {</span><span class="s3">\n          </span><span class="s1">// This was the last entry</span><span class="s3">\n          </span><span class="s1">head = null</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">head = next</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">prev.next = next</span><span class="s3">\n        </span><span class="s1">next.prev = prev</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Already deleted</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function ensureCleanupIsScheduled() {</span><span class="s3">\n    </span><span class="s1">if (didScheduleCleanup || lruSize &lt;= maxLruSize) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">didScheduleCleanup = true</span><span class="s3">\n    </span><span class="s1">requestCleanupCallback(cleanup)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function cleanup() {</span><span class="s3">\n    </span><span class="s1">didScheduleCleanup = false</span><span class="s3">\n\n    </span><span class="s1">// Evict entries until we're at 90% capacity. We can assume this won't</span><span class="s3">\n    </span><span class="s1">// infinite loop because even if `maxLruSize` were 0, eventually</span><span class="s3">\n    </span><span class="s1">// `deleteNode` sets `head` to `null` when we run out entries.</span><span class="s3">\n    </span><span class="s1">const ninetyPercentMax = maxLruSize * 0.9</span><span class="s3">\n    </span><span class="s1">while (lruSize &gt; ninetyPercentMax &amp;&amp; head !== null) {</span><span class="s3">\n      </span><span class="s1">const tail = head.prev</span><span class="s3">\n      </span><span class="s1">deleteNode(tail)</span><span class="s3">\n      </span><span class="s1">onEviction(tail)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">put,</span><span class="s3">\n    </span><span class="s1">delete: deleteNode,</span><span class="s3">\n    </span><span class="s1">updateSize,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const requestCleanupCallback =</span><span class="s3">\n  </span><span class="s1">typeof requestIdleCallback === 'function'</span><span class="s3">\n    </span><span class="s1">? requestIdleCallback</span><span class="s3">\n    </span><span class="s1">: (cb: () =&gt; void) =&gt; setTimeout(cb, 0)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createLRU&quot;</span><span class="s0">,</span><span class="s1">&quot;maxLruSize&quot;</span><span class="s0">,</span><span class="s1">&quot;onEviction&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;didScheduleCleanup&quot;</span><span class="s0">,</span><span class="s1">&quot;lruSize&quot;</span><span class="s0">,</span><span class="s1">&quot;put&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;prev&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureCleanupIsScheduled&quot;</span><span class="s0">,</span><span class="s1">&quot;tail&quot;</span><span class="s0">,</span><span class="s1">&quot;updateSize&quot;</span><span class="s0">,</span><span class="s1">&quot;newNodeSize&quot;</span><span class="s0">,</span><span class="s1">&quot;prevNodeSize&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteNode&quot;</span><span class="s0">,</span><span class="s1">&quot;deleted&quot;</span><span class="s0">,</span><span class="s1">&quot;requestCleanupCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanup&quot;</span><span class="s0">,</span><span class="s1">&quot;ninetyPercentMax&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;requestIdleCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAmBgBA;;;eAAAA;;;AAAT,SAASA,UACd,sEAAsE;AACtE,kCAAkC;AAClCC,UAAkB,EAClBC,UAA6B;IAE7B,IAAIC,OAAiB;IACrB,IAAIC,qBAA8B;IAClC,IAAIC,UAAkB;IAEtB,SAASC,IAAIC,IAAO;QAClB,IAAIJ,SAASI,MAAM;YACjB,sBAAsB;YACtB;QACF;QACA,MAAMC,OAAOD,KAAKC,IAAI;QACtB,MAAMC,OAAOF,KAAKE,IAAI;QACtB,IAAIA,SAAS,QAAQD,SAAS,MAAM;YAClC,uBAAuB;YACvBH,WAAWE,KAAKG,IAAI;YACpB,mEAAmE;YACnE,yEAAyE;YACzE,wBAAwB;YACxBC;QACF,OAAO;YACL,oDAAoD;YACpDH,KAAKC,IAAI,GAAGA;YACZA,KAAKD,IAAI,GAAGA;QACd;QAEA,gCAAgC;QAChC,IAAIL,SAAS,MAAM;YACjB,0BAA0B;YAC1BI,KAAKC,IAAI,GAAGD;YACZA,KAAKE,IAAI,GAAGF;QACd,OAAO;YACL,+BAA+B;YAC/B,MAAMK,OAAOT,KAAKK,IAAI;YACtBD,KAAKC,IAAI,GAAGI;YACZA,KAAKH,IAAI,GAAGF;YACZA,KAAKE,IAAI,GAAGN;YACZA,KAAKK,IAAI,GAAGD;QACd;QACAJ,OAAOI;IACT;IAEA,SAASM,WAAWN,IAAO,EAAEO,WAAmB;QAC9C,yEAAyE;QACzE,iEAAiE;QACjE,MAAMC,eAAeR,KAAKG,IAAI;QAC9BH,KAAKG,IAAI,GAAGI;QACZ,IAAIP,KAAKE,IAAI,KAAK,MAAM;YACtB,wDAAwD;YACxD;QACF;QACA,4BAA4B;QAC5BJ,UAAUA,UAAUU,eAAeD;QACnCH;IACF;IAEA,SAASK,WAAWC,OAAU;QAC5B,MAAMR,OAAOQ,QAAQR,IAAI;QACzB,MAAMD,OAAOS,QAAQT,IAAI;QACzB,IAAIC,SAAS,QAAQD,SAAS,MAAM;YAClCH,WAAWY,QAAQP,IAAI;YAEvBO,QAAQR,IAAI,GAAG;YACfQ,QAAQT,IAAI,GAAG;YAEf,uBAAuB;YACvB,IAAIL,SAASc,SAAS;gBACpB,kBAAkB;gBAClB,IAAIR,SAASN,MAAM;oBACjB,0BAA0B;oBAC1BA,OAAO;gBACT,OAAO;oBACLA,OAAOM;gBACT;YACF,OAAO;gBACLD,KAAKC,IAAI,GAAGA;gBACZA,KAAKD,IAAI,GAAGA;YACd;QACF,OAAO;QACL,kBAAkB;QACpB;IACF;IAEA,SAASG;QACP,IAAIP,sBAAsBC,WAAWJ,YAAY;YAC/C;QACF;QACAG,qBAAqB;QACrBc,uBAAuBC;IACzB;IAEA,SAASA;QACPf,qBAAqB;QAErB,sEAAsE;QACtE,gEAAgE;QAChE,8DAA8D;QAC9D,MAAMgB,mBAAmBnB,aAAa;QACtC,MAAOI,UAAUe,oBAAoBjB,SAAS,KAAM;YAClD,MAAMS,OAAOT,KAAKK,IAAI;YACtBQ,WAAWJ;YACXV,WAAWU;QACb;IACF;IAEA,OAAO;QACLN;QACAe,QAAQL;QACRH;IACF;AACF;AAEA,MAAMK,yBACJ,OAAOI,wBAAwB,aAC3BA,sBACA,CAACC,KAAmBC,WAAWD,IAAI&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>