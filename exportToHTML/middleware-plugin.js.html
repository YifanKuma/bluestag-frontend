<html>
<head>
<title>middleware-plugin.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
middleware-plugin.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">SUPPORTED_NATIVE_MODULES: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getEdgePolyfilledModules: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">handleWebpackExternalForEdgeRuntime: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">SUPPORTED_NATIVE_MODULES: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">SUPPORTED_NATIVE_MODULES;</span>
    <span class="s1">},</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">MiddlewarePlugin;</span>
    <span class="s1">},</span>
    <span class="s1">getEdgePolyfilledModules: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getEdgePolyfilledModules;</span>
    <span class="s1">},</span>
    <span class="s1">handleWebpackExternalForEdgeRuntime: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">handleWebpackExternalForEdgeRuntime;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_routeregex = require(</span><span class="s0">&quot;../../../shared/lib/router/utils/route-regex&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getmodulebuildinfo = require(</span><span class="s0">&quot;../loaders/get-module-build-info&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../../../shared/lib/router/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_webpack = require(</span><span class="s0">&quot;next/dist/compiled/webpack/webpack&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_picomatch = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/picomatch&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_shared = require(</span><span class="s0">&quot;../../../trace/shared&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_events = require(</span><span class="s0">&quot;../../../telemetry/events&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../../../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;../../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_generateinterceptionroutesrewrites = require(</span><span class="s0">&quot;../../../lib/generate-interception-routes-rewrites&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parsedynamiccodeevaluationerror = require(</span><span class="s0">&quot;./wellknown-errors-plugin/parse-dynamic-code-evaluation-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;../utils&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">KNOWN_SAFE_DYNAMIC_PACKAGES = require(</span><span class="s0">'../../../lib/known-edge-safe-packages.json'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">NAME = </span><span class="s0">'MiddlewarePlugin'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">MANIFEST_VERSION = </span><span class="s3">3</span><span class="s1">;</span>
<span class="s4">/**</span>
 <span class="s4">* Checks the value of usingIndirectEval and when it is a set of modules it</span>
 <span class="s4">* check if any of the modules is actually being used. If the value is</span>
 <span class="s4">* simply truthy it will return true.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">isUsingIndirectEvalAndUsedByExports(args) {</span>
    <span class="s2">const </span><span class="s1">{ moduleGraph, runtime, module: module1, usingIndirectEval, wp } = args;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">usingIndirectEval === </span><span class="s0">'boolean'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">usingIndirectEval;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">exportsInfo = moduleGraph.getExportsInfo(module1);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportName of usingIndirectEval){</span>
        <span class="s2">if </span><span class="s1">(exportsInfo.getUsed(exportName, runtime) !== wp.UsageState.Unused) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getEntryFiles(entryFiles, meta, hasInstrumentationHook, opts) {</span>
    <span class="s2">const </span><span class="s1">files = [];</span>
    <span class="s2">if </span><span class="s1">(meta.edgeSSR) {</span>
        <span class="s2">if </span><span class="s1">(meta.edgeSSR.isServerComponent) {</span>
            <span class="s1">files.push(</span><span class="s0">`server/</span><span class="s1">${_constants.SERVER_REFERENCE_MANIFEST}</span><span class="s0">.js`</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(opts.sriEnabled) {</span>
                <span class="s1">files.push(</span><span class="s0">`server/</span><span class="s1">${_constants.SUBRESOURCE_INTEGRITY_MANIFEST}</span><span class="s0">.js`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">files.push(...entryFiles.filter((file)=&gt;file.startsWith(</span><span class="s0">'app/'</span><span class="s1">) &amp;&amp; !file.endsWith(</span><span class="s0">'.hot-update.js'</span><span class="s1">)).map((file)=&gt;</span><span class="s0">'server/' </span><span class="s1">+ file.replace(</span><span class="s5">/\.js$/</span><span class="s1">, </span><span class="s0">'_' </span><span class="s1">+ _constants.CLIENT_REFERENCE_MANIFEST + </span><span class="s0">'.js'</span><span class="s1">)));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!opts.dev &amp;&amp; !meta.edgeSSR.isAppDir) {</span>
            <span class="s1">files.push(</span><span class="s0">`server/</span><span class="s1">${_constants.DYNAMIC_CSS_MANIFEST}</span><span class="s0">.js`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">files.push(</span><span class="s0">`server/</span><span class="s1">${_constants.MIDDLEWARE_BUILD_MANIFEST}</span><span class="s0">.js`</span><span class="s1">, </span><span class="s0">`server/</span><span class="s1">${_constants.MIDDLEWARE_REACT_LOADABLE_MANIFEST}</span><span class="s0">.js`</span><span class="s1">, </span><span class="s0">`server/</span><span class="s1">${_constants.NEXT_FONT_MANIFEST}</span><span class="s0">.js`</span><span class="s1">, </span><span class="s0">`server/</span><span class="s1">${_constants.INTERCEPTION_ROUTE_REWRITE_MANIFEST}</span><span class="s0">.js`</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(hasInstrumentationHook) {</span>
        <span class="s1">files.push(</span><span class="s0">`server/edge-</span><span class="s1">${_constants1.INSTRUMENTATION_HOOK_FILENAME}</span><span class="s0">.js`</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">files.push(...entryFiles.filter((file)=&gt;!file.endsWith(</span><span class="s0">'.hot-update.js'</span><span class="s1">)).map((file)=&gt;</span><span class="s0">'server/' </span><span class="s1">+ file));</span>
    <span class="s2">return </span><span class="s1">files;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCreateAssets(params) {</span>
    <span class="s2">const </span><span class="s1">{ compilation, metadataByEntry, opts } = params;</span>
    <span class="s2">return </span><span class="s1">()=&gt;{</span>
        <span class="s2">const </span><span class="s1">middlewareManifest = {</span>
            <span class="s1">version: MANIFEST_VERSION,</span>
            <span class="s1">middleware: {},</span>
            <span class="s1">functions: {},</span>
            <span class="s1">sortedMiddleware: []</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">hasInstrumentationHook = compilation.entrypoints.has(_constants1.INSTRUMENTATION_HOOK_FILENAME);</span>
        <span class="s4">// we only emit this entry for the edge runtime since it doesn't have access to a routes manifest</span>
        <span class="s4">// and we don't need to provide the entire route manifest, just the interception routes.</span>
        <span class="s2">const </span><span class="s1">interceptionRewrites = JSON.stringify(opts.rewrites.beforeFiles.filter(_generateinterceptionroutesrewrites.isInterceptionRouteRewrite));</span>
        <span class="s1">compilation.emitAsset(</span><span class="s0">`</span><span class="s1">${_constants.INTERCEPTION_ROUTE_REWRITE_MANIFEST}</span><span class="s0">.js`</span><span class="s1">, </span><span class="s2">new </span><span class="s1">_webpack.sources.RawSource(</span><span class="s0">`self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST=</span><span class="s1">${JSON.stringify(interceptionRewrites)}</span><span class="s0">`</span><span class="s1">));</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entrypoint of compilation.entrypoints.values()){</span>
            <span class="s2">var </span><span class="s1">_metadata_edgeMiddleware, _metadata_edgeSSR, _metadata_edgeApiFunction, _metadata_edgeSSR1, _metadata_edgeMiddleware1;</span>
            <span class="s2">if </span><span class="s1">(!entrypoint.name) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// There should always be metadata for the entrypoint.</span>
            <span class="s2">const </span><span class="s1">metadata = metadataByEntry.get(entrypoint.name);</span>
            <span class="s2">const </span><span class="s1">page = (metadata == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_metadata_edgeMiddleware = metadata.edgeMiddleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _metadata_edgeMiddleware.page) || (metadata == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_metadata_edgeSSR = metadata.edgeSSR) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _metadata_edgeSSR.page) || (metadata == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_metadata_edgeApiFunction = metadata.edgeApiFunction) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _metadata_edgeApiFunction.page);</span>
            <span class="s2">if </span><span class="s1">(!page) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">matcherSource = ((_metadata_edgeSSR1 = metadata.edgeSSR) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _metadata_edgeSSR1.isAppDir) ? (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(page) : page;</span>
            <span class="s2">const </span><span class="s1">catchAll = !metadata.edgeSSR &amp;&amp; !metadata.edgeApiFunction;</span>
            <span class="s2">const </span><span class="s1">{ namedRegex } = (</span><span class="s3">0</span><span class="s1">, _routeregex.getNamedMiddlewareRegex)(matcherSource, {</span>
                <span class="s1">catchAll</span>
            <span class="s1">});</span>
            <span class="s2">const </span><span class="s1">matchers = (metadata == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_metadata_edgeMiddleware1 = metadata.edgeMiddleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _metadata_edgeMiddleware1.matchers) ?? [</span>
                <span class="s1">{</span>
                    <span class="s1">regexp: namedRegex,</span>
                    <span class="s1">originalSource: page === </span><span class="s0">'/' </span><span class="s1">&amp;&amp; catchAll ? </span><span class="s0">'/:path*' </span><span class="s1">: matcherSource</span>
                <span class="s1">}</span>
            <span class="s1">];</span>
            <span class="s2">const </span><span class="s1">isEdgeFunction = !!(metadata.edgeApiFunction || metadata.edgeSSR);</span>
            <span class="s2">const </span><span class="s1">edgeFunctionDefinition = {</span>
                <span class="s1">files: getEntryFiles(entrypoint.getFiles(), metadata, hasInstrumentationHook, opts),</span>
                <span class="s1">name: entrypoint.name,</span>
                <span class="s1">page: page,</span>
                <span class="s1">matchers,</span>
                <span class="s1">wasm: Array.from(metadata.wasmBindings, ([name, filePath])=&gt;({</span>
                        <span class="s1">name,</span>
                        <span class="s1">filePath</span>
                    <span class="s1">})),</span>
                <span class="s1">assets: Array.from(metadata.assetBindings, ([name, filePath])=&gt;({</span>
                        <span class="s1">name,</span>
                        <span class="s1">filePath</span>
                    <span class="s1">})),</span>
                <span class="s1">env: opts.edgeEnvironments,</span>
                <span class="s1">...metadata.regions &amp;&amp; {</span>
                    <span class="s1">regions: metadata.regions</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
            <span class="s2">if </span><span class="s1">(isEdgeFunction) {</span>
                <span class="s1">middlewareManifest.functions[page] = edgeFunctionDefinition;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">middlewareManifest.middleware[page] = edgeFunctionDefinition;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">middlewareManifest.sortedMiddleware = (</span><span class="s3">0</span><span class="s1">, _utils.getSortedRoutes)(Object.keys(middlewareManifest.middleware));</span>
        <span class="s1">compilation.emitAsset(_constants.MIDDLEWARE_MANIFEST, </span><span class="s2">new </span><span class="s1">_webpack.sources.RawSource(JSON.stringify(middlewareManifest, </span><span class="s2">null</span><span class="s1">, </span><span class="s3">2</span><span class="s1">)));</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildWebpackError({ message, loc, compilation, entryModule, parser }) {</span>
    <span class="s2">const </span><span class="s1">error = </span><span class="s2">new </span><span class="s1">compilation.compiler.webpack.WebpackError(message);</span>
    <span class="s1">error.name = NAME;</span>
    <span class="s2">const </span><span class="s1">module1 = entryModule ?? (parser == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: parser.state.current);</span>
    <span class="s2">if </span><span class="s1">(module1) {</span>
        <span class="s1">error.module = module1;</span>
    <span class="s1">}</span>
    <span class="s1">error.loc = loc;</span>
    <span class="s2">return </span><span class="s1">error;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isInMiddlewareLayer(parser) {</span>
    <span class="s2">var </span><span class="s1">_parser_state_module;</span>
    <span class="s2">const </span><span class="s1">layer = (_parser_state_module = parser.state.module) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _parser_state_module.layer;</span>
    <span class="s2">return </span><span class="s1">layer === _constants1.WEBPACK_LAYERS.middleware || layer === _constants1.WEBPACK_LAYERS.apiEdge;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isNodeJsModule(moduleName) {</span>
    <span class="s2">return </span><span class="s1">require(</span><span class="s0">'module'</span><span class="s1">).builtinModules.includes(moduleName);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isBunModule(moduleName) {</span>
    <span class="s2">return </span><span class="s1">moduleName === </span><span class="s0">'bun' </span><span class="s1">|| moduleName.startsWith(</span><span class="s0">'bun:'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isDynamicCodeEvaluationAllowed(fileName, middlewareConfig, rootDir) {</span>
    <span class="s4">// Some packages are known to use `eval` but are safe to use in the Edge</span>
    <span class="s4">// Runtime because the dynamic code will never be executed.</span>
    <span class="s2">if </span><span class="s1">(KNOWN_SAFE_DYNAMIC_PACKAGES.some((pkg)=&gt;fileName.includes(</span><span class="s0">`/node_modules/</span><span class="s1">${pkg}</span><span class="s0">/`</span><span class="s1">.replace(</span><span class="s5">/\//g</span><span class="s1">, _path.default.sep)))) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">name = fileName.replace(rootDir ?? </span><span class="s0">''</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _picomatch.default)((middlewareConfig == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: middlewareConfig.unstable_allowDynamic) ?? [], {</span>
        <span class="s1">dot: </span><span class="s2">true</span>
    <span class="s1">})(name);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildUnsupportedApiError({ apiName, loc, ...rest }) {</span>
    <span class="s2">return </span><span class="s1">buildWebpackError({</span>
        <span class="s1">message: </span><span class="s0">`A Node.js API is used (</span><span class="s1">${apiName} </span><span class="s0">at line: </span><span class="s1">${loc.start.line}</span><span class="s0">) which is not supported in the Edge Runtime. 
Learn more: https://nextjs.org/docs/api-reference/edge-runtime`</span><span class="s1">,</span>
        <span class="s1">loc,</span>
        <span class="s1">...rest</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">registerUnsupportedApiHooks(parser, compilation) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of _constants.EDGE_UNSUPPORTED_NODE_APIS){</span>
        <span class="s2">const </span><span class="s1">warnForUnsupportedApi = (node)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(!isInMiddlewareLayer(parser)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">compilation.warnings.push(buildUnsupportedApiError({</span>
                <span class="s1">compilation,</span>
                <span class="s1">parser,</span>
                <span class="s1">apiName: expression,</span>
                <span class="s1">...node</span>
            <span class="s1">}));</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s1">parser.hooks.call.for(expression).tap(NAME, warnForUnsupportedApi);</span>
        <span class="s1">parser.hooks.expression.for(expression).tap(NAME, warnForUnsupportedApi);</span>
        <span class="s1">parser.hooks.callMemberChain.for(expression).tap(NAME, warnForUnsupportedApi);</span>
        <span class="s1">parser.hooks.expressionMemberChain.for(expression).tap(NAME, warnForUnsupportedApi);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">warnForUnsupportedProcessApi = (node, [callee])=&gt;{</span>
        <span class="s2">if </span><span class="s1">(!isInMiddlewareLayer(parser) || callee === </span><span class="s0">'env'</span><span class="s1">) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">compilation.warnings.push(buildUnsupportedApiError({</span>
            <span class="s1">compilation,</span>
            <span class="s1">parser,</span>
            <span class="s1">apiName: </span><span class="s0">`process.</span><span class="s1">${callee}</span><span class="s0">`</span><span class="s1">,</span>
            <span class="s1">...node</span>
        <span class="s1">}));</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s1">parser.hooks.callMemberChain.for(</span><span class="s0">'process'</span><span class="s1">).tap(NAME, warnForUnsupportedProcessApi);</span>
    <span class="s1">parser.hooks.expressionMemberChain.for(</span><span class="s0">'process'</span><span class="s1">).tap(NAME, warnForUnsupportedProcessApi);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCodeAnalyzer(params) {</span>
    <span class="s2">return </span><span class="s1">(parser)=&gt;{</span>
        <span class="s2">const </span><span class="s1">{ dev, compiler: { webpack: wp }, compilation } = params;</span>
        <span class="s2">const </span><span class="s1">{ hooks } = parser;</span>
        <span class="s4">/**</span>
     <span class="s4">* For an expression this will check the graph to ensure it is being used</span>
     <span class="s4">* by exports. Then it will store in the module buildInfo a boolean to</span>
     <span class="s4">* express that it contains dynamic code and, if it is available, the</span>
     <span class="s4">* module path that is using it.</span>
     <span class="s4">*/ </span><span class="s2">const </span><span class="s1">handleExpression = ()=&gt;{</span>
            <span class="s2">if </span><span class="s1">(!isInMiddlewareLayer(parser)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">wp.optimize.InnerGraph.onUsage(parser.state, (used = </span><span class="s2">true</span><span class="s1">)=&gt;{</span>
                <span class="s2">const </span><span class="s1">buildInfo = (</span><span class="s3">0</span><span class="s1">, _getmodulebuildinfo.getModuleBuildInfo)(parser.state.module);</span>
                <span class="s2">if </span><span class="s1">(buildInfo.usingIndirectEval === </span><span class="s2">true </span><span class="s1">|| used === </span><span class="s2">false</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!buildInfo.usingIndirectEval || used === </span><span class="s2">true</span><span class="s1">) {</span>
                    <span class="s1">buildInfo.usingIndirectEval = used;</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">buildInfo.usingIndirectEval = </span><span class="s2">new </span><span class="s1">Set([</span>
                    <span class="s1">...Array.from(buildInfo.usingIndirectEval),</span>
                    <span class="s1">...Array.from(used)</span>
                <span class="s1">]);</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
        <span class="s4">/**</span>
     <span class="s4">* This expression handler allows to wrap a dynamic code expression with a</span>
     <span class="s4">* function call where we can warn about dynamic code not being allowed</span>
     <span class="s4">* but actually execute the expression.</span>
     <span class="s4">*/ </span><span class="s2">const </span><span class="s1">handleWrapExpression = (expr)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(!isInMiddlewareLayer(parser)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ ConstDependency } = wp.dependencies;</span>
            <span class="s2">const </span><span class="s1">dep1 = </span><span class="s2">new </span><span class="s1">ConstDependency(</span><span class="s0">'__next_eval__(function() { return '</span><span class="s1">, expr.range[</span><span class="s3">0</span><span class="s1">]);</span>
            <span class="s1">dep1.loc = expr.loc;</span>
            <span class="s1">parser.state.module.addPresentationalDependency(dep1);</span>
            <span class="s2">const </span><span class="s1">dep2 = </span><span class="s2">new </span><span class="s1">ConstDependency(</span><span class="s0">'})'</span><span class="s1">, expr.range[</span><span class="s3">1</span><span class="s1">]);</span>
            <span class="s1">dep2.loc = expr.loc;</span>
            <span class="s1">parser.state.module.addPresentationalDependency(dep2);</span>
            <span class="s1">handleExpression();</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s4">/**</span>
     <span class="s4">* This expression handler allows to wrap a WebAssembly.compile invocation with a</span>
     <span class="s4">* function call where we can warn about WASM code generation not being allowed</span>
     <span class="s4">* but actually execute the expression.</span>
     <span class="s4">*/ </span><span class="s2">const </span><span class="s1">handleWrapWasmCompileExpression = (expr)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(!isInMiddlewareLayer(parser)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ ConstDependency } = wp.dependencies;</span>
            <span class="s2">const </span><span class="s1">dep1 = </span><span class="s2">new </span><span class="s1">ConstDependency(</span><span class="s0">'__next_webassembly_compile__(function() { return '</span><span class="s1">, expr.range[</span><span class="s3">0</span><span class="s1">]);</span>
            <span class="s1">dep1.loc = expr.loc;</span>
            <span class="s1">parser.state.module.addPresentationalDependency(dep1);</span>
            <span class="s2">const </span><span class="s1">dep2 = </span><span class="s2">new </span><span class="s1">ConstDependency(</span><span class="s0">'})'</span><span class="s1">, expr.range[</span><span class="s3">1</span><span class="s1">]);</span>
            <span class="s1">dep2.loc = expr.loc;</span>
            <span class="s1">parser.state.module.addPresentationalDependency(dep2);</span>
            <span class="s1">handleExpression();</span>
        <span class="s1">};</span>
        <span class="s4">/**</span>
     <span class="s4">* This expression handler allows to wrap a WebAssembly.instatiate invocation with a</span>
     <span class="s4">* function call where we can warn about WASM code generation not being allowed</span>
     <span class="s4">* but actually execute the expression.</span>
     <span class="s4">*</span>
     <span class="s4">* Note that we don't update `usingIndirectEval`, i.e. we don't abort a production build</span>
     <span class="s4">* since we can't determine statically if the first parameter is a module (legit use) or</span>
     <span class="s4">* a buffer (dynamic code generation).</span>
     <span class="s4">*/ </span><span class="s2">const </span><span class="s1">handleWrapWasmInstantiateExpression = (expr)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(!isInMiddlewareLayer(parser)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(dev) {</span>
                <span class="s2">const </span><span class="s1">{ ConstDependency } = wp.dependencies;</span>
                <span class="s2">const </span><span class="s1">dep1 = </span><span class="s2">new </span><span class="s1">ConstDependency(</span><span class="s0">'__next_webassembly_instantiate__(function() { return '</span><span class="s1">, expr.range[</span><span class="s3">0</span><span class="s1">]);</span>
                <span class="s1">dep1.loc = expr.loc;</span>
                <span class="s1">parser.state.module.addPresentationalDependency(dep1);</span>
                <span class="s2">const </span><span class="s1">dep2 = </span><span class="s2">new </span><span class="s1">ConstDependency(</span><span class="s0">'})'</span><span class="s1">, expr.range[</span><span class="s3">1</span><span class="s1">]);</span>
                <span class="s1">dep2.loc = expr.loc;</span>
                <span class="s1">parser.state.module.addPresentationalDependency(dep2);</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s4">/**</span>
     <span class="s4">* Handler to store original source location of static and dynamic imports into module's buildInfo.</span>
     <span class="s4">*/ </span><span class="s2">const </span><span class="s1">handleImport = (node)=&gt;{</span>
            <span class="s2">var </span><span class="s1">_node_source;</span>
            <span class="s2">if </span><span class="s1">(isInMiddlewareLayer(parser) &amp;&amp; ((_node_source = node.source) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _node_source.value) &amp;&amp; (node == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: node.loc)) {</span>
                <span class="s2">var </span><span class="s1">_node_source_value;</span>
                <span class="s2">const </span><span class="s1">{ module: module1, source } = parser.state;</span>
                <span class="s2">const </span><span class="s1">buildInfo = (</span><span class="s3">0</span><span class="s1">, _getmodulebuildinfo.getModuleBuildInfo)(module1);</span>
                <span class="s2">if </span><span class="s1">(!buildInfo.importLocByPath) {</span>
                    <span class="s1">buildInfo.importLocByPath = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">importedModule = (_node_source_value = node.source.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _node_source_value.toString();</span>
                <span class="s1">buildInfo.importLocByPath.set(importedModule, {</span>
                    <span class="s1">sourcePosition: {</span>
                        <span class="s1">...node.loc.start,</span>
                        <span class="s1">source: module1.identifier()</span>
                    <span class="s1">},</span>
                    <span class="s1">sourceContent: source.toString()</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(!dev &amp;&amp; (isNodeJsModule(importedModule) || isBunModule(importedModule)) &amp;&amp; !SUPPORTED_NATIVE_MODULES.includes(importedModule)) {</span>
                    <span class="s2">const </span><span class="s1">isBun = isBunModule(importedModule);</span>
                    <span class="s1">compilation.warnings.push(buildWebpackError({</span>
                        <span class="s1">message: </span><span class="s0">`A </span><span class="s1">${isBun ? </span><span class="s0">'Bun' </span><span class="s1">: </span><span class="s0">'Node.js'</span><span class="s1">} </span><span class="s0">module is loaded ('</span><span class="s1">${importedModule}</span><span class="s0">' at line </span><span class="s1">${node.loc.start.line}</span><span class="s0">) which is not supported in the Edge Runtime. 
Learn More: https://nextjs.org/docs/messages/node-module-in-edge-runtime`</span><span class="s1">,</span>
                        <span class="s1">compilation,</span>
                        <span class="s1">parser,</span>
                        <span class="s1">...node</span>
                    <span class="s1">}));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s4">/**</span>
     <span class="s4">* A noop handler to skip analyzing some cases.</span>
     <span class="s4">* Order matters: for it to work, it must be registered first</span>
     <span class="s4">*/ </span><span class="s2">const </span><span class="s1">skip = ()=&gt;isInMiddlewareLayer(parser) ? </span><span class="s2">true </span><span class="s1">: undefined;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">prefix of [</span>
            <span class="s0">''</span><span class="s1">,</span>
            <span class="s0">'global.'</span>
        <span class="s1">]){</span>
            <span class="s1">hooks.expression.for(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">Function.prototype`</span><span class="s1">).tap(NAME, skip);</span>
            <span class="s1">hooks.expression.for(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">Function.bind`</span><span class="s1">).tap(NAME, skip);</span>
            <span class="s1">hooks.call.for(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">eval`</span><span class="s1">).tap(NAME, handleWrapExpression);</span>
            <span class="s1">hooks.call.for(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">Function`</span><span class="s1">).tap(NAME, handleWrapExpression);</span>
            <span class="s1">hooks.new.for(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">Function`</span><span class="s1">).tap(NAME, handleWrapExpression);</span>
            <span class="s1">hooks.call.for(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">WebAssembly.compile`</span><span class="s1">).tap(NAME, handleWrapWasmCompileExpression);</span>
            <span class="s1">hooks.call.for(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">WebAssembly.instantiate`</span><span class="s1">).tap(NAME, handleWrapWasmInstantiateExpression);</span>
        <span class="s1">}</span>
        <span class="s1">hooks.importCall.tap(NAME, handleImport);</span>
        <span class="s1">hooks.import.tap(NAME, handleImport);</span>
        <span class="s2">if </span><span class="s1">(!dev) {</span>
            <span class="s4">// do not issue compilation warning on dev: invoking code will provide details</span>
            <span class="s1">registerUnsupportedApiHooks(parser, compilation);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">codeAnalyzerBySwc(compilation, modules, dev) {</span>
    <span class="s2">const </span><span class="s1">binding = require(</span><span class="s0">'../../swc'</span><span class="s1">);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module1 of modules){</span>
        <span class="s2">if </span><span class="s1">(module1.layer !== _constants1.WEBPACK_LAYERS.middleware &amp;&amp; module1.layer !== _constants1.WEBPACK_LAYERS.apiEdge) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(module1.constructor.name !== </span><span class="s0">'NormalModule'</span><span class="s1">) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">normalModule = module1;</span>
        <span class="s2">if </span><span class="s1">(!normalModule.type.startsWith(</span><span class="s0">'javascript'</span><span class="s1">)) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">originalSource = normalModule.originalSource();</span>
        <span class="s2">if </span><span class="s1">(!originalSource) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">source = originalSource.source();</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">source !== </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">diagnostics = </span><span class="s2">await </span><span class="s1">binding.warnForEdgeRuntime(source, !dev);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">diagnostic of diagnostics){</span>
            <span class="s2">const </span><span class="s1">webpackError = buildWebpackError({</span>
                <span class="s1">message: diagnostic.message,</span>
                <span class="s1">loc: diagnostic.loc,</span>
                <span class="s1">compilation,</span>
                <span class="s1">entryModule: module1</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(diagnostic.severity === </span><span class="s0">'Warning'</span><span class="s1">) {</span>
                <span class="s1">compilation.warnings.push(webpackError);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">compilation.errors.push(webpackError);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getExtractMetadata(params) {</span>
    <span class="s2">const </span><span class="s1">{ dev, compilation, metadataByEntry, compiler } = params;</span>
    <span class="s2">const </span><span class="s1">{ webpack: wp } = compiler;</span>
    <span class="s2">return </span><span class="s1">async ()=&gt;{</span>
        <span class="s1">metadataByEntry.clear();</span>
        <span class="s2">const </span><span class="s1">telemetry = _shared.traceGlobals.get(</span><span class="s0">'telemetry'</span><span class="s1">);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[entryName, entry] of compilation.entries){</span>
            <span class="s2">var </span><span class="s1">_entry_dependencies, _route_middlewareConfig;</span>
            <span class="s2">if </span><span class="s1">(entry.options.runtime !== _constants.EDGE_RUNTIME_WEBPACK) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">entryDependency = (_entry_dependencies = entry.dependencies) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _entry_dependencies[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s2">const </span><span class="s1">resolvedModule = compilation.moduleGraph.getResolvedModule(entryDependency);</span>
            <span class="s2">if </span><span class="s1">(!resolvedModule) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ rootDir, route } = (</span><span class="s3">0</span><span class="s1">, _getmodulebuildinfo.getModuleBuildInfo)(resolvedModule);</span>
            <span class="s2">const </span><span class="s1">{ moduleGraph } = compilation;</span>
            <span class="s2">const </span><span class="s1">modules = </span><span class="s2">new </span><span class="s1">Set();</span>
            <span class="s2">const </span><span class="s1">addEntriesFromDependency = (dependency)=&gt;{</span>
                <span class="s2">const </span><span class="s1">module1 = moduleGraph.getModule(dependency);</span>
                <span class="s2">if </span><span class="s1">(module1) {</span>
                    <span class="s1">modules.add(module1);</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
            <span class="s1">entry.dependencies.forEach(addEntriesFromDependency);</span>
            <span class="s1">entry.includeDependencies.forEach(addEntriesFromDependency);</span>
            <span class="s2">const </span><span class="s1">entryMetadata = {</span>
                <span class="s1">wasmBindings: </span><span class="s2">new </span><span class="s1">Map(),</span>
                <span class="s1">assetBindings: </span><span class="s2">new </span><span class="s1">Map()</span>
            <span class="s1">};</span>
            <span class="s2">if </span><span class="s1">(route == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_route_middlewareConfig = route.middlewareConfig) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _route_middlewareConfig.regions) {</span>
                <span class="s1">entryMetadata.regions = route.middlewareConfig.regions;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(route == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: route.preferredRegion) {</span>
                <span class="s2">const </span><span class="s1">preferredRegion = route.preferredRegion;</span>
                <span class="s1">entryMetadata.regions = </span><span class="s4">// Ensures preferredRegion is always an array in the manifest.</span>
                <span class="s2">typeof </span><span class="s1">preferredRegion === </span><span class="s0">'string' </span><span class="s1">? [</span>
                    <span class="s1">preferredRegion</span>
                <span class="s1">] : preferredRegion;</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">ogImageGenerationCount = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module1 of modules){</span>
                <span class="s2">const </span><span class="s1">buildInfo = (</span><span class="s3">0</span><span class="s1">, _getmodulebuildinfo.getModuleBuildInfo)(module1);</span>
                <span class="s4">/**</span>
         <span class="s4">* Check if it uses the image generation feature.</span>
         <span class="s4">*/ </span><span class="s2">if </span><span class="s1">(!dev) {</span>
                    <span class="s2">const </span><span class="s1">resource = module1.resource;</span>
                    <span class="s2">const </span><span class="s1">hasOGImageGeneration = resource &amp;&amp; </span><span class="s5">/[\\/]node_modules[\\/]@vercel[\\/]og[\\/]dist[\\/]index\.(edge|node)\.js$|[\\/]next[\\/]dist[\\/](esm[\\/])?server[\\/]og[\\/]image-response\.js$/</span><span class="s1">.test(resource);</span>
                    <span class="s2">if </span><span class="s1">(hasOGImageGeneration) {</span>
                        <span class="s1">ogImageGenerationCount++;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">/**</span>
         <span class="s4">* When building for production checks if the module is using `eval`</span>
         <span class="s4">* and in such case produces a compilation error. The module has to</span>
         <span class="s4">* be in use.</span>
         <span class="s4">*/ </span><span class="s2">if </span><span class="s1">(!dev &amp;&amp; buildInfo.usingIndirectEval &amp;&amp; isUsingIndirectEvalAndUsedByExports({</span>
                    <span class="s1">module: module1,</span>
                    <span class="s1">moduleGraph,</span>
                    <span class="s1">runtime: wp.util.runtime.getEntryRuntime(compilation, entryName),</span>
                    <span class="s1">usingIndirectEval: buildInfo.usingIndirectEval,</span>
                    <span class="s1">wp</span>
                <span class="s1">})) {</span>
                    <span class="s2">var </span><span class="s1">_route_middlewareConfig1;</span>
                    <span class="s2">const </span><span class="s1">id = module1.identifier();</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s5">/node_modules[\\/]regenerator-runtime[\\/]runtime\.js/</span><span class="s1">.test(id)) {</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(route == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_route_middlewareConfig1 = route.middlewareConfig) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _route_middlewareConfig1.unstable_allowDynamic) {</span>
                        <span class="s1">telemetry == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: telemetry.record({</span>
                            <span class="s1">eventName: </span><span class="s0">'NEXT_EDGE_ALLOW_DYNAMIC_USED'</span><span class="s1">,</span>
                            <span class="s1">payload: {</span>
                                <span class="s1">file: route == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: route.absolutePagePath.replace(rootDir ?? </span><span class="s0">''</span><span class="s1">, </span><span class="s0">''</span><span class="s1">),</span>
                                <span class="s1">config: route == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: route.middlewareConfig,</span>
                                <span class="s1">fileWithDynamicCode: module1.userRequest.replace(rootDir ?? </span><span class="s0">''</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!isDynamicCodeEvaluationAllowed(module1.userRequest, route == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: route.middlewareConfig, rootDir)) {</span>
                        <span class="s2">const </span><span class="s1">message = </span><span class="s0">`Dynamic Code Evaluation (e. g. 'eval', 'new Function', 'WebAssembly.compile') not allowed in Edge Runtime </span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">buildInfo.usingIndirectEval !== </span><span class="s0">'boolean' </span><span class="s1">? </span><span class="s0">`</span><span class="s6">\n</span><span class="s0">Used by </span><span class="s1">${Array.from(buildInfo.usingIndirectEval).join(</span><span class="s0">', '</span><span class="s1">)}</span><span class="s0">` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}</span><span class="s6">\n</span><span class="s0">Learn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`</span><span class="s1">;</span>
                        <span class="s1">compilation.errors.push((</span><span class="s3">0</span><span class="s1">, _parsedynamiccodeevaluationerror.getDynamicCodeEvaluationError)(message, module1, compilation, compiler));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">/**</span>
         <span class="s4">* The entry module has to be either a page or a middleware and hold</span>
         <span class="s4">* the corresponding metadata.</span>
         <span class="s4">*/ </span><span class="s2">if </span><span class="s1">(buildInfo == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: buildInfo.nextEdgeSSR) {</span>
                    <span class="s1">entryMetadata.edgeSSR = buildInfo.nextEdgeSSR;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(buildInfo == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: buildInfo.nextEdgeMiddleware) {</span>
                    <span class="s1">entryMetadata.edgeMiddleware = buildInfo.nextEdgeMiddleware;</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(buildInfo == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: buildInfo.nextEdgeApiFunction) {</span>
                    <span class="s1">entryMetadata.edgeApiFunction = buildInfo.nextEdgeApiFunction;</span>
                <span class="s1">}</span>
                <span class="s4">/**</span>
         <span class="s4">* If the module is a WASM module we read the binding information and</span>
         <span class="s4">* append it to the entry wasm bindings.</span>
         <span class="s4">*/ </span><span class="s2">if </span><span class="s1">(buildInfo == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: buildInfo.nextWasmMiddlewareBinding) {</span>
                    <span class="s1">entryMetadata.wasmBindings.set(buildInfo.nextWasmMiddlewareBinding.name, buildInfo.nextWasmMiddlewareBinding.filePath);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(buildInfo == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: buildInfo.nextAssetMiddlewareBinding) {</span>
                    <span class="s1">entryMetadata.assetBindings.set(buildInfo.nextAssetMiddlewareBinding.name, buildInfo.nextAssetMiddlewareBinding.filePath);</span>
                <span class="s1">}</span>
                <span class="s4">/**</span>
         <span class="s4">* Append to the list of modules to process outgoingConnections from</span>
         <span class="s4">* the module that is being processed.</span>
         <span class="s4">*/ </span><span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">conn of (</span><span class="s3">0</span><span class="s1">, _utils1.getModuleReferencesInOrder)(module1, moduleGraph)){</span>
                    <span class="s2">if </span><span class="s1">(conn.module) {</span>
                        <span class="s1">modules.add(conn.module);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">telemetry == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: telemetry.record({</span>
                <span class="s1">eventName: _events.EVENT_BUILD_FEATURE_USAGE,</span>
                <span class="s1">payload: {</span>
                    <span class="s1">featureName: </span><span class="s0">'vercelImageGeneration'</span><span class="s1">,</span>
                    <span class="s1">invocationCount: ogImageGenerationCount</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s1">metadataByEntry.set(entryName, entryMetadata);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">MiddlewarePlugin {</span>
    <span class="s1">constructor({ dev, sriEnabled, rewrites, edgeEnvironments }){</span>
        <span class="s2">this</span><span class="s1">.dev = dev;</span>
        <span class="s2">this</span><span class="s1">.sriEnabled = sriEnabled;</span>
        <span class="s2">this</span><span class="s1">.rewrites = rewrites;</span>
        <span class="s2">this</span><span class="s1">.edgeEnvironments = edgeEnvironments;</span>
    <span class="s1">}</span>
    <span class="s1">apply(compiler) {</span>
        <span class="s1">compiler.hooks.compilation.tap(NAME, (compilation, params)=&gt;{</span>
            <span class="s4">// parser hooks aren't available in rspack</span>
            <span class="s2">if </span><span class="s1">(process.env.NEXT_RSPACK) {</span>
                <span class="s1">compilation.hooks.finishModules.tapPromise(NAME, async (modules)=&gt;{</span>
                    <span class="s2">await </span><span class="s1">codeAnalyzerBySwc(compilation, modules, </span><span class="s2">this</span><span class="s1">.dev);</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">{ hooks } = params.normalModuleFactory;</span>
                <span class="s4">/**</span>
         <span class="s4">* This is the static code analysis phase.</span>
         <span class="s4">*/ </span><span class="s2">const </span><span class="s1">codeAnalyzer = getCodeAnalyzer({</span>
                    <span class="s1">dev: </span><span class="s2">this</span><span class="s1">.dev,</span>
                    <span class="s1">compiler,</span>
                    <span class="s1">compilation</span>
                <span class="s1">});</span>
                <span class="s1">hooks.parser.for(</span><span class="s0">'javascript/auto'</span><span class="s1">).tap(NAME, codeAnalyzer);</span>
                <span class="s1">hooks.parser.for(</span><span class="s0">'javascript/dynamic'</span><span class="s1">).tap(NAME, codeAnalyzer);</span>
                <span class="s1">hooks.parser.for(</span><span class="s0">'javascript/esm'</span><span class="s1">).tap(NAME, codeAnalyzer);</span>
            <span class="s1">}</span>
            <span class="s4">/**</span>
       <span class="s4">* Extract all metadata for the entry points in a Map object.</span>
       <span class="s4">*/ </span><span class="s2">const </span><span class="s1">metadataByEntry = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s1">compilation.hooks.finishModules.tapPromise(NAME, getExtractMetadata({</span>
                <span class="s1">compilation,</span>
                <span class="s1">compiler,</span>
                <span class="s1">dev: </span><span class="s2">this</span><span class="s1">.dev,</span>
                <span class="s1">metadataByEntry</span>
            <span class="s1">}));</span>
            <span class="s4">/**</span>
       <span class="s4">* Emit the middleware manifest.</span>
       <span class="s4">*/ </span><span class="s1">compilation.hooks.processAssets.tap({</span>
                <span class="s1">name: </span><span class="s0">'NextJsMiddlewareManifest'</span><span class="s1">,</span>
                <span class="s1">stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS</span>
            <span class="s1">}, getCreateAssets({</span>
                <span class="s1">compilation,</span>
                <span class="s1">metadataByEntry,</span>
                <span class="s1">opts: {</span>
                    <span class="s1">sriEnabled: </span><span class="s2">this</span><span class="s1">.sriEnabled,</span>
                    <span class="s1">rewrites: </span><span class="s2">this</span><span class="s1">.rewrites,</span>
                    <span class="s1">edgeEnvironments: </span><span class="s2">this</span><span class="s1">.edgeEnvironments,</span>
                    <span class="s1">dev: </span><span class="s2">this</span><span class="s1">.dev</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">SUPPORTED_NATIVE_MODULES = [</span>
    <span class="s0">'buffer'</span><span class="s1">,</span>
    <span class="s0">'events'</span><span class="s1">,</span>
    <span class="s0">'assert'</span><span class="s1">,</span>
    <span class="s0">'util'</span><span class="s1">,</span>
    <span class="s0">'async_hooks'</span>
<span class="s1">];</span>
<span class="s2">const </span><span class="s1">supportedEdgePolyfills = </span><span class="s2">new </span><span class="s1">Set(SUPPORTED_NATIVE_MODULES);</span>
<span class="s2">function </span><span class="s1">getEdgePolyfilledModules() {</span>
    <span class="s2">const </span><span class="s1">records = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">mod of SUPPORTED_NATIVE_MODULES){</span>
        <span class="s1">records[mod] = </span><span class="s0">`commonjs node:</span><span class="s1">${mod}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">records[</span><span class="s0">`node:</span><span class="s1">${mod}</span><span class="s0">`</span><span class="s1">] = </span><span class="s0">`commonjs node:</span><span class="s1">${mod}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">records;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">handleWebpackExternalForEdgeRuntime({ request, context, contextInfo, getResolve }) {</span>
    <span class="s2">if </span><span class="s1">((contextInfo.issuerLayer === _constants1.WEBPACK_LAYERS.middleware || contextInfo.issuerLayer === _constants1.WEBPACK_LAYERS.apiEdge) &amp;&amp; (isNodeJsModule(request) || isBunModule(request)) &amp;&amp; !supportedEdgePolyfills.has(request)) {</span>
        <span class="s4">// allows user to provide and use their polyfills, as we do with buffer.</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">await </span><span class="s1">getResolve()(context, request);</span>
        <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s0">`root globalThis.__import_unsupported('</span><span class="s1">${request}</span><span class="s0">')`</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=middleware-plugin.js.map</span></pre>
</body>
</html>