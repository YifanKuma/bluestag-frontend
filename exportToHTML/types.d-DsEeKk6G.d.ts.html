<html>
<head>
<title>types.d-DsEeKk6G.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
types.d-DsEeKk6G.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/// &lt;reference types=&quot;react&quot; /&gt;</span>
<span class="s2">import </span><span class="s1">* as motion_dom from </span><span class="s3">'motion-dom'</span><span class="s1">;</span>
<span class="s2">import </span><span class="s1">{ Transition, TransformProperties, MotionNodeOptions, MotionValue, SVGPathProperties, JSAnimation, ValueTransition, TargetAndTransition, AnyResolvedKeyframe, KeyframeResolver, AnimationDefinition, Batcher } from </span><span class="s3">'motion-dom'</span><span class="s1">;</span>
<span class="s2">import </span><span class="s1">{ TransformPoint, Box, Delta, Point, Axis } from </span><span class="s3">'motion-utils'</span><span class="s1">;</span>
<span class="s2">import </span><span class="s1">* as React$1 from </span><span class="s3">'react'</span><span class="s1">;</span>
<span class="s2">import </span><span class="s1">{ CSSProperties, PropsWithoutRef, RefAttributes, JSX, SVGAttributes } from </span><span class="s3">'react'</span><span class="s1">;</span>

<span class="s1">type ReducedMotionConfig = </span><span class="s3">&quot;always&quot; </span><span class="s1">| </span><span class="s3">&quot;never&quot; </span><span class="s1">| </span><span class="s3">&quot;user&quot;</span><span class="s1">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">MotionConfigContext {</span>
    <span class="s0">/**</span>
     <span class="s0">* Internal, exported only for usage in Framer</span>
     <span class="s0">*/</span>
    <span class="s1">transformPagePoint: TransformPoint;</span>
    <span class="s0">/**</span>
     <span class="s0">* Internal. Determines whether this is a static context ie the Framer canvas. If so,</span>
     <span class="s0">* it'll disable all dynamic functionality.</span>
     <span class="s0">*/</span>
    <span class="s1">isStatic: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Defines a new default transition for the entire tree.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@public</span>
     <span class="s0">*/</span>
    <span class="s1">transition?: Transition;</span>
    <span class="s0">/**</span>
     <span class="s0">* If true, will respect the device prefersReducedMotion setting by switching</span>
     <span class="s0">* transform animations off.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@public</span>
     <span class="s0">*/</span>
    <span class="s1">reducedMotion?: ReducedMotionConfig;</span>
    <span class="s0">/**</span>
     <span class="s0">* A custom `nonce` attribute used when wanting to enforce a Content Security Policy (CSP).</span>
     <span class="s0">* For more details see:</span>
     <span class="s0">* https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src#unsafe_inline_styles</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@public</span>
     <span class="s0">*/</span>
    <span class="s1">nonce?: string;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s1">declare </span><span class="s2">const </span><span class="s1">MotionConfigContext: React$1.Context&lt;MotionConfigContext&gt;;</span>

<span class="s0">/**</span>
 <span class="s0">* Either a string, or array of strings, that reference variants defined via the `variants` prop.</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s1">type VariantLabels = string | string[];</span>

<span class="s1">type MotionValueString = MotionValue&lt;string&gt;;</span>
<span class="s1">type MotionValueNumber = MotionValue&lt;number&gt;;</span>
<span class="s1">type MotionValueAny = MotionValue&lt;any&gt;;</span>
<span class="s1">type AnyMotionValue = MotionValueNumber | MotionValueString | MotionValueAny;</span>
<span class="s1">type MotionValueHelper&lt;T&gt; = T | AnyMotionValue;</span>
<span class="s1">type MakeMotionHelper&lt;T&gt; = {</span>
    <span class="s1">[K </span><span class="s2">in </span><span class="s1">keyof T]: MotionValueHelper&lt;T[K]&gt;;</span>
<span class="s1">};</span>
<span class="s1">type MakeCustomValueTypeHelper&lt;T&gt; = MakeMotionHelper&lt;T&gt;;</span>
<span class="s1">type MakeMotion&lt;T&gt; = MakeCustomValueTypeHelper&lt;T&gt;;</span>
<span class="s1">type MotionCSS = MakeMotion&lt;Omit&lt;CSSProperties, </span><span class="s3">&quot;rotate&quot; </span><span class="s1">| </span><span class="s3">&quot;scale&quot; </span><span class="s1">| </span><span class="s3">&quot;perspective&quot;</span><span class="s1">&gt;&gt;;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s1">type MotionTransform = MakeMotion&lt;TransformProperties&gt;;</span>
<span class="s1">type MotionSVGProps = MakeMotion&lt;SVGPathProperties&gt;;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">MotionStyle </span><span class="s2">extends </span><span class="s1">MotionCSS, MotionTransform, MotionSVGProps {</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Props for `motion` components.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">MotionProps </span><span class="s2">extends </span><span class="s1">MotionNodeOptions {</span>
    <span class="s0">/**</span>
     <span class="s0">*</span>
     <span class="s0">* The React DOM `style` prop, enhanced with support for `MotionValue`s and separate `transform` values.</span>
     <span class="s0">*</span>
     <span class="s0">* ```jsx</span>
     <span class="s0">* export const MyComponent = () =&gt; {</span>
     <span class="s0">*   const x = useMotionValue(0)</span>
     <span class="s0">*</span>
     <span class="s0">*   return &lt;motion.div style={{ x, opacity: 1, scale: 0.5 }} /&gt;</span>
     <span class="s0">* }</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">style?: MotionStyle;</span>
    <span class="s1">children?: React.ReactNode | MotionValueNumber | MotionValueString;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">PresenceContextProps {</span>
    <span class="s1">id: string;</span>
    <span class="s1">isPresent: boolean;</span>
    <span class="s1">register: (id: string | number) =&gt; () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">onExitComplete?: (id: string | number) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">initial?: </span><span class="s2">false </span><span class="s1">| VariantLabels;</span>
    <span class="s1">custom?: any;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s1">declare </span><span class="s2">const </span><span class="s1">PresenceContext: React$1.Context&lt;PresenceContextProps | </span><span class="s2">null</span><span class="s1">&gt;;</span>

<span class="s2">interface </span><span class="s1">VisualState&lt;Instance, RenderState&gt; {</span>
    <span class="s1">renderState: RenderState;</span>
    <span class="s1">latestValues: ResolvedValues;</span>
    <span class="s1">onMount?: (instance: Instance) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">type UseVisualState&lt;Instance, RenderState&gt; = (props: MotionProps, isStatic: boolean) =&gt; VisualState&lt;Instance, RenderState&gt;;</span>
<span class="s2">interface </span><span class="s1">UseVisualStateConfig&lt;RenderState&gt; {</span>
    <span class="s1">scrapeMotionValuesFromProps: ScrapeMotionValuesFromProps;</span>
    <span class="s1">createRenderState: () =&gt; RenderState;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">const </span><span class="s1">makeUseVisualState: &lt;I, RS&gt;(config: UseVisualStateConfig&lt;RS&gt;) =&gt; UseVisualState&lt;I, RS&gt;;</span>

<span class="s2">interface </span><span class="s1">HTMLElements {</span>
    <span class="s1">a: HTMLAnchorElement;</span>
    <span class="s1">abbr: HTMLElement;</span>
    <span class="s1">address: HTMLElement;</span>
    <span class="s1">area: HTMLAreaElement;</span>
    <span class="s1">article: HTMLElement;</span>
    <span class="s1">aside: HTMLElement;</span>
    <span class="s1">audio: HTMLAudioElement;</span>
    <span class="s1">b: HTMLElement;</span>
    <span class="s1">base: HTMLBaseElement;</span>
    <span class="s1">bdi: HTMLElement;</span>
    <span class="s1">bdo: HTMLElement;</span>
    <span class="s1">big: HTMLElement;</span>
    <span class="s1">blockquote: HTMLQuoteElement;</span>
    <span class="s1">body: HTMLBodyElement;</span>
    <span class="s1">br: HTMLBRElement;</span>
    <span class="s1">button: HTMLButtonElement;</span>
    <span class="s1">canvas: HTMLCanvasElement;</span>
    <span class="s1">caption: HTMLElement;</span>
    <span class="s1">center: HTMLElement;</span>
    <span class="s1">cite: HTMLElement;</span>
    <span class="s1">code: HTMLElement;</span>
    <span class="s1">col: HTMLTableColElement;</span>
    <span class="s1">colgroup: HTMLTableColElement;</span>
    <span class="s1">data: HTMLDataElement;</span>
    <span class="s1">datalist: HTMLDataListElement;</span>
    <span class="s1">dd: HTMLElement;</span>
    <span class="s1">del: HTMLModElement;</span>
    <span class="s1">details: HTMLDetailsElement;</span>
    <span class="s1">dfn: HTMLElement;</span>
    <span class="s1">dialog: HTMLDialogElement;</span>
    <span class="s1">div: HTMLDivElement;</span>
    <span class="s1">dl: HTMLDListElement;</span>
    <span class="s1">dt: HTMLElement;</span>
    <span class="s1">em: HTMLElement;</span>
    <span class="s1">embed: HTMLEmbedElement;</span>
    <span class="s1">fieldset: HTMLFieldSetElement;</span>
    <span class="s1">figcaption: HTMLElement;</span>
    <span class="s1">figure: HTMLElement;</span>
    <span class="s1">footer: HTMLElement;</span>
    <span class="s1">form: HTMLFormElement;</span>
    <span class="s1">h1: HTMLHeadingElement;</span>
    <span class="s1">h2: HTMLHeadingElement;</span>
    <span class="s1">h3: HTMLHeadingElement;</span>
    <span class="s1">h4: HTMLHeadingElement;</span>
    <span class="s1">h5: HTMLHeadingElement;</span>
    <span class="s1">h6: HTMLHeadingElement;</span>
    <span class="s1">head: HTMLHeadElement;</span>
    <span class="s1">header: HTMLElement;</span>
    <span class="s1">hgroup: HTMLElement;</span>
    <span class="s1">hr: HTMLHRElement;</span>
    <span class="s1">html: HTMLHtmlElement;</span>
    <span class="s1">i: HTMLElement;</span>
    <span class="s1">iframe: HTMLIFrameElement;</span>
    <span class="s1">img: HTMLImageElement;</span>
    <span class="s1">input: HTMLInputElement;</span>
    <span class="s1">ins: HTMLModElement;</span>
    <span class="s1">kbd: HTMLElement;</span>
    <span class="s1">keygen: HTMLElement;</span>
    <span class="s1">label: HTMLLabelElement;</span>
    <span class="s1">legend: HTMLLegendElement;</span>
    <span class="s1">li: HTMLLIElement;</span>
    <span class="s1">link: HTMLLinkElement;</span>
    <span class="s1">main: HTMLElement;</span>
    <span class="s1">map: HTMLMapElement;</span>
    <span class="s1">mark: HTMLElement;</span>
    <span class="s1">menu: HTMLElement;</span>
    <span class="s1">menuitem: HTMLElement;</span>
    <span class="s1">meta: HTMLMetaElement;</span>
    <span class="s1">meter: HTMLMeterElement;</span>
    <span class="s1">nav: HTMLElement;</span>
    <span class="s1">noindex: HTMLElement;</span>
    <span class="s1">noscript: HTMLElement;</span>
    <span class="s1">object: HTMLObjectElement;</span>
    <span class="s1">ol: HTMLOListElement;</span>
    <span class="s1">optgroup: HTMLOptGroupElement;</span>
    <span class="s1">option: HTMLOptionElement;</span>
    <span class="s1">output: HTMLOutputElement;</span>
    <span class="s1">p: HTMLParagraphElement;</span>
    <span class="s1">param: HTMLParamElement;</span>
    <span class="s1">picture: HTMLElement;</span>
    <span class="s1">pre: HTMLPreElement;</span>
    <span class="s1">progress: HTMLProgressElement;</span>
    <span class="s1">q: HTMLQuoteElement;</span>
    <span class="s1">rp: HTMLElement;</span>
    <span class="s1">rt: HTMLElement;</span>
    <span class="s1">ruby: HTMLElement;</span>
    <span class="s1">s: HTMLElement;</span>
    <span class="s1">samp: HTMLElement;</span>
    <span class="s1">search: HTMLElement;</span>
    <span class="s1">slot: HTMLSlotElement;</span>
    <span class="s1">script: HTMLScriptElement;</span>
    <span class="s1">section: HTMLElement;</span>
    <span class="s1">select: HTMLSelectElement;</span>
    <span class="s1">small: HTMLElement;</span>
    <span class="s1">source: HTMLSourceElement;</span>
    <span class="s1">span: HTMLSpanElement;</span>
    <span class="s1">strong: HTMLElement;</span>
    <span class="s1">style: HTMLStyleElement;</span>
    <span class="s1">sub: HTMLElement;</span>
    <span class="s1">summary: HTMLElement;</span>
    <span class="s1">sup: HTMLElement;</span>
    <span class="s1">table: HTMLTableElement;</span>
    <span class="s1">template: HTMLTemplateElement;</span>
    <span class="s1">tbody: HTMLTableSectionElement;</span>
    <span class="s1">td: HTMLTableDataCellElement;</span>
    <span class="s1">textarea: HTMLTextAreaElement;</span>
    <span class="s1">tfoot: HTMLTableSectionElement;</span>
    <span class="s1">th: HTMLTableHeaderCellElement;</span>
    <span class="s1">thead: HTMLTableSectionElement;</span>
    <span class="s1">time: HTMLTimeElement;</span>
    <span class="s1">title: HTMLTitleElement;</span>
    <span class="s1">tr: HTMLTableRowElement;</span>
    <span class="s1">track: HTMLTrackElement;</span>
    <span class="s1">u: HTMLElement;</span>
    <span class="s1">ul: HTMLUListElement;</span>
    <span class="s2">var</span><span class="s1">: HTMLElement;</span>
    <span class="s1">video: HTMLVideoElement;</span>
    <span class="s1">wbr: HTMLElement;</span>
    <span class="s1">webview: HTMLWebViewElement;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">TransformOrigin {</span>
    <span class="s1">originX?: number | string;</span>
    <span class="s1">originY?: number | string;</span>
    <span class="s1">originZ?: number | string;</span>
<span class="s1">}</span>
<span class="s2">interface </span><span class="s1">HTMLRenderState {</span>
    <span class="s0">/**</span>
     <span class="s0">* A mutable record of transforms we want to apply directly to the rendered Element</span>
     <span class="s0">* every frame. We use a mutable data structure to reduce GC during animations.</span>
     <span class="s0">*/</span>
    <span class="s1">transform: ResolvedValues;</span>
    <span class="s0">/**</span>
     <span class="s0">* A mutable record of transform origins we want to apply directly to the rendered Element</span>
     <span class="s0">* every frame. We use a mutable data structure to reduce GC during animations.</span>
     <span class="s0">*/</span>
    <span class="s1">transformOrigin: TransformOrigin;</span>
    <span class="s0">/**</span>
     <span class="s0">* A mutable record of styles we want to apply directly to the rendered Element</span>
     <span class="s0">* every frame. We use a mutable data structure to reduce GC during animations.</span>
     <span class="s0">*/</span>
    <span class="s1">style: ResolvedValues;</span>
    <span class="s0">/**</span>
     <span class="s0">* A mutable record of CSS variables we want to apply directly to the rendered Element</span>
     <span class="s0">* every frame. We use a mutable data structure to reduce GC during animations.</span>
     <span class="s0">*/</span>
    <span class="s1">vars: ResolvedValues;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s1">type ForwardRefComponent&lt;T, P&gt; = {</span>
    <span class="s1">readonly $$typeof: symbol;</span>
<span class="s1">} &amp; ((props: PropsWithoutRef&lt;P&gt; &amp; RefAttributes&lt;T&gt;) =&gt; JSX.Element);</span>
<span class="s1">type AttributesWithoutMotionProps&lt;Attributes&gt; = {</span>
    <span class="s1">[K </span><span class="s2">in </span><span class="s1">Exclude&lt;keyof Attributes, keyof MotionProps&gt;]?: Attributes[K];</span>
<span class="s1">};</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s1">type HTMLMotionProps&lt;Tag </span><span class="s2">extends </span><span class="s1">keyof HTMLElements&gt; = AttributesWithoutMotionProps&lt;JSX.IntrinsicElements[Tag]&gt; &amp; MotionProps;</span>
<span class="s0">/**</span>
 <span class="s0">* Motion-optimised versions of React's HTML components.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s1">type HTMLMotionComponents = {</span>
    <span class="s1">[K </span><span class="s2">in </span><span class="s1">keyof HTMLElements]: ForwardRefComponent&lt;HTMLElements[K], HTMLMotionProps&lt;K&gt;&gt;;</span>
<span class="s1">};</span>

<span class="s1">type UnionStringArray&lt;T </span><span class="s2">extends </span><span class="s1">Readonly&lt;string[]&gt;&gt; = T[number];</span>
<span class="s1">declare </span><span class="s2">const </span><span class="s1">svgElements: readonly [</span><span class="s3">&quot;animate&quot;</span><span class="s1">, </span><span class="s3">&quot;circle&quot;</span><span class="s1">, </span><span class="s3">&quot;defs&quot;</span><span class="s1">, </span><span class="s3">&quot;desc&quot;</span><span class="s1">, </span><span class="s3">&quot;ellipse&quot;</span><span class="s1">, </span><span class="s3">&quot;g&quot;</span><span class="s1">, </span><span class="s3">&quot;image&quot;</span><span class="s1">, </span><span class="s3">&quot;line&quot;</span><span class="s1">, </span><span class="s3">&quot;filter&quot;</span><span class="s1">, </span><span class="s3">&quot;marker&quot;</span><span class="s1">, </span><span class="s3">&quot;mask&quot;</span><span class="s1">, </span><span class="s3">&quot;metadata&quot;</span><span class="s1">, </span><span class="s3">&quot;path&quot;</span><span class="s1">, </span><span class="s3">&quot;pattern&quot;</span><span class="s1">, </span><span class="s3">&quot;polygon&quot;</span><span class="s1">, </span><span class="s3">&quot;polyline&quot;</span><span class="s1">, </span><span class="s3">&quot;rect&quot;</span><span class="s1">, </span><span class="s3">&quot;stop&quot;</span><span class="s1">, </span><span class="s3">&quot;svg&quot;</span><span class="s1">, </span><span class="s3">&quot;switch&quot;</span><span class="s1">, </span><span class="s3">&quot;symbol&quot;</span><span class="s1">, </span><span class="s3">&quot;text&quot;</span><span class="s1">, </span><span class="s3">&quot;tspan&quot;</span><span class="s1">, </span><span class="s3">&quot;use&quot;</span><span class="s1">, </span><span class="s3">&quot;view&quot;</span><span class="s1">, </span><span class="s3">&quot;clipPath&quot;</span><span class="s1">, </span><span class="s3">&quot;feBlend&quot;</span><span class="s1">, </span><span class="s3">&quot;feColorMatrix&quot;</span><span class="s1">, </span><span class="s3">&quot;feComponentTransfer&quot;</span><span class="s1">, </span><span class="s3">&quot;feComposite&quot;</span><span class="s1">, </span><span class="s3">&quot;feConvolveMatrix&quot;</span><span class="s1">, </span><span class="s3">&quot;feDiffuseLighting&quot;</span><span class="s1">, </span><span class="s3">&quot;feDisplacementMap&quot;</span><span class="s1">, </span><span class="s3">&quot;feDistantLight&quot;</span><span class="s1">, </span><span class="s3">&quot;feDropShadow&quot;</span><span class="s1">, </span><span class="s3">&quot;feFlood&quot;</span><span class="s1">, </span><span class="s3">&quot;feFuncA&quot;</span><span class="s1">, </span><span class="s3">&quot;feFuncB&quot;</span><span class="s1">, </span><span class="s3">&quot;feFuncG&quot;</span><span class="s1">, </span><span class="s3">&quot;feFuncR&quot;</span><span class="s1">, </span><span class="s3">&quot;feGaussianBlur&quot;</span><span class="s1">, </span><span class="s3">&quot;feImage&quot;</span><span class="s1">, </span><span class="s3">&quot;feMerge&quot;</span><span class="s1">, </span><span class="s3">&quot;feMergeNode&quot;</span><span class="s1">, </span><span class="s3">&quot;feMorphology&quot;</span><span class="s1">, </span><span class="s3">&quot;feOffset&quot;</span><span class="s1">, </span><span class="s3">&quot;fePointLight&quot;</span><span class="s1">, </span><span class="s3">&quot;feSpecularLighting&quot;</span><span class="s1">, </span><span class="s3">&quot;feSpotLight&quot;</span><span class="s1">, </span><span class="s3">&quot;feTile&quot;</span><span class="s1">, </span><span class="s3">&quot;feTurbulence&quot;</span><span class="s1">, </span><span class="s3">&quot;foreignObject&quot;</span><span class="s1">, </span><span class="s3">&quot;linearGradient&quot;</span><span class="s1">, </span><span class="s3">&quot;radialGradient&quot;</span><span class="s1">, </span><span class="s3">&quot;textPath&quot;</span><span class="s1">];</span>
<span class="s1">type SVGElements = UnionStringArray&lt;</span><span class="s2">typeof </span><span class="s1">svgElements&gt;;</span>

<span class="s2">interface </span><span class="s1">SVGAttributesWithoutMotionProps&lt;T&gt; </span><span class="s2">extends </span><span class="s1">Pick&lt;SVGAttributes&lt;T&gt;, Exclude&lt;keyof SVGAttributes&lt;T&gt;, keyof MotionProps&gt;&gt; {</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Blanket-accept any SVG attribute as a `MotionValue`</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s1">type SVGAttributesAsMotionValues&lt;T&gt; = MakeMotion&lt;SVGAttributesWithoutMotionProps&lt;T&gt;&gt;;</span>
<span class="s1">type UnwrapSVGFactoryElement&lt;F&gt; = F </span><span class="s2">extends </span><span class="s1">React.SVGProps&lt;infer P&gt; ? P : never;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">SVGMotionProps&lt;T&gt; </span><span class="s2">extends </span><span class="s1">SVGAttributesAsMotionValues&lt;T&gt;, MotionProps {</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Motion-optimised versions of React's SVG components.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s4">@public</span>
 <span class="s0">*/</span>
<span class="s1">type SVGMotionComponents = {</span>
    <span class="s1">[K </span><span class="s2">in </span><span class="s1">SVGElements]: ForwardRefComponent&lt;UnwrapSVGFactoryElement&lt;JSX.IntrinsicElements[K]&gt;, SVGMotionProps&lt;UnwrapSVGFactoryElement&lt;JSX.IntrinsicElements[K]&gt;&gt;&gt;;</span>
<span class="s1">};</span>

<span class="s1">type DOMMotionComponents = HTMLMotionComponents &amp; SVGMotionComponents;</span>

<span class="s2">interface </span><span class="s1">SwitchLayoutGroup {</span>
    <span class="s1">register?: (member: IProjectionNode) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">deregister?: (member: IProjectionNode) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">type InitialPromotionConfig = {</span>
    <span class="s0">/**</span>
     <span class="s0">* The initial transition to use when the elements in this group mount (and automatically promoted).</span>
     <span class="s0">* Subsequent updates should provide a transition in the promote method.</span>
     <span class="s0">*/</span>
    <span class="s1">transition?: Transition;</span>
    <span class="s0">/**</span>
     <span class="s0">* If the follow tree should preserve its opacity when the lead is promoted on mount</span>
     <span class="s0">*/</span>
    <span class="s1">shouldPreserveFollowOpacity?: (member: IProjectionNode) =&gt; boolean;</span>
<span class="s1">};</span>
<span class="s1">type SwitchLayoutGroupContext = SwitchLayoutGroup &amp; InitialPromotionConfig;</span>
<span class="s0">/**</span>
 <span class="s0">* Internal, exported only for usage in Framer</span>
 <span class="s0">*/</span>
<span class="s1">declare </span><span class="s2">const </span><span class="s1">SwitchLayoutGroupContext: React$1.Context&lt;SwitchLayoutGroupContext&gt;;</span>

<span class="s2">interface </span><span class="s1">WithDepth {</span>
    <span class="s1">depth: number;</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s2">class </span><span class="s1">FlatTree {</span>
    <span class="s2">private </span><span class="s1">children;</span>
    <span class="s2">private </span><span class="s1">isDirty;</span>
    <span class="s1">add(child: WithDepth): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">remove(child: WithDepth): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">forEach(callback: (child: WithDepth) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s2">class </span><span class="s1">NodeStack {</span>
    <span class="s1">lead?: IProjectionNode;</span>
    <span class="s1">prevLead?: IProjectionNode;</span>
    <span class="s1">members: IProjectionNode[];</span>
    <span class="s1">add(node: IProjectionNode): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">remove(node: IProjectionNode): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">relegate(node: IProjectionNode): boolean;</span>
    <span class="s1">promote(node: IProjectionNode, preserveFollowOpacity?: boolean): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">exitAnimationComplete(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">scheduleRender(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Clear any leads that have been removed this render to prevent them from being</span>
     <span class="s0">* used in future animations and to prevent memory leaks</span>
     <span class="s0">*/</span>
    <span class="s1">removeLeadSnapshot(): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Measurements {</span>
    <span class="s1">animationId: number;</span>
    <span class="s1">measuredBox: Box;</span>
    <span class="s1">layoutBox: Box;</span>
    <span class="s1">latestValues: ResolvedValues;</span>
    <span class="s1">source: number;</span>
<span class="s1">}</span>
<span class="s1">type Phase = </span><span class="s3">&quot;snapshot&quot; </span><span class="s1">| </span><span class="s3">&quot;measure&quot;</span><span class="s1">;</span>
<span class="s2">interface </span><span class="s1">ScrollMeasurements {</span>
    <span class="s1">animationId: number;</span>
    <span class="s1">phase: Phase;</span>
    <span class="s1">offset: Point;</span>
    <span class="s1">isRoot: boolean;</span>
    <span class="s1">wasRoot: boolean;</span>
<span class="s1">}</span>
<span class="s1">type LayoutEvents = </span><span class="s3">&quot;willUpdate&quot; </span><span class="s1">| </span><span class="s3">&quot;didUpdate&quot; </span><span class="s1">| </span><span class="s3">&quot;beforeMeasure&quot; </span><span class="s1">| </span><span class="s3">&quot;measure&quot; </span><span class="s1">| </span><span class="s3">&quot;projectionUpdate&quot; </span><span class="s1">| </span><span class="s3">&quot;animationStart&quot; </span><span class="s1">| </span><span class="s3">&quot;animationComplete&quot;</span><span class="s1">;</span>
<span class="s2">interface </span><span class="s1">IProjectionNode&lt;I = unknown&gt; {</span>
    <span class="s1">id: number;</span>
    <span class="s1">animationId: number;</span>
    <span class="s1">animationCommitId: number;</span>
    <span class="s1">parent?: IProjectionNode;</span>
    <span class="s1">relativeParent?: IProjectionNode;</span>
    <span class="s1">root?: IProjectionNode;</span>
    <span class="s1">children: Set&lt;IProjectionNode&gt;;</span>
    <span class="s1">path: IProjectionNode[];</span>
    <span class="s1">nodes?: FlatTree;</span>
    <span class="s1">depth: number;</span>
    <span class="s1">instance: I | undefined;</span>
    <span class="s1">mount: (node: I, isLayoutDirty?: boolean) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">unmount: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">options: ProjectionNodeOptions;</span>
    <span class="s1">setOptions(options: ProjectionNodeOptions): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">layout?: Measurements;</span>
    <span class="s1">snapshot?: Measurements;</span>
    <span class="s1">target?: Box;</span>
    <span class="s1">relativeTarget?: Box;</span>
    <span class="s1">relativeTargetOrigin?: Box;</span>
    <span class="s1">targetDelta?: Delta;</span>
    <span class="s1">targetWithTransforms?: Box;</span>
    <span class="s1">scroll?: ScrollMeasurements;</span>
    <span class="s1">treeScale?: Point;</span>
    <span class="s1">projectionDelta?: Delta;</span>
    <span class="s1">projectionDeltaWithTransform?: Delta;</span>
    <span class="s1">latestValues: ResolvedValues;</span>
    <span class="s1">isLayoutDirty: boolean;</span>
    <span class="s1">isProjectionDirty: boolean;</span>
    <span class="s1">isSharedProjectionDirty: boolean;</span>
    <span class="s1">isTransformDirty: boolean;</span>
    <span class="s1">resolvedRelativeTargetAt?: number;</span>
    <span class="s1">shouldResetTransform: boolean;</span>
    <span class="s1">prevTransformTemplateValue: string | undefined;</span>
    <span class="s1">isUpdateBlocked(): boolean;</span>
    <span class="s1">updateManuallyBlocked: boolean;</span>
    <span class="s1">updateBlockedByResize: boolean;</span>
    <span class="s1">blockUpdate(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">unblockUpdate(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">isUpdating: boolean;</span>
    <span class="s1">needsReset: boolean;</span>
    <span class="s1">startUpdate(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">willUpdate(notifyListeners?: boolean): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">didUpdate(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">measure(removeTransform?: boolean): Measurements;</span>
    <span class="s1">measurePageBox(): Box;</span>
    <span class="s1">updateLayout(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">updateSnapshot(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">clearSnapshot(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">updateScroll(phase?: Phase): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">scheduleUpdateProjection(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">scheduleCheckAfterUnmount(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">checkUpdateFailed(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">sharedNodes: Map&lt;string, NodeStack&gt;;</span>
    <span class="s1">registerSharedNode(id: string, node: IProjectionNode): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">getStack(): NodeStack | undefined;</span>
    <span class="s1">isVisible: boolean;</span>
    <span class="s1">hide(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">show(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">scheduleRender(notifyAll?: boolean): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">getClosestProjectingParent(): IProjectionNode | undefined;</span>
    <span class="s1">setTargetDelta(delta: Delta): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">resetTransform(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">resetSkewAndRotation(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">applyTransform(box: Box, transformOnly?: boolean): Box;</span>
    <span class="s1">resolveTargetDelta(force?: boolean): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">calcProjection(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">applyProjectionStyles(targetStyle: CSSStyleDeclaration, styleProp?: MotionStyle): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">clearMeasurements(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">resetTree(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">isProjecting(): boolean;</span>
    <span class="s1">animationValues?: ResolvedValues;</span>
    <span class="s1">currentAnimation?: JSAnimation&lt;number&gt;;</span>
    <span class="s1">isTreeAnimating?: boolean;</span>
    <span class="s1">isAnimationBlocked?: boolean;</span>
    <span class="s1">isTreeAnimationBlocked: () =&gt; boolean;</span>
    <span class="s1">setAnimationOrigin(delta: Delta): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">startAnimation(transition: ValueTransition): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">finishAnimation(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">hasCheckedOptimisedAppear: boolean;</span>
    <span class="s1">isLead(): boolean;</span>
    <span class="s1">promote(options?: {</span>
        <span class="s1">needsReset?: boolean;</span>
        <span class="s1">transition?: Transition;</span>
        <span class="s1">preserveFollowOpacity?: boolean;</span>
    <span class="s1">}): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">relegate(): boolean;</span>
    <span class="s1">resumeFrom?: IProjectionNode;</span>
    <span class="s1">resumingFrom?: IProjectionNode;</span>
    <span class="s1">isPresent?: boolean;</span>
    <span class="s1">addEventListener(name: LayoutEvents, handler: any): VoidFunction;</span>
    <span class="s1">notifyListeners(name: LayoutEvents, ...args: any): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">hasListeners(name: LayoutEvents): boolean;</span>
    <span class="s1">hasTreeAnimated: boolean;</span>
    <span class="s1">preserveOpacity?: boolean;</span>
<span class="s1">}</span>
<span class="s2">interface </span><span class="s1">ProjectionNodeOptions {</span>
    <span class="s1">animate?: boolean;</span>
    <span class="s1">layoutScroll?: boolean;</span>
    <span class="s1">layoutRoot?: boolean;</span>
    <span class="s1">alwaysMeasureLayout?: boolean;</span>
    <span class="s1">onExitComplete?: VoidFunction;</span>
    <span class="s1">animationType?: </span><span class="s3">&quot;size&quot; </span><span class="s1">| </span><span class="s3">&quot;position&quot; </span><span class="s1">| </span><span class="s3">&quot;both&quot; </span><span class="s1">| </span><span class="s3">&quot;preserve-aspect&quot;</span><span class="s1">;</span>
    <span class="s1">layoutId?: string;</span>
    <span class="s1">layout?: boolean | string;</span>
    <span class="s1">visualElement?: VisualElement;</span>
    <span class="s1">crossfade?: boolean;</span>
    <span class="s1">transition?: Transition;</span>
    <span class="s1">initialPromotionConfig?: InitialPromotionConfig;</span>
<span class="s1">}</span>

<span class="s1">type AnimationType = </span><span class="s3">&quot;animate&quot; </span><span class="s1">| </span><span class="s3">&quot;whileHover&quot; </span><span class="s1">| </span><span class="s3">&quot;whileTap&quot; </span><span class="s1">| </span><span class="s3">&quot;whileDrag&quot; </span><span class="s1">| </span><span class="s3">&quot;whileFocus&quot; </span><span class="s1">| </span><span class="s3">&quot;whileInView&quot; </span><span class="s1">| </span><span class="s3">&quot;exit&quot;</span><span class="s1">;</span>

<span class="s1">type VisualElementAnimationOptions = {</span>
    <span class="s1">delay?: number;</span>
    <span class="s1">transitionOverride?: Transition;</span>
    <span class="s1">custom?: any;</span>
    <span class="s1">type?: AnimationType;</span>
<span class="s1">};</span>

<span class="s2">interface </span><span class="s1">AnimationState {</span>
    <span class="s1">animateChanges: (type?: AnimationType) =&gt; Promise&lt;any&gt;;</span>
    <span class="s1">setActive: (type: AnimationType, isActive: boolean, options?: VisualElementAnimationOptions) =&gt; Promise&lt;any&gt;;</span>
    <span class="s1">setAnimateFunction: (fn: any) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">getState: () =&gt; {</span>
        <span class="s1">[key: string]: AnimationTypeState;</span>
    <span class="s1">};</span>
    <span class="s1">reset: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">interface </span><span class="s1">AnimationTypeState {</span>
    <span class="s1">isActive: boolean;</span>
    <span class="s1">protectedKeys: {</span>
        <span class="s1">[key: string]: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s1">needsAnimating: {</span>
        <span class="s1">[key: string]: boolean;</span>
    <span class="s1">};</span>
    <span class="s1">prevResolvedValues: {</span>
        <span class="s1">[key: string]: any;</span>
    <span class="s1">};</span>
    <span class="s1">prevProp?: VariantLabels | TargetAndTransition;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* A VisualElement is an imperative abstraction around UI elements such as</span>
 <span class="s0">* HTMLElement, SVGElement, Three.Object3D etc.</span>
 <span class="s0">*/</span>
<span class="s1">declare abstract </span><span class="s2">class </span><span class="s1">VisualElement&lt;Instance = unknown, RenderState = unknown, Options </span><span class="s2">extends </span><span class="s1">{} = {}&gt; {</span>
    <span class="s0">/**</span>
     <span class="s0">* VisualElements are arranged in trees mirroring that of the React tree.</span>
     <span class="s0">* Each type of VisualElement has a unique name, to detect when we're crossing</span>
     <span class="s0">* type boundaries within that tree.</span>
     <span class="s0">*/</span>
    <span class="s1">abstract type: string;</span>
    <span class="s0">/**</span>
     <span class="s0">* An `Array.sort` compatible function that will compare two Instances and</span>
     <span class="s0">* compare their respective positions within the tree.</span>
     <span class="s0">*/</span>
    <span class="s1">abstract sortInstanceNodePosition(a: Instance, b: Instance): number;</span>
    <span class="s0">/**</span>
     <span class="s0">* Measure the viewport-relative bounding box of the Instance.</span>
     <span class="s0">*/</span>
    <span class="s1">abstract measureInstanceViewportBox(instance: Instance, props: MotionProps &amp; Partial&lt;MotionConfigContext&gt;): Box;</span>
    <span class="s0">/**</span>
     <span class="s0">* When a value has been removed from all animation props we need to</span>
     <span class="s0">* pick a target to animate back to. For instance, for HTMLElements</span>
     <span class="s0">* we can look in the style prop.</span>
     <span class="s0">*/</span>
    <span class="s1">abstract getBaseTargetFromProps(props: MotionProps, key: string): AnyResolvedKeyframe | undefined | MotionValue;</span>
    <span class="s0">/**</span>
     <span class="s0">* When we first animate to a value we need to animate it *from* a value.</span>
     <span class="s0">* Often this have been specified via the initial prop but it might be</span>
     <span class="s0">* that the value needs to be read from the Instance.</span>
     <span class="s0">*/</span>
    <span class="s1">abstract readValueFromInstance(instance: Instance, key: string, options: Options): AnyResolvedKeyframe | </span><span class="s2">null </span><span class="s1">| undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* When a value has been removed from the VisualElement we use this to remove</span>
     <span class="s0">* it from the inherting class' unique render state.</span>
     <span class="s0">*/</span>
    <span class="s1">abstract removeValueFromRenderState(key: string, renderState: RenderState): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Run before a React or VisualElement render, builds the latest motion</span>
     <span class="s0">* values into an Instance-specific format. For example, HTMLVisualElement</span>
     <span class="s0">* will use this step to build `style` and `var` values.</span>
     <span class="s0">*/</span>
    <span class="s1">abstract build(renderState: RenderState, latestValues: ResolvedValues, props: MotionProps): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Apply the built values to the Instance. For example, HTMLElements will have</span>
     <span class="s0">* styles applied via `setProperty` and the style attribute, whereas SVGElements</span>
     <span class="s0">* will have values applied to attributes.</span>
     <span class="s0">*/</span>
    <span class="s1">abstract renderInstance(instance: Instance, renderState: RenderState, styleProp?: MotionStyle, projection?: IProjectionNode): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This method is called when a transform property is bound to a motion value.</span>
     <span class="s0">* It's currently used to measure SVG elements when a new transform property is bound.</span>
     <span class="s0">*/</span>
    <span class="s1">onBindTransform?(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* If the component child is provided as a motion value, handle subscriptions</span>
     <span class="s0">* with the renderer-specific VisualElement.</span>
     <span class="s0">*/</span>
    <span class="s1">handleChildMotionValue?(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This method takes React props and returns found MotionValues. For example, HTML</span>
     <span class="s0">* MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.</span>
     <span class="s0">*</span>
     <span class="s0">* This isn't an abstract method as it needs calling in the constructor, but it is</span>
     <span class="s0">* intended to be one.</span>
     <span class="s0">*/</span>
    <span class="s1">scrapeMotionValuesFromProps(_props: MotionProps, _prevProps: MotionProps, _visualElement: VisualElement): {</span>
        <span class="s1">[key: string]: MotionValue | AnyResolvedKeyframe;</span>
    <span class="s1">};</span>
    <span class="s0">/**</span>
     <span class="s0">* A reference to the current underlying Instance, e.g. a HTMLElement</span>
     <span class="s0">* or Three.Mesh etc.</span>
     <span class="s0">*/</span>
    <span class="s1">current: Instance | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* A reference to the parent VisualElement (if exists).</span>
     <span class="s0">*/</span>
    <span class="s1">parent: VisualElement | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* A set containing references to this VisualElement's children.</span>
     <span class="s0">*/</span>
    <span class="s1">children: Set&lt;VisualElement&lt;unknown, unknown, {}&gt;&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* A set containing the latest children of this VisualElement. This is flushed</span>
     <span class="s0">* at the start of every commit. We use it to calculate the stagger delay</span>
     <span class="s0">* for newly-added children.</span>
     <span class="s0">*/</span>
    <span class="s1">enteringChildren?: Set&lt;VisualElement&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The depth of this VisualElement within the overall VisualElement tree.</span>
     <span class="s0">*/</span>
    <span class="s1">depth: number;</span>
    <span class="s0">/**</span>
     <span class="s0">* The current render state of this VisualElement. Defined by inherting VisualElements.</span>
     <span class="s0">*/</span>
    <span class="s1">renderState: RenderState;</span>
    <span class="s0">/**</span>
     <span class="s0">* An object containing the latest static values for each of this VisualElement's</span>
     <span class="s0">* MotionValues.</span>
     <span class="s0">*/</span>
    <span class="s1">latestValues: ResolvedValues;</span>
    <span class="s0">/**</span>
     <span class="s0">* Determine what role this visual element should take in the variant tree.</span>
     <span class="s0">*/</span>
    <span class="s1">isVariantNode: boolean;</span>
    <span class="s1">isControllingVariants: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* If this component is part of the variant tree, it should track</span>
     <span class="s0">* any children that are also part of the tree. This is essentially</span>
     <span class="s0">* a shadow tree to simplify logic around how to stagger over children.</span>
     <span class="s0">*/</span>
    <span class="s1">variantChildren?: Set&lt;VisualElement&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Decides whether this VisualElement should animate in reduced motion</span>
     <span class="s0">* mode.</span>
     <span class="s0">*</span>
     <span class="s0">* TODO: This is currently set on every individual VisualElement but feels</span>
     <span class="s0">* like it could be set globally.</span>
     <span class="s0">*/</span>
    <span class="s1">shouldReduceMotion: boolean | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Normally, if a component is controlled by a parent's variants, it can</span>
     <span class="s0">* rely on that ancestor to trigger animations further down the tree.</span>
     <span class="s0">* However, if a component is created after its parent is mounted, the parent</span>
     <span class="s0">* won't trigger that mount animation so the child needs to.</span>
     <span class="s0">*</span>
     <span class="s0">* TODO: This might be better replaced with a method isParentMounted</span>
     <span class="s0">*/</span>
    <span class="s1">manuallyAnimateOnMount: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* This can be set by AnimatePresence to force components that mount</span>
     <span class="s0">* at the same time as it to mount as if they have initial={false} set.</span>
     <span class="s0">*/</span>
    <span class="s1">blockInitialAnimation: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* A reference to this VisualElement's projection node, used in layout animations.</span>
     <span class="s0">*/</span>
    <span class="s1">projection?: IProjectionNode;</span>
    <span class="s0">/**</span>
     <span class="s0">* A map of all motion values attached to this visual element. Motion</span>
     <span class="s0">* values are source of truth for any given animated value. A motion</span>
     <span class="s0">* value might be provided externally by the component via props.</span>
     <span class="s0">*/</span>
    <span class="s1">values: Map&lt;string, MotionValue&lt;any&gt;&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The AnimationState, this is hydrated by the animation Feature.</span>
     <span class="s0">*/</span>
    <span class="s1">animationState?: AnimationState;</span>
    <span class="s1">KeyframeResolver: </span><span class="s2">typeof </span><span class="s1">KeyframeResolver;</span>
    <span class="s0">/**</span>
     <span class="s0">* The options used to create this VisualElement. The Options type is defined</span>
     <span class="s0">* by the inheriting VisualElement and is passed straight through to the render functions.</span>
     <span class="s0">*/</span>
    <span class="s1">readonly options: Options;</span>
    <span class="s0">/**</span>
     <span class="s0">* A reference to the latest props provided to the VisualElement's host React component.</span>
     <span class="s0">*/</span>
    <span class="s1">props: MotionProps;</span>
    <span class="s1">prevProps?: MotionProps;</span>
    <span class="s1">presenceContext: PresenceContextProps | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">prevPresenceContext?: PresenceContextProps | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Cleanup functions for active features (hover/tap/exit etc)</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">features;</span>
    <span class="s0">/**</span>
     <span class="s0">* A map of every subscription that binds the provided or generated</span>
     <span class="s0">* motion values onChange listeners to this visual element.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">valueSubscriptions;</span>
    <span class="s0">/**</span>
     <span class="s0">* A reference to the ReducedMotionConfig passed to the VisualElement's host React component.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">reducedMotionConfig;</span>
    <span class="s0">/**</span>
     <span class="s0">* On mount, this will be hydrated with a callback to disconnect</span>
     <span class="s0">* this visual element from its parent on unmount.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">removeFromVariantTree;</span>
    <span class="s0">/**</span>
     <span class="s0">* A reference to the previously-provided motion values as returned</span>
     <span class="s0">* from scrapeMotionValuesFromProps. We use the keys in here to determine</span>
     <span class="s0">* if any motion values need to be removed after props are updated.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">prevMotionValues;</span>
    <span class="s0">/**</span>
     <span class="s0">* When values are removed from all animation props we need to search</span>
     <span class="s0">* for a fallback value to animate to. These values are tracked in baseTarget.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">baseTarget;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create an object of the values we initially animated from (if initial prop present).</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">initialValues;</span>
    <span class="s0">/**</span>
     <span class="s0">* An object containing a SubscriptionManager for each active event.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">events;</span>
    <span class="s0">/**</span>
     <span class="s0">* An object containing an unsubscribe function for each prop event subscription.</span>
     <span class="s0">* For example, every &quot;Update&quot; event can have multiple subscribers via</span>
     <span class="s0">* VisualElement.on(), but only one of those can be defined via the onUpdate prop.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">propEventSubscriptions;</span>
    <span class="s1">constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }: VisualElementOptions&lt;Instance, RenderState&gt;, options?: Options);</span>
    <span class="s1">mount(instance: Instance): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">unmount(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">addChild(child: VisualElement): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">removeChild(child: VisualElement): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">private </span><span class="s1">bindToMotionValue;</span>
    <span class="s1">sortNodePosition(other: VisualElement&lt;Instance&gt;): number;</span>
    <span class="s1">updateFeatures(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">notifyUpdate: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">triggerBuild(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">render: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">private </span><span class="s1">renderScheduledAt;</span>
    <span class="s1">scheduleRender: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Measure the current viewport box with or without transforms.</span>
     <span class="s0">* Only measures axis-aligned boxes, rotate and skew must be manually</span>
     <span class="s0">* removed with a re-render to work.</span>
     <span class="s0">*/</span>
    <span class="s1">measureViewportBox(): Box;</span>
    <span class="s1">getStaticValue(key: string): AnyResolvedKeyframe;</span>
    <span class="s1">setStaticValue(key: string, value: AnyResolvedKeyframe): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Update the provided props. Ensure any newly-added motion values are</span>
     <span class="s0">* added to our map, old ones removed, and listeners updated.</span>
     <span class="s0">*/</span>
    <span class="s1">update(props: MotionProps, presenceContext: PresenceContextProps | </span><span class="s2">null</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">getProps(): MotionProps;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the variant definition with a given name.</span>
     <span class="s0">*/</span>
    <span class="s1">getVariant(name: string): motion_dom.Variant | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the defined default transition on this component.</span>
     <span class="s0">*/</span>
    <span class="s1">getDefaultTransition(): motion_dom.Transition&lt;any&gt; | undefined;</span>
    <span class="s1">getTransformPagePoint(): any;</span>
    <span class="s1">getClosestVariantNode(): VisualElement | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Add a child visual element to our set of children.</span>
     <span class="s0">*/</span>
    <span class="s1">addVariantChild(child: VisualElement): (() =&gt; boolean) | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Add a motion value and bind it to this visual element.</span>
     <span class="s0">*/</span>
    <span class="s1">addValue(key: string, value: MotionValue): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Remove a motion value and unbind any active subscriptions.</span>
     <span class="s0">*/</span>
    <span class="s1">removeValue(key: string): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Check whether we have a motion value for this key</span>
     <span class="s0">*/</span>
    <span class="s1">hasValue(key: string): boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Get a motion value for this key. If called with a default</span>
     <span class="s0">* value, we'll create one if none exists.</span>
     <span class="s0">*/</span>
    <span class="s1">getValue(key: string): MotionValue | undefined;</span>
    <span class="s1">getValue(key: string, defaultValue: AnyResolvedKeyframe | </span><span class="s2">null</span><span class="s1">): MotionValue;</span>
    <span class="s0">/**</span>
     <span class="s0">* If we're trying to animate to a previously unencountered value,</span>
     <span class="s0">* we need to check for it in our state and as a last resort read it</span>
     <span class="s0">* directly from the instance (which might have performance implications).</span>
     <span class="s0">*/</span>
    <span class="s1">readValue(key: string, target?: AnyResolvedKeyframe | </span><span class="s2">null</span><span class="s1">): any;</span>
    <span class="s0">/**</span>
     <span class="s0">* Set the base target to later animate back to. This is currently</span>
     <span class="s0">* only hydrated on creation and when we first read a value.</span>
     <span class="s0">*/</span>
    <span class="s1">setBaseTarget(key: string, value: AnyResolvedKeyframe): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Find the base target for a value thats been removed from all animation</span>
     <span class="s0">* props.</span>
     <span class="s0">*/</span>
    <span class="s1">getBaseTarget(key: string): ResolvedValues[string] | undefined | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">on&lt;EventName </span><span class="s2">extends </span><span class="s1">keyof VisualElementEventCallbacks&gt;(eventName: EventName, callback: VisualElementEventCallbacks[EventName]): VoidFunction;</span>
    <span class="s1">notify&lt;EventName </span><span class="s2">extends </span><span class="s1">keyof VisualElementEventCallbacks&gt;(eventName: EventName, ...args: any): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">scheduleRenderMicrotask(): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">type ScrapeMotionValuesFromProps = (props: MotionProps, prevProps: MotionProps, visualElement?: VisualElement) =&gt; {</span>
    <span class="s1">[key: string]: MotionValue | AnyResolvedKeyframe;</span>
<span class="s1">};</span>
<span class="s2">interface </span><span class="s1">VisualElementOptions&lt;Instance, RenderState = any&gt; {</span>
    <span class="s1">visualState: VisualState&lt;Instance, RenderState&gt;;</span>
    <span class="s1">parent?: VisualElement&lt;unknown&gt;;</span>
    <span class="s1">variantParent?: VisualElement&lt;unknown&gt;;</span>
    <span class="s1">presenceContext: PresenceContextProps | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">props: MotionProps;</span>
    <span class="s1">blockInitialAnimation?: boolean;</span>
    <span class="s1">reducedMotionConfig?: ReducedMotionConfig;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* A generic set of string/number values</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">ResolvedValues {</span>
    <span class="s1">[key: string]: AnyResolvedKeyframe;</span>
<span class="s1">}</span>
<span class="s2">interface </span><span class="s1">VisualElementEventCallbacks {</span>
    <span class="s1">BeforeLayoutMeasure: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">LayoutMeasure: (layout: Box, prevLayout?: Box) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">LayoutUpdate: (layout: Axis, prevLayout: Axis) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">Update: (latest: ResolvedValues) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">AnimationStart: (definition: AnimationDefinition) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">AnimationComplete: (definition: AnimationDefinition) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">LayoutAnimationStart: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">LayoutAnimationComplete: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">SetAxisTarget: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">Unmount: () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">type CreateVisualElement&lt;Props = {}, TagName </span><span class="s2">extends </span><span class="s1">keyof DOMMotionComponents | string = </span><span class="s3">&quot;div&quot;</span><span class="s1">&gt; = (Component: TagName | string | React.ComponentType&lt;Props&gt;, options: VisualElementOptions&lt;HTMLElement | SVGElement&gt;) =&gt; VisualElement&lt;HTMLElement | SVGElement&gt;;</span>

<span class="s1">declare </span><span class="s2">const </span><span class="s1">optimizedAppearDataAttribute: </span><span class="s3">&quot;data-framer-appear-id&quot;</span><span class="s1">;</span>

<span class="s0">/**</span>
 <span class="s0">* Expose only the needed part of the VisualElement interface to</span>
 <span class="s0">* ensure React types don't end up in the generic DOM bundle.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">WithAppearProps {</span>
    <span class="s1">props: {</span>
        <span class="s1">[optimizedAppearDataAttribute]?: string;</span>
        <span class="s1">values?: {</span>
            <span class="s1">[key: string]: MotionValue&lt;number&gt; | MotionValue&lt;string&gt;;</span>
        <span class="s1">};</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">type HandoffFunction = (storeId: string, valueName: string, frame: Batcher) =&gt; number | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s0">/**</span>
 <span class="s0">* The window global object acts as a bridge between our inline script</span>
 <span class="s0">* triggering the optimized appear animations, and Motion.</span>
 <span class="s0">*/</span>
<span class="s1">declare global {</span>
    <span class="s2">interface </span><span class="s1">Window {</span>
        <span class="s1">MotionHandoffAnimation?: HandoffFunction;</span>
        <span class="s1">MotionHandoffMarkAsComplete?: (elementId: string) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">MotionHandoffIsComplete?: (elementId: string) =&gt; boolean;</span>
        <span class="s1">MotionHasOptimisedAnimation?: (elementId?: string, valueName?: string) =&gt; boolean;</span>
        <span class="s1">MotionCancelOptimisedAnimation?: (elementId?: string, valueName?: string, frame?: Batcher, canResume?: boolean) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">MotionCheckAppearSync?: (visualElement: WithAppearProps, valueName: string, value: MotionValue) =&gt; VoidFunction | </span><span class="s2">void</span><span class="s1">;</span>
        <span class="s1">MotionIsMounted?: boolean;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s1">{ type AnimationType as A, type CreateVisualElement as C, type DOMMotionComponents as D, type ForwardRefComponent as F, type HTMLElements as H, type IProjectionNode as I, type MotionProps as M, PresenceContext as P, type ResolvedValues as R, type SVGMotionComponents as S, VisualElement as V, MotionConfigContext as a, type HTMLMotionProps as b, type HTMLMotionComponents as c, type VisualElementAnimationOptions as d, type HTMLRenderState as e, type ScrapeMotionValuesFromProps as f, type VisualState as g, SwitchLayoutGroupContext as h, type MotionStyle as i, type MotionTransform as j, type VariantLabels as k, type SVGAttributesAsMotionValues as l, makeUseVisualState as m, type SVGMotionProps as n, optimizedAppearDataAttribute as o, FlatTree as p };</span>
</pre>
</body>
</html>