<html>
<head>
<title>search-params.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
search-params.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">createPrerenderSearchParamsForClientPage: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createSearchParamsFromClient: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createServerSearchParamsForMetadata: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createServerSearchParamsForServerPage: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">makeErroringSearchParamsForUseCache: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">createPrerenderSearchParamsForClientPage: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createPrerenderSearchParamsForClientPage;</span>
    <span class="s1">},</span>
    <span class="s1">createSearchParamsFromClient: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createSearchParamsFromClient;</span>
    <span class="s1">},</span>
    <span class="s1">createServerSearchParamsForMetadata: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createServerSearchParamsForMetadata;</span>
    <span class="s1">},</span>
    <span class="s1">createServerSearchParamsForServerPage: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createServerSearchParamsForServerPage;</span>
    <span class="s1">},</span>
    <span class="s1">makeErroringSearchParamsForUseCache: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">makeErroringSearchParamsForUseCache;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_reflect = require(</span><span class="s0">&quot;../web/spec-extension/adapters/reflect&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrendering = require(</span><span class="s0">&quot;../app-render/dynamic-rendering&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_invarianterror = require(</span><span class="s0">&quot;../../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrenderingutils = require(</span><span class="s0">&quot;../dynamic-rendering-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_creatededupedbycallsiteservererrorlogger = require(</span><span class="s0">&quot;../create-deduped-by-callsite-server-error-logger&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_reflectutils = require(</span><span class="s0">&quot;../../shared/lib/utils/reflect-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;./utils&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">createSearchParamsFromClient(underlyingSearchParams, workStore) {</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createStaticPrerenderSearchParams(workStore, workUnitStore);</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createSearchParamsFromClient should not be called in a runtime prerender.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E769&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createSearchParamsFromClient should not be called in cache contexts.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E739&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createRenderSearchParams(underlyingSearchParams, workStore);</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;</span>
<span class="s2">function </span><span class="s1">createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createStaticPrerenderSearchParams(workStore, workUnitStore);</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createServerSearchParamsForServerPage should not be called in cache contexts.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E747&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore);</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createRenderSearchParams(underlyingSearchParams, workStore);</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPrerenderSearchParamsForClientPage(workStore) {</span>
    <span class="s2">if </span><span class="s1">(workStore.forceStatic) {</span>
        <span class="s4">// When using forceStatic we override all other logic and always just return an empty</span>
        <span class="s4">// dictionary object.</span>
        <span class="s2">return </span><span class="s1">Promise.resolve({});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                <span class="s4">// We're prerendering in a mode that aborts (cacheComponents) and should stall</span>
                <span class="s4">// the promise to ensure the RSC side is considered dynamic</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'`searchParams`'</span><span class="s1">);</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E768&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createPrerenderSearchParamsForClientPage should not be called in cache contexts.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E746&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">Promise.resolve({});</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createStaticPrerenderSearchParams(workStore, prerenderStore) {</span>
    <span class="s2">if </span><span class="s1">(workStore.forceStatic) {</span>
        <span class="s4">// When using forceStatic we override all other logic and always just return an empty</span>
        <span class="s4">// dictionary object.</span>
        <span class="s2">return </span><span class="s1">Promise.resolve({});</span>
    <span class="s1">}</span>
    <span class="s2">switch</span><span class="s1">(prerenderStore.type){</span>
        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s4">// We are in a cacheComponents (PPR or otherwise) prerender</span>
            <span class="s2">return </span><span class="s1">makeHangingSearchParams(workStore, prerenderStore);</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s4">// We are in a legacy static generation and need to interrupt the</span>
            <span class="s4">// prerender when search params are accessed.</span>
            <span class="s2">return </span><span class="s1">makeErroringExoticSearchParams(workStore, prerenderStore);</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">prerenderStore;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.delayUntilRuntimeStage)(workUnitStore, process.env.__NEXT_CACHE_COMPONENTS ? makeUntrackedSearchParams(underlyingSearchParams) : makeUntrackedExoticSearchParams(underlyingSearchParams));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRenderSearchParams(underlyingSearchParams, workStore) {</span>
    <span class="s2">if </span><span class="s1">(workStore.forceStatic) {</span>
        <span class="s4">// When using forceStatic we override all other logic and always just return an empty</span>
        <span class="s4">// dictionary object.</span>
        <span class="s2">return </span><span class="s1">Promise.resolve({});</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
            <span class="s4">// Semantically we only need the dev tracking when running in `next dev`</span>
            <span class="s4">// but since you would never use next dev with production NODE_ENV we use this</span>
            <span class="s4">// as a proxy so we can statically exclude this code from production builds.</span>
            <span class="s2">if </span><span class="s1">(process.env.__NEXT_CACHE_COMPONENTS) {</span>
                <span class="s2">return </span><span class="s1">makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, workStore);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(process.env.__NEXT_CACHE_COMPONENTS) {</span>
                <span class="s2">return </span><span class="s1">makeUntrackedSearchParams(underlyingSearchParams);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">makeUntrackedExoticSearchParams(underlyingSearchParams);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">CachedSearchParams = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s2">const </span><span class="s1">CachedSearchParamsForUseCache = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s2">function </span><span class="s1">makeHangingSearchParams(workStore, prerenderStore) {</span>
    <span class="s2">const </span><span class="s1">cachedSearchParams = CachedSearchParams.get(prerenderStore);</span>
    <span class="s2">if </span><span class="s1">(cachedSearchParams) {</span>
        <span class="s2">return </span><span class="s1">cachedSearchParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">promise = (</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, </span><span class="s0">'`searchParams`'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">proxiedPromise = </span><span class="s2">new </span><span class="s1">Proxy(promise, {</span>
        <span class="s1">get (target, prop, receiver) {</span>
            <span class="s2">if </span><span class="s1">(Object.hasOwn(promise, prop)) {</span>
                <span class="s4">// The promise has this property directly. we must return it.</span>
                <span class="s4">// We know it isn't a dynamic access because it can only be something</span>
                <span class="s4">// that was previously written to the promise and thus not an underlying searchParam value</span>
                <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
            <span class="s1">}</span>
            <span class="s2">switch</span><span class="s1">(prop){</span>
                <span class="s2">case </span><span class="s0">'then'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`await searchParams`, `searchParams.then`, or similar'</span><span class="s1">;</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);</span>
                        <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
                    <span class="s1">}</span>
                <span class="s2">case </span><span class="s0">'status'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`use(searchParams)`, `searchParams.status`, or similar'</span><span class="s1">;</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);</span>
                        <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
                    <span class="s1">}</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
                    <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">CachedSearchParams.set(prerenderStore, proxiedPromise);</span>
    <span class="s2">return </span><span class="s1">proxiedPromise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeErroringExoticSearchParams(workStore, prerenderStore) {</span>
    <span class="s2">const </span><span class="s1">cachedSearchParams = CachedSearchParams.get(workStore);</span>
    <span class="s2">if </span><span class="s1">(cachedSearchParams) {</span>
        <span class="s2">return </span><span class="s1">cachedSearchParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">underlyingSearchParams = {};</span>
    <span class="s4">// For search params we don't construct a ReactPromise because we want to interrupt</span>
    <span class="s4">// rendering on any property access that was not set from outside and so we only want</span>
    <span class="s4">// to have properties like value and status if React sets them.</span>
    <span class="s2">const </span><span class="s1">promise = Promise.resolve(underlyingSearchParams);</span>
    <span class="s2">const </span><span class="s1">proxiedPromise = </span><span class="s2">new </span><span class="s1">Proxy(promise, {</span>
        <span class="s1">get (target, prop, receiver) {</span>
            <span class="s2">if </span><span class="s1">(Object.hasOwn(promise, prop)) {</span>
                <span class="s4">// The promise has this property directly. we must return it.</span>
                <span class="s4">// We know it isn't a dynamic access because it can only be something</span>
                <span class="s4">// that was previously written to the promise and thus not an underlying searchParam value</span>
                <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
            <span class="s1">}</span>
            <span class="s2">switch</span><span class="s1">(prop){</span>
                <span class="s2">case </span><span class="s0">'then'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`await searchParams`, `searchParams.then`, or similar'</span><span class="s1">;</span>
                        <span class="s2">if </span><span class="s1">(workStore.dynamicShouldError) {</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
                        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prerenderStore.type === </span><span class="s0">'prerender-ppr'</span><span class="s1">) {</span>
                            <span class="s4">// PPR Prerender (no cacheComponents)</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s4">// Legacy Prerender</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                        <span class="s1">}</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s2">case </span><span class="s0">'status'</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`use(searchParams)`, `searchParams.status`, or similar'</span><span class="s1">;</span>
                        <span class="s2">if </span><span class="s1">(workStore.dynamicShouldError) {</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
                        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prerenderStore.type === </span><span class="s0">'prerender-ppr'</span><span class="s1">) {</span>
                            <span class="s4">// PPR Prerender (no cacheComponents)</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s4">// Legacy Prerender</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                        <span class="s1">}</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s1">{</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; !_reflectutils.wellKnownProperties.has(prop)) {</span>
                            <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(</span><span class="s0">'searchParams'</span><span class="s1">, prop);</span>
                            <span class="s2">if </span><span class="s1">(workStore.dynamicShouldError) {</span>
                                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
                            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prerenderStore.type === </span><span class="s0">'prerender-ppr'</span><span class="s1">) {</span>
                                <span class="s4">// PPR Prerender (no cacheComponents)</span>
                                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                <span class="s4">// Legacy Prerender</span>
                                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
                    <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">has (target, prop) {</span>
            <span class="s4">// We don't expect key checking to be used except for testing the existence of</span>
            <span class="s4">// searchParams so we make all has tests trigger dynamic. this means that `promise.then`</span>
            <span class="s4">// can resolve to the then function on the Promise prototype but 'then' in promise will assume</span>
            <span class="s4">// you are testing whether the searchParams has a 'then' property.</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s0">'searchParams'</span><span class="s1">, prop);</span>
                <span class="s2">if </span><span class="s1">(workStore.dynamicShouldError) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prerenderStore.type === </span><span class="s0">'prerender-ppr'</span><span class="s1">) {</span>
                    <span class="s4">// PPR Prerender (no cacheComponents)</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// Legacy Prerender</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                <span class="s1">}</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.has(target, prop);</span>
        <span class="s1">},</span>
        <span class="s1">ownKeys () {</span>
            <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`{...searchParams}`, `Object.keys(searchParams)`, or similar'</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(workStore.dynamicShouldError) {</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prerenderStore.type === </span><span class="s0">'prerender-ppr'</span><span class="s1">) {</span>
                <span class="s4">// PPR Prerender (no cacheComponents)</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// Legacy Prerender</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">CachedSearchParams.set(workStore, proxiedPromise);</span>
    <span class="s2">return </span><span class="s1">proxiedPromise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeErroringSearchParamsForUseCache(workStore) {</span>
    <span class="s2">const </span><span class="s1">cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);</span>
    <span class="s2">if </span><span class="s1">(cachedSearchParams) {</span>
        <span class="s2">return </span><span class="s1">cachedSearchParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">promise = Promise.resolve({});</span>
    <span class="s2">const </span><span class="s1">proxiedPromise = </span><span class="s2">new </span><span class="s1">Proxy(promise, {</span>
        <span class="s1">get: </span><span class="s2">function </span><span class="s1">get(target, prop, receiver) {</span>
            <span class="s2">if </span><span class="s1">(Object.hasOwn(promise, prop)) {</span>
                <span class="s4">// The promise has this property directly. we must return it. We know it</span>
                <span class="s4">// isn't a dynamic access because it can only be something that was</span>
                <span class="s4">// previously written to the promise and thus not an underlying</span>
                <span class="s4">// searchParam value</span>
                <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; (prop === </span><span class="s0">'then' </span><span class="s1">|| !_reflectutils.wellKnownProperties.has(prop))) {</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwForSearchParamsAccessInUseCache)(workStore, get);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">has: </span><span class="s2">function </span><span class="s1">has(target, prop) {</span>
            <span class="s4">// We don't expect key checking to be used except for testing the existence of</span>
            <span class="s4">// searchParams so we make all has tests throw an error. this means that `promise.then`</span>
            <span class="s4">// can resolve to the then function on the Promise prototype but 'then' in promise will assume</span>
            <span class="s4">// you are testing whether the searchParams has a 'then' property.</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; (prop === </span><span class="s0">'then' </span><span class="s1">|| !_reflectutils.wellKnownProperties.has(prop))) {</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwForSearchParamsAccessInUseCache)(workStore, has);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.has(target, prop);</span>
        <span class="s1">},</span>
        <span class="s1">ownKeys: </span><span class="s2">function </span><span class="s1">ownKeys() {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwForSearchParamsAccessInUseCache)(workStore, ownKeys);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">CachedSearchParamsForUseCache.set(workStore, proxiedPromise);</span>
    <span class="s2">return </span><span class="s1">proxiedPromise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeUntrackedExoticSearchParams(underlyingSearchParams) {</span>
    <span class="s2">const </span><span class="s1">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s2">if </span><span class="s1">(cachedSearchParams) {</span>
        <span class="s2">return </span><span class="s1">cachedSearchParams;</span>
    <span class="s1">}</span>
    <span class="s4">// We don't use makeResolvedReactPromise here because searchParams</span>
    <span class="s4">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s4">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s2">const </span><span class="s1">promise = Promise.resolve(underlyingSearchParams);</span>
    <span class="s1">CachedSearchParams.set(underlyingSearchParams, promise);</span>
    <span class="s1">Object.keys(underlyingSearchParams).forEach((prop)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(!_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s1">Object.defineProperty(promise, prop, {</span>
                <span class="s1">get () {</span>
                    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
                    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.trackDynamicDataInDynamicRender)(workUnitStore);</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">underlyingSearchParams[prop];</span>
                <span class="s1">},</span>
                <span class="s1">set (value) {</span>
                    <span class="s1">Object.defineProperty(promise, prop, {</span>
                        <span class="s1">value,</span>
                        <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">},</span>
                <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">promise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeUntrackedSearchParams(underlyingSearchParams) {</span>
    <span class="s2">const </span><span class="s1">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s2">if </span><span class="s1">(cachedSearchParams) {</span>
        <span class="s2">return </span><span class="s1">cachedSearchParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">promise = Promise.resolve(underlyingSearchParams);</span>
    <span class="s1">CachedSearchParams.set(underlyingSearchParams, promise);</span>
    <span class="s2">return </span><span class="s1">promise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {</span>
    <span class="s2">const </span><span class="s1">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s2">if </span><span class="s1">(cachedSearchParams) {</span>
        <span class="s2">return </span><span class="s1">cachedSearchParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">proxiedProperties = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">const </span><span class="s1">unproxiedProperties = [];</span>
    <span class="s4">// We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying</span>
    <span class="s4">// searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender</span>
    <span class="s4">// indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking</span>
    <span class="s4">// at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger</span>
    <span class="s4">// dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce</span>
    <span class="s4">// this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.</span>
    <span class="s2">let </span><span class="s1">promiseInitialized = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">proxiedUnderlying = </span><span class="s2">new </span><span class="s1">Proxy(underlyingSearchParams, {</span>
        <span class="s1">get (target, prop, receiver) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; promiseInitialized) {</span>
                <span class="s2">if </span><span class="s1">(store.dynamicShouldError) {</span>
                    <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(</span><span class="s0">'searchParams'</span><span class="s1">, prop);</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
                <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.trackDynamicDataInDynamicRender)(workUnitStore);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">has (target, prop) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(store.dynamicShouldError) {</span>
                    <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s0">'searchParams'</span><span class="s1">, prop);</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Reflect.has(target, prop);</span>
        <span class="s1">},</span>
        <span class="s1">ownKeys (target) {</span>
            <span class="s2">if </span><span class="s1">(store.dynamicShouldError) {</span>
                <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`{...searchParams}`, `Object.keys(searchParams)`, or similar'</span><span class="s1">;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Reflect.ownKeys(target);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s4">// We don't use makeResolvedReactPromise here because searchParams</span>
    <span class="s4">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s4">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s2">const </span><span class="s1">promise = (</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingSearchParams);</span>
    <span class="s1">promise.then(()=&gt;{</span>
        <span class="s1">promiseInitialized = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s1">Object.keys(underlyingSearchParams).forEach((prop)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s4">// These properties cannot be shadowed because they need to be the</span>
            <span class="s4">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s1">unproxiedProperties.push(prop);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">proxiedProperties.add(prop);</span>
            <span class="s1">Object.defineProperty(promise, prop, {</span>
                <span class="s1">get () {</span>
                    <span class="s2">return </span><span class="s1">proxiedUnderlying[prop];</span>
                <span class="s1">},</span>
                <span class="s1">set (newValue) {</span>
                    <span class="s1">Object.defineProperty(promise, prop, {</span>
                        <span class="s1">value: newValue,</span>
                        <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">},</span>
                <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">proxiedPromise = </span><span class="s2">new </span><span class="s1">Proxy(promise, {</span>
        <span class="s1">get (target, prop, receiver) {</span>
            <span class="s2">if </span><span class="s1">(prop === </span><span class="s0">'then' </span><span class="s1">&amp;&amp; store.dynamicShouldError) {</span>
                <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`searchParams.then`'</span><span class="s1">;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s4">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s4">// the underlying searchParams.</span>
                <span class="s1">Reflect.has(target, prop) === </span><span class="s2">false</span><span class="s1">)) {</span>
                    <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(</span><span class="s0">'searchParams'</span><span class="s1">, prop);</span>
                    <span class="s1">syncIODev(store.route, expression);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">set (target, prop, value, receiver) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s1">proxiedProperties.delete(prop);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Reflect.set(target, prop, value, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">has (target, prop) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s4">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s4">// the underlying searchParams.</span>
                <span class="s1">Reflect.has(target, prop) === </span><span class="s2">false</span><span class="s1">)) {</span>
                    <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s0">'searchParams'</span><span class="s1">, prop);</span>
                    <span class="s1">syncIODev(store.route, expression);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Reflect.has(target, prop);</span>
        <span class="s1">},</span>
        <span class="s1">ownKeys (target) {</span>
            <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`Object.keys(searchParams)` or similar'</span><span class="s1">;</span>
            <span class="s1">syncIODev(store.route, expression, unproxiedProperties);</span>
            <span class="s2">return </span><span class="s1">Reflect.ownKeys(target);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">CachedSearchParams.set(underlyingSearchParams, proxiedPromise);</span>
    <span class="s2">return </span><span class="s1">proxiedPromise;</span>
<span class="s1">}</span>
<span class="s4">// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but</span>
<span class="s4">// just logging the sync access without actually defining the search params on</span>
<span class="s4">// the promise.</span>
<span class="s2">function </span><span class="s1">makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, store) {</span>
    <span class="s2">const </span><span class="s1">cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);</span>
    <span class="s2">if </span><span class="s1">(cachedSearchParams) {</span>
        <span class="s2">return </span><span class="s1">cachedSearchParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">proxiedProperties = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">const </span><span class="s1">unproxiedProperties = [];</span>
    <span class="s2">const </span><span class="s1">promise = (</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingSearchParams);</span>
    <span class="s1">Object.keys(underlyingSearchParams).forEach((prop)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s4">// These properties cannot be shadowed because they need to be the</span>
            <span class="s4">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s1">unproxiedProperties.push(prop);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">proxiedProperties.add(prop);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">proxiedPromise = </span><span class="s2">new </span><span class="s1">Proxy(promise, {</span>
        <span class="s1">get (target, prop, receiver) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s4">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s4">// the underlying searchParams.</span>
                <span class="s1">Reflect.has(target, prop) === </span><span class="s2">false</span><span class="s1">)) {</span>
                    <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(</span><span class="s0">'searchParams'</span><span class="s1">, prop);</span>
                    <span class="s1">warnForSyncAccess(store.route, expression);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">set (target, prop, value, receiver) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s1">proxiedProperties.delete(prop);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Reflect.set(target, prop, value, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">has (target, prop) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!_reflectutils.wellKnownProperties.has(prop) &amp;&amp; (proxiedProperties.has(prop) || </span><span class="s4">// We are accessing a property that doesn't exist on the promise nor</span>
                <span class="s4">// the underlying searchParams.</span>
                <span class="s1">Reflect.has(target, prop) === </span><span class="s2">false</span><span class="s1">)) {</span>
                    <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeHasCheckingStringProperty)(</span><span class="s0">'searchParams'</span><span class="s1">, prop);</span>
                    <span class="s1">warnForSyncAccess(store.route, expression);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Reflect.has(target, prop);</span>
        <span class="s1">},</span>
        <span class="s1">ownKeys (target) {</span>
            <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`Object.keys(searchParams)` or similar'</span><span class="s1">;</span>
            <span class="s1">warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);</span>
            <span class="s2">return </span><span class="s1">Reflect.ownKeys(target);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">CachedSearchParams.set(underlyingSearchParams, proxiedPromise);</span>
    <span class="s2">return </span><span class="s1">proxiedPromise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">syncIODev(route, expression, missingProperties) {</span>
    <span class="s4">// In all cases we warn normally</span>
    <span class="s2">if </span><span class="s1">(missingProperties &amp;&amp; missingProperties.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s1">warnForIncompleteEnumeration(route, expression, missingProperties);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">warnForSyncAccess(route, expression);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(workUnitStore.prerenderPhase === </span><span class="s2">true</span><span class="s1">) {</span>
                    <span class="s4">// When we're rendering dynamically in dev, we need to advance out of</span>
                    <span class="s4">// the Prerender environment when we read Request data synchronously.</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(workUnitStore);</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">warnForSyncAccess = (</span><span class="s3">0</span><span class="s1">, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createSearchAccessError);</span>
<span class="s2">const </span><span class="s1">warnForIncompleteEnumeration = (</span><span class="s3">0</span><span class="s1">, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);</span>
<span class="s2">function </span><span class="s1">createSearchAccessError(route, expression) {</span>
    <span class="s2">const </span><span class="s1">prefix = route ? </span><span class="s0">`Route &quot;</span><span class="s1">${route}</span><span class="s0">&quot; ` </span><span class="s1">: </span><span class="s0">'This route '</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">used </span><span class="s1">${expression}</span><span class="s0">. ` </span><span class="s1">+ </span><span class="s0">`</span><span class="s5">\`</span><span class="s0">searchParams</span><span class="s5">\` </span><span class="s0">should be awaited before using its properties. ` </span><span class="s1">+ </span><span class="s0">`Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s0">&quot;E249&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createIncompleteEnumerationError(route, expression, missingProperties) {</span>
    <span class="s2">const </span><span class="s1">prefix = route ? </span><span class="s0">`Route &quot;</span><span class="s1">${route}</span><span class="s0">&quot; ` </span><span class="s1">: </span><span class="s0">'This route '</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">used </span><span class="s1">${expression}</span><span class="s0">. ` </span><span class="s1">+ </span><span class="s0">`</span><span class="s5">\`</span><span class="s0">searchParams</span><span class="s5">\` </span><span class="s0">should be awaited before using its properties. ` </span><span class="s1">+ </span><span class="s0">`The following properties were not available through enumeration ` </span><span class="s1">+ </span><span class="s0">`because they conflict with builtin or well-known property names: ` </span><span class="s1">+ </span><span class="s0">`</span><span class="s1">${describeListOfPropertyNames(missingProperties)}</span><span class="s0">. ` </span><span class="s1">+ </span><span class="s0">`Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s0">&quot;E2&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">describeListOfPropertyNames(properties) {</span>
    <span class="s2">switch</span><span class="s1">(properties.length){</span>
        <span class="s2">case </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E531&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s2">case </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s0">`</span><span class="s5">\`</span><span class="s1">${properties[</span><span class="s3">0</span><span class="s1">]}</span><span class="s5">\`</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s0">`</span><span class="s5">\`</span><span class="s1">${properties[</span><span class="s3">0</span><span class="s1">]}</span><span class="s5">\` </span><span class="s0">and </span><span class="s5">\`</span><span class="s1">${properties[</span><span class="s3">1</span><span class="s1">]}</span><span class="s5">\`</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">let </span><span class="s1">description = </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; properties.length - </span><span class="s3">1</span><span class="s1">; i++){</span>
                    <span class="s1">description += </span><span class="s0">`</span><span class="s5">\`</span><span class="s1">${properties[i]}</span><span class="s5">\`</span><span class="s0">, `</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">description += </span><span class="s0">`, and </span><span class="s5">\`</span><span class="s1">${properties[properties.length - </span><span class="s3">1</span><span class="s1">]}</span><span class="s5">\`</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s2">return </span><span class="s1">description;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=search-params.js.map</span></pre>
</body>
</html>